,task_url,task_name,task_description,language_url,language_name,code,code_length,line_count
54,http://rosettacode.org/wiki/Array_concatenation,Array concatenation,"Task

Show how to concatenate two arrays in your language.



If this is as simple as array1 + array2, so be it.



",#C.23,C#,"using System;
 
namespace RosettaCode
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] a = { 1, 2, 3 };
            int[] b = { 4, 5, 6 };
 
            int[] c = new int[a.Length + b.Length];
            a.CopyTo(c, 0);
            b.CopyTo(c, a.Length);
 
            foreach(int n in c)
            {
                Console.WriteLine(n.ToString());
            }
        }
    }
}",429,22
279,http://rosettacode.org/wiki/Array_length,Array length,"Task

Determine the amount of elements in an array.



As an example use an array holding the strings 'apple' and 'orange'.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#," 
using System;
 
class Program
{
    public static void Main()
    {
        var fruit = new[] { ""apple"", ""orange"" };
        Console.WriteLine(fruit.Length);
    }
}
 ",169,12
408,http://rosettacode.org/wiki/Arithmetic/Integer,Arithmetic/Integer,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Get two integers from the user,   and then (for those two integers), display their:

   sum 
   difference 
   product 
   integer quotient
   remainder 
   exponentiation   (if the operator exists) 


Don't include error handling.

For quotient, indicate how it rounds   (e.g. towards zero, towards negative infinity, etc.).

For remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.



",#C.23,C#,"using System;
 
class Program
{
    static void Main(string[] args)
    {
        int a = Convert.ToInt32(args[0]);
        int b = Convert.ToInt32(args[1]);
 
        Console.WriteLine(""{0} + {1} = {2}"", a, b, a + b);
        Console.WriteLine(""{0} - {1} = {2}"", a, b, a - b);
        Console.WriteLine(""{0} * {1} = {2}"", a, b, a * b);
        Console.WriteLine(""{0} / {1} = {2}"", a, b, a / b); // truncates towards 0
        Console.WriteLine(""{0} % {1} = {2}"", a, b, a % b); // matches sign of first operand
        Console.WriteLine(""{0} to the power of {1} = {2}"", a, b, Math.Pow(a, b));
    }
}",600,17
630,http://rosettacode.org/wiki/Arithmetic-geometric_mean/Calculate_Pi,Arithmetic-geometric mean/Calculate Pi,"Almkvist Berndt 1988 begins with an investigation of why the agm is such an efficient algorithm, and proves that it converges quadratically. This is an efficient method to calculate 



π


{\displaystyle \pi }

.

With the same notations used in Arithmetic-geometric mean, we can summarize the paper by writing:





π
=



4


a
g
m

(
1
,
1

/



2



)

2




1
−

∑

n
=
1


∞



2

n
+
1


(

a

n


2


−

g

n


2


)





{\displaystyle \pi ={\frac {4\;\mathrm {agm} (1,1/{\sqrt {2}})^{2}}{1-\sum \limits _{n=1}^{\infty }2^{n+1}(a_{n}^{2}-g_{n}^{2})}}}



This allows you to make the approximation, for any large   N:





π
≈



4


a

N


2




1
−

∑

k
=
1


N



2

k
+
1


(

a

k


2


−

g

k


2


)





{\displaystyle \pi \approx {\frac {4\;a_{N}^{2}}{1-\sum \limits _{k=1}^{N}2^{k+1}(a_{k}^{2}-g_{k}^{2})}}}



The purpose of this task is to demonstrate how to use this approximation in order to compute a large number of decimals of 



π


{\displaystyle \pi }

.
",#C.23,C#,"using System;
using System.Numerics;
 
class AgmPie
{
    static BigInteger IntSqRoot(BigInteger valu, BigInteger guess)
    {
        BigInteger term; do {
            term = valu / guess; if (BigInteger.Abs(term - guess) <= 1) break;
            guess += term; guess >>= 1;
        } while (true); return guess;
    }
 
    static BigInteger ISR(BigInteger term, BigInteger guess)
    {
        BigInteger valu = term * guess; do {
            if (BigInteger.Abs(term - guess) <= 1) break;
            guess += term; guess >>= 1; term = valu / guess;
        } while (true); return guess;
    }
 
    static BigInteger CalcAGM(BigInteger lam, BigInteger gm, ref BigInteger z,
                              BigInteger ep)
    {
        BigInteger am, zi; ulong n = 1; do {
            am = (lam + gm) >> 1; gm = ISR(lam, gm);
            BigInteger v = am - lam; if ((zi = v * v * n) < ep) break;
            z -= zi; n <<= 1; lam = am;
        } while (true); return am;
    }
 
    static BigInteger BIP(int exp, ulong man = 1) 
    {
        BigInteger rv = BigInteger.Pow(10, exp); return man == 1 ? rv : man * rv;
    }
 
    static void Main(string[] args)
    {
        int d = 25000;
        if (args.Length > 0)
        {
            int.TryParse(args[0], out d);
            if (d < 1 || d > 999999) d = 25000;
        }
        DateTime st = DateTime.Now;
        BigInteger am = BIP(d),
          gm = IntSqRoot(BIP(d + d - 1, 5),
                             BIP(d - 15, (ulong)(Math.Sqrt(0.5) * 1e+15))),
          z = BIP(d + d - 2, 25),
          agm = CalcAGM(am, gm, ref z, BIP(d + 1)),
          pi = agm * agm * BIP(d - 2) / z;
        Console.WriteLine(""Computation time: {0:0.0000} seconds "",
                             (DateTime.Now - st).TotalMilliseconds / 1000);
        string s = pi.ToString();
        Console.WriteLine(""{0}.{1}"", s[0], s.Substring(1));
        if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();
    }
}",1964,58
717,http://rosettacode.org/wiki/Arithmetic/Rational,Arithmetic/Rational,"Task

Create a reasonably complete implementation of rational arithmetic in the particular language using the idioms of the language.



Example

Define a new type called frac with binary operator ""//"" of two integers that returns a structure made up of the numerator and the denominator (as per a rational number).

Further define the appropriate rational unary operators abs and '-', with the binary operators for addition '+', subtraction '-', multiplication '×', division '/', integer division '÷', modulo division, the comparison operators (e.g. '<', '≤', '>', & '≥') and equality operators (e.g. '=' & '≠').

Define standard coercion operators for casting int to frac etc.

If space allows, define standard increment and decrement operators (e.g. '+:=' & '-:=' etc.).

Finally test the operators:
Use the new type frac to find all perfect numbers less than 219 by summing the reciprocal of the factors.



Related task

   Perfect Numbers

",#C.23,C#,"using System;
 
struct Fraction : IEquatable<Fraction>, IComparable<Fraction>
{
    public readonly long Num;
    public readonly long Denom;
 
    public Fraction(long num, long denom)
    {
        if (num == 0)
        {
            denom = 1;
        }
        else if (denom == 0)
        {
            throw new ArgumentException(""Denominator may not be zero"", ""denom"");
        }
        else if (denom < 0)
        {
            num = -num;
            denom = -denom;
        }
 
        long d = GCD(num, denom);
        this.Num = num / d;
        this.Denom = denom / d;
    }
 
    private static long GCD(long x, long y)
    {
        return y == 0 ? x : GCD(y, x % y);
    }
 
    private static long LCM(long x, long y)
    {
        return x / GCD(x, y) * y;
    }
 
    public Fraction Abs()
    {
        return new Fraction(Math.Abs(Num), Denom);
    }
 
    public Fraction Reciprocal()
    {
        return new Fraction(Denom, Num);
    }
 
    #region Conversion Operators
 
    public static implicit operator Fraction(long i)
    {
        return new Fraction(i, 1);
    }
 
    public static explicit operator double(Fraction f)
    {
        return f.Num == 0 ? 0 : (double)f.Num / f.Denom;
    }
 
    #endregion
 
    #region Arithmetic Operators
 
    public static Fraction operator -(Fraction f)
    {
        return new Fraction(-f.Num, f.Denom);
    }
 
    public static Fraction operator +(Fraction a, Fraction b)
    {
        long m = LCM(a.Denom, b.Denom);
        long na = a.Num * m / a.Denom;
        long nb = b.Num * m / b.Denom;
        return new Fraction(na + nb, m);
    }
 
    public static Fraction operator -(Fraction a, Fraction b)
    {
        return a + (-b);
    }
 
    public static Fraction operator *(Fraction a, Fraction b)
    {
        return new Fraction(a.Num * b.Num, a.Denom * b.Denom);
    }
 
    public static Fraction operator /(Fraction a, Fraction b)
    {
        return a * b.Reciprocal();
    }
 
    public static Fraction operator %(Fraction a, Fraction b)
    {
        long l = a.Num * b.Denom, r = a.Denom * b.Num;
        long n = l / r;
        return new Fraction(l - n * r, a.Denom * b.Denom);
    }
 
    #endregion
 
    #region Comparison Operators
 
    public static bool operator ==(Fraction a, Fraction b)
    {
        return a.Num == b.Num && a.Denom == b.Denom;
    }
 
    public static bool operator !=(Fraction a, Fraction b)
    {
        return a.Num != b.Num || a.Denom != b.Denom;
    }
 
    public static bool operator <(Fraction a, Fraction b)
    {
        return (a.Num * b.Denom) < (a.Denom * b.Num);
    }
 
    public static bool operator >(Fraction a, Fraction b)
    {
        return (a.Num * b.Denom) > (a.Denom * b.Num);
    }
 
    public static bool operator <=(Fraction a, Fraction b)
    {
        return !(a > b);
    }
 
    public static bool operator >=(Fraction a, Fraction b)
    {
        return !(a < b);
    }
 
    #endregion
 
    #region Object Members
 
    public override bool Equals(object obj)
    {
        if (obj is Fraction)
            return ((Fraction)obj) == this;
        else
            return false;
    }
 
    public override int GetHashCode()
    {
        return Num.GetHashCode() ^ Denom.GetHashCode();
    }
 
    public override string ToString()
    {
        return Num.ToString() + ""/"" + Denom.ToString();
    }
 
    #endregion
 
    #region IEquatable<Fraction> Members
 
    public bool Equals(Fraction other)
    {
        return other == this;
    }
 
    #endregion
 
    #region IComparable<Fraction> Members
 
    public int CompareTo(Fraction other)
    {
        return (this.Num * other.Denom).CompareTo(this.Denom * other.Num);
    }
 
    #endregion
}",3722,175
727,http://rosettacode.org/wiki/Arithmetic/Complex,Arithmetic/Complex,"A   complex number   is a number which can be written as:




a
+
b
×
i


{\displaystyle a+b\times i}


(sometimes shown as:




b
+
a
×
i


{\displaystyle b+a\times i}


where   



a


{\displaystyle a}

   and   



b


{\displaystyle b}

  are real numbers,   and   



i


{\displaystyle i}

   is   √ -1 



Typically, complex numbers are represented as a pair of real numbers called the ""imaginary part"" and ""real part"",   where the imaginary part is the number to be multiplied by 



i


{\displaystyle i}

.



Task

 Show addition, multiplication, negation, and inversion of complex numbers in separate functions. (Subtraction and division operations can be made with pairs of these operations.) 
 Print the results for each operation tested.
 Optional: Show complex conjugation.


By definition, the   complex conjugate   of




a
+
b
i


{\displaystyle a+bi}


is




a
−
b
i


{\displaystyle a-bi}





Some languages have complex number libraries available.   If your language does, show the operations.   If your language does not, also show the definition of this type.



",#C.23,C#,"namespace RosettaCode.Arithmetic.Complex
{
    using System;
    using System.Numerics;
 
    internal static class Program
    {
        private static void Main()
        {
            var number = Complex.ImaginaryOne;
            foreach (var result in new[] { number + number, number * number, -number, 1 / number, Complex.Conjugate(number) })
            {
                Console.WriteLine(result);
            }
        }
    }
}",437,17
747,http://rosettacode.org/wiki/Arithmetic-geometric_mean,Arithmetic-geometric mean,"

 This page uses content from Wikipedia. The original article was at Arithmetic-geometric mean. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Write a function to compute the arithmetic-geometric mean of two numbers.



The arithmetic-geometric mean of two numbers can be (usefully) denoted as 




a
g
m

(
a
,
g
)


{\displaystyle \mathrm {agm} (a,g)}

, and is equal to the limit of the sequence:

 




a

0


=
a
;


g

0


=
g


{\displaystyle a_{0}=a;\qquad g_{0}=g}


 




a

n
+
1


=



1
2



(

a

n


+

g

n


)
;


g

n
+
1


=



a

n



g

n




.


{\displaystyle a_{n+1}={\tfrac {1}{2}}(a_{n}+g_{n});\quad g_{n+1}={\sqrt {a_{n}g_{n}}}.}


Since the limit of 




a

n


−

g

n




{\displaystyle a_{n}-g_{n}}

 tends (rapidly) to zero with iterations, this is an efficient method.

Demonstrate the function by calculating:






a
g
m

(
1
,
1

/



2


)


{\displaystyle \mathrm {agm} (1,1/{\sqrt {2}})}




Also see

   mathworld.wolfram.com/Arithmetic-Geometric Mean

",#C.23,C#,"namespace RosettaCode.ArithmeticGeometricMean
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
 
    internal static class Program
    {
        private static double ArithmeticGeometricMean(double number,
                                                      double otherNumber,
                                                      IEqualityComparer<double>
                                                          comparer)
        {
            return comparer.Equals(number, otherNumber)
                       ? number
                       : ArithmeticGeometricMean(
                           ArithmeticMean(number, otherNumber),
                           GeometricMean(number, otherNumber), comparer);
        }
 
        private static double ArithmeticMean(double number, double otherNumber)
        {
            return 0.5 * (number + otherNumber);
        }
 
        private static double GeometricMean(double number, double otherNumber)
        {
            return Math.Sqrt(number * otherNumber);
        }
 
        private static void Main()
        {
            Console.WriteLine(
                ArithmeticGeometricMean(1, 0.5 * Math.Sqrt(2),
                                        new RelativeDifferenceComparer(1e-5)).
                    ToString(CultureInfo.InvariantCulture));
        }
 
        private class RelativeDifferenceComparer : IEqualityComparer<double>
        {
            private readonly double _maximumRelativeDifference;
 
            internal RelativeDifferenceComparer(double maximumRelativeDifference)
            {
                _maximumRelativeDifference = maximumRelativeDifference;
            }
 
            public bool Equals(double number, double otherNumber)
            {
                return RelativeDifference(number, otherNumber) <=
                       _maximumRelativeDifference;
            }
 
            public int GetHashCode(double number)
            {
                return number.GetHashCode();
            }
 
            private static double RelativeDifference(double number,
                                                     double otherNumber)
            {
                return AbsoluteDifference(number, otherNumber) /
                       Norm(number, otherNumber);
            }
 
            private static double AbsoluteDifference(double number,
                                                     double otherNumber)
            {
                return Math.Abs(number - otherNumber);
            }
 
            private static double Norm(double number, double otherNumber)
            {
                return 0.5 * (Math.Abs(number) + Math.Abs(otherNumber));
            }
        }
    }
}",2741,78
909,http://rosettacode.org/wiki/Archimedean_spiral,Archimedean spiral,"
The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.



An Archimedean spiral can be described by the equation:






r
=
a
+
b
θ


{\displaystyle \,r=a+b\theta }


with real numbers a and b.



Task
Draw an Archimedean spiral.



",#C.23,C#,"using System;
using System.Linq;
using System.Drawing;
using System.Diagnostics;
using System.Drawing.Drawing2D;
 
class Program
{
    const int width = 380;
    const int height = 380;
    static PointF archimedeanPoint(int degrees)
    {
        const double a = 1;
        const double b = 9;
        double t = degrees * Math.PI / 180;
        double r = a + b * t;
        return new PointF { X = (float)(width / 2 + r * Math.Cos(t)), Y = (float)(height / 2 + r * Math.Sin(t)) };
    }
 
    static void Main(string[] args)
    {
        var bm = new Bitmap(width, height);
        var g = Graphics.FromImage(bm);
        g.SmoothingMode = SmoothingMode.AntiAlias;
        g.FillRectangle(new SolidBrush(Color.White), new Rectangle { X = 0, Y = 0, Width = width, Height = height });
        var pen = new Pen(Color.OrangeRed, 1.5f);
 
        var spiral = Enumerable.Range(0, 360 * 3).AsParallel().AsOrdered().Select(archimedeanPoint);
        var p0 = new PointF(width / 2, height / 2);
        foreach (var p1 in spiral)
        {
            g.DrawLine(pen, p0, p1);
            p0 = p1;
        }
        g.Save(); // is this really necessary ?
        bm.Save(""archimedes-csharp.png"");
        Process.Start(""archimedes-csharp.png""); // Launches default photo viewing app
    }
}
 ",1291,40
938,http://rosettacode.org/wiki/Arrays,Arrays,"This task is about arrays.

For hashes or associative arrays, please see Creating an Associative Array.

For a definition and in-depth discussion of what an array is, see Array.



Task

Show basic array syntax in your language.

Basically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and
dynamic arrays, pushing a value into it).

Please discuss at Village Pump:   Arrays.

Please merge code in from these obsolete tasks:

   Creating an Array
   Assigning Values to an Array
   Retrieving an Element of an Array


Related tasks

   Collections
   Creating an Associative Array
   Two-dimensional array (runtime)

",#C.23,C#, int[] numbers = new int[10];,29,1
1096,http://rosettacode.org/wiki/Zero_to_the_zero_power,Zero to the zero power,"Some computer programming languages are not exactly consistent   (with other computer programming languages)  

when   raising zero to the zeroth power:     00



Task

Show the results of raising   zero   to the   zeroth   power.



If your computer language objects to      0**0      or      0^0      at compile time,   you may also try something like:

           x = 0
           y = 0
           z = x**y
           say  'z='  z


Show the result here.

And of course use any symbols or notation that is supported in your computer programming language for exponentiation.



See also

 The Wiki entry: Zero to the power of zero. 
 The Wiki entry: History of differing points of view.
 The MathWorld™ entry: exponent laws.
 Also, in the above MathWorld™ entry, see formula (9): 




x

0


=
1


{\displaystyle x^{0}=1}

.
 The OEIS entry: The special case of zero to the zeroth power

",#C.23,C#,"using System;
 
namespace ZeroToTheZeroeth
{
    class Program
    {
        static void Main(string[] args)
        {
            double k = Math.Pow(0, 0);
            Console.Write(""0^0 is {0}"", k);           
        }
    }
}",230,13
1161,http://rosettacode.org/wiki/Zeckendorf_number_representation,Zeckendorf number representation,"Just as numbers can be represented in a positional notation as sums of multiples of the powers of ten (decimal) or two (binary); all the positive integers can be represented as the sum of one or zero times the distinct members of the Fibonacci series.

Recall that the first six distinct Fibonacci numbers are: 1, 2, 3, 5, 8, 13.

The decimal number eleven can be written as 0*13 + 1*8 + 0*5 + 1*3 + 0*2 + 0*1 or 010100 in positional notation where the columns represent multiplication by a particular member of the sequence. Leading zeroes are dropped so that 11 decimal becomes 10100.

10100 is not the only way to make 11 from the Fibonacci numbers however; 0*13 + 1*8 + 0*5 + 0*3 + 1*2 + 1*1 or 010011 would also represent decimal 11. For a true Zeckendorf number there is the added restriction that no two consecutive Fibonacci numbers can be used which leads to the former unique solution.



Task

Generate and show here a table of the Zeckendorf number representations of the decimal numbers zero to twenty, in order.

The intention in this task to find the Zeckendorf form of an arbitrary integer. The Zeckendorf form can be iterated by some bit twiddling rather than calculating each value separately but leave that to another separate task.



Also see

   OEIS A014417   for the the sequence of required results.
   Brown's Criterion - Numberphile


Related task

   Fibonacci sequence

",#C.23,C#," 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace Zeckendorf
{
    class Program
    {
        private static uint Fibonacci(uint n)
        {
            if (n < 2)
            {
                return n;
            }
            else
            {
                return Fibonacci(n - 1) + Fibonacci(n - 2);
            }
        }
 
        private static string Zeckendorf(uint num)
        {
            IList<uint> fibonacciNumbers = new List<uint>();
            uint fibPosition = 2;
 
            uint currentFibonaciNum = Fibonacci(fibPosition);
 
            do
            {
                fibonacciNumbers.Add(currentFibonaciNum);
                currentFibonaciNum = Fibonacci(++fibPosition);
            } while (currentFibonaciNum <= num);
 
            uint temp = num;
            StringBuilder output = new StringBuilder();
 
            foreach (uint item in fibonacciNumbers.Reverse())
            {
                if (item <= temp)
                {
                    output.Append(""1"");
                    temp -= item;
                }
                else
                {
                    output.Append(""0"");
                }
            }
 
            return output.ToString();
        }
 
        static void Main(string[] args)
        {
            for (uint i = 1; i <= 20; i++)
            {
                string zeckendorfRepresentation = Zeckendorf(i);
                Console.WriteLine(string.Format(""{0} : {1}"", i, zeckendorfRepresentation));
            }
 
            Console.ReadKey();
        }
    }
}
 ",1610,67
1192,http://rosettacode.org/wiki/Zumkeller_numbers,Zumkeller numbers,"Zumkeller numbers are the set of numbers whose divisors can be partitioned into two disjoint sets that sum to the same value. Each sum must contain divisor values that are not in the other sum, and all of the divisors must be in one or the other. There are no restrictions on how the divisors are partitioned, only that the two partition sums are equal.



E.G.
 6 is a Zumkeller number; The divisors {1 2 3 6} can be partitioned into two groups {1 2 3} and {6} that both sum to 6.
 10 is not a Zumkeller number; The divisors {1 2 5 10} can not be partitioned into two groups in any way that will both sum to the same value.
 12 is a Zumkeller number; The divisors {1 2 3 4 6 12} can be partitioned into two groups {1 3 4 6} and {2 12} that both sum to 14.


Even Zumkeller numbers are common; odd Zumkeller numbers are much less so. For values below 10^6, there is at least one Zumkeller number in every 12 consecutive integers, and the vast majority of them are even. The odd Zumkeller numbers are very similar to the list from the task Abundant odd numbers; they are nearly the same except for the further restriction that the abundance (A(n) = sigma(n) - 2n), must be even: A(n) mod 2 == 0



Task

 Write a routine (function, procedure, whatever) to find Zumkeller numbers.
 Use the routine to find and display here, on this page, the first 220 Zumkeller numbers.
 Use the routine to find and display here, on this page, the first 40 odd Zumkeller numbers.
 Optional, stretch goal: Use the routine to find and display here, on this page, the first 40 odd Zumkeller numbers that don't end with 5.


See Also

 OEIS:A083207 - Zumkeller numbers to get an impression of different partitions OEIS:A083206 Zumkeller partitions
 OEIS:A174865 - Odd Zumkeller numbers


Related Tasks

 Abundant odd numbers
 Abundant, deficient and perfect number classifications
 Proper divisors , Factors of an integer",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace ZumkellerNumbers {
    class Program {
        static List<int> GetDivisors(int n) {
            List<int> divs = new List<int> {
                1, n
            };
            for (int i = 2; i * i <= n; i++) {
                if (n % i == 0) {
                    int j = n / i;
                    divs.Add(i);
                    if (i != j) {
                        divs.Add(j);
                    }
                }
            }
            return divs;
        }
 
        static bool IsPartSum(List<int> divs, int sum) {
            if (sum == 0) {
                return true;
            }
            var le = divs.Count;
            if (le == 0) {
                return false;
            }
            var last = divs[le - 1];
            List<int> newDivs = new List<int>();
            for (int i = 0; i < le - 1; i++) {
                newDivs.Add(divs[i]);
            }
            if (last > sum) {
                return IsPartSum(newDivs, sum);
            }
            return IsPartSum(newDivs, sum) || IsPartSum(newDivs, sum - last);
        }
 
        static bool IsZumkeller(int n) {
            var divs = GetDivisors(n);
            var sum = divs.Sum();
            // if sum is odd can't be split into two partitions with equal sums
            if (sum % 2 == 1) {
                return false;
            }
            // if n is odd use 'abundant odd number' optimization
            if (n % 2 == 1) {
                var abundance = sum - 2 * n;
                return abundance > 0 && abundance % 2 == 0;
            }
            // if n and sum are both even check if there's a partition which totals sum / 2
            return IsPartSum(divs, sum / 2);
        }
 
        static void Main() {
            Console.WriteLine(""The first 220 Zumkeller numbers are:"");
            int i = 2;
            for (int count = 0; count < 220; i++) {
                if (IsZumkeller(i)) {
                    Console.Write(""{0,3} "", i);
                    count++;
                    if (count % 20 == 0) {
                        Console.WriteLine();
                    }
                }
            }
 
            Console.WriteLine(""\nThe first 40 odd Zumkeller numbers are:"");
            i = 3;
            for (int count = 0; count < 40; i += 2) {
                if (IsZumkeller(i)) {
                    Console.Write(""{0,5} "", i);
                    count++;
                    if (count % 10 == 0) {
                        Console.WriteLine();
                    }
                }
            }
 
            Console.WriteLine(""\nThe first 40 odd Zumkeller numbers which don't end in 5 are:"");
            i = 3;
            for (int count = 0; count < 40; i += 2) {
                if (i % 10 != 5 && IsZumkeller(i)) {
                    Console.Write(""{0,7} "", i);
                    count++;
                    if (count % 8 == 0) {
                        Console.WriteLine();
                    }
                }
            }
        }
    }
}",3089,96
1208,http://rosettacode.org/wiki/Zeckendorf_arithmetic,Zeckendorf arithmetic,"This task is a total immersion zeckendorf task; using decimal numbers will attract serious disapprobation.

The task is to implement addition, subtraction, multiplication, and division using Zeckendorf number representation. Optionally provide decrement, increment and comparitive operation functions.

Addition
Like binary 1 + 1 = 10, note carry 1 left. There the similarity ends. 10 + 10 = 101, note carry 1 left and 1 right. 100 + 100 = 1001, note carry 1 left and 2 right, this is the general case.

Occurrences of 11 must be changed to 100. Occurrences of 111 may be changed from the right by replacing 11 with 100, or from the left converting 111 to 100 + 100;

Subtraction
10 - 1 = 1. The general rule is borrow 1 right carry 1 left. eg:

  abcde
  10100 -
   1000
  _____
    100  borrow 1 from a leaves 100
  + 100  add the carry
  _____
   1001

A larger example:

  abcdef
  100100 -
    1000
  ______
  1*0100 borrow 1 from b
   + 100 add the carry
  ______
  1*1001

Sadly we borrowed 1 from b which didn't have it to lend. So now b borrows from a:

    1001
  + 1000 add the carry
    ____
   10100

Multiplication
Here you teach your computer its zeckendorf tables. eg. 101 * 1001:

  a = 1 * 101 = 101
  b = 10 * 101 = a + a = 10000
  c = 100 * 101 = b + a = 10101
  d = 1000 * 101 = c + b = 101010

  1001 = d + a therefore 101 * 1001 =
 
  101010
   + 101
  ______
 1000100

Division
Lets try 1000101 divided by 101, so we can use the same table used for multiplication.

  1000101 -
   101010 subtract d (1000 * 101)
  _______
     1000 -
      101 b and c are too large to subtract, so subtract a
     ____
        1 so 1000101 divided by 101 is d + a (1001) remainder 1

Efficient algorithms for Zeckendorf arithmetic is interesting. The sections on addition and subtraction are particularly relevant for this task.
",#C.23,C#,"using System;
using System.Text;
 
namespace ZeckendorfArithmetic {
    class Zeckendorf : IComparable<Zeckendorf> {
        private static readonly string[] dig = { ""00"", ""01"", ""10"" };
        private static readonly string[] dig1 = { """", ""1"", ""10"" };
 
        private int dVal = 0;
        private int dLen = 0;
 
        public Zeckendorf() : this(""0"") {
            // empty
        }
 
        public Zeckendorf(string x) {
            int q = 1;
            int i = x.Length - 1;
            dLen = i / 2;
            while (i >= 0) {
                dVal += (x[i] - '0') * q;
                q *= 2;
                i--;
            }
        }
 
        private void A(int n) {
            int i = n;
            while (true) {
                if (dLen < i) dLen = i;
                int j = (dVal >> (i * 2)) & 3;
                switch (j) {
                    case 0:
                    case 1:
                        return;
                    case 2:
                        if (((dVal >> ((i + 1) * 2)) & 1) != 1) return;
                        dVal += 1 << (i * 2 + 1);
                        return;
                    case 3:
                        int temp = 3 << (i * 2);
                        temp ^= -1;
                        dVal = dVal & temp;
                        B((i + 1) * 2);
                        break;
                }
                i++;
            }
        }
 
        private void B(int pos) {
            if (pos == 0) {
                Inc();
                return;
            }
            if (((dVal >> pos) & 1) == 0) {
                dVal += 1 << pos;
                A(pos / 2);
                if (pos > 1) A(pos / 2 - 1);
            }
            else {
                int temp = 1 << pos;
                temp ^= -1;
                dVal = dVal & temp;
                B(pos + 1);
                B(pos - (pos > 1 ? 2 : 1));
            }
        }
 
        private void C(int pos) {
            if (((dVal >> pos) & 1) == 1) {
                int temp = 1 << pos;
                temp ^= -1;
                dVal = dVal & temp;
                return;
            }
            C(pos + 1);
            if (pos > 0) {
                B(pos - 1);
            }
            else {
                Inc();
            }
        }
 
        public Zeckendorf Inc() {
            dVal++;
            A(0);
            return this;
        }
 
        public Zeckendorf Copy() {
            Zeckendorf z = new Zeckendorf {
                dVal = dVal,
                dLen = dLen
            };
            return z;
        }
 
        public void PlusAssign(Zeckendorf other) {
            for (int gn = 0; gn < (other.dLen + 1) * 2; gn++) {
                if (((other.dVal >> gn) & 1) == 1) {
                    B(gn);
                }
            }
        }
 
        public void MinusAssign(Zeckendorf other) {
            for (int gn = 0; gn < (other.dLen + 1) * 2; gn++) {
                if (((other.dVal >> gn) & 1) == 1) {
                    C(gn);
                }
            }
            while ((((dVal >> dLen * 2) & 3) == 0) || (dLen == 0)) {
                dLen--;
            }
        }
 
        public void TimesAssign(Zeckendorf other) {
            Zeckendorf na = other.Copy();
            Zeckendorf nb = other.Copy();
            Zeckendorf nt;
            Zeckendorf nr = new Zeckendorf();
            for (int i = 0; i < (dLen + 1) * 2; i++) {
                if (((dVal >> i) & 1) > 0) {
                    nr.PlusAssign(nb);
                }
                nt = nb.Copy();
                nb.PlusAssign(na);
                na = nt.Copy();
            }
            dVal = nr.dVal;
            dLen = nr.dLen;
        }
 
        public int CompareTo(Zeckendorf other) {
            return dVal.CompareTo(other.dVal);
        }
 
        public override string ToString() {
            if (dVal == 0) {
                return ""0"";
            }
 
            int idx = (dVal >> (dLen * 2)) & 3;
            StringBuilder sb = new StringBuilder(dig1[idx]);
            for (int i = dLen - 1; i >= 0; i--) {
                idx = (dVal >> (i * 2)) & 3;
                sb.Append(dig[idx]);
            }
            return sb.ToString();
        }
    }
 
    class Program {
        static void Main(string[] args) {
            Console.WriteLine(""Addition:"");
            Zeckendorf g = new Zeckendorf(""10"");
            g.PlusAssign(new Zeckendorf(""10""));
            Console.WriteLine(g);
            g.PlusAssign(new Zeckendorf(""10""));
            Console.WriteLine(g);
            g.PlusAssign(new Zeckendorf(""1001""));
            Console.WriteLine(g);
            g.PlusAssign(new Zeckendorf(""1000""));
            Console.WriteLine(g);
            g.PlusAssign(new Zeckendorf(""10101""));
            Console.WriteLine(g);
            Console.WriteLine();
 
            Console.WriteLine(""Subtraction:"");
            g = new Zeckendorf(""1000"");
            g.MinusAssign(new Zeckendorf(""101""));
            Console.WriteLine(g);
            g = new Zeckendorf(""10101010"");
            g.MinusAssign(new Zeckendorf(""1010101""));
            Console.WriteLine(g);
            Console.WriteLine();
 
            Console.WriteLine(""Multiplication:"");
            g = new Zeckendorf(""1001"");
            g.TimesAssign(new Zeckendorf(""101""));
            Console.WriteLine(g);
            g = new Zeckendorf(""101010"");
            g.PlusAssign(new Zeckendorf(""101""));
            Console.WriteLine(g);
        }
    }
}",5520,189
1243,http://rosettacode.org/wiki/Arbitrary-precision_integers_(included),Arbitrary-precision integers (included),"Using the in-built capabilities of your language, calculate the integer value of:

        
  
    
      
        
          5
          
            
              4
              
                
                  3
                  
                    2
                  
                
              
            
          
        
      
    
    {\displaystyle 5^{4^{3^{2}}}}
  


 Confirm that the first and last twenty digits of the answer are: 
     62060698786608744707...92256259918212890625

 Find and show the number of decimal digits in the answer.


Note: Do not submit an implementation of arbitrary precision arithmetic. The intention is to show the capabilities of the language as supplied. If a language has a single, overwhelming, library of varied modules that is endorsed by its home site – such as CPAN for Perl or Boost for C++ – then that may be used instead.
Strictly speaking, this should not be solved by fixed-precision numeric libraries where the precision has to be manually set to a large value; although if this is the only recourse then it may be used with a note explaining that the precision must be set manually to a large enough value.


Related tasks

   Long multiplication
   Exponentiation order
   exponentiation operator
   Exponentiation with infix operators in (or operating on) the base

",#C.23,C#,"using System;
using System.Diagnostics;
using System.Linq;
using System.Numerics;
 
static class Program {
    static void Main() {
        BigInteger n = BigInteger.Pow(5, (int)BigInteger.Pow(4, (int)BigInteger.Pow(3, 2)));
        string result = n.ToString();
 
        Debug.Assert(result.Length == 183231);
        Debug.Assert(result.StartsWith(""62060698786608744707""));
        Debug.Assert(result.EndsWith(""92256259918212890625""));
 
        Console.WriteLine(""n = 5^4^3^2"");
        Console.WriteLine(""n = {0}...{1}"", 
            result.Substring(0, 20),
            result.Substring(result.Length - 20, 20)
            );
 
        Console.WriteLine(""n digits = {0}"", result.Length);
    }
}",702,23
1360,http://rosettacode.org/wiki/100_doors,100 doors,"There are 100 doors in a row that are all initially closed.

You make 100 passes by the doors.

The first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).

The second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.

The third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.



Task

Answer the question:   what state are the doors in after the last pass?   Which are open, which are closed?


Alternate:
As noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.

Opening only those doors is an   optimization   that may also be expressed;
however, as should be obvious, this defeats the intent of comparing implementations across programming languages.



",#C.23,C#,"namespace ConsoleApplication1
{
    using System;
    class Program
    {
        static void Main(string[] args)
        {
            bool[] doors = new bool[100];
 
            //Close all doors to start.
            for (int d = 0; d < 100; d++) doors[d] = false;
 
            //For each pass...
            for (int p = 0; p < 100; p++)//number of passes
            {
                //For each door to toggle...
                for (int d = 0; d < 100; d++)//door number
                {
                    if ((d + 1) % (p + 1) == 0)
                    {
                        doors[d] = !doors[d];
                    }
                }
            }
 
            //Output the results.
            Console.WriteLine(""Passes Completed!!!  Here are the results: \r\n"");
            for (int d = 0; d < 100; d++)
            {
                if (doors[d])
                {
                    Console.WriteLine(String.Format(""Door #{0}: Open"", d + 1));
                }
                else
                {
                    Console.WriteLine(String.Format(""Door #{0}: Closed"", d + 1));
                }
            }
            Console.ReadKey(true);
        }
    }
}",1192,42
1415,http://rosettacode.org/wiki/Yahoo!_search_interface,Yahoo! search interface,"Create a class for searching Yahoo! results.

It must implement a Next Page method, and read URL, Title and Content from results.



",#C.23,C#,"using System;
using System.Net;
using System.Text.RegularExpressions;
using System.Collections.Generic;
 
class YahooSearch {
    private string query;
    private string content;
    private int page;
 
    const string yahoo = ""http://search.yahoo.com/search?"";
 
    public YahooSearch(string query) : this(query, 0) { }
 
    public YahooSearch(string query, int page) {
        this.query = query;
        this.page = page;
        this.content = new WebClient()
            .DownloadString(
                string.Format(yahoo + ""p={0}&b={1}"", query, this.page * 10 + 1)
            );
    }
 
    public YahooResult[] Results {
        get {
            List<YahooResult> results = new List<YahooResult>();
 
            Func<string, string, string> substringBefore = (str, before) =>
            {
                int iHref = str.IndexOf(before);
                return iHref < 0 ? """" : str.Substring(0, iHref);
            };
            Func<string, string, string> substringAfter = (str, after) =>
            {
                int iHref = str.IndexOf(after);
                return iHref < 0 ? """" : str.Substring(iHref + after.Length);
            };
            Converter<string, string> getText = p => 
                Regex.Replace(p, ""<[^>]*>"", x => """");
 
            Regex rx = new Regex(@""
                <li>
                    <div \s class=""""res"""">
                        <div>
                            <h3>
                                <a \s (?'LinkAttributes'[^>]+)>
                                    (?'LinkText' .*?)
                                (?></a>)
                            </h3>
                        </div>
                        <div \s class=""""abstr"""">
                            (?'Abstract' .*?)
                        (?></div>)
                        .*?
                    (?></div>)
                </li>"",
                RegexOptions.IgnorePatternWhitespace
                | RegexOptions.ExplicitCapture
            );
            foreach (Match e in rx.Matches(this.content)) {
                string rurl = getText(substringBefore(substringAfter(
                    e.Groups[""LinkAttributes""].Value, @""href=""""""), @""""""""));
                string rtitle = getText(e.Groups[""LinkText""].Value);
                string rcontent = getText(e.Groups[""Abstract""].Value);
 
                results.Add(new YahooResult(rurl, rtitle, rcontent));
            }
            return results.ToArray();
        }
    }
 
    public YahooSearch NextPage() {
        return new YahooSearch(this.query, this.page + 1);
    }
 
    public YahooSearch GetPage(int page) {
        return new YahooSearch(this.query, page);
    }
}
 
class YahooResult {
    public string URL { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }
 
    public YahooResult(string url, string title, string content) {
        this.URL = url;
        this.Title = title;
        this.Content = content;
    }
 
    public override string ToString()
    {
        return string.Format(""\nTitle: {0}\nLink:  {1}\nText:  {2}"",
            Title, URL, Content);
    }
}
 
// Usage: 
 
class Prog {
    static void Main() {
        foreach (int page in new[] { 0, 1 })
        {
            YahooSearch x = new YahooSearch(""test"", page);
 
            foreach (YahooResult result in x.Results)
            {
                Console.WriteLine(result);
            }
        }
    }
}
 ",3445,114
1575,http://rosettacode.org/wiki/XML/XPath,XML/XPath,"Perform the following three XPath queries on the XML Document below:

 //item[1]: Retrieve the first ""item"" element 
 //price/text(): Perform an action on each ""price"" element (print it out)
 //name: Get an array of all the ""name"" elements
XML Document:

<inventory title=""OmniCorp Store #45x10^3"">
  <section name=""health"">
    <item upc=""123456789"" stock=""12"">
      <name>Invisibility Cream</name>
      <price>14.50</price>
      <description>Makes you invisible</description>
    </item>
    <item upc=""445322344"" stock=""18"">
      <name>Levitation Salve</name>
      <price>23.99</price>
      <description>Levitate yourself for up to 3 hours per application</description>
    </item>
  </section>
  <section name=""food"">
    <item upc=""485672034"" stock=""653"">
      <name>Blork and Freen Instameal</name>
      <price>4.95</price>
      <description>A tasty meal in a tablet; just add water</description>
    </item>
    <item upc=""132957764"" stock=""44"">
      <name>Grob winglets</name>
      <price>3.56</price>
      <description>Tender winglets of Grob. Just add water</description>
    </item>
  </section>
</inventory>
",#C.23,C#,"XmlReader XReader;
 
// Either read the xml from a string ...
XReader = XmlReader.Create(new StringReader(""<inventory title=... </inventory>""));
 
// ... or read it from the file system.
XReader = XmlReader.Create(""xmlfile.xml"");
 
// Create a XPathDocument object (which implements the IXPathNavigable interface)
// which is optimized for XPath operation. (very fast).
IXPathNavigable XDocument = new XPathDocument(XReader);
 
// Create a Navigator to navigate through the document.
XPathNavigator Nav = XDocument.CreateNavigator();
Nav = Nav.SelectSingleNode(""//item"");
 
// Move to the first element of the selection. (if available).
if(Nav.MoveToFirst())
{
  Console.WriteLine(Nav.OuterXml); // The outer xml of the first item element.
}
 
// Get an iterator to loop over multiple selected nodes.
XPathNodeIterator Iterator = XDocument.CreateNavigator().Select(""//price"");
 
while (Iterator.MoveNext())
{
  Console.WriteLine(Iterator.Current.Value);
}
 
Iterator = XDocument.CreateNavigator().Select(""//name"");
 
// Use a generic list.
List<string> NodesValues = new List<string>();
 
while (Iterator.MoveNext())
{
  NodesValues.Add(Iterator.Current.Value);
}
 
// Convert the generic list to an array and output the count of items.
Console.WriteLine(NodesValues.ToArray().Length);",1285,42
1596,http://rosettacode.org/wiki/Zebra_puzzle,Zebra puzzle,"Zebra puzzle

You are encouraged to solve this task according to the task description, using any language you may know.
The Zebra puzzle, a.k.a. Einstein's Riddle,
is a logic puzzle which is to be solved programmatically.



It has several variants, one of them this:

   There are five houses.
   The English man lives in the red house.
   The Swede has a dog.
   The Dane drinks tea.
   The green house is immediately to the left of the white house.
   They drink coffee in the green house.
   The man who smokes Pall Mall has birds.
   In the yellow house they smoke Dunhill.
   In the middle house they drink milk.
   The Norwegian lives in the first house.
   The man who smokes Blend lives in the house next to the house with cats.
   In a house next to the house where they have a horse, they smoke Dunhill.
   The man who smokes Blue Master drinks beer.
   The German smokes Prince.
   The Norwegian lives next to the blue house.
   They drink water in a house next to the house where they smoke Blend. 

The question is, who owns the zebra?

Additionally, list the solution for all the houses.

Optionally, show the solution is unique.



Related tasks

   Dinesman's multiple-dwelling problem
   Twelve statements

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using static System.Console;
 
public enum Colour { Red, Green, White, Yellow, Blue }
public enum Nationality { Englishman, Swede, Dane, Norwegian,German }
public enum Pet { Dog, Birds, Cats, Horse, Zebra }
public enum Drink { Coffee, Tea, Milk, Beer, Water }
public enum Smoke { PallMall, Dunhill, Blend, BlueMaster, Prince}
 
public static class ZebraPuzzle
{
    private static (Colour[] colours, Drink[] drinks, Smoke[] smokes, Pet[] pets, Nationality[] nations) _solved;
 
    static ZebraPuzzle()
    {
        var solve = from colours in Permute<Colour>()  //r1 5 range
                    where (colours,Colour.White).IsRightOf(colours, Colour.Green) // r5
                    from nations in Permute<Nationality>()
                    where nations[0] == Nationality.Norwegian // r10
                    where (nations, Nationality.Englishman).IsSameIndex(colours, Colour.Red) //r2
                    where (nations,Nationality.Norwegian).IsNextTo(colours,Colour.Blue) // r15
                    from drinks in Permute<Drink>()
                    where drinks[2] == Drink.Milk //r9
                    where (drinks, Drink.Coffee).IsSameIndex(colours, Colour.Green) // r6
                    where (drinks, Drink.Tea).IsSameIndex(nations, Nationality.Dane) //r4
                    from pets in Permute<Pet>()
                    where (pets, Pet.Dog).IsSameIndex(nations, Nationality.Swede) // r3
                    from smokes in Permute<Smoke>()
                    where (smokes, Smoke.PallMall).IsSameIndex(pets, Pet.Birds) // r7
                    where (smokes, Smoke.Dunhill).IsSameIndex(colours, Colour.Yellow) // r8
                    where (smokes, Smoke.Blend).IsNextTo(pets, Pet.Cats) // r11
                    where (smokes, Smoke.Dunhill).IsNextTo(pets, Pet.Horse) //r12
                    where (smokes, Smoke.BlueMaster).IsSameIndex(drinks, Drink.Beer) //r13
                    where (smokes, Smoke.Prince).IsSameIndex(nations, Nationality.German) // r14
                    where (drinks,Drink.Water).IsNextTo(smokes,Smoke.Blend) // r16
                    select (colours, drinks, smokes, pets, nations);
 
        _solved = solve.First();
    }
 
    private static int IndexOf<T>(this T[] arr, T obj) => Array.IndexOf(arr, obj);
 
    private static bool IsRightOf<T, U>(this (T[] a, T v) right, U[] a, U v) => right.a.IndexOf(right.v) == a.IndexOf(v) + 1;
 
    private static bool IsSameIndex<T, U>(this (T[] a, T v)x, U[] a, U v) => x.a.IndexOf(x.v) == a.IndexOf(v);
 
    private static bool IsNextTo<T, U>(this (T[] a, T v)x, U[] a,  U v) => (x.a,x.v).IsRightOf(a, v) || (a,v).IsRightOf(x.a,x.v);
 
    // made more generic from https://codereview.stackexchange.com/questions/91808/permutations-in-c
    public static IEnumerable<IEnumerable<T>> Permutations<T>(this IEnumerable<T> values)
    {
        if (values.Count() == 1)
            return values.ToSingleton();
 
        return values.SelectMany(v => Permutations(values.Except(v.ToSingleton())),(v, p) => p.Prepend(v));
    }
 
    public static IEnumerable<T[]> Permute<T>() => ToEnumerable<T>().Permutations().Select(p=>p.ToArray());
 
    private static IEnumerable<T> ToSingleton<T>(this T item){ yield return item; }
 
    private static IEnumerable<T> ToEnumerable<T>() => Enum.GetValues(typeof(T)).Cast<T>();
 
    public static new String ToString()
    {
        var sb = new StringBuilder();
        sb.AppendLine(""House Colour Drink    Nationality Smokes     Pet"");
        sb.AppendLine(""───── ────── ──────── ─────────── ────────── ─────"");
        var (colours, drinks, smokes, pets, nations) = _solved;
        for (var i = 0; i < 5; i++)
            sb.AppendLine($""{i+1,5} {colours[i],-6} {drinks[i],-8} {nations[i],-11} {smokes[i],-10} {pets[i],-10}"");
        return sb.ToString();
    }
 
    public static void Main(string[] arguments)
    {
        var owner = _solved.nations[_solved.pets.IndexOf(Pet.Zebra)];
        WriteLine($""The zebra owner is {owner}"");
        Write(ToString());
        Read();
    }
}",4122,85
1600,http://rosettacode.org/wiki/Y_combinator,Y combinator,"In strict functional programming and the lambda calculus, functions (lambda expressions) don't have state and are only allowed to refer to arguments of enclosing functions.

This rules out the usual definition of a recursive function wherein a function is associated with the state of a variable and this variable's state is used in the body of the function.

The   Y combinator   is itself a stateless function that, when applied to another stateless function, returns a recursive version of the function.

The Y combinator is the simplest of the class of such functions, called fixed-point combinators.



Task

Define the stateless   Y combinator   and use it to compute factorials and Fibonacci numbers from other stateless functions or lambda expressions.



Cf

 Jim Weirich: Adventures in Functional Programming

",#C.23,C#,"using System;
 
static class YCombinator<T, TResult>
{
    // RecursiveFunc is not needed to call Fix() and so can be private.
    private delegate Func<T, TResult> RecursiveFunc(RecursiveFunc r);
 
    public static Func<Func<Func<T, TResult>, Func<T, TResult>>, Func<T, TResult>> Fix { get; } =
        f => ((RecursiveFunc)(g => f(x => g(g)(x))))(g => f(x => g(g)(x)));
}
 
static class Program
{
    static void Main()
    {
        var fac = YCombinator<int, int>.Fix(f => x => x < 2 ? 1 : x * f(x - 1));
        var fib = YCombinator<int, int>.Fix(f => x => x < 2 ? x : f(x - 1) + f(x - 2));
 
        Console.WriteLine(fac(10));
        Console.WriteLine(fib(10));
    }
}
 ",681,23
1646,http://rosettacode.org/wiki/Zig-zag_matrix,Zig-zag matrix,"Task

Produce a zig-zag array.



A   zig-zag   array is a square arrangement of the first   N2   natural numbers,   where the

numbers increase sequentially as you zig-zag along the array's   anti-diagonals.

For a graphical representation, see   JPG zigzag   (JPG uses such arrays to encode images).



For example, given   5,   produce this array:

 0  1  5  6 14
 2  4  7 13 15
 3  8 12 16 21
 9 11 17 20 22
10 18 19 23 24



Related tasks

   Spiral matrix
   Identity matrix
   Ulam spiral (for primes)


See also

   Wiktionary entry:   anti-diagonals

",#C.23,C#,"public static int[,] ZigZag(int n)
{
    int[,] result = new int[n, n];
    int i = 0, j = 0;
    int d = -1; // -1 for top-right move, +1 for bottom-left move
    int start = 0, end = n * n - 1;
    do
    {
        result[i, j] = start++;
        result[n - i - 1, n - j - 1] = end--;
 
        i += d; j -= d;
        if (i < 0)
        {
            i++; d = -d; // top reached, reverse
        }
        else if (j < 0)
        {
            j++; d = -d; // left reached, reverse
        }
    } while (start < end);
    if (start == end)
        result[i, j] = start;
    return result;
}",594,25
1667,http://rosettacode.org/wiki/Yin_and_yang,Yin and yang,"One well-known symbol of the philosophy of duality known as yin and yang is the taijitu.



Task

   Create a function that, given a parameter representing size, generates such a symbol scaled to the requested size.
   Generate and display the symbol for two different (small) sizes.

",#C.23,C#," 
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
            Paint += Form1_Paint;
        }
 
        private void Form1_Paint(object sender, PaintEventArgs e)
        {
            Graphics g = e.Graphics;
            g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;
 
            DrawTaijitu(g, new Point(50, 50), 200, true);
            DrawTaijitu(g, new Point(10, 10), 60, true);
        }
 
        private void DrawTaijitu(Graphics g, Point pt, int width, bool hasOutline)
        {
            g.FillPie(Brushes.Black, pt.X, pt.Y, width, width, 90, 180);
            g.FillPie(Brushes.White, pt.X, pt.Y, width, width, 270, 180);
            float headSize = Convert.ToSingle(width * 0.5);
            float headXPosition = Convert.ToSingle(pt.X + (width * 0.25));
            g.FillEllipse(Brushes.Black, headXPosition, Convert.ToSingle(pt.Y), headSize, headSize);
            g.FillEllipse(Brushes.White, headXPosition, Convert.ToSingle(pt.Y + (width * 0.5)), headSize, headSize);
            float headBlobSize = Convert.ToSingle(width * 0.125);
            float headBlobXPosition = Convert.ToSingle(pt.X + (width * 0.4375));
            g.FillEllipse(Brushes.White, headBlobXPosition, Convert.ToSingle(pt.Y + (width * 0.1875)), headBlobSize, headBlobSize);
            g.FillEllipse(Brushes.Black, headBlobXPosition, Convert.ToSingle(pt.Y + (width * 0.6875)), headBlobSize, headBlobSize);
            if (hasOutline) g.DrawEllipse(Pens.Black, pt.X, pt.Y, width, width);
        }
    }",1582,33
2353,http://rosettacode.org/wiki/Write_to_Windows_event_log,Write to Windows event log,"Task

Write script status to the Windows Event Log



",#C.23,C#,"using System.Diagnostics;
 
namespace RC
{
  internal class Program
  {
    public static void Main()
    {
      string sSource  = ""Sample App"";
      string sLog     = ""Application"";
      string sEvent   = ""Hello from RC!"";
 
      if (!EventLog.SourceExists(sSource))
        EventLog.CreateEventSource(sSource, sLog);
 
      EventLog.WriteEntry(sSource, sEvent);
      EventLog.WriteEntry(sSource, sEvent, EventLogEntryType.Information);
    }
  }
}",455,20
2421,http://rosettacode.org/wiki/Write_entire_file,Write entire file,"Task

(Over)write a file so that it contains a string.



The reverse of Read entire file—for when you want to update or create a file which you would read in its entirety all at once.



",#C.23,C#,"System.IO.File.WriteAllText(""filename.txt"", ""This file contains a string."");",76,1
2446,http://rosettacode.org/wiki/Write_float_arrays_to_a_text_file,Write float arrays to a text file,"Task

Write two equal-sized numerical arrays 'x' and 'y' to
a two-column text file named 'filename'.

The first column of the file contains values from an 'x'-array with a
given 'xprecision', the second -- values from 'y'-array with 'yprecision'.

For example, considering:

   x = {1, 2, 3, 1e11};
   y = {1, 1.4142135623730951, 1.7320508075688772, 316227.76601683791}; 
                                                          /* sqrt(x) */
   xprecision = 3;
   yprecision = 5;

The file should look like:

   1    1
   2    1.4142
   3    1.7321
   1e+011   3.1623e+005

This task is intended as a subtask for Measure relative performance of sorting algorithms implementations.



",#C.23,C#,"using System.IO;
 
class Program
{
    static void Main(string[] args)
    {
        var x = new double[] { 1, 2, 3, 1e11 };
        var y = new double[] { 1, 1.4142135623730951, 1.7320508075688772, 316227.76601683791 };
 
        int xprecision = 3;
        int yprecision = 5;
 
        string formatString = ""{0:G"" + xprecision + ""}\t{1:G"" + yprecision + ""}"";
 
        using (var outf = new StreamWriter(""FloatArrayColumns.txt""))
            for (int i = 0; i < x.Length; i++)
                outf.WriteLine(formatString, x[i], y[i]);
    }
}",546,19
2456,http://rosettacode.org/wiki/XML/DOM_serialization,XML/DOM serialization,"Create a simple DOM and having it serialize to:

 <?xml version=""1.0"" ?>
 <root>
     <element>
         Some text here
     </element>
 </root>
",#C.23,C#,"using System.Xml;
using System.Xml.Serialization;
[XmlRoot(""root"")]
public class ExampleXML
{
    [XmlElement(""element"")]
    public string element = ""Some text here"";
    static void Main(string[] args)
    {
        var xmlnamespace = new XmlSerializerNamespaces();
        xmlnamespace.Add("""", """"); //used to stop default namespaces from printing
        var writer = XmlWriter.Create(""output.xml"");
        new XmlSerializer(typeof(ExampleXML)).Serialize(writer, new ExampleXML(), xmlnamespace);
    }
    //Output: <?xml version=""1.0"" encoding=""utf-8""?><root><element>Some text here</element></root>
}",606,16
2522,http://rosettacode.org/wiki/World_Cup_group_stage,World Cup group stage,"It's World Cup season (or at least it was when this page was created)!

The World Cup is an international football/soccer tournament that happens every 4 years.   Countries put their international teams together in the years between tournaments and qualify for the tournament based on their performance in other international games.   Once a team has qualified they are put into a group with 3 other teams.

For the first part of the World Cup tournament the teams play in ""group stage"" games where each of the four teams in a group plays all three other teams once.   The results of these games determine which teams will move on to the ""knockout stage"" which is a standard single-elimination tournament.   The two teams from each group with the most standings points move on to the knockout stage.

Each game can result in a win for one team and a loss for the other team or it can result in a draw/tie for each team.

   A win is worth three points.
   A draw/tie is worth one point. 
   A loss is worth zero points.


Task

   Generate all possible outcome combinations for the six group stage games.   With three possible outcomes for each game there should be 36 = 729 of them. 
   Calculate the standings points for each team with each combination of outcomes. 
   Show a histogram (graphical,   ASCII art, or straight counts--whichever is easiest/most fun) of the standings points for all four teams over all possible outcomes.


Don't worry about tiebreakers as they can get complicated.   We are basically looking to answer the question ""if a team gets x standings points, where can they expect to end up in the group standings?"".

Hint: there should be no possible way to end up in second place with less than two points as well as no way to end up in first with less than three.   Oddly enough, there is no way to get 8 points at all.
",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using static System.Console;
using static System.Linq.Enumerable;
 
namespace WorldCupGroupStage
{
    public static class WorldCupGroupStage
    {
        static int[][] _histogram;
 
        static WorldCupGroupStage()
        {
            int[] scoring = new[] { 0, 1, 3 };
 
            _histogram = Repeat<Func<int[]>>(()=>new int[10], 4).Select(f=>f()).ToArray();
 
            var teamCombos = Range(0, 4).Combinations(2).Select(t2=>t2.ToArray()).ToList();
 
            foreach (var results in Range(0, 3).CartesianProduct(6))
            {
                var points = new int[4]; 
 
                foreach (var (result, teams) in results.Zip(teamCombos, (r, t) => (r, t)))
                {
                    points[teams[0]] += scoring[result];
                    points[teams[1]] += scoring[2 - result];
                }
 
                foreach(var (p,i) in points.OrderByDescending(a => a).Select((p,i)=>(p,i)))
                    _histogram[i][p]++;
            }
        }
 
       // https://gist.github.com/martinfreedman/139dd0ec7df4737651482241e48b062f
 
       static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> seqs) => 
            seqs.Aggregate(Empty<T>().ToSingleton(), (acc, sq) => acc.SelectMany(a => sq.Select(s => a.Append(s))));
 
       static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<T> seq, int repeat = 1) => 
            Repeat(seq, repeat).CartesianProduct();
 
       static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq) => 
            seq.Aggregate(Empty<T>().ToSingleton(), (a, b) => a.Concat(a.Select(x => x.Append(b))));
 
       static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq, int numItems) => 
            seq.Combinations().Where(s => s.Count() == numItems);
 
        private static IEnumerable<T> ToSingleton<T>(this T item) { yield return item; }
 
        static new string ToString()
        {
            var sb = new StringBuilder();
 
            var range = String.Concat(Range(0, 10).Select(i => $""{i,-3} ""));
            sb.AppendLine($""Points      : {range}"");
 
            var u = String.Concat(Repeat(""─"", 40+13));
            sb.AppendLine($""{u}"");
 
            var places = new[] { ""First"", ""Second"", ""Third"", ""Fourth"" };
            foreach (var row in _histogram.Select((r, i) => (r, i)))
            {
                sb.Append($""{places[row.i],-6} place: "");
                foreach (var standing in row.r)
                    sb.Append($""{standing,-3} "");
                sb.Append(""\n"");
            }
 
            return sb.ToString();
        }
 
        static void Main(string[] args)
        {
            Write(ToString());
            Read();
        }
    }
}
 ",2846,82
2604,http://rosettacode.org/wiki/Xiaolin_Wu%27s_line_algorithm,Xiaolin Wu's line algorithm,"Task

Implement the   Xiaolin Wu's line algorithm   described in Wikipedia.



This algorithm draws anti-aliased lines.



Related task

   See   Bresenham's line algorithm   for aliased lines.

",#C.23,C#," 
public class Line
    {
        private double x0, y0, x1, y1;
        private Color foreColor;
        private byte lineStyleMask;
        private int thickness;
        private float globalm;
 
        public Line(double x0, double y0, double x1, double y1, Color color, byte lineStyleMask, int thickness)
        {
            this.x0 = x0;
            this.y0 = y0;
            this.y1 = y1;
            this.x1 = x1;
 
            this.foreColor = color;
 
            this.lineStyleMask = lineStyleMask;
 
            this.thickness = thickness;
 
        }
 
        private void plot(Bitmap bitmap, double x, double y, double c)
        {
            int alpha = (int)(c * 255);
            if (alpha > 255) alpha = 255;
            if (alpha < 0) alpha = 0;
            Color color = Color.FromArgb(alpha, foreColor);
            if (BitmapDrawHelper.checkIfInside((int)x, (int)y, bitmap))
            {
                bitmap.SetPixel((int)x, (int)y, color);
            }
        }
 
        int ipart(double x) { return (int)x;}
 
        int round(double x) {return ipart(x+0.5);}
 
        double fpart(double x) {
            if(x<0) return (1-(x-Math.Floor(x)));
            return (x-Math.Floor(x));
        }
 
        double rfpart(double x) {
            return 1-fpart(x);
        }
 
 
        public void draw(Bitmap bitmap) {
            bool steep = Math.Abs(y1-y0)>Math.Abs(x1-x0);
             double temp;
            if(steep){
                temp=x0; x0=y0; y0=temp;
                temp=x1;x1=y1;y1=temp;
            }
            if(x0>x1){
                temp = x0;x0=x1;x1=temp;
                temp = y0;y0=y1;y1=temp;
            }
 
            double dx = x1-x0;
            double dy = y1-y0;
            double gradient = dy/dx;
 
            double xEnd = round(x0);
            double yEnd = y0+gradient*(xEnd-x0);
            double xGap = rfpart(x0+0.5);
            double xPixel1 = xEnd;
            double yPixel1 = ipart(yEnd);
 
            if(steep){
                plot(bitmap, yPixel1,   xPixel1, rfpart(yEnd)*xGap);
                plot(bitmap, yPixel1+1, xPixel1,  fpart(yEnd)*xGap);
            }else{
                plot(bitmap, xPixel1,yPixel1, rfpart(yEnd)*xGap);
                plot(bitmap, xPixel1, yPixel1+1, fpart(yEnd)*xGap);
            }
            double intery = yEnd+gradient;
 
            xEnd = round(x1);
            yEnd = y1+gradient*(xEnd-x1);
            xGap = fpart(x1+0.5);
            double xPixel2 = xEnd;
            double yPixel2 = ipart(yEnd);
            if(steep){
                plot(bitmap, yPixel2,   xPixel2, rfpart(yEnd)*xGap);
                plot(bitmap, yPixel2+1, xPixel2, fpart(yEnd)*xGap);
            }else{
                plot(bitmap, xPixel2, yPixel2, rfpart(yEnd)*xGap);
                plot(bitmap, xPixel2, yPixel2+1, fpart(yEnd)*xGap);
            }
 
            if(steep){
                for(int x=(int)(xPixel1+1);x<=xPixel2-1;x++){
                    plot(bitmap, ipart(intery), x, rfpart(intery));
                    plot(bitmap, ipart(intery)+1, x, fpart(intery));
                    intery+=gradient;
                }
            }else{
                for(int x=(int)(xPixel1+1);x<=xPixel2-1;x++){
                    plot(bitmap, x,ipart(intery), rfpart(intery));
                    plot(bitmap, x, ipart(intery)+1, fpart(intery));
                    intery+=gradient;
                }
            }
        }
    }
 ",3450,110
2623,http://rosettacode.org/wiki/XML/Output,XML/Output,"Create a function that takes a list of character names and a list of corresponding remarks and returns an XML document of <Character> elements each with a name attributes and each enclosing its remarks.
All <Character> elements are to be enclosed in turn, in an outer <CharacterRemarks> element.

As an example, calling the function with the three names of:

April
Tam O'Shanter
Emily
And three remarks of:

Bubbly: I'm > Tam and <= Emily
Burns: ""When chapman billies leave the street ...""
Short & shrift
Should produce the XML (but not necessarily with the indentation):

<CharacterRemarks>
    <Character name=""April"">Bubbly: I'm &gt; Tam and &lt;= Emily</Character>
    <Character name=""Tam O'Shanter"">Burns: ""When chapman billies leave the street ...""</Character>
    <Character name=""Emily"">Short &amp; shrift</Character>
</CharacterRemarks>
The document may include an <?xml?> declaration and document type declaration, but these are optional. If attempting this task by direct string manipulation, the implementation must include code to perform entity substitution for the characters that have entities defined in the XML 1.0 specification.

Note: the example is chosen to show correct escaping of XML strings.
Note too that although the task is written to take two lists of corresponding data, a single mapping/hash/dictionary of names to remarks is also acceptable.

Note to editors: Program output with escaped characters will be viewed as the character on the page so you need to 'escape-the-escapes' to make the RC entry display what would be shown in a plain text viewer (See this).
Alternately, output can be placed in <lang xml></lang> tags without any special treatment.
",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
 
class Program
{
    static string CreateXML(Dictionary<string, string> characterRemarks)
    {
        var remarks = characterRemarks.Select(r => new XElement(""Character"", r.Value, new XAttribute(""Name"", r.Key)));
        var xml = new XElement(""CharacterRemarks"", remarks);
        return xml.ToString();
    }
 
    static void Main(string[] args)
    {
        var characterRemarks = new Dictionary<string, string>
        {
            { ""April"", ""Bubbly: I'm > Tam and <= Emily"" },
            { ""Tam O'Shanter"", ""Burns: \""When chapman billies leave the street ...\"""" },
            { ""Emily"", ""Short & shrift"" }
        };
 
        string xml = CreateXML(characterRemarks);
        Console.WriteLine(xml);
    }
}",812,27
2640,http://rosettacode.org/wiki/XML/Input,XML/Input,"Given the following XML fragment, extract the list of student names using whatever means desired. If the only viable method is to use XPath, refer the reader to the task XML and XPath.

<Students>
  <Student Name=""April"" Gender=""F"" DateOfBirth=""1989-01-02"" />
  <Student Name=""Bob"" Gender=""M""  DateOfBirth=""1990-03-04"" />
  <Student Name=""Chad"" Gender=""M""  DateOfBirth=""1991-05-06"" />
  <Student Name=""Dave"" Gender=""M""  DateOfBirth=""1992-07-08"">
    <Pet Type=""dog"" Name=""Rover"" />
  </Student>
  <Student DateOfBirth=""1993-09-10"" Gender=""F"" Name=""&#x00C9;mily"" />
</Students>
Expected Output

April
Bob
Chad
Dave
Émily
",#C.23,C#," 
class Program
{
    static void Main(string[] args)
    {   
        XDocument xmlDoc = XDocument.Load(""XMLFile1.xml"");
        var query = from p in xmlDoc.Descendants(""Student"")
                    select p.Attribute(""Name"");
 
        foreach (var item in query)
        {
            Console.WriteLine(item.Value);
        }
        Console.ReadLine();
    }  
}
 ",370,17
2700,http://rosettacode.org/wiki/Write_language_name_in_3D_ASCII,Write language name in 3D ASCII,"Task

Write/display a language's name in 3D ASCII.



(We can leave the definition of ""3D ASCII"" fuzzy,
so long as the result is interesting or amusing,
not a cheap hack to satisfy the task.)



Related tasks

 draw a sphere
 draw a cuboid
 draw a rotating cube
 draw a Deathstar

",#C.23,C#,"using System;
using System.Text;
 
namespace Language_name_in_3D_ascii
{
    public class F5
    {
        char[] z = { ' ', ' ', '_', '/', };
        long[,] f ={
            {87381,87381,87381,87381,87381,87381,87381,},
            {349525,375733,742837,742837,375733,349525,349525,},
            {742741,768853,742837,742837,768853,349525,349525,},
            {349525,375733,742741,742741,375733,349525,349525,},
            {349621,375733,742837,742837,375733,349525,349525,},
            {349525,375637,768949,742741,375733,349525,349525,},
            {351157,374101,768949,374101,374101,349525,349525,},
            {349525,375733,742837,742837,375733,349621,351157,},
            {742741,768853,742837,742837,742837,349525,349525,},
            {181,85,181,181,181,85,85,},
            {1461,1365,1461,1461,1461,1461,2901,},
            {742741,744277,767317,744277,742837,349525,349525,},
            {181,181,181,181,181,85,85,},
            {1431655765,3149249365L,3042661813L,3042661813L,3042661813L,1431655765,1431655765,},
            {349525,768853,742837,742837,742837,349525,349525,},
            {349525,375637,742837,742837,375637,349525,349525,},
            {349525,768853,742837,742837,768853,742741,742741,},
            {349525,375733,742837,742837,375733,349621,349621,},
            {349525,744373,767317,742741,742741,349525,349525,},
            {349525,375733,767317,351157,768853,349525,349525,},
            {374101,768949,374101,374101,351157,349525,349525,},
            {349525,742837,742837,742837,375733,349525,349525,},
            {5592405,11883957,11883957,5987157,5616981,5592405,5592405,},
            {366503875925L,778827027893L,778827027893L,392374737749L,368114513237L,366503875925L,366503875925L,},
            {349525,742837,375637,742837,742837,349525,349525,},
            {349525,742837,742837,742837,375733,349621,375637,},
            {349525,768949,351061,374101,768949,349525,349525,},
            {375637,742837,768949,742837,742837,349525,349525,},
            {768853,742837,768853,742837,768853,349525,349525,},
            {375733,742741,742741,742741,375733,349525,349525,},
            {192213,185709,185709,185709,192213,87381,87381,},
            {1817525,1791317,1817429,1791317,1817525,1398101,1398101,},
            {768949,742741,768853,742741,742741,349525,349525,},
            {375733,742741,744373,742837,375733,349525,349525,},
            {742837,742837,768949,742837,742837,349525,349525,},
            {48053,23381,23381,23381,48053,21845,21845,},
            {349621,349621,349621,742837,375637,349525,349525,},
            {742837,744277,767317,744277,742837,349525,349525,},
            {742741,742741,742741,742741,768949,349525,349525,},
            {11883957,12278709,11908533,11883957,11883957,5592405,5592405,},
            {11883957,12277173,11908533,11885493,11883957,5592405,5592405,},
            {375637,742837,742837,742837,375637,349525,349525,},
            {768853,742837,768853,742741,742741,349525,349525,},
            {6010197,11885397,11909973,11885397,6010293,5592405,5592405,},
            {768853,742837,768853,742837,742837,349525,349525,},
            {375733,742741,375637,349621,768853,349525,349525,},
            {12303285,5616981,5616981,5616981,5616981,5592405,5592405,},
            {742837,742837,742837,742837,375637,349525,349525,},
            {11883957,11883957,11883957,5987157,5616981,5592405,5592405,},
            {3042268597L,3042268597L,3042661813L,1532713813,1437971797,1431655765,1431655765,},
            {11883957,5987157,5616981,5987157,11883957,5592405,5592405,},
            {11883957,5987157,5616981,5616981,5616981,5592405,5592405,},
            {12303285,5593941,5616981,5985621,12303285,5592405,5592405,}
            };
 
        private F5(string s)
        {
            StringBuilder[] o = new StringBuilder[7];
            for (int i = 0; i < 7; i++) o[i] = new StringBuilder();
            for (int i = 0, l = s.Length; i < l; i++)
            {
                int c = s[i];
                if (65 <= c && c <= 90) c -= 39;
                else if (97 <= c && c <= 122) c -= 97;
                else c = -1;
                long[] d = new long[7];
                Buffer.BlockCopy(f, (++c * sizeof(long) * 7), d, 0, 7 * sizeof(long));
                for (int j = 0; j < 7; j++)
                {
                    StringBuilder b = new StringBuilder();
                    long v = d[j];
                    while (v > 0)
                    {
                        b.Append(z[(int)(v & 3)]);
                        v >>= 2;
                    }
                    char[] charArray = b.ToString().ToCharArray();
                    Array.Reverse(charArray);
                    o[j].Append(new string(charArray));
                }
            }
            for (int i = 0; i < 7; i++)
            {
                for (int j = 0; j < 7 - i; j++)
                    System.Console.Write(' ');
                System.Console.WriteLine(o[i]);
            }
        }
 
        public static void Main(string[] args)
        {
            new F5(args.Length > 0 ? args[0] : ""C sharp"");
        }
    }
}",5148,104
2735,http://rosettacode.org/wiki/Word_search,Word search,"A word search puzzle typically consists of a grid of letters in which words are hidden.

There are many varieties of word search puzzles. For the task at hand we will use a rectangular grid in which the words may be placed horizontally, vertically, or diagonally. The words may also be spelled backwards.

The words may overlap but are not allowed to zigzag, or wrap around.




Task 
Create a 10 by 10 word search and fill it using words from the unixdict. Use only words that are longer than 2, and contain no non-alphabetic characters.

The cells not used by the hidden words should contain the message: Rosetta Code, read from left to right, top to bottom. These letters should be somewhat evenly distributed over the grid, not clumped together. The message should be in upper case, the hidden words in lower case. All cells should either contain letters from the hidden words or from the message.

Pack a minimum of 25 words into the grid.

Print the resulting grid and the solutions.




Example
     0  1  2  3  4  5  6  7  8  9

0    n  a  y  r  y  R  e  l  m  f 
1    y  O  r  e  t  s  g  n  a  g 
2    t  n  e  d  i  S  k  y  h  E 
3    n  o  t  n  c  p  c  w  t  T 
4    a  l  s  u  u  n  T  m  a  x 
5    r  o  k  p  a  r  i  s  h  h 
6    a  A  c  f  p  a  e  a  c  C 
7    u  b  u  t  t  t  O  l  u  n 
8    g  y  h  w  a  D  h  p  m  u 
9    m  i  r  p  E  h  o  g  a  n 

parish     (3,5)(8,5)   gangster   (9,1)(2,1)
paucity    (4,6)(4,0)   guaranty   (0,8)(0,1)
prim       (3,9)(0,9)   huckster   (2,8)(2,1)
plasm      (7,8)(7,4)   fancy      (3,6)(7,2)
hogan      (5,9)(9,9)   nolo       (1,2)(1,5)
under      (3,4)(3,0)   chatham    (8,6)(8,0)
ate        (4,8)(6,6)   nun        (9,7)(9,9)
butt       (1,7)(4,7)   hawk       (9,5)(6,2)
why        (3,8)(1,8)   ryan       (3,0)(0,0)
fay        (9,0)(7,2)   much       (8,8)(8,5)
tar        (5,7)(5,5)   elm        (6,0)(8,0)
max        (7,4)(9,4)   pup        (5,3)(3,5)
mph        (8,8)(6,8)




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
 
namespace Wordseach
{
    static class Program
    {
        readonly static int[,] dirs = {{1, 0}, {0, 1}, {1, 1}, {1, -1}, {-1, 0},
            {0, -1}, {-1, -1}, {-1, 1}};
 
        class Grid
        {
            public char[,] Cells = new char[nRows, nCols];
            public List<string> Solutions = new List<string>();
            public int NumAttempts;
        }
 
        readonly static int nRows = 10;
        readonly static int nCols = 10;
        readonly static int gridSize = nRows * nCols;
        readonly static int minWords = 25;
 
        readonly static Random rand = new Random();
 
        static void Main(string[] args)
        {
            PrintResult(CreateWordSearch(ReadWords(""unixdict.txt"")));
        }
 
        private static List<string> ReadWords(string filename)
        {
            int maxLen = Math.Max(nRows, nCols);
 
            return System.IO.File.ReadAllLines(filename)
                .Select(s => s.Trim().ToLower())
                .Where(s => Regex.IsMatch(s, ""^[a-z]{3,"" + maxLen + ""}$""))
                .ToList();
        }
 
        private static Grid CreateWordSearch(List<string> words)
        {
            int numAttempts = 0;
 
            while (++numAttempts < 100)
            {
                words.Shuffle();
 
                var grid = new Grid();
                int messageLen = PlaceMessage(grid, ""Rosetta Code"");
                int target = gridSize - messageLen;
 
                int cellsFilled = 0;
                foreach (var word in words)
                {
                    cellsFilled += TryPlaceWord(grid, word);
                    if (cellsFilled == target)
                    {
                        if (grid.Solutions.Count >= minWords)
                        {
                            grid.NumAttempts = numAttempts;
                            return grid;
                        }
                        else break; // grid is full but we didn't pack enough words, start over
                    }
                }
            }
            return null;
        }
 
        private static int TryPlaceWord(Grid grid, string word)
        {
            int randDir = rand.Next(dirs.GetLength(0));
            int randPos = rand.Next(gridSize);
 
            for (int dir = 0; dir < dirs.GetLength(0); dir++)
            {
                dir = (dir + randDir) % dirs.GetLength(0);
 
                for (int pos = 0; pos < gridSize; pos++)
                {
                    pos = (pos + randPos) % gridSize;
 
                    int lettersPlaced = TryLocation(grid, word, dir, pos);
                    if (lettersPlaced > 0)
                        return lettersPlaced;
                }
            }
            return 0;
        }
 
        private static int TryLocation(Grid grid, string word, int dir, int pos)
        {
            int r = pos / nCols;
            int c = pos % nCols;
            int len = word.Length;
 
            //  check bounds
            if ((dirs[dir, 0] == 1 && (len + c) > nCols)
                    || (dirs[dir, 0] == -1 && (len - 1) > c)
                    || (dirs[dir, 1] == 1 && (len + r) > nRows)
                    || (dirs[dir, 1] == -1 && (len - 1) > r))
                return 0;
 
            int rr, cc, i, overlaps = 0;
 
            // check cells
            for (i = 0, rr = r, cc = c; i < len; i++)
            {
                if (grid.Cells[rr, cc] != 0 && grid.Cells[rr, cc] != word[i])
                {
                    return 0;
                }
 
                cc += dirs[dir, 0];
                rr += dirs[dir, 1];
            }
 
            // place
            for (i = 0, rr = r, cc = c; i < len; i++)
            {
                if (grid.Cells[rr, cc] == word[i])
                    overlaps++;
                else
                    grid.Cells[rr, cc] = word[i];
 
                if (i < len - 1)
                {
                    cc += dirs[dir, 0];
                    rr += dirs[dir, 1];
                }
            }
 
            int lettersPlaced = len - overlaps;
            if (lettersPlaced > 0)
            {
                grid.Solutions.Add($""{word,-10} ({c},{r})({cc},{rr})"");
            }
 
            return lettersPlaced;
        }
 
        private static int PlaceMessage(Grid grid, string msg)
        {
            msg = Regex.Replace(msg.ToUpper(), ""[^A-Z]"", """");
 
            int messageLen = msg.Length;
            if (messageLen > 0 && messageLen < gridSize)
            {
                int gapSize = gridSize / messageLen;
 
                for (int i = 0; i < messageLen; i++)
                {
                    int pos = i * gapSize + rand.Next(gapSize);
                    grid.Cells[pos / nCols, pos % nCols] = msg[i];
                }
                return messageLen;
            }
            return 0;
        }
 
        public static void Shuffle<T>(this IList<T> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = rand.Next(n + 1);
                T value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }
 
        private static void PrintResult(Grid grid)
        {
            if (grid == null || grid.NumAttempts == 0)
            {
                Console.WriteLine(""No grid to display"");
                return;
            }
            int size = grid.Solutions.Count;
 
            Console.WriteLine(""Attempts: "" + grid.NumAttempts);
            Console.WriteLine(""Number of words: "" + size);
 
            Console.WriteLine(""\n     0  1  2  3  4  5  6  7  8  9"");
            for (int r = 0; r < nRows; r++)
            {
                Console.Write(""\n{0}   "", r);
                for (int c = 0; c < nCols; c++)
                    Console.Write("" {0} "", grid.Cells[r, c]);
            }
 
            Console.WriteLine(""\n"");
 
            for (int i = 0; i < size - 1; i += 2)
            {
                Console.WriteLine(""{0}   {1}"", grid.Solutions[i],
                        grid.Solutions[i + 1]);
            }
            if (size % 2 == 1)
                Console.WriteLine(grid.Solutions[size - 1]);
 
            Console.ReadLine();
        }        
    }
}",6388,209
2883,http://rosettacode.org/wiki/Word_wrap,Word wrap,"Even today, with proportional fonts and complex layouts, there are still cases where you need to wrap text at a specified column.



Basic task

The basic task is to wrap a paragraph of text in a simple way in your language.

If there is a way to do this that is built-in, trivial, or provided in a standard library, show that. Otherwise implement the minimum length greedy algorithm from Wikipedia.

Show your routine working on a sample of text at two different wrap columns.



Extra credit

Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX algorithm.
If your language provides this, you get easy extra credit,
but you must reference documentation indicating that the algorithm
is something better than a simple minimum length algorithm.

If you have both basic and extra credit solutions, show an example where
the two algorithms give different results.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"namespace RosettaCode.WordWrap
{
    using System;
    using System.Collections.Generic;
 
    internal static class Program
    {
        private const string LoremIpsum = @""
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas varius sapien
vel purus hendrerit vehicula. Integer hendrerit viverra turpis, ac sagittis arcu
pharetra id. Sed dapibus enim non dui posuere sit amet rhoncus tellus
consectetur. Proin blandit lacus vitae nibh tincidunt cursus. Cum sociis natoque
penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nam tincidunt
purus at tortor tincidunt et aliquam dui gravida. Nulla consectetur sem vel
felis vulputate et imperdiet orci pharetra. Nam vel tortor nisi. Sed eget porta
tortor. Aliquam suscipit lacus vel odio faucibus tempor. Sed ipsum est,
condimentum eget eleifend ac, ultricies non dui. Integer tempus, nunc sed
venenatis feugiat, augue orci pellentesque risus, nec pretium lacus enim eu
nibh."";
 
        private static void Main()
        {
            foreach (var lineWidth in new[] { 72, 80 })
            {
                Console.WriteLine(new string('-', lineWidth));
                Console.WriteLine(Wrap(LoremIpsum, lineWidth));
            }
        }
 
        private static string Wrap(string text, int lineWidth)
        {
            return string.Join(string.Empty,
                               Wrap(
                                   text.Split(new char[0],
                                              StringSplitOptions
                                                  .RemoveEmptyEntries),
                                   lineWidth));
        }
 
        private static IEnumerable<string> Wrap(IEnumerable<string> words,
                                                int lineWidth)
        {
            var currentWidth = 0;
            foreach (var word in words)
            {
                if (currentWidth != 0)
                {
                    if (currentWidth + word.Length < lineWidth)
                    {
                        currentWidth++;
                        yield return "" "";
                    }
                    else
                    {
                        currentWidth = 0;
                        yield return Environment.NewLine;
                    }
                }
                currentWidth += word.Length;
                yield return word;
            }
        }
    }
}",2417,64
2936,http://rosettacode.org/wiki/Window_creation,Window creation,"Display a GUI window. The window need not have any contents, but should respond to requests to be closed.
",#C.23,C#,"using System;
using System.Windows.Forms;
 
public class Window {
    [STAThread]
    static void Main() {
        Form form = new Form();
 
        form.Text = ""Window"";
        form.Disposed += delegate { Application.Exit(); };
 
        form.Show();
        Application.Run();
    }
}",287,15
2957,http://rosettacode.org/wiki/Wieferich_primes,Wieferich primes,"

 This page uses content from Wikipedia. The original article was at Wieferich prime. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In number theory, a Wieferich prime is a prime number  p  such that  p2  evenly divides  2(p − 1) − 1 .



It is conjectured that there are infinitely many Wieferich primes, but as of March 2021,only two have been identified.



Task 
 Write a routine (function procedure, whatever) to find Wieferich primes.
 Use that routine to identify and display all of the Wieferich primes less than 5000.


See also
 OEIS A001220 - Wieferich primes

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace WieferichPrimes {
    class Program {
        static long ModPow(long @base, long exp, long mod) {
            if (mod == 1) {
                return 0;
            }
 
            long result = 1;
            @base %= mod;
            for (; exp > 0; exp >>= 1) {
                if ((exp & 1) == 1) {
                    result = (result * @base) % mod;
                }
                @base = (@base * @base) % mod;
            }
            return result;
        }
 
        static bool[] PrimeSieve(int limit) {
            bool[] sieve = Enumerable.Repeat(true, limit).ToArray();
 
            if (limit > 0) {
                sieve[0] = false;
            }
            if (limit > 1) {
                sieve[1] = false;
            }
 
            for (int i = 4; i < limit; i += 2) {
                sieve[i] = false;
            }
 
            for (int p = 3; ; p += 2) {
                int q = p * p;
                if (q >= limit) {
                    break;
                }
                if (sieve[p]) {
                    int inc = 2 * p;
                    for (; q < limit; q += inc) {
                        sieve[q] = false;
                    }
                }
            }
 
            return sieve;
        }
 
        static List<int> WiefreichPrimes(int limit) {
            bool[] sieve = PrimeSieve(limit);
            List<int> result = new List<int>();
            for (int p = 2; p < limit; p++) {
                if (sieve[p] && ModPow(2, p - 1, p * p) == 1) {
                    result.Add(p);
                }
            }
            return result;
        }
 
        static void Main() {
            const int limit = 5000;
            Console.WriteLine(""Wieferich primes less that {0}:"", limit);
            foreach (int p in WiefreichPrimes(limit)) {
                Console.WriteLine(p);
            }
        }
    }
}",1957,72
2976,http://rosettacode.org/wiki/Weird_numbers,Weird numbers,"In number theory, a weird number is a natural number that is abundant but not semiperfect (and therefore not perfect either).

In other words, the sum of the proper divisors of the number (divisors including 1 but not itself) is greater than the number itself (the number is abundant), but no subset of those divisors sums to the number itself (the number is not semiperfect).

For example:

 12 is not a weird number.
 It is abundant; its proper divisors 1, 2, 3, 4, 6 sum to 16 (which is > 12),
 but it is semiperfect, e.g.:     6 + 4 + 2 == 12.
 70 is a weird number.
 It is abundant; its proper divisors 1, 2, 5, 7, 10, 14, 35 sum to 74 (which is > 70),
 and there is no subset of proper divisors that sum to 70.


Task

Find and display, here on this page, the first 25 weird numbers.



Related tasks

 Abundant, deficient and perfect number classifications
 Proper divisors


See also

 OEIS: A006037 weird numbers
 Wikipedia: weird number
 MathWorld: weird number

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace WeirdNumbers {
    class Program {
        static List<int> Divisors(int n) {
            List<int> divs = new List<int> { 1 };
            List<int> divs2 = new List<int>();
 
            for (int i = 2; i * i <= n; i++) {
                if (n % i == 0) {
                    int j = n / i;
                    divs.Add(i);
                    if (i != j) {
                        divs2.Add(j);
                    }
                }
            }
 
            divs.Reverse();
            divs2.AddRange(divs);
            return divs2;
        }
 
        static bool Abundant(int n, List<int> divs) {
            return divs.Sum() > n;
        }
 
        static bool Semiperfect(int n, List<int> divs) {
            if (divs.Count > 0) {
                var h = divs[0];
                var t = divs.Skip(1).ToList();
                if (n < h) {
                    return Semiperfect(n, t);
                } else {
                    return n == h
                        || Semiperfect(n - h, t)
                        || Semiperfect(n, t);
                }
            } else {
                return false;
            }
        }
 
        static List<bool> Sieve(int limit) {
            // false denotes abundant and not semi-perfect.
            // Only interested in even numbers >= 2
            bool[] w = new bool[limit];
            for (int i = 2; i < limit; i += 2) {
                if (w[i]) continue;
                var divs = Divisors(i);
                if (!Abundant(i, divs)) {
                    w[i] = true;
                } else if (Semiperfect(i, divs)) {
                    for (int j = i; j < limit; j += i) {
                        w[j] = true;
                    }
                }
            }
            return w.ToList();
        }
 
        static void Main() {
            var w = Sieve(17_000);
            int count = 0;
            int max = 25;
            Console.WriteLine(""The first 25 weird numbers:"");
            for (int n = 2; count < max; n += 2) {
                if (!w[n]) {
                    Console.Write(""{0} "", n);
                    count++;
                }
            }
            Console.WriteLine();
        }
    }
}",2333,80
3013,http://rosettacode.org/wiki/Wireworld,Wireworld,"Wireworld
Conway's Game of Life
It is capable of doing sophisticated computations with appropriate programs
(it is actually Turing complete),
and is much simpler to program for.

A Wireworld arena consists of a Cartesian grid of cells,
each of which can be in one of four states.
All cell transitions happen simultaneously.

The cell transition rules are this:



 Input State

 Output State

 Condition


 empty

 empty




 electron head 

 electron tail 




 electron tail 

 conductor




 conductor

 electron head 

 if 1 or 2 cells in the neighborhood of the cell are in the state “electron head”


 conductor

 conductor

 otherwise



Task

Create a program that reads a Wireworld program from a file and displays an animation of the processing. Here is a sample description file (using ""H"" for an electron head, ""t"" for a tail, ""."" for a conductor and a space for empty) you may wish to test with, which demonstrates two cycle-3 generators and an inhibit gate:

tH.........
.   .
   ...
.   .
Ht.. ......

While text-only implementations of this task are possible, mapping cells to pixels is advisable if you wish to be able to display large designs. The logic is not significantly more complex.



",#C.23,C#,"#include <ggi/ggi.h>
#include <set>
#include <map>
#include <utility>
#include <iostream>
#include <fstream>
#include <string>
 
#include <unistd.h> // for usleep
 
enum cell_type { none, wire, head, tail };
 
// *****************
// * display class *
// *****************
 
// this is just a small wrapper for the ggi interface
 
class display
{
public:
  display(int sizex, int sizey, int pixsizex, int pixsizey,
          ggi_color* colors);
  ~display()
  {
    ggiClose(visual);
    ggiExit();
  }
 
  void flush();
  bool keypressed() { return ggiKbhit(visual); }
  void clear();
  void putpixel(int x, int y, cell_type c);
private:
  ggi_visual_t visual;
  int size_x, size_y;
  int pixel_size_x, pixel_size_y;
  ggi_pixel pixels[4];
};
 
display::display(int sizex, int sizey, int pixsizex, int pixsizey,
                 ggi_color* colors):
  pixel_size_x(pixsizex),
  pixel_size_y(pixsizey)
{
  if (ggiInit() < 0)
  {
    std::cerr << ""couldn't open ggi\n"";
    exit(1);
  }
 
  visual = ggiOpen(NULL);
  if (!visual)
  {
    ggiPanic(""couldn't open visual\n"");
  }
 
  ggi_mode mode;
  if (ggiCheckGraphMode(visual, sizex, sizey,
                        GGI_AUTO, GGI_AUTO, GT_4BIT,
                        &mode) != 0)
  {
    if (GT_DEPTH(mode.graphtype) < 2) // we need 4 colors!
      ggiPanic(""low-color displays are not supported!\n"");
  }
  if (ggiSetMode(visual, &mode) != 0)
  {
    ggiPanic(""couldn't set graph mode\n"");
  }
  ggiAddFlags(visual, GGIFLAG_ASYNC);
 
  size_x = mode.virt.x;
  size_y = mode.virt.y;
 
  for (int i = 0; i < 4; ++i)
    pixels[i] = ggiMapColor(visual, colors+i);
}
 
void display::flush()
{
  // set the current display frame to the one we have drawn to
  ggiSetDisplayFrame(visual, ggiGetWriteFrame(visual));
 
  // flush the current visual
  ggiFlush(visual);
 
  // try to set a different frame for drawing (errors are ignored; if
  // setting the new frame fails, the current one will be drawn upon,
  // with the only adverse effect being some flickering).
  ggiSetWriteFrame(visual, 1-ggiGetDisplayFrame(visual));
}
 
void display::clear()
{
  ggiSetGCForeground(visual, pixels[0]);
  ggiDrawBox(visual, 0, 0, size_x, size_y);
}
 
void display::putpixel(int x, int y, cell_type cell)
{
  // this draws a logical pixel (i.e. a rectangle of size pixel_size_x
  // times pixel_size_y), not a physical pixel
  ggiSetGCForeground(visual, pixels[cell]);
  ggiDrawBox(visual,
             x*pixel_size_x, y*pixel_size_y,
             pixel_size_x, pixel_size_y);
}
 
// *****************
// * the wireworld *
// *****************
 
// initialized to an empty wireworld
class wireworld
{
public:
  void set(int posx, int posy, cell_type type);
  void draw(display& destination);
  void step();
private:
  typedef std::pair<int, int> position;
  typedef std::set<position> position_set;
  typedef position_set::iterator positer;
  position_set wires, heads, tails;
};
 
void wireworld::set(int posx, int posy, cell_type type)
{
  position p(posx, posy);
  wires.erase(p);
  heads.erase(p);
  tails.erase(p);
  switch(type)
  {
  case head:
    heads.insert(p);
    break;
  case tail:
    tails.insert(p);
    break;
  case wire:
    wires.insert(p);
    break;
  }
}
 
void wireworld::draw(display& destination)
{
  destination.clear();
  for (positer i = heads.begin(); i != heads.end(); ++i)
    destination.putpixel(i->first, i->second, head);
  for (positer i = tails.begin(); i != tails.end(); ++i)
    destination.putpixel(i->first, i->second, tail);
  for (positer i = wires.begin(); i != wires.end(); ++i)
    destination.putpixel(i->first, i->second, wire);
  destination.flush();
}
 
void wireworld::step()
{
  std::map<position, int> new_heads;
  for (positer i = heads.begin(); i != heads.end(); ++i)
    for (int dx = -1; dx <= 1; ++dx)
      for (int dy = -1; dy <= 1; ++dy)
      {
        position pos(i->first + dx, i->second + dy);
        if (wires.count(pos))
          new_heads[pos]++;
      }
  wires.insert(tails.begin(), tails.end());
  tails.swap(heads);
  heads.clear();
  for (std::map<position, int>::iterator i = new_heads.begin();
       i != new_heads.end();
       ++i)
  {
//     std::cout << i->second;
    if (i->second < 3)
    {
      wires.erase(i->first);
      heads.insert(i->first);
    }
  }
}
 
ggi_color colors[4] =
  {{ 0x0000, 0x0000, 0x0000 },  // background: black
   { 0x8000, 0x8000, 0x8000 },  // wire: white
   { 0xffff, 0xffff, 0x0000 },  // electron head: yellow
   { 0xffff, 0x0000, 0x0000 }}; // electron tail: red
 
int main(int argc, char* argv[])
{
  int display_x = 800;
  int display_y = 600;
  int pixel_x = 5;
  int pixel_y = 5;
 
  if (argc < 2)
  {
    std::cerr << ""No file name given!\n"";
    return 1;
  }
 
  // assume that the first argument is the name of a file to parse
  std::ifstream f(argv[1]);
  wireworld w;
  std::string line;
  int line_number = 0;
  while (std::getline(f, line))
  {
    for (int col = 0; col < line.size(); ++col)
    {
      switch (line[col])
      {
      case 'h': case 'H':
        w.set(col, line_number, head);
        break;
      case 't': case 'T':
        w.set(col, line_number, tail);
        break;
      case 'w': case 'W': case '.':
        w.set(col, line_number, wire);
        break;
      default:
        std::cerr << ""unrecognized character: "" << line[col] << ""\n"";
        return 1;
      case ' ':
        ; // no need to explicitly set this, so do nothing
      }
    }
    ++line_number;
  }
 
  display d(display_x, display_y, pixel_x, pixel_y, colors);
 
  w.draw(d);
 
  while (!d.keypressed())
  {
    usleep(100000);
    w.step();
    w.draw(d);
  }
  std::cout << std::endl;
}",5657,246
3149,http://rosettacode.org/wiki/Web_scraping,Web scraping,"Task

Create a program that downloads the time from this URL:   http://tycho.usno.navy.mil/cgi-bin/timer.pl   and then prints the current UTC time by extracting just the UTC time from the web page's HTML. Alternatively, if the above url is not working, grab the first date/time off this page's talk page.



If possible, only use libraries that come at no extra monetary cost with the programming language and that are widely available and popular such as CPAN for Perl or Boost for C++.



",#C.23,C#,"class Program
    {
        static void Main(string[] args)
        {
            WebClient wc = new WebClient();
            Stream myStream = wc.OpenRead(""http://tycho.usno.navy.mil/cgi-bin/timer.pl"");
            string html = """";
            using (StreamReader sr = new StreamReader(myStream))
            {
                while (sr.Peek() >= 0)
                {
                    html = sr.ReadLine();
                    if (html.Contains(""UTC""))
                    {
                        break;
                    }
                }
 
            }
            Console.WriteLine(html.Remove(0, 4));
 
            Console.ReadLine();
        }
    }
 ",668,25
3173,http://rosettacode.org/wiki/Word_frequency,Word frequency,"Task

Given a text file and an integer   n,   print/display the   n   most
common words in the file   (and the number of their occurrences)   in decreasing frequency.



For the purposes of this task:

   A word is a sequence of one or more contiguous letters.
   You are free to define what a   letter   is. 
   Underscores, accented letters, apostrophes, hyphens, and other special characters can be handled at your discretion.
   You may treat a compound word like   well-dressed   as either one word or two. 
   The word   it's   could also be one or two words as you see fit. 
   You may also choose not to support non US-ASCII characters. 
   Assume words will not span multiple lines.
   Don't worry about normalization of word spelling differences. 
   Treat   color   and   colour   as two distinct words.
   Uppercase letters are considered equivalent to their lowercase counterparts.
   Words of equal frequency can be listed in any order.
   Feel free to explicitly state the thoughts behind the program decisions.


Show example output using Les Misérables from Project Gutenberg as the text file input and display the top   10   most used words.



History

This task was originally taken from programming pearls from Communications of the ACM June 1986 Volume 29 Number 6
where this problem is solved by Donald Knuth using literate programming and then critiqued by Doug McIlroy,
demonstrating solving the problem in a 6 line Unix shell script (provided as an example below).



References

McIlroy's program



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
 
namespace WordCount {
    class Program {
        static void Main(string[] args) {
            var text = File.ReadAllText(""135-0.txt"").ToLower();
 
            var match = Regex.Match(text, ""\\w+"");
            Dictionary<string, int> freq = new Dictionary<string, int>();
            while (match.Success) {
                string word = match.Value;
                if (freq.ContainsKey(word)) {
                    freq[word]++;
                } else {
                    freq.Add(word, 1);
                }
 
                match = match.NextMatch();
            }
 
            Console.WriteLine(""Rank  Word  Frequency"");
            Console.WriteLine(""====  ====  ========="");
            int rank = 1;
            foreach (var elem in freq.OrderByDescending(a => a.Value).Take(10)) {
                Console.WriteLine(""{0,2}    {1,-4}    {2,5}"", rank++, elem.Key, elem.Value);
            }
        }
    }
}",1045,33
3772,http://rosettacode.org/wiki/Walk_a_directory/Non-recursively,Walk a directory/Non-recursively,"Task

Walk a given directory and print the names of files matching a given pattern.

(How is ""pattern"" defined? substring match? DOS pattern? BASH pattern? ZSH pattern? Perl regular expression?)


Note: This task is for non-recursive methods.   These tasks should read a single directory, not an entire directory tree.

Note: Please be careful when running any code presented here.



Related task

   Walk Directory Tree   (read entire directory tree). 

",#C.23,C#,"using System;
using System.IO;
 
namespace DirectoryWalk
{
    class Program
    {
        static void Main(string[] args)
        {
            string[] filePaths = Directory.GetFiles(@""c:\MyDir"", ""a*"");
            foreach (string filename in filePaths)
                Console.WriteLine(filename);            
        }
    }
}
 ",332,16
3848,http://rosettacode.org/wiki/Water_collected_between_towers,Water collected between towers,"Task

In a two-dimensional world, we begin with any bar-chart (or row of close-packed 'towers', each of unit width), and then it rains,
completely filling all convex enclosures in the chart with water.



9               ██           9               ██    
8               ██           8               ██    
7     ██        ██           7     ██≈≈≈≈≈≈≈≈██    
6     ██  ██    ██           6     ██≈≈██≈≈≈≈██    
5 ██  ██  ██  ████           5 ██≈≈██≈≈██≈≈████    
4 ██  ██  ████████           4 ██≈≈██≈≈████████    
3 ██████  ████████           3 ██████≈≈████████    
2 ████████████████  ██       2 ████████████████≈≈██
1 ████████████████████       1 ████████████████████


In the example above, a bar chart representing the values [5, 3, 7, 2, 6, 4, 5, 9, 1, 2] has filled, collecting 14 units of water.

Write a function, in your language, from a given array of heights, to the number of water units that can be held in this way, by a corresponding bar chart.

Calculate the number of water units that could be collected by bar charts representing each of the following seven series:

   [[1, 5, 3, 7, 2],
    [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],
    [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],
    [5, 5, 5, 5],
    [5, 6, 7, 8],
    [8, 7, 7, 6],
    [6, 7, 10, 7, 6]]


See, also:

 Four Solutions to a Trivial Problem – a Google Tech Talk by Guy Steele
 Water collected between towers on Stack Overflow, from which the example above is taken)
 An interesting Haskell solution, using the Tardis monad, by Phil Freeman in a Github gist.

",#C.23,C#,"class Program
{
    static void Main(string[] args)
    {
        int[][] wta = {
            new int[] {1, 5, 3, 7, 2},   new int[] { 5, 3, 7, 2, 6, 4, 5, 9, 1, 2 },
            new int[] { 2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1 },
            new int[] { 5, 5, 5, 5 },    new int[] { 5, 6, 7, 8 },
            new int[] { 8, 7, 7, 6 },    new int[] { 6, 7, 10, 7, 6 }};
        string blk, lf = ""\n"", tb = ""██"", wr = ""≈≈"", mt = ""  "";
        for (int i = 0; i < wta.Length; i++)
        {
            int bpf; blk = """"; do
            {
                string floor = """"; bpf = 0; for (int j = 0; j < wta[i].Length; j++)
                {
                    if (wta[i][j] > 0)
                    {    floor += tb; wta[i][j] -= 1; bpf += 1; }
                    else floor += (j > 0 && j < wta[i].Length - 1 ? wr : mt);
                }
                if (bpf > 0) blk = floor + lf + blk;
            } while (bpf > 0);
            while (blk.Contains(mt + wr)) blk = blk.Replace(mt + wr, mt + mt);
            while (blk.Contains(wr + mt)) blk = blk.Replace(wr + mt, mt + mt);
            if (args.Length > 0) System.Console.Write(""\n{0}"", blk);
            System.Console.WriteLine(""Block {0} retains {1,2} water units."",
                i + 1, (blk.Length - blk.Replace(wr, """").Length) / 2);
        }
    }
}",1326,30
3864,http://rosettacode.org/wiki/Walk_a_directory/Recursively,Walk a directory/Recursively,"Task

Walk a given directory tree and print files matching a given pattern.


Note: This task is for recursive methods.   These tasks should read an entire directory tree, not a single directory.


Note: Please be careful when running any code examples found here.



Related task

   Walk a directory/Non-recursively   (read a single directory). 

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
 
namespace RosettaRecursiveDirectory
{
    class Program
    {
        static IEnumerable<FileInfo> TraverseDirectory(string rootPath, Func<FileInfo, bool> Pattern)
        {
            var directoryStack = new Stack<DirectoryInfo>();
            directoryStack.Push(new DirectoryInfo(rootPath));
            while (directoryStack.Count > 0)
            {
                var dir = directoryStack.Pop();
                try
                {
                    foreach (var i in dir.GetDirectories())
                        directoryStack.Push(i);
                }
                catch (UnauthorizedAccessException) {
                    continue; // We don't have access to this directory, so skip it
                }
                foreach (var f in dir.GetFiles().Where(Pattern)) // ""Pattern"" is a function
                    yield return f;
            }
        }
        static void Main(string[] args)
        {
            // Print the full path of all .wmv files that are somewhere in the C:\Windows directory or its subdirectories
            foreach (var file in TraverseDirectory(@""C:\Windows"", f => f.Extension == "".wmv""))
                Console.WriteLine(file.FullName);
            Console.WriteLine(""Done."");
        }
    }
}
 ",1338,38
3869,http://rosettacode.org/wiki/Visualize_a_tree,Visualize a tree,"A tree structure   (i.e. a rooted, connected acyclic graph)   is often used in programming.

It's often helpful to visually examine such a structure.

There are many ways to represent trees to a reader, such as:

   indented text   (à la unix  tree  command)
   nested HTML tables
   hierarchical GUI widgets
   2D   or   3D   images
   etc.
Task

Write a program to produce a visual representation of some tree.

The content of the tree doesn't matter, nor does the output format, the only requirement being that the output is human friendly.

Make do with the vague term ""friendly"" the best you can.



",#C.23,C#,"using System;
 
public static class VisualizeTree
{
    public static void Main() {
        ""A"".t(
            ""B0"".t(
                ""C1"",
                ""C2"".t(
                    ""D"".t(""E1"", ""E2"", ""E3"")),
                ""C3"".t(
                    ""F1"",
                    ""F2"",
                    ""F3"".t(""G""),
                    ""F4"".t(""H1"", ""H2""))),
            ""B1"".t(
                ""K1"",
                ""K2"".t(
                    ""L1"".t(""M""),
                    ""L2"",
                    ""L3""),
                ""K3"")
        ).Print();
    }
 
    private static Tree t(this string value, params Tree[] children) => new Tree(value, children);
 
    private static void Print(this Tree tree) => tree.Print(true, """");
 
    private static void Print(this Tree tree, bool last, string prefix) {
        (string current, string next) = last
            ? (prefix + ""└─"" + tree.Value, prefix + ""  "")
            : (prefix + ""├─"" + tree.Value, prefix + ""| "");
        Console.WriteLine(current[2..]);
        for (int c = 0; c < tree.Children.Length; c++) {
            tree.Children[c].Print(c == tree.Children.Length - 1, next);
        }
    }
 
    class Tree
    {
        public Tree(string value, params Tree[] children) => (Value, Children) = (value, children);
        public static implicit operator Tree(string value) => new Tree(value);
        public string Value { get; }
        public Tree[] Children { get; }
    }
 
}",1448,48
3941,http://rosettacode.org/wiki/Vigen%C3%A8re_cipher,Vigenère cipher,"Task

Implement a   Vigenère cypher,   both encryption and decryption.

The program should handle keys and text of unequal length,
and should capitalize everything and discard non-alphabetic characters. 

(If your program handles non-alphabetic characters in another way,
make a note of it.)



Related tasks

   Caesar cipher
   Rot-13
   Substitution Cipher

",#C.23,C#," 
using System;
 
namespace VigenereCipher
{
    class VCipher
    {
        public string encrypt(string txt, string pw, int d)
        {
            int pwi = 0, tmp;
            string ns = """";
            txt = txt.ToUpper();
            pw = pw.ToUpper();
            foreach (char t in txt)
            {
                if (t < 65) continue;
                tmp = t - 65 + d * (pw[pwi] - 65);
                if (tmp < 0) tmp += 26;
                ns += Convert.ToChar(65 + ( tmp % 26) );
                if (++pwi == pw.Length) pwi = 0;
            }
 
            return ns;
        }
    };
 
    class Program
    {
        static void Main(string[] args)
        {
            VCipher v = new VCipher();
 
            string s0 = ""Beware the Jabberwock, my son! The jaws that bite, the claws that catch!"",
                   pw = ""VIGENERECIPHER"";
 
            Console.WriteLine(s0 + ""\n"" + pw + ""\n"");
            string s1 = v.encrypt(s0, pw, 1);
            Console.WriteLine(""Encrypted: "" + s1);
            s1 = v.encrypt(s1, ""VIGENERECIPHER"", -1);
            Console.WriteLine(""Decrypted: "" + s1);
            Console.WriteLine(""\nPress any key to continue..."");
            Console.ReadKey();
        }
    }
}
 ",1234,46
4144,http://rosettacode.org/wiki/Variable-length_quantity,Variable-length quantity,"Implement some operations on variable-length quantities, at least including conversions from a normal number in the language to the binary representation of the variable-length quantity for that number, and vice versa. Any variants are acceptable.



Task

With above operations,

convert these two numbers 0x200000 (2097152 in decimal) and 0x1fffff (2097151 in decimal) into sequences of octets (an eight-bit byte); 
display these sequences of octets;
convert these sequences of octets back to numbers, and check that they are equal to original numbers.

",#C.23,C#,"namespace Vlq
{
  using System;
  using System.Collections.Generic;
  using System.Linq;
 
  public static class VarLenQuantity
  {
    public static ulong ToVlq(ulong integer)
    {
      var array = new byte[8];
      var buffer = ToVlqCollection(integer)
        .SkipWhile(b => b == 0)
        .Reverse()
        .ToArray();
      Array.Copy(buffer, array, buffer.Length);
      return BitConverter.ToUInt64(array, 0);
    }
 
    public static ulong FromVlq(ulong integer)
    {
      var collection = BitConverter.GetBytes(integer).Reverse();
      return FromVlqCollection(collection);
    }
 
    public static IEnumerable<byte> ToVlqCollection(ulong integer)
    {
      if (integer > Math.Pow(2, 56))
        throw new OverflowException(""Integer exceeds max value."");
 
      var index = 7;
      var significantBitReached = false;
      var mask = 0x7fUL << (index * 7);
      while (index >= 0)
      {
        var buffer = (mask & integer);
        if (buffer > 0 || significantBitReached)
        {
          significantBitReached = true;
          buffer >>= index * 7;
          if (index > 0)
            buffer |= 0x80;
          yield return (byte)buffer;
        }
        mask >>= 7;
        index--;
      }
    }
 
 
    public static ulong FromVlqCollection(IEnumerable<byte> vlq)
    {
      ulong integer = 0;
      var significantBitReached = false;
 
      using (var enumerator = vlq.GetEnumerator())
      {
        int index = 0;
        while (enumerator.MoveNext())
        {
          var buffer = enumerator.Current;
          if (buffer > 0 || significantBitReached)
          {
            significantBitReached = true;
            integer <<= 7;
            integer |= (buffer & 0x7fUL);
          }
 
          if (++index == 8 || (significantBitReached && (buffer & 0x80) != 0x80))
            break;
        }
      }
      return integer;
    }
 
    public static void Main()
    {
      var integers = new ulong[] { 0x7fUL << 7 * 7, 0x80, 0x2000, 0x3FFF, 0x4000, 0x200000, 0x1fffff };
 
      foreach (var original in integers)
      {
        Console.WriteLine(""Original: 0x{0:X}"", original);
 
        //collection
        var seq = ToVlqCollection(original);
        Console.WriteLine(""Sequence: 0x{0}"", seq.Select(b => b.ToString(""X2"")).Aggregate(string.Concat));
 
        var decoded = FromVlqCollection(seq);
        Console.WriteLine(""Decoded: 0x{0:X}"", decoded);
 
        //ints
        var encoded = ToVlq(original);
        Console.WriteLine(""Encoded: 0x{0:X}"", encoded);
 
        decoded = FromVlq(encoded);
        Console.WriteLine(""Decoded: 0x{0:X}"", decoded);
 
        Console.WriteLine();
      }
      Console.WriteLine(""Press any key to continue..."");
      Console.ReadKey();
    }
  }
}",2754,104
4147,http://rosettacode.org/wiki/Vector,Vector,"Task
Implement a Vector class (or a set of functions) that models a Physical Vector. The four basic operations and a pretty print function should be implemented.



The Vector may be initialized in any reasonable way.

 Start and end points, and direction
 Angular coefficient and value (length)


The four operations to be implemented are:

 Vector  +  Vector addition
 Vector  -  Vector subtraction
 Vector  *  scalar multiplication
 Vector  /  scalar division

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace RosettaVectors
{
    public class Vector
    {
        public double[] store;
        public Vector(IEnumerable<double> init)
        {
            store = init.ToArray();
        }
        public Vector(double x, double y)
        {
            store = new double[] { x, y };
        }
        static public Vector operator+(Vector v1, Vector v2)
        {
            return new Vector(v1.store.Zip(v2.store, (a, b) => a + b));
        }
        static public Vector operator -(Vector v1, Vector v2)
        {
            return new Vector(v1.store.Zip(v2.store, (a, b) => a - b));
        }
        static public Vector operator *(Vector v1, double scalar)
        {
            return new Vector(v1.store.Select(x => x * scalar));
        }
        static public Vector operator /(Vector v1, double scalar)
        {
            return new Vector(v1.store.Select(x => x / scalar));
        }
        public override string ToString()
        {
            return string.Format(""[{0}]"", string.Join("","", store));
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            var v1 = new Vector(5, 7);
            var v2 = new Vector(2, 3);
            Console.WriteLine(v1 + v2);
            Console.WriteLine(v1 - v2);
            Console.WriteLine(v1 * 11);
            Console.WriteLine(v1 / 2);
            // Works with arbitrary size vectors, too.
            var lostVector = new Vector(new double[] { 4, 8, 15, 16, 23, 42 });
            Console.WriteLine(lostVector * 7);
            Console.ReadLine();
        }
    }
}
 ",1655,56
4301,http://rosettacode.org/wiki/Variadic_function,Variadic function,"Task

Create a function which takes in a variable number of arguments and prints each one on its own line.

Also show, if possible in your language, how to call the function on a list of arguments constructed at runtime.



Functions of this type are also known as Variadic Functions.



Related task

   Call a function

",#C.23,C#,"using System;
 
class Program {
    static void Main(string[] args) {
        PrintAll(""test"", ""rosetta code"", 123, 5.6);
    }
 
    static void PrintAll(params object[] varargs) {
        foreach (var i in varargs) {
            Console.WriteLine(i);
        }
    }
}",270,13
4331,http://rosettacode.org/wiki/Variable_size/Get,Variable size/Get,"Demonstrate how to get the size of a variable.

See also: Host introspection
",#C.23,C#," 
class Program
{
    static void Main(string[] args)
    {
        int i = sizeof(int);
        Console.WriteLine(i);
        Console.ReadLine();
    }       
}
 ",163,11
4436,http://rosettacode.org/wiki/Vampire_number,Vampire number,"A vampire number is a natural decimal number with an even number of digits,   that can be factored into two integers.

These two factors are called the   fangs,   and must have the following properties:

   they each contain half the number of the decimal digits of the original number
   together they consist of exactly the same decimal digits as the original number
   at most one of them has a trailing zero


An example of a vampire number and its fangs:    1260 : (21, 60) 



Task

 Print the first   25   vampire numbers and their fangs. 
 Check if the following numbers are vampire numbers and,   if so,   print them and their fangs: 
 16758243290880, 24959017348650, 14593825548650 



Note that a vampire number can have more than one pair of fangs.



See also

 numberphile.com.
 vampire search algorithm
 vampire numbers on OEIS

",#C.23,C#,"using System;
 
namespace RosettaVampireNumber
{
    class Program
    {
        static void Main(string[] args)
        {
            int i, j, n;
            ulong x;
            var f = new ulong[16];
            var bigs = new ulong[] { 16758243290880UL, 24959017348650UL, 14593825548650UL, 0 };
            ulong[] tens = new ulong[20];
            tens[0] = 1;
            for (i = 1; i < 20; i++)
                tens[i] = tens[i - 1] * 10;
 
            for (x = 1, n = 0; n < 25; x++)
            {
                if ((j = fangs(x, f, tens)) == 0) continue;
                Console.Write(++n + "": "");
                show_fangs(x, f, j);
            }
 
            Console.WriteLine();
            for (i = 0; bigs[i] > 0 ; i++)
            {
                if ((j = fangs(bigs[i], f, tens)) > 0)
                    show_fangs(bigs[i], f, j);
                else
                    Console.WriteLine(bigs[i] + "" is not vampiric."");
            }
            Console.ReadLine();
        }
 
        private static void show_fangs(ulong x, ulong[] f, int cnt)
        {
            Console.Write(x); 
            int i;
            for (i = 0; i < cnt; i++)
                Console.Write("" = "" + f[i] + "" * "" + (x / f[i]));
            Console.WriteLine();
        }
 
        private static int fangs(ulong x, ulong[] f, ulong[] tens)
        {
            int n = 0;
            int nd = ndigits(x);
            if ((nd & 1) > 0) return 0;
            nd /= 2;
 
            ulong lo, hi;
            lo = Math.Max(tens[nd - 1], (x + tens[nd] - 2) / (tens[nd] - 1));
            hi = Math.Min(x / lo, (ulong) Math.Sqrt(x));
 
            ulong a, b, t = dtally(x);
            for (a = lo; a <= hi; a++)
            {
                b = x / a;
                if (a * b == x && ((a % 10) > 0 || (b % 10) > 0) && t == dtally(a) + dtally(b))
                    f[n++] = a;
            }
 
            return n;
        }
 
        private static ulong dtally(ulong x)
        {
            ulong t = 0;
            while (x > 0)
            {
                t += 1UL << (int)((x % 10) * 6);
                x /= 10;
            }
 
            return t;
        }
 
        private static int ndigits(ulong x)
        {
            int n = 0;
            while (x > 0)
            {
                n++;
                x /= 10;
            }
            return n;
        }
    }
}",2398,90
4526,http://rosettacode.org/wiki/Validate_International_Securities_Identification_Number,Validate International Securities Identification Number,"An International Securities Identification Number (ISIN) is a unique international identifier for a financial security such as a stock or bond.



Task

Write a function or program that takes a string as input, and checks whether it is a valid ISIN.

It is only valid if it has the correct format,   and   the embedded checksum is correct.

Demonstrate that your code passes the test-cases listed below.



Details

The format of an ISIN is as follows:


┌───────────── a 2-character ISO country code (A-Z)
│ ┌─────────── a 9-character security code (A-Z, 0-9)
│ │        ┌── a checksum digit (0-9)
AU0000XVGZA3



For this task, you may assume that any 2-character alphabetic sequence is a valid country code.

The checksum can be validated as follows:

 Replace letters with digits, by converting each character from base 36 to base 10, e.g. AU0000XVGZA3 →1030000033311635103.
 Perform the Luhn test on this base-10 number.
There is a separate task for this test: Luhn test of credit card numbers.
You don't have to replicate the implementation of this test here   ───   you can just call the existing function from that task.   (Add a comment stating if you did this.)


Test cases



 ISIN

 Validity

 Comment


 US0378331005 
 valid 



 US0373831005 
 not valid 
 The transposition typo is caught by the checksum constraint.


 U50378331005 
 not valid 
 The substitution typo is caught by the format constraint.


 US03378331005 
 not valid 
 The duplication typo is caught by the format constraint.


 AU0000XVGZA3 
 valid 



 AU0000VXGZA3 
 valid 
 Unfortunately, not all transposition typos are caught by the checksum constraint.


 FR0000988040 
 valid 


(The comments are just informational.   Your function should simply return a Boolean result.   See #Raku for a reference solution.)



Related task:

 Luhn test of credit card numbers


Also see

 Interactive online ISIN validator
 Wikipedia article: International Securities Identification Number

",#C.23,C#,"using System;
using System.Linq;
using System.Text.RegularExpressions;
 
namespace ValidateIsin
{
    public static class IsinValidator
    {
        public static bool IsValidIsin(string isin) => 
            IsinRegex.IsMatch(isin) && LuhnTest(Digitize(isin));
 
        private static readonly Regex IsinRegex = 
            new Regex(""^[A-Z]{2}[A-Z0-9]{9}\\d$"", RegexOptions.Compiled);
 
        private static string Digitize(string isin) =>
            string.Join("""", isin.Select(c => $""{DigitValue(c)}""));
 
        private static bool LuhnTest(string number) => 
            number.Reverse().Select(DigitValue).Select(Summand).Sum() % 10 == 0;
 
        private static int Summand(int digit, int i) =>
            digit + (i % 2) * (digit - digit / 5 * 9);
 
        private static int DigitValue(char c) =>
            c >= '0' && c <= '9' 
                ? c - '0' 
                : c - 'A' + 10;
   }
 
   public class Program
   {
        public static void Main() 
        {
            string[] isins = 
            {
                ""US0378331005"",
                ""US0373831005"",
                ""U50378331005"",
                ""US03378331005"",
                ""AU0000XVGZA3"",
                ""AU0000VXGZA3"",
                ""FR0000988040""
            };
 
            foreach (string isin in isins) {
                string validOrNot = IsinValidator.IsValidIsin(isin) ? ""valid"" : ""not valid"";
                Console.WriteLine($""{isin} is {validOrNot}"");
            }
        }
    }
}",1507,51
4551,http://rosettacode.org/wiki/Vector_products,Vector products,"A vector is defined as having three dimensions as being represented by an ordered collection of three numbers:   (X, Y, Z).

If you imagine a graph with the   x   and   y   axis being at right angles to each other and having a third,   z   axis coming out of the page, then a triplet of numbers,   (X, Y, Z)   would represent a point in the region,   and a vector from the origin to the point.

Given the vectors:

        A = (a1,  a2,  a3) 
        B = (b1,  b2,  b3) 
        C = (c1,  c2,  c3) 

then the following common vector products are defined:

 The dot product       (a scalar quantity)
  A • B = a1b1   +   a2b2   +   a3b3  
 The cross product       (a vector quantity)
  A x B = (a2b3  -   a3b2,     a3b1   -   a1b3,     a1b2   -   a2b1)  
 The scalar triple product       (a scalar quantity)
  A • (B x C) 
 The vector triple product       (a vector quantity)
  A x (B x C) 


Task

Given the three vectors:

        a = ( 3,    4,    5)
        b = ( 4,    3,    5)
        c = (-5,  -12,  -13)

 Create a named function/subroutine/method to compute the dot product of two vectors.
 Create a function to compute the cross product of two vectors.
 Optionally create a function to compute the scalar triple product of three vectors.
 Optionally create a function to compute the vector triple product of three vectors.
 Compute and display: a • b
 Compute and display: a x b
 Compute and display: a • (b x c), the scalar triple product.
 Compute and display: a x (b x c), the vector triple product.


References

   A starting page on Wolfram MathWorld is   Vector Multiplication .
   Wikipedia   dot product. 
   Wikipedia   cross product. 
   Wikipedia   triple product.


Related tasks

   Dot product
   Quaternion type

",#C.23,C#,"using System;
using System.Windows.Media.Media3D;
 
class VectorProducts
{
    static double ScalarTripleProduct(Vector3D a, Vector3D b, Vector3D c)
    {
        return Vector3D.DotProduct(a, Vector3D.CrossProduct(b, c));
    }
 
    static Vector3D VectorTripleProduct(Vector3D a, Vector3D b, Vector3D c)
    {
        return Vector3D.CrossProduct(a, Vector3D.CrossProduct(b, c));
    }
 
    static void Main()
    {
        var a = new Vector3D(3, 4, 5);
        var b = new Vector3D(4, 3, 5);
        var c = new Vector3D(-5, -12, -13);
 
        Console.WriteLine(Vector3D.DotProduct(a, b));
        Console.WriteLine(Vector3D.CrossProduct(a, b));
        Console.WriteLine(ScalarTripleProduct(a, b, c));
        Console.WriteLine(VectorTripleProduct(a, b, c));
    }
}",775,27
4553,http://rosettacode.org/wiki/Van_der_Corput_sequence,Van der Corput sequence,"When counting integers in binary, if you put a (binary) point to the righEasyLangt of the count then the column immediately to the left denotes a digit with a multiplier of 




2

0




{\displaystyle 2^{0}}

; the digit in the next column to the left has a multiplier of 




2

1




{\displaystyle 2^{1}}

; and so on.

So in the following table:

  0.
  1.
 10.
 11.
 ...
the binary number ""10"" is 



1
×

2

1


+
0
×

2

0




{\displaystyle 1\times 2^{1}+0\times 2^{0}}

.

You can also have binary digits to the right of the “point”, just as in the decimal number system. In that case, the digit in the place immediately to the right of the point has a weight of 




2

−
1




{\displaystyle 2^{-1}}

, or 



1

/

2


{\displaystyle 1/2}

.
The weight for the second column to the right of the point is 




2

−
2




{\displaystyle 2^{-2}}

 or 



1

/

4


{\displaystyle 1/4}

. And so on.

If you take the integer binary count of the first table, and reflect the digits about the binary point, you end up with the van der Corput sequence of numbers in base 2.

  .0
  .1
  .01
  .11
  ...
The third member of the sequence, binary 0.01, is therefore 



0
×

2

−
1


+
1
×

2

−
2




{\displaystyle 0\times 2^{-1}+1\times 2^{-2}}

 or 



1

/

4


{\displaystyle 1/4}

.



 Distribution of 2500 points each: Van der Corput (top) vs pseudorandom




0
≤
x
<
1


{\displaystyle 0\leq x<1}


Monte Carlo simulations
This sequence is also a superset of the numbers representable by the ""fraction"" field of an old IEEE floating point standard. In that standard, the ""fraction"" field represented the fractional part of a binary number beginning with ""1."" e.g. 1.101001101.

Hint

A hint at a way to generate members of the sequence is to modify a routine used to change the base of an integer:

>>> def base10change(n, base):
	digits = []
	while n:
		n,remainder = divmod(n, base)
		digits.insert(0, remainder)
	return digits
 
>>> base10change(11, 2)
[1, 0, 1, 1]
the above showing that 11 in decimal is 



1
×

2

3


+
0
×

2

2


+
1
×

2

1


+
1
×

2

0




{\displaystyle 1\times 2^{3}+0\times 2^{2}+1\times 2^{1}+1\times 2^{0}}

.

Reflected this would become .1101 or 



1
×

2

−
1


+
1
×

2

−
2


+
0
×

2

−
3


+
1
×

2

−
4




{\displaystyle 1\times 2^{-1}+1\times 2^{-2}+0\times 2^{-3}+1\times 2^{-4}}





Task description

 Create a function/method/routine that given n, generates the n'th term of the van der Corput sequence in base 2.
 Use the function to compute and display the first ten members of the sequence. (The first member of the sequence is for n=0).
 As a stretch goal/extra credit, compute and show members of the sequence for bases other than 2.


See also

 The Basic Low Discrepancy Sequences
 Non-decimal radices/Convert
 Van der Corput sequence

",#C.23,C#," 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace VanDerCorput
{
    /// <summary>
    /// Computes the Van der Corput sequence for any number base.
    /// The numbers in the sequence vary from zero to one, including zero but excluding one.
    /// The sequence possesses low discrepancy.
    /// Here are the first ten terms for bases 2 to 5:
    /// 
    /// base 2:  0  1/2  1/4  3/4  1/8  5/8  3/8  7/8  1/16  9/16
    /// base 3:  0  1/3  2/3  1/9  4/9  7/9  2/9  5/9  8/9  1/27
    /// base 4:  0  1/4  1/2  3/4  1/16  5/16  9/16  13/16  1/8  3/8
    /// base 5:  0  1/5  2/5  3/5  4/5  1/25  6/25  11/25  16/25  21/25
    /// </summary>
    /// <see cref=""http://rosettacode.org/wiki/Van_der_Corput_sequence""/>
    public class VanDerCorputSequence: IEnumerable<Tuple<long,long>>
    {
        /// <summary>
        /// Number base for the sequence, which must bwe two or more.
        /// </summary>
        public int Base { get; private set; }
 
        /// <summary>
        /// Maximum number of terms to be returned by iterator.
        /// </summary>
        public long Count { get; private set; }
 
        /// <summary>
        /// Construct a sequence for the given base.
        /// </summary>
        /// <param name=""iBase"">Number base for the sequence.</param>
        /// <param name=""count"">Maximum number of items to be returned by the iterator.</param>
        public VanDerCorputSequence(int iBase, long count = long.MaxValue) {
            if (iBase < 2)
                throw new ArgumentOutOfRangeException(""iBase"", ""must be two or greater, not the given value of "" + iBase);
            Base = iBase;
            Count = count;
        }
 
        /// <summary>
        /// Compute nth term in the Van der Corput sequence for the base specified in the constructor.
        /// </summary>
        /// <param name=""n"">The position in the sequence, which may be zero or any positive number.</param>
        /// This number is always an integral power of the base.</param>
        /// <returns>The Van der Corput sequence value expressed as a Tuple containing a numerator and a denominator.</returns>
        public Tuple<long,long> Compute(long n)
        {
            long p = 0, q = 1;
            long numerator, denominator;
            while (n != 0)
            {
                p = p * Base + (n % Base);
                q *= Base;
                n /= Base;
            }
            numerator = p;
            denominator = q;
            while (p != 0) 
            { 
                n = p; 
                p = q % p; 
                q = n; 
            }
            numerator /= q;
            denominator /= q;
            return new Tuple<long,long>(numerator, denominator);
        }
 
        /// <summary>
        /// Compute nth term in the Van der Corput sequence for the given base.
        /// </summary>
        /// <param name=""iBase"">Base to use for the sequence.</param>
        /// <param name=""n"">The position in the sequence, which may be zero or any positive number.</param>
        /// <returns>The Van der Corput sequence value expressed as a Tuple containing a numerator and a denominator.</returns>
        public static Tuple<long, long> Compute(int iBase, long n)
        {
            var seq = new VanDerCorputSequence(iBase);
            return seq.Compute(n);
        }
 
        /// <summary>
        /// Iterate over the Van Der Corput sequence.
        /// The first value in the sequence is always zero, regardless of the base.
        /// </summary>
        /// <returns>A tuple whose items are the Van der Corput value given as a numerator and denominator.</returns>
        public IEnumerator<Tuple<long, long>> GetEnumerator()
        {
            long iSequenceIndex = 0L;
            while (iSequenceIndex < Count)
            {
                yield return Compute(iSequenceIndex);
                iSequenceIndex++;
            }
        }
 
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
 
    class Program
    {
        static void Main(string[] args)
        {
            TestBasesTwoThroughFive();
 
            Console.WriteLine(""Type return to continue..."");
            Console.ReadLine();
        }
 
        static void TestBasesTwoThroughFive()
        {
            foreach (var seq in Enumerable.Range(2, 5).Select(x => new VanDerCorputSequence(x, 10))) // Just the first 10 elements of the each sequence
            {
                Console.Write(""base "" + seq.Base + "":"");
                foreach(var vc in seq) 
                    Console.Write("" "" + vc.Item1 + ""/"" + vc.Item2);
                Console.WriteLine();
            }
        }
    }
}
 
 ",4806,130
4601,http://rosettacode.org/wiki/Van_Eck_sequence,Van Eck sequence,"The sequence is generated by following this pseudo-code:

A:  The first term is zero.
    Repeatedly apply:
        If the last term is *new* to the sequence so far then:
B:          The next term is zero.
        Otherwise:
C:          The next term is how far back this last term occured previously.



Example

Using A:

0
Using B:

0 0
Using C:

0 0 1
Using B:

0 0 1 0
Using C: (zero last occurred two steps back - before the one)

0 0 1 0 2
Using B:

0 0 1 0 2 0
Using C: (two last occurred two steps back - before the zero)

0 0 1 0 2 0 2 2
Using C: (two last occurred one step back)

0 0 1 0 2 0 2 2 1
Using C: (one last appeared six steps back)

0 0 1 0 2 0 2 2 1 6
...



Task

 Create a function/procedure/method/subroutine/... to generate the Van Eck sequence of numbers.
 Use it to display here, on this page:
 The first ten terms of the sequence.
 Terms 991 - to - 1000 of the sequence.


References

 Don't Know (the Van Eck Sequence) - Numberphile video.
 Wikipedia Article: Van Eck's Sequence.
  OEIS sequence: A181391.

",#C.23,C#,"using System.Linq; class Program { static void Main() {
    int a, b, c, d, e, f, g; int[] h = new int[g = 1000];
    for (a = 0, b = 1, c = 2; c < g; a = b, b = c++)
        for (d = a, e = b - d, f = h[b]; e <= b; e++)
            if (f == h[d--]) { h[c] = e; break; }
    void sho(int i) { System.Console.WriteLine(string.Join("" "",
        h.Skip(i).Take(10))); } sho(0); sho(990); } }",388,7
4649,http://rosettacode.org/wiki/URL_parser,URL parser,"URLs are strings with a simple syntax:

  scheme://[username:password@]domain[:port]/path?query_string#fragment_id



Task

Parse a well-formed URL to retrieve the relevant information:   scheme, domain, path, ...



Note:   this task has nothing to do with URL encoding or URL decoding.



According to the standards, the characters:

     ! * ' ( ) ; : @ & = + $ , / ? % # [ ] 
only need to be percent-encoded   (%)   in case of possible confusion.

Also note that the path, query and fragment are case sensitive, even if the scheme and domain are not.

The way the returned information is provided (set of variables, array, structured, record, object,...)
is language-dependent and left to the programmer, but the code should be clear enough to reuse.

Extra credit is given for clear error diagnostics.

   Here is the official standard:     https://tools.ietf.org/html/rfc3986, 
   and here is a simpler   BNF:     http://www.w3.org/Addressing/URL/5_URI_BNF.html.


Test cases

According to T. Berners-Lee

foo://example.com:8042/over/there?name=ferret#nose     should parse into:

   scheme = foo
   domain = example.com
   port = :8042
   path = over/there
   query = name=ferret
   fragment = nose

urn:example:animal:ferret:nose     should parse into:

   scheme = urn
   path = example:animal:ferret:nose

other URLs that must be parsed include:

   jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true 
   ftp://ftp.is.co.za/rfc/rfc1808.txt 
   http://www.ietf.org/rfc/rfc2396.txt#header1 
   ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two 
   mailto:John.Doe@example.com 
   news:comp.infosystems.www.servers.unix 
   tel:+1-816-555-1212 
   telnet://192.0.2.16:80/ 
   urn:oasis:names:specification:docbook:dtd:xml:4.1.2 

",#C.23,C#,"using System;
 
namespace RosettaUrlParse
{
    class Program
    {
        static void ParseUrl(string url)
        {
            var u = new Uri(url);
            Console.WriteLine(""URL:         {0}"", u.AbsoluteUri);
            Console.WriteLine(""Scheme:      {0}"", u.Scheme);
            Console.WriteLine(""Host:        {0}"", u.DnsSafeHost);
            Console.WriteLine(""Port:        {0}"", u.Port);
            Console.WriteLine(""Path:        {0}"", u.LocalPath);
            Console.WriteLine(""Query:       {0}"", u.Query);
            Console.WriteLine(""Fragment:    {0}"", u.Fragment);
            Console.WriteLine();
        }
        static void Main(string[] args)
        {
            ParseUrl(""foo://example.com:8042/over/there?name=ferret#nose"");
            ParseUrl(""urn:example:animal:ferret:nose"");
            ParseUrl(""jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true"");
            ParseUrl(""ftp://ftp.is.co.za/rfc/rfc1808.txt"");
            ParseUrl(""http://www.ietf.org/rfc/rfc2396.txt#header1"");
            ParseUrl(""ldap://[2001:db8::7]/c=GB?objectClass?one"");
            ParseUrl(""mailto:John.Doe@example.com"");
            ParseUrl(""news:comp.infosystems.www.servers.unix"");
            ParseUrl(""tel:+1-816-555-1212"");
            ParseUrl(""telnet://192.0.2.16:80/"");
            ParseUrl(""urn:oasis:names:specification:docbook:dtd:xml:4.1.2"");
        }
    }
}
 ",1417,35
4717,http://rosettacode.org/wiki/Variables,Variables,"Task

Demonstrate a language's methods of:

   variable declaration
   initialization
   assignment
   datatypes
   scope 
   referencing,     and 
   other variable related facilities

",#C.23,C#,int j;,6,1
4778,http://rosettacode.org/wiki/URL_encoding,URL encoding,"Task

Provide a function or mechanism to convert a provided string into URL encoding representation.

In URL encoding, special characters, control characters and extended characters
are converted into a percent symbol followed by a two digit hexadecimal code,
So a space character encodes into %20 within the string.

For the purposes of this task, every character except 0-9, A-Z and a-z requires conversion, so the following characters all require conversion by default:

 ASCII control codes (Character ranges 00-1F hex (0-31 decimal) and 7F (127 decimal).
 ASCII symbols (Character ranges 32-47 decimal (20-2F hex))
 ASCII symbols (Character ranges 58-64 decimal (3A-40 hex))
 ASCII symbols (Character ranges 91-96 decimal (5B-60 hex))
 ASCII symbols (Character ranges 123-126 decimal (7B-7E hex))
 Extended characters with character codes of 128 decimal (80 hex) and above.


Example

The string ""http://foo bar/"" would be encoded as ""http%3A%2F%2Ffoo%20bar%2F"".



Variations

 Lowercase escapes are legal, as in ""http%3a%2f%2ffoo%20bar%2f"".
 Some standards give different rules: RFC 3986, Uniform Resource Identifier (URI): Generic Syntax, section 2.3, says that ""-._~"" should not be encoded. HTML 5, section 4.10.22.5 URL-encoded form data, says to preserve ""-._*"", and to encode space "" "" to ""+"". The options below provide for utilization of an exception string, enabling preservation (non encoding) of particular characters to meet specific standards.


Options

It is permissible to use an exception string (containing a set of symbols
that do not need to be converted).
However, this is an optional feature and is not a requirement of this task.



Related tasks
 
   URL decoding
   URL parser

",#C.23,C#,"using System;
 
namespace URLEncode
{
    internal class Program
    {
        private static void Main(string[] args)
        {
            Console.WriteLine(Encode(""http://foo bar/""));
        }
 
        private static string Encode(string uri)
        {
            return Uri.EscapeDataString(uri);
        }
    }
}",321,17
4834,http://rosettacode.org/wiki/UTF-8_encode_and_decode,UTF-8 encode and decode,"As described in UTF-8 and in Wikipedia, UTF-8 is a popular encoding of (multi-byte) Unicode code-points into eight-bit octets.

The goal of this task is to write a encoder that takes a unicode code-point (an integer representing a unicode character) and returns a sequence of 1-4 bytes representing that character in the UTF-8 encoding.

Then you have to write the corresponding decoder that takes a sequence of 1-4 UTF-8 encoded bytes and return the corresponding unicode character.

Demonstrate the functionality of your encoder and decoder on the following five characters:

Character   Name                                  Unicode    UTF-8 encoding (hex)
---------------------------------------------------------------------------------
A           LATIN CAPITAL LETTER A                U+0041     41
ö           LATIN SMALL LETTER O WITH DIAERESIS   U+00F6     C3 B6
Ж           CYRILLIC CAPITAL LETTER ZHE           U+0416     D0 96
€           EURO SIGN                             U+20AC     E2 82 AC
𝄞           MUSICAL SYMBOL G CLEF                 U+1D11E    F0 9D 84 9E

Provided below is a reference implementation in Common Lisp.
",#C.23,C#,"using System;
using System.Text;
 
namespace Rosetta
{
    class Program
    {
        static byte[] MyEncoder(int codepoint) => Encoding.UTF8.GetBytes(char.ConvertFromUtf32(codepoint));
        static string MyDecoder(byte[] utf8bytes) => Encoding.UTF8.GetString(utf8bytes);
        static void Main(string[] args)
        {
            Console.OutputEncoding = Encoding.UTF8;  // makes sure it doesn't print rectangles...
            foreach (int unicodePoint in new int[] {  0x0041, 0x00F6, 0x0416, 0x20AC, 0x1D11E})
            {
                byte[] asUtf8bytes = MyEncoder(unicodePoint);
                string theCharacter = MyDecoder(asUtf8bytes);
                Console.WriteLine(""{0,8} {1,5}     {2,-15}"", unicodePoint.ToString(""X4""), theCharacter, BitConverter.ToString(asUtf8bytes));
            }
        }
    }
}
/* Output:
 *  0041     A     41
    00F6     ö     C3-B6
    0416     Ж     D0-96
    20AC     €     E2-82-AC
   1D11E     𝄞     F0-9D-84-9E */
 ",977,28
4857,http://rosettacode.org/wiki/URL_decoding,URL decoding,"This task   (the reverse of   URL encoding   and distinct from   URL parser)   is to provide a function
or mechanism to convert an URL-encoded string into its original unencoded form.



Test cases

   The encoded string   ""http%3A%2F%2Ffoo%20bar%2F""   should be reverted to the unencoded form   ""http://foo bar/"".
   The encoded string   ""google.com/search?q=%60Abdu%27l-Bah%C3%A1""   should revert to the unencoded form   ""google.com/search?q=`Abdu'l-Bahá"".

",#C.23,C#,"using System;
 
namespace URLEncode
{
    internal class Program
    {
        private static void Main(string[] args)
        {
            Console.WriteLine(Decode(""http%3A%2F%2Ffoo%20bar%2F""));
        }
 
        private static string Decode(string uri)
        {
            return Uri.UnescapeDataString(uri);
        }
    }
}",333,17
4920,http://rosettacode.org/wiki/User_input/Text,User input/Text,"User input/Text is part of Short Circuit's Console Program Basics selection.
Task
 
Input a string and the integer   75000   from the text console.

See also: User input/Graphical
",#C.23,C#,"using System;
 
namespace C_Sharp_Console {
 
    class example {
 
        static void Main() {
            string word;
            int num;
 
            Console.Write(""Enter an integer: "");
            num = Console.Read();
            Console.Write(""Enter a String: "");
            word = Console.ReadLine();
        }
    }
}",331,17
5649,http://rosettacode.org/wiki/Undefined_values,Undefined values,"
",#C.23,C#,string foo = null;,18,1
5709,http://rosettacode.org/wiki/Unix/ls,Unix/ls,"Task

Write a program that will list everything in the current folder,   similar to:

   the Unix utility   “ls”   [1]       or 
   the Windows terminal command   “DIR” 


The output must be sorted, but printing extended details and producing multi-column output is not required.



Example output
For the list of paths:

/foo/bar
/foo/bar/1
/foo/bar/2
/foo/bar/a
/foo/bar/b



When the program is executed in   `/foo`,   it should print:

bar

and when the program is executed in   `/foo/bar`,   it should print:

1
2
a
b


",#C.23,C#,"using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
 
namespace Unix_ls
{
    public class UnixLS
    {
        public static void Main(string[] args)
        {
            UnixLS ls = new UnixLS();
            ls.list(args.Length.Equals(0) ? ""."" : args[0]);
        }
 
        private void list(string folder)
        {
            foreach (FileSystemInfo fileSystemInfo in new DirectoryInfo(folder).EnumerateFileSystemInfos(""*"", SearchOption.TopDirectoryOnly))
            {
                Console.WriteLine(fileSystemInfo.Name);
            }
        }
    }
}",627,25
5734,http://rosettacode.org/wiki/Unicode_variable_names,Unicode variable names,"Task

 Describe, and give a pointer to documentation on your languages use of characters beyond those of the ASCII character set in the naming of variables.
 Show how to:
 Set a variable with a name including the 'Δ', (delta character), to 1 
 Increment it
 Print its value.


Related task
 
 Case-sensitivity of identifiers

",#C.23,C#,"class Program
{
    static void Main()
    {
        var Δ = 1;
        Δ++;
        System.Console.WriteLine(Δ);        
    }
}",129,9
5810,http://rosettacode.org/wiki/Unbias_a_random_generator,Unbias a random generator,"




P

1




{\displaystyle P_{1}}







P

0




{\displaystyle P_{0}}







P

1




{\displaystyle P_{1}}







P

0




{\displaystyle P_{0}}







P

0




{\displaystyle P_{0}}







P

1




{\displaystyle P_{1}}




Task details

 Use your language's random number generator to create a function/method/subroutine/... randN that returns a one or a zero, but with one occurring, on average, 1 out of N times, where N is an integer from the range 3 to 6 inclusive.
 Create a function unbiased that uses only randN as its source of randomness to become an unbiased generator of random ones and zeroes.
 For N over its range, generate and show counts of the outputs of randN and unbiased(randN).


The actual unbiasing should be done by generating two numbers at a time from randN and only returning a 1 or 0 if they are different. As long as you always return the first number or always return the second number, the probabilities discussed above should take over the biased probability of randN.

This task is an implementation of Von Neumann debiasing, first described in a 1951 paper.



",#C.23,C#,"using System;
 
namespace Unbias
{
    internal class Program
    {
        private static void Main(string[] args)
        {
            // Demonstrate.
            for (int n = 3; n <= 6; n++)
            {
                int biasedZero = 0, biasedOne = 0, unbiasedZero = 0, unbiasedOne = 0;
                for (int i = 0; i < 100000; i++)
                {
                    if (randN(n))
                        biasedOne++;
                    else
                        biasedZero++;
                    if (Unbiased(n))
                        unbiasedOne++;
                    else
                        unbiasedZero++;
                }
 
                Console.WriteLine(""(N = {0}):"".PadRight(17) + ""# of 0\t# of 1\t% of 0\t% of 1"", n);
                Console.WriteLine(""Biased:"".PadRight(15) + ""{0}\t{1}\t{2}\t{3}"",
                                  biasedZero, biasedOne,
                                  biasedZero/1000, biasedOne/1000);
                Console.WriteLine(""Unbiased:"".PadRight(15) + ""{0}\t{1}\t{2}\t{3}"",
                                  unbiasedZero, unbiasedOne,
                                  unbiasedZero/1000, unbiasedOne/1000);
            }
        }
 
        private static bool Unbiased(int n)
        {
            bool flip1, flip2;
 
            /* Flip twice, and check if the values are the same.
             * If so, flip again. Otherwise, return the value of the first flip. */
 
            do
            {
                flip1 = randN(n);
                flip2 = randN(n);
            } while (flip1 == flip2);
 
            return flip1;
        }
 
        private static readonly Random random = new Random();
 
        private static bool randN(int n)
        {
            // Has an 1/n chance of returning 1. Otherwise it returns 0.
            return random.Next(0, n) == 0;
        }
    }
}",1866,59
5820,http://rosettacode.org/wiki/Unicode_strings,Unicode strings,"As the world gets smaller each day, internationalization becomes more and more important.   For handling multiple languages, Unicode is your best friend.

It is a very capable tool, but also quite complex compared to older single- and double-byte character encodings.

How well prepared is your programming language for Unicode?



Task

Discuss and demonstrate its unicode awareness and capabilities.



Some suggested topics:

   How easy is it to present Unicode strings in source code? 
   Can Unicode literals be written directly, or be part of identifiers/keywords/etc?
   How well can the language communicate with the rest of the world? 
   Is it good at input/output with Unicode?
   Is it convenient to manipulate Unicode strings in the language?
   How broad/deep does the language support Unicode? 
   What encodings (e.g. UTF-8, UTF-16, etc) can be used? 
   Does it support normalization?


Note

This task is a bit unusual in that it encourages general discussion rather than clever coding.



See also

   Unicode variable names
   Terminal control/Display an extended character

",#C.23,C#," 
(defvar ♥♦♣♠ ""♥♦♣♠"")
(defun ✈ () ""a plane unicode function"")
 ",64,4
5982,http://rosettacode.org/wiki/Twin_primes,Twin primes,"Twin primes are pairs of natural numbers   (P1  and  P2)   that satisfy the following:

     P1   and   P2   are primes
     P1  +  2   =   P2


Task

Write a program that displays the number of pairs of twin primes that can be found under a user-specified number

(P1 < user-specified number & P2 < user-specified number).



Extension

 Find all twin prime pairs under 100000, 10000000 and 1000000000.
 What is the time complexity of the program? Are there ways to reduce computation time?


Examples

> Search Size: 100
> 8 twin prime pairs.

> Search Size: 1000
> 35 twin prime pairs.



Also see

   The OEIS entry: A001097: Twin primes. 
   The OEIS entry: A167874: The number of distinct primes < 10^n which are members of twin-prime pairs. 
   The OEIS entry: A077800: List of twin primes {p, p+2}, with repetition. 
   The OEIS entry: A007508: Number of twin prime pairs below 10^n. 

",#C.23,C#,"using System;
 
class Program {
 
    static uint[] res = new uint[10];
    static uint ri = 1, p = 10, count = 0;
 
    static void TabulateTwinPrimes(uint bound) {
        if (bound < 5) return; count++;
        uint cl = (bound - 1) >> 1, i = 1, j,
             limit = (uint)(Math.Sqrt(bound) - 1) >> 1;
        var comp = new bool[cl]; bool lp;
        for (j = 3; j < cl; j += 3) comp[j] = true;
        while (i < limit) {
            if (lp = !comp[i]) {
                uint pr = (i << 1) + 3;
                for (j = (pr * pr - 2) >> 1; j < cl; j += pr)
                    comp[j] = true;
            }
            if (!comp[++i]) {
                uint pr = (i << 1) + 3;
                if (lp) {
                    if (pr > p) {
                        res[ri++] = count;
                        p *= 10;
                    }
                    count++;
                    i++;
                }
                for (j = (pr * pr - 2) >> 1; j < cl; j += pr)
                    comp[j] = true; 
            }
        }
        cl--;
        while (i < cl) {
            lp = !comp[i++];
            if (!comp[i] && lp) {
                if ((i++ << 1) + 3 > p) {
                    res[ri++] = count;
                    p *= 10;
                }
                count++;
            }
        }
        res[ri] = count;
    }
 
    static void Main(string[] args) {
        var sw = System.Diagnostics.Stopwatch.StartNew();
        string fmt = ""{0,9:n0} twin primes below {1,-13:n0}"";
        TabulateTwinPrimes(1_000_000_000);
        sw.Stop();
        p = 1;
        for (var j = 1; j <= ri; j++)
            Console.WriteLine(fmt, res[j], p *= 10);
        Console.Write(""{0} sec"", sw.Elapsed.TotalSeconds);
    }
}",1742,58
6089,http://rosettacode.org/wiki/Truncate_a_file,Truncate a file,"Task

Truncate a file to a specific length.   This should be implemented as a routine that takes two parameters: the filename and the required file length (in bytes).



Truncation can be achieved using system or library calls intended for such a task, if such methods exist, or by creating a temporary file of a reduced size and renaming it, after first deleting the original file, if no other method is available.   The file may contain non human readable binary data in an unspecified format, so the routine should be ""binary safe"", leaving the contents of the untruncated part of the file unchanged.

If the specified filename does not exist, or the provided length is not less than the current file length, then the routine should raise an appropriate error condition.

On some systems, the provided file truncation facilities might not change the file or may extend the file, if the specified length is greater than the current length of the file.

This task permits the use of such facilities.   However, such behaviour should be noted, or optionally a warning message relating to an non change or increase in file size may be implemented.



",#C.23,C#,"using System;
using System.IO;
 
namespace TruncateFile
{
    internal class Program
    {
        private static void Main(string[] args)
        {
            TruncateFile(args[0], long.Parse(args[1]));
        }
 
        private static void TruncateFile(string path, long length)
        {
            if (!File.Exists(path))
                throw new ArgumentException(""No file found at specified path."", ""path"");
 
            using (var fileStream = new FileStream(path, FileMode.Open, FileAccess.Write))
            {
                if (fileStream.Length < length)
                    throw new ArgumentOutOfRangeException(""length"",
                                                          ""The specified length is greater than that of the file."");
 
                fileStream.SetLength(length);
            }
        }
    }
}",838,28
6195,http://rosettacode.org/wiki/Twelve_statements,Twelve statements,"This puzzle is borrowed from   math-frolic.blogspot.



Given the following twelve statements, which of them are true?

 1.  This is a numbered list of twelve statements.
 2.  Exactly 3 of the last 6 statements are true.
 3.  Exactly 2 of the even-numbered statements are true.
 4.  If statement 5 is true, then statements 6 and 7 are both true.
 5.  The 3 preceding statements are all false.
 6.  Exactly 4 of the odd-numbered statements are true.
 7.  Either statement 2 or 3 is true, but not both.
 8.  If statement 7 is true, then 5 and 6 are both true.
 9.  Exactly 3 of the first 6 statements are true.
10.  The next two statements are both true.
11.  Exactly 1 of statements 7, 8 and 9 are true.
12.  Exactly 4 of the preceding statements are true.



Task

When you get tired of trying to figure it out in your head,
write a program to solve it, and print the correct answer or answers.



Extra credit

Print out a table of near misses, that is, solutions that are contradicted by only a single statement.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
public static class TwelveStatements
{
    public static void Main() {
        Func<Statements, bool>[] checks = {
            st => st[1],
            st => st[2] == (7.To(12).Count(i => st[i]) == 3),
            st => st[3] == (2.To(12, by: 2).Count(i => st[i]) == 2),
            st => st[4] == st[5].Implies(st[6] && st[7]),
            st => st[5] == (!st[2] && !st[3] && !st[4]),
            st => st[6] == (1.To(12, by: 2).Count(i => st[i]) == 4),
            st => st[7] == (st[2] != st[3]),
            st => st[8] == st[7].Implies(st[5] && st[6]),
            st => st[9] == (1.To(6).Count(i => st[i]) == 3),
            st => st[10] == (st[11] && st[12]),
            st => st[11] == (7.To(9).Count(i => st[i]) == 1),
            st => st[12] == (1.To(11).Count(i => st[i]) == 4)
        };
 
        for (Statements statements = new Statements(0); statements.Value < 4096; statements++) {
            int count = 0;
            int falseIndex = 0;
            for (int i = 0; i < checks.Length; i++) {
                if (checks[i](statements)) count++;
                else falseIndex = i;
            }
            if (count == 0) Console.WriteLine($""{""All wrong:"", -13}{statements}"");
            else if (count == 11) Console.WriteLine($""{$""Wrong at {falseIndex + 1}:"", -13}{statements}"");
            else if (count == 12) Console.WriteLine($""{""All correct:"", -13}{statements}"");
        }
    }
 
    struct Statements
    {    
        public Statements(int value) : this() { Value = value; }
 
        public int Value { get; }
 
        public bool this[int index] => (Value & (1 << index - 1)) != 0;
 
        public static Statements operator ++(Statements statements) => new Statements(statements.Value + 1);
 
        public override string ToString() {
            Statements copy = this; //Cannot access 'this' in anonymous method...
            return string.Join("" "", from i in 1.To(12) select copy[i] ? ""T"" : ""F"");
        }
 
    }
 
    //Extension methods
    static bool Implies(this bool x, bool y) => !x || y;
 
    static IEnumerable<int> To(this int start, int end, int by = 1) {
        while (start <= end) {
            yield return start;
            start += by;
        }
    }
 
}",2294,63
6212,http://rosettacode.org/wiki/Truth_table,Truth table,"A truth table is a display of the inputs to, and the output of a Boolean function organized as a table where each row gives one combination of input values and the corresponding value of the function.



Task

 Input a Boolean function from the user as a string then calculate and print a formatted truth table for the given function.
 (One can assume that the user input is correct).
 Print and show output for Boolean functions of two and three input variables, but any program should not be limited to that many variables in the function. 
 Either reverse-polish or infix notation expressions are allowed.


Related tasks

   Boolean values
   Ternary logic


See also

   Wolfram MathWorld entry on truth tables.
   some ""truth table"" examples from Google.

",#C.23,C#,"using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
public class TruthTable
{
    enum TokenType { Unknown, WhiteSpace, Constant, Operand, Operator, LeftParenthesis, RightParenthesis }
 
    readonly char trueConstant, falseConstant;
    readonly IDictionary<char, Operator> operators = new Dictionary<char, Operator>();
 
    public TruthTable(char falseConstant, char trueConstant)
    {
        this.trueConstant = trueConstant;
        this.falseConstant = falseConstant;
        Operators = new OperatorCollection(operators);
    }
 
    public OperatorCollection Operators { get; }
 
    public void PrintTruthTable(string expression, bool isPostfix = false)
    {
        try {
            foreach (string line in GetTruthTable(expression, isPostfix)) {
                Console.WriteLine(line);
            }
        } catch (ArgumentException ex) {
            Console.WriteLine(expression + ""   "" + ex.Message);
        }
    }
 
    public IEnumerable<string> GetTruthTable(string expression, bool isPostfix = false)
    {
        if (string.IsNullOrWhiteSpace(expression)) throw new ArgumentException(""Invalid expression."");
        //Maps parameters to an index in BitSet
        //Makes sure they appear in the truth table in the order they first appear in the expression
        var parameters = expression
            .Where(c => TypeOf(c) == TokenType.Operand)
            .Distinct()
            .Reverse()
            .Select((c, i) => (symbol: c, index: i))
            .ToDictionary(p => p.symbol, p => p.index);
 
        int count = parameters.Count;
        if (count > 32) throw new ArgumentException(""Cannot have more than 32 parameters."");
        string header = count == 0 ? expression : string.Join("" "",
            parameters.OrderByDescending(p => p.Value).Select(p => p.Key)) + "" "" + expression;
 
        if (!isPostfix) expression = ConvertToPostfix(expression);
 
        var values = default(BitSet);
        var stack = new Stack<char>(expression.Length);
        for (int loop = 1 << count; loop > 0; loop--) {
            foreach (char token in expression) stack.Push(token);
            bool result = Evaluate(stack, values, parameters);
            if (header != null) {
                if (stack.Count > 0) throw new ArgumentException(""Invalid expression."");
                yield return header;
                header = null;
            }
            string line = (count == 0 ? """" : "" "") + (result ? trueConstant : falseConstant);
            line = string.Join("" "", Enumerable.Range(0, count)
                .Select(i => values[count - i - 1] ? trueConstant : falseConstant)) + line;
            yield return line;
            values++;
        }
    }
 
    public string ConvertToPostfix(string infix)
    {
        var stack = new Stack<char>();
        var postfix = new StringBuilder();
        foreach (char c in infix) {
            switch (TypeOf(c)) {
            case TokenType.WhiteSpace:
                continue;
            case TokenType.Constant:
            case TokenType.Operand:
                postfix.Append(c);
                break;
            case TokenType.Operator:
                int precedence = Precedence(c);
                while (stack.Count > 0 && Precedence(stack.Peek()) > precedence) {
                    postfix.Append(stack.Pop());
                }
                stack.Push(c);
                break;
            case TokenType.LeftParenthesis:
                stack.Push(c);
                break;
            case TokenType.RightParenthesis:
                char top = default(char);
                while (stack.Count > 0) {
                    top = stack.Pop();
                    if (top == '(') break;
                    else postfix.Append(top);
                }
                if (top != '(') throw new ArgumentException(""No matching left parenthesis."");
                break;
            default:
                throw new ArgumentException(""Invalid character: "" + c);
            }
        }
        while (stack.Count > 0) {
            char top = stack.Pop();
            if (top == '(') throw new ArgumentException(""No matching right parenthesis."");
            postfix.Append(top);
        }
        return postfix.ToString();
    }
 
    private bool Evaluate(Stack<char> expression, BitSet values, IDictionary<char, int> parameters)
    {
        if (expression.Count == 0) throw new ArgumentException(""Invalid expression."");
        char c = expression.Pop();
        TokenType type = TypeOf(c);
        while (type == TokenType.WhiteSpace) type = TypeOf(c = expression.Pop());
        switch (type) {
        case TokenType.Constant:
            return c == trueConstant;
        case TokenType.Operand:
            return values[parameters[c]];
        case TokenType.Operator:
            bool right = Evaluate(expression, values, parameters);
            Operator op = operators[c];
            if (op.Arity == 1) return op.Function(right, right);
            bool left = Evaluate(expression, values, parameters);
            return op.Function(left, right);
        default:
            throw new ArgumentException(""Invalid character: "" + c);
        }
    }
 
    private TokenType TypeOf(char c)
    {
        if (char.IsWhiteSpace(c)) return TokenType.WhiteSpace;
        if (c == '(') return TokenType.LeftParenthesis;
        if (c == ')') return TokenType.RightParenthesis;
        if (c == trueConstant || c == falseConstant) return TokenType.Constant;
        if (operators.ContainsKey(c)) return TokenType.Operator;
        if (char.IsLetter(c)) return TokenType.Operand;
        return TokenType.Unknown;
    }
 
    private int Precedence(char op) => operators.TryGetValue(op, out var o) ? o.Precedence : int.MinValue;
}
 
struct Operator
{
    public Operator(char symbol, int precedence, Func<bool, bool> function) : this(symbol, precedence, 1, (l, r) => function(r)) { }
 
    public Operator(char symbol, int precedence, Func<bool, bool, bool> function) : this(symbol, precedence, 2, function) { }
 
    private Operator(char symbol, int precedence, int arity, Func<bool, bool, bool> function) : this()
    {
        Symbol = symbol;
        Precedence = precedence;
        Arity = arity;
        Function = function;
    }
 
    public char Symbol { get; }
    public int Precedence { get; }
    public int Arity { get; }
    public Func<bool, bool, bool> Function { get; }
}
 
public class OperatorCollection : IEnumerable
{
    readonly IDictionary<char, Operator> operators;
 
    internal OperatorCollection(IDictionary<char, Operator> operators) {
        this.operators = operators;
    }
 
    public void Add(char symbol, int precedence, Func<bool, bool> function)
        => operators[symbol] = new Operator(symbol, precedence, function);
    public void Add(char symbol, int precedence, Func<bool, bool, bool> function)
        => operators[symbol] = new Operator(symbol, precedence, function);
 
    public void Remove(char symbol) => operators.Remove(symbol);
 
    IEnumerator IEnumerable.GetEnumerator() => operators.Values.GetEnumerator();
}
 
struct BitSet
{
    private int bits;
 
    private BitSet(int bits) { this.bits = bits; }
 
    public static BitSet operator ++(BitSet bitSet) => new BitSet(bitSet.bits + 1);
 
    public bool this[int index] => (bits & (1 << index)) != 0;
}
 
class Program
{
    public static void Main() {
        TruthTable tt = new TruthTable('F', 'T') {
            Operators = {
                { '!', 6, r => !r },
                { '&', 5, (l, r) => l && r },
                { '^', 4, (l, r) => l ^ r },
                { '|', 3, (l, r) => l || r }
            }
        };
        //Add a crazy operator:
        var rng = new Random();
        tt.Operators.Add('?', 6, r => rng.NextDouble() < 0.5);
        string[] expressions = {
            ""!!!T"",
            ""?T"",
            ""F & x | T"",
            ""F & (x | T"",
            ""F & x | T)"",
            ""a ! (a & a)"",
            ""a | (a * a)"",
            ""a ^ T & (b & !c)"",
        };
        foreach (string expression in expressions) {
            tt.PrintTruthTable(expression);
            Console.WriteLine();
        }
 
        //Define a different language
        tt = new TruthTable('0', '1') {
            Operators = {
                { '-', 6, r => !r },
                { '^', 5, (l, r) => l && r },
                { 'v', 3, (l, r) => l || r },
                { '>', 2, (l, r) => !l || r },
                { '=', 1, (l, r) => l == r },
            }
        };
        expressions = new[] {
            ""-X v 0 = X ^ 1"",
            ""(H > M) ^ (S > H) > (S > M)""
        };
        foreach (string expression in expressions) {
            tt.PrintTruthTable(expression);
            Console.WriteLine();
        }
    }
}",8852,247
6288,http://rosettacode.org/wiki/Truncatable_primes,Truncatable primes,"A truncatable prime is a prime number that when you successively remove digits from one end of the prime, you are left with a new prime number.



Examples

The number 997 is called a left-truncatable prime as the numbers 997, 97, and 7 are all prime.

The number 7393 is a right-truncatable prime as the numbers 7393, 739, 73, and 7 formed by removing digits from its right are also prime.

No zeroes are allowed in truncatable primes.



Task

The task is to find the largest left-truncatable and right-truncatable primes less than one million (base 10 is implied).



Related tasks
 
 Find largest left truncatable prime in a given base
 Sieve of Eratosthenes


See also

 Truncatable Prime from MathWorld.]

",#C.23,C#,"using System;  // 4790@3.6
using System.Collections.Generic;
class truncatable_primes
{
    static void Main()
    {
        uint m = 1000000;
        Console.Write(""L "" + L(m) + "" R "" + R(m) + ""  "");
        var sw = System.Diagnostics.Stopwatch.StartNew();
        for (int i = 1000; i > 0; i--) { L(m); R(m); }
        Console.Write(sw.Elapsed); Console.Read();
    }
 
    static uint L(uint n)
    {
        n -= n & 1; n--;
        for (uint d, d1 = 100; ; n -= 2)
        {
            while (n % 3 == 0 || n % 5 == 0 || n % 7 == 0) n -= 2;
            if ((d = n % 10) == 3 || d == 7)
            {
                while (d1 < n && d < (d = n % d1) && isP(d)) d1 *= 10;
                if (d1 > n && isP(n)) return n; d1 = 100;
            }
        }
    }
 
    static uint R(uint m)
    {
        var p = new List<uint>() { 2, 3, 5, 7 }; uint n = 20, np;
        for (int i = 1; i < p.Count; n = 10 * p[i++])
        {
            if ((np = n + 1) >= m) break; if (isP(np)) p.Add(np);
            if ((np = n + 3) >= m) break; if (isP(np)) p.Add(np);
            if ((np = n + 7) >= m) break; if (isP(np)) p.Add(np);
            if ((np = n + 9) >= m) break; if (isP(np)) p.Add(np);
        }
        return p[p.Count - 1];
    }
 
    static bool isP(uint n)
    {
        if (n < 7) return n == 2 || n == 3 || n == 5;
        if ((n & 1) == 0 || n % 3 == 0 || n % 5 == 0) return false;
        for (uint r = (uint)Math.Sqrt(n), d = 7; d <= r; d += 30)
            if (n % (d + 00) == 0 || n % (d + 04) == 0 ||
                n % (d + 06) == 0 || n % (d + 10) == 0 ||
                n % (d + 12) == 0 || n % (d + 16) == 0 ||
                n % (d + 22) == 0 || n % (d + 24) == 0) return false;
        return true;
    }
}",1737,52
6360,http://rosettacode.org/wiki/Universal_Turing_machine,Universal Turing machine,"One of the foundational mathematical constructs behind computer science
is the universal Turing Machine.



(Alan Turing introduced the idea of such a machine in 1936–1937.)

Indeed one way to definitively prove that a language
is turing-complete
is to implement a universal Turing machine in it.



Task

Simulate such a machine capable
of taking the definition of any other Turing machine and executing it.

Of course, you will not have an infinite tape,
but you should emulate this as much as is possible.

The three permissible actions on the tape are ""left"", ""right"" and ""stay"".

To test your universal Turing machine (and prove your programming language
is Turing complete!), you should execute the following two Turing machines
based on the following definitions.


Simple incrementer

 States: q0, qf
 Initial state: q0
 Terminating states: qf
 Permissible symbols: B, 1
 Blank symbol: B
 Rules:
 (q0, 1, 1, right, q0)
 (q0, B, 1, stay, qf)


The input for this machine should be a tape of 1 1 1


Three-state busy beaver

 States: a, b, c, halt
 Initial state: a
 Terminating states: halt
 Permissible symbols: 0, 1
 Blank symbol: 0
 Rules:
 (a, 0, 1, right, b)
 (a, 1, 1, left, c)
 (b, 0, 1, left, a)
 (b, 1, 1, right, b)
 (c, 0, 1, left, b)
 (c, 1, 1, stay, halt)


The input for this machine should be an empty tape.


Bonus:

5-state, 2-symbol probable Busy Beaver machine from Wikipedia

 States: A, B, C, D, E, H
 Initial state: A
 Terminating states: H
 Permissible symbols: 0, 1
 Blank symbol: 0
 Rules:
 (A, 0, 1, right, B)
 (A, 1, 1, left, C)
 (B, 0, 1, right, C)
 (B, 1, 1, right, B)
 (C, 0, 1, right, D)
 (C, 1, 0, left, E)
 (D, 0, 1, left, A)
 (D, 1, 1, left, D)
 (E, 0, 1, stay, H)
 (E, 1, 0, left, A)


The input for this machine should be an empty tape.

This machine runs for more than 47 millions steps.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
 
public class TuringMachine
{
    public static async Task Main() {
        var fiveStateBusyBeaver = new TuringMachine(""A"", '0', ""H"").WithTransitions(
            (""A"", '0', '1', Right, ""B""),
            (""A"", '1', '1', Left,  ""C""),
            (""B"", '0', '1', Right, ""C""),
            (""B"", '1', '1', Right, ""B""),
            (""C"", '0', '1', Right, ""D""),
            (""C"", '1', '0', Left,  ""E""),
            (""D"", '0', '1', Left,  ""A""),
            (""D"", '1', '1', Left,  ""D""),
            (""E"", '0', '1', Stay,  ""H""),
            (""E"", '1', '0', Left,  ""A"")
        );
        var busyBeaverTask = fiveStateBusyBeaver.TimeAsync();
 
        var incrementer = new TuringMachine(""q0"", 'B', ""qf"").WithTransitions(
            (""q0"", '1', '1', Right, ""q0""),
            (""q0"", 'B', '1', Stay,  ""qf"")
        )
        .WithInput(""111"");
        foreach (var _ in incrementer.Run()) PrintLine(incrementer);
        PrintResults(incrementer);
 
        var threeStateBusyBeaver = new TuringMachine(""a"", '0', ""halt"").WithTransitions(
            (""a"", '0', '1', Right, ""b""),
            (""a"", '1', '1', Left,  ""c""),
            (""b"", '0', '1', Left,  ""a""),
            (""b"", '1', '1', Right, ""b""),
            (""c"", '0', '1', Left,  ""b""),
            (""c"", '1', '1', Stay,  ""halt"")
        );
        foreach (var _ in threeStateBusyBeaver.Run()) PrintLine(threeStateBusyBeaver);
        PrintResults(threeStateBusyBeaver);
 
        var sorter = new TuringMachine(""A"", '*', ""X"").WithTransitions(
            (""A"", 'a', 'a', Right, ""A""),
            (""A"", 'b', 'B', Right, ""B""),
            (""A"", '*', '*', Left,  ""E""),
            (""B"", 'a', 'a', Right, ""B""),
            (""B"", 'b', 'b', Right, ""B""),
            (""B"", '*', '*', Left,  ""C""),
            (""C"", 'a', 'b', Left,  ""D""),
            (""C"", 'b', 'b', Left,  ""C""),
            (""C"", 'B', 'b', Left,  ""E""),
            (""D"", 'a', 'a', Left,  ""D""),
            (""D"", 'b', 'b', Left,  ""D""),
            (""D"", 'B', 'a', Right, ""A""),
            (""E"", 'a', 'a', Left,  ""E""),
            (""E"", '*', '*', Right, ""X"")
        )
        .WithInput(""babbababaa"");
        sorter.Run().Last();
        Console.WriteLine(""Sorted: "" + sorter.TapeString);
        PrintResults(sorter);
 
        sorter.Reset().WithInput(""bbbababaaabba"");
        sorter.Run().Last();
        Console.WriteLine(""Sorted: "" + sorter.TapeString);
        PrintResults(sorter);
 
        Console.WriteLine(await busyBeaverTask);
        PrintResults(fiveStateBusyBeaver);
 
        void PrintLine(TuringMachine tm) => Console.WriteLine(tm.TapeString + ""\tState "" + tm.State);
 
        void PrintResults(TuringMachine tm) {
            Console.WriteLine($""End state: {tm.State} = {(tm.Success ? ""Success"" : ""Failure"")}"");
            Console.WriteLine(tm.Steps + "" steps"");
            Console.WriteLine(""tape length: "" + tm.TapeLength);
            Console.WriteLine();
        }
    }
 
    public const int Left = -1, Stay = 0, Right = 1;
    private readonly Tape tape;
    private readonly string initialState;
    private readonly HashSet<string> terminatingStates;
    private Dictionary<(string state, char read), (char write, int move, string toState)> transitions;
 
    public TuringMachine(string initialState, char blankSymbol, params string[] terminatingStates) {
        State = this.initialState = initialState;
        tape = new Tape(blankSymbol);
        this.terminatingStates = terminatingStates.ToHashSet();
    }
 
    public TuringMachine WithTransitions(
        params (string state, char read, char write, int move, string toState)[] transitions)
    {
        this.transitions = transitions.ToDictionary(k => (k.state, k.read), k => (k.write, k.move, k.toState));
        return this;
    }
 
    public TuringMachine Reset() {
        State = initialState;
        Steps = 0;
        tape.Reset();
        return this;
    }
 
    public TuringMachine WithInput(string input) {
        tape.Input(input);
        return this;
    }
 
    public int Steps { get; private set; }
    public string State { get; private set; }
    public bool Success => terminatingStates.Contains(State);
    public int TapeLength => tape.Length;
    public string TapeString => tape.ToString();
 
    public IEnumerable<string> Run() {
        yield return State;
        while (Step()) yield return State;
    }
 
    public async Task<TimeSpan> TimeAsync(CancellationToken cancel = default) {
        var chrono = Stopwatch.StartNew();
        await RunAsync(cancel);
        chrono.Stop();
        return chrono.Elapsed;
    }
 
    public Task RunAsync(CancellationToken cancel = default)
        => Task.Run(() => {
            while (Step()) cancel.ThrowIfCancellationRequested();
        });
 
    private bool Step() {
        if (!transitions.TryGetValue((State, tape.Current), out var action)) return false;
        tape.Current = action.write;
        tape.Move(action.move);
        State = action.toState;
        Steps++;
        return true;
    }
 
 
    private class Tape
    {
        private List<char> forwardTape = new List<char>(), backwardTape = new List<char>();
        private int head = 0;
        private char blank;
 
        public Tape(char blankSymbol) => forwardTape.Add(blank = blankSymbol);
 
        public void Reset() {
            backwardTape.Clear();
            forwardTape.Clear();
            head = 0;
            forwardTape.Add(blank);
        }
 
        public void Input(string input) {
            Reset();
            forwardTape.Clear();
            forwardTape.AddRange(input);
        }
 
        public void Move(int direction) {
            head += direction;
            if (head >= 0 && forwardTape.Count <= head) forwardTape.Add(blank);
            if (head < 0 && backwardTape.Count <= ~head) backwardTape.Add(blank);
        }
 
        public char Current {
            get => head < 0 ? backwardTape[~head] : forwardTape[head];
            set {
                if (head < 0) backwardTape[~head] = value;
                else forwardTape[head] = value;
            }
        }
 
        public int Length => backwardTape.Count + forwardTape.Count;
 
        public override string ToString() {
            int h = (head < 0 ? ~head : backwardTape.Count + head) * 2 + 1;
            var builder = new StringBuilder("" "", Length * 2 + 1);
            if (backwardTape.Count > 0) {
                builder.Append(string.Join("" "", backwardTape)).Append("" "");
                if (head < 0) (builder[h + 1], builder[h - 1]) = ('(', ')');
                for (int l = 0, r = builder.Length - 1; l < r; l++, r--) (builder[l], builder[r]) = (builder[r], builder[l]);
            }
            builder.Append(string.Join("" "", forwardTape)).Append("" "");
            if (head >= 0) (builder[h - 1], builder[h + 1]) = ('(', ')');
            return builder.ToString();
        }
 
    }
 
}",7039,200
6506,http://rosettacode.org/wiki/Totient_function,Totient function,"The   totient   function is also known as:

   Euler's totient function
   Euler's phi totient function
   phi totient function
    Φ    function   (uppercase Greek phi)
    φ     function   (lowercase Greek phi)


Definitions   (as per number theory)

The totient function:

   counts the integers up to a given positive integer   n   that are relatively prime to   n
   counts the integers   k   in the range   1 ≤ k ≤ n   for which the greatest common divisor   gcd(n,k)   is equal to   1
   counts numbers   ≤ n   and   prime to   n


If the totient number   (for N)   is one less than   N,   then   N   is prime.



Task

Create a   totient   function and:

   Find and display   (1 per line)   for the 1st   25   integers:
   the integer   (the index)
   the totient number for that integer
   indicate if that integer is prime
   Find and display the   count   of the primes up to          100
   Find and display the   count   of the primes up to       1,000
   Find and display the   count   of the primes up to     10,000
   Find and display the   count   of the primes up to   100,000     (optional)
Show all output here.



Related task

   Perfect totient numbers


Also see

   Wikipedia: Euler's totient function.
   MathWorld: totient function.
   OEIS: Euler totient function phi(n).

",#C.23,C#,"using static System.Console;
using static System.Linq.Enumerable;
 
public class Program
{
    static void Main()
    {
        for (int i = 1; i <= 25; i++) {
            int t = Totient(i);
            WriteLine(i + ""\t"" + t + (t == i - 1 ? ""\tprime"" : """"));
        }
        WriteLine();
        for (int i = 100; i <= 100_000; i *= 10) {
            WriteLine($""{Range(1, i).Count(x => Totient(x) + 1 == x):n0} primes below {i:n0}"");
        }
    }
 
    static int Totient(int n) {
        if (n < 3) return 1;
        if (n == 3) return 2;
 
        int totient = n;
 
        if ((n & 1) == 0) {
            totient >>= 1;
            while (((n >>= 1) & 1) == 0) ;
        }
 
        for (int i = 3; i * i <= n; i += 2) {
            if (n % i == 0) {
                totient -= totient / i;
                while ((n /= i) % i == 0) ;
            }
        }
        if (n > 1) totient -= totient / n;
        return totient;
    }
}",945,38
6564,http://rosettacode.org/wiki/Tonelli-Shanks_algorithm,Tonelli-Shanks algorithm,"

 This page uses content from Wikipedia. The original article was at Tonelli-Shanks algorithm. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In computational number theory, the Tonelli–Shanks algorithm is a technique for solving for x in a congruence of the form:


 x2 ≡ n (mod p)

where n is an integer which is a quadratic residue (mod p), p is an odd prime, and x,n ∈ Fp where Fp = {0, 1, ..., p - 1}.

It is used in cryptography techniques.



To apply the algorithm, we need the Legendre symbol:

The Legendre symbol (a | p) denotes the value of a(p-1)/2 (mod p).

 (a | p) ≡ 1    if a is a square (mod p)
 (a | p) ≡ -1    if a is not a square (mod p)
 (a | p) ≡ 0    if a ≡ 0 (mod p) 


Algorithm pseudo-code


All ≡ are taken to mean (mod p) unless stated otherwise.

 Input: p an odd prime, and an integer n .
 Step 0: Check that n is indeed a square: (n | p) must be ≡ 1 .
 Step 1: By factoring out powers of 2 from p - 1, find q and s such that p - 1 = q2s with q odd .
 If p ≡ 3 (mod 4) (i.e. s = 1), output the two solutions r ≡ ± n(p+1)/4 .
 Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq .
 Step 3: Set r ≡ n(q+1)/2, t ≡ nq, m = s .
 Step 4: Loop the following:
 If t ≡ 1, output r and p - r .
 Otherwise find, by repeated squaring, the lowest i, 0 < i < m , such that t2i ≡ 1 .
 Let b ≡ c2(m - i - 1), and set r ≡ rb, t ≡ tb2, c ≡ b2 and m = i .




Task

Implement the above algorithm.

Find solutions (if any) for

 n = 10 p = 13
 n = 56 p = 101
 n = 1030 p = 10009
 n = 1032 p = 10009
 n = 44402 p = 100049 
Extra credit

 n = 665820697 p = 1000000009 
 n = 881398088036 p = 1000000000039 
 n = 41660815127637347468140745042827704103445750172002 p = 10^50 + 577 


See also

 Modular exponentiation
 Cipolla's algorithm

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Numerics;
 
namespace TonelliShanks {
    class Solution {
        private readonly BigInteger root1, root2;
        private readonly bool exists;
 
        public Solution(BigInteger root1, BigInteger root2, bool exists) {
            this.root1 = root1;
            this.root2 = root2;
            this.exists = exists;
        }
 
        public BigInteger Root1() {
            return root1;
        }
 
        public BigInteger Root2() {
            return root2;
        }
 
        public bool Exists() {
            return exists;
        }
    }
 
    class Program {
        static Solution Ts(BigInteger n, BigInteger p) {
            if (BigInteger.ModPow(n, (p - 1) / 2, p) != 1) {
                return new Solution(0, 0, false);
            }
 
            BigInteger q = p - 1;
            BigInteger ss = 0;
            while ((q & 1) == 0) {
                ss = ss + 1;
                q = q >> 1;
            }
 
            if (ss == 1) {
                BigInteger r1 = BigInteger.ModPow(n, (p + 1) / 4, p);
                return new Solution(r1, p - r1, true);
            }
 
            BigInteger z = 2;
            while (BigInteger.ModPow(z, (p - 1) / 2, p) != p - 1) {
                z = z + 1;
            }
            BigInteger c = BigInteger.ModPow(z, q, p);
            BigInteger r = BigInteger.ModPow(n, (q + 1) / 2, p);
            BigInteger t = BigInteger.ModPow(n, q, p);
            BigInteger m = ss;
 
            while (true) {
                if (t == 1) {
                    return new Solution(r, p - r, true);
                }
                BigInteger i = 0;
                BigInteger zz = t;
                while (zz != 1 && i < (m - 1)) {
                    zz = zz * zz % p;
                    i = i + 1;
                }
                BigInteger b = c;
                BigInteger e = m - i - 1;
                while (e > 0) {
                    b = b * b % p;
                    e = e - 1;
                }
                r = r * b % p;
                c = b * b % p;
                t = t * c % p;
                m = i;
            }
        }
 
        static void Main(string[] args) {
            List<Tuple<long, long>> pairs = new List<Tuple<long, long>>() {
                new Tuple<long, long>(10, 13),
                new Tuple<long, long>(56, 101),
                new Tuple<long, long>(1030, 10009),
                new Tuple<long, long>(1032, 10009),
                new Tuple<long, long>(44402, 100049),
                new Tuple<long, long>(665820697, 1000000009),
                new Tuple<long, long>(881398088036, 1000000000039),
            };
 
            foreach (var pair in pairs) {
                Solution sol = Ts(pair.Item1, pair.Item2);
                Console.WriteLine(""n = {0}"", pair.Item1);
                Console.WriteLine(""p = {0}"", pair.Item2);
                if (sol.Exists()) {
                    Console.WriteLine(""root1 = {0}"", sol.Root1());
                    Console.WriteLine(""root2 = {0}"", sol.Root2());
                } else {
                    Console.WriteLine(""No solution exists"");
                }
                Console.WriteLine();
            }
 
            BigInteger bn = BigInteger.Parse(""41660815127637347468140745042827704103445750172002"");
            BigInteger bp = BigInteger.Pow(10, 50) + 577;
            Solution bsol = Ts(bn, bp);
            Console.WriteLine(""n = {0}"", bn);
            Console.WriteLine(""p = {0}"", bp);
            if (bsol.Exists()) {
                Console.WriteLine(""root1 = {0}"", bsol.Root1());
                Console.WriteLine(""root2 = {0}"", bsol.Root2());
            } else {
                Console.WriteLine(""No solution exists"");
            }
        }
    }
}",3804,116
6567,http://rosettacode.org/wiki/Topological_sort,Topological sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




Given a mapping between items, and items they depend on, a topological sort orders items so that no item precedes an item it depends upon.

The compiling of a library in the VHDL language has the constraint that a library must be compiled after any library it depends on.

A tool exists that extracts library dependencies.



Task

Write a function that will return a valid compile order of VHDL libraries from their dependencies.

 Assume library names are single words. 
 Items mentioned as only dependents, (sic), have no dependents of their own, but their order of compiling must be given.
 Any self dependencies should be ignored. 
 Any un-orderable dependencies should be flagged.


Use the following data as an example:

LIBRARY          LIBRARY DEPENDENCIES
=======          ====================
des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee
dw01             ieee dw01 dware gtech
dw02             ieee dw02 dware
dw03             std synopsys dware dw03 dw02 dw01 ieee gtech
dw04             dw04 ieee dw01 dware gtech
dw05             dw05 ieee dware
dw06             dw06 ieee dware
dw07             ieee dware
dware            ieee dware
gtech            ieee gtech
ramlib           std ieee
std_cell_lib     ieee std_cell_lib
synopsys


Note: the above data would be un-orderable if, for example, dw04 is added to the list of dependencies of dw01.



C.f.

   Topological sort/Extracted top item.


There are two popular algorithms for topological sorting:

   Kahn's 1962 topological sort [1] 
   depth-first search [2] [3]

",#C.23,C#," 
namespace Algorithms
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
 
    public class TopologicalSorter<ValueType>
    {
        private class Relations
        {
            public int Dependencies = 0;
            public HashSet<ValueType> Dependents = new HashSet<ValueType>();
        }
 
        private Dictionary<ValueType, Relations> _map = new Dictionary<ValueType, Relations>();
 
        public void Add(ValueType obj)
        {
            if (!_map.ContainsKey(obj)) _map.Add(obj, new Relations());
        }
 
        public void Add(ValueType obj, ValueType dependency)
        {
            if (dependency.Equals(obj)) return;
 
            if (!_map.ContainsKey(dependency)) _map.Add(dependency, new Relations());
 
            var dependents = _map[dependency].Dependents;
 
            if (!dependents.Contains(obj))
            {
                dependents.Add(obj);
 
                if (!_map.ContainsKey(obj)) _map.Add(obj, new Relations());
 
                ++_map[obj].Dependencies;
            }
        }
 
        public void Add(ValueType obj, IEnumerable<ValueType> dependencies)
        {
            foreach (var dependency in dependencies) Add(obj, dependency);
        }
 
        public void Add(ValueType obj, params ValueType[] dependencies)
        {
            Add(obj, dependencies as IEnumerable<ValueType>);
        }
 
        public Tuple<IEnumerable<ValueType>, IEnumerable<ValueType>> Sort()
        {
            List<ValueType> sorted = new List<ValueType>(), cycled = new List<ValueType>();
            var map = _map.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
 
            sorted.AddRange(map.Where(kvp => kvp.Value.Dependencies == 0).Select(kvp => kvp.Key));
 
            for (int idx = 0; idx < sorted.Count; ++idx) sorted.AddRange(map[sorted[idx]].Dependents.Where(k => --map[k].Dependencies == 0));
 
            cycled.AddRange(map.Where(kvp => kvp.Value.Dependencies != 0).Select(kvp => kvp.Key));
 
            return new Tuple<IEnumerable<ValueType>, IEnumerable<ValueType>>(sorted, cycled);
        }
 
        public void Clear()
        {
            _map.Clear();
        }
    }
 
}
 
/*
	Example usage with Task object
*/
 
namespace ExampleApplication
{
    using Algorithms;
    using System;
    using System.Collections.Generic;
    using System.Linq;
 
    public class Task
    {
        public string Message;
    }
 
    class Program
    {
        static void Main(string[] args)
        {
            List<Task> tasks = new List<Task>
            {
                new Task{ Message = ""A - depends on B and C"" },    //0
                new Task{ Message = ""B - depends on none"" },       //1
                new Task{ Message = ""C - depends on D and E"" },    //2
                new Task{ Message = ""D - depends on none"" },       //3
                new Task{ Message = ""E - depends on F, G and H"" }, //4
                new Task{ Message = ""F - depends on I"" },          //5
                new Task{ Message = ""G - depends on none"" },       //6
                new Task{ Message = ""H - depends on none"" },       //7
                new Task{ Message = ""I - depends on none"" },       //8
            };
 
            TopologicalSorter<Task> resolver = new TopologicalSorter<Task>();
 
            // now setting relations between them as described above
            resolver.Add(tasks[0], new[] { tasks[1], tasks[2] });
            //resolver.Add(tasks[1]); // no need for this since the task was already mentioned as a dependency
            resolver.Add(tasks[2], new[] { tasks[3], tasks[4] });
            //resolver.Add(tasks[3]); // no need for this since the task was already mentioned as a dependency
            resolver.Add(tasks[4], tasks[5], tasks[6], tasks[7]);
            resolver.Add(tasks[5], tasks[8]);
            //resolver.Add(tasks[6]); // no need for this since the task was already mentioned as a dependency
            //resolver.Add(tasks[7]); // no need for this since the task was already mentioned as a dependency
 
            //resolver.Add(tasks[3], tasks[0]); // uncomment this line to test cycled dependency
 
            var result = resolver.Sort();
            var sorted = result.Item1;
            var cycled = result.Item2;
 
            if (!cycled.Any())
            {
                foreach (var d in sorted) Console.WriteLine(d.Message);
            }
            else
            {
                Console.Write(""Cycled dependencies detected: "");
 
                foreach (var d in cycled) Console.Write($""{d.Message[0]} "");
 
                Console.WriteLine();
            }
 
            Console.WriteLine(""exiting..."");
        }
    }
}
 
 ",4712,142
6572,http://rosettacode.org/wiki/Trigonometric_functions,Trigonometric functions,"Task

If your language has a library or built-in functions for trigonometry, show examples of:

   sine
   cosine
   tangent
   inverses   (of the above)

using the same angle in radians and degrees.

For the non-inverse functions,   each radian/degree pair should use arguments that evaluate to the same angle   (that is, it's not necessary to use the same angle for all three regular functions as long as the two sine calls use the same angle).

For the inverse functions,   use the same number and convert its answer to radians and degrees.

If your language does not have trigonometric functions available or only has some available,   write functions to calculate the functions based on any   known approximation or identity.



",#C.23,C#,"using System;
 
namespace RosettaCode {
    class Program {
        static void Main(string[] args) {
            Console.WriteLine(""=== radians ==="");
            Console.WriteLine(""sin (pi/3) = {0}"", Math.Sin(Math.PI / 3));
            Console.WriteLine(""cos (pi/3) = {0}"", Math.Cos(Math.PI / 3));
            Console.WriteLine(""tan (pi/3) = {0}"", Math.Tan(Math.PI / 3));
            Console.WriteLine(""arcsin (1/2) = {0}"", Math.Asin(0.5));
            Console.WriteLine(""arccos (1/2) = {0}"", Math.Acos(0.5));
            Console.WriteLine(""arctan (1/2) = {0}"", Math.Atan(0.5));
            Console.WriteLine("""");
            Console.WriteLine(""=== degrees ==="");
            Console.WriteLine(""sin (60) = {0}"", Math.Sin(60 * Math.PI / 180));
            Console.WriteLine(""cos (60) = {0}"", Math.Cos(60 * Math.PI / 180));
            Console.WriteLine(""tan (60) = {0}"", Math.Tan(60 * Math.PI / 180));
            Console.WriteLine(""arcsin (1/2) = {0}"", Math.Asin(0.5) * 180/ Math.PI);
            Console.WriteLine(""arccos (1/2) = {0}"", Math.Acos(0.5) * 180 / Math.PI);
            Console.WriteLine(""arctan (1/2) = {0}"", Math.Atan(0.5) * 180 / Math.PI);
 
            Console.ReadLine();
        }
    }
}",1208,25
6629,http://rosettacode.org/wiki/Tokenize_a_string_with_escaping,Tokenize a string with escaping,"Task[edit]
Write a function or program that can split a string at each non-escaped occurrence of a separator character.

It should accept three input parameters:

   The string
   The separator character
   The escape character


It should output a list of strings.

Details
Rules for splitting:

 The fields that were separated by the separators, become the elements of the output list.
 Empty fields should be preserved, even at the start and end.


Rules for escaping:

 ""Escaped"" means preceded by an occurrence of the escape character that is not already escaped itself.
 When the escape character precedes a character that has no special meaning, it still counts as an escape (but does not do anything special).
 Each occurrence of the escape character that was used to escape something, should not become part of the output.


Test case
Demonstrate that your function satisfies the following test-case:



 Input

 Output





 string:

 one^|uno||three^^^^|four^^^|^cuatro|


 separator character:

 |


 escape character:

 ^





 one|uno


 


 three^^


 four^|cuatro


 


(Print the output list in any format you like, as long as it is it easy to see what the fields are.)


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.Text;
using System.Collections.Generic;
 
public class TokenizeAStringWithEscaping
{
    public static void Main() {
        string testcase = ""one^|uno||three^^^^|four^^^|^cuatro|"";
        foreach (var token in testcase.Tokenize(separator: '|', escape: '^')) {
            Console.WriteLine("": "" + token); //Adding a : so we can see empty lines
        }
    }
}
 
public static class Extensions
{
    public static IEnumerable<string> Tokenize(this string input, char separator, char escape) {
        if (input == null) yield break;
        var buffer = new StringBuilder();
        bool escaping = false;
        foreach (char c in input) {
            if (escaping) {
                buffer.Append(c);
                escaping = false;
            } else if (c == escape) {
                escaping = true;
            } else if (c == separator) {
                yield return buffer.Flush();
            } else {
                buffer.Append(c);
            }
        }
        if (buffer.Length > 0 || input[input.Length-1] == separator) yield return buffer.Flush();
    }
 
    public static string Flush(this StringBuilder stringBuilder) {
        string result = stringBuilder.ToString();
        stringBuilder.Clear();
        return result;
    }
}",1289,41
6686,http://rosettacode.org/wiki/Tree_traversal,Tree traversal,"Task

Implement a binary tree where each node carries an integer,   and implement:

   pre-order,
   in-order, 
   post-order,     and 
   level-order   traversal. 


Use those traversals to output the following tree:

         1
        / \
       /   \
      /     \
     2       3
    / \     /
   4   5   6
  /       / \
 7       8   9

The correct output should look like this:

preorder:    1 2 4 7 5 3 6 8 9
inorder:     7 4 2 5 1 8 6 9 3
postorder:   7 4 5 2 8 9 6 3 1
level-order: 1 2 3 4 5 6 7 8 9



See also

   Wikipedia article:   Tree traversal.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
class Node
{
    int Value;
    Node Left;
    Node Right;
 
    Node(int value = default(int), Node left = default(Node), Node right = default(Node))
    {
        Value = value;
        Left = left;
        Right = right;
    }
 
    IEnumerable<int> Preorder()
    {
        yield return Value;
        if (Left != null)
            foreach (var value in Left.Preorder())
                yield return value;
        if (Right != null)
            foreach (var value in Right.Preorder())
                yield return value;
    }
 
    IEnumerable<int> Inorder()
    {
        if (Left != null)
            foreach (var value in Left.Inorder())
                yield return value;
        yield return Value;
        if (Right != null)
            foreach (var value in Right.Inorder())
                yield return value;
    }
 
    IEnumerable<int> Postorder()
    {
        if (Left != null)
            foreach (var value in Left.Postorder())
                yield return value;
        if (Right != null)
            foreach (var value in Right.Postorder())
                yield return value;
        yield return Value;
    }
 
    IEnumerable<int> LevelOrder()
    {
        var queue = new Queue<Node>();
        queue.Enqueue(this);
        while (queue.Any())
        {
            var node = queue.Dequeue();
            yield return node.Value;
            if (node.Left != null)
                queue.Enqueue(node.Left);
            if (node.Right != null)
                queue.Enqueue(node.Right);
        }
    }
 
    static void Main()
    {
        var tree = new Node(1, new Node(2, new Node(4, new Node(7)), new Node(5)), new Node(3, new Node(6, new Node(8), new Node(9))));
        foreach (var traversal in new Func<IEnumerable<int>>[] { tree.Preorder, tree.Inorder, tree.Postorder, tree.LevelOrder })
            Console.WriteLine(""{0}:\t{1}"", traversal.Method.Name, string.Join("" "", traversal()));
    }
}",2003,72
6690,http://rosettacode.org/wiki/Thue-Morse,Thue-Morse,"Task

Create a Thue-Morse sequence.



See also
   YouTube entry: The Fairest Sharing Sequence Ever
   YouTube entry: Math and OCD - My story with the Thue-Morse sequence
   Task: Fairshare between two and more

",#C.23,C#,"using System;
using System.Text;
 
namespace ThueMorse
{
    class Program
    {
        static void Main(string[] args)
        {
            Sequence(6);
        }
 
        public static void Sequence(int steps)
        {
            var sb1 = new StringBuilder(""0"");
            var sb2 = new StringBuilder(""1"");
            for (int i = 0; i < steps; i++)
            {
                var tmp = sb1.ToString();
                sb1.Append(sb2);
                sb2.Append(tmp);
            }
            Console.WriteLine(sb1);
            Console.ReadLine();
        }
    }
}",582,27
6759,http://rosettacode.org/wiki/Top_rank_per_group,Top rank per group,"Task

Find the top   N   salaries in each department,   where   N   is provided as a parameter.

Use this data as a formatted internal data structure (adapt it to your language-native idioms, rather than parse at runtime), or identify your external data source:

Employee Name,Employee ID,Salary,Department
Tyler Bennett,E10297,32000,D101
John Rappl,E21437,47000,D050
George Woltman,E00127,53500,D101
Adam Smith,E63535,18000,D202
Claire Buckman,E39876,27800,D202
David McClellan,E04242,41500,D101
Rich Holcomb,E01234,49500,D202
Nathan Adams,E41298,21900,D050
Richard Potter,E43128,15900,D101
David Motsinger,E27002,19250,D202
Tim Sampair,E03033,27000,D101
Kim Arlich,E10001,57000,D190
Timothy Grove,E16398,29900,D190


",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
public class Program
{
    class Employee
    {
        public Employee(string name, string id, int salary, string department)
        {
            Name = name;
            Id = id;
            Salary = salary;
            Department = department;
        }
 
        public string Name { get; private set; }
        public string Id { get; private set; }
        public int Salary { get; private set; }
        public string Department { get; private set; }
 
        public override string ToString()
        {
            return String.Format(""{0, -25}\t{1}\t{2}"", Name, Id, Salary);
        }
    }
 
    private static void Main(string[] args)
    {
        var employees = new List<Employee>
                        {
                            new Employee(""Tyler Bennett"", ""E10297"", 32000, ""D101""),
                            new Employee(""John Rappl"", ""E21437"", 47000, ""D050""),
                            new Employee(""George Woltman"", ""E21437"", 53500, ""D101""),
                            new Employee(""Adam Smith"", ""E21437"", 18000, ""D202""),
                            new Employee(""Claire Buckman"", ""E39876"", 27800, ""D202""),
                            new Employee(""David McClellan"", ""E04242"", 41500, ""D101""),
                            new Employee(""Rich Holcomb"", ""E01234"", 49500, ""D202""),
                            new Employee(""Nathan Adams"", ""E41298"", 21900, ""D050""),
                            new Employee(""Richard Potter"", ""E43128"", 15900, ""D101""),
                            new Employee(""David Motsinger"", ""E27002"", 19250, ""D202""),
                            new Employee(""Tim Sampair"", ""E03033"", 27000, ""D101""),
                            new Employee(""Kim Arlich"", ""E10001"", 57000, ""D190""),
                            new Employee(""Timothy Grove"", ""E16398"", 29900, ""D190"")
                        };
 
        DisplayTopNPerDepartment(employees, 2);
    }
 
    static void DisplayTopNPerDepartment(IEnumerable<Employee> employees, int n)
    {
        var topSalariesByDepartment =
            from employee in employees
            group employee by employee.Department
            into g
            select new
                    {
                        Department = g.Key,
                        TopEmployeesBySalary = g.OrderByDescending(e => e.Salary).Take(n)
                    };
 
        foreach (var x in topSalariesByDepartment)
        {
            Console.WriteLine(""Department: "" + x.Department);
            foreach (var employee in x.TopEmployeesBySalary)
                Console.WriteLine(employee);
            Console.WriteLine(""----------------------------"");
        }
    }
}",2710,70
6903,http://rosettacode.org/wiki/Tokenize_a_string,Tokenize a string,"Separate the string ""Hello,How,Are,You,Today"" by commas into an array (or list) so that each element of it stores a different word.

Display the words to the 'user', in the simplest manner possible, separated by a period.

To simplify, you may display a trailing period.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"string str = ""Hello,How,Are,You,Today""; 
// or Regex.Split ( ""Hello,How,Are,You,Today"", "","" );
// (Regex is in System.Text.RegularExpressions namespace)
string[] strings = str.Split(',');
Console.WriteLine(String.Join(""."", strings));
 ",235,6
6948,http://rosettacode.org/wiki/Time_a_function,Time a function,"Task

Write a program which uses a timer (with the least granularity available
on your system) to time how long a function takes to execute.

Whenever possible, use methods which measure only the processing time used
by the current process; instead of the difference in system time
between start and finish, which could include time used by
other processes on the computer.

This task is intended as a subtask for Measure relative performance of sorting algorithms implementations.



",#C.23,C#,"using System;
using System.Linq;
using System.Threading;
using System.Diagnostics;
 
class Program {
    static void Main(string[] args) {
        Stopwatch sw = new Stopwatch();
 
        sw.Start();
        DoSomething();
        sw.Stop();
 
        Console.WriteLine(""DoSomething() took {0}ms."", sw.Elapsed.TotalMilliseconds);
    }
 
    static void DoSomething() {
        Thread.Sleep(1000);
 
        Enumerable.Range(1, 10000).Where(x => x % 2 == 0).Sum();  // Sum even numers from 1 to 10000
    }
}",509,22
6993,http://rosettacode.org/wiki/Tic-tac-toe,Tic-tac-toe,"
Task

Play a game of tic-tac-toe.

Ensure that legal moves are played and that a winning position is notified.


Tic-tac-toe   is also known as:

   naughts and crosses 
   tic tac toe 
   tick tack toe 
   three in a row 
   tres en rayo       and
   Xs  and  Os


See also
   MathWorld™, Tic-Tac-Toe game.
   Wikipedia tic-tac-toe.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace RosettaTicTacToe
{
  class Program
  {
 
    /*================================================================
     *Pieces (players and board)
     *================================================================*/
    static string[][] Players = new string[][] { 
      new string[] { ""COMPUTER"", ""X"" }, // computer player
      new string[] { ""HUMAN"", ""O"" }     // human player
    };
 
    const int Unplayed = -1;
    const int Computer = 0;
    const int Human = 1;
 
    // GameBoard holds index into Players[] (0 or 1) or Unplayed (-1) if location not yet taken
    static int[] GameBoard = new int[9];
 
    static int[] corners = new int[] { 0, 2, 6, 8 };
 
    static int[][] wins = new int[][] { 
      new int[] { 0, 1, 2 }, new int[] { 3, 4, 5 }, new int[] { 6, 7, 8 }, 
      new int[] { 0, 3, 6 }, new int[] { 1, 4, 7 }, new int[] { 2, 5, 8 }, 
      new int[] { 0, 4, 8 }, new int[] { 2, 4, 6 } };
 
 
    /*================================================================
     *Main Game Loop (this is what runs/controls the game)
     *================================================================*/
    static void Main(string[] args)
    {
      while (true)
      {
        Console.Clear();
        Console.WriteLine(""Welcome to Rosetta Code Tic-Tac-Toe for C#."");
        initializeGameBoard();
        displayGameBoard();
        int currentPlayer = rnd.Next(0, 2);  // current player represented by Players[] index of 0 or 1
        Console.WriteLine(""The first move goes to {0} who is playing {1}s.\n"", playerName(currentPlayer), playerToken(currentPlayer));
        while (true)
        {
          int thisMove = getMoveFor(currentPlayer);
          if (thisMove == Unplayed)
          {
            Console.WriteLine(""{0}, you've quit the game ... am I that good?"", playerName(currentPlayer));
            break;
          }
          playMove(thisMove, currentPlayer);
          displayGameBoard();
          if (isGameWon())
          {
            Console.WriteLine(""{0} has won the game!"", playerName(currentPlayer));
            break;
          }
          else if (isGameTied())
          {
            Console.WriteLine(""Cat game ... we have a tie."");
            break;
          }
          currentPlayer = getNextPlayer(currentPlayer);
        }
        if (!playAgain())
          return;
      }
    }
 
    /*================================================================
     *Move Logic
     *================================================================*/
    static int getMoveFor(int player)
    {
      if (player == Human)
        return getManualMove(player);
      else
      {
        //int selectedMove = getManualMove(player);
        //int selectedMove = getRandomMove(player);
        int selectedMove = getSemiRandomMove(player);
        //int selectedMove = getBestMove(player);
        Console.WriteLine(""{0} selects position {1}."", playerName(player), selectedMove + 1);
        return selectedMove;
      }
    }
 
    static int getManualMove(int player)
    {
      while (true)
      {
        Console.Write(""{0}, enter you move (number): "", playerName(player));
        ConsoleKeyInfo keyInfo = Console.ReadKey();
        Console.WriteLine();  // keep the display pretty
        if (keyInfo.Key == ConsoleKey.Escape)
          return Unplayed;
        if (keyInfo.Key >= ConsoleKey.D1 && keyInfo.Key <= ConsoleKey.D9)
        {
          int move = keyInfo.KeyChar - '1';  // convert to between 0..8, a GameBoard index position.
          if (GameBoard[move] == Unplayed)
            return move;
          else
            Console.WriteLine(""Spot {0} is already taken, please select again."", move + 1);
        }
        else
          Console.WriteLine(""Illegal move, please select again.\n"");
      }
    }
 
    static int getRandomMove(int player)
    {
      int movesLeft = GameBoard.Count(position => position == Unplayed);
      int x = rnd.Next(0, movesLeft);
      for (int i = 0; i < GameBoard.Length; i++)  // walk board ...
      {
        if (GameBoard[i] == Unplayed && x < 0)    // until we reach the unplayed move.
          return i;
        x--;
      }
      return Unplayed;
    }
 
    // plays random if no winning move or needed block.
    static int getSemiRandomMove(int player)
    {
      int posToPlay;
      if (checkForWinningMove(player, out posToPlay))
        return posToPlay;
      if (checkForBlockingMove(player, out posToPlay))
        return posToPlay;
      return getRandomMove(player);
    }
 
    // purposely not implemented (this is the thinking part).
    static int getBestMove(int player)
    {
      return -1;
    }
 
    static bool checkForWinningMove(int player, out int posToPlay)
    {
      posToPlay = Unplayed;
      foreach (var line in wins)
        if (twoOfThreeMatchPlayer(player, line, out posToPlay))
          return true;
      return false;
    }
 
    static bool checkForBlockingMove(int player, out int posToPlay)
    {
      posToPlay = Unplayed;
      foreach (var line in wins)
        if (twoOfThreeMatchPlayer(getNextPlayer(player), line, out posToPlay))
          return true;
      return false;
    }
 
    static bool twoOfThreeMatchPlayer(int player, int[] line, out int posToPlay)
    {
      int cnt = 0;
      posToPlay = int.MinValue;
      foreach (int pos in line)
      {
        if (GameBoard[pos] == player)
          cnt++;
        else if (GameBoard[pos] == Unplayed)
          posToPlay = pos;
      }
      return cnt == 2 && posToPlay >= 0;
    }
 
    static void playMove(int boardPosition, int player)
    {
      GameBoard[boardPosition] = player;
    }
 
    static bool isGameWon()
    {
      return wins.Any(line => takenBySamePlayer(line[0], line[1], line[2]));
    }
 
    static bool takenBySamePlayer(int a, int b, int c)
    {
      return GameBoard[a] != Unplayed && GameBoard[a] == GameBoard[b] && GameBoard[a] == GameBoard[c];
    }
 
    static bool isGameTied()
    {
      return !GameBoard.Any(spot => spot == Unplayed);
    }
 
    /*================================================================
     *Misc Methods
     *================================================================*/
    static Random rnd = new Random();
 
    static void initializeGameBoard()
    {
      for (int i = 0; i < GameBoard.Length; i++)
        GameBoard[i] = Unplayed;
    }
 
    static string playerName(int player)
    {
      return Players[player][0];
    }
 
    static string playerToken(int player)
    {
      return Players[player][1];
    }
 
    static int getNextPlayer(int player)
    {
      return (player + 1) % 2;
    }
 
    static void displayGameBoard()
    {
      Console.WriteLine("" {0} | {1} | {2}"", pieceAt(0), pieceAt(1), pieceAt(2));
      Console.WriteLine(""---|---|---"");
      Console.WriteLine("" {0} | {1} | {2}"", pieceAt(3), pieceAt(4), pieceAt(5));
      Console.WriteLine(""---|---|---"");
      Console.WriteLine("" {0} | {1} | {2}"", pieceAt(6), pieceAt(7), pieceAt(8));
      Console.WriteLine();
    }
 
    static string pieceAt(int boardPosition)
    {
      if (GameBoard[boardPosition] == Unplayed)
        return (boardPosition + 1).ToString();  // display 1..9 on board rather than 0..8
      return playerToken(GameBoard[boardPosition]);
    }
 
    private static bool playAgain()
    {
      Console.WriteLine(""\nDo you want to play again?"");
      return Console.ReadKey(false).Key == ConsoleKey.Y;
    }
  }
 
}",7537,246
7068,http://rosettacode.org/wiki/Towers_of_Hanoi,Towers of Hanoi,"Task

Solve the   Towers of Hanoi   problem with recursion.



",#C.23,C#,"public  void move(int n, int from, int to, int via) {
   if (n == 1) {
     System.Console.WriteLine(""Move disk from pole "" + from + "" to pole "" + to);
   } else {
     move(n - 1, from, via, to);
     move(1, from, to, via);
     move(n - 1, via, to, from);
   }
 }",266,9
7789,http://rosettacode.org/wiki/The_sieve_of_Sundaram,The sieve of Sundaram,"The sieve of Eratosthenes: you've been there; done that; have the T-shirt. The sieve of Eratosthenes was ancient history when Euclid was a schoolboy. You are ready for something less than 3000 years old. You are ready for The sieve of Sundaram.

Starting with the ordered set of +ve integers, mark every third starting at 4 (4;7;10...).

Step through the set and if the value is not marked output 2*n+1. So from 1 to 4 output 3 5 7.

4 is marked so skip for 5 and 6 output 11 and 13.

7 is marked, so no output but now also mark every fifth starting at 12 (12;17;22...)

as per to 10 and now mark every seventh starting at 17 (17;24;31....)

as per for every further third element (13;16;19...) mark every (9th;11th;13th;...) element.

The output will be the ordered set of odd primes.

Using your function find and output the first 100 and the millionth Sundaram prime.

The faithless amongst you may compare the results with those generated by The sieve of Eratosthenes.

References

 The article on Wikipedia.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using static System.Console;
 
class Program
{
    static string fmt(int[] a)
    {
        var sb = new System.Text.StringBuilder();
        for (int i = 0; i < a.Length; i++)
            sb.Append(string.Format(""{0,5}{1}"",
              a[i], i % 10 == 9 ? ""\n"" : "" ""));
        return sb.ToString();
    }
 
    static void Main(string[] args)
    {
        var sw = System.Diagnostics.Stopwatch.StartNew();
        var pr = PG.Sundaram(15_500_000).Take(1_000_000).ToArray();
        sw.Stop();
        Write(""The first 100 odd prime numbers:\n{0}\n"",
          fmt(pr.Take(100).ToArray()));
        Write(""The millionth odd prime number: {0}"", pr.Last());
        Write(""\n{0} ms"", sw.Elapsed.TotalMilliseconds);
    }
}
 
class PG
{
    public static IEnumerable<int> Sundaram(int n)
    {
        // yield return 2;
        int i = 1, k = (n + 1) >> 1, t = 1, v = 1, d = 1, s = 1;
        var comps = new bool[k + 1];
        for (; t < k; t = ((++i + (s += d += 2)) << 1) - d - 2)
            while ((t += d + 2) < k)
                comps[t] = true;
        for (; v < k; v++)
            if (!comps[v])
                yield return (v << 1) + 1;
    }
}",1229,43
7844,http://rosettacode.org/wiki/The_Name_Game,The Name Game,"Write a program that accepts a name as input and outputs the lyrics to the Shirley Ellis song ""The Name Game"".



The regular verse

Unless your name begins with a vowel (A, E, I, O, U), 'B', 'F' or 'M' you don't have to care about special rules.
The verse for the name 'Gary' would be like this:

   Gary, Gary, bo-bary
   Banana-fana fo-fary
   Fee-fi-mo-mary
   Gary! 

At the end of every line, the name gets repeated without the first letter: Gary becomes ary
If we take (X) as the full name (Gary) and (Y) as the name without the first letter (ary) the verse would look like this:

   (X), (X), bo-b(Y)
   Banana-fana fo-f(Y)
   Fee-fi-mo-m(Y)
   (X)! 

Vowel as first letter of the name

If you have a vowel as the first letter of your name (e.g. Earl) you do not truncate the name.
The verse looks like this:

   Earl, Earl, bo-bearl
   Banana-fana fo-fearl
   Fee-fi-mo-mearl
   Earl! 

'B', 'F' or 'M' as first letter of the name

In case of a 'B', an 'F' or an 'M' (e.g. Billy, Felix, Mary) there is a special rule.
The line which would 'rebuild' the name (e.g. bo-billy) is sang without the first letter of the name.
The verse for the name Billy looks like this:

   Billy, Billy, bo-illy
   Banana-fana fo-filly
   Fee-fi-mo-milly
   Billy! 

For the name 'Felix', this would be right:

   Felix, Felix, bo-belix
   Banana-fana fo-elix
   Fee-fi-mo-melix
   Felix!


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Text;
 
namespace TheNameGame {
    class Program {
        static void PrintVerse(string name) {
            StringBuilder sb = new StringBuilder(name.ToLower());
            sb[0] = Char.ToUpper(sb[0]);
            string x = sb.ToString();
            string y = ""AEIOU"".IndexOf(x[0]) > -1 ? x.ToLower() : x.Substring(1);
            string b = ""b"" + y;
            string f = ""f"" + y;
            string m = ""m"" + y;
            switch (x[0]) {
                case 'B':
                    b = y;
                    break;
                case 'F':
                    f = y;
                    break;
                case 'M':
                    m = y;
                    break;
            }
            Console.WriteLine(""{0}, {0}, bo-{1}"", x, b);
            Console.WriteLine(""Banana-fana fo-{0}"", f);
            Console.WriteLine(""Fee-fi-mo-{0}"", m);
            Console.WriteLine(""{0}!"", x);
            Console.WriteLine();
        }
 
        static void Main(string[] args) {
            List<string> nameList = new List<string>() { ""Gary"", ""Earl"", ""Billy"", ""Felix"", ""Mary"", ""Steve"" };
            nameList.ForEach(PrintVerse);
        }
    }
}",1226,38
7854,http://rosettacode.org/wiki/Text_processing/2,Text processing/2,"The following task concerns data that came from a pollution monitoring station with twenty-four instruments monitoring twenty-four aspects of pollution in the air. Periodically a record is added to the file, each record being a line of 49 fields separated by white-space, which can be one or more space or tab characters.

The fields (from the left) are:

 DATESTAMP [ VALUEn FLAGn ] * 24

i.e. a datestamp followed by twenty-four repetitions of a floating-point instrument value and that instrument's associated integer flag. Flag values are >= 1 if the instrument is working and < 1 if there is some problem with it, in which case that instrument's value should be ignored.

A sample from the full data file readings.txt, which is also used in the Text processing/1 task, follows:

Data is no longer available at that link. Zipped mirror available here

1991-03-30	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1
1991-03-31	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	20.000	1	20.000	1	20.000	1	35.000	1	50.000	1	60.000	1	40.000	1	30.000	1	30.000	1	30.000	1	25.000	1	20.000	1	20.000	1	20.000	1	20.000	1	20.000	1	35.000	1
1991-03-31	40.000	1	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2
1991-04-01	0.000	-2	13.000	1	16.000	1	21.000	1	24.000	1	22.000	1	20.000	1	18.000	1	29.000	1	44.000	1	50.000	1	43.000	1	38.000	1	27.000	1	27.000	1	24.000	1	23.000	1	18.000	1	12.000	1	13.000	1	14.000	1	15.000	1	13.000	1	10.000	1
1991-04-02	8.000	1	9.000	1	11.000	1	12.000	1	12.000	1	12.000	1	27.000	1	26.000	1	27.000	1	33.000	1	32.000	1	31.000	1	29.000	1	31.000	1	25.000	1	25.000	1	24.000	1	21.000	1	17.000	1	14.000	1	15.000	1	12.000	1	12.000	1	10.000	1
1991-04-03	10.000	1	9.000	1	10.000	1	10.000	1	9.000	1	10.000	1	15.000	1	24.000	1	28.000	1	24.000	1	18.000	1	14.000	1	12.000	1	13.000	1	14.000	1	15.000	1	14.000	1	15.000	1	13.000	1	13.000	1	13.000	1	12.000	1	10.000	1	10.000	1

Task

 Confirm the general field format of the file.
 Identify any DATESTAMPs that are duplicated.
 Report the number of records that have good readings for all instruments.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.IO;
 
namespace TextProc2
{
    class Program
    {
        static void Main(string[] args)
        {
            Regex multiWhite = new Regex(@""\s+"");
            Regex dateEx = new Regex(@""^\d{4}-\d{2}-\d{2}$"");
            Regex valEx = new Regex(@""^\d+\.{1}\d{3}$"");
            Regex flagEx = new Regex(@""^[1-9]{1}$"");
 
            int missformcount = 0, totalcount = 0;
            Dictionary<int, string> dates = new Dictionary<int, string>();
 
            using (StreamReader sr = new StreamReader(""readings.txt""))
            {
                string line = sr.ReadLine();
                while (line != null)
                {
                    line = multiWhite.Replace(line, @"" "");                    
                    string[] splitLine = line.Split(' ');
                    if (splitLine.Length != 49)
                        missformcount++;
                    if (!dateEx.IsMatch(splitLine[0]))                        
                        missformcount++;                    
                    else
                        dates.Add(totalcount + 1, dateEx.Match(splitLine[0]).ToString());
                    int err = 0;                    
                    for (int i = 1; i < splitLine.Length; i++)
                    {
                        if (i%2 != 0)
                        {
                            if (!valEx.IsMatch(splitLine[i]))                          
                                err++;
                        }
                        else
                        {
                            if (!flagEx.IsMatch(splitLine[i]))
                                err++;                                                        
                        }                        
                    }
                    if (err != 0) missformcount++;
                    line = sr.ReadLine();
                    totalcount++;                    
                }
            }
 
            int goodEntries = totalcount - missformcount;
            Dictionary<string,List<int>> dateReverse = new Dictionary<string,List<int>>();
 
            foreach (KeyValuePair<int, string> kvp in dates)
            {
                if (!dateReverse.ContainsKey(kvp.Value))
                    dateReverse[kvp.Value] = new List<int>();
                dateReverse[kvp.Value].Add(kvp.Key);
            }
 
            Console.WriteLine(goodEntries + "" valid Records out of "" + totalcount);
 
            foreach (KeyValuePair<string, List<int>> kvp in dateReverse)
            {
                if (kvp.Value.Count > 1)
                    Console.WriteLine(""{0} is duplicated at Lines : {1}"", kvp.Key, string.Join("","", kvp.Value));                    
            }
        }
    }
}",2832,72
7888,http://rosettacode.org/wiki/Text_processing/Max_licenses_in_use,Text processing/Max licenses in use,"A company currently pays a fixed sum for the use of a particular licensed software package.   In determining if it has a good deal it decides to calculate its maximum use of the software from its license management log file.

Assume the software's licensing daemon faithfully records a checkout event when a copy of the software starts and a checkin event when the software finishes to its log file.

An example of checkout and checkin events are:

 License OUT @ 2008/10/03_23:51:05 for job 4974
 ...
 License IN  @ 2008/10/04_00:18:22 for job 4974



Task

Save the 10,000 line log file from    here   into a local file, then write a program to scan the file extracting both the maximum licenses that were out at any time, and the time(s) at which this occurs.

Mirror of log file available as a zip here (offsite mirror).



",#C.23,C#," 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
 
namespace TextProc3
{
    class Program
    {
        static void Main(string[] args)
        {            
            string line;
            int count = 0, maxcount = 0;
            List<string> times = new List<string>();
            System.IO.StreamReader file = new StreamReader(""mlijobs.txt"");
            while ((line = file.ReadLine()) != null)
            {
                string[] lineelements = line.Split(' ');                
                switch (lineelements[1])
                {
                    case ""IN"":
                        count--;
                        break;
                    case ""OUT"":
                        count++;
                        if (count > maxcount)
                        {
                            maxcount = count;
                            times.Clear();
                            times.Add(lineelements[3]);
                        }else if(count == maxcount){
                            times.Add(lineelements[3]);
                        }
                        break;
                }                
            }
            file.Close();
            Console.WriteLine(maxcount);
            foreach (string time in times)
            {
                Console.WriteLine(time);
            }
        }
    }
}
 ",1397,48
8039,http://rosettacode.org/wiki/Terminal_control/Ringing_the_terminal_bell,Terminal control/Ringing the terminal bell,"

Task

Make the terminal running the program ring its ""bell"".



On modern terminal emulators, this may be done by playing some other sound which might or might not be configurable, or by flashing the title bar or inverting the colors of the screen, but was classically a physical bell within the terminal.   It is usually used to indicate a problem where a wrong character has been typed.

In most terminals, if the   Bell character   (ASCII code 7,    \a  in C)   is printed by the program, it will cause the terminal to ring its bell.   This is a function of the terminal, and is independent of the programming language of the program, other than the ability to print a particular character to standard out.



",#C.23,C#,"// the simple version:
System.Console.Write(""\a""); // will beep
System.Threading.Thread.Sleep(1000); // will wait for 1 second
System.Console.Beep(); // will beep a second time
System.Threading.Thread.Sleep(1000);
 
// System.Console.Beep() also accepts (int)hertz and (int)duration in milliseconds:
System.Console.Beep(440, 2000); // default ""concert pitch"" for 2 seconds
 ",374,9
8046,http://rosettacode.org/wiki/Test_a_function,Test a function,"

Task

Using a well-known testing-specific library/module/suite for your language, write some tests for your language's entry in Palindrome.

If your language does not have a testing specific library well known to the language's community then state this or omit the language.


",#C.23,C#," 
using Microsoft.VisualStudio.TestTools.UnitTesting;
using PalindromeDetector.ConsoleApp;
 
namespace PalindromeDetector.VisualStudioTests
{
    [TestClass]
    public class VSTests
    {
        [TestMethod]
        public void PalindromeDetectorCanUnderstandPalindrome()
        {
            //Microsoft.VisualStudio.QualityTools.UnitTestFramework v4.0.30319
            bool expected = true;
            bool actual;
            actual = Program.IsPalindrome(""1"");
            Assert.AreEqual(expected, actual);
            actual = Program.IsPalindromeNonRecursive(""1"");
            Assert.AreEqual(expected, actual);
            actual = Program.IsPalindrome(""ingirumimusnocteetconsumimurigni"");
            Assert.AreEqual(expected, actual);
            actual = Program.IsPalindromeNonRecursive(""ingirumimusnocteetconsumimurigni"");
            Assert.AreEqual(expected, actual);
        }
        [TestMethod]
        public void PalindromeDetecotryCanUnderstandNonPalindrome()
        {
            bool notExpected = true;
            bool actual = Program.IsPalindrome(""ThisIsNotAPalindrome"");
            Assert.AreNotEqual(notExpected, actual);
            actual = Program.IsPalindromeNonRecursive(""ThisIsNotAPalindrome"");
            Assert.AreNotEqual(notExpected, actual);
        }
    }
}",1308,35
8054,http://rosettacode.org/wiki/The_ISAAC_Cipher,The ISAAC Cipher,"ISAAC is a cryptographically secure pseudo-random number generator (CSPRNG) and stream cipher. It was developed by Bob Jenkins from 1993 (http://burtleburtle.net/bob/rand/isaac.html) and placed in the Public Domain. ISAAC is fast - especially when optimised - and portable to most architectures in nearly all programming and scripting languages.
It is also simple and succinct, using as it does just two 256-word arrays for its state.

ISAAC stands for ""Indirection, Shift, Accumulate, Add, and Count"" which are the principal bitwise operations employed.
To date - and that's after more than 20 years of existence - ISAAC has not been broken (unless GCHQ or NSA did it, but they wouldn't be telling).
ISAAC thus deserves a lot more attention than it has hitherto received and it would be salutary to see it more universally implemented.



Task

Translate ISAAC's reference C or Pascal code into your language of choice.

The RNG should then be seeded with the string ""this is my secret key"" and
finally the message ""a Top Secret secret"" should be encrypted on that key.
Your program's output cipher-text will be a string of hexadecimal digits.

Optional: Include a decryption check by re-initializing ISAAC and performing
the same encryption pass on the cipher-text.

Please use the C or Pascal as a reference guide to these operations.

Two encryption schemes are possible:
(1) XOR (Vernam) or
(2) Caesar-shift mod 95 (Vigenère).
XOR is the simplest; C-shifting offers greater security.

You may choose either scheme, or both, but please specify which you used.
Here are the alternative sample outputs for checking purposes:

Message: a Top Secret secret
Key    : this is my secret key
XOR    : 1C0636190B1260233B35125F1E1D0E2F4C5422
MOD    : 734270227D36772A783B4F2A5F206266236978
XOR dcr: a Top Secret secret
MOD dcr: a Top Secret secret

No official seeding method for ISAAC has been published, but for this task
we may as well just inject the bytes of our key into the randrsl array,
padding with zeroes before mixing, like so:

// zeroise mm array
FOR i:= 0 TO 255 DO mm[i]:=0;
// check seed's highest array element
m := High(seed);
// inject the seed
FOR i:= 0 TO 255 DO BEGIN
	// in case seed[] has less than 256 elements.
	IF i>m THEN randrsl[i]:=0  
		ELSE randrsl[i]:=seed[i];
END;
// initialize ISAAC with seed
RandInit(true);

ISAAC can of course also be initialized with a single 32-bit unsigned integer in the manner of traditional RNGs, and indeed used as such for research and gaming purposes.
But building a strong and simple ISAAC-based stream cipher - replacing the irreparably broken RC4 - is our goal here: ISAAC's intended purpose.



",#C.23,C#," 
using System;
 
namespace cipher {
 
static class Cipher {
 
// external results 
static uint[] randrsl = new uint[256];
static uint randcnt;
// internal state 
static uint[] mm = new uint[256];
static uint aa=0, bb=0, cc=0;
 
 
static void isaac() {
   uint i,x,y;
   cc++;    // cc just gets incremented once per 256 results 
   bb+=cc;   // then combined with bb 
 
   for (i=0; i<=255; i++) {
     x = mm[i];
     switch (i & 3) {
      case 0: aa = aa ^ (aa << 13); break;
      case 1: aa = aa ^ (aa >> 6); break;
      case 2: aa = aa ^ (aa << 2); break;
      case 3: aa = aa ^ (aa >> 16); break;
     }
     aa = mm[(i+128) & 255] + aa;
     y  = mm[(x >> 2) & 255] + aa + bb;
     mm[i] = y; 	
     bb = mm[(y >> 10) & 255] + x; 
     randrsl[i]= bb; 
   }
}
 
 
// if (flag==TRUE), then use the contents of randrsl[] to initialize mm[]. 
static void mix(ref uint a, ref uint b, ref uint c, ref uint d, ref uint e, ref uint f, ref uint g, ref uint h) {
   a = a ^ b << 11; d+=a; b+=c; 
   b = b ^ c >> 2;  e+=b; c+=d; 
   c = c ^ d << 8;  f+=c; d+=e;
   d = d ^ e >> 16; g+=d; e+=f;
   e = e ^ f << 10; h+=e; f+=g;
   f = f ^ g >> 4;  a+=f; g+=h;
   g = g ^ h << 8;  b+=g; h+=a;
   h = h ^ a >> 9;  c+=h; a+=b;
}
 
 
static void Init(bool flag) {
  short i; uint a,b,c,d,e,f,g,h;
 
   aa=0; bb=0; cc=0;
   a=0x9e3779b9; b=a; c=a; d=a; 
   e=a; f=a; g=a; h=a; 
 
   for (i=0; i<=3; i++)           // scramble it 
        mix(ref a,ref b,ref c,ref d,ref e,ref f,ref g,ref h);
 
   i=0;
   do  { // fill in mm[] with messy stuff  
          if (flag) {     // use all the information in the seed 
            a+=randrsl[i  ]; b+=randrsl[i+1]; c+=randrsl[i+2]; d+=randrsl[i+3];
            e+=randrsl[i+4]; f+=randrsl[i+5]; g+=randrsl[i+6]; h+=randrsl[i+7];
          } // if flag
 
      mix(ref a,ref b,ref c,ref d,ref e,ref f,ref g,ref h);
      mm[i  ]=a; mm[i+1]=b; mm[i+2]=c; mm[i+3]=d;
      mm[i+4]=e; mm[i+5]=f; mm[i+6]=g; mm[i+7]=h;
      i+=8;
      }
   while (i<255);
 
   if (flag) {
   // do a second pass to make all of the seed affect all of mm 
     i=0;
     do {
      a+=mm[i  ]; b+=mm[i+1]; c+=mm[i+2]; d+=mm[i+3];
      e+=mm[i+4]; f+=mm[i+5]; g+=mm[i+6]; h+=mm[i+7];
      mix(ref a,ref b,ref c,ref d,ref e,ref f,ref g,ref h);
      mm[i  ]=a; mm[i+1]=b; mm[i+2]=c; mm[i+3]=d;
      mm[i+4]=e; mm[i+5]=f; mm[i+6]=g; mm[i+7]=h;
      i+=8;
        }
     while (i<255);
   }
   isaac();           // fill in the first set of results 
   randcnt=0;       // prepare to use the first set of results 
}
 
 
// Seed ISAAC with a string
static void Seed(string seed, bool flag) {
	for (int i=0; i<256; i++) mm[i]=0;
	for (int i=0; i<256; i++) randrsl[i]=0;
	int m = seed.Length;
	for (int i=0; i<m; i++) {
        randrsl[i] = seed[i];
	}
	// initialize ISAAC with seed
	Init(flag);
}
 
 
// Get a random 32-bit value 
static uint Random() {
    uint result = randrsl[randcnt];
    randcnt++;
    if (randcnt>255) {
         isaac(); randcnt=0;
    }
    return result;
}
 
 
// Get a random character in printable ASCII range
static byte RandA() {	
	return (byte)(Random() % 95 + 32);
}
 
 
// XOR encrypt on random stream. Output: ASCII byte array
static byte[] Vernam(string msg)
	{
		int n,l;
		byte[] v = new byte[msg.Length];
		l = msg.Length;
		// XOR message
		for (n=0; n<l; n++) {
			v[n] = (byte) (RandA() ^ (byte)msg[n]);
		}	
		return v;
	}
 
 
	public static void Main() {
		string msg = ""a Top Secret secret"";
		string key = ""this is my secret key"";
		byte[] xctx= new byte[msg.Length];
		byte[] xptx= new byte[msg.Length];
		string xtcx= ""*******************"";
		string xtpx= ""*******************"";
		Seed(key,true);
		// XOR encrypt
		xctx = Vernam(msg);
		xtcx = System.Text.Encoding.ASCII.GetString(xctx);
		// XOR decrypt
		Seed(key,true);
		xptx = Vernam(xtcx);
		xtpx = System.Text.Encoding.ASCII.GetString(xptx);
		Console.WriteLine(""Message: ""+msg);
		Console.WriteLine(""Key    : ""+key);
		Console.Write    (""XOR    : "");
		// output ciphertext as a string of hexadecimal digits
		for (int n=0; n<xctx.Length; n++) Console.Write(""{0:X2}"", xctx[n]);
		Console.WriteLine(""\nXOR dcr: ""+xtpx);
	}
}
}
 ",4148,161
8055,http://rosettacode.org/wiki/Test_integerness,Test integerness,"Mathematically,

 the integers Z are included in the rational numbers Q,
 which are included in the real numbers R,
 which can be generalized to the complex numbers C.


This means that each of those larger sets, and the data types used to represent them, include some integers.

Task[edit]
Given a rational, real, or complex number of any type, test whether it is mathematically an integer.

Your code should handle all numeric data types commonly used in your programming language.

Discuss any limitations of your code.

Definition
For the purposes of this task, integerness means that a number could theoretically be represented as an integer at no loss of precision (given an infinitely wide integer type).

In other words:



 Set

 Common representation

 C++ type

 Considered an integer...


 rational numbers Q

 fraction

 std::ratio

 ...if its denominator is 1 (in reduced form)


 real numbers Z
(approximated)

 fixed-point



 ...if it has no non-zero digits after the decimal point


 floating-point

 float, double

 ...if the number of significant decimal places of its mantissa isn't greater than its exponent


 complex numbers C

 pair of real numbers

 std::complex

 ...if its real part is considered an integer and its imaginary part is zero

Extra credit
Optionally, make your code accept a tolerance parameter for fuzzy testing. The tolerance is the maximum amount by which the number may differ from the nearest integer, to still be considered an integer.

This is useful in practice, because when dealing with approximate numeric types (such as floating point), there may already be round-off errors from previous calculations. For example, a float value of 0.9999999998 might actually be intended to represent the integer 1.

Test cases


 Input

 Output

 Comment


 Type

 Value

 exact

 tolerance = 0.00001


 decimal

 25.000000

 true




 24.999999

 false

 true




 25.000100

 false




 floating-point

 -2.1e120

 true

 This one is tricky, because in most languages it is too large to fit into a native integer type.
It is, nonetheless, mathematically an integer, and your code should identify it as such.


 -5e-2

 false




 NaN

 false




 Inf

 false

 This one is debatable. If your code considers it an integer, that's okay too.


 complex

 5.0+0.0i

 true




 5-5i

 false



(The types and notations shown in these tables are merely examples – you should use the native data types and number literals of your programming language and standard library. Use a different set of test-cases, if this one doesn't demonstrate all relevant behavior.)

",#C.23,C#," 
namespace Test_integerness
{
	class Program
	{
		public static void Main(string[] args)
		{
			Console.Clear();
			Console.WriteLine();
			Console.WriteLine("" ***************************************************"");
			Console.WriteLine("" *                                                 *"");
			Console.WriteLine("" *              Integerness test                   *"");
			Console.WriteLine("" *                                                 *"");
			Console.WriteLine("" ***************************************************"");
			Console.WriteLine();
 
			ConsoleKeyInfo key = new ConsoleKeyInfo('Y',ConsoleKey.Y,true,true,true);
 
			while(key.Key == ConsoleKey.Y)
			{
				// Get number value from keyboard
				Console.Write("" Enter number value : "");
 
				string LINE = Console.ReadLine();
 
				// Get tolerance value from keyboard
				Console.Write("" Enter tolerance value : "");
 
				double TOLERANCE = double.Parse(Console.ReadLine());
 
 
				// Resolve entered number format and set NUMBER value
				double NUMBER = 0;
 
				string [] N;
 
				// Real number value
				if(!double.TryParse(LINE, out NUMBER))
				{
					// Rational number value
					if(LINE.Contains(""/""))
					{
						N = LINE.Split('/');
 
						NUMBER = double.Parse(N[0]) / double.Parse(N[1]);
					}
					// Inf value
					else if(LINE.ToUpper().Contains(""INF""))
					{
						NUMBER = double.PositiveInfinity;
					}
					// Complex value
					else if(LINE.ToUpper().Contains(""I""))
					{
						// Delete letter i
						LINE = LINE.ToUpper().Replace(""I"","""");
 
						string r = string.Empty; // real part
						string i = string.Empty; // imaginary part
 
						int s = 1; // sign offset
 
						// Get sign
						if(LINE[0]=='+' || LINE[0]=='-')
						{
							r+=LINE[0].ToString();
							LINE = LINE.Remove(0,1);
							s--;
						}
						// Get real part
						foreach (char element in LINE) 
						{
							if(element!='+' && element!='-')
								r+=element.ToString();
							else
								break;
						}
						// get imaginary part
						i = LINE.Substring(LINE.Length-(r.Length+s));
 
						NUMBER = double.Parse(i);
						if(NUMBER==0)
							NUMBER = double.Parse(r);
						else
							NUMBER = double.NaN;
 
					}
					// NaN value
					else
						NUMBER = double.NaN;
				}
 
 
				// Test
				bool IS_INTEGER = false;
				bool IS_INTEGER_T = false;
 
				if(double.IsNaN(NUMBER))
					IS_INTEGER=false;
 
				else if(Math.Round(NUMBER,0).ToString() == NUMBER.ToString())
					IS_INTEGER = true;
 
				else if((decimal)TOLERANCE >= (decimal)Math.Abs( (decimal)Math.Round(NUMBER,0) - (decimal)NUMBER ))
					IS_INTEGER_T = true;
 
 
 
				if(IS_INTEGER)
					Console.WriteLine("" Is exact integer "" + IS_INTEGER);
 
				else
				{
					Console.WriteLine( "" Is exact integer "" + IS_INTEGER );
					Console.WriteLine( "" Is integer with tolerance "" + IS_INTEGER_T );
				}
 
 
				Console.WriteLine();
				Console.Write("" Another test < Y /N > . . . "");
				key  = Console.ReadKey(true);
				Console.WriteLine();
				Console.WriteLine();
			}
 
		}
 
	}
}
 
 ",3050,131
8226,http://rosettacode.org/wiki/Terminal_control/Hiding_the_cursor,Terminal control/Hiding the cursor,"The task is to hide the cursor and show it again.



",#C.23,C#,"static void Main(string[] args)
{
    Console.Write(""At the end of this line you will see the cursor, process will sleep for 5 seconds."");
    System.Threading.Thread.Sleep(5000);
    Console.CursorVisible = false;
    Console.WriteLine();
    Console.Write(""At the end of this line you will not see the cursor, process will sleep for 5 seconds."");
    System.Threading.Thread.Sleep(5000);
}",391,9
8307,http://rosettacode.org/wiki/Terminal_control/Display_an_extended_character,Terminal control/Display an extended character,"Task

Display an extended (non ASCII) character onto the terminal.

Specifically, display a    £    (GBP currency sign).



",#C.23,C#,"class Program
{
    static void Main()
    {
        System.Console.WriteLine(""£"");
    }
}",91,7
8376,http://rosettacode.org/wiki/Terminal_control/Dimensions,Terminal control/Dimensions,"Determine the height and width of the terminal, and store this information into variables for subsequent use.
",#C.23,C#," 
static void Main(string[] args)
{
    int bufferHeight = Console.BufferHeight;
    int bufferWidth = Console.BufferWidth;
    int windowHeight = Console.WindowHeight;
    int windowWidth = Console.WindowWidth;
 
    Console.Write(""Buffer Height: "");
    Console.WriteLine(bufferHeight);
    Console.Write(""Buffer Width: "");
    Console.WriteLine(bufferWidth);
    Console.Write(""Window Height: "");
    Console.WriteLine(windowHeight);
    Console.Write(""Window Width: "");
    Console.WriteLine(windowWidth);
    Console.ReadLine();
}
 ",537,19
8416,http://rosettacode.org/wiki/Terminal_control/Cursor_positioning,Terminal control/Cursor positioning,"

Task

Move the cursor to column   3,   row   6,   and display the word   ""Hello""   (without the quotes),   so that the letter   H   is in column   3   on row   6.



",#C.23,C#,"static void Main(string[] args)
{
    Console.SetCursorPosition(3, 6);
    Console.Write(""Hello"");
}",100,5
8460,http://rosettacode.org/wiki/Ternary_logic,Ternary logic,"

 This page uses content from Wikipedia. The original article was at Ternary logic. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In logic, a three-valued logic (also trivalent, ternary, or trinary logic, sometimes abbreviated 3VL) is any of several many-valued logic systems in which there are three truth values indicating true, false and some indeterminate third value.

This is contrasted with the more commonly known bivalent logics (such as classical sentential or boolean logic) which provide only for true and false.

Conceptual form and basic ideas were initially created by Łukasiewicz, Lewis and Sulski.

These were then re-formulated by Grigore Moisil in an axiomatic algebraic form, and also extended to n-valued logics in 1945.


Example Ternary Logic Operators in Truth Tables:




not a


 ¬


 True 
 False


 Maybe 
 Maybe


 False 
 True




a and b


 ∧

 True 
 Maybe 
 False


 True 
 True 
 Maybe 
 False


 Maybe 
 Maybe 
 Maybe 
 False


 False 
 False 
 False 
 False




a or b


 ∨

 True 
 Maybe 
 False


 True 
 True 
 True 
 True


 Maybe 
 True 
 Maybe 
 Maybe


 False 
 True 
 Maybe 
 False





if a then b


 ⊃

 True 
 Maybe 
 False


 True 
 True 
 Maybe 
 False


 Maybe 
 True 
 Maybe 
 Maybe


 False 
 True 
 True 
 True




a is equivalent to b


 ≡

 True 
 Maybe 
 False


 True 
 True 
 Maybe 
 False


 Maybe 
 Maybe 
 Maybe 
 Maybe


 False 
 False 
 Maybe 
 True




Task

 Define a new type that emulates ternary logic by storing data trits.
 Given all the binary logic operators of the original programming language, reimplement these operators for the new Ternary logic type trit.
 Generate a sampling of results using trit variables.
 Kudos for actually thinking up a test case algorithm where ternary logic is intrinsically useful, optimises the test case algorithm and is preferable to binary logic.


Note:   Setun   (Сетунь) was a   balanced ternary   computer developed in 1958 at   Moscow State University.   The device was built under the lead of   Sergei Sobolev   and   Nikolay Brusentsov.   It was the only modern   ternary computer,   using three-valued ternary logic
",#C.23,C#,"using System;
 
/// <summary>
/// Extension methods on nullable bool.
/// </summary>
/// <remarks>
/// The operators !, & and | are predefined.
/// </remarks>
public static class NullableBoolExtension
{
    public static bool? Implies(this bool? left, bool? right)
    {
        return !left | right;
    }
 
    public static bool? IsEquivalentTo(this bool? left, bool? right)
    {
        return left.HasValue && right.HasValue ? left == right : default(bool?);
    }
 
    public static string Format(this bool? value)
    {
        return value.HasValue ? value.Value.ToString() : ""Maybe"";
    }
}
 
public class Program
{
    private static void Main()
    {
        var values = new[] { true, default(bool?), false };
 
        foreach (var left in values)
        {
            Console.WriteLine(""¬{0} = {1}"", left.Format(), (!left).Format());
            foreach (var right in values)
            {
                Console.WriteLine(""{0} & {1} = {2}"", left.Format(), right.Format(), (left & right).Format());
                Console.WriteLine(""{0} | {1} = {2}"", left.Format(), right.Format(), (left | right).Format());
                Console.WriteLine(""{0} → {1} = {2}"", left.Format(), right.Format(), left.Implies(right).Format());
                Console.WriteLine(""{0} ≡ {1} = {2}"", left.Format(), right.Format(), left.IsEquivalentTo(right).Format());
            }
        }
    }
}",1396,45
8478,http://rosettacode.org/wiki/The_Twelve_Days_of_Christmas,The Twelve Days of Christmas,"Task

Write a program that outputs the lyrics of the Christmas carol The Twelve Days of Christmas.
The lyrics can be found here.

(You must reproduce the words in the correct order, but case, format, and punctuation are left to your discretion.)




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
 
public class TwelveDaysOfChristmas {
 
    public static void Main() {
 
        string[] days = new string[12] {
            ""first"", ""second"", ""third"", ""fourth"", ""fifth"", ""sixth"", ""seventh"", ""eighth"", ""ninth"",
            ""tenth"", ""eleventh"", ""twelfth"",
        };
 
        string[] gifts = new string[12] {
            ""A partridge in a pear tree"",
            ""Two turtle doves"",
            ""Three french hens"",
            ""Four calling birds"",
            ""Five golden rings"",
            ""Six geese a-laying"",
            ""Seven swans a-swimming"",
            ""Eight maids a-milking"",
            ""Nine ladies dancing"",
            ""Ten lords a-leaping"",
            ""Eleven pipers piping"",
            ""Twelve drummers drumming""
        };
 
        for ( int i = 0; i < 12; i++ ) {
 
            Console.WriteLine(""On the "" + days[i] + "" day of Christmas, my true love gave to me"");
 
            int j = i + 1;
            while ( j-- > 0 )
                Console.WriteLine(gifts[j]);
 
            Console.WriteLine();
 
            if ( i == 0 )
                gifts[0] = ""And a partridge in a pear tree"";
        }
 
    }
 
}",1159,43
8600,http://rosettacode.org/wiki/Terminal_control/Cursor_movement,Terminal control/Cursor movement,"Task

Demonstrate how to achieve movement of the terminal cursor:

 how to move the cursor one position to the left
 how to move the cursor one position to the right
 how to move the cursor up one line (without affecting its horizontal position)
 how to move the cursor down one line (without affecting its horizontal position)
 how to move the cursor to the beginning of the line
 how to move the cursor to the end of the line
 how to move the cursor to the top left corner of the screen
 how to move the cursor to the bottom right corner of the screen


For the purpose of this task, it is not permitted to overwrite any characters or attributes on any part of the screen (so outputting a space is not a suitable solution to achieve a movement to the right).



Handling of out of bounds locomotion
This task has no specific requirements to trap or correct cursor movement beyond the terminal boundaries, so the implementer should decide what behavior fits best in terms of the chosen language.   Explanatory notes may be added to clarify how an out of bounds action would behave and the generation of error messages relating to an out of bounds cursor position is permitted.



",#C.23,C#,"static void Main(string[] args)
{
    //There will be a 3 second pause between each cursor movement.
    Console.Write(""\n\n\n\n     Cursor is here -->   "");
    System.Threading.Thread.Sleep(3000);
    Console.CursorLeft = Console.CursorLeft - 1; //Console.CursorLeft += -1 is an alternative.
    System.Threading.Thread.Sleep(3000);
    Console.CursorLeft = Console.CursorLeft + 1;
    System.Threading.Thread.Sleep(3000);
    Console.CursorTop = Console.CursorTop - 1;
    System.Threading.Thread.Sleep(3000);
    Console.CursorTop = Console.CursorTop + 1;
    System.Threading.Thread.Sleep(3000);
    Console.CursorLeft = 0; //Move the cursor far left.
    System.Threading.Thread.Sleep(3000);
    Console.CursorLeft = Console.BufferWidth - 1;
    /* BufferWidth represents the number of characters wide the console area is.
        * The exact value may vary on different systems.
        * As the cursor position is a 0 based index we must subtract 1 from buffer width or we move the cursor out of bounds.
        * In some cases WindowWidth may be preferable (however in this demonstration window and buffer should be the same).
        */ 
    System.Threading.Thread.Sleep(3000);
    Console.SetCursorPosition(0,0); //I have used an alternative method for moving the cursor here which I feel is cleaner for the task at hand.
    System.Threading.Thread.Sleep(3000);
    Console.SetCursorPosition(Console.BufferWidth-1, Console.WindowHeight-1); //Buffer height is usually longer than the window so window has been used instead.
    System.Threading.Thread.Sleep(3000);
}
 ",1580,28
8624,http://rosettacode.org/wiki/Terminal_control/Coloured_text,Terminal control/Coloured text,"Task

Display a word in various colours on the terminal.

The system palette, or colours such as Red, Green, Blue, Magenta, Cyan, and Yellow can be used.



Optionally demonstrate:

 How the system should determine if the terminal supports colour
 Setting of the background colour
 How to cause blinking or flashing (if supported by the terminal)

",#C.23,C#," 
static void Main(string[] args)
{
    Console.ForegroundColor = ConsoleColor.Red;
    Console.BackgroundColor = ConsoleColor.Yellow;
    Console.WriteLine(""Red on Yellow"");
    Console.ForegroundColor = ConsoleColor.White;
    Console.BackgroundColor = ConsoleColor.Black;
    Console.WriteLine(""White on black"");
    Console.ResetColor();
    Console.WriteLine(""Back to normal"");
    Console.ReadKey();
}
 ",409,14
8758,http://rosettacode.org/wiki/Tarjan,Tarjan,"

 This page uses content from Wikipedia. The original article was at Graph. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Tarjan's algorithm is an algorithm in graph theory for finding the strongly connected components of a graph.

It runs in linear time, matching the time bound for alternative methods including Kosaraju's algorithm and the path-based strong component algorithm.

Tarjan's Algorithm is named for its discoverer, Robert Tarjan.



References

 The article on Wikipedia.

",#C.23,C#,"using System;
using System.Collections.Generic;
 
class Node
{
    public int LowLink { get; set; }
    public int Index { get; set; }
    public int N { get; }
 
    public Node(int n)
    {
        N = n;
        Index = -1;
        LowLink = 0;
    }
}
 
class Graph
{
    public HashSet<Node> V { get; }
    public Dictionary<Node, HashSet<Node>> Adj { get; }
 
    /// <summary>
    /// Tarjan's strongly connected components algorithm
    /// </summary>
    public void Tarjan()
    {
        var index = 0; // number of nodes
        var S = new Stack<Node>();
 
        Action<Node> StrongConnect = null;
        StrongConnect = (v) =>
        {
            // Set the depth index for v to the smallest unused index
            v.Index = index;
            v.LowLink = index;
 
            index++;
            S.Push(v);
 
            // Consider successors of v
            foreach (var w in Adj[v])
                if (w.Index < 0)
                {
                    // Successor w has not yet been visited; recurse on it
                    StrongConnect(w);
                    v.LowLink = Math.Min(v.LowLink, w.LowLink);
                }
                else if (S.Contains(w))
                    // Successor w is in stack S and hence in the current SCC
                    v.LowLink = Math.Min(v.LowLink, w.Index);
 
            // If v is a root node, pop the stack and generate an SCC
            if (v.LowLink == v.Index)
            {
                Console.Write(""SCC: "");
 
                Node w;
                do
                {
                    w = S.Pop();
                    Console.Write(w.N + "" "");
                } while (w != v);
 
                Console.WriteLine();
            }
        };
 
        foreach (var v in V)
            if (v.Index < 0)
                StrongConnect(v);
    }
}",1841,73
8779,http://rosettacode.org/wiki/Taxicab_numbers,Taxicab numbers,"
A   taxicab number   (the definition that is being used here)   is a positive integer that can be expressed as the sum of two positive cubes in more than one way.



The first taxicab number is   1729,   which is:

 13   +   123       and also
 93   +   103.


Taxicab numbers are also known as:

   taxi numbers
   taxi-cab numbers
   taxi cab numbers
   Hardy-Ramanujan numbers


Task

 Compute and display the lowest 25 taxicab numbers (in numeric order, and in a human-readable format).
 For each of the taxicab numbers, show the number as well as it's constituent cubes.


Extra credit
 Show the 2,000th taxicab number, and a half dozen more


See also

 A001235: taxicab numbers on The On-Line Encyclopedia of Integer Sequences.
 Hardy-Ramanujan Number on MathWorld.
 taxicab number on MathWorld.
 taxicab number on Wikipedia   (includes the story on how taxi-cab numbers came to be called).

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace TaxicabNumber
{
    class Program
    {
        static void Main(string[] args)
        {
            IDictionary<long, IList<Tuple<int, int>>> taxicabNumbers = GetTaxicabNumbers(2006);
            PrintTaxicabNumbers(taxicabNumbers);
            Console.ReadKey();
        }
 
        private static IDictionary<long, IList<Tuple<int, int>>> GetTaxicabNumbers(int length)
        {
            SortedList<long, IList<Tuple<int, int>>> sumsOfTwoCubes = new SortedList<long, IList<Tuple<int, int>>>();
 
            for (int i = 1; i < int.MaxValue; i++)
            {
                for (int j = 1; j < int.MaxValue; j++)
                {
                    long sum = (long)(Math.Pow((double)i, 3) + Math.Pow((double)j, 3));
 
                    if (!sumsOfTwoCubes.ContainsKey(sum))
                    {
                        sumsOfTwoCubes.Add(sum, new List<Tuple<int, int>>());
                    }
 
                    sumsOfTwoCubes[sum].Add(new Tuple<int, int>(i, j));
 
                    if (j >= i)
                    {
                        break;
                    }
                }
 
                // Found that you need to keep going for a while after the length, because higher i values fill in gaps
                if (sumsOfTwoCubes.Count(t => t.Value.Count >= 2) >= length * 1.1)
                {
                    break;
                }
            }
 
            IDictionary<long, IList<Tuple<int, int>>> values = (from t in sumsOfTwoCubes where t.Value.Count >= 2 select t)
                .Take(2006)
                .ToDictionary(u => u.Key, u => u.Value);
 
            return values;
        }
 
        private static void PrintTaxicabNumbers(IDictionary<long, IList<Tuple<int, int>>> values)
        {
            int i = 1;
 
            foreach (long taxicabNumber in values.Keys)
            {
                StringBuilder output = new StringBuilder().AppendFormat(""{0,10}\t{1,4}"", i, taxicabNumber);
 
                foreach (Tuple<int, int> numbers in values[taxicabNumber])
                {
                    output.AppendFormat(""\t= {0}^3 + {1}^3"", numbers.Item1, numbers.Item2);
                }
 
                if (i <= 25 || (i >= 2000 && i <= 2006))
                {
                    Console.WriteLine(output.ToString());
                }
 
                i++;
            }
        }
    }
}",2467,76
8790,http://rosettacode.org/wiki/Terminal_control/Clear_the_screen,Terminal control/Clear the screen,"Task

Clear the terminal window.



",#C.23,C#,System.Console.Clear();,23,1
8955,http://rosettacode.org/wiki/Synchronous_concurrency,Synchronous concurrency,"The goal of this task is to create two concurrent activities (""Threads"" or ""Tasks"", not processes.) that share data synchronously. Your language may provide syntax or libraries to perform concurrency. Different languages provide different implementations of concurrency, often with different names. Some languages use the term threads, others use the term tasks, while others use co-processes. This task should not be implemented using fork, spawn, or the Linux/UNIX/Win32 pipe command, as communication should be between threads, not processes.

One of the concurrent units will read from a file named ""input.txt"" and send the contents of that file, one line at a time, to the other concurrent unit, which will print the line it receives to standard output. The printing unit must count the number of lines it prints. After the concurrent unit reading the file sends its last line to the printing unit, the reading unit will request the number of lines printed by the printing unit. The reading unit will then print the number of lines printed by the printing unit.

This task requires two-way communication between the concurrent units. All concurrent units must cleanly terminate at the end of the program.
",#C.23,C#,"using System;
using System.Threading.Tasks;
using System.Collections.Concurrent;
using System.IO;
 
namespace SynchronousConcurrency
{
    class Program
    {
        static void Main(string[] args)
        {
            BlockingCollection<string> toWriterTask = new BlockingCollection<string>();
            BlockingCollection<int> fromWriterTask = new BlockingCollection<int>();
            Task writer = Task.Factory.StartNew(() => ConsoleWriter(toWriterTask, fromWriterTask));
            Task reader = Task.Factory.StartNew(() => FileReader(fromWriterTask, toWriterTask));
            Task.WaitAll(writer, reader);
        }
        static void ConsoleWriter(BlockingCollection<string> input, BlockingCollection<int> output)
        {
            int nLines = 0;
            string line;
            while ((line = input.Take()) != null)
            {
                Console.WriteLine(line);
                ++nLines;
            }
            output.Add(nLines);
        }
        static void FileReader(BlockingCollection<int> input, BlockingCollection<string> output)
        {
            StreamReader file = new StreamReader(""input.txt""); // TODO: check exceptions
            string line;
            while ((line = file.ReadLine()) != null)
            {
                output.Add(line);
 
            }
            output.Add(null); // EOF
            Console.WriteLine(""line count: "" + input.Take());
        }
    }
}",1434,42
8960,http://rosettacode.org/wiki/Take_notes_on_the_command_line,Take notes on the command line,"Take notes on the command line is part of Short Circuit's Console Program Basics selection.
Invoking NOTES without commandline arguments displays the current contents of the local NOTES.TXT if it exists.
If NOTES has arguments, the current date and time are appended to the local NOTES.TXT followed by a newline.
Then all the arguments, joined with spaces, prepended with a tab, and appended with a trailing newline, are written to NOTES.TXT.
If NOTES.TXT doesn't already exist in the current directory then a new NOTES.TXT file should be created.
",#C.23,C#,"using System;
using System.IO;
using System.Text;
 
namespace RosettaCode
{
  internal class Program
  {
    private const string FileName = ""NOTES.TXT"";
 
    private static void Main(string[] args)
    {
      if (args.Length==0)
      {
        string txt = File.ReadAllText(FileName);
        Console.WriteLine(txt);
      }
      else
      {
        var sb = new StringBuilder();
        sb.Append(DateTime.Now).Append(""\n\t"");
        foreach (string s in args)
          sb.Append(s).Append("" "");
        sb.Append(""\n"");
 
        if (File.Exists(FileName))
          File.AppendAllText(FileName, sb.ToString());
        else
          File.WriteAllText(FileName, sb.ToString());
      }
    }
  }
}",708,33
9021,http://rosettacode.org/wiki/Super-d_numbers,Super-d numbers,"A super-d number is a positive, decimal (base ten) integer   n   such that   d × nd   has at least   d   consecutive digits   d   where

   2 ≤ d ≤ 9

For instance, 753 is a super-3 number because 3 × 7533 = 1280873331.


Super-d   numbers are also shown on   MathWorld™   as   super-d    or   super-d.



Task

 Write a function/procedure/routine to find super-d numbers.
 For   d=2   through   d=6,   use the routine to show the first   10   super-d numbers.


Extra credit

 Show the first   10   super-7, super-8, and/or super-9 numbers   (optional).


See also

   Wolfram MathWorld - Super-d Number.
   OEIS: A014569 - Super-3 Numbers.

",#C.23,C#,"using System;
using System.Collections.Generic;
using BI = System.Numerics.BigInteger;
using lbi = System.Collections.Generic.List<System.Numerics.BigInteger[]>;
using static System.Console;
 
class Program {
 
    // provides 320 bits (90 decimal digits)
    struct LI { public UInt64 lo, ml, mh, hi, tp; }
 
    const UInt64 Lm = 1_000_000_000_000_000_000UL;
    const string Fm = ""D18"";
 
    static void inc(ref LI d, LI s) { // d += s
        d.lo += s.lo; while (d.lo >= Lm) { d.ml++; d.lo -= Lm; }
        d.ml += s.ml; while (d.ml >= Lm) { d.mh++; d.ml -= Lm; }
        d.mh += s.mh; while (d.mh >= Lm) { d.hi++; d.mh -= Lm; }
        d.hi += s.hi; while (d.hi >= Lm) { d.tp++; d.hi -= Lm; }
        d.tp += s.tp;
    }
 
    static void set(ref LI d, UInt64 s) { // d = s
        d.lo = s; d.ml = d.mh = d.hi = d.tp = 0;
    }
 
    const int ls = 10;
 
    static lbi co = new lbi { new BI[] { 0 } }; // for BigInteger addition
    static List<LI[]> Co = new List<LI[]> { new LI[1] }; // for UInt64 addition
 
    static Int64 ipow(Int64 bas, Int64 exp) { // Math.Pow()
        Int64 res = 1; while (exp != 0) {
            if ((exp & 1) != 0) res *= bas; exp >>= 1; bas *= bas;
        }
        return res;
    }
 
    // finishes up, shows performance value
    static void fin() { WriteLine(""{0}s"", (DateTime.Now - st).TotalSeconds.ToString().Substring(0, 5)); }
 
    static void funM(int d) { // straightforward BigInteger method, medium performance
        string s = new string(d.ToString()[0], d); Write(""{0}: "", d);
        for (int i = 0, c = 0; c < ls; i++)
            if ((BI.Pow((BI)i, d) * d).ToString().Contains(s))
                Write(""{0} "", i, ++c);
        fin();
    }
 
    static void funS(int d) { // BigInteger ""mostly adding"" method, low performance
        BI[] m = co[d];
        string s = new string(d.ToString()[0], d); Write(""{0}: "", d);
        for (int i = 0, c = 0; c < ls; i++) {
            if ((d * m[0]).ToString().Contains(s))
                Write(""{0} "", i, ++c);
            for (int j = d, k = d - 1; j > 0; j = k--) m[k] += m[j];
        }
        fin();
    }
 
    static string scale(uint s, ref LI x) { // performs a small multiply and returns a string value
        ulong Lo = x.lo * s, Ml = x.ml * s, Mh = x.mh * s, Hi = x.hi * s, Tp = x.tp * s;
        while (Lo >= Lm) { Lo -= Lm; Ml++; }
        while (Ml >= Lm) { Ml -= Lm; Mh++; }
        while (Mh >= Lm) { Mh -= Lm; Hi++; }
        while (Hi >= Lm) { Hi -= Lm; Tp++; }
        if (Tp > 0) return Tp.ToString() + Hi.ToString(Fm) + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);
        if (Hi > 0) return Hi.ToString() + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);
        if (Mh > 0) return Mh.ToString() + Ml.ToString(Fm) + Lo.ToString(Fm);
        if (Ml > 0) return Ml.ToString() + Lo.ToString(Fm);
        return Lo.ToString();
    }
 
    static void funF(int d) { // structure of UInt64 method, high performance
        LI[] m = Co[d];
        string s = new string(d.ToString()[0], d); Write(""{0}: "", d);
        for (int i = d, c = 0; c < ls; i++) {
            if (scale((uint)d, ref m[0]).Contains(s))
                Write(""{0} "", i, ++c);
            for (int j = d, k = d - 1; j > 0; j = k--)
                inc(ref m[k], m[j]);
        }
        fin();
    }
 
    static void init() { // initializes co and Co
        for (int v = 1; v < 10; v++) {
            BI[] res = new BI[v + 1];
            long[] f = new long[v + 1], l = new long[v + 1];
            for (int j = 0; j <= v; j++) {
                if (j == v) {
                    LI[] t = new LI[v + 1];
                    for (int y = 0; y <= v; y++) set(ref t[y], (UInt64)f[y]);
                    Co.Add(t);
                }
                res[j] = f[j];
                l[0] = f[0]; f[0] = ipow(j + 1, v);
                for (int a = 0, b = 1; b <= v; a = b++) {
                    l[b] = f[b]; f[b] = f[a] - l[a];
                }
            }
            for (int z = res.Length - 2; z > 0; z -= 2) res[z] *= -1;
            co.Add(res);
        }
    }
 
    static DateTime st;
 
    static void doOne(string title, int top, Action<int> func) {
        WriteLine('\n' + title); st = DateTime.Now;
        for (int i = 2; i <= top; i++) func(i);
    }
 
    static void Main(string[] args)
    {
        init(); const int top = 9;
        doOne(""BigInteger mostly addition:"", top, funS);
        doOne(""BigInteger.Pow():"", top, funM);
        doOne(""UInt64 structure mostly addition:"", top, funF);
    }
}",4533,121
9114,http://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping,Sutherland-Hodgman polygon clipping,"The   Sutherland-Hodgman clipping algorithm   finds the polygon that is the intersection between an arbitrary polygon (the “subject polygon”) and a convex polygon (the “clip polygon”).

It is used in computer graphics (especially 2D graphics) to reduce the complexity of a scene being displayed by eliminating parts of a polygon that do not need to be displayed.



Task

Take the closed polygon defined by the points:

 



[
(
50
,
150
)
,
(
200
,
50
)
,
(
350
,
150
)
,
(
350
,
300
)
,
(
250
,
300
)
,
(
200
,
250
)
,
(
150
,
350
)
,
(
100
,
250
)
,
(
100
,
200
)
]


{\displaystyle [(50,150),(200,50),(350,150),(350,300),(250,300),(200,250),(150,350),(100,250),(100,200)]}


and clip it by the rectangle defined by the points:

 



[
(
100
,
100
)
,
(
300
,
100
)
,
(
300
,
300
)
,
(
100
,
300
)
]


{\displaystyle [(100,100),(300,100),(300,300),(100,300)]}


Print the sequence of points that define the resulting clipped polygon.



Extra credit

Display all three polygons on a graphical surface, using a different color for each polygon and filling the resulting polygon.

(When displaying you may use either a north-west or a south-west origin, whichever is more convenient for your display mechanism.)



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
 
namespace Sutherland
{
    public static class SutherlandHodgman
    {
        #region Class: Edge
 
        /// <summary>
        /// This represents a line segment
        /// </summary>
        private class Edge
        {
            public Edge(Point from, Point to)
            {
                this.From = from;
                this.To = to;
            }
 
            public readonly Point From;
            public readonly Point To;
        }
 
        #endregion
 
        /// <summary>
        /// This clips the subject polygon against the clip polygon (gets the intersection of the two polygons)
        /// </summary>
        /// <remarks>
        /// Based on the psuedocode from:
        /// http://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman
        /// </remarks>
        /// <param name=""subjectPoly"">Can be concave or convex</param>
        /// <param name=""clipPoly"">Must be convex</param>
        /// <returns>The intersection of the two polygons (or null)</returns>
        public static Point[] GetIntersectedPolygon(Point[] subjectPoly, Point[] clipPoly)
        {
            if (subjectPoly.Length < 3 || clipPoly.Length < 3)
            {
                throw new ArgumentException(string.Format(""The polygons passed in must have at least 3 points: subject={0}, clip={1}"", subjectPoly.Length.ToString(), clipPoly.Length.ToString()));
            }
 
            List<Point> outputList = subjectPoly.ToList();
 
            //	Make sure it's clockwise
            if (!IsClockwise(subjectPoly))
            {
                outputList.Reverse();
            }
 
            //	Walk around the clip polygon clockwise
            foreach (Edge clipEdge in IterateEdgesClockwise(clipPoly))
            {
                List<Point> inputList = outputList.ToList();		//	clone it
                outputList.Clear();
 
                if (inputList.Count == 0)
                {
                    //	Sometimes when the polygons don't intersect, this list goes to zero.  Jump out to avoid an index out of range exception
                    break;
                }
 
                Point S = inputList[inputList.Count - 1];
 
                foreach (Point E in inputList)
                {
                    if (IsInside(clipEdge, E))
                    {
                        if (!IsInside(clipEdge, S))
                        {
                            Point? point = GetIntersect(S, E, clipEdge.From, clipEdge.To);
                            if (point == null)
                            {
                                throw new ApplicationException(""Line segments don't intersect"");		//	may be colinear, or may be a bug
                            }
                            else
                            {
                                outputList.Add(point.Value);
                            }
                        }
 
                        outputList.Add(E);
                    }
                    else if (IsInside(clipEdge, S))
                    {
                        Point? point = GetIntersect(S, E, clipEdge.From, clipEdge.To);
                        if (point == null)
                        {
                            throw new ApplicationException(""Line segments don't intersect"");		//	may be colinear, or may be a bug
                        }
                        else
                        {
                            outputList.Add(point.Value);
                        }
                    }
 
                    S = E;
                }
            }
 
            //	Exit Function
            return outputList.ToArray();
        }
 
        #region Private Methods
 
        /// <summary>
        /// This iterates through the edges of the polygon, always clockwise
        /// </summary>
        private static IEnumerable<Edge> IterateEdgesClockwise(Point[] polygon)
        {
            if (IsClockwise(polygon))
            {
                #region Already clockwise
 
                for (int cntr = 0; cntr < polygon.Length - 1; cntr++)
                {
                    yield return new Edge(polygon[cntr], polygon[cntr + 1]);
                }
 
                yield return new Edge(polygon[polygon.Length - 1], polygon[0]);
 
                #endregion
            }
            else
            {
                #region Reverse
 
                for (int cntr = polygon.Length - 1; cntr > 0; cntr--)
                {
                    yield return new Edge(polygon[cntr], polygon[cntr - 1]);
                }
 
                yield return new Edge(polygon[0], polygon[polygon.Length - 1]);
 
                #endregion
            }
        }
 
        /// <summary>
        /// Returns the intersection of the two lines (line segments are passed in, but they are treated like infinite lines)
        /// </summary>
        /// <remarks>
        /// Got this here:
        /// http://stackoverflow.com/questions/14480124/how-do-i-detect-triangle-and-rectangle-intersection
        /// </remarks>
        private static Point? GetIntersect(Point line1From, Point line1To, Point line2From, Point line2To)
        {
            Vector direction1 = line1To - line1From;
            Vector direction2 = line2To - line2From;
            double dotPerp = (direction1.X * direction2.Y) - (direction1.Y * direction2.X);
 
            // If it's 0, it means the lines are parallel so have infinite intersection points
            if (IsNearZero(dotPerp))
            {
                return null;
            }
 
            Vector c = line2From - line1From;
            double t = (c.X * direction2.Y - c.Y * direction2.X) / dotPerp;
            //if (t < 0 || t > 1)
            //{
            //    return null;		//	lies outside the line segment
            //}
 
            //double u = (c.X * direction1.Y - c.Y * direction1.X) / dotPerp;
            //if (u < 0 || u > 1)
            //{
            //    return null;		//	lies outside the line segment
            //}
 
            //	Return the intersection point
            return line1From + (t * direction1);
        }
 
        private static bool IsInside(Edge edge, Point test)
        {
            bool? isLeft = IsLeftOf(edge, test);
            if (isLeft == null)
            {
                //	Colinear points should be considered inside
                return true;
            }
 
            return !isLeft.Value;
        }
        private static bool IsClockwise(Point[] polygon)
        {
            for (int cntr = 2; cntr < polygon.Length; cntr++)
            {
                bool? isLeft = IsLeftOf(new Edge(polygon[0], polygon[1]), polygon[cntr]);
                if (isLeft != null)		//	some of the points may be colinear.  That's ok as long as the overall is a polygon
                {
                    return !isLeft.Value;
                }
            }
 
            throw new ArgumentException(""All the points in the polygon are colinear"");
        }
 
        /// <summary>
        /// Tells if the test point lies on the left side of the edge line
        /// </summary>
        private static bool? IsLeftOf(Edge edge, Point test)
        {
            Vector tmp1 = edge.To - edge.From;
            Vector tmp2 = test - edge.To;
 
            double x = (tmp1.X * tmp2.Y) - (tmp1.Y * tmp2.X);		//	dot product of perpendicular?
 
            if (x < 0)
            {
                return false;
            }
            else if (x > 0)
            {
                return true;
            }
            else
            {
                //	Colinear points;
                return null;
            }
        }
 
        private static bool IsNearZero(double testValue)
        {
            return Math.Abs(testValue) <= .000000001d;
        }
 
        #endregion
    }
}",7911,237
9243,http://rosettacode.org/wiki/Temperature_conversion,Temperature conversion,"There are quite a number of temperature scales. For this task we will concentrate on four of the perhaps best-known ones:
Kelvin, Celsius, Fahrenheit, and Rankine.

The Celsius and Kelvin scales have the same magnitude, but different null points.

 0 degrees Celsius corresponds to 273.15 kelvin.
 0 kelvin is absolute zero.
The Fahrenheit and Rankine scales also have the same magnitude, but different null points.

 0 degrees Fahrenheit corresponds to 459.67 degrees Rankine.
 0 degrees Rankine is absolute zero.
The Celsius/Kelvin and Fahrenheit/Rankine scales have a ratio of 5 : 9.



Task
Write code that accepts a value of kelvin, converts it to values of the three other scales, and prints the result.



Example

K  21.00

C  -252.15

F  -421.87

R  37.80


",#C.23,C#,"using System;
 
namespace TemperatureConversion
{
    class Program
    {
        static Func<double, double> ConvertKelvinToFahrenheit = x => (x * 1.8) - 459.67;
        static Func<double, double> ConvertKelvinToRankine = x => x * 1.8;
        static Func<double, double> ConvertKelvinToCelsius = x => x = 273.13;
 
        static void Main(string[] args)
        {
            Console.Write(""Enter a Kelvin Temperature: "");
            string inputVal = Console.ReadLine();
            double kelvinTemp = 0f;
 
            if (double.TryParse(inputVal, out kelvinTemp))
            {
                Console.WriteLine(string.Format(""Kelvin: {0}"", kelvinTemp));
                Console.WriteLine(string.Format(""Fahrenheit: {0}"", ConvertKelvinToFahrenheit(kelvinTemp)));
                Console.WriteLine(string.Format(""Rankine: {0}"", ConvertKelvinToRankine(kelvinTemp)));
                Console.WriteLine(string.Format(""Celsius: {0}"", ConvertKelvinToCelsius(kelvinTemp)));
                Console.ReadKey();
            }
            else
            {
                Console.WriteLine(""Invalid input value: "" + inputVal);
            }
        }
    }
}",1159,31
9345,http://rosettacode.org/wiki/Symmetric_difference,Symmetric difference,"Task
Given two sets A and B, compute 



(
A
∖
B
)
∪
(
B
∖
A
)
.


{\displaystyle (A\setminus B)\cup (B\setminus A).}



That is, enumerate the items that are in A or B but not both. This set is called the symmetric difference of A and B.

In other words: 



(
A
∪
B
)
∖
(
A
∩
B
)


{\displaystyle (A\cup B)\setminus (A\cap B)}

 (the set of items that are in at least one of A or B minus the set of items that are in both A and B).

Optionally, give the individual differences (



A
∖
B


{\displaystyle A\setminus B}

 and 



B
∖
A


{\displaystyle B\setminus A}

) as well.



Test cases
A = {John, Bob, Mary, Serena}
B = {Jim, Mary, John, Bob}



Notes
 If your code uses lists of items to represent sets then ensure duplicate items in lists are correctly handled. For example two lists representing sets of a = [""John"", ""Serena"", ""Bob"", ""Mary"", ""Serena""] and b = [""Jim"", ""Mary"", ""John"", ""Jim"", ""Bob""] should produce the result of just two strings: [""Serena"", ""Jim""], in any order.
 In the mathematical notation above A \ B gives the set of items in A that are not in B; A ∪ B gives the set of items in both A and B, (their union); and A ∩ B gives the set of items that are in both A and B (their intersection).

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace RosettaCode.SymmetricDifference
{
    public static class IEnumerableExtension
    {
        public static IEnumerable<T> SymmetricDifference<T>(this IEnumerable<T> @this, IEnumerable<T> that)
        {
            return @this.Except(that).Concat(that.Except(@this));
        }
    }
 
    class Program
    {
        static void Main()
        {
            var a = new[] { ""John"", ""Bob"", ""Mary"", ""Serena"" };
            var b = new[] { ""Jim"", ""Mary"", ""John"", ""Bob"" };
 
            foreach (var element in a.SymmetricDifference(b))
            {
                Console.WriteLine(element);
            }
        }
    }
}",703,28
9542,http://rosettacode.org/wiki/System_time,System time,"Task

Output the system time   (any units will do as long as they are noted) either by a system command or one built into the language.

The system time can be used for debugging, network information, random number seeds, or something as simple as program performance.



Related task

   Date format


See also

   Retrieving system time (wiki)

",#C.23,C#,Console.WriteLine(DateTime.Now);,32,1
9940,http://rosettacode.org/wiki/Sum_and_product_puzzle,Sum and product puzzle,"Task[edit]
Solve the ""Impossible Puzzle"":


X and Y are two different whole numbers greater than 1. Their sum is no greater than 100, and Y is greater than X. S and P are two mathematicians (and consequently perfect logicians); S knows the sum X+Y and P knows the product X*Y. Both S and P know all the information in this paragraph.
The following conversation occurs:

 S says ""P does not know X and Y.""
 P says ""Now I know X and Y.""
 S says ""Now I also know X and Y!""
What are X and Y?


Guidance
It can be hard to wrap one's head around what the three lines of dialog between S (the ""sum guy"") and P (the ""product guy"") convey about the values of X and Y.

So for your convenience, here's a break-down:





 Quote

 Implied fact


 1)

 S says ""P does not know X and Y.""

 For every possible sum decomposition of the number X+Y, the product has in turn more than one product decomposition.


 2)

 P says ""Now I know X and Y.""

 The number X*Y has only one product decomposition for which fact 1 is true.


 3)

 S says ""Now I also know X and Y.""

 The number X+Y has only one sum decomposition for which fact 2 is true.

Terminology:

 ""sum decomposition"" of a number = Any pair of positive integers (A, B) so that A+B equals the number. Here, with the additional constraint 2 ≤ A < B.
 ""product decomposition"" of a number = Any pair of positive integers (A, B) so that A*B equals the number. Here, with the additional constraint 2 ≤ A < B.


Your program can solve the puzzle by considering all possible pairs (X, Y) in the range 2 ≤ X < Y ≤ 98, and then successively eliminating candidates based on the three facts. It turns out only one solution remains!

See the Python example for an implementation that uses this approach with a few optimizations.

See also
   Wikipedia:   Sum and Product Puzzle
",#C.23,C#,"using System;
using System.Linq;
using System.Collections.Generic;
 
public class Program
{
    public static void Main()
    {
        const int maxSum = 100;
        var pairs = (
            from X in 2.To(maxSum / 2 - 1)
            from Y in (X + 1).To(maxSum - 2).TakeWhile(y => X + y <= maxSum)
            select new { X, Y, S = X + Y, P = X * Y }
            ).ToHashSet();
 
        Console.WriteLine(pairs.Count);
 
        var uniqueP = pairs.GroupBy(pair => pair.P).Where(g => g.Count() == 1).Select(g => g.Key).ToHashSet();
 
        pairs.ExceptWith(pairs.GroupBy(pair => pair.S).Where(g => g.Any(pair => uniqueP.Contains(pair.P))).SelectMany(g => g));
        Console.WriteLine(pairs.Count);
 
        pairs.ExceptWith(pairs.GroupBy(pair => pair.P).Where(g => g.Count() > 1).SelectMany(g => g));
        Console.WriteLine(pairs.Count);
 
        pairs.ExceptWith(pairs.GroupBy(pair => pair.S).Where(g => g.Count() > 1).SelectMany(g => g));
        Console.WriteLine(pairs.Count);
 
        foreach (var pair in pairs) Console.WriteLine(pair);
    }
}
 
public static class Extensions
{
    public static IEnumerable<int> To(this int start, int end) {
        for (int i = start; i <= end; i++) yield return i;
    }
 
    public static HashSet<T> ToHashSet<T>(this IEnumerable<T> source) => new HashSet<T>(source);
}",1332,40
10191,http://rosettacode.org/wiki/Sum_to_100,Sum to 100,"Task

Find solutions to the    sum to one hundred    puzzle.



Add (insert) the mathematical
operators      +    or    -      (plus
or minus)   before any of the digits in the

decimal numeric string    123456789    such that the
resulting mathematical expression adds up to a

particular sum   (in this iconic case,   100).



Example:

             123 + 4 - 5 + 67 - 89   =   100     

Show all output here.



   Show all solutions that sum to    100 
   Show the sum that has the maximum   number   of solutions   (from zero to infinity‡)
   Show the lowest positive sum that   can't   be expressed   (has no solutions),   using the rules for this task
   Show the ten highest numbers that can be expressed using the rules for this task   (extra credit)


‡   (where   infinity   would be a relatively small   123,456,789)



An example of a sum that can't be expressed   (within the rules of this task)   is:   5074

(which,   of course,   isn't the lowest positive sum that can't be expressed).



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
class Program
{
    static void Main(string[] args)
    {
        // All unique expressions that have a plus sign in front of the 1; calculated in parallel
        var expressionsPlus = Enumerable.Range(0, (int)Math.Pow(3, 8)).AsParallel().Select(i => new Expression(i, 1));
        // All unique expressions that have a minus sign in front of the 1; calculated in parallel
        var expressionsMinus = Enumerable.Range(0, (int)Math.Pow(3, 8)).AsParallel().Select(i => new Expression(i, -1));
        var expressions = expressionsPlus.Concat(expressionsMinus);
        var results = new Dictionary<int, List<Expression>>();
        foreach (var e in expressions)
        {
            if (results.Keys.Contains(e.Value))
                results[e.Value].Add(e);
            else
                results[e.Value] = new List<Expression>() { e };
        }
        Console.WriteLine(""Show all solutions that sum to 100"");
        foreach (Expression e in results[100])
            Console.WriteLine(""  "" + e);
        Console.WriteLine(""Show the sum that has the maximum number of solutions (from zero to infinity)"");
        var summary = results.Keys.Select(k => new Tuple<int, int>(k, results[k].Count));
        var maxSols = summary.Aggregate((a, b) => a.Item2 > b.Item2 ? a : b);
        Console.WriteLine(""  The sum "" + maxSols.Item1 + "" has "" + maxSols.Item2 + "" solutions."");
        Console.WriteLine(""Show the lowest positive sum that can't be expressed (has no solutions), using the rules for this task"");
        var lowestPositive = Enumerable.Range(1, int.MaxValue).First(x => !results.Keys.Contains(x));
        Console.WriteLine(""  "" + lowestPositive);
        Console.WriteLine(""Show the ten highest numbers that can be expressed using the rules for this task (extra credit)"");
        var highest = from k in results.Keys
                      orderby k descending
                      select k;
        foreach (var x in highest.Take(10))
            Console.WriteLine(""  "" + x);
    }
}
public enum Operations { Plus, Minus, Join };
public class Expression
{
    protected Operations[] Gaps;
    // 123456789 => there are 8 ""gaps"" between each number
    ///             with 3 possibilities for each gap: plus, minus, or join
    public int Value; // What this expression sums up to
    protected int _one;
 
    public Expression(int serial, int one)
    {
        _one = one;
        Gaps = new Operations[8];
        // This represents ""serial"" as a base 3 number, each Gap expression being a base-three digit
        int divisor = 2187; // == Math.Pow(3,7)
        int times;
        for (int i = 0; i < 8; i++)
        {
            times = Math.DivRem(serial, divisor, out serial);
            divisor /= 3;
            if (times == 0)
                Gaps[i] = Operations.Join;
            else if (times == 1)
                Gaps[i] = Operations.Minus;
            else
                Gaps[i] = Operations.Plus;
        }
        // go ahead and calculate the value of this expression
        // because this is going to be done in a parallel thread (save time)
        Value = Evaluate();
    }
    public override string ToString()
    {
        string ret = _one.ToString();
        for (int i = 0; i < 8; i++)
        {
            switch (Gaps[i])
            {
                case Operations.Plus:
                    ret += ""+"";
                    break;
                case Operations.Minus:
                    ret += ""-"";
                    break;
            }
            ret += (i + 2);
        }
        return ret;
    }
    private int Evaluate()
        /* Calculate what this expression equals */
    {
        var numbers = new int[9];
        int nc = 0;
        var operations = new List<Operations>();
        int a = 1;
        for (int i = 0; i < 8; i++)
        {
            if (Gaps[i] == Operations.Join)
                a = a * 10 + (i + 2);
            else
            {
                if (a > 0)
                {
                    if (nc == 0)
                        a *= _one;
                    numbers[nc++] = a;
                    a = i + 2;
                }
                operations.Add(Gaps[i]);
            }
        }
        if (nc == 0)
            a *= _one;
        numbers[nc++] = a;
        int ni = 0;
        int left = numbers[ni++];
        foreach (var operation in operations)
        {
            int right = numbers[ni++];
            if (operation == Operations.Plus)
                left = left + right;
            else
                left = left - right;
        }
        return left;
    }
}",4668,127
10194,http://rosettacode.org/wiki/Sum_of_squares,Sum of squares,"Task

Write a program to find the sum of squares of a numeric vector.

The program should work on a zero-length vector (with an answer of   0).



Related task

   Mean

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
class Program
{
    static int SumOfSquares(IEnumerable<int> list)
    {
        return list.Sum(x => x * x);
    }
    static void Main(string[] args)
    {
        Console.WriteLine(SumOfSquares(new int[] { 4, 8, 15, 16, 23, 42 })); // 2854
        Console.WriteLine(SumOfSquares(new int[] { 1, 2, 3, 4, 5 })); // 55
        Console.WriteLine(SumOfSquares(new int[] { })); // 0
    }
}",456,17
10209,http://rosettacode.org/wiki/Sum_multiples_of_3_and_5,Sum multiples of 3 and 5,"Task

The objective is to write a function that finds the sum of all positive multiples of 3 or 5 below n.

Show output for n = 1000.

This is is the same as Project Euler problem 1.

Extra credit: do this efficiently for n = 1e20 or higher.



",#C.23,C#," 
using System;
using System.Collections.Generic;
using System.Numerics;
 
namespace RosettaCode
{
    class Program
    {
        static void Main()
        {
            List<BigInteger> candidates = new List<BigInteger>(new BigInteger[] { 1000, 100000, 10000000, 10000000000, 1000000000000000 });
            candidates.Add(BigInteger.Parse(""100000000000000000000""));
 
            foreach (BigInteger candidate in candidates)
            {
                BigInteger c = candidate - 1;
                BigInteger answer3 = GetSumOfNumbersDivisibleByN(c, 3);
                BigInteger answer5 = GetSumOfNumbersDivisibleByN(c, 5);
                BigInteger answer15 = GetSumOfNumbersDivisibleByN(c, 15);
 
                Console.WriteLine(""The sum of numbers divisible by 3 or 5 between 1 and {0} is {1}"", c, answer3 + answer5 - answer15);
            }
 
            Console.ReadKey(true);
        }
 
        private static BigInteger GetSumOfNumbersDivisibleByN(BigInteger candidate, uint n)
        {
            BigInteger largest = candidate;
            while (largest % n > 0)
                largest--;
            BigInteger totalCount = (largest / n);
            BigInteger pairCount = totalCount / 2;
            bool unpairedNumberOnFoldLine = (totalCount % 2 == 1);
            BigInteger pairSum = largest + n;
            return pairCount * pairSum + (unpairedNumberOnFoldLine ? pairSum / 2 : 0);
        }
 
    }
}
 ",1440,42
10222,http://rosettacode.org/wiki/Substitution_cipher,Substitution cipher,"Substitution Cipher Implementation - File Encryption/Decryption



Task

Encrypt a input/source file by replacing every upper/lower case alphabets of the source file with another predetermined upper/lower case alphabets or symbols and save it into another output/encrypted file and then again convert that output/encrypted file into original/decrypted file.

This type of Encryption/Decryption scheme is often called a Substitution Cipher.



Related tasks

 Caesar cipher
 Rot-13
 Vigenère Cipher/Cryptanalysis


See also

 Wikipedia: Substitution cipher

",#C.23,C#,"using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace SubstitutionCipherProject
{
    class SubstitutionCipher
    {
        static void Main(string[] args)
        {
            doEncDec(""e:\\source.txt"", ""enc.txt"", true);
            doEncDec(""enc.txt"", ""dec.txt"", false);
            Console.WriteLine(""Done"");
            Console.ReadKey();
        }
        static void doEncDec(String source, String target, bool IsEncrypt)
        {
            ITransform trans;
 
            if (IsEncrypt)
                trans = new Encrypt();
            else
                trans = new Decrypt();
 
            FileInfo sfi = new FileInfo(source);
            FileStream sstream = sfi.OpenRead();
            StreamReader sr = new StreamReader(sstream);
 
            FileInfo tfi = new FileInfo(target);
            FileStream tstream = tfi.OpenWrite();
            TransformWriter tw = new TransformWriter(tstream, trans);
            StreamWriter sw = new StreamWriter(tw);
 
            String line;
            while ((line = sr.ReadLine()) != null)
                sw.WriteLine(line);
            sw.Close();
        }
    }
    public interface ITransform
    {
        byte transform(byte ch);
    }
    public class Encrypt : ITransform
    {
        const String str = ""xyfagchbimpourvnqsdewtkjzl"";
        byte ITransform.transform(byte ch)
        {
            if (char.IsLower((char)ch))
                ch = (byte)str[ch - (byte)'a'];
            return ch;
        }
    }
    class Decrypt : ITransform
    {
        const String str = ""xyfagchbimpourvnqsdewtkjzl"";
        byte ITransform.transform(byte ch)
        {
            if (char.IsLower((char)ch))
                ch = (byte)(str.IndexOf((char)ch) + 'a');
            return ch;
        }
    }
    class TransformWriter : Stream, IDisposable
    {
        private Stream outs;
        private ITransform trans;
 
        public TransformWriter(Stream s, ITransform t)
        {
            this.outs = s;
            this.trans = t;
        }
 
        public override bool CanRead
        {
            get { return false; }
        }
 
        public override bool CanSeek
        {
            get { return false; }
        }
 
        public override bool CanWrite
        {
            get { return true; }
        }
        public override void Flush()
        {
            outs.Flush();
        }
 
        public override long Length
        {
            get { return outs.Length; }
        }
        public override long Position
        {
            get
            {
                return outs.Position;
            }
            set
            {
                outs.Position = value;
            }
        }
        public override long Seek(long offset, SeekOrigin origin)
        {
            return outs.Seek(offset, origin);
        }
 
        public override void SetLength(long value)
        {
            outs.SetLength(value);
        }
 
        public override void Write(byte[] buf, int off, int len)
        {
            for (int i = off; i < off + len; i++)
                buf[i] = trans.transform(buf[i]);
            outs.Write(buf, off, len);
        }
 
        void IDisposable.Dispose()
        {
            outs.Dispose();
        }
 
        public override void Close()
        {
            outs.Close();
        }
 
        public override int Read(byte[] cbuf, int off, int count)
        {
            return outs.Read(cbuf, off, count);
        }
    }
}",3572,144
10228,http://rosettacode.org/wiki/Sum_digits_of_an_integer,Sum digits of an integer,"Task

Take a   Natural Number   in a given base and return the sum of its digits:

   110         sums to   1
   123410   sums to   10
   fe16       sums to   29
   f0e16     sums to   29

",#C.23,C#,"namespace RosettaCode.SumDigitsOfAnInteger
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
 
    internal static class Program
    {
        /// <summary>
        ///     Enumerates the digits of a number in a given base.
        /// </summary>
        /// <param name=""number""> The number. </param>
        /// <param name=""base""> The base. </param>
        /// <returns> The digits of the number in the given base. </returns>
        /// <remarks>
        ///     The digits are enumerated from least to most significant.
        /// </remarks>
        private static IEnumerable<int> Digits(this int number, int @base = 10)
        {
            while (number != 0)
            {
                int digit;
                number = Math.DivRem(number, @base, out digit);
                yield return digit;
            }
        }
 
        /// <summary>
        ///     Sums the digits of a number in a given base.
        /// </summary>
        /// <param name=""number""> The number. </param>
        /// <param name=""base""> The base. </param>
        /// <returns> The sum of the digits of the number in the given base. </returns>
        private static int SumOfDigits(this int number, int @base = 10)
        {
            return number.Digits(@base).Sum();
        }
 
        /// <summary>
        ///     Demonstrates <see cref=""SumOfDigits"" />.
        /// </summary>
        private static void Main()
        {
            foreach (var example in
                new[]
                {
                    new {Number = 1, Base = 10},
                    new {Number = 12345, Base = 10},
                    new {Number = 123045, Base = 10},
                    new {Number = 0xfe, Base = 0x10},
                    new {Number = 0xf0e, Base = 0x10}
                })
            {
                Console.WriteLine(example.Number.SumOfDigits(example.Base));
            }
        }
    }
}",1938,58
10244,http://rosettacode.org/wiki/Sum_and_product_of_an_array,Sum and product of an array,"Task

Compute the sum and product of an array of integers.



",#C.23,C#,"int sum = 0, prod = 1;
int[] arg = { 1, 2, 3, 4, 5 };
foreach (int value in arg) {
  sum += value;
  prod *= value;
}",117,6
10245,http://rosettacode.org/wiki/Sum_of_a_series,Sum of a series,"Compute the   nth   term of a series,   i.e. the sum of the   n   first terms of the corresponding sequence.

Informally this value, or its limit when   n   tends to infinity, is also called the sum of the series, thus the title of this task.

For this task, use:

 




S

n


=

∑

k
=
1


n




1

k

2






{\displaystyle S_{n}=\sum _{k=1}^{n}{\frac {1}{k^{2}}}}




 and compute   




S

1000




{\displaystyle S_{1000}}




This approximates the   zeta function   for   S=2,   whose exact value

 



ζ
(
2
)
=



π

2


6




{\displaystyle \zeta (2)={\pi ^{2} \over 6}}


is the solution of the Basel problem.



",#C.23,C#,"class Program
{
    static void Main(string[] args)
    {
        // Create and fill a list of number 1 to 1000
 
        List<double> myList = new List<double>();
        for (double i = 1; i < 1001; i++)
        {
            myList.Add(i);
        }
        // Calculate the sum of 1/x^2
 
        var sum = myList.Sum(x => 1/(x*x));
 
        Console.WriteLine(sum);
        Console.ReadLine();
    }
}",406,19
10300,http://rosettacode.org/wiki/Subtractive_generator,Subtractive generator,"A subtractive generator calculates a sequence of random numbers, where each number is congruent to the subtraction of two previous numbers from the sequence. 

The formula is

 




r

n


=

r

(
n
−
i
)


−

r

(
n
−
j
)




(
mod

m
)



{\displaystyle r_{n}=r_{(n-i)}-r_{(n-j)}{\pmod {m}}}


for some fixed values of 



i


{\displaystyle i}

, 



j


{\displaystyle j}

 and 



m


{\displaystyle m}

, all positive integers. Supposing that 



i
>
j


{\displaystyle i>j}

, then the state of this generator is the list of the previous numbers from 




r

n
−
i




{\displaystyle r_{n-i}}

 to 




r

n
−
1




{\displaystyle r_{n-1}}

. Many states generate uniform random integers from 



0


{\displaystyle 0}

 to 



m
−
1


{\displaystyle m-1}

, but some states are bad. A state, filled with zeros, generates only zeros. If 



m


{\displaystyle m}

 is even, then a state, filled with even numbers, generates only even numbers. More generally, if 



f


{\displaystyle f}

 is a factor of 



m


{\displaystyle m}

, then a state, filled with multiples of 



f


{\displaystyle f}

, generates only multiples of 



f


{\displaystyle f}

.

All subtractive generators have some weaknesses. The formula correlates 




r

n




{\displaystyle r_{n}}

, 




r

(
n
−
i
)




{\displaystyle r_{(n-i)}}

 and 




r

(
n
−
j
)




{\displaystyle r_{(n-j)}}

; these three numbers are not independent, as true random numbers would be. Anyone who observes 



i


{\displaystyle i}

 consecutive numbers can predict the next numbers, so the generator is not cryptographically secure. The authors of Freeciv (utility/rand.c) and xpat2 (src/testit2.c) knew another problem: the low bits are less random than the high bits.

The subtractive generator has a better reputation than the linear congruential generator, perhaps because it holds more state. A subtractive generator might never multiply numbers: this helps where multiplication is slow. A subtractive generator might also avoid division: the value of 




r

(
n
−
i
)


−

r

(
n
−
j
)




{\displaystyle r_{(n-i)}-r_{(n-j)}}

 is always between 



−
m


{\displaystyle -m}

 and 



m


{\displaystyle m}

, so a program only needs to add 



m


{\displaystyle m}

 to negative numbers.

The choice of 



i


{\displaystyle i}

 and 



j


{\displaystyle j}

 affects the period of the generator. A popular choice is 



i
=
55


{\displaystyle i=55}

 and 



j
=
24


{\displaystyle j=24}

, so the formula is

 




r

n


=

r

(
n
−
55
)


−

r

(
n
−
24
)




(
mod

m
)



{\displaystyle r_{n}=r_{(n-55)}-r_{(n-24)}{\pmod {m}}}


The subtractive generator from xpat2 uses

 




r

n


=

r

(
n
−
55
)


−

r

(
n
−
24
)




(
mod


10

9


)



{\displaystyle r_{n}=r_{(n-55)}-r_{(n-24)}{\pmod {10^{9}}}}


The implementation is by J. Bentley and comes from program_tools/universal.c of the DIMACS (netflow) archive at Rutgers University. It credits Knuth, TAOCP, Volume 2, Section 3.2.2 (Algorithm A).

Bentley uses this clever algorithm to seed the generator.

 Start with a single 



s
e
e
d


{\displaystyle seed}

 in range 



0


{\displaystyle 0}

 to 




10

9


−
1


{\displaystyle 10^{9}-1}

.
 Set 




s

0


=
s
e
e
d


{\displaystyle s_{0}=seed}

 and 




s

1


=
1


{\displaystyle s_{1}=1}

. The inclusion of 




s

1


=
1


{\displaystyle s_{1}=1}

 avoids some bad states (like all zeros, or all multiples of 10).
 Compute 




s

2


,

s

3


,
.
.
.
,

s

54




{\displaystyle s_{2},s_{3},...,s_{54}}

 using the subtractive formula 




s

n


=

s

(
n
−
2
)


−

s

(
n
−
1
)




(
mod


10

9


)



{\displaystyle s_{n}=s_{(n-2)}-s_{(n-1)}{\pmod {10^{9}}}}

.
 Reorder these 55 values so 




r

0


=

s

34




{\displaystyle r_{0}=s_{34}}

, 




r

1


=

s

13




{\displaystyle r_{1}=s_{13}}

, 




r

2


=

s

47




{\displaystyle r_{2}=s_{47}}

, ..., 




r

n


=

s

(
34
∗
(
n
+
1
)


(
mod

55
)

)




{\displaystyle r_{n}=s_{(34*(n+1){\pmod {55}})}}

.
 This is the same order as 




s

0


=

r

54




{\displaystyle s_{0}=r_{54}}

, 




s

1


=

r

33




{\displaystyle s_{1}=r_{33}}

, 




s

2


=

r

12




{\displaystyle s_{2}=r_{12}}

, ..., 




s

n


=

r

(
(
34
∗
n
)
−
1


(
mod

55
)

)




{\displaystyle s_{n}=r_{((34*n)-1{\pmod {55}})}}

.
 This rearrangement exploits how 34 and 55 are relatively prime.
 Compute the next 165 values 




r

55




{\displaystyle r_{55}}

 to 




r

219




{\displaystyle r_{219}}

. Store the last 55 values.
This generator yields the sequence 




r

220




{\displaystyle r_{220}}

, 




r

221




{\displaystyle r_{221}}

, 




r

222




{\displaystyle r_{222}}

 and so on. For example, if the seed is 292929, then the sequence begins with 




r

220


=
467478574


{\displaystyle r_{220}=467478574}

, 




r

221


=
512932792


{\displaystyle r_{221}=512932792}

, 




r

222


=
539453717


{\displaystyle r_{222}=539453717}

. By starting at 




r

220




{\displaystyle r_{220}}

, this generator avoids a bias from the first numbers of the sequence. This generator must store the last 55 numbers of the sequence, so to compute the next 




r

n




{\displaystyle r_{n}}

. Any array or list would work; a ring buffer is ideal but not necessary.

Implement a subtractive generator that replicates the sequences from xpat2.



",#C.23,C#," 
public class SubtractiveGenerator {
    public static int MAX = 1000000000;
    private int[] state;
    private int pos;
 
    private int mod(int n) {
        return ((n % MAX) + MAX) % MAX;
    }
 
    public SubtractiveGenerator(int seed) {
        state = new int[55];
 
        int[] temp = new int[55];
        temp[0] = mod(seed);
        temp[1] = 1;
        for(int i = 2; i < 55; ++i)
            temp[i] = mod(temp[i - 2] - temp[i - 1]);
 
        for(int i = 0; i < 55; ++i)
            state[i] = temp[(34 * (i + 1)) % 55];
 
        pos = 54;
        for(int i = 55; i < 220; ++i)
            next();
    }
 
    public int next() {
        int temp = mod(state[(pos + 1) % 55] - state[(pos + 32) % 55]);
        pos = (pos + 1) % 55;
        state[pos] = temp;
        return temp;
    }
 
    static void Main(string[] args) {
        SubtractiveGenerator gen = new SubtractiveGenerator(292929);
        for(int i = 220; i < 230; ++i)
            Console.WriteLine(i.ToString() + "": "" + gen.next().ToString());
    }
}
 ",1039,41
10330,http://rosettacode.org/wiki/Successive_prime_differences,Successive prime differences,"The series of increasing prime numbers begins: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, ...

The task applies a filter to the series returning groups of successive primes, (s'primes), that differ from the next by a given value or values.

Example 1: Specifying that the difference between s'primes be 2 leads to the groups:

(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), ...

(Known as Twin primes or Prime pairs)

Example 2: Specifying more than one difference between s'primes leads to groups of size one greater than the number of differences. Differences of 2, 4 leads to the groups:

(5, 7, 11), (11, 13, 17), (17, 19, 23), (41, 43, 47), .... 

In the first group 7 is two more than 5 and 11 is four more than 7; as well as 5, 7, and 11 being successive primes.
Differences are checked in the order of the values given, (differences of 4, 2 would give different groups entirely).

Task

 In each case use a list of primes less than 1_000_000
 For the following Differences show the first and last group, as well as the number of groups found:
 Differences of 2.
 Differences of 1.
 Differences of 2, 2.
 Differences of 2, 4.
 Differences of 4, 2.
 Differences of 6, 4, 2.
 Show output here.

Note: Generation of a list of primes is a secondary aspect of the task. Use of a built in function, well known library, or importing/use of prime generators from other Rosetta Code tasks is encouraged.

references
https://pdfs.semanticscholar.org/78a1/7349819304863ae061df88dbcb26b4908f03.pdf
https://www.primepuzzles.net/puzzles/puzz_011.htm
https://matheplanet.de/matheplanet/nuke/html/viewtopic.php?topic=232720&start=0",#C.23,C#,"using System;
using System.Collections.Generic;
using static System.Linq.Enumerable;
 
public static class SuccessivePrimeDifferences {
 
    public static void Main() {
        var primes = GeneratePrimes(1_000_000).ToList();
        foreach (var d in new[] {
            new [] { 2 },
            new [] { 1 },
            new [] { 2, 2 },
            new [] { 2, 4 },
            new [] { 4, 2 },
            new [] { 6, 4, 2 },
        }) {
            IEnumerable<int> first = null, last = null;
            int count = 0;
            foreach (var grp in FindDifferenceGroups(d)) {
                if (first == null) first = grp;
                last = grp;
                count++;
            }
            Console.WriteLine($""{$""({string.Join("", "", first)})""}, {$""({string.Join("", "", last)})""}, {count}"");
        }
 
        IEnumerable<IEnumerable<int>> FindDifferenceGroups(int[] diffs) {
            for (int pi = diffs.Length; pi < primes.Count; pi++)
                if (Range(0, diffs.Length).All(di => primes[pi-diffs.Length+di+1] - primes[pi-diffs.Length+di] == diffs[di]))
                    yield return Range(pi - diffs.Length, diffs.Length + 1).Select(i => primes[i]);
        }
 
        IEnumerable<int> GeneratePrimes(int lmt) {
            bool[] comps = new bool[lmt + 1];
            comps[0] = comps[1] = true;
            yield return 2; yield return 3;
            for (int j = 4; j <= lmt; j += 2) comps[j] = true;
            for (int j = 9; j <= lmt; j += 6) comps[j] = true;
            int i = 5, d = 4, rt = (int)Math.Sqrt(lmt);
            for ( ; i <= rt; i += (d = 6 - d))
                if (!comps[i]) {
                    yield return i;
                    for (int j = i * i, k = i << 1; j <= lmt; j += k)
                        comps[j] = true;
                }
            for ( ; i <= lmt; i += (d = 6 - d)) if (!comps[i]) yield return i;
        }
    }
}",1907,49
10390,http://rosettacode.org/wiki/Strong_and_weak_primes,Strong and weak primes,"

Definitions   (as per number theory)

   The   prime(p)   is the    pth   prime.
   prime(1)   is   2
   prime(4)   is   7
   A    strong   prime   is when     prime(p)   is   >   [prime(p-1) + prime(p+1)] ÷ 2
   A     weak    prime   is when     prime(p)   is   <   [prime(p-1) + prime(p+1)] ÷ 2


Note that the definition for   strong primes   is different when used in the context of   cryptography.



Task

   Find and display (on one line) the first   36   strong primes.
   Find and display the   count   of the strong primes below   1,000,000.
   Find and display the   count   of the strong primes below 10,000,000.
   Find and display (on one line) the first   37   weak primes.
   Find and display the   count   of the weak primes below   1,000,000.
   Find and display the   count   of the weak primes below 10,000,000.
   (Optional)   display the   counts   and   ""below numbers""   with commas.
Show all output here.



Related Task

   Safe primes and unsafe primes.


Also see

   The OEIS article A051634: strong primes.
   The OEIS article A051635: weak primes.

",#C.23,C#,"using static System.Console;
using static System.Linq.Enumerable;
using System;
 
public static class StrongAndWeakPrimes
{
    public static void Main() {
        var primes = PrimeGenerator(10_000_100).ToList();
        var strongPrimes = from i in Range(1, primes.Count - 2) where primes[i] > (primes[i-1] + primes[i+1]) / 2 select primes[i];
        var weakPrimes = from i in Range(1, primes.Count - 2) where primes[i] < (primes[i-1] + primes[i+1]) / 2.0 select primes[i];
        WriteLine($""First 36 strong primes: {string.Join("", "", strongPrimes.Take(36))}"");
        WriteLine($""There are {strongPrimes.TakeWhile(p => p < 1_000_000).Count():N0} strong primes below {1_000_000:N0}"");
        WriteLine($""There are {strongPrimes.TakeWhile(p => p < 10_000_000).Count():N0} strong primes below {10_000_000:N0}"");
        WriteLine($""First 37 weak primes: {string.Join("", "", weakPrimes.Take(37))}"");
        WriteLine($""There are {weakPrimes.TakeWhile(p => p < 1_000_000).Count():N0} weak primes below {1_000_000:N0}"");
        WriteLine($""There are {weakPrimes.TakeWhile(p => p < 10_000_000).Count():N0} weak primes below {1_000_000:N0}"");
    }
 
}",1154,19
10499,http://rosettacode.org/wiki/Substring/Top_and_tail,Substring/Top and tail,"The task is to demonstrate how to remove the first and last characters from a string.

The solution should demonstrate how to obtain the following results:

 String with first character removed
 String with last character removed
 String with both the first and last characters removed


If the program uses UTF-8 or UTF-16, it must work on any valid Unicode code point, whether in the Basic Multilingual Plane or above it.

The program must reference logical characters (code points), not 8-bit code units for UTF-8 or 16-bit code units for UTF-16.

Programs for other encodings (such as 8-bit ASCII, or EUC-JP) are not required to handle all Unicode characters.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#," 
using System;
 
class Program
{
    static void Main(string[] args)
    {
        string testString = ""test"";
        Console.WriteLine(testString.Substring(1));
        Console.WriteLine(testString.Substring(0, testString.Length - 1));
        Console.WriteLine(testString.Substring(1, testString.Length - 2));
    }
}
 ",323,14
10520,http://rosettacode.org/wiki/Sudoku,Sudoku,"Task

Solve a partially filled-in normal   9x9   Sudoku grid   and display the result in a human-readable format.

references

 Algorithmics of Sudoku   may help implement this.
 Python Sudoku Solver Computerphile video.

",#C.23,C#,"using System;
 
class SudokuSolver
{
    private int[] grid;
 
    public SudokuSolver(String s)
    {
        grid = new int[81];
        for (int i = 0; i < s.Length; i++)
        {
            grid[i] = int.Parse(s[i].ToString());
        }
    }
 
    public void solve()
    {
        try
        {
            placeNumber(0);
            Console.WriteLine(""Unsolvable!"");
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            Console.WriteLine(this);
        }
    }
 
    public void placeNumber(int pos)
    {
        if (pos == 81)
        {
            throw new Exception(""Finished!"");
        }
        if (grid[pos] > 0)
        {
            placeNumber(pos + 1);
            return;
        }
        for (int n = 1; n <= 9; n++)
        {
            if (checkValidity(n, pos % 9, pos / 9))
            {
                grid[pos] = n;
                placeNumber(pos + 1);
                grid[pos] = 0;
            }
        }
    }
 
    public bool checkValidity(int val, int x, int y)
    {
        for (int i = 0; i < 9; i++)
        {
            if (grid[y * 9 + i] == val || grid[i * 9 + x] == val)
                return false;
        }
        int startX = (x / 3) * 3;
        int startY = (y / 3) * 3;
        for (int i = startY; i < startY + 3; i++)
        {
            for (int j = startX; j < startX + 3; j++)
            {
                if (grid[i * 9 + j] == val)
                    return false;
            }
        }
        return true;
    }
 
    public override string ToString()
    {
        string sb = """";
        for (int i = 0; i < 9; i++)
        {
            for (int j = 0; j < 9; j++)
            {
                sb += (grid[i * 9 + j] + "" "");
                if (j == 2 || j == 5)
                    sb += (""| "");
            }
            sb += ('\n');
            if (i == 2 || i == 5)
                sb += (""------+-------+------\n"");
        }
        return sb;
    }
 
    public static void Main(String[] args)
    {
        new SudokuSolver(""850002400"" +
                         ""720000009"" +
                         ""004000000"" +
                         ""000107002"" +
                         ""305000900"" +
                         ""040000000"" +
                         ""000080070"" +
                         ""017000000"" +
                         ""000036040"").solve();
        Console.Read();
    }
}",2429,103
10531,http://rosettacode.org/wiki/Strip_block_comments,Strip block comments,"A block comment begins with a   beginning delimiter   and ends with a   ending delimiter,   including the delimiters.   These delimiters are often multi-character sequences.



Task

Strip block comments from program text (of a programming language much like classic C).

Your demos should at least handle simple, non-nested and multi-line block comment delimiters.

The block comment delimiters are the two-character sequences:

      /*      (beginning delimiter)
      */      (ending delimiter)


Sample text for stripping:

  /**
   * Some comments
   * longer comments here that we can parse.
   *
   * Rahoo 
   */
   function subroutine() {
    a = /* inline comment */ b + c ;
   }
   /*/ <-- tricky comments */

   /**
    * Another comment.
    */
    function something() {
    }

Extra credit

Ensure that the stripping code is not hard-coded to the particular delimiters described above, but instead allows the caller to specify them.   (If your language supports them,   optional parameters   may be useful for this.)




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
 
    class Program
    {
        private static string BlockCommentStrip(string commentStart, string commentEnd, string sampleText)
        {
            while (sampleText.IndexOf(commentStart) > -1 && sampleText.IndexOf(commentEnd, sampleText.IndexOf(commentStart) + commentStart.Length) > -1)
            {
                int start = sampleText.IndexOf(commentStart);
                int end = sampleText.IndexOf(commentEnd, start + commentStart.Length);
                sampleText = sampleText.Remove(
                    start,
                    (end + commentEnd.Length) - start
                    );
            }
            return sampleText;
        }
    }",685,18
10552,http://rosettacode.org/wiki/Subleq,Subleq,"Subleq is an example of a One-Instruction Set Computer (OISC).

It is named after its only instruction, which is SUbtract and Branch if Less than or EQual to zero.

Task
Your task is to create an interpreter which emulates a SUBLEQ machine.

The machine's memory consists of an array of signed integers.   These integers may be interpreted in three ways:

   simple numeric values 
   memory addresses 
   characters for input or output
Any reasonable word size that accommodates all three of the above uses is fine.

The program should load the initial contents of the emulated machine's memory, set the instruction pointer to the first address (which is defined to be address 0), and begin emulating the machine, which works as follows:

   Let A be the value in the memory location identified by the instruction pointer;   let B and C be the values stored in the next two consecutive addresses in memory.
   Advance the instruction pointer three words, to point at the address after the address containing C.
   If A is   -1   (negative unity),   then a character is read from the machine's input and its numeric value stored in the address given by B.   C is unused.
   If B is   -1   (negative unity),   then the number contained in the address given by A is interpreted as a character and written to the machine's output.   C is unused.
   Otherwise, both A and B are treated as addresses.   The number contained in address A is subtracted from the number in address B (and the difference left in address B).   If the result is positive, execution continues uninterrupted; if the result is zero or negative, the number in C becomes the new instruction pointer.
   If the instruction pointer becomes negative, execution halts.
Your solution may initialize the emulated machine's memory in any convenient manner, but if you accept it as input, it should be a separate input stream from the one fed to the emulated machine once it is running. And if fed as text input, it should be in the form of raw subleq ""machine code"" - whitespace-separated decimal numbers, with no symbolic names or other assembly-level extensions, to be loaded into memory starting at address   0   (zero).

For purposes of this task, show the output of your solution when fed the below   ""Hello, world!""   program.

As written, this example assumes ASCII or a superset of it, such as any of the Latin-N character sets or Unicode;   you may translate the numbers representing characters (starting with 72=ASCII 'H') into another character set if your implementation runs in a non-ASCII-compatible environment. If 0 is not an appropriate terminator in your character set, the program logic will need some adjustment as well.

15 17 -1 17 -1 -1 16 1 -1 16 3 -1 15 15 0 0 -1 72 101 108 108 111 44 32 119 111 114 108 100 33 10 0
The above ""machine code"" corresponds to something like this in a hypothetical assembler language for a signed 8-bit version of the machine:

start:
    0f 11 ff subleq (zero), (message), -1
    11 ff ff subleq (message), -1, -1    ; output character at message
    10 01 ff subleq (neg1), (start+1), -1
    10 03 ff subleq (neg1), (start+3), -1
    0f 0f 00 subleq (zero), (zero), start
; useful constants
zero: 
    00      .data 0  
neg1: 
    ff      .data -1
; the message to print
message: .data ""Hello, world!\n\0""
    48 65 6c 6c 6f 2c 20 77 6f 72 6c 64 21 0a 00

",#C.23,C#,"using System;
 
namespace Subleq {
    class Program {
        static void Main(string[] args) {
            int[] mem = {
                15, 17, -1, 17, -1, -1, 16, 1, -1, 16,
                3, -1, 15, 15, 0, 0, -1, 72, 101, 108,
                108, 111, 44, 32, 119, 111, 114, 108, 100, 33,
                10, 0,
            };
 
            int instructionPointer = 0;
 
            do {
                int a = mem[instructionPointer];
                int b = mem[instructionPointer + 1];
 
                if (a == -1) {
                    mem[b] = Console.Read();
                }
                else if (b == -1) {
                    Console.Write((char)mem[a]);
                }
                else {
                    mem[b] -= mem[a];
                    if (mem[b] < 1) {
                        instructionPointer = mem[instructionPointer + 2];
                        continue;
                    }
                }
 
                instructionPointer += 3;
            } while (instructionPointer >= 0);
        }
    }
}",1050,37
10637,http://rosettacode.org/wiki/String_prepend,String prepend,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Create a string variable equal to any text value.

Prepend the string variable with another string literal.

If your language supports any idiomatic ways to do this without referring to the variable twice in one expression, include such solutions.



To illustrate the operation, show the content of the variable.



",#C.23,C#,"using System;
 
namespace PrependString
{
    class Program
    {
        static void Main(string[] args)
        {
            string str = ""World"";
            str = ""Hello "" + str;
            Console.WriteLine(str);
            Console.ReadKey();
        }
    }
}",268,15
10645,http://rosettacode.org/wiki/Strip_control_codes_and_extended_characters_from_a_string,Strip control codes and extended characters from a string,"Task

Strip control codes and extended characters from a string.



The solution should demonstrate how to achieve each of the following results:

   a string with control codes stripped (but extended characters not stripped)
   a string with control codes and extended characters stripped


In ASCII, the control codes have decimal codes 0 through to 31 and 127.

On an ASCII based system, if the control codes are stripped, the resultant string would have all of its characters within the range of 32 to 126 decimal on the ASCII table.

On a non-ASCII based system, we consider characters that do not have a corresponding glyph on the ASCII table (within the ASCII range of 32 to 126 decimal) to be an extended character for the purpose of this task.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms  (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#," 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace RosettaCode
{
    class Program
    {
        static void Main(string[] args)
        {
            string test = ""string of ☺☻♥♦⌂, may include control characters and other ilk.♫☼§►↔◄"";
            Console.WriteLine(""Original: {0}"", test);
            Console.WriteLine(""Stripped of control codes: {0}"", StripControlChars(test));
            Console.WriteLine(""Stripped of extended: {0}"", StripExtended(test));
        }
 
        static string StripControlChars(string arg)
        {
            char[] arrForm = arg.ToCharArray();
            StringBuilder buffer = new StringBuilder(arg.Length);//This many chars at most
 
            foreach(char ch in arrForm)
                if (!Char.IsControl(ch)) buffer.Append(ch);//Only add to buffer if not a control char
 
            return buffer.ToString();
        }
 
        static string StripExtended(string arg)
        {
            StringBuilder buffer = new StringBuilder(arg.Length); //Max length
            foreach(char ch in arg)
            {
                UInt16 num = Convert.ToUInt16(ch);//In .NET, chars are UTF-16
                //The basic characters have the same code points as ASCII, and the extended characters are bigger
                if((num >= 32u) && (num <= 126u)) buffer.Append(ch);
            }
            return buffer.ToString();
        }
    }
}
 ",1469,44
10652,http://rosettacode.org/wiki/Strip_whitespace_from_a_string/Top_and_tail,Strip whitespace from a string/Top and tail,"Task

Demonstrate how to strip leading and trailing whitespace from a string.

The solution should demonstrate how to achieve the following three results:

 String with leading whitespace removed
 String with trailing whitespace removed
 String with both leading and trailing whitespace removed


For the purposes of this task whitespace includes non printable characters such as the space character, the tab character, and other such characters that have no corresponding graphical representation.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
 
public class TrimExample
{
    public static void Main(String[] args)
    {
        const string toTrim = "" Trim me "";
        Console.WriteLine(Wrap(toTrim.TrimStart()));
        Console.WriteLine(Wrap(toTrim.TrimEnd()));
        Console.WriteLine(Wrap(toTrim.Trim()));
    }
 
    private static string Wrap(string s)
    {
        return ""'"" + s + ""'"";
    }
}",379,17
10668,http://rosettacode.org/wiki/Strip_comments_from_a_string,Strip comments from a string,"Strip comments from a string

You are encouraged to solve this task according to the task description, using any language you may know.
The task is to remove text that follow any of a set of comment markers, (in these examples either a hash or a semicolon) from a string or input line.


Whitespace debacle:   There is some confusion about whether to remove any whitespace from the input line.

As of 2 September 2011, at least 8 languages (C, C++, Java, Perl, Python, Ruby, sed, UNIX Shell) were incorrect, out of 36 total languages, because they did not trim whitespace by 29 March 2011 rules. Some other languages might be incorrect for the same reason.

Please discuss this issue at Talk:Strip comments from a string.

 From 29 March 2011, this task required that: ""The comment marker and any whitespace at the beginning or ends of the resultant line should be removed. A line without comments should be trimmed of any leading or trailing whitespace before being produced as a result."" The task had 28 languages, which did not all meet this new requirement.
 From 28 March 2011, this task required that: ""Whitespace before the comment marker should be removed.""
 From 30 October 2010, this task did not specify whether or not to remove whitespace.


The following examples will be truncated to either ""apples, pears "" or ""apples, pears"".

(This example has flipped between ""apples, pears "" and ""apples, pears"" in the past.)

apples, pears # and bananas
apples, pears ; and bananas




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#," 
using System.Text.RegularExpressions;
 
string RemoveComments(string str, string delimiter)
        {
            //regular expression to find a character (delimiter) and 
            //      replace it and everything following it with an empty string.
            //.Trim() will remove all beginning and ending white space.
            return Regex.Replace(str, delimiter + "".+"", string.Empty).Trim();
        }
 ",416,11
10769,http://rosettacode.org/wiki/Substring,Substring,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses




Task

Display a substring:

   starting from   n   characters in and of   m   length;
   starting from   n   characters in,   up to the end of the string;
   whole string minus the last character;
   starting from a known   character   within the string and of   m   length;
   starting from a known   substring   within the string and of   m   length.


If the program uses UTF-8 or UTF-16,   it must work on any valid Unicode code point,
whether in the   Basic Multilingual Plane   or above it.

The program must reference logical characters (code points),   not 8-bit code units for UTF-8 or 16-bit code units for UTF-16.

Programs for other encodings (such as 8-bit ASCII, or EUC-JP) are not required to handle all Unicode characters.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
namespace SubString
{
    class Program
    {
        static void Main(string[] args)
        {
            string s = ""0123456789"";
            const int n = 3;
            const int m = 2;
            const char c = '3';
            const string z = ""345"";
 
            // A: starting from n characters in and of m length;
            Console.WriteLine(s.Substring(n, m));
            // B: starting from n characters in, up to the end of the string;
            Console.WriteLine(s.Substring(n, s.Length - n));
            // C: whole string minus the last character;
            Console.WriteLine(s.Substring(0, s.Length - 1));
            // D: starting from a known character within the string and of m length;
            Console.WriteLine(s.Substring(s.IndexOf(c), m));
            // E: starting from a known substring within the string and of m length.
            Console.WriteLine(s.Substring(s.IndexOf(z), m));
        }
    }
}",956,26
10895,http://rosettacode.org/wiki/Strip_a_set_of_characters_from_a_string,Strip a set of characters from a string,"Task

Create a function that strips a set of characters from a string.



The function should take two arguments:

   a string to be stripped 
   a string containing the set of characters to be stripped


The returned string should contain the first string, stripped of any characters in the second argument:

 print stripchars(""She was a soul stripper. She took my heart!"",""aei"")
Sh ws  soul strppr. Sh took my hrt!



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
 
public static string RemoveCharactersFromString(string testString, string removeChars)
{
    char[] charAry = removeChars.ToCharArray();
    string returnString = testString;
    foreach (char c in charAry)
    {
        while (returnString.IndexOf(c) > -1)
        {
            returnString = returnString.Remove(returnString.IndexOf(c), 1);
        }
    }
    return returnString;
}",402,15
10971,http://rosettacode.org/wiki/String_interpolation_(included),String interpolation (included),"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Given a string and defined variables or values, string interpolation is the replacement of defined character sequences in the string by values or variable values.

 For example, given an original string of ""Mary had a X lamb."", a value of ""big"", and if the language replaces X in its interpolation routine, then the result of its interpolation would be the string ""Mary had a big lamb"".
(Languages usually include an infrequently used character or sequence of characters to indicate what is to be replaced such as ""%"", or ""#"" rather than ""X"").


Task

 Use your languages inbuilt string interpolation abilities to interpolate a string missing the text ""little"" which is held in a variable, to produce the output string ""Mary had a little lamb"".
 If possible, give links to further documentation on your languages string interpolation features.

Note: The task is not to create a string interpolation routine, but to show a language's built-in capability.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"class Program
{
    static void Main()
    {
        string extra = ""little"";
        string formatted = $""Mary had a {extra} lamb."";
        System.Console.WriteLine(formatted);
    }
}",186,9
10986,http://rosettacode.org/wiki/String_concatenation,String concatenation,"String concatenation

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a string variable equal to any text value.

Create another string variable whose value is the original variable concatenated with another string literal.

To illustrate the operation, show the content of the variables.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
 
class Program {
    static void Main(string[] args) {
        var s = ""hello"";
        Console.Write(s);
        Console.WriteLine("" literal"");
        var s2 = s + "" literal"";
        Console.WriteLine(s2);
    }
}",231,11
11117,http://rosettacode.org/wiki/String_matching,String matching,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Given two strings, demonstrate the following three types of string matching:

   Determining if the first string starts with second string
   Determining if the first string contains the second string at any location
   Determining if the first string ends with the second string


Optional requirements:

   Print the location of the match for part 2
   Handle multiple occurrences of a string for part 2.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#," 
class Program
{
	public static void Main (string[] args)
	{
		var value = ""abcd"".StartsWith(""ab"");
		value = ""abcd"".EndsWith(""zn""); //returns false
		value = ""abab"".Contains(""bb""); //returns false
		value = ""abab"".Contains(""ab""); //returns true
		int loc = ""abab"".IndexOf(""bb""); //returns -1
		loc = ""abab"".IndexOf(""ab""); //returns 0
		loc = ""abab"".IndexOf(""ab"",loc+1); //returns 2
	}
}
 ",390,15
11220,http://rosettacode.org/wiki/String_case,String case,"Task

Take the string     alphaBETA     and demonstrate how to convert it to:

   upper-case     and 
   lower-case


Use the default encoding of a string literal or plain ASCII if there is no string literal in your language.

Note: In some languages alphabets toLower and toUpper is not reversable.

Show any additional case conversion functions   (e.g. swapping case, capitalizing the first letter, etc.)   that may be included in the library of your language.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#," 
class Program
{
    static void Main(string[] args)
    {
        string input;
        Console.Write(""Enter a series of letters: "");
        input = Console.ReadLine();
        stringCase(input);
    }
 
    private static void stringCase(string str)
    {
        char[] chars = str.ToCharArray();
        string newStr = """";
 
        foreach (char i in chars)
            if (char.IsLower(i))
                newStr += char.ToUpper(i);
            else
                newStr += char.ToLower(i);
        Console.WriteLine(""Converted: {0}"", newStr);
    }
}",562,24
11261,http://rosettacode.org/wiki/String_length,String length,"Task

Find the character and byte length of a string.

This means encodings like UTF-8 need to be handled properly, as there is not necessarily a one-to-one relationship between bytes and characters.

By character, we mean an individual Unicode code point, not a user-visible grapheme containing combining characters.

For example, the character length of ""møøse"" is 5 but the byte length is 7 in UTF-8 and 10 in UTF-16.

Non-BMP code points (those between 0x10000 and 0x10FFFF) must also be handled correctly: answers should produce actual character counts in code points, not in code unit counts.

Therefore a string like ""𝔘𝔫𝔦𝔠𝔬𝔡𝔢"" (consisting of the 7 Unicode characters U+1D518 U+1D52B U+1D526 U+1D520 U+1D52C U+1D521 U+1D522) is 7 characters long, not 14 UTF-16 code units; and it is 28 bytes long whether encoded in UTF-8 or in UTF-16.

Please mark your examples with ===Character Length=== or ===Byte Length===.

If your language is capable of providing the string length in graphemes, mark those examples with ===Grapheme Length===.

For example, the string ""J̲o̲s̲é̲"" (""J\x{332}o\x{332}s\x{332}e\x{301}\x{332}"") has 4 user-visible graphemes, 9 characters (code points), and 14 bytes when encoded in UTF-8.





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"string s = ""Hello, world!"";
int characterLength = s.Length;",59,2
12871,http://rosettacode.org/wiki/String_append,String append,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Most languages provide a way to concatenate two string values, but some languages also provide a convenient way to append in-place to an existing string variable without referring to the variable twice.



Task

Create a string variable equal to any text value.

Append the string variable with another string literal in the most idiomatic way, without double reference if your language supports it.

Show the contents of the variable after the append operation.



",#C.23,C#,"class Program
{
    static void Main(string[] args)
    {
        string x = ""foo"";
        x += ""bar"";
        System.Console.WriteLine(x);
    }
}",148,9
12875,http://rosettacode.org/wiki/Straddling_checkerboard,Straddling checkerboard,"Task

Implement functions to encrypt and decrypt a message using the straddling checkerboard method. The checkerboard should take a 28 character alphabet (A-Z plus a full stop and an escape character) and two different numbers representing the blanks in the first row. The output will be a series of decimal digits.

Numbers should be encrypted by inserting the escape character before each digit, then including the digit unencrypted. This should be reversed for decryption.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
 
namespace StraddlingCheckerboard
{
    class Program
    {
        public readonly static IReadOnlyDictionary<char, string> val2Key;
        public readonly static IReadOnlyDictionary<string, char> key2Val;
 
        static Program()
        {
            val2Key = new Dictionary<char, string> {
                {'A',""30""},  {'B',""31""}, {'C',""32""},  {'D',""33""},  {'E',""5""},   {'F',""34""},  {'G',""35""},
                {'H',""0""},   {'I',""36""}, {'J',""37""},  {'K',""38""},  {'L',""2""},   {'M',""4""},   {'.',""78""},
                {'N',""39""},  {'/',""79""}, {'O',""1""},   {'0',""790""}, {'P',""70""},  {'1',""791""}, {'Q',""71""},
                {'2',""792""}, {'R',""8""},  {'3',""793""}, {'S',""6""},   {'4',""794""}, {'T',""9""},   {'5',""795""},
                {'U',""72""},  {'6',""796""},{'V',""73""},  {'7',""797""}, {'W',""74""},  {'8',""798""}, {'X',""75""},
                {'9',""799""}, {'Y',""76""}, {'Z',""77""}};
 
            key2Val = val2Key.ToDictionary(kv => kv.Value, kv => kv.Key);
        }
 
        public static string Encode(string s)
        {
            return string.Concat(s.ToUpper().ToCharArray()
                .Where(c => val2Key.ContainsKey(c)).Select(c => val2Key[c]));
        }
 
        public static string Decode(string s)
        {
            return string.Concat(Regex.Matches(s, ""79.|7.|3.|."").Cast<Match>()
                .Where(m => key2Val.ContainsKey(m.Value)).Select(m => key2Val[m.Value]));
        }
 
        static void Main(string[] args)
        {
            var enc = Encode(""One night-it was on the twentieth of March, 1888-I was returning"");
            Console.WriteLine(enc);
            Console.WriteLine(Decode(enc));
 
            Console.ReadLine();
        }
    }
}",1793,47
12905,http://rosettacode.org/wiki/Stream_merge,Stream merge," 2-stream merge
 Read two sorted streams of items from external source (e.g. disk, or network), and write one stream of sorted items to external sink.
 Common algorithm: keep 1 buffered item from each source, select minimal of them, write it, fetch another item from that stream from which the written item was.
 N-stream merge
 The same as above, but reading from    N    sources.
 Common algorithm: same as above, but keep buffered items and their source descriptors in a heap.


Assume streams are very big. You must not suck them whole in the memory, but read them as streams.



",#C.23,C#," 
using System;
using System.Collections.Generic;
using System.Linq;
 
namespace RosettaCode
{
    static class StreamMerge
    {
        static IEnumerable<T> Merge2<T>(IEnumerable<T> source1, IEnumerable<T> source2) where T : IComparable
        {
            var q1 = new Queue<T>(source1);
            var q2 = new Queue<T>(source2);
            while (q1.Any() && q2.Any())
            {
                var c = q1.Peek().CompareTo(q2.Peek());
                if (c <= 0) yield return q1.Dequeue(); else yield return q2.Dequeue();
            }
            while (q1.Any()) yield return q1.Dequeue();
            while (q2.Any()) yield return q2.Dequeue();
        }
 
        static IEnumerable<T> MergeN<T>(params IEnumerable<T>[] sources) where T : IComparable
        {
            var queues = sources.Select(e => new Queue<T>(e)).Where(q => q.Any()).ToList();
            var headComparer = Comparer<Queue<T>>.Create((x, y) => x.Peek().CompareTo(y.Peek()));
            queues.Sort(headComparer);
 
            while (queues.Any())
            {
                var q = queues.First();
                queues.RemoveAt(0);
                yield return q.Dequeue();
                if (q.Any())
                {
                    var index = queues.BinarySearch(q, headComparer);
                    queues.Insert(index < 0 ? ~index : index, q);
                }
            }
        }
 
        static void Main()
        {
            var a = new[] { 1, 4, 7, 10 };
            var b = new[] { 2, 5, 8, 11 };
            var c = new[] { 3, 6, 9, 12 };
 
            foreach (var i in Merge2(a, b)) Console.Write($""{i} "");
            Console.WriteLine();
 
            foreach (var i in MergeN(a, b, c)) Console.Write($""{i} "");
            Console.WriteLine();
        }
    }
}",1794,55
12954,http://rosettacode.org/wiki/Statistics/Normal_distribution,Statistics/Normal distribution,"The Normal (or Gaussian) distribution is a frequently used distribution in statistics. While most programming languages provide a uniformly distributed random number generator, one can derive normally distributed random numbers from a uniform generator.



The task

 Take a uniform random number generator and create a large (you decide how large) set of numbers that follow a normal (Gaussian) distribution. Calculate the dataset's mean and standard deviation, and show a histogram of the data.
 Mention any native language support for the generation of normally distributed random numbers.


Reference

 You may refer to code in Statistics/Basic if available.

",#C.23,C#,"using System;
using MathNet.Numerics.Distributions;
using MathNet.Numerics.Statistics;
 
class Program
{
    static void RunNormal(int sampleSize)
    {
        double[] X = new double[sampleSize];
        var norm = new Normal(new Random());
        norm.Samples(X);
 
        const int numBuckets = 10;
        var histogram = new Histogram(X, numBuckets);
        Console.WriteLine(""Sample size: {0:N0}"", sampleSize);
        for (int i = 0; i < numBuckets; i++)
        {
            string bar = new String('#', (int)(histogram[i].Count * 360 / sampleSize));
            Console.WriteLine("" {0:0.00} : {1}"", histogram[i].LowerBound, bar);
        }
        var statistics = new DescriptiveStatistics(X);
        Console.WriteLine(""  Mean: "" + statistics.Mean);
        Console.WriteLine(""StdDev: "" + statistics.StandardDeviation);
        Console.WriteLine();
    }
    static void Main(string[] args)
    {
        RunNormal(100);
        RunNormal(1000);
        RunNormal(10000);
    }
}",995,32
13011,http://rosettacode.org/wiki/Stem-and-leaf_plot,Stem-and-leaf plot,"Create a well-formatted stem-and-leaf plot from the following data set, where the leaves are the last digits:

12 127 28 42 39 113 42 18 44 118 44 37 113 124 37 48 127 36 29 31 125 139 131 115 105 132 104 123 35 113 122 42 117 119 58 109 23 105 63 27 44 105 99 41 128 121 116 125 32 61 37 127 29 113 121 58 114 126 53 114 96 25 109 7 31 141 46 13 27 43 117 116 27 7 68 40 31 115 124 42 128 52 71 118 117 38 27 106 33  117 116 111 40 119 47 105 57 122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34 133 45 120 30 127 31 116 146
The primary intent of this task is the presentation of information. It is acceptable to hardcode the data set or characteristics of it (such as what the stems are) in the example, insofar as it is impractical to make the example generic to any data set. For example, in a computation-less language like HTML the data set may be entirely prearranged within the example; the interesting characteristics are how the proper visual formatting is arranged.

If possible, the output should not be a bitmap image. Monospaced plain text is acceptable, but do better if you can. It may be a window, i.e. not a file.


Note: If you wish to try multiple data sets, you might try this generator.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
class Program
{
    static void Main()
    {
        const string data =
        ""12 127 28 42 39 113 42 18 44 118 44 37 113 124 37 48 127 36 29 31 "" +
        ""125 139 131 115 105 132 104 123 35 113 122 42 117 119 58 109 23 "" +
        ""105 63 27 44 105 99 41 128 121 116 125 32 61 37 127 29 113 121 58 "" +
        ""114 126 53 114 96 25 109 7 31 141 46 13 27 43 117 116 27 7 68 40 31 "" +
        ""115 124 42 128 52 71 118 117 38 27 106 33 117 116 111 40 119 47 "" +
        ""105 57 122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34 "" +
        ""133 45 120 30 127 31 116 146"";
 
        int[] ints = data.Split(' ').Select(int.Parse).ToArray();
 
        StemAndLeafPlot(ints);
 
        Console.ReadKey();
    }
 
    public static void StemAndLeafPlot(int[] arr)
    {
        int stemMax = arr.Max() / 10;
        int stemMin = arr.Min() / 10;
        Array.Sort(arr);
 
        for (int i = stemMin; i <= stemMax; i++)
        {
            Console.Write(""{0,3} | "", i);
            foreach (var t in arr)
            {
                if (t < 10 * i)
                    continue;
                if (t >= 10 * (i + 1))
                    break;
                Console.Write(""{0} "", t % 10);
            }
            Console.WriteLine("""");
        }
    }
}",1388,47
13097,http://rosettacode.org/wiki/Stern-Brocot_sequence,Stern-Brocot sequence,"For this task, the Stern-Brocot sequence is to be generated by an algorithm similar to that employed in generating the Fibonacci sequence.

 The first and second members of the sequence are both 1:
     1, 1
 Start by considering the second member of the sequence
 Sum the considered member of the sequence and its precedent, (1 + 1) = 2, and append it to the end of the sequence:
     1, 1, 2
 Append the considered member of the sequence to the end of the sequence:
     1, 1, 2, 1
 Consider the next member of the series, (the third member i.e. 2)
 GOTO 3
 
         ─── Expanding another loop we get: ───

 Sum the considered member of the sequence and its precedent, (2 + 1) = 3, and append it to the end of the sequence:
     1, 1, 2, 1, 3
 Append the considered member of the sequence to the end of the sequence:
     1, 1, 2, 1, 3, 2
 Consider the next member of the series, (the fourth member i.e. 1)


The task is to

 Create a function/method/subroutine/procedure/... to generate the Stern-Brocot sequence of integers using the method outlined above.
 Show the first fifteen members of the sequence. (This should be: 1, 1, 2, 1, 3, 2, 3, 1, 4, 3, 5, 2, 5, 3, 4)
 Show the (1-based) index of where the numbers 1-to-10 first appears in the sequence.
 Show the (1-based) index of where the number 100 first appears in the sequence.
 Check that the greatest common divisor of all the two consecutive members of the series up to the 1000th member, is always one.

Show your output on this page.



Related tasks

   Fusc sequence.
   Continued fraction/Arithmetic


Ref

 Infinite Fractions - Numberphile (Video).
 Trees, Teeth, and Time: The mathematics of clock making. 
 A002487 The On-Line Encyclopedia of Integer Sequences.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
static class Program {
    static List<int> l = new List<int>() { 1, 1 };
 
    static int gcd(int a, int b) {
        return a > 0 ? a < b ? gcd(b % a, a) : gcd(a % b, b) : b; }
 
    static void Main(string[] args) {
        int max = 1000; int take = 15; int i = 1;
        int[] selection = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100 };
        do { l.AddRange(new List<int>() { l[i] + l[i - 1], l[i] }); i += 1; }
        while (l.Count < max || l[l.Count - 2] != selection.Last());
        Console.Write(""The first {0} items In the Stern-Brocot sequence: "", take);
        Console.WriteLine(""{0}\n"", string.Join("", "", l.Take(take)));
        Console.WriteLine(""The locations of where the selected numbers (1-to-10, & 100) first appear:"");
        foreach (int ii in selection) {
            int j = l.FindIndex(x => x == ii) + 1; Console.WriteLine(""{0,3}: {1:n0}"", ii, j); }
        Console.WriteLine(); bool good = true;
        for (i = 1; i <= max; i++) { if (gcd(l[i], l[i - 1]) != 1) { good = false; break; } }
        Console.WriteLine(""The greatest common divisor of all the two consecutive items of the"" + 
                          "" series up to the {0}th item is {1}always one."", max, good ? """" : ""not "");
    }
}",1299,26
13100,http://rosettacode.org/wiki/Stack_traces,Stack traces,"Many programming languages allow for introspection of the current call stack environment. This can be for a variety of purposes such as enforcing security checks, debugging, or for getting access to the stack frame of callers.



Task

Print out (in a manner considered suitable for the platform) the current call stack.

The amount of information printed for each frame on the call stack is not constrained, but should include at least the name of the function or method at that level of the stack frame.

You may explicitly add a call to produce the stack trace to the (example) code being instrumented for examination.

The task should allow the program to continue after generating the stack trace.

The task report here must include the trace from a sample program.



",#C.23,C#,"using System;
using System.Diagnostics;
 
class Program
{
    static void Inner()
    {
        Console.WriteLine(new StackTrace());
    }
 
    static void Middle()
    {
        Inner();
    }
 
    static void Outer()
    {
        Middle();
    }
 
    static void Main()
    {
        Outer();
    }
}",306,25
13156,http://rosettacode.org/wiki/Stair-climbing_puzzle,Stair-climbing puzzle,"From Chung-Chieh Shan (LtU):

Your stair-climbing robot has a very simple low-level API: the ""step"" function takes no argument and attempts to climb one step as a side effect. Unfortunately, sometimes the attempt fails and the robot clumsily falls one step instead. The ""step"" function detects what happens and returns a boolean flag: true on success, false on failure.

Write a function ""step_up"" that climbs one step up [from the initial position] (by repeating ""step"" attempts if necessary). Assume that the robot is not already at the top of the stairs, and neither does it ever reach the bottom of the stairs. How small can you make ""step_up""? Can you avoid using variables (even immutable ones) and numbers?

Here's a pseudo-code of a simple recursive solution without using variables:

func step_up()
{
    if not step() {
        step_up();
        step_up();
    }
}

Inductive proof that step_up() steps up one step, if it terminates:

 Base case (if the step() call returns true): it stepped up one step. QED
 Inductive case (if the step() call returns false): Assume that recursive calls to step_up() step up one step. It stepped down one step (because step() returned false), but now we step up two steps using two step_up() calls. QED


The second (tail) recursion above can be turned into an iteration, as follows:

func step_up()
{
    while not step() {
        step_up();
    }
}
",#C.23,C#,"void step_up() {
    while (!step()) step_up();
}",49,3
13303,http://rosettacode.org/wiki/Statistics/Basic,Statistics/Basic,"Statistics is all about large groups of numbers.
When talking about a set of sampled data, most frequently used is their mean value and standard deviation (stddev).
If you have set of data 




x

i




{\displaystyle x_{i}}

 where 



i
=
1
,
2
,
…
,
n




{\displaystyle i=1,2,\ldots ,n\,\!}

, the mean is 






x
¯



≡


1
n



∑

i



x

i




{\displaystyle {\bar {x}}\equiv {1 \over n}\sum _{i}x_{i}}

, while the stddev is 



σ
≡




1
n



∑

i




(

x

i


−



x
¯



)


2






{\displaystyle \sigma \equiv {\sqrt {{1 \over n}\sum _{i}\left(x_{i}-{\bar {x}}\right)^{2}}}}

.

When examining a large quantity of data, one often uses a histogram, which shows the counts of data samples falling into a prechosen set of intervals (or bins).
When plotted, often as bar graphs, it visually indicates how often each data value occurs.

Task Using your language's random number routine, generate real numbers in the range of [0, 1]. It doesn't matter if you chose to use open or closed range.
Create 100 of such numbers (i.e. sample size 100) and calculate their mean and stddev.
Do so for sample size of 1,000 and 10,000, maybe even higher if you feel like.
Show a histogram of any of these sets.
Do you notice some patterns about the standard deviation?

Extra Sometimes so much data need to be processed that it's impossible to keep all of them at once. Can you calculate the mean, stddev and histogram of a trillion numbers? (You don't really need to do a trillion numbers, just show how it can be done.)

Hint

For a finite population with equal probabilities at all points, one can derive:








(
x
−


x
¯



)

2



¯


=



x

2


¯


−



x
¯



2




{\displaystyle {\overline {(x-{\overline {x}})^{2}}}={\overline {x^{2}}}-{\overline {x}}^{2}}


Or, more verbosely:







1
N



∑

i
=
1


N


(

x

i


−


x
¯



)

2


=


1
N



(

∑

i
=
1


N



x

i


2


)

−



x
¯



2


.


{\displaystyle {\frac {1}{N}}\sum _{i=1}^{N}(x_{i}-{\overline {x}})^{2}={\frac {1}{N}}\left(\sum _{i=1}^{N}x_{i}^{2}\right)-{\overline {x}}^{2}.}


See also
 Statistics/Normal distribution
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",#C.23,C#,"using System;
using MathNet.Numerics.Statistics;
 
class Program
{
    static void Run(int sampleSize)
    {
        double[] X = new double[sampleSize];
        var r = new Random();
        for (int i = 0; i < sampleSize; i++)
            X[i] = r.NextDouble();
 
        const int numBuckets = 10;
        var histogram = new Histogram(X, numBuckets);
        Console.WriteLine(""Sample size: {0:N0}"", sampleSize);
        for (int i = 0; i < numBuckets; i++)
        {
            string bar = new String('#', (int)(histogram[i].Count * 360 / sampleSize));
            Console.WriteLine("" {0:0.00} : {1}"", histogram[i].LowerBound, bar);
        }
        var statistics = new DescriptiveStatistics(X);
        Console.WriteLine(""  Mean: "" + statistics.Mean);
        Console.WriteLine(""StdDev: "" + statistics.StandardDeviation);
        Console.WriteLine();
    }
    static void Main(string[] args)
    {
        Run(100);
        Run(1000);
        Run(10000);
    }
}",973,32
13386,http://rosettacode.org/wiki/SQL-based_authentication,SQL-based authentication,"This task has three parts:

 Connect to a MySQL database (connect_db)
 Create user/password records in the following table (create_user)
 Authenticate login requests against the table (authenticate_user)
This is the table definition:

CREATE TABLE users (
    userid INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(32) UNIQUE KEY NOT NULL,
    pass_salt tinyblob NOT NULL,
            -- a string of 16 random bytes
    pass_md5 tinyblob NOT NULL
            -- binary MD5 hash of pass_salt concatenated with the password
);
(pass_salt and pass_md5 would be binary(16) values, but MySQL versions before 5.0.15 strip trailing spaces when selecting them.)
",#C.23,C#,"using System.Security.Cryptography;
using System.Text;
 
namespace rosettaMySQL
{
    class Hasher
    {
        private static string _BytesToHex(byte[] input)
        {
            var strBuilder = new StringBuilder();
            foreach (byte _byte in input)
            {
                strBuilder.Append(_byte.ToString(""x2""));
            }
            return strBuilder.ToString();
        }
 
        public static string Hash(string salt, string input)
        {
            using (MD5 md5 = new MD5CryptoServiceProvider())
            {
                var bytes = Encoding.Default.GetBytes(salt + input);
                var data = md5.ComputeHash(bytes);
                return _BytesToHex(data);
            }
        }
 
        public static string GenSalt()
        {
            using (RandomNumberGenerator rng = new RNGCryptoServiceProvider())
            {
                var salt = new byte[16];
                rng.GetBytes(salt);
                return _BytesToHex(salt);
            }
        }
    }
}",1028,38
13458,http://rosettacode.org/wiki/Square_but_not_cube,Square but not cube,"Task

Show the first   30   positive integers which are squares but not cubes of such integers.

Optionally, show also the first   3   positive integers which are both squares and cubes,   and mark them as such.



",#C.23,C#,"using System;
using System.Collections.Generic;
using static System.Console;
using static System.Linq.Enumerable;
 
public static class SquareButNotCube
{
    public static void Main() {
        var squares = from i in Integers() select i * i;
        var cubes = from i in Integers() select i * i * i;
 
        foreach (var x in Merge().Take(33)) {
            WriteLine(x.isCube ? x.n + "" (also cube)"" : x.n + """");
        }
 
        IEnumerable<int> Integers() {
            for (int i = 1; ;i++) yield return i;
        }
 
        IEnumerable<(int n, bool isCube)> Merge() {
            using (var s = squares.GetEnumerator())
            using (var c = cubes.GetEnumerator()) {
                s.MoveNext();
                c.MoveNext();
                while (true) {
                    if (s.Current < c.Current) {
                        yield return (s.Current, false);
                        s.MoveNext();
                    } else if (s.Current == c.Current) {
                        yield return (s.Current, true);
                        s.MoveNext();
                        c.MoveNext();
                    } else {
                        c.MoveNext();
                    }
                }
            }
        }
 
    }
}",1250,41
13527,http://rosettacode.org/wiki/Speech_synthesis,Speech synthesis,"Render the text       This is an example of speech synthesis      as speech.



Related task

   using a speech engine to highlight words



",#C.23,C#,"using SpeechLib;
 
namespace Speaking_Computer
{
  public class Program
  {
    private static void Main()
    {
      var voice = new SpVoice();
      voice.Speak(""This is an example of speech synthesis."");
    }
  }
}",219,13
13596,http://rosettacode.org/wiki/Split_a_character_string_based_on_change_of_character,Split a character string based on change of character,"

Task

Split a (character) string into comma (plus a blank) delimited
strings based on a change of character   (left to right).

Show the output here   (use the 1st example below).



Blanks should be treated as any other character   (except
they are problematic to display clearly).   The same applies
to commas.



For instance, the string:

 gHHH5YY++///\ 

should be split and show:

 g, HHH, 5, YY, ++, ///, \ 




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.Linq;
using System.Collections.Generic;
 
public class Program
{
    string s = @""gHHH5YY++///\"";
    Console.WriteLine(s.RunLengthSplit().Delimit("", ""));
}
 
public static class Extensions
{
    public static IEnumerable<string> RunLengthSplit(this string source) {
        using (var enumerator = source.GetEnumerator()) {
            if (!enumerator.MoveNext()) yield break;
            char previous = enumerator.Current;
            int count = 1;
            while (enumerator.MoveNext()) {
                if (previous == enumerator.Current) {
                    count++;
                } else {
                    yield return new string(Enumerable.Repeat(previous, count).ToArray());
                    previous = enumerator.Current;
                    count = 1;
                }
            }
            yield return new string(Enumerable.Repeat(previous, count).ToArray());
        }
    }
 
    public static string Delimit<T>(this IEnumerable<T> source, string separator = """") => string.Join(separator ?? """", source);
}",1067,32
13696,http://rosettacode.org/wiki/Stack,Stack,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
A stack is a container of elements with   last in, first out   access policy.   Sometimes it also called LIFO.

The stack is accessed through its top.

The basic stack operations are:

   push   stores a new element onto the stack top;
   pop   returns the last pushed stack element, while removing it from the stack;
   empty   tests if the stack contains no elements.


Sometimes the last pushed stack element is made accessible for immutable access (for read) or mutable access (for write):

   top   (sometimes called peek to keep with the p theme) returns the topmost element without modifying the stack.


Stacks allow a very simple hardware implementation.

They are common in almost all processors.

In programming, stacks are also very popular for their way (LIFO) of resource management, usually memory.

Nested scopes of language objects are naturally implemented by a stack (sometimes by multiple stacks).

This is a classical way to implement local variables of a re-entrant or recursive subprogram. Stacks are also used to describe a formal computational framework.

See stack machine.

Many algorithms in pattern matching, compiler construction (e.g. recursive descent parsers), and machine learning (e.g. based on tree traversal) have a natural representation in terms of stacks.



Task

Create a stack supporting the basic operations: push, pop, empty.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#C.23,C#,"// Non-Generic Stack
System.Collections.Stack stack = new System.Collections.Stack();
stack.Push( obj );
bool isEmpty = stack.Count == 0;
object top = stack.Peek(); // Peek without Popping.
top = stack.Pop();
 
// Generic Stack
System.Collections.Generic.Stack<Foo> stack = new System.Collections.Generic.Stack<Foo>();
stack.Push(new Foo());
bool isEmpty = stack.Count == 0;
Foo top = stack.Peek(); // Peek without Popping.
top = stack.Pop();",442,13
13800,http://rosettacode.org/wiki/Stable_marriage_problem,Stable marriage problem,"Solve the Stable marriage problem using the Gale/Shapley algorithm.


Problem description

Given an equal number of men and women to be paired for marriage, each man ranks all the women in order of his preference and each woman ranks all the men in order of her preference.

A stable set of engagements for marriage is one where no man prefers a woman over the one he is engaged to, where that other woman also prefers that man over the one she is engaged to. I.e. with consulting marriages, there would be no reason for the engagements between the people to change.

Gale and Shapley proved that there is a stable set of engagements for any set of preferences and the first link above gives their algorithm for finding a set of stable engagements.


Task Specifics

Given ten males:

   abe, bob, col, dan, ed, fred, gav, hal, ian, jon

And ten females:

   abi, bea, cath, dee, eve, fay, gay, hope, ivy, jan

And a complete list of ranked preferences, where the most liked is to the left:

  abe: abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay
  bob: cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay
  col: hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan
  dan: ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi
   ed: jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay
 fred: bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay
  gav: gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay
  hal: abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee
  ian: hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve
  jon: abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope
   
  abi: bob, fred, jon, gav, ian, abe, dan, ed, col, hal
  bea: bob, abe, col, fred, gav, dan, ian, ed, jon, hal
 cath: fred, bob, ed, gav, hal, col, ian, abe, dan, jon
  dee: fred, jon, col, abe, ian, hal, gav, dan, bob, ed
  eve: jon, hal, fred, dan, abe, gav, col, ed, ian, bob
  fay: bob, abe, ed, ian, jon, dan, fred, gav, col, hal
  gay: jon, gav, hal, fred, bob, abe, col, ed, dan, ian
 hope: gav, jon, bob, abe, ian, dan, hal, ed, col, fred
  ivy: ian, col, hal, gav, fred, bob, abe, ed, jon, dan
  jan: ed, hal, gav, abe, bob, jon, col, ian, fred, dan

 Use the Gale Shapley algorithm to find a stable set of engagements
 Perturb this set of engagements to form an unstable set of engagements then check this new set for stability.

References

 The Stable Marriage Problem. (Eloquent description and background information).
 Gale-Shapley Algorithm Demonstration.
 Another Gale-Shapley Algorithm Demonstration.
 Stable Marriage Problem - Numberphile (Video).
 Stable Marriage Problem (the math bit) (Video).
 The Stable Marriage Problem and School Choice. (Excellent exposition)

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace StableMarriage
{
    class Person
    {
        private int _candidateIndex;
        public string Name { get; set; }
        public List<Person> Prefs { get; set; }
        public Person Fiance { get; set; }
 
        public Person(string name) {
            Name = name;
            Prefs = null;
            Fiance = null;
            _candidateIndex = 0;
        }
        public bool Prefers(Person p) {
            return Prefs.FindIndex(o => o == p) < Prefs.FindIndex(o => o == Fiance);
        }
        public Person NextCandidateNotYetProposedTo() {
            if (_candidateIndex >= Prefs.Count) return null;
            return Prefs[_candidateIndex++];
        }
        public void EngageTo(Person p) {
            if (p.Fiance != null) p.Fiance.Fiance = null;
            p.Fiance = this;
            if (Fiance != null) Fiance.Fiance = null;
            Fiance = p;
        }
    }
 
    static class MainClass
    {
        static public bool IsStable(List<Person> men) {
            List<Person> women = men[0].Prefs;
            foreach (Person guy in men) {
                foreach (Person gal in women) {
                    if (guy.Prefers(gal) && gal.Prefers(guy))
                        return false;
                }
            }
            return true;
        }
 
        static void DoMarriage() {
            Person abe  = new Person(""abe"");
            Person bob  = new Person(""bob"");
            Person col  = new Person(""col"");
            Person dan  = new Person(""dan"");
            Person ed   = new Person(""ed"");
            Person fred = new Person(""fred"");
            Person gav  = new Person(""gav"");
            Person hal  = new Person(""hal"");
            Person ian  = new Person(""ian"");
            Person jon  = new Person(""jon"");
            Person abi  = new Person(""abi"");
            Person bea  = new Person(""bea"");
            Person cath = new Person(""cath"");
            Person dee  = new Person(""dee"");
            Person eve  = new Person(""eve"");
            Person fay  = new Person(""fay"");
            Person gay  = new Person(""gay"");
            Person hope = new Person(""hope"");
            Person ivy  = new Person(""ivy"");
            Person jan  = new Person(""jan"");
 
            abe.Prefs  = new List<Person>() {abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay};
            bob.Prefs  = new List<Person>() {cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay};
            col.Prefs  = new List<Person>() {hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan};
            dan.Prefs  = new List<Person>() {ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi};
            ed.Prefs   = new List<Person>() {jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay};
            fred.Prefs = new List<Person>() {bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay};
            gav.Prefs  = new List<Person>() {gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay};
            hal.Prefs  = new List<Person>() {abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee};
            ian.Prefs  = new List<Person>() {hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve};
            jon.Prefs  = new List<Person>() {abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope};
            abi.Prefs  = new List<Person>() {bob, fred, jon, gav, ian, abe, dan, ed, col, hal};
            bea.Prefs  = new List<Person>() {bob, abe, col, fred, gav, dan, ian, ed, jon, hal};
            cath.Prefs = new List<Person>() {fred, bob, ed, gav, hal, col, ian, abe, dan, jon};
            dee.Prefs  = new List<Person>() {fred, jon, col, abe, ian, hal, gav, dan, bob, ed};
            eve.Prefs  = new List<Person>() {jon, hal, fred, dan, abe, gav, col, ed, ian, bob};
            fay.Prefs  = new List<Person>() {bob, abe, ed, ian, jon, dan, fred, gav, col, hal};
            gay.Prefs  = new List<Person>() {jon, gav, hal, fred, bob, abe, col, ed, dan, ian};
            hope.Prefs = new List<Person>() {gav, jon, bob, abe, ian, dan, hal, ed, col, fred};
            ivy.Prefs  = new List<Person>() {ian, col, hal, gav, fred, bob, abe, ed, jon, dan};
            jan.Prefs  = new List<Person>() {ed, hal, gav, abe, bob, jon, col, ian, fred, dan};
 
            List<Person> men = new List<Person>(abi.Prefs);
 
            int freeMenCount = men.Count;
            while (freeMenCount > 0) {
                foreach (Person guy in men) {
                    if (guy.Fiance == null) {
                        Person gal = guy.NextCandidateNotYetProposedTo();
                        if (gal.Fiance == null) {
                            guy.EngageTo(gal);
                            freeMenCount--;
                        } else if (gal.Prefers(guy)) {
                            guy.EngageTo(gal);
                        }
                    }
                }
            }
 
            foreach (Person guy in men) {
                Console.WriteLine(""{0} is engaged to {1}"", guy.Name, guy.Fiance.Name);
            }
            Console.WriteLine(""Stable = {0}"", IsStable(men));
 
            Console.WriteLine(""\nSwitching fred & jon's partners"");
            Person jonsFiance = jon.Fiance;
            Person fredsFiance = fred.Fiance;
            fred.EngageTo(jonsFiance);
            jon.EngageTo(fredsFiance);
            Console.WriteLine(""Stable = {0}"", IsStable(men));
        }
 
        public static void Main(string[] args)
        {
            DoMarriage();
        }
    }
}",5487,125
13934,http://rosettacode.org/wiki/Spiral_matrix,Spiral matrix,"Task

Produce a spiral array.



A   spiral array   is a square arrangement of the first    N2   natural numbers,   where the

numbers increase sequentially as you go around the edges of the array spiraling inwards.



For example, given   5,   produce this array:

 0  1  2  3  4
15 16 17 18  5
14 23 24 19  6
13 22 21 20  7
12 11 10  9  8



Related tasks

   Zig-zag matrix 
   Identity_matrix
   Ulam_spiral_(for_primes)

",#C.23,C#,"public int[,] Spiral(int n) {
    int[,] result = new int[n, n];
 
    int pos = 0;
    int count = n;
    int value = -n;
    int sum = -1;
 
    do {
        value = -1 * value / n;
        for (int i = 0; i < count; i++) {
            sum += value;
            result[sum / n, sum % n] = pos++;
        }
        value *= n;
        count--;
        for (int i = 0; i < count; i++) {
            sum += value;
            result[sum / n, sum % n] = pos++;
        }
    } while (count > 0);
 
    return result;
}
 
 
// Method to print arrays, pads numbers so they line up in columns
public void PrintArray(int[,] array) {
    int n = (array.GetLength(0) * array.GetLength(1) - 1).ToString().Length + 1;
 
    for (int i = 0; i < array.GetLength(0); i++) {
        for (int j = 0; j < array.GetLength(1); j++) {
            Console.Write(array[i, j].ToString().PadLeft(n, ' '));
        }
        Console.WriteLine();
    }
}",929,37
14046,http://rosettacode.org/wiki/Sorting_algorithms/Sleep_sort,Sorting algorithms/Sleep sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


In general, sleep sort works by starting a separate task for each item to be sorted, where each task sleeps for an interval corresponding to the item's sort key, then emits the item. Items are then collected sequentially in time.

Task: Write a program that implements sleep sort. Have it accept non-negative integers on the command line and print the integers in sorted order. If this is not idomatic in your language or environment, input and output may be done differently. Enhancements for optimization, generalization, practicality, robustness, and so on are not required.

Sleep sort was presented anonymously on 4chan and has been discussed on Hacker News.
",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
 
class Program
{
    static void ThreadStart(object item)
    {
        Thread.Sleep(1000 * (int)item);
        Console.WriteLine(item);
    }
 
    static void SleepSort(IEnumerable<int> items)
    {
        foreach (var item in items)
        {
            new Thread(ThreadStart).Start(item);
        }
    }
 
    static void Main(string[] arguments)
    {
        SleepSort(arguments.Select(int.Parse));
    }
}",508,26
14085,http://rosettacode.org/wiki/Sorting_algorithms/Stooge_sort,Sorting algorithms/Stooge sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Stooge sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Show the   Stooge Sort   for an array of integers.



The Stooge Sort algorithm is as follows:

algorithm stoogesort(array L, i = 0, j = length(L)-1)
     if L[j] < L[i] then
         L[i] ↔ L[j]
     if j - i > 1 then
         t := (j - i + 1)/3
         stoogesort(L, i  , j-t)
         stoogesort(L, i+t, j  )
         stoogesort(L, i  , j-t)
     return L


",#C.23,C#,"    public static void Sort<T>(List<T> list) where T : IComparable {
        if (list.Count > 1) {
            StoogeSort(list, 0, list.Count - 1);
        }
    }
    private static void StoogeSort<T>(List<T> L, int i, int j) where T : IComparable {
        if (L[j].CompareTo(L[i])<0) {
            T tmp = L[i];
            L[i] = L[j];
            L[j] = tmp;
        }
        if (j - i > 1) {
            int t = (j - i + 1) / 3;
            StoogeSort(L, i, j - t);
            StoogeSort(L, i + t, j);
            StoogeSort(L, i, j - t);
        }
    }",562,18
14183,http://rosettacode.org/wiki/Sorting_algorithms/Permutation_sort,Sorting algorithms/Permutation sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Implement a permutation sort, which proceeds by generating the possible permutations
of the input array/list until discovering the sorted one.

Pseudocode:

while not InOrder(list) do
    nextPermutation(list)
done


",#C.23,C#," 
public static class PermutationSorter
{
    public static void Sort<T>(List<T> list) where T : IComparable
    {
        PermutationSort(list, 0);
    }
    public static bool PermutationSort<T>(List<T> list, int i) where T : IComparable
    {
        int j;
        if (issorted(list, i))
        {
            return true;
        }
        for (j = i + 1; j < list.Count; j++)
        {
            T temp = list[i];
            list[i] = list[j];
            list[j] = temp;
            if (PermutationSort(list, i + 1))
            {
                return true;
            }
            temp = list[i];
            list[i] = list[j];
            list[j] = temp;
        }
        return false;
    }
    public static bool issorted<T>(List<T> list, int i) where T : IComparable
    {
	    for (int j = list.Count-1; j > 0; j--)
        {
	        if(list[j].CompareTo(list[j-1])<0)
            {
		        return false;
	        }
	    }
	    return true;
    }
}
 ",974,42
14189,http://rosettacode.org/wiki/Sorting_algorithms/Shell_sort,Sorting algorithms/Shell sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array of elements using the Shell sort algorithm, a diminishing increment sort.

The Shell sort   (also known as Shellsort or Shell's method)   is named after its inventor, Donald Shell, who published the algorithm in 1959.

Shell sort is a sequence of interleaved insertion sorts based on an increment sequence.
The increment size is reduced after each pass until the increment size is 1.

With an increment size of 1, the sort is a basic insertion sort, but by this time the data is guaranteed to be almost sorted, which is insertion sort's ""best case"".

Any sequence will sort the data as long as it ends in 1, but some work better than others.

Empirical studies have shown a geometric increment sequence with a ratio of about 2.2 work well in practice.
[1]

Other good sequences are found at the On-Line Encyclopedia of Integer Sequences.



",#C.23,C#," 
public static class ShellSorter
{
    public static void Sort<T>(IList<T> list) where T : IComparable
    {
        int n = list.Count;
        int h = 1;
 
        while (h < (n >> 1))
        {   
            h = (h << 1) + 1;
        }
 
        while (h >= 1)
        {
            for (int i = h; i < n; i++)
            {
                int k = i - h;
                for (int j = i; j >= h && list[j].CompareTo(list[k]) < 0; k -= h)
                {
                    T temp = list[j];
                    list[j] = list[k];
                    list[k] = temp;
                    j = k;
                }
            }
            h >>= 1;
        }
    }
}
 ",673,31
14250,http://rosettacode.org/wiki/Soundex,Soundex,"Soundex is an algorithm for creating indices for words based on their pronunciation.



Task

The goal is for homophones to be encoded to the same representation so that they can be matched despite minor differences in spelling   (from the   soundex   Wikipedia article).

Caution

There is a major issue in many of the implementations concerning the separation of two consonants that have the same soundex code! According to the official Rules [[1]]. So check for instance if Ashcraft is coded to A-261.

 If a vowel (A, E, I, O, U) separates two consonants that have the same soundex code, the consonant to the right of the vowel is coded. Tymczak is coded as T-522 (T, 5 for the M, 2 for the C, Z ignored (see ""Side-by-Side"" rule above), 2 for the K). Since the vowel ""A"" separates the Z and K, the K is coded.
 If ""H"" or ""W"" separate two consonants that have the same soundex code, the consonant to the right of the vowel is not coded. Example: Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 for the F). It is not coded A-226.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace Soundex
{
    internal static class Program
    {
        private static void Main()
        {
            var testWords = new TestWords
                                {
                                    {""Soundex"", ""S532""},
                                    {""Example"", ""E251""},
                                    {""Sownteks"", ""S532""},
                                    {""Ekzampul"", ""E251""},
                                    {""Euler"", ""E460""},
                                    {""Gauss"", ""G200""},
                                    {""Hilbert"", ""H416""},
                                    {""Knuth"", ""K530""},
                                    {""Lloyd"", ""L300""},
                                    {""Lukasiewicz"", ""L222""},
                                    {""Ellery"", ""E460""},
                                    {""Ghosh"", ""G200""},
                                    {""Heilbronn"", ""H416""},
                                    {""Kant"", ""K530""},
                                    {""Ladd"", ""L300""},
                                    {""Lissajous"", ""L222""},
                                    {""Wheaton"", ""W350""},
                                    {""Burroughs"", ""B620""},
                                    {""Burrows"", ""B620""},
                                    {""O'Hara"", ""O600""},
                                    {""Washington"", ""W252""},
                                    {""Lee"", ""L000""},
                                    {""Gutierrez"", ""G362""},
                                    {""Pfister"", ""P236""},
                                    {""Jackson"", ""J250""},
                                    {""Tymczak"", ""T522""},
                                    {""VanDeusen"", ""V532""},
                                    {""Ashcraft"", ""A261""}
                                };
 
            foreach (var testWord in testWords)
                Console.WriteLine(""{0} -> {1} ({2})"", testWord.Word.PadRight(11), testWord.ActualSoundex,
                                  (testWord.ExpectedSoundex == testWord.ActualSoundex));
        }
 
        // List<TestWord> wrapper to make declaration simpler.
        private class TestWords : List<TestWord> 
        {
            public void Add(string word, string expectedSoundex)
            {
                Add(new TestWord(word, expectedSoundex));
            }
        }
 
        private class TestWord
        {
            public TestWord(string word, string expectedSoundex)
            {
                Word = word;
                ExpectedSoundex = expectedSoundex;
                ActualSoundex = Soundex(word);
            }
 
            public string Word { get; private set; }
            public string ExpectedSoundex { get; private set; }
            public string ActualSoundex { get; private set; }
        }
 
        private static string Soundex(string word)
        {
            const string soundexAlphabet = ""0123012#02245501262301#202"";
            string soundexString = """";
            char lastSoundexChar = '?';
            word = word.ToUpper();
 
            foreach (var c in from ch in word
                              where ch >= 'A' &&
                                    ch <= 'Z' &&
                                    soundexString.Length < 4
                              select ch)
            {
                char thisSoundexChar = soundexAlphabet[c - 'A'];
 
                if (soundexString.Length == 0)
                    soundexString += c;
                else if (thisSoundexChar == '#')
                    continue;
                else if (thisSoundexChar != '0' &&
                         thisSoundexChar != lastSoundexChar)
                    soundexString += thisSoundexChar;
 
                lastSoundexChar = thisSoundexChar;
            }
 
            return soundexString.PadRight(4, '0');
        }
    }
}",3921,100
14305,http://rosettacode.org/wiki/Sorting_algorithms/Radix_sort,Sorting algorithms/Radix sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




Task

Sort an integer array with the   radix sort algorithm.

The primary purpose is to complete the characterization of sort algorithms task.



",#C.23,C#,"using System;
 
namespace RadixSort
{
    class Program
    {
        static void Sort(int[] old)
        {
            int i, j;
            int[] tmp = new int[old.Length];
            for (int shift = 31; shift > -1; --shift)
            {
                j = 0;
                for (i = 0; i < old.Length; ++i)
                {
                    bool move = (old[i] << shift) >= 0;
                    if (shift == 0 ? !move : move)  // shift the 0's to old's head
                        old[i-j] = old[i];
                    else                            // move the 1's to tmp
                        tmp[j++] = old[i];
                }
                Array.Copy(tmp, 0, old, old.Length-j, j);
            }
        }
        static void Main(string[] args)
        {
            int[] old = new int[] { 2, 5, 1, -3, 4 };
            Console.WriteLine(string.Join("", "", old));
            Sort(old);
            Console.WriteLine(string.Join("", "", old));
            Console.Read();
        }
    }
}",1015,34
14360,http://rosettacode.org/wiki/Sorting_algorithms/Selection_sort,Sorting algorithms/Selection sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array (or list) of elements using the Selection sort algorithm.



It works as follows:

First find the smallest element in the array and exchange it with the element in the first position, then find the second smallest element and exchange it with the element in the second position, and continue in this way until the entire array is sorted.



Its asymptotic complexity is    O(n2)    making it inefficient on large arrays.

Its primary purpose is for when writing data is very expensive (slow) when compared to reading, eg. writing to flash memory or EEPROM.

No other sorting algorithm has less data movement.



References

   Rosetta Code:   O     (complexity).
   Wikipedia:   Selection sort.
   Wikipedia:   [Big O notation].

",#C.23,C#,"class SelectionSort<T> where T : IComparable {
    public T[] Sort(T[] list) {
        int k;
        T temp;
 
        for (int i = 0; i < list.Length; i++) {
            k = i;
            for (int j=i + 1; j < list.Length; j++) {
                if (list[j].CompareTo(list[k]) < 0) {
                    k = j;
                }
            }
            temp = list[i];
            list[i] = list[k];
            list[k] = temp;
        }
 
        return list;
    }
}",473,20
14419,http://rosettacode.org/wiki/Sorting_algorithms/Pancake_sort,Sorting algorithms/Pancake sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array of integers (of any convenient size) into ascending order using Pancake sorting.

In short, instead of individual elements being sorted, the only operation allowed is to ""flip"" one end of the list, like so:

          Before:   6 7 8 9 2 5 3 4 1
          After:    9 8 7 6 2 5 3 4 1

Only one end of the list can be flipped; this should be the low end, but the high end is okay if it's easier to code or works better, but it must be the same end for the entire solution. (The end flipped can't be arbitrarily changed.)

Show both the initial, unsorted list and the final sorted list.

(Intermediate steps during sorting are optional.)

Optimizations are optional (but recommended).



Related tasks

   Number reversal game
   Topswops


Also see

   Wikipedia article:   pancake sorting.

",#C.23,C#," 
public static class PancakeSorter
{
    public static void Sort<T>(List<T> list) where T : IComparable
    {
        if (list.Count < 2)
        {
            return;
        }
        int i, a, max_num_pos;
        for (i = list.Count; i > 1; i--)
        {
            max_num_pos = 0;
            for (a = 0; a < i; a++)
            {
                if (list[a].CompareTo(list[max_num_pos]) > 0)
                {
                    max_num_pos = a;
                }
            }
            if (max_num_pos == i - 1)
            {
                continue;
            }
            if (max_num_pos > 0)
            {
                Flip(list, list.Count, max_num_pos + 1);
            }
            Flip(list, list.Count, i);
        }
        return;
    }
    private static void Flip<T>(List<T> list, int length, int num)
    {
        for (int i = 0; i < --num; i++)
        {
            T swap = list[i];
            list[i] = list[num];
            list[num] = swap;
        }
    }
}
 ",1005,43
14710,http://rosettacode.org/wiki/Sorting_algorithms/Quicksort,Sorting algorithms/Quicksort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Quicksort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Sort an array (or list) elements using the   quicksort   algorithm.

The elements must have a   strict weak order   and the index of the array can be of any discrete type.

For languages where this is not possible, sort an array of integers.



Quicksort, also known as   partition-exchange sort,   uses these steps.

   Choose any element of the array to be the pivot.
   Divide all other elements (except the pivot) into two partitions.
   All elements less than the pivot must be in the first partition.
   All elements greater than the pivot must be in the second partition.
   Use recursion to sort both partitions.
   Join the first sorted partition, the pivot, and the second sorted partition.


The best pivot creates partitions of equal length (or lengths differing by   1).

The worst pivot creates an empty partition (for example, if the pivot is the first or last element of a sorted array).

The run-time of Quicksort ranges from    O(n log n)    with the best pivots, to    O(n2)    with the worst pivots, where    n    is the number of elements in the array.



This is a simple quicksort algorithm, adapted from Wikipedia.

function quicksort(array)
    less, equal, greater := three empty arrays
    if length(array) > 1  
        pivot := select any element of array
        for each x in array
            if x < pivot then add x to less
            if x = pivot then add x to equal
            if x > pivot then add x to greater
        quicksort(less)
        quicksort(greater)
        array := concatenate(less, equal, greater)

A better quicksort algorithm works in place, by swapping elements within the array, to avoid the memory allocation of more arrays.

function quicksort(array)
    if length(array) > 1
        pivot := select any element of array
        left := first index of array
        right := last index of array
        while left ≤ right
            while array[left] < pivot
                left := left + 1
            while array[right] > pivot
                right := right - 1
            if left ≤ right
                swap array[left] with array[right]
                left := left + 1
                right := right - 1
        quicksort(array from first index to right)
        quicksort(array from left to last index)

Quicksort has a reputation as the fastest sort. Optimized variants of quicksort are common features of many languages and libraries. One often contrasts quicksort with   merge sort,   because both sorts have an average time of    O(n log n). 

 ""On average, mergesort does fewer comparisons than quicksort, so it may be better when complicated comparison routines are used. Mergesort also takes advantage of pre-existing order, so it would be favored for using sort() to merge several sorted arrays. On the other hand, quicksort is often faster for small arrays, and on arrays of a few distinct values, repeated many times."" — http://perldoc.perl.org/sort.html
Quicksort is at one end of the spectrum of divide-and-conquer algorithms, with merge sort at the opposite end.

 Quicksort is a conquer-then-divide algorithm, which does most of the work during the partitioning and the recursive calls. The subsequent reassembly of the sorted partitions involves trivial effort.
 Merge sort is a divide-then-conquer algorithm. The partioning happens in a trivial way, by splitting the input array in half. Most of the work happens during the recursive calls and the merge phase.


With quicksort, every element in the first partition is less than or equal to every element in the second partition. Therefore, the merge phase of quicksort is so trivial that it needs no mention!

This task has not specified whether to allocate new arrays, or sort in place. This task also has not specified how to choose the pivot element. (Common ways to are to choose the first element, the middle element, or the median of three elements.) Thus there is a variety among the following implementations.



",#C.23,C#,"//
// The Tripartite conditional enables Bentley-McIlroy 3-way Partitioning.
// This performs additional compares to isolate islands of keys equal to
// the pivot value.  Use unless key-equivalent classes are of small size.
//
#define Tripartite
 
namespace RosettaCode {
  using System;
  using System.Diagnostics;
 
  public class QuickSort<T> where T : IComparable {
    #region Constants
    public const UInt32 INSERTION_LIMIT_DEFAULT = 12;
    private const Int32 SAMPLES_MAX = 19;
    #endregion
 
    #region Properties
    public UInt32 InsertionLimit { get; }
    private T[] Samples { get; }
    private Int32 Left { get; set; }
    private Int32 Right { get; set; }
    private Int32 LeftMedian { get; set; }
    private Int32 RightMedian { get; set; }
    #endregion
 
    #region Constructors
    public QuickSort(UInt32 insertionLimit = INSERTION_LIMIT_DEFAULT) {
      this.InsertionLimit = insertionLimit;
      this.Samples = new T[SAMPLES_MAX];
    }
    #endregion
 
    #region Sort Methods
    public void Sort(T[] entries) {
      Sort(entries, 0, entries.Length - 1);
    }
 
    public void Sort(T[] entries, Int32 first, Int32 last) {
      var length = last + 1 - first;
      while (length > 1) {
        if (length < InsertionLimit) {
          InsertionSort<T>.Sort(entries, first, last);
          return;
        }
 
        Left = first;
        Right = last;
        var median = pivot(entries);
        partition(median, entries);
        //[Note]Right < Left
 
        var leftLength = Right + 1 - first;
        var rightLength = last + 1 - Left;
 
        //
        // First recurse over shorter partition, then loop
        // on the longer partition to elide tail recursion.
        //
        if (leftLength < rightLength) {
          Sort(entries, first, Right);
          first = Left;
          length = rightLength;
        }
        else {
          Sort(entries, Left, last);
          last = Right;
          length = leftLength;
        }
      }
    }
 
    /// <summary>Return an odd sample size proportional to the log of a large interval size.</summary>
    private static Int32 sampleSize(Int32 length, Int32 max = SAMPLES_MAX) {
      var logLen = (Int32)Math.Log10(length);
      var samples = Math.Min(2 * logLen + 1, max);
      return Math.Min(samples, length);
    }
 
    /// <summary>Estimate the median value of entries[Left:Right]</summary>
    /// <remarks>A sample median is used as an estimate the true median.</remarks>
    private T pivot(T[] entries) {
      var length = Right + 1 - Left;
      var samples = sampleSize(length);
      // Sample Linearly:
      for (var sample = 0; sample < samples; sample++) {
        // Guard against Arithmetic Overflow:
        var index = (Int64)length * sample / samples + Left;
        Samples[sample] = entries[index];
      }
 
      InsertionSort<T>.Sort(Samples, 0, samples - 1);
      return Samples[samples / 2];
    }
 
    private void partition(T median, T[] entries) {
      var first = Left;
      var last = Right;
#if Tripartite
      LeftMedian = first;
      RightMedian = last;
#endif
      while (true) {
        //[Assert]There exists some index >= Left where entries[index] >= median
        //[Assert]There exists some index <= Right where entries[index] <= median
        // So, there is no need for Left or Right bound checks
        while (median.CompareTo(entries[Left]) > 0) Left++;
        while (median.CompareTo(entries[Right]) < 0) Right--;
 
        //[Assert]entries[Right] <= median <= entries[Left]
        if (Right <= Left) break;
 
        Swap(entries, Left, Right);
        swapOut(median, entries);
        Left++;
        Right--;
        //[Assert]entries[first:Left - 1] <= median <= entries[Right + 1:last]
      }
 
      if (Left == Right) {
        Left++;
        Right--;
      }
      //[Assert]Right < Left
      swapIn(entries, first, last);
 
      //[Assert]entries[first:Right] <= median <= entries[Left:last]
      //[Assert]entries[Right + 1:Left - 1] == median when non-empty
    }
    #endregion
 
    #region Swap Methods
    [Conditional(""Tripartite"")]
    private void swapOut(T median, T[] entries) {
      if (median.CompareTo(entries[Left]) == 0) Swap(entries, LeftMedian++, Left);
      if (median.CompareTo(entries[Right]) == 0) Swap(entries, Right, RightMedian--);
    }
 
    [Conditional(""Tripartite"")]
    private void swapIn(T[] entries, Int32 first, Int32 last) {
      // Restore Median entries
      while (first < LeftMedian) Swap(entries, first++, Right--);
      while (RightMedian < last) Swap(entries, Left++, last--);
    }
 
    /// <summary>Swap entries at the left and right indicies.</summary>
    public void Swap(T[] entries, Int32 left, Int32 right) {
      Swap(ref entries[left], ref entries[right]);
    }
 
    /// <summary>Swap two entities of type T.</summary>
    public static void Swap(ref T e1, ref T e2) {
      var e = e1;
      e1 = e2;
      e2 = e;
    }
    #endregion
  }
 
  #region Insertion Sort
  static class InsertionSort<T> where T : IComparable {
    public static void Sort(T[] entries, Int32 first, Int32 last) {
      for (var next = first + 1; next <= last; next++)
        insert(entries, first, next);
    }
 
    /// <summary>Bubble next entry up to its sorted location, assuming entries[first:next - 1] are already sorted.</summary>
    private static void insert(T[] entries, Int32 first, Int32 next) {
      var entry = entries[next];
      while (next > first && entries[next - 1].CompareTo(entry) > 0)
        entries[next] = entries[--next];
      entries[next] = entry;
    }
  }
  #endregion
}",5633,176
14766,http://rosettacode.org/wiki/Sorting_algorithms/Insertion_sort,Sorting algorithms/Insertion sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Insertion sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



An O(n2) sorting algorithm which moves elements one at a time into the correct position.
The algorithm consists of inserting one element at a time into the previously sorted part of the array, moving higher ranked elements up as necessary.
To start off, the first (or smallest, or any arbitrary) element of the unsorted array is considered to be the sorted part.

Although insertion sort is an O(n2) algorithm, its simplicity, low overhead, good locality of reference and efficiency make it a good choice in two cases: 


   small   n, 

   as the final finishing-off algorithm for O(n logn) algorithms such as mergesort and quicksort.


The algorithm is as follows (from wikipedia):

function insertionSort(array A)
    for i from 1 to length[A]-1 do
        value := A[i] 
        j := i-1
        while j >= 0 and A[j] > value do
            A[j+1] := A[j]
            j := j-1
        done
        A[j+1] = value
    done

Writing the algorithm for integers will suffice.



",#C.23,C#,"namespace Sort {
  using System;
 
  static class InsertionSort<T> where T : IComparable {
    public static void Sort(T[] entries) {
      Sort(entries, 0, entries.Length - 1);
    }
 
    public static void Sort(T[] entries, Int32 first, Int32 last) {
      for (var i = first + 1; i <= last; i++) {
        var entry = entries[i];
        var j = i;
 
        while (j > first && entries[j - 1].CompareTo(entry) > 0)
          entries[j] = entries[--j];
 
        entries[j] = entry;
      }
    }
  }
}",506,21
14818,http://rosettacode.org/wiki/Sorting_algorithms/Heapsort,Sorting algorithms/Heapsort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Heapsort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Heapsort is an in-place sorting algorithm with worst case and average complexity of   O(n logn).

The basic idea is to turn the array into a binary heap structure, which has the property that it allows efficient retrieval and removal of the maximal element.

We repeatedly ""remove"" the maximal element from the heap, thus building the sorted list from back to front.

A heap sort requires random access, so can only be used on an array-like data structure.

Pseudocode:

function heapSort(a, count) is
   input: an unordered array a of length count
 
   (first place a in max-heap order)
   heapify(a, count)
 
   end := count - 1
   while end > 0 do
      (swap the root(maximum value) of the heap with the
       last element of the heap)
      swap(a[end], a[0])
      (decrement the size of the heap so that the previous
       max value will stay in its proper place)
      end := end - 1
      (put the heap back in max-heap order)
      siftDown(a, 0, end)



function heapify(a,count) is
   (start is assigned the index in a of the last parent node)
   start := (count - 2) / 2
   
   while start ≥ 0 do
      (sift down the node at index start to the proper place
       such that all nodes below the start index are in heap
       order)
      siftDown(a, start, count-1)
      start := start - 1
   (after sifting down the root all nodes/elements are in heap order)
 
function siftDown(a, start, end) is
   (end represents the limit of how far down the heap to sift)
   root := start

   while root * 2 + 1 ≤ end do       (While the root has at least one child)
      child := root * 2 + 1           (root*2+1 points to the left child)
      (If the child has a sibling and the child's value is less than its sibling's...)
      if child + 1 ≤ end and a[child] < a[child + 1] then
         child := child + 1           (... then point to the right child instead)
      if a[root] < a[child] then     (out of max-heap order)
         swap(a[root], a[child])
         root := child                (repeat to continue sifting down the child now)
      else
         return



Write a function to sort a collection of integers using heapsort.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Text;
 
public class HeapSortClass
{
    public static void HeapSort<T>(T[] array)
    {
        HeapSort<T>(array, 0, array.Length, Comparer<T>.Default);
    }
 
    public static void HeapSort<T>(T[] array, int offset, int length, IComparer<T> comparer)
    {
        HeapSort<T>(array, offset, length, comparer.Compare);
    }
 
    public static void HeapSort<T>(T[] array, int offset, int length, Comparison<T> comparison)
    {
        // build binary heap from all items
        for (int i = 0; i < length; i++)
        {
            int index = i;
            T item = array[offset + i]; // use next item
 
            // and move it on top, if greater than parent
            while (index > 0 &&
                comparison(array[offset + (index - 1) / 2], item) < 0)
            {
                int top = (index - 1) / 2;
                array[offset + index] = array[offset + top];
                index = top;
            }
            array[offset + index] = item;
        }
 
        for (int i = length - 1; i > 0; i--)
        {
            // delete max and place it as last
            T last = array[offset + i];
            array[offset + i] = array[offset];
 
            int index = 0;
            // the last one positioned in the heap
            while (index * 2 + 1 < i)
            {
                int left = index * 2 + 1, right = left + 1;
 
                if (right < i && comparison(array[offset + left], array[offset + right]) < 0)
                {
                    if (comparison(last, array[offset + right]) > 0) break;
 
                    array[offset + index] = array[offset + right];
                    index = right;
                }
                else
                {
                    if (comparison(last, array[offset + left]) > 0) break;
 
                    array[offset + index] = array[offset + left];
                    index = left;
                }
            }
            array[offset + index] = last;
        }
    }
 
    static void Main()
    {
        // usage
        byte[] r = {5, 4, 1, 2};
        HeapSort(r);
 
        string[] s = { ""-"", ""D"", ""a"", ""33"" };
        HeapSort(s, 0, s.Length, StringComparer.CurrentCultureIgnoreCase);
    }
}",2283,76
14877,http://rosettacode.org/wiki/Sorting_algorithms/Merge_sort,Sorting algorithms/Merge sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


The   merge sort   is a recursive sort of order    n*log(n). 

It is notable for having a worst case and average complexity of    O(n*log(n)),    and a best case complexity of    O(n)    (for pre-sorted input).

The basic idea is to split the collection into smaller groups by halving it until the groups only have one element or no elements   (which are both entirely sorted groups).

Then merge the groups back together so that their elements are in order.

This is how the algorithm gets its   divide and conquer   description.



Task

Write a function to sort a collection of integers using the merge sort.



The merge sort algorithm comes in two parts:

   a sort function     and 
   a merge function 

The functions in pseudocode look like this:

function mergesort(m)
   var list left, right, result
   if length(m) ≤ 1
       return m
   else
       var middle = length(m) / 2
       for each x in m up to middle - 1
           add x to left
       for each x in m at and after middle
           add x to right
       left = mergesort(left)
       right = mergesort(right)
       if last(left) ≤ first(right) 
          append right to left
          return left
       result = merge(left, right)
       return result

function merge(left,right)
   var list result
   while length(left) > 0 and length(right) > 0
       if first(left) ≤ first(right)
           append first(left) to result
           left = rest(left)
       else
           append first(right) to result
           right = rest(right)
   if length(left) > 0 
       append rest(left) to result
   if length(right) > 0 
       append rest(right) to result
   return result



See also

   the Wikipedia entry:    merge sort


Note:   better performance can be expected if, rather than recursing until    length(m) ≤ 1,    an insertion sort is used for    length(m)    smaller than some threshold larger than   1.   However, this complicates the example code, so it is not shown here.



",#C.23,C#,"namespace RosettaCode {
  using System;
 
  public class MergeSort<T> where T : IComparable {
    #region Constants
    public const UInt32 INSERTION_LIMIT_DEFAULT = 12;
    public const Int32 MERGES_DEFAULT = 6;
    #endregion
 
    #region Properties
    public UInt32 InsertionLimit { get; }
    protected UInt32[] Positions { get; set; }
 
    private Int32 merges;
    public Int32 Merges {
      get { return merges; }
      set {
        // A minimum of 2 merges are required
        if (value > 1)
          merges = value;
        else
          throw new ArgumentOutOfRangeException($""value = {value} must be greater than one"", nameof(Merges));
 
        if (Positions == null || Positions.Length != merges)
          Positions = new UInt32[merges];
      }
    }
    #endregion
 
    #region Constructors
    public MergeSort(UInt32 insertionLimit, Int32 merges) {
      InsertionLimit = insertionLimit;
      Merges = merges;
    }
 
    public MergeSort()
      : this(INSERTION_LIMIT_DEFAULT, MERGES_DEFAULT) {
    }
    #endregion
 
    #region Sort Methods
    public void Sort(T[] entries) {
      // Allocate merge buffer
      var entries2 = new T[entries.Length];
      Sort(entries, entries2, 0, entries.Length - 1);
    }
 
    // Top-Down K-way Merge Sort
    public void Sort(T[] entries1, T[] entries2, Int32 first, Int32 last) {
      var length = last + 1 - first;
      if (length < 2) return;      
      if (length < Merges || length < InsertionLimit) {
        InsertionSort<T>.Sort(entries1, first, last);
        return;
      }
 
      var left = first;
      var size = ceiling(length, Merges);
      for (var remaining = length; remaining > 0; remaining -= size, left += size) {
        var right = left + Math.Min(remaining, size) - 1;
        Sort(entries1, entries2, left, right);
      }
 
      Merge(entries1, entries2, first, last);
      Array.Copy(entries2, first, entries1, first, length);
    }
    #endregion
 
    #region Merge Methods
    public void Merge(T[] entries1, T[] entries2, Int32 first, Int32 last) {
      Array.Clear(Positions, 0, Merges);
      // This implementation has a quadratic time dependency on the number of merges
      for (var index = first; index <= last; index++)
        entries2[index] = remove(entries1, first, last);
    }
 
    private T remove(T[] entries, Int32 first, Int32 last) {
      T entry = default;
      Int32? found = default;
      var length = last + 1 - first;
 
      var index = 0;
      var left = first;
      var size = ceiling(length, Merges);
      for (var remaining = length; remaining > 0; remaining -= size, left += size, index++) {
        var position = Positions[index];
        if (position < Math.Min(remaining, size)) {
          var next = entries[left + position];
          if (!found.HasValue || entry.CompareTo(next) > 0) {
            found = index;
            entry = next;
          }
        }
      }
 
      // Remove entry
      Positions[found.Value]++;
      return entry;
    }
    #endregion
 
    #region Math Methods
    private static Int32 ceiling(Int32 numerator, Int32 denominator) {
      return (numerator + denominator - 1) / denominator;
    }
    #endregion
  }
 
  #region Insertion Sort
  static class InsertionSort<T> where T : IComparable {
    public static void Sort(T[] entries, Int32 first, Int32 last) {
      for (var next = first + 1; next <= last; next++)
        insert(entries, first, next);
    }
 
    /// <summary>Bubble next entry up to its sorted location, assuming entries[first:next - 1] are already sorted.</summary>
    private static void insert(T[] entries, Int32 first, Int32 next) {
      var entry = entries[next];
      while (next > first && entries[next - 1].CompareTo(entry) > 0)
        entries[next] = entries[--next];
      entries[next] = entry;
    }
  }
  #endregion
}",3850,125
15468,http://rosettacode.org/wiki/Sorting_Algorithms/Circle_Sort,Sorting Algorithms/Circle Sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Sort an array of integers (of any convenient size) into ascending order using Circlesort.

In short, compare the first element to the last element, then the second element to the second last element, etc.

Then split the array in two and recurse until there is only one single element in the array, like this:

Before:
6 7 8 9 2 5 3 4 1
After:
1 4 3 5 2 9 8 7 6

Repeat this procedure until quiescence (i.e. until there are no swaps).

Show both the initial, unsorted list and the final sorted list. (Intermediate steps during sorting are optional.)

Optimizations (like doing 0.5 log2(n) iterations and then continue with an Insertion sort) are optional. 


Pseudo code:

 function circlesort (index lo, index hi, swaps)
 {
   if lo == hi return (swaps)
   high := hi
   low := lo
   mid := int((hi-lo)/2)
   while lo < hi {
     if  (value at lo) > (value at hi) {
        swap.values (lo,hi)
        swaps++
     }
     lo++
     hi--
   }
   if lo == hi
     if (value at lo) > (value at hi+1) {
         swap.values (lo,hi+1)
         swaps++
     }
   swaps := circlesort(low,low+mid,swaps)
   swaps := circlesort(low+mid+1,high,swaps)
   return(swaps)
 }
 while circlesort (0, sizeof(array)-1, 0)



See also

 For more information on Circle sorting, see Sourceforge.

",#C.23,C#,"using System;
using System.Linq;
 
namespace CircleSort
{
    internal class Program
    {
        public static int[] CircleSort(int[] array)
        {
            if (array.Length > 0)
                while (CircleSortR(array, 0, array.Length - 1, 0) != 0)
                    continue;
            return array;
        }
 
        private static int CircleSortR(int[] arr, int lo, int hi, int numSwaps)
        {
            if (lo == hi)
                return numSwaps;
 
            var high = hi;
            var low = lo;
            var mid = (hi - lo) / 2;
 
            while (lo < hi)
            {
                if (arr[lo] > arr[hi])
                {
                    (arr[lo], arr[hi]) = (arr[hi], arr[lo]);
                    numSwaps++;
                }
                lo++;
                hi--;
            }
 
            if (lo == hi && arr[lo] > arr[hi + 1])
            {
                (arr[lo], arr[hi + 1]) = (arr[hi + 1], arr[lo]);
                numSwaps++;
            }
 
            numSwaps = CircleSortR(arr, low, low + mid, numSwaps);
            numSwaps = CircleSortR(arr, low + mid + 1, high, numSwaps);
 
            return numSwaps;
        }
 
        private static void Main(string[] args)
        {
            var sortedArray = CircleSort(new int[] { 6, 7, 8, 9, 2, 5, 3, 4, 1 });
            sortedArray.ToList().ForEach(i => Console.Write(i.ToString() + "" ""));
            Console.WriteLine();
            var sortedArray2 = CircleSort(new int[] { 2, 14, 4, 6, 8, 1, 3, 5, 7, 11, 0, 13, 12, -1 });
            sortedArray2.ToList().ForEach(i => Console.Write(i.ToString() + "" ""));
            Console.WriteLine();
            var sortedArray3 = CircleSort(new int[] { 2, 3, 3, 5, 5, 1, 1, 7, 7, 6, 6, 4, 4, 0, 0 });
            sortedArray3.ToList().ForEach(i => Console.Write(i.ToString() + "" ""));
            Console.ReadKey();
        }
    }
}",1905,61
15552,http://rosettacode.org/wiki/Sorting_algorithms/Comb_sort,Sorting algorithms/Comb sort,"Sorting algorithms/Comb sort

You are encouraged to solve this task according to the task description, using any language you may know.

Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Implement a   comb sort.



The Comb Sort is a variant of the Bubble Sort.

Like the Shell sort, the Comb Sort increases the gap used in comparisons and exchanges.

Dividing the gap by   



(
1
−

e

−
φ



)

−
1


≈
1.247330950103979


{\displaystyle (1-e^{-\varphi })^{-1}\approx 1.247330950103979}

    works best, but    1.3   may be more practical.



Some implementations use the insertion sort once the gap is less than a certain amount.



Also see

   the Wikipedia article:   Comb sort.


Variants:

 Combsort11 makes sure the gap ends in (11, 8, 6, 4, 3, 2, 1), which is significantly faster than the other two possible endings.
 Combsort with different endings changes to a more efficient sort when the data is almost sorted (when the gap is small).   Comb sort with a low gap isn't much better than the Bubble Sort.


Pseudocode:

function combsort(array input)
    gap := input.size //initialize gap size
    loop until gap = 1 and swaps = 0
        //update the gap value for a next comb. Below is an example
        gap := int(gap / 1.25)
        if gap < 1
          //minimum gap is 1
          gap := 1
        end if
        i := 0
        swaps := 0 //see Bubble Sort for an explanation
        //a single ""comb"" over the input list
        loop until i + gap >= input.size //see Shell sort for similar idea
            if input[i] > input[i+gap]
                swap(input[i], input[i+gap])
                swaps := 1 // Flag a swap has occurred, so the
                           // list is not guaranteed sorted
            end if
            i := i + 1
        end loop
    end loop
end function


",#C.23,C#,"using System;
 
namespace CombSort
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] unsorted = new int[] { 3, 5, 1, 9, 7, 6, 8, 2, 4 };
            Console.WriteLine(string.Join("","", combSort(unsorted)));
        }
        public static int[] combSort(int[] input)
        {
            double gap = input.Length;
            bool swaps = true;
            while (gap > 1 || swaps)
            {
                gap /= 1.247330950103979;
                if (gap < 1) { gap = 1; }
                int i = 0;
                swaps = false;
                while (i + gap < input.Length)
                {
                    int igap = i + (int)gap;
                    if (input[i] > input[igap])
                    {
                        int swap = input[i];
                        input[i] = input[igap];
                        input[igap] = swap;
                        swaps = true;
                    }
                    i++;
                }
            }
            return input;
        }
    }
}",1060,38
15594,http://rosettacode.org/wiki/Sorting_algorithms/Bogosort,Sorting algorithms/Bogosort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Bogosort a list of numbers.



Bogosort simply shuffles a collection randomly until it is sorted.

""Bogosort"" is a perversely inefficient algorithm only used as an in-joke.

Its average run-time is   O(n!)   because the chance that any given shuffle of a set will end up in sorted order is about one in   n   factorial,   and the worst case is infinite since there's no guarantee that a random shuffling will ever produce a sorted sequence.

Its best case is   O(n)   since a single pass through the elements may suffice to order them.



Pseudocode:

while not InOrder(list) do
   Shuffle(list)
done



The Knuth shuffle may be used to implement the shuffle part of this algorithm.



",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace RosettaCode.BogoSort
{
    public static class BogoSorter
    {
        public static void Sort<T>(List<T> list) where T:IComparable
        {
            while (!list.isSorted())
            {
                list.Shuffle();
            }
        }
 
        private static bool isSorted<T>(this IList<T> list) where T:IComparable
        {
            if(list.Count<=1)
                return true;
            for (int i = 1 ; i < list.Count; i++)
                if(list[i].CompareTo(list[i-1])<0) return false;
            return true;
        }
 
        private static void Shuffle<T>(this IList<T> list)
        {
            Random rand = new Random();
            for (int i = 0; i < list.Count; i++)
            {
                int swapIndex = rand.Next(list.Count);
                T temp = list[swapIndex];
                list[swapIndex] = list[i];
                list[i] = temp;
            }
        }
    }
 
    class TestProgram
    {
        static void Main()
        {
            List<int> testList = new List<int> { 3, 4, 1, 8, 7, 4, -2 };
            BogoSorter.Sort(testList);
            foreach (int i in testList) Console.Write(i + "" "");
        }
 
    }
}",1249,48
15627,http://rosettacode.org/wiki/Sorting_algorithms/Counting_sort,Sorting algorithms/Counting sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Counting sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Implement the Counting sort.   This is a way of sorting integers when the minimum and maximum value are known.



Pseudocode

function countingSort(array, min, max):
    count: array of (max - min + 1) elements
    initialize count with 0
    for each number in array do
        count[number - min] := count[number - min] + 1
    done
    z := 0
    for i from min to max do
        while ( count[i - min] > 0 ) do
            array[z] := i
            z := z+1
            count[i - min] := count[i - min] - 1
        done
    done

The min and max can be computed apart, or be known a priori.


Note:   we know that, given an array of integers,   its maximum and minimum values can be always found;   but if we imagine the worst case for an array that can hold up to 32 bit integers,   we see that in order to hold the counts,   an array of up to 232 elements may be needed.   I.E.:   we need to hold a count value up to 232-1,   which is a little over 4.2 Gbytes.   So the counting sort is more practical when the range is (very) limited,   and minimum and maximum values are known   a priori.     (However, as a counterexample,   the use of   sparse arrays   minimizes the impact of the memory usage,   as well as removing the need of having to know the minimum and maximum values   a priori.)



",#C.23,C#,"using System;
using System.Linq;
 
namespace CountingSort
{
    class Program
    {
        static void Main(string[] args)
        {
            Random rand = new Random();                                   // Just for creating a test array
            int[] arr = new int[100];                                     // of random numbers
            for (int i = 0; i < 100; i++) { arr[i] = rand.Next(0, 100); } // ...
 
            int[] newarr = countingSort(arr, arr.Min(), arr.Max());
        }
 
        private static int[] countingSort(int[] arr, int min, int max)
        {
            int[] count = new int[max - min + 1];
            int z = 0;
 
            for (int i = 0; i < count.Length; i++) { count[i] = 0; }
            for (int i = 0; i < arr.Length; i++) { count[arr[i] - min]++; }           
 
            for (int i = min; i <= max; i++)
            {
                while (count[i - min]-- > 0)
                {
                    arr[z] = i;
                    z++;                    
                }
            }
            return arr;
        }
    }
}",1086,36
15647,http://rosettacode.org/wiki/Sorting_algorithms/Gnome_sort,Sorting algorithms/Gnome sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Gnome sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Gnome sort is a sorting algorithm which is similar to Insertion sort, except that moving an element to its proper place is accomplished by a series of swaps, as in Bubble Sort.

The pseudocode for the algorithm is:

function gnomeSort(a[0..size-1])
    i := 1
    j := 2
    while i < size do
        if a[i-1] <= a[i] then
            // for descending sort, use >= for comparison
            i := j
            j := j + 1 
        else
            swap a[i-1] and a[i]
            i := i - 1
            if i = 0 then
                i := j
                j := j + 1
            endif
        endif
    done



Task

Implement the Gnome sort in your language to sort an array (or list) of numbers.



",#C.23,C#," 
        public static void gnomeSort(int[] anArray)
        {
            int first = 1;
            int second = 2;
 
            while (first < anArray.Length)
            {
                if (anArray[first - 1] <= anArray[first])
                {
                    first = second;
                    second++;
                }
                else
                {
                    int tmp = anArray[first - 1];
                    anArray[first - 1] = anArray[first];
                    anArray[first] = tmp;
                    first -= 1;
                    if (first == 0)
                    {
                        first = 1;
                        second = 2;
                    }
                }
 
            }
        }
 ",754,29
15718,http://rosettacode.org/wiki/Sorting_algorithms/Cocktail_sort,Sorting algorithms/Cocktail sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Cocktail sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The cocktail shaker sort is an improvement on the Bubble Sort.

The improvement is basically that values ""bubble"" both directions through the array, because on each iteration the cocktail shaker sort bubble sorts once forwards and once backwards. Pseudocode for the algorithm (from wikipedia):

function cocktailSort( A : list of sortable items )
 do
   swapped := false
   for each i in 0 to length( A ) - 2 do
     if A[ i ] > A[ i+1 ] then // test whether the two 
                               // elements are in the wrong 
                               // order
       swap( A[ i ], A[ i+1 ] ) // let the two elements
                                // change places
       swapped := true;
   if swapped = false then
     // we can exit the outer loop here if no swaps occurred.
     break do-while loop;
   swapped := false
   for each i in length( A ) - 2 down to 0 do
     if A[ i ] > A[ i+1 ] then
       swap( A[ i ], A[ i+1 ] )
       swapped := true;
 while swapped; // if no elements have been swapped, 
                // then the list is sorted

Related task

   cocktail sort with shifting bounds

",#C.23,C#,"public static void cocktailSort(int[] A)
    {
        bool swapped;
        do
        {
            swapped = false;
            for (int i = 0; i <= A.Length - 2; i++)
            {
                if (A[i] > A[i + 1])
                {
                    //test whether the two elements are in the wrong order
                    int temp = A[i];
                    A[i] = A[i + 1];
                    A[i + 1] = temp;
                    swapped = true;
                }
            }
            if (!swapped)
            {
                //we can exit the outer loop here if no swaps occurred.
                break;
            }
            swapped = false;
            for (int i = A.Length - 2; i >= 0; i--)
            {
                if (A[i] > A[i + 1])
                {
                    int temp = A[i];
                    A[i] = A[i + 1];
                    A[i + 1] = temp;
                    swapped = true;
                }
            }
            //if no elements have been swapped, then the list is sorted
        } while (swapped);
    }",1076,36
15804,http://rosettacode.org/wiki/Sort_three_variables,Sort three variables,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort   (the values of)   three variables   (X,   Y,   and   Z)   that contain any value   (numbers and/or literals).

If that isn't possible in your language, then just sort numbers   (and note if they can be floating point, integer, or other).

I.E.:   (for the three variables   x,   y,   and   z),   where:

                        x =  'lions, tigers, and'
                        y =  'bears, oh my!'
                        z =  '(from the ""Wizard of OZ"")'

After sorting, the three variables would hold:

                        x =  '(from the ""Wizard of OZ"")'
                        y =  'bears, oh my!'
                        z =  'lions, tigers, and'

For numeric value sorting, use:
I.E.:   (for the three variables   x,   y,   and   z),   where:

                        x =  77444
                        y =    -12
                        z =      0

After sorting, the three variables would hold:

                        x =    -12
                        y =      0
                        z =  77444

The variables should contain some form of a number, but specify if the algorithm
used can be for floating point or integers.   Note any limitations.

The values may or may not be unique.

The method used for sorting can be any algorithm;   the goal is to use the most idiomatic in the computer programming language used.

More than one algorithm could be shown if one isn't clearly the better choice.



One algorithm could be:

                        •  store the three variables   x, y, and z
                                 into an array (or a list)   A
                         
                        •  sort  (the three elements of)  the array   A
                         
                        •  extract the three elements from the array and place them in the
                                 variables x, y, and z   in order of extraction



Another algorithm   (only for numeric values):

       x= 77444 
       y=   -12 
       z=     0      
    low= x                                          
    mid= y                                          
   high= z 
      x= min(low,  mid,  high)            /*determine the lowest value of X,Y,Z. */    
      z= max(low,  mid,  high)            /*    ""      ""  highest  ""    "" "" "" ""  */    
      y=     low + mid + high - x - z     /*    ""      ""  middle   ""    "" "" "" ""  */      



Show the results of the sort here on this page using at least the values of those shown above.



",#C.23,C#,"using System;
public class Program
{
    public static void Main()
    {
        (int x, int y, int z) = (77444, -12, 0);
 
        //Sort directly:
        if (x > y) (x, y) = (y, x);
        if (x > z) (x, z) = (z, x);
        if (y > z) (y, z) = (z, y);
        Console.WriteLine((x, y, z));
 
        var (a, b, c) = (
            ""lions, tigers, and"",
            ""bears, oh my!"",
            ""(from the 'Wizard of OZ')"");
 
        //Sort with generic method:
        Sort(ref a, ref b, ref c);
        Console.WriteLine((a, b, c));
    }
 
    public static void Sort<T>(ref T a, ref T b, ref T c)
        where T : IComparable<T>
    {
        if (a.CompareTo(b) > 0) (a, b) = (b, a);
        if (a.CompareTo(c) > 0) (a, c) = (c, a);
        if (b.CompareTo(c) > 0) (b, c) = (c, b);
    }
}",798,31
15805,http://rosettacode.org/wiki/Sort_using_a_custom_comparator,Sort using a custom comparator,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array (or list) of strings in order of descending length, and in ascending lexicographic order for strings of equal length.

Use a sorting facility provided by the language/library, combined with your own callback comparison function.


Note:   Lexicographic order is case-insensitive.



",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace RosettaCode {
    class SortCustomComparator {
        // Driver program
        public void CustomSort() {
            String[] items = { ""Here"", ""are"", ""some"", ""sample"", ""strings"", ""to"", ""be"", ""sorted"" };
            List<String> list = new List<string>(items);
 
            DisplayList(""Unsorted"", list);
 
            list.Sort(CustomCompare);
            DisplayList(""Descending Length"", list);
 
            list.Sort();
            DisplayList(""Ascending order"", list);
        }
 
        // Custom compare
        public int CustomCompare(String x, String y) {
            int result = -x.Length.CompareTo(y.Length);
            if (result == 0) {
                result = x.ToLower().CompareTo(y.ToLower());
            }
 
            return result;
        }
 
        // Output routine
        public void DisplayList(String header, List<String> theList) {
            Console.WriteLine(header);
            Console.WriteLine("""".PadLeft(header.Length, '*'));
            foreach (String str in theList) {
                Console.WriteLine(str);
            }
            Console.WriteLine();
        }
    }
}",1183,40
15816,http://rosettacode.org/wiki/Sort_numbers_lexicographically,Sort numbers lexicographically,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Given an integer   n,   return   1──►n   (inclusive)   in lexicographical order.



Show all output here on this page.



Example

Given   13,

return:   [1,10,11,12,13,2,3,4,5,6,7,8,9].
",#C.23,C#,"using static System.Console;
using static System.Linq.Enumerable;
 
public class Program
{
    public static void Main() {
        foreach (int n in new [] { 0, 5, 13, 21, -22 }) WriteLine($""{n}: {string.Join("", "", LexOrder(n))}"");
    }
 
    public static IEnumerable<int> LexOrder(int n) => (n < 1 ? Range(n, 2 - n) : Range(1, n)).OrderBy(i => i.ToString());
}",363,11
15867,http://rosettacode.org/wiki/Sort_stability,Sort stability,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


When sorting records in a table by a particular column or field, a stable sort will always retain the relative order of records that have the same key.



Example

In this table of countries and cities, a stable sort on the second column, the cities, would keep the   US Birmingham   above the   UK Birmingham.

(Although an unstable sort might, in this case, place the   US Birmingham   above the   UK Birmingham,   a stable sort routine would guarantee it).

UK  London
US  New York
US  Birmingham
UK  Birmingham

Similarly, stable sorting on just the first column would generate UK London as the first item and US Birmingham as the last item   (since the order of the elements having the same first word –   UK or US   – would be maintained).



Task

   Examine the documentation on any in-built sort routines supplied by a language.
   Indicate if an in-built routine is supplied
   If supplied, indicate whether or not the in-built routine is stable.


(This Wikipedia table shows the stability of some common sort routines).



",#C.23,C#,"cities = [ {""UK"", ""London""},
           {""US"", ""New York""},
           {""US"", ""Birmingham""},
           {""UK"", ""Birmingham""} ]
 
IO.inspect Enum.sort(cities)
IO.inspect Enum.sort(cities, fn a,b -> elem(a,0) >= elem(b,0) end)
IO.inspect Enum.sort_by(cities, fn {country, _city} -> country end)
IO.inspect Enum.sort_by(cities, fn {_country, city} -> city end)",357,9
15949,http://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort,Sorting algorithms/Bubble sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


A   bubble   sort is generally considered to be the simplest sorting algorithm.

A   bubble   sort is also known as a   sinking   sort.



Because of its simplicity and ease of visualization, it is often taught in introductory computer science courses.

Because of its abysmal O(n2) performance, it is not used often for large (or even medium-sized) datasets.

The bubble sort works by passing sequentially over a list, comparing each value to the one immediately after it.   If the first value is greater than the second, their positions are switched.   Over a number of passes, at most equal to the number of elements in the list, all of the values drift into their correct positions (large values ""bubble"" rapidly toward the end, pushing others down around them).  
Because each pass finds the maximum item and puts it at the end, the portion of the list to be sorted can be reduced at each pass.  
A boolean variable is used to track whether any changes have been made in the current pass; when a pass completes without changing anything, the algorithm exits.

This can be expressed in pseudo-code as follows (assuming 1-based indexing):

repeat
    if itemCount <= 1
        return
    hasChanged := false
    decrement itemCount
    repeat with index from 1 to itemCount
        if (item at index) > (item at (index + 1))
            swap (item at index) with (item at (index + 1))
            hasChanged := true
until hasChanged = false



Task

Sort an array of elements using the bubble sort algorithm.   The elements must have a total order and the index of the array can be of any discrete type.   For languages where this is not possible, sort an array of integers.



References

 The article on Wikipedia.
 Dance interpretation.

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace RosettaCode.BubbleSort
{
    public static class BubbleSortMethods
    {
        //The ""this"" keyword before the method parameter identifies this as a C# extension
        //method, which can be called using instance method syntax on any generic list,
        //without having to modify the generic List<T> code provided by the .NET framework.
        public static void BubbleSort<T>(this List<T> list) where T : IComparable
        {
            bool madeChanges;
            int itemCount = list.Count;
            do
            {
                madeChanges = false;
                itemCount--;
                for (int i = 0; i < itemCount; i++)
                {
                    if (list[i].CompareTo(list[i + 1]) > 0)
                    {
                        T temp = list[i + 1];
                        list[i + 1] = list[i];
                        list[i] = temp;
                        madeChanges = true;
                    }
                }
            } while (madeChanges);
        }
    }
 
    //A short test program to demonstrate the BubbleSort. The compiler will change the
    //call to testList.BubbleSort() into one to BubbleSortMethods.BubbleSort<T>(testList).
    class Program
    {
        static void Main()
        {
            List<int> testList = new List<int> { 3, 7, 3, 2, 1, -4, 10, 12, 4 };
            testList.BubbleSort();
            foreach (var t in testList) Console.Write(t + "" "");
        }
    }
}",1519,44
16026,http://rosettacode.org/wiki/Sort_disjoint_sublist,Sort disjoint sublist,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Given a list of values and a set of integer indices into that value list, the task is to sort the values at the given indices, while preserving the values at indices outside the set of those to be sorted.

Make your example work with the following list of values and set of indices:

 Values: [7, 6, 5, 4, 3, 2, 1, 0]
 Indices: {6, 1, 7}
Where the correct result would be:

 [7, 0, 5, 4, 3, 2, 1, 6].
In case of one-based indexing, rather than the zero-based indexing above, you would use the indices {7, 2, 8} instead.

The indices are described as a set rather than a list but any collection-type of those indices without duplication may be used as long as the example is insensitive to the order of indices given.



Cf.
   Order disjoint list items

",#C.23,C#,"using System;
using System.Linq;
using System.Collections.Generic;
 
public class Test
{
    public static void Main()
    {
        var list = new List<int>{ 7, 6, 5, 4, 3, 2, 1, 0 };
        list.SortSublist(6, 1, 7);
        Console.WriteLine(string.Join("", "", list));
    }
}
 
public static class Extensions
{
    public static void SortSublist<T>(this List<T> list, params int[] indices)
        where T : IComparable<T>
    {
        var sublist = indices.OrderBy(i => i)
            .Zip(indices.Select(i => list[i]).OrderBy(v => v),
                (Index, Value) => new { Index, Value });
 
        foreach (var entry in sublist) {
            list[entry.Index] = entry.Value;
        }
    }
 
}",706,29
16080,http://rosettacode.org/wiki/Solve_a_Numbrix_puzzle,Solve a Numbrix puzzle,"Numbrix puzzles are similar to Hidato.
The most important difference is that it is only possible to move 1 node left, right, up, or down (sometimes referred to as the Von Neumann neighborhood).
Published puzzles also tend not to have holes in the grid and may not always indicate the end node.
Two examples follow:

Example 1
Problem.

 0  0  0  0  0  0  0  0  0
 0  0 46 45  0 55 74  0  0
 0 38  0  0 43  0  0 78  0
 0 35  0  0  0  0  0 71  0
 0  0 33  0  0  0 59  0  0
 0 17  0  0  0  0  0 67  0
 0 18  0  0 11  0  0 64  0
 0  0 24 21  0  1  2  0  0
 0  0  0  0  0  0  0  0  0

Solution.

 49 50 51 52 53 54 75 76 81
 48 47 46 45 44 55 74 77 80
 37 38 39 40 43 56 73 78 79
 36 35 34 41 42 57 72 71 70
 31 32 33 14 13 58 59 68 69
 30 17 16 15 12 61 60 67 66
 29 18 19 20 11 62 63 64 65
 28 25 24 21 10  1  2  3  4
 27 26 23 22  9  8  7  6  5

Example 2
Problem.

 0  0  0  0  0  0  0  0  0
 0 11 12 15 18 21 62 61  0
 0  6  0  0  0  0  0 60  0
 0 33  0  0  0  0  0 57  0
 0 32  0  0  0  0  0 56  0
 0 37  0  1  0  0  0 73  0
 0 38  0  0  0  0  0 72  0
 0 43 44 47 48 51 76 77  0
 0  0  0  0  0  0  0  0  0

Solution.

  9 10 13 14 19 20 63 64 65
  8 11 12 15 18 21 62 61 66
  7  6  5 16 17 22 59 60 67
 34 33  4  3 24 23 58 57 68
 35 32 31  2 25 54 55 56 69
 36 37 30  1 26 53 74 73 70
 39 38 29 28 27 52 75 72 71
 40 43 44 47 48 51 76 77 78
 41 42 45 46 49 50 81 80 79

Task
Write a program to solve puzzles of this ilk,
demonstrating your program by solving the above examples.
Extra credit for other interesting examples.



Related tasks

 A* search algorithm
 Solve a Holy Knight's tour
 Knight's tour
 N-queens problem
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Solve a Hopido puzzle
 Solve the no connection puzzle

",#C.23,C#,"using System.Collections;
using System.Collections.Generic;
using static System.Console;
using static System.Math;
using static System.Linq.Enumerable;
 
public class Solver
{
    private static readonly (int dx, int dy)[]
        //other puzzle types elided
        numbrixMoves = {(1,0),(0,1),(-1,0),(0,-1)};
 
    private (int dx, int dy)[] moves;
 
    public static void Main()
    {
        var numbrixSolver = new Solver(numbrixMoves);
        Print(numbrixSolver.Solve(false, new [,] {
            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },
            {  0,  0, 46, 45,  0, 55, 74,  0,  0 },
            {  0, 38,  0,  0, 43,  0,  0, 78,  0 },
            {  0, 35,  0,  0,  0,  0,  0, 71,  0 },
            {  0,  0, 33,  0,  0,  0, 59,  0,  0 },
            {  0, 17,  0,  0,  0,  0,  0, 67,  0 },
            {  0, 18,  0,  0, 11,  0,  0, 64,  0 },
            {  0,  0, 24, 21,  0,  1,  2,  0,  0 },
            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },
        }));
 
        Print(numbrixSolver.Solve(false, new [,] {
            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },
            {  0, 11, 12, 15, 18, 21, 62, 61,  0 },
            {  0,  6,  0,  0,  0,  0,  0, 60,  0 },
            {  0, 33,  0,  0,  0,  0,  0, 57,  0 },
            {  0, 32,  0,  0,  0,  0,  0, 56,  0 },
            {  0, 37,  0,  1,  0,  0,  0, 73,  0 },
            {  0, 38,  0,  0,  0,  0,  0, 72,  0 },
            {  0, 43, 44, 47, 48, 51, 76, 77,  0 },
            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },
        }));
    }
 
    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;
 
    public int[,] Solve(bool circular, params string[] puzzle)
    {
        var (board, given, count) = Parse(puzzle);
        return Solve(board, given, count, circular);
    }
 
    public int[,] Solve(bool circular, int[,] puzzle)
    {
        var (board, given, count) = Parse(puzzle);
        return Solve(board, given, count, circular);
    }
 
    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)
    {
        var (height, width) = (board.GetLength(0), board.GetLength(1));
        bool solved = false;
        for (int x = 0; x < height && !solved; x++) {
            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));
            if (solved) return board;
        }
        return null;
    }
 
    private bool Solve(int[,] board, BitArray given, bool circular,
        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)
    {
        var (x, y) = current;
        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;
        if (board[x, y] < 0) return false;
        if (given[n - 1]) {
            if (board[x, y] != n) return false;
        } else if (board[x, y] > 0) return false;
        board[x, y] = n;
        if (n == last) {
            if (!circular || AreNeighbors(start, current)) return true;
        }
        for (int i = 0; i < moves.Length; i++) {
            var move = moves[i];
            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;
        }
        if (!given[n - 1]) board[x, y] = 0;
        return false;
 
        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));
    }
 
    private static (int[,] board, BitArray given, int count) Parse(string[] input)
    {
        (int height, int width) = (input.Length, input[0].Length);
        int[,] board = new int[height, width];
        int count = 0;
        for (int x = 0; x < height; x++) {
            string line = input[x];
            for (int y = 0; y < width; y++) {
                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;
                if (board[x, y] >= 0) count++;
            }
        }
        BitArray given = Scan(board, count, height, width);
        return (board, given, count);
    }
 
    private static (int[,] board, BitArray given, int count) Parse(int[,] input)
    {
        (int height, int width) = (input.GetLength(0), input.GetLength(1));
        int[,] board = new int[height, width];
        int count = 0;
        for (int x = 0; x < height; x++)
            for (int y = 0; y < width; y++)
                if ((board[x, y] = input[x, y]) >= 0) count++;
        BitArray given = Scan(board, count, height, width);
        return (board, given, count);
    }
 
    private static BitArray Scan(int[,] board, int count, int height, int width)
    {
        var given = new BitArray(count + 1);
        for (int x = 0; x < height; x++)
            for (int y = 0; y < width; y++)
                if (board[x, y] > 0) given[board[x, y] - 1] = true;
        return given;
    }
 
    private static void Print(int[,] board)
    {
        if (board == null) {
            WriteLine(""No solution"");
        } else {
            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;
            string e = new string('-', w);
            foreach (int x in Range(0, board.GetLength(0)))
                WriteLine(string.Join("" "", Range(0, board.GetLength(1))
                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));
        }
        WriteLine();
    }
 
}",5327,142
16105,http://rosettacode.org/wiki/Sort_a_list_of_object_identifiers,Sort a list of object identifiers,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Object identifiers (OID)


Task

Show how to sort a list of OIDs, in their natural sort order.

Details
 An OID consists of one or more non-negative integers in base 10, separated by dots. It starts and ends with a number.
 Their natural sort order is lexicographical with regard to the dot-separated fields, using numeric comparison between fields.
Test case


 Input (list of strings)

 Output (list of strings)



1.3.6.1.4.1.11.2.17.19.3.4.0.10
1.3.6.1.4.1.11.2.17.5.2.0.79
1.3.6.1.4.1.11.2.17.19.3.4.0.4
1.3.6.1.4.1.11150.3.4.0.1
1.3.6.1.4.1.11.2.17.19.3.4.0.1
1.3.6.1.4.1.11150.3.4.0



1.3.6.1.4.1.11.2.17.5.2.0.79
1.3.6.1.4.1.11.2.17.19.3.4.0.1
1.3.6.1.4.1.11.2.17.19.3.4.0.4
1.3.6.1.4.1.11.2.17.19.3.4.0.10
1.3.6.1.4.1.11150.3.4.0
1.3.6.1.4.1.11150.3.4.0.1


Related tasks
 Natural sorting
 Sort using a custom comparator
",#C.23,C#,"using System;
using System.Linq;
using System.Collections.Generic;
 
public class Program
{
    public static void Main() {
        var oids = new [] {
            ""1.3.6.1.4.1.11.2.17.19.3.4.0.10"",
            ""1.3.6.1.4.1.11.2.17.5.2.0.79"",
            ""1.3.6.1.4.1.11.2.17.19.3.4.0.4"",
            ""1.3.6.1.4.1.11150.3.4.0.1"",
            ""1.3.6.1.4.1.11.2.17.19.3.4.0.1"",
            ""1.3.6.1.4.1.11150.3.4.0""
        };
 
        var comparer = Comparer<string>.Create((a, b) => {
            int c = a.Split('.').Select(int.Parse)
	        .Zip(b.Split('.').Select(int.Parse),
                    (i, j) => i.CompareTo(j)).FirstOrDefault(x => x != 0);
            return c != 0 ? c : a.Length.CompareTo(b.Length);
        });
 
        Array.Sort(oids, comparer);
 
        Console.WriteLine(string.Join(Environment.NewLine, oids));
    }
}",846,28
16147,http://rosettacode.org/wiki/Solve_a_Hopido_puzzle,Solve a Hopido puzzle,"Hopido puzzles are similar to  Hidato. The most important difference is that the only moves allowed are: hop over one tile diagonally; and over two tiles horizontally and vertically. It should be possible to start anywhere in the path, the end point isn't indicated and there are no intermediate clues. Hopido Design Post Mortem contains the following:

""Big puzzles represented another problem. Up until quite late in the project our puzzle solver was painfully slow with most puzzles above 7×7 tiles. Testing the solution from each starting point could take hours. If the tile layout was changed even a little, the whole puzzle had to be tested again. We were just about to give up the biggest puzzles entirely when our programmer suddenly came up with a magical algorithm that cut the testing process down to only minutes. Hooray!""

Knowing the kindness in the heart of every contributor to Rosetta Code, I know that we shall feel that as an act of humanity we must solve these puzzles for them in let's say milliseconds.

Example:

. 0 0 . 0 0 .
0 0 0 0 0 0 0
0 0 0 0 0 0 0
. 0 0 0 0 0 .
. . 0 0 0 . .
. . . 0 . . .

Extra credits are available for other interesting designs.



Related tasks

 A* search algorithm
 Solve a Holy Knight's tour
 Knight's tour
 N-queens problem
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Solve a Numbrix puzzle
 Solve the no connection puzzle

",#C.23,C#,"using System.Collections;
using System.Collections.Generic;
using static System.Console;
using static System.Math;
using static System.Linq.Enumerable;
 
public class Solver
{
    private static readonly (int dx, int dy)[]
        //other puzzle types elided
        hopidoMoves = {(-3,0),(0,-3),(0,3),(3,0),(-2,-2),(-2,2),(2,-2),(2,2)},
 
    private (int dx, int dy)[] moves;
 
    public static void Main()
    {
        Print(new Solver(hopidoMoves).Solve(false,
            "".00.00."",
            ""0000000"",
            ""0000000"",
            "".00000."",
            ""..000.."",
            ""...0...""
        ));
    }
 
    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;
 
    public int[,] Solve(bool circular, params string[] puzzle)
    {
        var (board, given, count) = Parse(puzzle);
        return Solve(board, given, count, circular);
    }
 
    public int[,] Solve(bool circular, int[,] puzzle)
    {
        var (board, given, count) = Parse(puzzle);
        return Solve(board, given, count, circular);
    }
 
    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)
    {
        var (height, width) = (board.GetLength(0), board.GetLength(1));
        bool solved = false;
        for (int x = 0; x < height && !solved; x++) {
            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));
            if (solved) return board;
        }
        return null;
    }
 
    private bool Solve(int[,] board, BitArray given, bool circular,
        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)
    {
        var (x, y) = current;
        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;
        if (board[x, y] < 0) return false;
        if (given[n - 1]) {
            if (board[x, y] != n) return false;
        } else if (board[x, y] > 0) return false;
        board[x, y] = n;
        if (n == last) {
            if (!circular || AreNeighbors(start, current)) return true;
        }
        for (int i = 0; i < moves.Length; i++) {
            var move = moves[i];
            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;
        }
        if (!given[n - 1]) board[x, y] = 0;
        return false;
 
        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));
    }
 
    private static (int[,] board, BitArray given, int count) Parse(string[] input)
    {
        (int height, int width) = (input.Length, input[0].Length);
        int[,] board = new int[height, width];
        int count = 0;
        for (int x = 0; x < height; x++) {
            string line = input[x];
            for (int y = 0; y < width; y++) {
                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;
                if (board[x, y] >= 0) count++;
            }
        }
        BitArray given = Scan(board, count, height, width);
        return (board, given, count);
    }
 
    private static (int[,] board, BitArray given, int count) Parse(int[,] input)
    {
        (int height, int width) = (input.GetLength(0), input.GetLength(1));
        int[,] board = new int[height, width];
        int count = 0;
        for (int x = 0; x < height; x++)
            for (int y = 0; y < width; y++)
                if ((board[x, y] = input[x, y]) >= 0) count++;
        BitArray given = Scan(board, count, height, width);
        return (board, given, count);
    }
 
    private static BitArray Scan(int[,] board, int count, int height, int width)
    {
        var given = new BitArray(count + 1);
        for (int x = 0; x < height; x++)
            for (int y = 0; y < width; y++)
                if (board[x, y] > 0) given[board[x, y] - 1] = true;
        return given;
    }
 
    private static void Print(int[,] board)
    {
        if (board == null) {
            WriteLine(""No solution"");
        } else {
            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;
            string e = new string('-', w);
            foreach (int x in Range(0, board.GetLength(0)))
                WriteLine(string.Join("" "", Range(0, board.GetLength(1))
                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));
        }
        WriteLine();
    }
 
}",4434,126
16243,http://rosettacode.org/wiki/Solve_a_Holy_Knight%27s_tour,Solve a Holy Knight's tour,"
Chess coaches have been known to inflict a kind of torture on beginners by taking a chess board, placing pennies on some squares and requiring that a Knight's tour be constructed that avoids the squares with pennies.

This kind of knight's tour puzzle is similar to   Hidato.

The present task is to produce a solution to such problems. At least demonstrate your program by solving the following:



Example

  0 0 0 
  0   0 0 
  0 0 0 0 0 0 0
0 0 0     0   0
0   0     0 0 0
1 0 0 0 0 0 0
    0 0   0
      0 0 0

Note that the zeros represent the available squares, not the pennies.

Extra credit is available for other interesting examples.



Related tasks

 A* search algorithm
 Knight's tour
 N-queens problem
 Solve a Hidato puzzle
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle

",#C.23,C#,"using System.Collections;
using System.Collections.Generic;
using static System.Console;
using static System.Math;
using static System.Linq.Enumerable;
 
public class Solver
{
    private static readonly (int dx, int dy)[]
        //other puzzle types elided
        knightMoves = {(1,-2),(2,-1),(2,1),(1,2),(-1,2),(-2,1),(-2,-1),(-1,-2)};
 
    private (int dx, int dy)[] moves;
 
    public static void Main()
    {
        var knightSolver = new Solver(knightMoves);
        Print(knightSolver.Solve(true,
            "".000...."",
            "".0.00..."",
            "".0000000"",
            ""000..0.0"",
            ""0.0..000"",
            ""1000000."",
            ""..00.0.."",
            ""...000..""));
 
        Print(knightSolver.Solve(true,
            "".....0.0....."",
            "".....0.0....."",
            ""....00000...."",
            "".....000....."",
            ""..0..0.0..0.."",
            ""00000...00000"",
            ""..00.....00.."",
            ""00000...00000"",
            ""..0..0.0..0.."",
            "".....000....."",
            ""....00000...."",
            "".....0.0....."",
            "".....0.0....."" 
        ));
    }
 
    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;
 
    public int[,] Solve(bool circular, params string[] puzzle)
    {
        var (board, given, count) = Parse(puzzle);
        return Solve(board, given, count, circular);
    }
 
    public int[,] Solve(bool circular, int[,] puzzle)
    {
        var (board, given, count) = Parse(puzzle);
        return Solve(board, given, count, circular);
    }
 
    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)
    {
        var (height, width) = (board.GetLength(0), board.GetLength(1));
        bool solved = false;
        for (int x = 0; x < height && !solved; x++) {
            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));
            if (solved) return board;
        }
        return null;
    }
 
    private bool Solve(int[,] board, BitArray given, bool circular,
        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)
    {
        var (x, y) = current;
        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;
        if (board[x, y] < 0) return false;
        if (given[n - 1]) {
            if (board[x, y] != n) return false;
        } else if (board[x, y] > 0) return false;
        board[x, y] = n;
        if (n == last) {
            if (!circular || AreNeighbors(start, current)) return true;
        }
        for (int i = 0; i < moves.Length; i++) {
            var move = moves[i];
            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;
        }
        if (!given[n - 1]) board[x, y] = 0;
        return false;
 
        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));
    }
 
    private static (int[,] board, BitArray given, int count) Parse(string[] input)
    {
        (int height, int width) = (input.Length, input[0].Length);
        int[,] board = new int[height, width];
        int count = 0;
        for (int x = 0; x < height; x++) {
            string line = input[x];
            for (int y = 0; y < width; y++) {
                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;
                if (board[x, y] >= 0) count++;
            }
        }
        BitArray given = Scan(board, count, height, width);
        return (board, given, count);
    }
 
    private static (int[,] board, BitArray given, int count) Parse(int[,] input)
    {
        (int height, int width) = (input.GetLength(0), input.GetLength(1));
        int[,] board = new int[height, width];
        int count = 0;
        for (int x = 0; x < height; x++)
            for (int y = 0; y < width; y++)
                if ((board[x, y] = input[x, y]) >= 0) count++;
        BitArray given = Scan(board, count, height, width);
        return (board, given, count);
    }
 
    private static BitArray Scan(int[,] board, int count, int height, int width)
    {
        var given = new BitArray(count + 1);
        for (int x = 0; x < height; x++)
            for (int y = 0; y < width; y++)
                if (board[x, y] > 0) given[board[x, y] - 1] = true;
        return given;
    }
 
    private static void Print(int[,] board)
    {
        if (board == null) {
            WriteLine(""No solution"");
        } else {
            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;
            string e = new string('-', w);
            foreach (int x in Range(0, board.GetLength(0)))
                WriteLine(string.Join("" "", Range(0, board.GetLength(1))
                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));
        }
        WriteLine();
    }
 
}",4951,144
16252,http://rosettacode.org/wiki/Sort_an_integer_array,Sort an integer array,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array (or list) of integers in ascending numerical order.



Use a sorting facility provided by the language/library if possible.



",#C.23,C#,"using System;
using System.Collections.Generic;
 
public class Program {
    static void Main() {
        int[] unsorted = { 6, 2, 7, 8, 3, 1, 10, 5, 4, 9 };
        Array.Sort(unsorted);
    }
}",195,9
16314,http://rosettacode.org/wiki/Sort_an_array_of_composite_structures,Sort an array of composite structures,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Sort an array of composite structures by a key.



For example, if you define a composite structure that presents a name-value pair (in pseudo-code):

Define structure pair such that: 
   name as a string
   value as a string

and an array of such pairs:

   x: array of pairs

then define a sort routine that sorts the array x by the key name.

This task can always be accomplished with Sorting Using a Custom Comparator.

If your language is not listed here, please see the other article.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
class Program
{        
    struct Entry
    {
        public Entry(string name, double value) { Name = name; Value = value; }
        public string Name;
        public double Value;
    }
 
    static void Main(string[] args)
    {
        var Elements = new List<Entry>
        {
            new Entry(""Krypton"", 83.798), new Entry(""Beryllium"", 9.012182), new Entry(""Silicon"", 28.0855),
            new Entry(""Cobalt"", 58.933195), new Entry(""Selenium"", 78.96), new Entry(""Germanium"", 72.64)
        };
 
        var sortedElements = Elements.OrderBy(e => e.Name);
 
        foreach (Entry e in sortedElements)
            Console.WriteLine(""{0,-11}{1}"", e.Name, e.Value);
    }
}",751,27
16405,http://rosettacode.org/wiki/Sokoban,Sokoban,"Demonstrate how to find a solution to a given Sokoban level. For the purpose of this task (formally, a PSPACE-complete problem) any method may be used. However a move-optimal or push-optimal (or any other -optimal) solutions is preferred.

Sokoban levels are usually stored as a character array where

 space is an empty square
 # is a wall
 @ is the player
 $ is a box
 . is a goal
 + is the player on a goal
 * is a box on a goal
#######
#     #
#     #
#. #  #
#. $$ #
#.$$  #
#.#  @#
#######
Sokoban solutions are usually stored in the LURD format, where lowercase l, u, r and d represent a move in that (left, up, right, down) direction and capital LURD represents a push.

Please state if you use some other format for either the input or output, and why.

For more information, see the Sokoban wiki.


",#C.23,C#,"using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace SokobanSolver
{
    public class SokobanSolver
    {
        private class Board
        {
            public string Cur { get; internal set; }
            public string Sol { get; internal set; }
            public int X { get; internal set; }
            public int Y { get; internal set; }
 
            public Board(string cur, string sol, int x, int y)
            {
                Cur = cur;
                Sol = sol;
                X = x;
                Y = y;
            }
        }
 
        private string destBoard, currBoard;
        private int playerX, playerY, nCols;
 
        SokobanSolver(string[] board)
        {
            nCols = board[0].Length;
            StringBuilder destBuf = new StringBuilder();
            StringBuilder currBuf = new StringBuilder();
 
            for (int r = 0; r < board.Length; r++)
            {
                for (int c = 0; c < nCols; c++)
                {
 
                    char ch = board[r][c];
 
                    destBuf.Append(ch != '$' && ch != '@' ? ch : ' ');
                    currBuf.Append(ch != '.' ? ch : ' ');
 
                    if (ch == '@')
                    {
                        this.playerX = c;
                        this.playerY = r;
                    }
                }
            }
            destBoard = destBuf.ToString();
            currBoard = currBuf.ToString();
        }
 
        private string Move(int x, int y, int dx, int dy, string trialBoard)
        {
 
            int newPlayerPos = (y + dy) * nCols + x + dx;
 
            if (trialBoard[newPlayerPos] != ' ')
                return null;
 
            char[] trial = trialBoard.ToCharArray();
            trial[y * nCols + x] = ' ';
            trial[newPlayerPos] = '@';
 
            return new string(trial);
        }
 
        private string Push(int x, int y, int dx, int dy, string trialBoard)
        {
 
            int newBoxPos = (y + 2 * dy) * nCols + x + 2 * dx;
 
            if (trialBoard[newBoxPos] != ' ')
                return null;
 
            char[] trial = trialBoard.ToCharArray();
            trial[y * nCols + x] = ' ';
            trial[(y + dy) * nCols + x + dx] = '@';
            trial[newBoxPos] = '$';
 
            return new string(trial);
        }
 
        private bool IsSolved(string trialBoard)
        {
            for (int i = 0; i < trialBoard.Length; i++)
                if ((destBoard[i] == '.')
                        != (trialBoard[i] == '$'))
                    return false;
            return true;
        }
 
        private string Solve()
        {
            char[,] dirLabels = { { 'u', 'U' }, { 'r', 'R' }, { 'd', 'D' }, { 'l', 'L' } };
            int[,] dirs = { { 0, -1 }, { 1, 0 }, { 0, 1 }, { -1, 0 } };
            ISet<string> history = new HashSet<string>();
            LinkedList<Board> open = new LinkedList<Board>();
 
            history.Add(currBoard);
            open.AddLast(new Board(currBoard, string.Empty, playerX, playerY));
 
            while (!open.Count.Equals(0))
            {
                Board item = open.First();
                open.RemoveFirst();
                string cur = item.Cur;
                string sol = item.Sol;
                int x = item.X;
                int y = item.Y;
 
                for (int i = 0; i < dirs.GetLength(0); i++)
                {
                    string trial = cur;
                    int dx = dirs[i, 0];
                    int dy = dirs[i, 1];
 
                    // are we standing next to a box ?
                    if (trial[(y + dy) * nCols + x + dx] == '$')
                    {
                        // can we push it ?
                        if ((trial = Push(x, y, dx, dy, trial)) != null)
                        {
                            // or did we already try this one ?
                            if (!history.Contains(trial))
                            {
 
                                string newSol = sol + dirLabels[i, 1];
 
                                if (IsSolved(trial))
                                    return newSol;
 
                                open.AddLast(new Board(trial, newSol, x + dx, y + dy));
                                history.Add(trial);
                            }
                        }
                        // otherwise try changing position
                    }
                    else if ((trial = Move(x, y, dx, dy, trial)) != null)
                    {
                        if (!history.Contains(trial))
                        {
                            string newSol = sol + dirLabels[i, 0];
                            open.AddLast(new Board(trial, newSol, x + dx, y + dy));
                            history.Add(trial);
                        }
                    }
                }
            }
            return ""No solution"";
        }
 
        public static void Main(string[] a)
        {
            string level = ""#######,"" +
                           ""#     #,"" +
                           ""#     #,"" +
                           ""#. #  #,"" +
                           ""#. $$ #,"" +
                           ""#.$$  #,"" +
                           ""#.#  @#,"" +
                           ""#######"";
            System.Console.WriteLine(""Level:\n"");
            foreach (string line in level.Split(','))
            {
                System.Console.WriteLine(line);
            }
            System.Console.WriteLine(""\nSolution:\n"");
            System.Console.WriteLine(new SokobanSolver(level.Split(',')).Solve());
        }
    }
}",5664,174
16495,http://rosettacode.org/wiki/Sockets,Sockets,"For this exercise a program is open a socket to localhost on port 256 and send the message ""hello socket world"" before closing the socket.

Catching any exceptions or errors is not required.



",#C.23,C#,"using System;
using System.IO;
using System.Net.Sockets;
 
class Program {
    static void Main(string[] args) {
        TcpClient tcp = new TcpClient(""localhost"", 256);
        StreamWriter writer = new StreamWriter(tcp.GetStream());
 
        writer.Write(""hello socket world"");
        writer.Flush();
 
        tcp.Close();
    }
}",335,15
16600,http://rosettacode.org/wiki/Solve_a_Hidato_puzzle,Solve a Hidato puzzle,"The task is to write a program which solves Hidato (aka Hidoku) puzzles.

The rules are:

 You are given a grid with some numbers placed in it. The other squares in the grid will be blank.
 The grid is not necessarily rectangular.
 The grid may have holes in it.
 The grid is always connected.
 The number “1” is always present, as is another number that is equal to the number of squares in the grid. Other numbers are present so as to force the solution to be unique.
 It may be assumed that the difference between numbers present on the grid is not greater than lucky 13.
 The aim is to place a natural number in each blank square so that in the sequence of numbered squares from “1” upwards, each square is in the wp:Moore neighborhood of the squares immediately before and after it in the sequence (except for the first and last squares, of course, which only have one-sided constraints).
 Thus, if the grid was overlaid on a chessboard, a king would be able to make legal moves along the path from first to last square in numerical order.
 A square may only contain one number.
 In a proper Hidato puzzle, the solution is unique.

For example the following problem


has the following solution, with path marked on it:




Related tasks

 A* search algorithm
 N-queens problem
 Solve a Holy Knight's tour
 Solve a Knight's tour
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle;

",#C.23,C#,"using System.Collections;
using System.Collections.Generic;
using static System.Console;
using static System.Math;
using static System.Linq.Enumerable;
 
public class Solver
{
    private static readonly (int dx, int dy)[]
        //other puzzle types elided
        hidatoMoves = {(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)};
 
    private (int dx, int dy)[] moves;
 
    public static void Main()
    {
        Print(new Solver(hidatoMoves).Solve(false, new [,] {
            {  0, 33, 35,  0,  0, -1, -1, -1 },
            {  0,  0, 24, 22,  0, -1, -1, -1 },
            {  0,  0,  0, 21,  0,  0, -1, -1 },
            {  0, 26,  0, 13, 40, 11, -1, -1 },
            { 27,  0,  0,  0,  9,  0,  1, -1 },
            { -1, -1,  0,  0, 18,  0,  0, -1 },
            { -1, -1, -1, -1,  0,  7,  0,  0 },
            { -1, -1, -1, -1, -1, -1,  5,  0 }
        }));
    }
 
    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;
 
    public int[,] Solve(bool circular, params string[] puzzle)
    {
        var (board, given, count) = Parse(puzzle);
        return Solve(board, given, count, circular);
    }
 
    public int[,] Solve(bool circular, int[,] puzzle)
    {
        var (board, given, count) = Parse(puzzle);
        return Solve(board, given, count, circular);
    }
 
    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)
    {
        var (height, width) = (board.GetLength(0), board.GetLength(1));
        bool solved = false;
        for (int x = 0; x < height && !solved; x++) {
            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));
            if (solved) return board;
        }
        return null;
    }
 
    private bool Solve(int[,] board, BitArray given, bool circular,
        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)
    {
        var (x, y) = current;
        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;
        if (board[x, y] < 0) return false;
        if (given[n - 1]) {
            if (board[x, y] != n) return false;
        } else if (board[x, y] > 0) return false;
        board[x, y] = n;
        if (n == last) {
            if (!circular || AreNeighbors(start, current)) return true;
        }
        for (int i = 0; i < moves.Length; i++) {
            var move = moves[i];
            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;
        }
        if (!given[n - 1]) board[x, y] = 0;
        return false;
 
        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));
    }
 
    private static (int[,] board, BitArray given, int count) Parse(string[] input)
    {
        (int height, int width) = (input.Length, input[0].Length);
        int[,] board = new int[height, width];
        int count = 0;
        for (int x = 0; x < height; x++) {
            string line = input[x];
            for (int y = 0; y < width; y++) {
                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;
                if (board[x, y] >= 0) count++;
            }
        }
        BitArray given = Scan(board, count, height, width);
        return (board, given, count);
    }
 
    private static (int[,] board, BitArray given, int count) Parse(int[,] input)
    {
        (int height, int width) = (input.GetLength(0), input.GetLength(1));
        int[,] board = new int[height, width];
        int count = 0;
        for (int x = 0; x < height; x++)
            for (int y = 0; y < width; y++)
                if ((board[x, y] = input[x, y]) >= 0) count++;
        BitArray given = Scan(board, count, height, width);
        return (board, given, count);
    }
 
    private static BitArray Scan(int[,] board, int count, int height, int width)
    {
        var given = new BitArray(count + 1);
        for (int x = 0; x < height; x++)
            for (int y = 0; y < width; y++)
                if (board[x, y] > 0) given[board[x, y] - 1] = true;
        return given;
    }
 
    private static void Print(int[,] board)
    {
        if (board == null) {
            WriteLine(""No solution"");
        } else {
            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;
            string e = new string('-', w);
            foreach (int x in Range(0, board.GetLength(0)))
                WriteLine(string.Join("" "", Range(0, board.GetLength(1))
                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));
        }
        WriteLine();
    }
 
}",4691,128
16778,http://rosettacode.org/wiki/Smith_numbers,Smith numbers,"Smith numbers are numbers such that the sum of the decimal digits of the integers that make up that number is the same as the sum of the decimal digits of its prime factors excluding 1.

By definition, all primes are excluded as they (naturally) satisfy this condition!

Smith numbers are also known as   joke   numbers.



Example
Using the number 166

Find the prime factors of 166 which are: 2 x 83

Then, take those two prime factors and sum all their decimal digits: 2 + 8 + 3 which is 13

Then, take the decimal digits of 166 and add their decimal digits: 1 + 6 + 6 which is 13

Therefore, the number 166 is a Smith number.



Task
Write a program to find all Smith numbers below 10000.



See also
 from Wikipedia:   [Smith number].
 from MathWorld:   [Smith number]. 
 from OEIS A6753:   [OEIS sequence A6753].
 from OEIS A104170:   [Number of Smith numbers below 10^n]. 
 from The Prime pages:   [Smith numbers].

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace SmithNumbers {
    class Program {
        static int SumDigits(int n) {
            int sum = 0;
            while (n > 0) {
                n = Math.DivRem(n, 10, out int rem);
                sum += rem;
            }
            return sum;
        }
 
        static List<int> PrimeFactors(int n) {
            List<int> result = new List<int>();
 
            for (int i = 2; n % i == 0; n /= i) {
                result.Add(i);
            }
 
            for (int i = 3; i * i < n; i += 2) {
                while (n % i == 0) {
                    result.Add(i);
                    n /= i;
                }
            }
 
            if (n != 1) {
                result.Add(n);
            }
 
            return result;
        }
 
        static void Main(string[] args) {
            const int SIZE = 8;
            int count = 0;
            for (int n = 1; n < 10_000; n++) {
                var factors = PrimeFactors(n);
                if (factors.Count > 1) {
                    int sum = SumDigits(n);
                    foreach (var f in factors) {
                        sum -= SumDigits(f);
                    }
                    if (sum == 0) {
                        Console.Write(""{0,5}"", n);
                        if (count == SIZE - 1) {
                            Console.WriteLine();
                        }
                        count = (count + 1) % SIZE;
                    }
                }
            }
        }
    }
}",1536,57
17248,http://rosettacode.org/wiki/Singleton,Singleton,"A Global Singleton is a class of which only one instance exists within a program.

Any attempt to use non-static members of the class involves performing operations on this one instance.



",#C.23,C#,"public sealed class Singleton1 //Lazy: Yes ||| Thread-safe: Yes ||| Uses locking: Yes
{
    private static Singleton1 instance;
    private static readonly object lockObj = new object();
 
    public static Singleton1 Instance {
        get {
            lock(lockObj) {
                if (instance == null) {
                    instance = new Singleton1();
                }
            }
            return instance;
        }
    }
}",438,16
17430,http://rosettacode.org/wiki/Singly-linked_list/Element_definition,Singly-linked list/Element definition,"singly-linked list
See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack",#C.23,C#,"class LinkedListNode
{
    public int Value { get; set; }
    public LinkedListNode Next { get; set; }
 
    // A constructor is not necessary, but could be useful.
    public Link(int value, LinkedListNode next = null)
    {
        Item = value;
        Next = next;
    }
}",276,12
17464,http://rosettacode.org/wiki/Singly-linked_list/Traversal,Singly-linked list/Traversal,"Traverse from the beginning of a singly-linked list to the end.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#C.23,C#,"var current = [head of list to traverse]
while(current != null)
{
    // Do something with current.Value.
 
    current = current.Next;
}",137,7
17491,http://rosettacode.org/wiki/Singly-linked_list/Element_insertion,Singly-linked list/Element insertion,"Singly-Linked List (element)
singly-linked list
Using this method, insert an element C into a list comprised of elements A->B, following element A.

See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#C.23,C#,"static void InsertAfter<T>(LinkedListNode<T> prev, T value)
{
    prev.Next = new Link() { Value = value, Next = prev.Next };
}",127,4
17517,http://rosettacode.org/wiki/Sleep,Sleep,"Task

Write a program that does the following in this order:

 Input an amount of time to sleep in whatever units are most natural for your language (milliseconds, seconds, ticks, etc.). This unit should be noted in comments or in a description.
 Print ""Sleeping...""
 Sleep the main thread for the given amount of time.
 Print ""Awake!""
 End.


Related task

   Nautical bell

",#C.23,C#,"using System;
using System.Threading;
 
class Program
{
    static void Main(string[] args)
    {
        int sleep = Convert.ToInt32(Console.ReadLine());
        Console.WriteLine(""Sleeping..."");
        Thread.Sleep(sleep); //milliseconds
        Console.WriteLine(""Awake!"");
    }
}",285,13
17621,http://rosettacode.org/wiki/Simple_windowed_application,Simple windowed application,"Task

Create a window that has:

   a label that says   ""There have been no clicks yet"" 
   a button that says   ""click me""


Upon clicking the button with the mouse, the label should change and show the number of times the button has been clicked.



",#C.23,C#,"using System.Windows.Forms;
 
class RosettaForm : Form
{
    RosettaForm()
    {
        var clickCount = 0;
 
        var label = new Label();
        label.Text = ""There have been no clicks yet."";
        label.Dock = DockStyle.Top;
        Controls.Add(label);
 
        var button = new Button();
        button.Text = ""Click Me"";
        button.Dock = DockStyle.Bottom;
        button.Click += delegate
                        {
                            clickCount++;
                            label.Text = ""Number of clicks: "" + clickCount + ""."";
                        };
        Controls.Add(button);
    }
 
    static void Main()
    {
        Application.Run(new RosettaForm());
    }
}
 ",705,30
18003,http://rosettacode.org/wiki/Show_the_epoch,Show the epoch,"Task
 
Choose popular date libraries used by your language and show the   epoch   those libraries use.

A demonstration is preferable   (e.g. setting the internal representation of the date to 0 ms/ns/etc.,   or another way that will still show the epoch even if it is changed behind the scenes by the implementers),   but text from (with links to) documentation is also acceptable where a demonstration is impossible/impractical.

For consistency's sake, show the date in UTC time where possible.



Related task

   Date format

",#C.23,C#,"using System;
 
class Program
{
    static void Main()
    {
        Console.WriteLine(new DateTime());
    }
}",111,9
18007,http://rosettacode.org/wiki/Sierpinski_triangle,Sierpinski triangle,"Task
Produce an ASCII representation of a Sierpinski triangle of order   N.



Example
The Sierpinski triangle of order   4   should look like this:

                       *
                      * *
                     *   *
                    * * * *
                   *       *
                  * *     * *
                 *   *   *   *
                * * * * * * * *
               *               *
              * *             * *
             *   *           *   *
            * * * *         * * * *
           *       *       *       *
          * *     * *     * *     * *
         *   *   *   *   *   *   *   *
        * * * * * * * * * * * * * * * *



Related tasks
 Sierpinski triangle/Graphical for graphics images of this pattern. 
 Sierpinski carpet

",#C.23,C#,"using System;
using System.Collections;
 
namespace RosettaCode {
    class SierpinskiTriangle {
        int len;
        BitArray b;
 
        public SierpinskiTriangle(int n) {
            if (n < 1) {
                throw new ArgumentOutOfRangeException(""Order must be greater than zero"");
            }
            len = 1 << (n+1);
            b = new BitArray(len+1, false);
            b[len>>1] = true;
        }
 
        public void Display() {
            for (int j = 0; j < len / 2; j++) {
                for (int i = 0; i < b.Count; i++) {
                    Console.Write(""{0}"", b[i] ? ""*"" : "" "");
                }
                Console.WriteLine();
                NextGen();
            }
        }
 
        private void NextGen() {
            BitArray next = new BitArray(b.Count, false);
            for (int i = 0; i < b.Count; i++) {
                if (b[i]) {
                    next[i - 1] = next[i - 1] ^ true;
                    next[i + 1] = next[i + 1] ^ true;
                }
            }
            b = next;
        }
    }
}",1070,39
18055,http://rosettacode.org/wiki/Simple_database,Simple database,"Task

Write a simple tool to track a small set of data.

The tool should have a command-line interface to enter at least two different values.

The entered data should be stored in a structured format and saved to disk.

It does not matter what kind of data is being tracked.   It could be a collection (CDs, coins, baseball cards, books), a diary, an electronic organizer (birthdays/anniversaries/phone numbers/addresses), etc.



You should track the following details:

 A description of the item. (e.g., title, name)
 A category or tag (genre, topic, relationship such as “friend” or “family”)
 A date (either the date when the entry was made or some other date that is meaningful, like the birthday); the date may be generated or entered manually
 Other optional fields


The command should support the following Command-line arguments to run:

 Add a new entry
 Print the latest entry
 Print the latest entry for each category
 Print all entries sorted by a date


The category may be realized as a tag or as structure (by making all entries in that category subitems)

The file format on disk should be human readable, but it need not be standardized.   A natively available format that doesn't need an external library is preferred.   Avoid developing your own format if you can use an already existing one.   If there is no existing format available, pick one of:

   JSON
   S-Expressions
   YAML
   others


Related task

   Take notes on the command line 

",#C.23,C#," 
using System;
using System.IO;
 
namespace Simple_database
{
	class Program
	{
		public static void Main(string[] args)
		{
			//
			// For appropriate use of this program
			// use standard Windows Command Processor or cmd.exe
			//
			// Create cmd.bat file at the same folder with executive version
			// of program Simple_database.exe, so when started, the correct
			// file path will be automatically set to cmd console.
			//
			// Start notepad, write only cmd.exe and save file as cmd.bat
			// 
			// To start cmd just double click at cmd.bat file.
			//
			//
			//
			// Console application command line start command
			// 
			// application name.exe [argument] [argument parameters]
			//
			//
			// Command line argument followed by parameters
			//
			// [a] - Add new entry
			//
			// [""data1""][""data2""][""data3""]...[""data n""]
			//
			// [""data1""] - Data category !
			// [""data2""] - Data
			// [""data3""] - Data
			//
			//
			// NOTICE !
			//
			// First parameter is taken for data category.
			//
			//
			//
			// Command line argument with no parameters
			//
			// [p1] - Print the latest entry
			//
			// [p2] - Print the latest entry for each category
			//
			// [p3] - Print all entries sorted by a date
			//
			//
			//
 
			//
			// Command line example
			//
			// Small_database.exe [a] [""home""] [""+398125465458""] [""My tel number""]
			//
			// Small_database.exe [a] [""office""] [""+398222789000""] [""Boss""]
			//
			// Small_database.exe [a] [cd] [""Action movie""] [""Movie title""]
			// Small_database.exe [a] [cd] [""SF movie""] [""Movie title""]
			// Small_database.exe [a] [dvd] [""Action movie""] [""Movie title""]
			//
			//
			// NOTICE !
			//
			// Brackets and space between arguments and parameters are necessary.
			// Quotes must be used when parameters have more than one word.
			//
			// If not used as shown in examples, program will show error message.
			//
			//
 
 
			//
			// Check command line for arguments
			// 
			//
			if(args.Length==0)
			{
				Console.WriteLine();
				Console.WriteLine("" Missing Argument Error. "");
				Console.WriteLine();
			}
			else
			{
				switch (args[0])
				{
						case ""[a]"" : Add_New_Entry(args);
						break;
 
						case ""[p1]"": Print_Document(""Print the latest entry.txt"");
						break;
 
						case ""[p2]"": Print_Document(""Print the latest entry for each category.txt"");
						break;
 
						case ""[p3]"": Print_Document(""Print all entries sorted by a date.txt"");
						break;
 
						default :
						{
							Console.WriteLine();
							Console.WriteLine("" Incorrect Argument Error. "");
							Console.WriteLine();
						}
						break;
				}
			}
		}
 
		static void Add_New_Entry(string [] args)
		{
 
			//
			// Check parameters
			//
			//
			// Minimum one parameter, category
			//
			if(args.Length==1)
			{
				Console.WriteLine();
				Console.WriteLine("" Missing Parameters Error..... "");
				Console.WriteLine();
			}
			else
			{
				bool parameters_ok = true;
				foreach (string a in args)
				{
					if(!a.StartsWith(""["") || !a.EndsWith(""]""))
					{
						parameters_ok = !parameters_ok;
						break;
					}
				}
				//
				// Add new entry to Data base document
				//
				if(parameters_ok)
				{
					//
					//
					//
					Console.WriteLine();
					Console.WriteLine("" Parameters are ok..... "");
					Console.WriteLine();
					Console.WriteLine("" Writing new entry to database..... "");
					//
					// Create new Data base entry
					//
					args[0] = string.Empty;
					string line = string.Empty;
					foreach (string a in args)
					{
						line+=a;
					}
					line+=""["" + DateTime.Now.ToString() + ""]"";
					args[0] = ""["" + DateTime.Now.ToString() + ""]"";
					//
					// Write entry to Data base
					// 
					StreamWriter w = new StreamWriter(""Data base.txt"",true);
					w.WriteLine(line);
					//
					// Close and dispose stream writer
					//
					w.Close();
					w.Dispose();
					//
					//
					//
					Console.WriteLine();
					Console.WriteLine("" New entry is written to database. "");
 
					Create_Print_Documents(args);
 
					//
					//
					//
					Console.WriteLine();
					Console.WriteLine("" Add new entry command executed. "");
					//
					//
					//
				}
				else
				{
					Console.WriteLine();
					Console.WriteLine("" ! Parameters are not ok ! "");
					Console.WriteLine();
					Console.WriteLine("" Add new entry command is not executed. "");
					Console.WriteLine();
				}
			}
		}
 
		static void Create_Print_Documents(string [] args)
		{
			//
			//
			//
			Console.WriteLine();
			Console.WriteLine("" Creating new print documents. "");
			//
			// Create ""Print all entries sorted by a date.txt""
			//
			File.Copy(""Data base.txt"",""Print all entries sorted by a date.txt"",true);
			//
			//
			//
			Console.WriteLine();
			Console.WriteLine("" Print all entries sorted by a date.txt created. "");
			//
			// Create ""Print the latest entry.txt""
			//
			//
			// Create new entry
			//
			string line = string.Empty;
			foreach (string a in args)
			{
				line+=a;
			}
			//
			StreamWriter w = new StreamWriter(""Print the latest entry.txt"");
			//
			w.WriteLine(line);
			//
			w.Close();
			w.Dispose();
			//
			//
			//
			Console.WriteLine();
			Console.WriteLine("" Print the latest entry.txt created. "");
			//
			// Create ""Print the latest entry for each category.txt""
			//
			string latest_entry = string.Empty;
			foreach (string a in args)
			{
				latest_entry+=a;
			}
 
			if(!File.Exists(""Print the latest entry for each category.txt""))
			{
				File.WriteAllText(""Print the latest entry for each category.txt"",latest_entry);
			}
			else
			{
				StreamReader r = new StreamReader(""Print the latest entry for each category.txt"");
				//
				w = new StreamWriter(""Print the latest entry for each category 1.txt"",true);
				//
				line = string.Empty;
				//
				while(!r.EndOfStream)
				{
					line = r.ReadLine();
					if(line.Contains(args[1].ToString()))
					{
						w.WriteLine(latest_entry);
						latest_entry = ""ok"";
					}
					else
					{
						w.WriteLine(line);
					}
				}
				// add new category
				if(latest_entry != ""ok"")
					w.WriteLine(latest_entry);
				//
				w.Close();
				w.Dispose();
				//
				r.Close();
				r.Dispose();
				//
				File.Copy(""Print the latest entry for each category 1.txt"",
				          ""Print the latest entry for each category.txt"",true);
				//
				File.Delete(""Print the latest entry for each category 1.txt"");
				//
				//
				//
				Console.WriteLine();
				Console.WriteLine("" Print the latest entry for each category.txt created. "");
				Console.WriteLine();
			}
		}
 
		static void Print_Document(string file_name)
		{
			//
			// Print document
			//
			Console.WriteLine();
			Console.WriteLine(file_name.Replace("".txt"","""")+ "" : "");
			Console.WriteLine();
			//
			StreamReader r = new StreamReader(file_name);
			//
			string line = string.Empty;
			//
			line = r.ReadToEnd();
			//
			Console.WriteLine(line);
			//
			r.Close();
			r.Dispose();
			//
			//
			//
		}
	}
}
 ",7002,325
18056,http://rosettacode.org/wiki/Shortest_common_supersequence,Shortest common supersequence,"The   shortest common supersequence   is a problem closely related to the   longest common subsequence,   which you can use as an external function for this task.



Task

Given two strings 



u


{\displaystyle u}

 and 



v


{\displaystyle v}

, find the shortest possible sequence 



s


{\displaystyle s}

, which is the shortest common super-sequence of 



u


{\displaystyle u}

 and 



v


{\displaystyle v}

 where both 



u


{\displaystyle u}

 and 



v


{\displaystyle v}

 are a subsequence of 



s


{\displaystyle s}

. Defined as such, 



s


{\displaystyle s}

 is not necessarily unique.

Demonstrate this by printing 



s


{\displaystyle s}

 where 



u
=


{\displaystyle u=}

“abcbdab” and 



v
=


{\displaystyle v=}

“bdcaba”.



Also see

 Wikipedia: shortest common supersequence 

",#C.23,C#,"public class ShortestCommonSupersequence
{
    Dictionary<(string, string), string> cache = new();
 
    public string scs(string x, string y)
    {
        if (x.Length == 0) return y;
        if (y.Length == 0) return x;
 
        if (cache.TryGetValue((x, y), out var result)) return result;
 
        if (x[0] == y[0])
        {
            return cache[(x, y)] = x[0] + scs(x.Substring(1), y.Substring(1));
        }
 
        var xr = scs(x.Substring(1), y);
        var yr = scs(x, y.Substring(1));
        if (yr.Length <= xr.Length)
        {
            return cache[(x, y)] = y[0] + yr;
        }
        else
        {
            return cache[(x, y)] = x[0] + xr;
        }
    }
 
    public static void Main(string[] args)
    {
        var scs = new ShortestCommonSupersequence();
        Console.WriteLine(scs.scs(""abcbdab"", ""bdcaba""));
    }
}
 ",863,35
18172,http://rosettacode.org/wiki/Shoelace_formula_for_polygonal_area,Shoelace formula for polygonal area,"Given the n + 1 vertices x[0], y[0] .. x[N], y[N] of a simple polygon described in a clockwise direction, then the polygon's area can be calculated by:

abs( (sum(x[0]*y[1] + ... x[n-1]*y[n]) + x[N]*y[0]) -
     (sum(x[1]*y[0] + ... x[n]*y[n-1]) + x[0]*y[N])
   ) / 2
(Where abs returns the absolute value)

Task

Write a function/method/routine to use the the Shoelace formula to calculate the area of the polygon described by the ordered points:

     (3,4), (5,11), (12,8), (9,5), and (5,6) 



Show the answer here, on this page.



",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace ShoelaceFormula {
    using Point = Tuple<double, double>;
 
    class Program {
        static double ShoelaceArea(List<Point> v) {
            int n = v.Count;
            double a = 0.0;
            for (int i = 0; i < n - 1; i++) {
                a += v[i].Item1 * v[i + 1].Item2 - v[i + 1].Item1 * v[i].Item2;
            }
            return Math.Abs(a + v[n - 1].Item1 * v[0].Item2 - v[0].Item1 * v[n - 1].Item2) / 2.0;
        }
 
        static void Main(string[] args) {
            List<Point> v = new List<Point>() {
                new Point(3,4),
                new Point(5,11),
                new Point(12,8),
                new Point(9,5),
                new Point(5,6),
            };
            double area = ShoelaceArea(v);
            Console.WriteLine(""Given a polygon with vertices [{0}],"", string.Join("", "", v));
            Console.WriteLine(""its area is {0}."", area);
        }
    }
}",977,30
18214,http://rosettacode.org/wiki/Shell_one-liner,Shell one-liner,"Task

Show how to specify and execute a short program in the language from a command shell, where the input to the command shell is only one line in length.

Avoid depending on the particular shell or operating system used as much as is reasonable; if the language has notable implementations which have different command argument syntax, or the systems those implementations run on have different styles of shells, it would be good to show multiple examples.



",#C.23,C#,"> Add-Type -TypeDefinition ""public class HelloWorld { public static void SayHi() { System.Console.WriteLine(""""Hi!""""); } }""
> [HelloWorld]::SayHi()
Hi!",150,3
18289,http://rosettacode.org/wiki/Sierpinski_carpet,Sierpinski carpet,"Task
Produce a graphical or ASCII-art representation of a Sierpinski carpet of order   N.



For example, the Sierpinski carpet of order   3   should look like this:

###########################
# ## ## ## ## ## ## ## ## #
###########################
###   ######   ######   ###
# #   # ## #   # ## #   # #
###   ######   ######   ###
###########################
# ## ## ## ## ## ## ## ## #
###########################
#########         #########
# ## ## #         # ## ## #
#########         #########
###   ###         ###   ###
# #   # #         # #   # #
###   ###         ###   ###
#########         #########
# ## ## #         # ## ## #
#########         #########
###########################
# ## ## ## ## ## ## ## ## #
###########################
###   ######   ######   ###
# #   # ## #   # ## #   # #
###   ######   ######   ###
###########################
# ## ## ## ## ## ## ## ## #
###########################

The use of the   #   character is not rigidly required for ASCII art.

The important requirement is the placement of whitespace and non-whitespace characters.



Related task

   Sierpinski triangle

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
class Program
{
    static List<string> NextCarpet(List<string> carpet)
    {
        return carpet.Select(x => x + x + x)
                     .Concat(carpet.Select(x => x + x.Replace('#', ' ') + x))
                     .Concat(carpet.Select(x => x + x + x)).ToList();
    }
 
    static List<string> SierpinskiCarpet(int n)
    {
        return Enumerable.Range(1, n).Aggregate(new List<string> { ""#"" }, (carpet, _) => NextCarpet(carpet));
    }
 
    static void Main(string[] args)
    {
        foreach (string s in SierpinskiCarpet(3))
            Console.WriteLine(s);
    }
}",653,24
18339,http://rosettacode.org/wiki/Short-circuit_evaluation,Short-circuit evaluation,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops



Assume functions   a   and   b   return boolean values,   and further, the execution of function   b   takes considerable resources without side effects, and is to be minimized.

If we needed to compute the conjunction   (and):

  x = a() and b() 
Then it would be best to not compute the value of   b()   if the value of   a()   is computed as   false,   as the value of   x   can then only ever be    false.

Similarly, if we needed to compute the disjunction (or):

  y = a() or b() 
Then it would be best to not compute the value of   b()   if the value of   a()   is computed as   true,   as the value of   y   can then only ever be   true.

Some languages will stop further computation of boolean equations as soon as the result is known, so-called   short-circuit evaluation   of boolean expressions



Task

Create two functions named   a   and   b,   that take and return the same boolean value.

The functions should also print their name whenever they are called.

Calculate and assign the values of the following equations to a variable in such a way that function   b   is only called when necessary:

  x = a(i) and b(j) 
  y = a(i) or b(j) 

If the language does not have short-circuit evaluation, this might be achieved with nested     if     statements.



",#C.23,C#,"using System;
 
class Program
{
    static bool a(bool value)
    {
        Console.WriteLine(""a"");
        return value;
    }
 
    static bool b(bool value)
    {
        Console.WriteLine(""b"");
        return value;
    }
 
    static void Main()
    {
        foreach (var i in new[] { false, true })
        {
            foreach (var j in new[] { false, true })
            {
                Console.WriteLine(""{0} and {1} = {2}"", i, j, a(i) && b(j));
                Console.WriteLine();
                Console.WriteLine(""{0} or {1} = {2}"", i, j, a(i) || b(j));
                Console.WriteLine();
            }
        }
    }
}",639,30
18451,http://rosettacode.org/wiki/Show_ASCII_table,Show ASCII table,"Task

Show  the ASCII character set  from values   32   to   127   (decimal)   in a table format.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using static System.Console;
using static System.Linq.Enumerable;
 
public class Program
{
    static void Main()
    {
        for (int start = 32; start + 16 * 5 < 128; start++) {
            WriteLine(string.Concat(Range(0, 6).Select(i => $""{start+16*i, 3} : {Text(start+16*i), -6}"")));
        }
 
        string Text(int index) => index == 32 ? ""Sp"" : index == 127 ? ""Del"" : (char)index + """";
    }
}",405,14
18464,http://rosettacode.org/wiki/SHA-1,SHA-1,"SHA-1 or SHA1 is a one-way hash function;
it computes a 160-bit message digest.
SHA-1 often appears in security protocols; for example,
many HTTPS websites use RSA with SHA-1 to secure their connections.
BitTorrent uses SHA-1 to verify downloads.
Git and Mercurial use SHA-1 digests to identify commits.

A US government standard, FIPS 180-1, defines SHA-1.

Find the SHA-1 message digest for a string of octets. You may either call a SHA-1 library, or implement SHA-1 in your language. Both approaches interest Rosetta Code.



 Warning: SHA-1 has known weaknesses. Theoretical attacks may find a collision after 252 operations, or perhaps fewer.
This is much faster than a brute force attack of 280 operations. USgovernment deprecated SHA-1.
For production-grade cryptography, users may consider a stronger alternative, such as SHA-256 (from the SHA-2 family) or the upcoming SHA-3.

",#C.23,C#,"using System;
using System.Security.Cryptography;
using System.Text;
using Microsoft.VisualStudio.TestTools.UnitTesting;
 
namespace RosettaCode.SHA1
{
    [TestClass]
    public class SHA1CryptoServiceProviderTest
    {
        [TestMethod]
        public void TestComputeHash()
        {
            var input = new UTF8Encoding().GetBytes(""Rosetta Code"");
            var output = new SHA1CryptoServiceProvider().ComputeHash(input);
            Assert.AreEqual(
                ""48-C9-8F-7E-5A-6E-73-6D-79-0A-B7-40-DF-C3-F5-1A-61-AB-E2-B5"",
                BitConverter.ToString(output));
        }
    }
}",609,21
18502,http://rosettacode.org/wiki/SHA-256,SHA-256,"SHA-256 is the recommended stronger alternative to SHA-1. See FIPS PUB 180-4 for implementation details.

Either by using a dedicated library or implementing the algorithm in your language, show that the SHA-256 digest of the string ""Rosetta code"" is: 764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf
",#C.23,C#,"using System;
using System.Security.Cryptography;
using System.Text;
using Microsoft.VisualStudio.TestTools.UnitTesting;
 
namespace RosettaCode.SHA256
{
    [TestClass]
    public class SHA256ManagedTest
    {
        [TestMethod]
        public void TestComputeHash()
        {
            var buffer = Encoding.UTF8.GetBytes(""Rosetta code"");
            var hashAlgorithm = new SHA256Managed();
            var hash = hashAlgorithm.ComputeHash(buffer);
            Assert.AreEqual(
                ""76-4F-AF-5C-61-AC-31-5F-14-97-F9-DF-A5-42-71-39-65-B7-85-E5-CC-2F-70-7D-64-68-D7-D1-12-4C-DF-CF"",
                BitConverter.ToString(hash));
        }
    }
}",663,22
18506,http://rosettacode.org/wiki/Seven-sided_dice_from_five-sided_dice,Seven-sided dice from five-sided dice,"Task

(Given an equal-probability generator of one of the integers 1 to 5
as dice5),   create dice7 that generates a pseudo-random integer from
1 to 7 in equal probability using only dice5 as a source of random
numbers,   and check the distribution for at least one million calls using the function created in   Simple Random Distribution Checker.


Implementation suggestion:
dice7 might call dice5 twice, re-call if four of the 25
combinations are given, otherwise split the other 21 combinations
into 7 groups of three, and return the group index from the rolls.

(Task adapted from an answer here)
",#C.23,C#," 
using System;
 
public class SevenSidedDice
{
    Random random = new Random();
 
        static void Main(string[] args)
		{
			SevenSidedDice sevenDice = new SevenSidedDice();
			Console.WriteLine(""Random number from 1 to 7: ""+ sevenDice.seven());
            Console.Read();
		}
 
		int seven()
		{
			int v=21;
			while(v>20)
				v=five()+five()*5-6;
			return 1+v%7;
		}
 
		int five()
		{
        return 1 + random.Next(5);
		}
}",437,27
18519,http://rosettacode.org/wiki/Set_puzzle,Set puzzle,"Set Puzzles are created with a deck of cards from the Set Game™. The object of the puzzle is to find sets of 3 cards in a rectangle of cards that have been dealt face up. 


There are 81 cards in a deck.
Each card contains a unique variation of the following four features: color, symbol, number and shading.

 there are three colors:
    red, green, purple

 there are three symbols:
    oval, squiggle, diamond

 there is a number of symbols on the card:
    one, two, three

 there are three shadings:
    solid, open, striped

Three cards form a set if each feature is either the same on each card, or is different on each card. For instance: all 3 cards are red, all 3 cards have a different symbol, all 3 cards have a different number of symbols, all 3 cards are striped.

There are two degrees of difficulty: basic and advanced. The basic mode deals 9 cards, that contain exactly 4 sets; the advanced mode deals 12 cards that contain exactly 6 sets.

When creating sets you may use the same card more than once.




Task
Write code that deals the cards (9 or 12, depending on selected mode) from a shuffled deck in which the total number of sets that could be found is 4 (or 6, respectively); and print the contents of the cards and the sets.

For instance:



DEALT 9 CARDS:

green, one, oval, striped
green, one, diamond, open
green, one, diamond, striped
green, one, diamond, solid
purple, one, diamond, open
purple, two, squiggle, open
purple, three, oval, open
red, three, oval, open
red, three, diamond, solid

CONTAINING 4 SETS:

green, one, oval, striped
purple, two, squiggle, open
red, three, diamond, solid


green, one, diamond, open
green, one, diamond, striped
green, one, diamond, solid


green, one, diamond, open
purple, two, squiggle, open
red, three, oval, open


purple, one, diamond, open
purple, two, squiggle, open
purple, three, oval, open

",#C.23,C#,"using System;
using System.Collections.Generic;
using static System.Linq.Enumerable;
 
public static class SetPuzzle
{
    static readonly Feature[] numbers  = { (1, ""One""), (2, ""Two""), (3, ""Three"") };
    static readonly Feature[] colors   = { (1, ""Red""), (2, ""Green""), (3, ""Purple"") };
    static readonly Feature[] shadings = { (1, ""Open""), (2, ""Striped""), (3, ""Solid"") };
    static readonly Feature[] symbols  = { (1, ""Oval""), (2, ""Squiggle""), (3, ""Diamond"") };
 
    private readonly struct Feature
    {
        public Feature(int value, string name) => (Value, Name) = (value, name);
        public int Value { get; }
        public string Name { get; }
        public static implicit operator int(Feature f) => f.Value;
        public static implicit operator Feature((int value, string name) t) => new Feature(t.value, t.name);
        public override string ToString() => Name;
    }
 
    private readonly struct Card : IEquatable<Card>
    {
        public Card(Feature number, Feature color, Feature shading, Feature symbol) =>
            (Number, Color, Shading, Symbol) = (number, color, shading, symbol);
 
        public Feature Number { get; }
        public Feature Color { get; }
        public Feature Shading { get; }
        public Feature Symbol { get; }
 
        public override string ToString() => $""{Number} {Color} {Shading} {Symbol}(s)"";
        public bool Equals(Card other) => Number == other.Number && Color == other.Color && Shading == other.Shading && Symbol == other.Symbol;
    }
 
    public static void Main() {
        Card[] deck = (
            from number in numbers
            from color in colors
            from shading in shadings
            from symbol in symbols
            select new Card(number, color, shading, symbol)
        ).ToArray();
        var random = new Random();
 
        Deal(deck, 9, 4, random);
        Console.WriteLine();
        Console.WriteLine();
        Deal(deck, 12, 6, random);
    }
 
    static void Deal(Card[] deck, int size, int target, Random random) {
        List<(Card a, Card b, Card c)> sets;
        do {
            Shuffle(deck, random.Next);
            sets = (
                from i in 0.To(size - 2)
                from j in (i + 1).To(size - 1)
                from k in (j + 1).To(size)
                select (deck[i], deck[j], deck[k])
            ).Where(IsSet).ToList();
        } while (sets.Count != target);
        Console.WriteLine(""The board:"");
        foreach (Card card in deck.Take(size)) Console.WriteLine(card);
        Console.WriteLine();
        Console.WriteLine(""Sets:"");
        foreach (var s in sets) Console.WriteLine(s);
    }
 
    static void Shuffle<T>(T[] array, Func<int, int, int> rng) {
        for (int i = 0; i < array.Length; i++) {
            int r = rng(i, array.Length);
            (array[r], array[i]) = (array[i], array[r]);
        }
    }
 
    static bool IsSet((Card a, Card b, Card c) t) =>
        AreSameOrDifferent(t.a.Number, t.b.Number, t.c.Number) &&
        AreSameOrDifferent(t.a.Color, t.b.Color, t.c.Color) &&
        AreSameOrDifferent(t.a.Shading, t.b.Shading, t.c.Shading) &&
        AreSameOrDifferent(t.a.Symbol, t.b.Symbol, t.c.Symbol);
 
    static bool AreSameOrDifferent(int a, int b, int c) => (a + b + c) % 3 == 0;
    static IEnumerable<int> To(this int start, int end) => Range(start, end - start - 1);
}",3383,85
18757,http://rosettacode.org/wiki/Set_consolidation,Set consolidation,"Given two sets of items then if any item is common to any set then the result of applying consolidation to those sets is a set of sets whose contents is:

 The two input sets if no common item exists between the two input sets of items.
 The single set that is the union of the two input sets if they share a common item.

Given N sets of items where N>2 then the result is the same as repeatedly replacing all combinations of two sets by their consolidation until no further consolidation between set pairs is possible.
If N<2 then consolidation has no strict meaning and the input can be returned.

Example 1:
Given the two sets {A,B} and {C,D} then there is no common element between the sets and the result is the same as the input.
Example 2:
Given the two sets {A,B} and {B,D} then there is a common element B between the sets and the result is the single set {B,D,A}. (Note that order of items in a set is immaterial: {A,B,D} is the same as {B,D,A} and {D,A,B}, etc).
Example 3:
Given the three sets {A,B} and {C,D} and {D,B} then there is no common element between the sets {A,B} and {C,D} but the sets {A,B} and {D,B} do share a common element that consolidates to produce the result {B,D,A}. On examining this result with the remaining set, {C,D}, they share a common element and so consolidate to the final output of the single set {A,B,C,D}
Example 4:
The consolidation of the five sets:
{H,I,K}, {A,B}, {C,D}, {D,B}, and {F,G,H}
Is the two sets:
{A, C, B, D}, and {G, F, I, H, K}

See also

 Connected component (graph theory)
 Range consolidation

",#C.23,C#,"using System;
using System.Linq;
using System.Collections.Generic;
 
public class SetConsolidation
{
    public static void Main()
    {
        var setCollection1 = new[] {new[] {""A"", ""B""}, new[] {""C"", ""D""}};
        var setCollection2 = new[] {new[] {""A"", ""B""}, new[] {""B"", ""D""}};
        var setCollection3 = new[] {new[] {""A"", ""B""}, new[] {""C"", ""D""}, new[] {""B"", ""D""}};
        var setCollection4 = new[] {new[] {""H"", ""I"", ""K""}, new[] {""A"", ""B""}, new[] {""C"", ""D""},
            new[] {""D"", ""B""}, new[] {""F"", ""G"", ""H""}};
        var input = new[] {setCollection1, setCollection2, setCollection3, setCollection4};
 
        foreach (var sets in input) {
            Console.WriteLine(""Start sets:"");
            Console.WriteLine(string.Join("", "", sets.Select(s => ""{"" + string.Join("", "", s) + ""}"")));
            Console.WriteLine(""Sets consolidated using Nodes:"");
            Console.WriteLine(string.Join("", "", ConsolidateSets1(sets).Select(s => ""{"" + string.Join("", "", s) + ""}"")));
            Console.WriteLine(""Sets consolidated using Set operations:"");
            Console.WriteLine(string.Join("", "", ConsolidateSets2(sets).Select(s => ""{"" + string.Join("", "", s) + ""}"")));
            Console.WriteLine();
        }
    }
 
    /// <summary>
    /// Consolidates sets using a connected-component-finding-algorithm involving Nodes with parent pointers.
    /// The more efficient solution, but more elaborate code.
    /// </summary>
    private static IEnumerable<IEnumerable<T>> ConsolidateSets1<T>(IEnumerable<IEnumerable<T>> sets,
        IEqualityComparer<T> comparer = null)
    {
        if (comparer == null) comparer = EqualityComparer<T>.Default;
        var elements = new Dictionary<T, Node<T>>();
        foreach (var set in sets) {
            Node<T> top = null;
            foreach (T value in set) {
                Node<T> element;
                if (elements.TryGetValue(value, out element)) {
                    if (top != null) {
                        var newTop = element.FindTop();
                        top.Parent = newTop;
                        element.Parent = newTop;
                        top = newTop;
                    } else {
                        top = element.FindTop();
                    }
                } else {
                    elements.Add(value, element = new Node<T>(value));
                    if (top == null) top = element;
                    else element.Parent = top;
                }
            }
        }
        foreach (var g in elements.Values.GroupBy(element => element.FindTop().Value))
            yield return g.Select(e => e.Value);
    }
 
    private class Node<T>
    {
        public Node(T value, Node<T> parent = null) {
            Value = value;
            Parent = parent ?? this;
        }
 
        public T Value { get; }
        public Node<T> Parent { get; set; }
 
        public Node<T> FindTop() {
            var top = this;
            while (top != top.Parent) top = top.Parent;
            //Set all parents to the top element to prevent repeated iteration in the future
            var element = this;
            while (element.Parent != top) {
                var parent = element.Parent;
                element.Parent = top;
                element = parent;
            }
            return top;
        }
    }
 
    /// <summary>
    /// Consolidates sets using operations on the HashSet&lt;T&gt; class.
    /// Less efficient than the other method, but easier to write.
    /// </summary>
    private static IEnumerable<IEnumerable<T>> ConsolidateSets2<T>(IEnumerable<IEnumerable<T>> sets,
        IEqualityComparer<T> comparer = null)
    {
        if (comparer == null) comparer = EqualityComparer<T>.Default;
        var currentSets = sets.Select(s => new HashSet<T>(s)).ToList();
        int previousSize;
        do {
            previousSize = currentSets.Count;
            for (int i = 0; i < currentSets.Count - 1; i++) {
                for (int j = currentSets.Count - 1; j > i; j--) {
                    if (currentSets[i].Overlaps(currentSets[j])) {
                        currentSets[i].UnionWith(currentSets[j]);
                        currentSets.RemoveAt(j);
                    }
                }
            }
        } while (previousSize > currentSets.Count);
        foreach (var set in currentSets) yield return set.Select(value => value);
    }
}",4394,107
18835,http://rosettacode.org/wiki/Set_of_real_numbers,Set of real numbers,"All real numbers form the uncountable set ℝ. Among its subsets, relatively simple are the convex sets, each expressed as a range between two real numbers a and b where a ≤ b. There are actually four cases for the meaning of ""between"", depending on open or closed boundary:

 [a, b]: {x | a ≤ x and x ≤ b }
 (a, b): {x | a < x and x < b }
 [a, b): {x | a ≤ x and x < b }
 (a, b]: {x | a < x and x ≤ b }
Note that if a = b, of the four only [a, a] would be non-empty.

Task

 Devise a way to represent any set of real numbers, for the definition of 'any' in the implementation notes below.
 Provide methods for these common set operations (x is a real number; A and B are sets):
 x ∈ A: determine if x is an element of A
 example: 1 is in [1, 2), while 2, 3, ... are not.
 A ∪ B: union of A and B, i.e. {x | x ∈ A or x ∈ B}
 example: [0, 2) ∪ (1, 3) = [0, 3); [0, 1) ∪ (2, 3] = well, [0, 1) ∪ (2, 3]
 A ∩ B: intersection of A and B, i.e. {x | x ∈ A and x ∈ B}
 example: [0, 2) ∩ (1, 3) = (1, 2); [0, 1) ∩ (2, 3] = empty set
 A - B: difference between A and B, also written as A \ B, i.e. {x | x ∈ A and x ∉ B}
 example: [0, 2) − (1, 3) = [0, 1]
 Test your implementation by checking if numbers 0, 1, and 2 are in any of the following sets:
 (0, 1] ∪ [0, 2)
 [0, 2) ∩ (1, 2]
 [0, 3) − (0, 1)
 [0, 3) − [0, 1]
Implementation notes

 'Any' real set means 'sets that can be expressed as the union of a finite number of convex real sets'. Cantor's set needs not apply.
 Infinities should be handled gracefully; indeterminate numbers (NaN) can be ignored.
 You can use your machine's native real number representation, which is probably IEEE floating point, and assume it's good enough (it usually is).
Optional work

 Create a function to determine if a given set is empty (contains no element).
 Define A = {x | 0 < x < 10 and |sin(π x²)| > 1/2 }, B = {x | 0 < x < 10 and |sin(π x)| > 1/2}, calculate the length of the real axis covered by the set A − B. Note that 
|sin(π x)| > 1/2 is the same as n + 1/6 < x < n + 5/6 for all integers n; your program does not need to derive this by itself.
",#C.23,C#,"using System;
 
namespace RosettaCode.SetOfRealNumbers
{
    public class Set<TValue>
    {
        public Set(Predicate<TValue> contains)
        {
            Contains = contains;
        }
 
        public Predicate<TValue> Contains
        {
            get;
            private set;
        }
 
        public Set<TValue> Union(Set<TValue> set)
        {
            return new Set<TValue>(value => Contains(value) || set.Contains(value));
        }
 
        public Set<TValue> Intersection(Set<TValue> set)
        {
            return new Set<TValue>(value => Contains(value) && set.Contains(value));
        }
 
        public Set<TValue> Difference(Set<TValue> set)
        {
            return new Set<TValue>(value => Contains(value) && !set.Contains(value));
        }
    }
}",789,33
18902,http://rosettacode.org/wiki/Send_an_unknown_method_call,Send an unknown method call,"Task

Invoke an object method where the name of the method to be invoked can be generated at run time.



Related tasks

 Respond to an unknown method call.
 Runtime evaluation

",#C.23,C#,"using System;
 
class Example
{
    public int foo(int x)
    {
        return 42 + x;
    }
}
 
class Program
{
    static void Main(string[] args)
    {
        var example = new Example();
        var method = ""foo"";
 
        var result = (int)example.GetType().GetMethod(method).Invoke(example, new object[]{ 5 });
        Console.WriteLine(""{0}(5) = {1}"", method, result);
    }
}
 ",388,22
18977,http://rosettacode.org/wiki/Send_email,Send email,"Task

Write a function to send an email.

The function should have parameters for setting From, To and Cc addresses; the Subject, and the message text, and optionally fields for the server name and login details.

 If appropriate, explain what notifications of problems/success are given.
 Solutions using libraries or functions from the language are preferred, but failing that, external programs can be used with an explanation.
 Note how portable the solution given is between operating systems when multi-OS languages are used.


(Remember to obfuscate any sensitive data used in examples)



",#C.23,C#," 
static void Main(string[] args)
{
    //First of all construct the SMTP client
 
    SmtpClient SMTP = new SmtpClient(""smtp.gmail.com"", 587); //I have provided the URI and port for GMail, replace with your providers SMTP details
    SMTP.EnableSsl = true; //Required for gmail, may not for your provider, if your provider does not require it then use false.
    SMTP.DeliveryMethod = SmtpDeliveryMethod.Network;
    SMTP.Credentials = new NetworkCredential(""YourUserName"", ""YourPassword"");
    MailMessage Mail = new MailMessage(""yourEmail@address.com"", ""theirEmail@address.com"");
 
 
    //Then we construct the message
 
    Mail.Subject = ""Important Message"";
    Mail.Body = ""Hello over there""; //The body contains the string for your email
    //using ""Mail.IsBodyHtml = true;"" you can put an HTML page in your message body
 
    //Then we use the SMTP client to send the message
 
    SMTP.Send(Mail);
 
    Console.WriteLine(""Message Sent"");
}
 ",954,25
19198,http://rosettacode.org/wiki/Sequence_of_primes_by_trial_division,Sequence of primes by trial division,"Sequence of primes by trial division

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Generate a sequence of primes by means of trial division.



Trial division is an algorithm where a candidate number is tested for being a prime by trying to divide it by other numbers.

You may use primes, or any numbers of your choosing, as long as the result is indeed a sequence of primes.

The sequence may be bounded (i.e. up to some limit), unbounded, starting from the start (i.e. 2) or above some given value.

Organize your function as you wish, in particular, it might resemble a filtering operation, or a sieving operation.

If you want to use a ready-made is_prime function, use one from the Primality by trial division page (i.e., add yours there if it isn't there already).



Related tasks

   count in factors
   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
public class Program
{
    static void Main() {
        Console.WriteLine(string.Join("" "", Primes(100)));
    }
 
    static IEnumerable<int> Primes(int limit) => Enumerable.Range(2, limit-1).Where(IsPrime);
    static bool IsPrime(int n) => Enumerable.Range(2, (int)Math.Sqrt(n)-1).All(i => n % i != 0);
}",375,13
19226,http://rosettacode.org/wiki/Semiprime,Semiprime,"Semiprime numbers are natural numbers that are products of exactly two (possibly equal) prime numbers.


Semiprimes   are also known as:

   semi-primes
   biprimes
   bi-primes
    2-almost    primes
   or simply:    P2  


Example
 
   1679  =  23 × 73  

(This particular number was chosen as the length of the Arecibo message).



Task

Write a function determining whether a given number is semiprime.



See also

 The Wikipedia article:  semiprime.
 The Wikipedia article:  almost prime.
 The OEIS sequence:  A001358: semiprimes  which has a shorter definition: the product of two primes.

",#C.23,C#," 
static void Main(string[] args)
{
    //test some numbers
    for (int i = 0; i < 50; i++)
    {
        Console.WriteLine(""{0}\t{1} "", i,isSemiPrime(i));
    }
    Console.ReadLine();
}
 
//returns true or false depending if input was considered semiprime
private static bool isSemiPrime(int c)
{
    int a = 2, b = 0;
    while (b < 3 && c != 1)
    {
        if ((c % a) == 0)
        {
            c /= a;
            b++;
        }
        else
        {
            a++;
        };
    }
    return b == 2;
}
 ",518,30
19230,http://rosettacode.org/wiki/Self_numbers,Self numbers,"A number n is a self number if there is no number g such that g + the sum of g's digits = n. So 18 is not a self number because 9+9=18, 43 is not a self number because 35+5+3=43.


The task is:

 Display the first 50 self numbers;
 I believe that the 100000000th self number is 1022727208. You should either confirm or dispute my conjecture.

224036583-1 is a Mersenne prime, claimed to also be a self number. Extra credit to anyone proving it.


See also
 
OEIS: A003052 - Self numbers or Colombian numbers
Wikipedia: Self numbers",#C.23,C#,"using System;
using static System.Console;
 
class Program {
 
  const int mc = 103 * 1000 * 10000 + 11 * 9 + 1;
 
  static bool[] sv = new bool[mc + 1];
 
  static void sieve() { int[] dS = new int[10000];
    for (int a = 9, i = 9999; a >= 0; a--)
      for (int b = 9; b >= 0; b--)
        for (int c = 9, s = a + b; c >= 0; c--)
          for (int d = 9, t = s + c; d >= 0; d--)
            dS[i--] = t + d;
    for (int a = 0, n = 0; a < 103; a++)
      for (int b = 0, d = dS[a]; b < 1000; b++, n += 10000)
        for (int c = 0, s = d + dS[b] + n; c < 10000; c++)
          sv[dS[c] + s++] = true; }
 
  static void Main() { DateTime st = DateTime.Now; sieve();
    WriteLine(""Sieving took {0}s"", (DateTime.Now - st).TotalSeconds); 
    WriteLine(""\nThe first 50 self numbers are:"");
    for (int i = 0, count = 0; count <= 50; i++) if (!sv[i]) {
        count++; if (count <= 50) Write(""{0} "", i);
        else WriteLine(""\n\n       Index     Self number""); }
    for (int i = 0, limit = 1, count = 0; i < mc; i++)
      if (!sv[i]) if (++count == limit) {
          WriteLine(""{0,12:n0}   {1,13:n0}"", count, i);
          if (limit == 1e9) break; limit *= 10; }
    WriteLine(""\nOverall took {0}s"", (DateTime.Now - st). TotalSeconds);
  }
}",1250,33
19252,http://rosettacode.org/wiki/Semordnilap,Semordnilap,"A semordnilap is a word (or phrase) that spells a different word (or phrase) backward. ""Semordnilap"" is a word that itself is a semordnilap.

Example: lager and regal

Task
This task does not consider semordnilap phrases, only single words.
Using only words from this list, report the total number of unique semordnilap pairs, and print 5 examples.
Two matching semordnilaps, such as lager and regal, should be counted as one unique pair.
(Note that the word ""semordnilap"" is not in the above dictionary.)




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.Net;
using System.Collections.Generic;
using System.Linq;
using System.IO;
 
public class Semordnilap
{
    public static void Main() {
        var results = FindSemordnilaps(""http://www.puzzlers.org/pub/wordlists/unixdict.txt"").ToList();
        Console.WriteLine(results.Count);
        var random = new Random();
        Console.WriteLine(""5 random results:"");
        foreach (string s in results.OrderBy(_ => random.Next()).Distinct().Take(5)) Console.WriteLine(s + "" "" + Reversed(s));
    }
 
    private static IEnumerable<string> FindSemordnilaps(string url) {
        var found = new HashSet<string>();
        foreach (string line in GetLines(url)) {
            string reversed = Reversed(line);
            //Not taking advantage of the fact the input file is sorted
            if (line.CompareTo(reversed) != 0) {
                if (found.Remove(reversed)) yield return reversed;
                else found.Add(line);
            }
        }
    }
 
    private static IEnumerable<string> GetLines(string url) {
        WebRequest request = WebRequest.Create(url);
        using (var reader = new StreamReader(request.GetResponse().GetResponseStream(), true)) {
            while (!reader.EndOfStream) {
                yield return reader.ReadLine();
            }
        }
    }
 
    private static string Reversed(string value) => new string(value.Reverse().ToArray());
}",1418,39
19294,http://rosettacode.org/wiki/Sequence_of_non-squares,Sequence of non-squares,"Task

Show that the following remarkable formula gives the sequence of non-square natural numbers:

            n + floor(1/2 + sqrt(n)) 

 Print out the values for    n    in the range   1   to   22
 Show that no squares occur for    n    less than one million


This is sequence   A000037   in the OEIS database.



",#C.23,C#,"using System;
using System.Diagnostics;
 
namespace sons
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int i = 1; i < 23; i++)            
                Console.WriteLine(nonsqr(i));            
 
            for (int i = 1; i < 1000000; i++)
            {
                double j = Math.Sqrt(nonsqr(i));
                Debug.Assert(j != Math.Floor(j),""Square"");
            }            
        }
 
        static int nonsqr(int i)
        {
            return (int)(i + Math.Floor(0.5 + Math.Sqrt(i)));
        }
    }
}",574,25
19295,http://rosettacode.org/wiki/Set,Set,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
A   set  is a collection of elements, without duplicates and without order.



Task

Show each of these set operations:

 Set creation
 Test m ∈ S -- ""m is an element in set S""
 A ∪ B -- union; a set of all elements either in set A or in set B.
 A ∩ B -- intersection; a set of all elements in both set A and set B.
 A ∖ B -- difference; a set of all elements in set A, except those in set B.
 A ⊆ B -- subset; true if every element in set A is also in set B.
 A = B -- equality; true if every element of set A is in set B and vice versa.


As an option, show some other set operations.

(If A ⊆ B, but A ≠ B, then A is called a true or proper subset of B, written A ⊂ B or A ⊊ B.)

As another option, show how to modify a mutable set.



One might implement a set using an associative array (with set elements as array keys and some dummy value as the values).

One might also implement a set with a binary search tree, or with a hash table, or with an ordered array of binary bits (operated on with bit-wise binary operators).

The basic test, m ∈ S, is O(n) with a sequential list of elements, O(log n) with a balanced binary search tree, or (O(1) average-case, O(n) worst case) with a hash table.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
class Program
{
    static void PrintCollection(IEnumerable<int> x)
    {
        Console.WriteLine(string.Join("" "", x));
    }
    static void Main(string[] args)
    {
        Console.OutputEncoding = Encoding.UTF8;
        Console.WriteLine(""Set creation"");
        var A = new HashSet<int> { 4, 12, 14, 17, 18, 19, 20 };
        var B = new HashSet<int> { 2, 5, 8, 11, 12, 13, 17, 18, 20 };
 
        PrintCollection(A);
        PrintCollection(B);
 
        Console.WriteLine(""Test m ∈ S -- \""m is an element in set S\"""");
        Console.WriteLine(""14 is an element in set A: {0}"", A.Contains(14));
        Console.WriteLine(""15 is an element in set A: {0}"", A.Contains(15));
 
        Console.WriteLine(""A ∪ B -- union; a set of all elements either in set A or in set B."");
        var aUb = A.Union(B);
        PrintCollection(aUb);
 
        Console.WriteLine(""A ∖ B -- difference; a set of all elements in set A, except those in set B."");
        var aDb = A.Except(B);
        PrintCollection(aDb);
 
        Console.WriteLine(""A ⊆ B -- subset; true if every element in set A is also in set B."");
        Console.WriteLine(A.IsSubsetOf(B));
        var C = new HashSet<int> { 14, 17, 18 };
        Console.WriteLine(C.IsSubsetOf(A));
 
        Console.WriteLine(""A = B -- equality; true if every element of set A is in set B and vice versa."");
        Console.WriteLine(A.SetEquals(B));
        var D = new HashSet<int> { 4, 12, 14, 17, 18, 19, 20 };
        Console.WriteLine(A.SetEquals(D));
 
        Console.WriteLine(""If A ⊆ B, but A ≠ B, then A is called a true or proper subset of B, written A ⊂ B or A ⊊ B"");
        Console.WriteLine(A.IsProperSubsetOf(B));
        Console.WriteLine(C.IsProperSubsetOf(A));
 
        Console.WriteLine(""Modify a mutable set.  (Add 10 to A; remove 12 from B)."");
        A.Add(10);
        B.Remove(12);
        PrintCollection(A);
        PrintCollection(B);
 
        Console.ReadKey();
    }
}",2037,56
19507,http://rosettacode.org/wiki/SEDOLs,SEDOLs,"Task

For each number list of 6-digit SEDOLs, calculate and append the checksum digit.



That is, given this input:

710889
B0YBKJ
406566
B0YBLH
228276
B0YBKL
557910
B0YBKR
585284
B0YBKT
B00030

Produce this output:

7108899
B0YBKJ7
4065663
B0YBLH2
2282765
B0YBKL9
5579107
B0YBKR5
5852842
B0YBKT7
B000300

Extra credit

Check each input is correctly formed, especially with respect to valid characters allowed in a SEDOL string.



Related tasks

   Luhn test
   ISIN

",#C.23,C#,"static int[] sedol_weights = { 1, 3, 1, 7, 3, 9 };
static int sedolChecksum(string sedol)
{
    int len = sedol.Length;
    int sum = 0;
 
    if (len == 7) //SEDOL code already checksummed?
        return (int)sedol[6];
 
    if ((len > 7) || (len < 6) || System.Text.RegularExpressions.Regex.IsMatch(sedol, ""[AEIOUaeiou]+"")) //invalid SEDOL
        return -1;
 
    for (int i = 0; i < 6; i++)
    {
        if (Char.IsDigit(sedol[i]))
            sum += (((int)sedol[i] - 48) * sedol_weights[i]);
 
        else if (Char.IsLetter(sedol[i]))
            sum += (((int)Char.ToUpper(sedol[i]) - 55) * sedol_weights[i]);
 
        else
            return -1;
 
    }
 
    return (10 - (sum % 10)) % 10;
}",704,27
19649,http://rosettacode.org/wiki/Sieve_of_Eratosthenes,Sieve of Eratosthenes,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.


The Sieve of Eratosthenes is a simple algorithm that finds the prime numbers up to a given integer.



Task

Implement the   Sieve of Eratosthenes   algorithm, with the only allowed optimization that the outer loop can stop at the square root of the limit, and the inner loop may start at the square of the prime just found.

That means especially that you shouldn't optimize by using pre-computed wheels, i.e. don't assume you need only to cross out odd numbers (wheel based on 2), numbers equal to 1 or 5 modulo 6 (wheel based on 2 and 3), or similar wheels based on low primes.

If there's an easy way to add such a wheel based optimization, implement it as an alternative version.



Note

 It is important that the sieve algorithm be the actual algorithm used to find prime numbers for the task.


Related tasks

   Emirp primes
   count in factors
   prime decomposition
   factors of an integer
   extensible prime generator
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",#C.23,C#,"using System;
using System.Collections;
using System.Collections.Generic;
 
namespace SieveOfEratosthenes
{
    class Program
    {
        static void Main(string[] args)
        {
            int maxprime = int.Parse(args[0]);
            var primelist = GetAllPrimesLessThan(maxprime);
            foreach (int prime in primelist)
            {
                Console.WriteLine(prime);
            }
            Console.WriteLine(""Count = "" + primelist.Count);
            Console.ReadLine();
        }
 
        private static List<int> GetAllPrimesLessThan(int maxPrime)
        {
            var primes = new List<int>();
            var maxSquareRoot = (int)Math.Sqrt(maxPrime);
            var eliminated = new BitArray(maxPrime + 1);
 
            for (int i = 2; i <= maxPrime; ++i)
            {
                if (!eliminated[i])
                {
                    primes.Add(i);
                    if (i <= maxSquareRoot)
                    {
                        for (int j = i * i; j <= maxPrime; j += i)
                        {
                            eliminated[j] = true;
                        }
                    }
                }
            }
            return primes;
        }
    }
}",1230,44
20078,http://rosettacode.org/wiki/Secure_temporary_file,Secure temporary file,"Task

Create a temporary file, securely and exclusively (opening it such that there are no possible race conditions).

It's fine assuming local filesystem semantics (NFS or other networking filesystems can have signficantly more complicated semantics for satisfying the ""no race conditions"" criteria).

The function should automatically resolve name collisions and should only fail in cases where permission is denied, the filesystem is read-only or full, or similar conditions exist (returning an error or raising an exception as appropriate to the language/environment).



",#C.23,C#,"using System;
using System.IO;
 
Console.WriteLine(Path.GetTempFileName());",75,4
20096,http://rosettacode.org/wiki/Scope_modifiers,Scope modifiers,"Most programming languages offer support for subroutines.
When execution changes between subroutines, different sets of variables and functions (""scopes"") are available to the program.
Frequently these sets are defined by the placement of the variable and function declarations (""static scoping"" or ""lexical scoping"").
These sets may also be defined by special modifiers to the variable and function declarations.

Show the different scope modifiers available in your language and briefly explain how they change the scope of their variable or function.
If your language has no scope modifiers, note it.
",#C.23,C#,"public //visible to anything.
protected //visible to current class and to derived classes.
internal //visible to anything inside the same assembly (.dll/.exe).
protected internal //visible to anything inside the same assembly and also to derived classes outside the assembly.
private //visible only to the current class.
//C# 7.2 adds:
private protected //visible to current class and to derived classes inside the same assembly.
 
//                   |       |     subclass     |    other class   ||     subclass     |    other class
//Modifier           | class | in same assembly | in same assembly || outside assembly | outside assembly
//-------------------------------------------------------------------------------------------------------
//public             |  Yes  |        Yes       |        Yes       ||        Yes       |       Yes
//protected internal |  Yes  |        Yes       |        Yes       ||        Yes       |       No
//protected          |  Yes  |        Yes       |        No        ||        Yes       |       No
//internal           |  Yes  |        Yes       |        Yes       ||        No        |       No
//private            |  Yes  |        No        |        No        ||        No        |       No
// C# 7.2:
//private protected  |  Yes  |        Yes       |        No        ||        No        |       No",1347,18
20164,"http://rosettacode.org/wiki/Sailors,_coconuts_and_a_monkey_problem","Sailors, coconuts and a monkey problem","Five sailors are shipwrecked on an island and collect a large pile of coconuts during the day.

That night the first sailor wakes up and decides to take his first share early so tries to divide the pile of coconuts equally into five piles but finds that there is one coconut left over, so he tosses it to a monkey and then hides ""his"" one of the five equally sized piles of coconuts and pushes the other four piles together to form a single visible pile of coconuts again and goes to bed.

To cut a long story short, each of the sailors in turn gets up once during the night and performs the same actions of dividing the coconut pile into five, finding that one coconut is left over and giving that single remainder coconut to the monkey.

In the morning (after the surreptitious and separate action of each of the five sailors during the night), the remaining coconuts are divided into five equal piles for each of the sailors, whereupon it is found that the pile of coconuts divides equally amongst the sailors with no remainder. (Nothing for the monkey in the morning.)



The task

 Calculate the minimum possible size of the initial pile of coconuts collected during the first day.
 Use a method that assumes an answer is possible, and then applies the constraints of the tale to see if it is correct. (I.e. no applying some formula that generates the correct answer without integer divisions and remainders and tests on remainders; but constraint solvers are allowed.)
 Calculate the size of the initial pile of coconuts if six sailors were marooned and went through a similar process (but split into six piles instead of five of course).
 Show your answers here.


Extra credit (optional)

 Give some indication of the number of coconuts each sailor hides during the night.


Note

 Of course the tale is told in a world where the collection of any amount of coconuts in a day and multiple divisions of the pile, etc can occur in time fitting the story line, so as not to affect the mathematics.
 The tale is also told in a version where the monkey also gets a coconut in the morning. This is not that tale!


C.f

 Monkeys and Coconuts - Numberphile (Video) Analytical solution.
 A002021: Pile of coconuts problem The On-Line Encyclopedia of Integer Sequences. (Although some of its references may use the alternate form of the tale).

",#C.23,C#,"class Test
{
    static bool valid(int n, int nuts)
    {
        for (int k = n; k != 0; k--, nuts -= 1 + nuts / n)
        {
            if (nuts % n != 1)
            {
                return false;
            }                
        }
 
        return nuts != 0 && (nuts % n == 0);
    }
 
    static void Main(string[] args)
    {
        int x = 0;
        for (int n = 2; n < 10; n++)
        {
            while (!valid(n, x))
                x++;
            System.Console.WriteLine(n + "": "" + x);
        }
    }
}",528,26
20221,http://rosettacode.org/wiki/Same_fringe,Same fringe,"Write a routine that will compare the leaves (""fringe"") of two binary trees to determine whether they are the same list of leaves when visited left-to-right. The structure or balance of the trees does not matter; only the number, order, and value of the leaves is important.

Any solution is allowed here, but many computer scientists will consider it inelegant to collect either fringe in its entirety before starting to collect the other one. In fact, this problem is usually proposed in various forums as a way to show off various forms of concurrency (tree-rotation algorithms have also been used to get around the need to collect one tree first). Thinking of it a slightly different way, an elegant solution is one that can perform the minimum amount of work to falsify the equivalence of the fringes when they differ somewhere in the middle, short-circuiting the unnecessary additional traversals and comparisons.

Any representation of a binary tree is allowed, as long as the nodes are orderable, and only downward links are used (for example, you may not use parent or sibling pointers to avoid recursion).
",#C.23,C#," 
using System;
using System.Collections.Generic;
using System.Linq;
 
namespace Same_Fringe
{
	class Program
	{
		static void Main()
		{
			var rnd = new Random(110456);
			var randList = Enumerable.Range(0, 20).Select(i => rnd.Next(1000)).ToList();
			var bt1 = new BinTree<int>(randList);
			// Shuffling will create a tree with the same values but different topology
			Shuffle(randList, 428);
			var bt2 = new BinTree<int>(randList);
			Console.WriteLine(bt1.CompareTo(bt2) ? ""True compare worked"" : ""True compare failed"");
			// Insert a 0 in the first tree which should cause a failure
			bt1.Insert(0);
			Console.WriteLine(bt1.CompareTo(bt2) ? ""False compare failed"" : ""False compare worked"");
		}
 
		static void Shuffle<T>(List<T> values, int seed)
		{
			var rnd = new Random(seed);
 
			for (var i = 0; i < values.Count - 2; i++)
			{
				var iSwap = rnd.Next(values.Count - i) + i;
				var tmp = values[iSwap];
				values[iSwap] = values[i];
				values[i] = tmp;
			}
		}
	}
 
	// Define other methods and classes here
	class BinTree<T> where T:IComparable
	{
		private BinTree<T> _left;
		private BinTree<T> _right;
		private T _value;
 
		private BinTree<T> Left
		{
			get { return _left; }
		}
 
		private BinTree<T> Right
		{
			get { return _right; }
		}
 
		// On interior nodes, any value greater than or equal to Value goes in the
		// right subtree, everything else in the left.
		private T Value
		{
			get { return _value; }
		}
 
		public bool IsLeaf { get { return Left == null; } }
 
		private BinTree(BinTree<T> left, BinTree<T> right, T value)
		{
			_left = left;
			_right = right;
			_value = value;
		}
 
		public BinTree(T value) : this(null, null, value) { }
 
		public BinTree(IEnumerable<T> values)
		{
			// ReSharper disable PossibleMultipleEnumeration
			_value = values.First();
			foreach (var value in values.Skip(1))
			{
				Insert(value);
			}
			// ReSharper restore PossibleMultipleEnumeration
		}
 
		public void Insert(T value)
		{
			if (IsLeaf)
			{
				if (value.CompareTo(Value) < 0)
				{
					_left = new BinTree<T>(value);
					_right = new BinTree<T>(Value);
				}
				else
				{
					_left = new BinTree<T>(Value);
					_right = new BinTree<T>(value);
					_value = value;
				}
			}
			else
			{
				if (value.CompareTo(Value) < 0)
				{
					Left.Insert(value);
				}
				else
				{
					Right.Insert(value);
				}
			}
		}
 
		public IEnumerable<T> GetLeaves()
		{
			if (IsLeaf)
			{
				yield return Value;
				yield break;
			}
			foreach (var val in Left.GetLeaves())
			{
				yield return val;
			}
			foreach (var val in Right.GetLeaves())
			{
				yield return val;
			}
		}
 
		internal bool CompareTo(BinTree<T> other)
		{
			return other.GetLeaves().Zip(GetLeaves(), (t1, t2) => t1.CompareTo(t2) == 0).All(f => f);
		}
	}
}
 ",2799,136
20243,http://rosettacode.org/wiki/Search_a_list_of_records,Search a list of records,"Many programming languages provide convenient ways to look for a known value in a simple list of strings or numbers.

But what if the elements of the list are themselves compound records/objects/data-structures, and the search condition is more complex than a simple equality test?

Task[edit]
Write a function/method/etc. that can find the first element in a given list matching a given condition.

It should be as generic and reusable as possible.

(Of course if your programming language already provides such a feature, you can use that instead of recreating it.)

Then to demonstrate its functionality, create the data structure specified under #Data set, and perform on it the searches specified under #Test cases.

Data set
The data structure to be used contains the names and populations (in millions) of the 10 largest metropolitan areas in Africa, and looks as follows when represented in JSON:

[
  { ""name"": ""Lagos"",                ""population"": 21.0  },
  { ""name"": ""Cairo"",                ""population"": 15.2  },
  { ""name"": ""Kinshasa-Brazzaville"", ""population"": 11.3  },
  { ""name"": ""Greater Johannesburg"", ""population"":  7.55 },
  { ""name"": ""Mogadishu"",            ""population"":  5.85 },
  { ""name"": ""Khartoum-Omdurman"",    ""population"":  4.98 },
  { ""name"": ""Dar Es Salaam"",        ""population"":  4.7  },
  { ""name"": ""Alexandria"",           ""population"":  4.58 },
  { ""name"": ""Abidjan"",              ""population"":  4.4  },
  { ""name"": ""Casablanca"",           ""population"":  3.98 }
]
However, you shouldn't parse it from JSON, but rather represent it natively in your programming language.

 The top-level data structure should be an ordered collection (i.e. a list, array, vector, or similar).
 Each element in this list should be an associative collection that maps from keys to values (i.e. a struct, object, hash map, dictionary, or similar).
 Each of them has two entries: One string value with key ""name"", and one numeric value with key ""population"".
 You may rely on the list being sorted by population count, as long as you explain this to readers.


If any of that is impossible or unreasonable in your programming language, then feel free to deviate, as long as you explain your reasons in a comment above your solution.

Test cases


 Search

 Expected result


 Find the (zero-based) index of the first city in the list whose name is ""Dar Es Salaam""

 6


 Find the name of the first city in this list whose population is less than 5 million

 Khartoum-Omdurman


 Find the population of the first city in this list whose name starts with the letter ""A""

 4.58

Guidance
If your programming language supports higher-order programming, then the most elegant way to implement the requested functionality in a generic and reusable way, might be to write a function (maybe called ""find_index"" or similar), that takes two arguments:

 The list to search through.
 A function/lambda/closure (the so-called ""predicate""), which will be applied in turn to each element in the list, and whose boolean return value defines whether that element matches the search requirement.
If this is not the approach which would be most natural or idiomatic in your language, explain why, and show what is.

Related tasks
 Search a list
",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace RosettaSearchListofRecords
{
    class Program
    {
        static void Main(string[] args)
        {
            var dataset = new List<Dictionary<string, object>>() {
                new Dictionary<string, object>   {{ ""name"" , ""Lagos""},                {""population"", 21.0  }},
                new Dictionary<string, object>   {{ ""name"" , ""Cairo""},                {""population"", 15.2  }},
                new Dictionary<string, object>   {{ ""name"" , ""Kinshasa-Brazzaville""}, {""population"", 11.3  }},
                new Dictionary<string, object>   {{ ""name"" , ""Greater Johannesburg""}, {""population"",  7.55 }},
                new Dictionary<string, object>   {{ ""name"" , ""Mogadishu""},            {""population"",  5.85 }},
                new Dictionary<string, object>   {{ ""name"" , ""Khartoum-Omdurman""},    {""population"",  4.98 }},
                new Dictionary<string, object>   {{ ""name"" , ""Dar Es Salaam""},        {""population"",  4.7  }},
                new Dictionary<string, object>   {{ ""name"" , ""Alexandria""},           {""population"",  4.58 }},
                new Dictionary<string, object>   {{ ""name"" , ""Abidjan""},              {""population"",  4.4  }},
                new Dictionary<string, object>   {{ ""name"" , ""Casablanca""},           {""population"",  3.98 }}
            };
 
            // Find the (zero-based) index of the first city in the list whose name is ""Dar Es Salaam""
            var index = dataset.FindIndex(x => ((string)x[""name""]) == ""Dar Es Salaam"");
            Console.WriteLine(index);
 
            // Find the name of the first city in this list whose population is less than 5 million 
            var name = (string)dataset.Find(x => (double)x[""population""] < 5.0)[""name""];
            Console.WriteLine(name);
 
            // Find the population of the first city in this list whose name starts with the letter ""A"" 
            var aNamePopulation = (double)dataset.Find(x => ((string)x[""name""]).StartsWith(""A""))[""population""];
            Console.WriteLine(aNamePopulation);
        }
    }
}",2098,36
20267,http://rosettacode.org/wiki/Safe_addition,Safe addition,"Implementation of   interval arithmetic   and more generally fuzzy number arithmetic require operations that yield safe upper and lower bounds of the exact result.

For example, for an addition, it is the operations    +↑    and    +↓    defined as:    a +↓ b ≤ a + b ≤ a +↑ b. 

Additionally it is desired that the width of the interval    (a +↑ b) - (a +↓ b)    would be about the machine epsilon after removing the exponent part.

Differently to the standard floating-point arithmetic, safe interval arithmetic is accurate (but still imprecise).

I.E.:   the result of each defined operation contains (though does not identify) the exact mathematical outcome.

Usually a   FPU's   have machine    +,-,*,/    operations accurate within the machine precision.

To illustrate it, let us consider a machine with decimal floating-point arithmetic that has the precision is 3 decimal points.

If the result of the machine addition is    1.23,    then the exact mathematical result is within the interval    ]1.22, 1.24[. 

When the machine rounds towards zero, then the exact result is within    [1.23,1.24[.    This is the basis for an implementation of safe addition.



Task;
Show how    +↓    and    +↑    can be implemented in your language using the standard floating-point type.

Define an interval type based on the standard floating-point one,   and implement an interval-valued addition of two floating-point numbers considering them exact, in short an operation that yields the interval    [a +↓ b, a +↑ b]. 
",#C.23,C#,"using System;
 
namespace SafeAddition {
    class Program {
        static float NextUp(float d) {
            if (d == 0.0) return float.Epsilon;
            if (float.IsNaN(d) || float.IsNegativeInfinity(d) || float.IsPositiveInfinity(d)) return d;
 
            byte[] bytes = BitConverter.GetBytes(d);
            int dl = BitConverter.ToInt32(bytes, 0);
            dl++;
            bytes = BitConverter.GetBytes(dl);
 
            return BitConverter.ToSingle(bytes, 0);
        }
 
        static float NextDown(float d) {
            if (d == 0.0) return -float.Epsilon;
            if (float.IsNaN(d) || float.IsNegativeInfinity(d) || float.IsPositiveInfinity(d)) return d;
 
            byte[] bytes = BitConverter.GetBytes(d);
            int dl = BitConverter.ToInt32(bytes, 0);
            dl--;
            bytes = BitConverter.GetBytes(dl);
 
            return BitConverter.ToSingle(bytes, 0);
        }
 
        static Tuple<float, float> SafeAdd(float a, float b) {
            return new Tuple<float, float>(NextDown(a + b), NextUp(a + b));
        }
 
        static void Main(string[] args) {
            float a = 1.20f;
            float b = 0.03f;
 
            Console.WriteLine(""({0} + {1}) is in the range {2}"", a, b, SafeAdd(a, b));
        }
    }
}",1281,40
20305,http://rosettacode.org/wiki/Safe_primes_and_unsafe_primes,Safe primes and unsafe primes,"Definitions

   A   safe prime   is a prime   p   and where   (p-1)/2   is also prime.
   The corresponding prime  (p-1)/2   is known as a   Sophie Germain   prime.
   An   unsafe prime   is a prime   p   and where   (p-1)/2   isn't   a prime.
   An   unsafe prime   is a prime that   isn't   a   safe   prime.


Task

   Find and display (on one line) the first   35   safe primes.
   Find and display the   count   of the safe primes below   1,000,000.
   Find and display the   count   of the safe primes below 10,000,000.
   Find and display (on one line) the first   40   unsafe primes.
   Find and display the   count   of the unsafe primes below   1,000,000.
   Find and display the   count   of the unsafe primes below 10,000,000.
   (Optional)   display the   counts   and   ""below numbers""   with commas.
Show all output here.



Related Task

   strong and weak primes.


Also see

   The OEIS article:     safe   primes.
   The OEIS article:   unsafe primes.

",#C.23,C#,"using static System.Console;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
 
public static class SafePrimes
{
    public static void Main() {
        HashSet<int> primes = Primes(10_000_000).ToHashSet();
        WriteLine(""First 35 safe primes:"");
        WriteLine(string.Join("" "", primes.Where(IsSafe).Take(35)));
        WriteLine($""There are {primes.TakeWhile(p => p < 1_000_000).Count(IsSafe):n0} safe primes below {1_000_000:n0}"");
        WriteLine($""There are {primes.TakeWhile(p => p < 10_000_000).Count(IsSafe):n0} safe primes below {10_000_000:n0}"");
        WriteLine(""First 40 unsafe primes:"");
        WriteLine(string.Join("" "", primes.Where(IsUnsafe).Take(40)));
        WriteLine($""There are {primes.TakeWhile(p => p < 1_000_000).Count(IsUnsafe):n0} unsafe primes below {1_000_000:n0}"");
        WriteLine($""There are {primes.TakeWhile(p => p < 10_000_000).Count(IsUnsafe):n0} unsafe primes below {10_000_000:n0}"");
 
        bool IsSafe(int prime) => primes.Contains(prime / 2);
        bool IsUnsafe(int prime) => !primes.Contains(prime / 2);
    }
 
    //Method from maths library
    static IEnumerable<int> Primes(int bound) {
        if (bound < 2) yield break;
        yield return 2;
 
        BitArray composite = new BitArray((bound - 1) / 2);
        int limit = ((int)(Math.Sqrt(bound)) - 1) / 2;
        for (int i = 0; i < limit; i++) {
            if (composite[i]) continue;
            int prime = 2 * i + 3;
            yield return prime;
            for (int j = (prime * prime - 2) / 2; j < composite.Count; j += prime) composite[j] = true;
        }
        for (int i = limit; i < composite.Count; i++) {
            if (!composite[i]) yield return 2 * i + 3;
        }
    }
 
}",1766,42
20494,http://rosettacode.org/wiki/Search_a_list,Search a list,"Task[edit]
Find the index of a string (needle) in an indexable, ordered collection of strings (haystack).

Raise an exception if the needle is missing.

If there is more than one occurrence then return the smallest index to the needle.

Extra credit
Return the largest index to a needle that has multiple occurrences in the haystack.

See also
 Search a list of records
",#C.23,C#,"using System;
using System.Collections.Generic;
 
class Program {
    static void Main(string[] args) {
        List<string> haystack = new List<string>() { ""Zig"", ""Zag"", ""Wally"", ""Ronald"", ""Bush"", ""Krusty"", ""Charlie"", ""Bush"", ""Bozo"" };
 
        foreach (string needle in new string[] { ""Washington"", ""Bush"" }) {
            int index = haystack.IndexOf(needle);
 
            if (index < 0) Console.WriteLine(""{0} is not in haystack"",needle);                
            else Console.WriteLine(""{0} {1}"",index,needle);
        }
    }
}",538,15
20533,http://rosettacode.org/wiki/RSA_code,RSA code,"Given an RSA key (n,e,d), construct a program to encrypt and decrypt plaintext messages strings.

Background

RSA code is used to encode secret messages. It is named after Ron Rivest, Adi Shamir, and Leonard Adleman who published it at MIT in 1977. The advantage of this type of encryption is that you can distribute the number “



n


{\displaystyle n}

” and “



e


{\displaystyle e}

” (which makes up the Public Key used for encryption) to everyone. The Private Key used for decryption “



d


{\displaystyle d}

” is kept secret, so that only the recipient can read the encrypted plaintext.

The process by which this is done is that a message, for example “Hello World” is encoded as numbers (This could be encoding as ASCII or as a subset of characters 



a
=
01
,
b
=
02
,
.
.
.
,
z
=
26


{\displaystyle a=01,b=02,...,z=26}

). This yields a string of numbers, generally referred to as ""numerical plaintext"", “



P


{\displaystyle P}

”. For example, “Hello World” encoded with a=1,...,z=26 by hundreds would yield 



08051212152315181204


{\displaystyle 08051212152315181204}

.

The plaintext must also be split into blocks so that the numerical plaintext is smaller than 



n


{\displaystyle n}

 otherwise the decryption will fail.

The ciphertext, 



C


{\displaystyle C}

, is then computed by taking each block of 



P


{\displaystyle P}

, and computing

 



C
≡

P

e



mod


n


{\displaystyle C\equiv P^{e}\mod n}


Similarly, to decode, one computes

 



P
≡

C

d



mod


n


{\displaystyle P\equiv C^{d}\mod n}

 
To generate a key, one finds 2 (ideally large) primes 



p


{\displaystyle p}

 and 



q


{\displaystyle q}

. the value “



n


{\displaystyle n}

” is simply: 



n
=
p
×
q


{\displaystyle n=p\times q}

.
One must then choose an “



e


{\displaystyle e}

” such that 



gcd
(
e
,
(
p
−
1
)
×
(
q
−
1
)
)
=
1


{\displaystyle \gcd(e,(p-1)\times (q-1))=1}

. That is to say, 



e


{\displaystyle e}

 and 



(
p
−
1
)
×
(
q
−
1
)


{\displaystyle (p-1)\times (q-1)}

 are relatively prime to each other.

The decryption value 



d


{\displaystyle d}

 is then found by solving

 



d
×
e
≡
1

mod


(
p
−
1
)
×
(
q
−
1
)


{\displaystyle d\times e\equiv 1\mod (p-1)\times (q-1)}


The security of the code is based on the secrecy of the Private Key (decryption exponent) “



d


{\displaystyle d}

” and the difficulty in factoring “



n


{\displaystyle n}

”. Research into RSA facilitated advances in factoring and a number of factoring challenges. Keys of 768 bits have been successfully factored. While factoring of keys of 1024 bits has not been demonstrated, NIST expected them to be factorable by 2010 and now recommends 2048 bit keys going forward (see Asymmetric algorithm key lengths or NIST 800-57 Pt 1 Revised Table 4: Recommended algorithms and minimum key sizes).

Summary of the task requirements:

 Encrypt and Decrypt a short message or two using RSA with a demonstration key. 
 Implement RSA do not call a library.
 Encode and decode the message using any reversible method of your choice (ASCII or a=1,..,z=26 are equally fine). 
 Either support blocking or give an error if the message would require blocking)
 Demonstrate that your solution could support real keys by using a non-trivial key that requires large integer support (built-in or libraries). There is no need to include library code but it must be referenced unless it is built into the language. The following keys will be meet this requirement;however, they are NOT long enough to be considered secure:
 n = 9516311845790656153499716760847001433441357
 e = 65537
 d = 5617843187844953170308463622230283376298685
 Messages can be hard-coded into the program, there is no need for elaborate input coding.
 Demonstrate that your implementation works by showing plaintext, intermediate results, encrypted text, and decrypted text.


 Warning
Rosetta Code is not a place you should rely on for examples of code in critical roles, including security.
Cryptographic routines should be validated before being used.
For a discussion of limitations and please refer to Talk:RSA_code#Difference_from_practical_cryptographical_version.
",#C.23,C#,"using System;
using System.Numerics;
using System.Text;
 
class Program
{
    static void Main(string[] args)
    {
        BigInteger n = BigInteger.Parse(""9516311845790656153499716760847001433441357"");
        BigInteger e = 65537;
        BigInteger d = BigInteger.Parse(""5617843187844953170308463622230283376298685"");
 
        const string plaintextstring = ""Hello, Rosetta!"";
        byte[] plaintext = ASCIIEncoding.ASCII.GetBytes(plaintextstring);
        BigInteger pt = new BigInteger(plaintext);
        if (pt > n)
            throw new Exception();
 
        BigInteger ct = BigInteger.ModPow(pt, e, n);
        Console.WriteLine(""Encoded:  "" + ct);
 
        BigInteger dc = BigInteger.ModPow(ct, d, n);
        Console.WriteLine(""Decoded:  "" + dc);
 
        string decoded = ASCIIEncoding.ASCII.GetString(dc.ToByteArray());
        Console.WriteLine(""As ASCII: "" + decoded);
    }
}",898,28
20668,http://rosettacode.org/wiki/Runge-Kutta_method,Runge-Kutta method,"Given the example Differential equation:






y
′

(
t
)
=
t
×


y
(
t
)




{\displaystyle y'(t)=t\times {\sqrt {y(t)}}}


With initial condition:






t

0


=
0


{\displaystyle t_{0}=0}

 and 




y

0


=
y
(

t

0


)
=
y
(
0
)
=
1


{\displaystyle y_{0}=y(t_{0})=y(0)=1}


This equation has an exact solution:





y
(
t
)
=



1
16



(

t

2


+
4

)

2




{\displaystyle y(t)={\tfrac {1}{16}}(t^{2}+4)^{2}}




Task
Demonstrate the commonly used explicit   fourth-order Runge–Kutta method   to solve the above differential equation.

 Solve the given differential equation over the range 



t
=
0
…
10


{\displaystyle t=0\ldots 10}

 with a step value of 



δ
t
=
0.1


{\displaystyle \delta t=0.1}

 (101 total points, the first being given)
 Print the calculated values of 



y


{\displaystyle y}

 at whole numbered 



t


{\displaystyle t}

's (



0.0
,
1.0
,
…
10.0


{\displaystyle 0.0,1.0,\ldots 10.0}

) along with error as compared to the exact solution.


Method summary
Starting with a given 




y

n




{\displaystyle y_{n}}

 and 




t

n




{\displaystyle t_{n}}

 calculate:





δ

y

1


=
δ
t
×

y
′

(

t

n


,

y

n


)



{\displaystyle \delta y_{1}=\delta t\times y'(t_{n},y_{n})\quad }






δ

y

2


=
δ
t
×

y
′

(

t

n


+



1
2



δ
t
,

y

n


+



1
2



δ

y

1


)


{\displaystyle \delta y_{2}=\delta t\times y'(t_{n}+{\tfrac {1}{2}}\delta t,y_{n}+{\tfrac {1}{2}}\delta y_{1})}






δ

y

3


=
δ
t
×

y
′

(

t

n


+



1
2



δ
t
,

y

n


+



1
2



δ

y

2


)


{\displaystyle \delta y_{3}=\delta t\times y'(t_{n}+{\tfrac {1}{2}}\delta t,y_{n}+{\tfrac {1}{2}}\delta y_{2})}






δ

y

4


=
δ
t
×

y
′

(

t

n


+
δ
t
,

y

n


+
δ

y

3


)



{\displaystyle \delta y_{4}=\delta t\times y'(t_{n}+\delta t,y_{n}+\delta y_{3})\quad }


then:






y

n
+
1


=

y

n


+



1
6



(
δ

y

1


+
2
δ

y

2


+
2
δ

y

3


+
δ

y

4


)


{\displaystyle y_{n+1}=y_{n}+{\tfrac {1}{6}}(\delta y_{1}+2\delta y_{2}+2\delta y_{3}+\delta y_{4})}







t

n
+
1


=

t

n


+
δ
t



{\displaystyle t_{n+1}=t_{n}+\delta t\quad }



",#C.23,C#," 
using System;
 
namespace RungeKutta
{
    class Program
    {
        static void Main(string[] args)
        {
            //Incrementers to pass into the known solution
            double t = 0.0;
            double T = 10.0;
            double dt = 0.1;
 
            // Assign the number of elements needed for the arrays
            int n = (int)(((T - t) / dt)) + 1;
 
            // Initialize the arrays for the time index 's' and estimates 'y' at each index 'i'
            double[] y = new double[n];
            double[] s = new double[n];
 
            // RK4 Variables
            double dy1;
            double dy2;
            double dy3;
            double dy4;
 
            // RK4 Initializations
            int i = 0;
            s[i] = 0.0;
            y[i] = 1.0;
 
            Console.WriteLine("" ===================================== "");
            Console.WriteLine("" Beging 4th Order Runge Kutta Method "");
            Console.WriteLine("" ===================================== "");
 
            Console.WriteLine();
            Console.WriteLine("" Given the example Differential equation: \n"");
            Console.WriteLine(""     y' = t*sqrt(y) \n"");
            Console.WriteLine("" With the initial conditions: \n"");
            Console.WriteLine(""     t0 = 0"" + "", y(0) = 1.0 \n"");
            Console.WriteLine("" Whose exact solution is known to be: \n"");
            Console.WriteLine(""     y(t) = 1/16*(t^2 + 4)^2 \n"");
            Console.WriteLine("" Solve the given equations over the range t = 0...10 with a step value dt = 0.1 \n"");
            Console.WriteLine("" Print the calculated values of y at whole numbered t's (0.0,1.0,...10.0) along with the error \n"");
            Console.WriteLine();
 
            Console.WriteLine("" y(t) "" +""RK4"" + "" "".PadRight(18) + ""Absolute Error"");
            Console.WriteLine("" -------------------------------------------------"");
            Console.WriteLine("" y(0) "" + y[i] + "" "".PadRight(20) + (y[i] - solution(s[i])));
 
            // Iterate and implement the Rk4 Algorithm
            while (i < y.Length - 1)
            {
 
                dy1 = dt * equation(s[i], y[i]);
                dy2 = dt * equation(s[i] + dt / 2, y[i] + dy1 / 2);
                dy3 = dt * equation(s[i] + dt / 2, y[i] + dy2 / 2);
                dy4 = dt * equation(s[i] + dt, y[i] + dy3);
 
                s[i + 1] = s[i] + dt;
                y[i + 1] = y[i] + (dy1 + 2 * dy2 + 2 * dy3 + dy4) / 6;
 
                double error = Math.Abs(y[i + 1] - solution(s[i + 1]));
                double t_rounded = Math.Round(t + dt, 2);
 
                if (t_rounded % 1 == 0)
                {
                    Console.WriteLine("" y("" + t_rounded + "")"" + "" "" + y[i + 1] + "" "".PadRight(5) + (error));
                }
 
                i++;
                t += dt;
 
            };//End Rk4
 
            Console.ReadLine();
        }
 
        // Differential Equation
        public static double equation(double t, double y)
        {
            double y_prime;
            return y_prime = t*Math.Sqrt(y);
        }
 
        // Exact Solution
        public static double solution(double t)
        {
            double actual;
            actual = Math.Pow((Math.Pow(t, 2) + 4), 2)/16;
            return actual;
        }
    }
}",3309,95
20689,http://rosettacode.org/wiki/S-expressions,S-expressions,"S-Expressions   are one convenient way to parse and store data.



Task

Write a simple reader and writer for S-Expressions that handles quoted and unquoted strings, integers and floats.

The reader should read a single but nested S-Expression from a string and store it in a suitable datastructure (list, array, etc).

Newlines and other whitespace may be ignored unless contained within a quoted string.

“()”   inside quoted strings are not interpreted, but treated as part of the string.

Handling escaped quotes inside a string is optional;   thus “(foo""bar)” maybe treated as a string “foo""bar”, or as an error.

For this, the reader need not recognize “\” for escaping, but should, in addition, recognize numbers if the language has appropriate datatypes.

Languages that support it may treat unquoted strings as symbols.

Note that with the exception of “()""” (“\” if escaping is supported) and whitespace there are no special characters. Anything else is allowed without quotes.

The reader should be able to read the following input

((data ""quoted data"" 123 4.5)
 (data (!@# (4.5) ""(more"" ""data)"")))
and turn it into a native datastructure. (see the Pike, Python and Ruby implementations for examples of native data structures.)

The writer should be able to take the produced list and turn it into a new S-Expression.
Strings that don't contain whitespace or parentheses () don't need to be quoted in the resulting S-Expression, but as a simplification, any string may be quoted.



Extra Credit

Let the writer produce pretty printed output with indenting and line-breaks.



",#C.23,C#," 
using System;
using System.Collections.Generic;
using System.Text;
 
  public class SNode
    {
        private List<SNode> _items;
        public string Name { get; set; }
        public IReadOnlyCollection<SNode> Items { get { return _items.AsReadOnly(); } }
        public SNode()
        {
            this._items = new List<SNode>();
        }
        public SNode(string name):this()
        {
            this.Name=name;
        }
        public void AddNode(SNode node)
        {
            this._items.Add(node);
        }      
    }
 
    public class SNodeFull : SNode
    {
        private bool _isLeaf;
        public bool IsLeaf { get => _isLeaf; }
        public SNodeFull(bool isLeaf) : base()
        {
            this._isLeaf = isLeaf;
        }
 
        public SNodeFull(string name, bool isLeaf) : base(name)
        {
            this._isLeaf = isLeaf;
        }
 
        public SNodeFull RootNode { get; set; }
 
        public void AddNode(SNodeFull node)
        {
            base.AddNode(node);
            node.RootNode = this;
        }
    }
 
 ",1081,48
20693,http://rosettacode.org/wiki/RPG_attributes_generator,RPG attributes generator,"RPG   =   Role Playing Game.



You're running a tabletop RPG, and your players are creating characters.

Each character has six core attributes: strength, dexterity, constitution, intelligence, wisdom, and charisma.

One way of generating values for these attributes is to roll four, 6-sided dice (d6) and sum the three highest rolls, discarding the lowest roll.

Some players like to assign values to their attributes in the order they're rolled.

To ensure generated characters don't put players at a disadvantage, the following requirements must be satisfied:

 The total of all character attributes must be at least 75.
 At least two of the attributes must be at least 15.

However, this can require a lot of manual dice rolling. A programatic solution would be much faster.



Task

Write a program that:

 Generates 4 random, whole values between 1 and 6.
 Saves the sum of the 3 largest values.
 Generates a total of 6 values this way.
 Displays the total, and all 6 values once finished.

 The order in which each value was generated must be preserved.
 The total of all 6 values must be at least 75.
 At least 2 of the values must be 15 or more.
",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
static class Module1
{
    static Random r = new Random();
 
    static List<int> getThree(int n)
    {
        List<int> g3 = new List<int>();
        for (int i = 0; i < 4; i++) g3.Add(r.Next(n) + 1);
        g3.Sort(); g3.RemoveAt(0); return g3;
    }
 
    static List<int> getSix()
    {
        List<int> g6 = new List<int>();
        for (int i = 0; i < 6; i++) g6.Add(getThree(6).Sum());
        return g6;
    }
 
    static void Main(string[] args)
    {
        bool good = false; do {
            List<int> gs = getSix(); int gss = gs.Sum(); int hvc = gs.FindAll(x => x > 14).Count;
            Console.Write(""attribs: {0}, sum={1}, ({2} sum, high vals={3})"",
                          string.Join("", "", gs), gss, gss >= 75 ? ""good"" : ""low"", hvc);
            Console.WriteLine("" - {0}"", (good = gs.Sum() >= 75 && hvc > 1) ? ""success"" : ""failure"");
        } while (!good);
    }
}",962,32
20738,http://rosettacode.org/wiki/Rosetta_Code/Rank_languages_by_popularity,Rosetta Code/Rank languages by popularity,"Rosetta Code/Rank languages by popularity

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Sort the most popular computer programming languages based in number of members in Rosetta Code categories.

Sample output on 01 juin 2022 at 14:13 +02

Rank:  1 (1,540 entries) Phix
Rank:  2 (1,531 entries) Wren
Rank:  3 (1,507 entries) Julia
Rank:  4 (1,494 entries) Go
Rank:  5 (1,488 entries) Raku
Rank:  6 (1,448 entries) Perl
Rank:  7 (1,402 entries) Nim
Rank:  8 (1,382 entries) Python
Rank:  9 (1,204 entries) C
Rank: 10 (1,152 entries) REXX
...


Notes
 
   Each language typically demonstrates one or two methods of accessing the data: 
   with web scraping   (via http://www.rosettacode.org/mw/index.php?title=Special:Categories&limit=5000)
   with the API method   (examples below for Awk, Perl, Ruby, Tcl, etc). 
   The scraping and API solutions can be separate subsections, see the Tcl example.
   Filtering wrong results is optional.   You can check against Special:MostLinkedCategories (if using web scraping)
If you use the API, and do elect to filter, you may check your results against this complete, accurate, sortable, wikitable listing of all 869 programming languages, updated periodically, typically weekly.
   A complete ranked listing of all   813   languages (from the REXX example) is included here   ──►   output from the REXX program.

",#C.23,C#,"using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
 
class Program
{
    static void Main(string[] args)
    {
        string get1 = new WebClient().DownloadString(""http://www.rosettacode.org/w/api.php?action=query&list=categorymembers&cmtitle=Category:Programming_Languages&cmlimit=500&format=json"");
        string get2 = new WebClient().DownloadString(""http://www.rosettacode.org/w/index.php?title=Special:Categories&limit=5000"");
 
        ArrayList langs = new ArrayList();
        Dictionary<string, int> qtdmbr = new Dictionary<string, int>();
 
        MatchCollection match1 = new Regex(""\""title\"":\""Category:(.+?)\"""").Matches(get1);
        MatchCollection match2 = new Regex(""title=\""Category:(.+?)\"">.+?</a>[^(]*\\((\\d+) members\\)"").Matches(get2);
 
        foreach (Match lang in match1) langs.Add(lang.Groups[1].Value);
 
        foreach (Match match in match2)
        {
            if (langs.Contains(match.Groups[1].Value))
            {
                qtdmbr.Add(match.Groups[1].Value, Int32.Parse(match.Groups[2].Value));
            }
        }
 
        string[] test = qtdmbr.OrderByDescending(x => x.Value).Select(x => String.Format(""{0,3} - {1}"", x.Value, x.Key)).ToArray();
 
        int count = 1;
 
        foreach (string i in test)
        {
            Console.WriteLine(""{0,3}. {1}"", count, i);
            count++;
        }
    }
}",1465,41
20773,http://rosettacode.org/wiki/Rosetta_Code/Find_unimplemented_tasks,Rosetta Code/Find unimplemented tasks,"Task

Given the name of a language on Rosetta Code, find all tasks which are not implemented in that language.



Note: Implementations should allow for fetching more data than can be returned in one request to Rosetta Code.

You'll need to use the Media Wiki API, which you can find out about locally, here, or in Media Wiki's API documentation at, API:Query
",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Net;
 
class Program {
    static List<string> GetTitlesFromCategory(string category) {
        string searchQueryFormat = ""http://www.rosettacode.org/w/api.php?action=query&list=categorymembers&cmtitle=Category:{0}&format=json{1}"";
        List<string> results = new List<string>();
        string cmcontinue = string.Empty;
 
        do {
            string cmContinueKeyValue;
 
            //append continue variable as needed
            if (cmcontinue.Length > 0)
                cmContinueKeyValue = String.Format(""&cmcontinue={0}"", cmcontinue);
            else
                cmContinueKeyValue = String.Empty;
 
            //execute query
            string query = String.Format(searchQueryFormat, category, cmContinueKeyValue);
            string content = new WebClient().DownloadString(query);
 
            results.AddRange(new Regex(""\""title\"":\""(.+?)\"""").Matches(content).Cast<Match>().Select(x => x.Groups[1].Value));
 
            //detect if more results are available
            cmcontinue = Regex.Match(content, @""{""""cmcontinue"""":""""([^""""]+)""""}"", RegexOptions.IgnoreCase).Groups[""1""].Value;                
        } while (cmcontinue.Length > 0);
 
        return results;
    }
 
    static string[] GetUnimplementedTasksFromLanguage(string language) {
        List<string> alltasks = GetTitlesFromCategory(""Programming_Tasks"");
        List<string> lang = GetTitlesFromCategory(language);
 
        return alltasks.Where(x => !lang.Contains(x)).ToArray();
    }
 
    static void Main(string[] args) {
        string[] unimpl = GetUnimplementedTasksFromLanguage(args[0]);
 
        foreach (string i in unimpl) Console.WriteLine(i);
    }
}",1785,47
20823,http://rosettacode.org/wiki/Rosetta_Code/Count_examples,Rosetta Code/Count examples,"task
Essentially, count the number of occurrences of =={{header| on each task page.

Output:

100 doors: 20 examples.
99 Bottles of Beer: 29 examples.
Abstract type: 10 examples.

Total: X examples.
For a full output, updated periodically, see Rosetta Code/Count examples/Full list.

You'll need to use the Media Wiki API, which you can find out about locally, here, or in Media Wiki's API documentation at, API:Query
",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Net;
 
class Task {
    private string _task;
    private int _examples;
 
    public Task(string task, int examples) {
        _task = task;
        _examples = examples;
    }
 
    public string Name {
        get { return _task; }
    }
 
    public int Examples {
        get { return _examples; }
    }
 
    public override string ToString() {
        return String.Format(""{0}: {1} examples."", this._task, this._examples);
    }
}
 
class Program {
    static List<string> GetTitlesFromCategory(string category, WebClient wc) {
        string content = wc.DownloadString(
            String.Format(""http://www.rosettacode.org/w/api.php?action=query&list=categorymembers&cmtitle=Category:{0}&cmlimit=500&format=json"", category)
        );
 
        return new Regex(""\""title\"":\""(.+?)\"""").Matches(content).Cast<Match>().Select(x => x.Groups[1].Value.Replace(""\\/"", ""/"")).ToList();
    }
 
    static string GetSourceCodeFromPage(string page, WebClient wc) {
        return wc.DownloadString(
            String.Format(""http://www.rosettacode.org/w/index.php?title={0}&action=raw"", page)
        );
    }
 
    static void Main(string[] args) {
        WebClient wc = new WebClient();
        List<Task> tasks = new List<Task>();
        List<string> tasknames = GetTitlesFromCategory(""Programming_Tasks"", wc);
 
        foreach (string task in tasknames) {
            string content = GetSourceCodeFromPage(task, wc);
            int count = new Regex(""=={{header"", RegexOptions.IgnoreCase).Matches(content).Count;
            Task t = new Task(task, count);
 
            Console.WriteLine(t);
            tasks.Add(t);
        }
 
        Console.WriteLine(""\nTotal: {0} examples."", tasks.Select(x => x.Examples).Sum());
    }
}",1856,60
20884,http://rosettacode.org/wiki/Roots_of_unity,Roots of unity,"The purpose of this task is to explore working with   complex numbers.



Task

Given   n,   find the   nth   roots of unity.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
 
class Program
{
    static IEnumerable<Complex> RootsOfUnity(int degree)
    {
        return Enumerable
            .Range(0, degree)
            .Select(element => Complex.FromPolarCoordinates(1, 2 * Math.PI * element / degree));
    }
 
    static void Main()
    {
        var degree = 3;
        foreach (var root in RootsOfUnity(degree))
        {
            Console.WriteLine(root);
        }
    }
}",500,23
20887,http://rosettacode.org/wiki/Roots_of_a_quadratic_function,Roots of a quadratic function,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.
Write a program to find the roots of a quadratic equation, i.e., solve the equation 



a

x

2


+
b
x
+
c
=
0


{\displaystyle ax^{2}+bx+c=0}

.
Your program must correctly handle non-real roots, but it need not check that 



a
≠
0


{\displaystyle a\neq 0}

.

The problem of solving a quadratic equation is a good example of how dangerous it can be to ignore the peculiarities of floating-point arithmetic.
The obvious way to implement the quadratic formula suffers catastrophic loss of accuracy when one of the roots to be found is much closer to 0 than the other.
In their classic textbook on numeric methods Computer Methods for Mathematical Computations, George Forsythe, Michael Malcolm, and Cleve Moler suggest trying the naive algorithm with 



a
=
1


{\displaystyle a=1}

, 



b
=
−

10

5




{\displaystyle b=-10^{5}}

, and 



c
=
1


{\displaystyle c=1}

.
(For double-precision floats, set 



b
=
−

10

9




{\displaystyle b=-10^{9}}

.)
Consider the following implementation in Ada:

with Ada.Text_IO;                        use Ada.Text_IO;
with Ada.Numerics.Elementary_Functions;  use Ada.Numerics.Elementary_Functions;
 
procedure Quadratic_Equation is
   type Roots is array (1..2) of Float;
   function Solve (A, B, C : Float) return Roots is
      SD : constant Float := sqrt (B**2 - 4.0 * A * C);
      AA : constant Float := 2.0 * A;
   begin
      return ((- B + SD) / AA, (- B - SD) / AA);
   end Solve;
 
   R : constant Roots := Solve (1.0, -10.0E5, 1.0);
begin
   Put_Line (""X1 ="" & Float'Image (R (1)) & "" X2 ="" & Float'Image (R (2)));
end Quadratic_Equation;

Output:
X1 = 1.00000E+06 X2 = 0.00000E+00
As we can see, the second root has lost all significant figures. The right answer is that X2 is about 




10

−
6




{\displaystyle 10^{-6}}

. The naive method is numerically unstable.

Suggested by Middlebrook (D-OA), a better numerical method: to define two parameters 



q
=


a
c



/

b


{\displaystyle q={\sqrt {ac}}/b}

 and 



f
=
1

/

2
+


1
−
4

q

2





/

2


{\displaystyle f=1/2+{\sqrt {1-4q^{2}}}/2}



and the two roots of the quardratic are: 






−
b

a


f


{\displaystyle {\frac {-b}{a}}f}

 and 






−
c


b
f





{\displaystyle {\frac {-c}{bf}}}




Task: do it better. This means that given 



a
=
1


{\displaystyle a=1}

, 



b
=
−

10

9




{\displaystyle b=-10^{9}}

, and 



c
=
1


{\displaystyle c=1}

, both of the roots your program returns should be greater than 




10

−
11




{\displaystyle 10^{-11}}

. Or, if your language can't do floating-point arithmetic any more precisely than single precision, your program should be able to handle 



b
=
−

10

6




{\displaystyle b=-10^{6}}

. Either way, show what your program gives as the roots of the quadratic in question. See page 9 of
""What Every Scientist Should Know About Floating-Point Arithmetic"" for a possible algorithm.
",#C.23,C#,"using System;
using System.Numerics;
 
class QuadraticRoots
{
    static Tuple<Complex, Complex> Solve(double a, double b, double c)
    {
        var q = -(b + Math.Sign(b) * Complex.Sqrt(b * b - 4 * a * c)) / 2;
        return Tuple.Create(q / a, c / q);
    }
 
    static void Main()
    {
        Console.WriteLine(Solve(1, -1E20, 1));
    }
}",348,16
20940,http://rosettacode.org/wiki/Run-length_encoding,Run-length encoding,"Run-length encoding

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Given a string containing uppercase characters (A-Z), compress repeated 'runs' of the same character by storing the length of that run, and provide a function to reverse the compression.

The output can be anything, as long as you can recreate the input with it.



Example

 Input: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW
 Output: 12W1B12W3B24W1B14W


Note: the encoding step in the above example is the same as a step of the Look-and-say sequence.



",#C.23,C#,"using System.Collections.Generic;
using System.Linq;
using static System.Console;
using static System.Linq.Enumerable;
 
namespace RunLengthEncoding
{
    static class Program
    {
          public static string Encode(string input) => input.Length ==0 ? """" : input.Skip(1)
            .Aggregate((t:input[0].ToString(),o:Empty<string>()),
               (a,c)=>a.t[0]==c ? (a.t+c,a.o) : (c.ToString(),a.o.Append(a.t)),
               a=>a.o.Append(a.t).Select(p => (key: p.Length, chr: p[0])))
            .Select(p=> $""{p.key}{p.chr}"")
            .StringConcat();
 
        public static string Decode(string input) => input
            .Aggregate((t: """", o: Empty<string>()), (a, c) => !char.IsDigit(c) ? ("""", a.o.Append(a.t+c)) : (a.t + c,a.o)).o 
            .Select(p => new string(p.Last(), int.Parse(string.Concat(p.Where(char.IsDigit)))))
            .StringConcat();
 
        private static string StringConcat(this IEnumerable<string> seq) => string.Concat(seq);
 
        public static void Main(string[] args)
        {
            const string  raw = ""WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW"";
            const string encoded = ""12W1B12W3B24W1B14W"";
 
            WriteLine($""raw = {raw}"");
            WriteLine($""encoded = {encoded}"");
            WriteLine($""Encode(raw) = encoded = {Encode(raw)}"");
            WriteLine($""Decode(encode) = {Decode(encoded)}"");
            WriteLine($""Decode(Encode(raw)) = {Decode(Encode(raw)) == raw}"");
            ReadLine();
        }
    }
}",1530,37
21065,http://rosettacode.org/wiki/Roots_of_a_function,Roots of a function,"Task

Create a program that finds and outputs the roots of a given function, range and (if applicable) step width.

The program should identify whether the root is exact or approximate.



For this task, use:      ƒ(x)   =   x3 - 3x2 + 2x 
",#C.23,C#,"using System;
 
class Program
{
    public static void Main(string[] args)
    {
        Func<double, double> f = x => { return x * x * x - 3 * x * x + 2 * x; };
 
        double step = 0.001; // Smaller step values produce more accurate and precise results
        double start = -1;
        double stop = 3;
        double value = f(start);
        int sign = (value > 0) ? 1 : 0;
 
        // Check for root at start
        if (value == 0)
            Console.WriteLine(""Root found at {0}"", start);
 
        for (var x = start + step; x <= stop; x += step)
        {
            value = f(x);
 
            if (((value > 0) ? 1 : 0) != sign)
                // We passed a root
                Console.WriteLine(""Root found near {0}"", x);
            else if (value == 0)
                // We hit a root
                Console.WriteLine(""Root found at {0}"", x);
 
            // Update our sign
            sign = (value > 0) ? 1 : 0;
        }
    }
}",959,34
21092,http://rosettacode.org/wiki/Rot-13,Rot-13,"

Task

Implement a   rot-13   function   (or procedure, class, subroutine, or other ""callable"" object as appropriate to your programming environment).

Optionally wrap this function in a utility program   (like tr,   which acts like a common UNIX utility, performing a line-by-line rot-13 encoding of every line of input contained in each file listed on its command line,   or (if no filenames are passed thereon) acting as a filter on its   ""standard input.""



(A number of UNIX scripting languages and utilities, such as   awk   and   sed   either default to processing files in this way or have command line switches or modules to easily implement these wrapper semantics, e.g.,   Perl   and   Python).

The   rot-13   encoding is commonly known from the early days of Usenet ""Netnews"" as a way of obfuscating text to prevent casual reading of   spoiler   or potentially offensive material.

Many news reader and mail user agent programs have built-in rot-13 encoder/decoders or have the ability to feed a message through any external utility script for performing this (or other) actions.

The definition of the rot-13 function is to simply replace every letter of the ASCII alphabet with the letter which is ""rotated"" 13 characters ""around"" the 26 letter alphabet from its normal cardinal position   (wrapping around from   z   to   a   as necessary).

Thus the letters   abc   become   nop   and so on.

Technically rot-13 is a   ""mono-alphabetic substitution cipher""   with a trivial   ""key"".

A proper implementation should work on upper and lower case letters, preserve case, and pass all non-alphabetic characters
in the input stream through without alteration.



Related tasks

   Caesar cipher
   Substitution Cipher
   Vigenère Cipher/Cryptanalysis



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.IO;
using System.Linq;
using System.Text;
 
class Program
{
    static char Rot13(char c)
    {
        if ('a' <= c && c <= 'm' || 'A' <= c && c <= 'M')
        {
            return (char)(c + 13);
        }
        if ('n' <= c && c <= 'z' || 'N' <= c && c <= 'Z')
        {
            return (char)(c - 13);
        }
        return c;
    }
 
    static string Rot13(string s)
    {
        return new string(s.Select(Rot13).ToArray());
    }
 
 
    static void Main(string[] args)
    {
        foreach (var file in args.Where(file => File.Exists(file)))
        {
            Console.WriteLine(Rot13(File.ReadAllText(file)));
        }
        if (!args.Any())
        {
            Console.WriteLine(Rot13(Console.In.ReadToEnd()));
        }
    }
}",785,38
21202,http://rosettacode.org/wiki/Rock-paper-scissors,Rock-paper-scissors,"Task

Implement the classic children's game Rock-paper-scissors, as well as a simple predictive   AI   (artificial intelligence)   player.

Rock Paper Scissors is a two player game.

Each player chooses one of rock, paper or scissors, without knowing the other player's choice.

The winner is decided by a set of rules:

   Rock beats scissors
   Scissors beat paper
   Paper beats rock


If both players choose the same thing, there is no winner for that round.

For this task, the computer will be one of the players.

The operator will select Rock, Paper or Scissors and the computer will keep a record of the choice frequency, and use that information to make a weighted random choice in an attempt to defeat its opponent.



Extra credit

Support additional choices   additional weapons.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace RockPaperScissors
{
    class Program
    {
        static void Main(string[] args)
        {
            // There is no limit on the amount of weapons supported by RPSGame. Matchups are calculated depending on the order.
            var rps = new RPSGame(""scissors"", ""paper"", ""rock"", ""lizard"", ""spock"");
 
            int wins = 0, losses = 0, draws = 0;
 
            while (true)
            {
                Console.WriteLine(""Make your move: "" + string.Join("", "", rps.Weapons) + "", quit"");
 
                string weapon = Console.ReadLine().Trim().ToLower();
 
                if (weapon == ""quit"")
                    break;
 
                if (!rps.Weapons.Contains(weapon))
                {
                    Console.WriteLine(""Invalid weapon!"");
                    continue;
                }
 
                int result = rps.Next(weapon);
 
                Console.WriteLine(""You chose {0} and your opponent chose {1}!"", weapon, rps.LastAIWeapon);
 
                switch (result)
                {
                    case 1: Console.WriteLine(""{0} pwns {1}. You're a winner!"", weapon, rps.LastAIWeapon);
                        wins++;
                        break;
                    case 0: Console.WriteLine(""Draw!"");
                        draws++;
                        break;
                    case -1: Console.WriteLine(""{0} pwns {1}. You're a loser!"", rps.LastAIWeapon, weapon);
                        losses++;
                        break;
                }
 
                Console.WriteLine();
            }
 
            Console.WriteLine(""\nPlayer Statistics\nWins: {0}\nLosses: {1}\nDraws: {2}"", wins, losses, draws);
        }
 
        class RPSGame
        {
            public RPSGame(params string[] weapons)
            {
                Weapons = weapons;
 
                // Creates a new AI opponent, and gives it the list of weapons.
                _rpsAI = new RPSAI(weapons);
            }
 
            // Play next turn.
            public int Next(string weapon)
            {
                string aiWeapon = _rpsAI.NextMove(); // Gets the AI opponent's next move.
                LastAIWeapon = aiWeapon; // Saves the AI opponent's move in a property so the player can see it.
 
                _rpsAI.AddPlayerMove(weapon); // Let the AI know which weapon the player chose, for future predictions.
                return GetWinner(Weapons, weapon, aiWeapon); // Returns -1 if AI win, 0 if draw, and 1 if player win.
            }
 
            // Returns matchup winner.
            public static int GetWinner(string[] weapons, string weapon1, string weapon2)
            {
                if (weapon1 == weapon2)
                    return 0; // If weapons are the same, return 0 for draw.
 
                if (GetVictories(weapons, weapon1).Contains(weapon2))
                    return 1; // Returns 1 for weapon1 win.
                else if (GetVictories(weapons, weapon2).Contains(weapon1))
                    return -1; // Returns -1 for weapon2 win.
 
                throw new Exception(""No winner found."");
            }
 
            /* 
             * Return weapons that the provided weapon beats.
             * The are calculated in the following way:
             * If the index of the weapon is even, then all even indices less than it,
             * and all odd indices greater than it, are victories.
             * One exception is if it is an odd index, and also the last index in the set,
             * then the first index in the set is a victory.
             */
            public static IEnumerable<string> GetVictories(string[] weapons, string weapon)
            {
                // Gets index of weapon.
                int index = Array.IndexOf(weapons, weapon);
 
                // If weapon is odd and the final index in the set, then return the first item in the set as a victory.
                if (index % 2 != 0 && index == weapons.Length - 1)
                    yield return weapons[0];
 
                for (int i = index - 2; i >= 0; i -= 2)
                    yield return weapons[i];
 
                for (int i = index + 1; i < weapons.Length; i += 2)
                    yield return weapons[i];
            }
 
            public string LastAIWeapon
            {
                private set;
                get;
            }
 
            public readonly string[] Weapons;
            private RPSAI _rpsAI;
 
            class RPSAI
            {
                public RPSAI(params string[] weapons)
                {
                    _weapons = weapons;
                    _weaponProbability = new Dictionary<string, int>();
 
                    // The AI sets the probability for each weapon to be chosen as 1.
                    foreach (string weapon in weapons)
                        _weaponProbability.Add(weapon, 1);
 
                    _random = new Random();
                }
 
                // Increases probability of selecting each weapon that beats the provided move.
                public void AddPlayerMove(string weapon)
                {
                    int index = Array.IndexOf(_weapons, weapon);
 
                    foreach (string winWeapon in _weapons.Except(GetVictories(_weapons, weapon)))
                        if (winWeapon != weapon)
                            _weaponProbability[winWeapon]++;
                }
 
                // Gets the AI's next move.
                public string NextMove()
                {
                    double r = _random.NextDouble();
 
                    double divisor = _weaponProbability.Values.Sum();
 
                    var weightedWeaponRanges = new Dictionary<double, string>();
 
                    double currentPos = 0.0;
 
                    // Maps probabilities to ranges between 0.0 and 1.0. Returns weighted random weapon.
                    foreach (var weapon in _weaponProbability)
                    {
                        double weightedRange = weapon.Value / divisor;
                        if (r <= currentPos + (weapon.Value / divisor))
                            return weapon.Key;
                        currentPos += weightedRange;
                    }
 
                    throw new Exception(""Error calculating move."");
                }
 
                Random _random;
                private readonly string[] _weapons;
                private Dictionary<string, int> _weaponProbability;
            }
        }
    }
}",6561,174
21370,http://rosettacode.org/wiki/Roman_numerals/Decode,Roman numerals/Decode,"Task

Create a function that takes a Roman numeral as its argument and returns its value as a numeric decimal integer.

You don't need to validate the form of the Roman numeral.

Modern Roman numerals are written by expressing each decimal digit of the number to be encoded separately,

starting with the leftmost decimal digit and skipping any 0s   (zeroes).

1990 is rendered as   MCMXC     (1000 = M,   900 = CM,   90 = XC)     and

2008 is rendered as   MMVIII       (2000 = MM,   8 = VIII).

The Roman numeral for 1666,   MDCLXVI,   uses each letter in descending order.



",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace Roman
{
    internal class Program
    {
        private static void Main(string[] args)
        {
            // Decode and print the numerals.
            Console.WriteLine(""{0}: {1}"", ""MCMXC"", Decode(""MCMXC""));
            Console.WriteLine(""{0}: {1}"", ""MMVIII"", Decode(""MMVIII""));
            Console.WriteLine(""{0}: {1}"", ""MDCLXVI"", Decode(""MDCLXVI""));
        }
 
        // Dictionary to hold our numerals and their values.
        private static readonly Dictionary<char, int> RomanDictionary = new Dictionary<char, int>
                                                                            {
                                                                                {'I', 1},
                                                                                {'V', 5},
                                                                                {'X', 10},
                                                                                {'L', 50},
                                                                                {'C', 100},
                                                                                {'D', 500},
                                                                                {'M', 1000}
                                                                            };
 
        private static int Decode(string roman)
        {
            /* Make the input string upper-case,
             * because the dictionary doesn't support lower-case characters. */
            roman = roman.ToUpper();
 
            /* total = the current total value that will be returned.
             * minus = value to subtract from next numeral. */
            int total = 0, minus = 0;
 
            for (int i = 0; i < roman.Length; i++) // Iterate through characters.
            {
                // Get the value for the current numeral. Takes subtraction into account.
                int thisNumeral = RomanDictionary[roman[i]] - minus;
 
                /* Checks if this is the last character in the string, or if the current numeral
                 * is greater than or equal to the next numeral. If so, we will reset our minus
                 * variable and add the current numeral to the total value. Otherwise, we will
                 * subtract the current numeral from the next numeral, and continue. */
                if (i >= roman.Length - 1 ||
                    thisNumeral + minus >= RomanDictionary[roman[i + 1]])
                {
                    total += thisNumeral;
                    minus = 0;
                }
                else
                {
                    minus = thisNumeral;
                }
            }
 
            return total; // Return the total.
        }
    }
}",2824,62
21433,http://rosettacode.org/wiki/Roman_numerals/Encode,Roman numerals/Encode,"Task

Create a function taking a positive integer as its parameter and returning a string containing the Roman numeral representation of that integer. Modern Roman numerals are written by expressing each digit separately, starting with the left most digit and skipping any digit with a value of zero.



In Roman numerals:

 1990 is rendered: 1000=M, 900=CM, 90=XC; resulting in MCMXC
 2008 is written as 2000=MM, 8=VIII; or MMVIII
 1666 uses each Roman symbol in descending order: MDCLXVI

",#C.23,C#,"using System;
class Program
{
    static uint[] nums = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };
    static string[] rum = { ""M"", ""CM"", ""D"", ""CD"", ""C"", ""XC"", ""L"", ""XL"", ""X"", ""IX"", ""V"", ""IV"", ""I"" };
 
    static string ToRoman(uint number)
    {
        string value = """";
        for (int i = 0; i < nums.Length && number != 0; i++)
        {
            while (number >= nums[i])
            {
                number -= nums[i];
                value += rum[i];
            }
        }
        return value;
    }
 
    static void Main()
    {
        for (uint number = 1; number <= 1 << 10; number *= 2)
        {
            Console.WriteLine(""{0} = {1}"", number, ToRoman(number));
        }
    }
}",720,28
21823,http://rosettacode.org/wiki/Respond_to_an_unknown_method_call,Respond to an unknown method call,"Task

Demonstrate how to make the object respond (sensibly/usefully) to an invocation of a method on it that it does not support through its class definitions.

Note that this is not the same as just invoking a defined method whose name is given dynamically; the method named at the point of invocation must not be defined.

This task is intended only for object systems that use a dynamic dispatch mechanism without static checking.



Related task

   Send an unknown method call.

",#C.23,C#,"using System;
using System.Dynamic;
 
class Example : DynamicObject
{
    public override bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result)
    {
        result = null;
 
        Console.WriteLine(""This is {0}."", binder.Name);
        return true;
    }
}
 
class Program
{
    static void Main(string[] args)
    {
        dynamic ex = new Example();
 
        ex.Foo();
        ex.Bar();
    }
}",429,24
21831,http://rosettacode.org/wiki/RIPEMD-160,RIPEMD-160,"RIPEMD-160 is another hash function; it computes a 160-bit message digest.

There is a RIPEMD-160 home page, with test vectors and pseudocode for RIPEMD-160.
For padding the message, RIPEMD-160 acts like MD4 (RFC 1320).

Find the RIPEMD-160 message digest of a string of octets.
Use the ASCII encoded string “Rosetta Code”.
You may either call an RIPEMD-160 library, or implement RIPEMD-160 in your language.
",#C.23,C#,"using System;
using System.Security.Cryptography;
using System.Text;
 
class Program
{
    static void Main(string[] args)
    {
        string text = ""Rosetta Code"";
        byte[] bytes = Encoding.ASCII.GetBytes(text);
        RIPEMD160 myRIPEMD160 = RIPEMD160Managed.Create();
        byte[] hashValue = myRIPEMD160.ComputeHash(bytes);
        var hexdigest = BitConverter.ToString(hashValue).Replace(""-"", """").ToLower();
        Console.WriteLine(hexdigest);
        Console.ReadLine();
    }
}",497,17
21928,http://rosettacode.org/wiki/Resistor_mesh,Resistor mesh,"
Task

Given    10×10    grid nodes   (as shown in the image)   interconnected by    1Ω    resistors as shown,

find the resistance between points   A   and   B.



See also

   (humor, nerd sniping)   xkcd.com cartoon

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace ResistorMesh {
    class Node {
        public Node(double v, int fixed_) {
            V = v;
            Fixed = fixed_;
        }
 
        public double V { get; set; }
        public int Fixed { get; set; }
    }
 
    class Program {
        static void SetBoundary(List<List<Node>> m) {
            m[1][1].V = 1.0;
            m[1][1].Fixed = 1;
 
            m[6][7].V = -1.0;
            m[6][7].Fixed = -1;
        }
 
        static double CalcuateDifference(List<List<Node>> m, List<List<Node>> d, int w, int h) {
            double total = 0.0;
            for (int i = 0; i < h; i++) {
                for (int j = 0; j < w; j++) {
                    double v = 0.0;
                    int n = 0;
                    if (i > 0) {
                        v += m[i - 1][j].V;
                        n++;
                    }
                    if (j > 0) {
                        v += m[i][j - 1].V;
                        n++;
                    }
                    if (i + 1 < h) {
                        v += m[i + 1][j].V;
                        n++;
                    }
                    if (j + 1 < w) {
                        v += m[i][j + 1].V;
                        n++;
                    }
                    v = m[i][j].V - v / n;
                    d[i][j].V = v;
                    if (m[i][j].Fixed == 0) {
                        total += v * v;
                    }
                }
            }
            return total;
        }
 
        static double Iter(List<List<Node>> m, int w, int h) {
            List<List<Node>> d = new List<List<Node>>(h);
            for (int i = 0; i < h; i++) {
                List<Node> t = new List<Node>(w);
                for (int j = 0; j < w; j++) {
                    t.Add(new Node(0.0, 0));
                }
                d.Add(t);
            }
 
            double[] curr = new double[3];
            double diff = 1e10;
 
            while (diff > 1e-24) {
                SetBoundary(m);
                diff = CalcuateDifference(m, d, w, h);
                for (int i = 0; i < h; i++) {
                    for (int j = 0; j < w; j++) {
                        m[i][j].V -= d[i][j].V;
                    }
                }
            }
 
            for (int i = 0; i < h; i++) {
                for (int j = 0; j < w; j++) {
                    int k = 0;
                    if (i != 0) k++;
                    if (j != 0) k++;
                    if (i < h - 1) k++;
                    if (j < w - 1) k++;
                    curr[m[i][j].Fixed + 1] += d[i][j].V * k;
                }
            }
 
            return (curr[2] - curr[0]) / 2.0;
        }
 
        const int S = 10;
        static void Main(string[] args) {
            List<List<Node>> mesh = new List<List<Node>>(S);
            for (int i = 0; i < S; i++) {
                List<Node> t = new List<Node>(S);
                for (int j = 0; j < S; j++) {
                    t.Add(new Node(0.0, 0));
                }
                mesh.Add(t);
            }
 
            double r = 2.0 / Iter(mesh, S, S);
            Console.WriteLine(""R = {0:F15}"", r);
        }
    }
}",3228,108
22045,http://rosettacode.org/wiki/Return_multiple_values,Return multiple values,"Task

Show how to return more than one value from a function.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
class ReturnMultipleValues
{
    static void Main()
    {
        var values = new[] { 4, 51, 1, -3, 3, 6, 8, 26, 2, 4 };
        int max, min;
        MinMaxNum(values, out max, out min);
 
        Console.WriteLine(""Min: {0}\nMax: {1}"", min, max);
    }
 
    static void MinMaxNum(IEnumerable<int> nums, out int max, out int min)
    {
        var sortedNums = nums.OrderBy(num => num).ToArray();
        max = sortedNums.Last();
        min = sortedNums.First();
    }
}",543,22
22056,http://rosettacode.org/wiki/Reverse_words_in_a_string,Reverse words in a string,"Task

Reverse the order of all tokens in each of a number of strings and display the result;   the order of characters within a token should not be modified.



Example

Hey you, Bub!    would be shown reversed as:    Bub! you, Hey 



Tokens are any non-space characters separated by spaces (formally, white-space);   the visible punctuation form part of the word within which it is located and should not be modified.

You may assume that there are no significant non-visible characters in the input.   Multiple or superfluous spaces may be compressed into a single space.

Some strings have no tokens, so an empty string   (or one just containing spaces)   would be the result.

Display the strings in order   (1st, 2nd, 3rd, ···),   and one string per line.

(You can consider the ten strings as ten lines, and the tokens as words.)



Input data
             (ten lines within the box)
 line
     ╔════════════════════════════════════════╗
   1 ║  ---------- Ice and Fire ------------  ║
   2 ║                                        ║  ◄─── a blank line here.
   3 ║  fire, in end will world the say Some  ║
   4 ║  ice. in say Some                      ║
   5 ║  desire of tasted I've what From       ║
   6 ║  fire. favor who those with hold I     ║
   7 ║                                        ║  ◄─── a blank line here.
   8 ║  ... elided paragraph last ...         ║
   9 ║                                        ║  ◄─── a blank line here.
  10 ║  Frost Robert -----------------------  ║
     ╚════════════════════════════════════════╝

Cf.
 Phrase reversals

",#C.23,C#,"using System;
 
public class ReverseWordsInString
{
    public static void Main(string[] args)
    {
        string text = @""
            ---------- Ice and Fire ------------
 
            fire, in end will world the say Some
            ice. in say Some
            desire of tasted I've what From
            fire. favor who those with hold I
 
            ... elided paragraph last ...
 
            Frost Robert -----------------------
            "";
 
        foreach (string line in text.Split(Environment.NewLine)) {
            //Splits on any whitespace, not just spaces
            string[] words = line.Split(default(char[]), StringSplitOptions.RemoveEmptyEntries);
            Array.Reverse(words);
            WriteLine(string.Join("" "", words));
        }
    }
}",776,27
22148,http://rosettacode.org/wiki/Reflection/List_properties,Reflection/List properties,"Task

The goal is to get the properties of an object, as names, values or both.

Some languages support dynamic properties, which in general can only be inspected if a class' public API includes a way of listing them.
",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
 
public static class Reflection
{
    public static void Main() {
        var t = new TestClass();
        var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
        foreach (var prop in GetPropertyValues(t, flags)) {
            Console.WriteLine(prop);
        }
        foreach (var field in GetFieldValues(t, flags)) {
            Console.WriteLine(field);
        }
    }
 
    public static IEnumerable<(string name, object value)> GetPropertyValues<T>(T obj, BindingFlags flags) =>
        from p in typeof(T).GetProperties(flags)
        where p.GetIndexParameters().Length == 0 //To filter out indexers
        select (p.Name, p.GetValue(obj, null));
 
    public static IEnumerable<(string name, object value)> GetFieldValues<T>(T obj, BindingFlags flags) =>
        typeof(T).GetFields(flags).Select(f => (f.Name, f.GetValue(obj)));
 
    class TestClass
    {
        private int privateField = 7;
        public int PublicNumber { get; } = 4;
        private int PrivateNumber { get; } = 2;
    }
 
}",1137,34
22186,http://rosettacode.org/wiki/Repeat,Repeat,"Task

Write a procedure which accepts as arguments another procedure and a positive integer.

The latter procedure is executed a number of times equal to the accepted integer.



",#C.23,C#,"using System;
 
namespace Repeat {
    class Program {
        static void Repeat(int count, Action<int> fn) {
            if (null == fn) {
                throw new ArgumentNullException(""fn"");
            }
            for (int i = 0; i < count; i++) {
                fn.Invoke(i + 1);
            }
        }
 
        static void Main(string[] args) {
            Repeat(3, x => Console.WriteLine(""Example {0}"", x));
        }
    }
}",440,18
22213,http://rosettacode.org/wiki/Rename_a_file,Rename a file,"Task

Rename:

   a file called     input.txt     into     output.txt     and 
   a directory called     docs     into     mydocs.


This should be done twice:  
once ""here"", i.e. in the current working directory and once in the filesystem root.

It can be assumed that the user has the rights to do so.

(In unix-type systems, only the user root would have
sufficient permissions in the filesystem root.)



",#C.23,C#,"using System;
using System.IO;
 
class Program {
    static void Main(string[] args) {
        File.Move(""input.txt"",""output.txt"");
        File.Move(@""\input.txt"",@""\output.txt"");
 
        Directory.Move(""docs"",""mydocs"");
        Directory.Move(@""\docs"",@""\mydocs"");
    }
}",276,12
22223,http://rosettacode.org/wiki/Reflection/List_methods,Reflection/List methods,"Task

The goal is to get the methods of an object, as names, values or both.

Some languages offer dynamic methods, which in general can only be inspected if a class' public API includes a way of listing them.
",#C.23,C#,"using System;
using System.Reflection;
 
public class Rosetta
{
    public static void Main()
    {
        //Let's get all methods, not just public ones.
        BindingFlags flags = BindingFlags.Instance | BindingFlags.Static
            | BindingFlags.Public | BindingFlags.NonPublic
            | BindingFlags.DeclaredOnly;
 
        foreach (var method in typeof(TestForMethodReflection).GetMethods(flags))
            Console.WriteLine(method);
    }
 
    class TestForMethodReflection
    {
        public void MyPublicMethod() {}
        private void MyPrivateMethod() {}
 
        public static void MyPublicStaticMethod() {}
        private static void MyPrivateStaticMethod() {}
    }
 
}",700,26
22319,http://rosettacode.org/wiki/Regular_expressions,Regular expressions,"

Task

   match a string against a regular expression
   substitute part of a string using a regular expression

",#C.23,C#,"using System;
using System.Text.RegularExpressions;
 
class Program {
    static void Main(string[] args) {
        string str = ""I am a string"";
 
        if (new Regex(""string$"").IsMatch(str)) {
            Console.WriteLine(""Ends with string."");
        }
 
        str = new Regex("" a "").Replace(str, "" another "");
        Console.WriteLine(str);
    }
}",358,15
22466,http://rosettacode.org/wiki/Repeat_a_string,Repeat a string,"Take a string and repeat it some number of times.

Example: repeat(""ha"", 5)   =>   ""hahahahaha""

If there is a simpler/more efficient way to repeat a single “character” (i.e. creating a string filled with a certain character), you might want to show that as well (i.e. repeat-char(""*"", 5) => ""*****"").




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"string s = """".PadLeft(5, 'X').Replace(""X"", ""ha"");",49,1
22499,http://rosettacode.org/wiki/Remove_lines_from_a_file,Remove lines from a file,"Task

Remove a specific line or a number of lines from a file.

This should be implemented as a routine that takes three parameters (filename, starting line, and the number of lines to be removed).

For the purpose of this task, line numbers and the number of lines start at one, so to remove the first two lines from the file foobar.txt, the parameters should be: foobar.txt, 1, 2

Empty lines are considered and should still be counted, and if the specified line is empty, it should still be removed.

An appropriate message should appear if an attempt is made to remove lines beyond the end of the file.



",#C.23,C#,"using System;
using System.IO;
using System.Linq;
 
public class Rosetta
{
    public static void Main() => RemoveLines(""foobar.txt"", start: 1, count: 2);
 
    static void RemoveLines(string filename, int start, int count = 1) =>
        File.WriteAllLines(filename, File.ReadAllLines(filename)
            .Where((line, index) => index < start - 1 || index >= start + count - 1));
}",384,12
22557,http://rosettacode.org/wiki/Recaman%27s_sequence,Recaman's sequence,"The Recamán's sequence generates Natural numbers.

Starting from a(0)=0, the n'th term a(n), where n>0, is the previous term minus n i.e a(n) = a(n-1) - n but only if this is both positive and has not been previousely generated.


If the conditions don't hold then a(n) = a(n-1) + n.



Task

 Generate and show here the first 15 members of the sequence.
 Find and show here, the first duplicated number in the sequence.
 Optionally: Find and show here, how many terms of the sequence are needed until all the integers 0..1000, inclusive, are generated.


References

 A005132, The On-Line Encyclopedia of Integer Sequences.
 The Slightly Spooky Recamán Sequence, Numberphile video.
 Recamán's sequence, on Wikipedia.

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace RecamanSequence {
    class Program {
        static void Main(string[] args) {
            List<int> a = new List<int>() { 0 };
            HashSet<int> used = new HashSet<int>() { 0 };
            HashSet<int> used1000 = new HashSet<int>() { 0 };
            bool foundDup = false;
            int n = 1;
            while (n <= 15 || !foundDup || used1000.Count < 1001) {
                int next = a[n - 1] - n;
                if (next < 1 || used.Contains(next)) {
                    next += 2 * n;
                }
                bool alreadyUsed = used.Contains(next);
                a.Add(next);
                if (!alreadyUsed) {
                    used.Add(next);
                    if (0 <= next && next <= 1000) {
                        used1000.Add(next);
                    }
                }
                if (n == 14) {
                    Console.WriteLine(""The first 15 terms of the Recaman sequence are: [{0}]"", string.Join("", "", a));
                }
                if (!foundDup && alreadyUsed) {
                    Console.WriteLine(""The first duplicated term is a[{0}] = {1}"", n, next);
                    foundDup = true;
                }
                if (used1000.Count == 1001) {
                    Console.WriteLine(""Terms up to a[{0}] are needed to generate 0 to 1000"", n);
                }
                n++;
            }
        }
    }
}",1454,39
22675,http://rosettacode.org/wiki/Remove_duplicate_elements,Remove duplicate elements,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Given an Array, derive a sequence of elements in which all duplicates are removed.

There are basically three approaches seen here:

 Put the elements into a hash table which does not allow duplicates. The complexity is O(n) on average, and O(n2) worst case. This approach requires a hash function for your type (which is compatible with equality), either built-in to your language, or provided by the user.
 Sort the elements and remove consecutive duplicate elements. The complexity of the best sorting algorithms is O(n log n). This approach requires that your type be ""comparable"", i.e., have an ordering. Putting the elements into a self-balancing binary search tree is a special case of sorting.
 Go through the list, and for each element, check the rest of the list to see if it appears again, and discard it if it does. The complexity is O(n2). The up-shot is that this always works on any type (provided that you can test for equality).

",#C.23,C#,"int[] nums = { 1, 1, 2, 3, 4, 4 };
List<int> unique = new List<int>();
foreach (int n in nums)
    if (!unique.Contains(n))
        unique.Add(n);",146,5
22730,http://rosettacode.org/wiki/Read_entire_file,Read entire file,"Task

Load the entire contents of some text file as a single string variable.

If applicable, discuss: encoding selection, the possibility of memory-mapping.

Of course, in practice one should avoid reading an entire file at once
if the file is large and the task can be accomplished incrementally instead
(in which case check File IO);
this is for those cases where having the entire file is actually what is wanted.



",#C.23,C#,"using System.IO;
 
class Program
{
    static void Main(string[] args)
    {
        var fileContents = File.ReadAllText(""c:\\autoexec.bat"");  
        // Can optionally take a second parameter to specify the encoding, e.g. File.ReadAllText(""c:\\autoexec.bat"", Encoding.UTF8)
    }
}",283,10
22773,http://rosettacode.org/wiki/Reduced_row_echelon_form,Reduced row echelon form,"Reduced row echelon form

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Show how to compute the reduced row echelon form
(a.k.a. row canonical form) of a matrix.

The matrix can be stored in any datatype that is convenient
(for most languages, this will probably be a two-dimensional array).

Built-in functions or this pseudocode (from Wikipedia) may be used:

function ToReducedRowEchelonForm(Matrix M) is
    lead := 0
    rowCount := the number of rows in M
    columnCount := the number of columns in M
    for 0 ≤ r < rowCount do
        if columnCount ≤ lead then
            stop
        end if
        i = r
        while M[i, lead] = 0 do
            i = i + 1
            if rowCount = i then
                i = r
                lead = lead + 1
                if columnCount = lead then
                    stop
                end if
            end if
        end while
        Swap rows i and r
        If M[r, lead] is not 0 divide row r by M[r, lead]
        for 0 ≤ i < rowCount do
            if i ≠ r do
                Subtract M[i, lead] multiplied by row r from row i
            end if
        end for
        lead = lead + 1
    end for
end function

For testing purposes, the RREF of this matrix:

 1    2   -1   -4
 2    3   -1   -11
-2    0   -3    22

is:

 1    0    0   -8
 0    1    0    1
 0    0    1   -2


",#C.23,C#,"using System;
 
namespace rref
{
    class Program
    {
        static void Main(string[] args)
        {
            int[,] matrix = new int[3, 4]{
                {  1, 2, -1,  -4 },
                {  2, 3, -1, -11 },
                { -2, 0, -3,  22 }
            };
            matrix = rref(matrix);   
        }
 
        private static int[,] rref(int[,] matrix)
        {            
            int lead = 0, rowCount = matrix.GetLength(0), columnCount = matrix.GetLength(1);
            for (int r = 0; r < rowCount; r++)
            {
                if (columnCount <= lead) break;
                int i = r;
                while (matrix[i, lead] == 0)
                {
                    i++;
                    if (i == rowCount)
                    {
                        i = r;
                        lead++;
                        if (columnCount == lead)
                        {
                        lead--;
                        break;
                        }
                    }
                }
                for (int j = 0; j < columnCount; j++)
                {
                    int temp = matrix[r, j];
                    matrix[r, j] = matrix[i, j];
                    matrix[i, j] = temp;
                }
                int div = matrix[r, lead];
                if(div != 0)
                    for (int j = 0; j < columnCount; j++) matrix[r, j] /= div;                
                for (int j = 0; j < rowCount; j++)
                {
                    if (j != r)
                    {
                        int sub = matrix[j, lead];
                        for (int k = 0; k < columnCount; k++) matrix[j, k] -= (sub * matrix[r, k]);
                    }
                }
                lead++;
            }
            return matrix;
        }
    }
}",1827,60
22801,http://rosettacode.org/wiki/Real_constants_and_functions,Real constants and functions,"Task

Show how to use the following math constants and functions in your language   (if not available, note it):

   e   (base of the natural logarithm)
   



π


{\displaystyle \pi }


   square root
   logarithm   (any base allowed)
   exponential   (ex )
   absolute value   (a.k.a. ""magnitude"")
   floor   (largest integer less than or equal to this number--not the same as truncate or int)
   ceiling   (smallest integer not less than this number--not the same as round up)
   power   (xy )


Related task

   Trigonometric Functions

",#C.23,C#,"using System;
 
class Program {
    static void Main(string[] args) {        
        Console.WriteLine(Math.E); //E
        Console.WriteLine(Math.PI); //PI
        Console.WriteLine(Math.Sqrt(10)); //Square Root
        Console.WriteLine(Math.Log(10)); // Logarithm
        Console.WriteLine(Math.Log10(10)); // Base 10 Logarithm
        Console.WriteLine(Math.Exp(10)); // Exponential
        Console.WriteLine(Math.Abs(10)); //Absolute value
        Console.WriteLine(Math.Floor(10.0)); //Floor
        Console.WriteLine(Math.Ceiling(10.0)); //Ceiling
        Console.WriteLine(Math.Pow(2, 5)); // Exponentiation
    }
}",624,16
22879,http://rosettacode.org/wiki/Reverse_a_string,Reverse a string,"Task

Take a string and reverse it.

For example, ""asdf"" becomes ""fdsa"".



Extra credit

Preserve Unicode combining characters.

For example, ""as⃝df̅"" becomes ""f̅ds⃝a"", not ""̅fd⃝sa"".




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"static string ReverseString(string input)
{
    char[] inputChars = input.ToCharArray();
    Array.Reverse(inputChars);
    return new string(inputChars);
}",156,6
23800,http://rosettacode.org/wiki/Read_a_file_character_by_character/UTF8,Read a file character by character/UTF8,"Task

Read a file one character at a time, as opposed to reading the entire file at once.

The solution may be implemented as a procedure, which returns the next character in the file on each consecutive call (returning EOF when the end of the file is reached).

The procedure should support the reading of files containing UTF8 encoded wide characters, returning whole characters for each consecutive read.

Related task

   Read a file line by line

",#C.23,C#,"using System;
using System.IO;
using System.Text;
 
namespace RosettaFileByChar
{
    class Program
    {
        static char GetNextCharacter(StreamReader streamReader) => (char)streamReader.Read();
 
        static void Main(string[] args)
        {
            Console.OutputEncoding = Encoding.UTF8;
            char c;
            using (FileStream fs = File.OpenRead(""input.txt""))
            {
                using (StreamReader streamReader = new StreamReader(fs, Encoding.UTF8))
                {
                    while (!streamReader.EndOfStream)
                    {
                        c = GetNextCharacter(streamReader);
                        Console.Write(c);
                    }
                }
            }
        }
    }
}",756,28
23922,http://rosettacode.org/wiki/Read_a_specific_line_from_a_file,Read a specific line from a file,"Some languages have special semantics for obtaining a known line number from a file.



Task

Demonstrate how to obtain the contents of a specific line within a file.

For the purpose of this task demonstrate how the contents of the seventh line of a file can be obtained,   and store it in a variable or in memory   (for potential future use within the program if the code were to become embedded).

If the file does not contain seven lines,   or the seventh line is empty,   or too big to be retrieved,   output an appropriate message.

If no special semantics are available for obtaining the required line,   it is permissible to read line by line.

Note that empty lines are considered and should still be counted.

Also note that for functional languages or languages without variables or storage,   it is permissible to output the extracted data to standard output.



",#C.23,C#,"using System;
using System.IO;
 
namespace GetLine
{
    internal class Program
    {
        private static void Main(string[] args)
        {
            Console.WriteLine(GetLine(args[0], uint.Parse(args[1])));
        }
 
        private static string GetLine(string path, uint line)
        {
            using (var reader = new StreamReader(path))
            {
                try
                {
                    for (uint i = 0; i <= line; i++)
                    {
                        if (reader.EndOfStream)
                            return string.Format(""There {1} less than {0} line{2} in the file."", line,
                                                 ((line == 1) ? ""is"" : ""are""), ((line == 1) ? """" : ""s""));
 
                        if (i == line)
                            return reader.ReadLine();
 
                        reader.ReadLine();
                    }
                }
                catch (IOException ex)
                {
                    return ex.Message;
                }
                catch (OutOfMemoryException ex)
                {
                    return ex.Message;
                }
            }
 
            throw new Exception(""Something bad happened."");
        }
    }
}",1248,44
24044,http://rosettacode.org/wiki/Ranking_methods,Ranking methods,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


The numerical rank of competitors in a competition shows if one is better than, equal to, or worse than another based on their results in a competition.

The numerical rank of a competitor can be assigned in several different ways.



Task

The following scores are accrued for all competitors of a competition (in best-first order):

44 Solomon
42 Jason
42 Errol
41 Garry
41 Bernard
41 Barry
39 Stephen
For each of the following ranking methods, create a function/method/procedure/subroutine... that applies the ranking method to an ordered list of scores with scorers:

 Standard. (Ties share what would have been their first ordinal number).
 Modified. (Ties share what would have been their last ordinal number).
 Dense. (Ties share the next available integer). 
 Ordinal. ((Competitors take the next available integer. Ties are not treated otherwise).
 Fractional. (Ties share the mean of what would have been their ordinal numbers).


See the wikipedia article for a fuller description.

Show here, on this page, the ranking of the test scores under each of the numbered ranking methods.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace RankingMethods {
    class Program {
        static void Main(string[] args) {
            Dictionary<string, int> scores = new Dictionary<string, int> {
                [""Solomon""] = 44,
                [""Jason""] = 42,
                [""Errol""] = 42,
                [""Gary""] = 41,
                [""Bernard""] = 41,
                [""Barry""] = 41,
                [""Stephen""] = 39,
            };
 
            StandardRank(scores);
            ModifiedRank(scores);
            DenseRank(scores);
            OrdinalRank(scores);
            FractionalRank(scores);
        }
 
        static void StandardRank(Dictionary<string, int> data) {
            Console.WriteLine(""Standard Rank"");
 
            var list = data.Values.Distinct().ToList();
            list.Sort((a, b) => b.CompareTo(a));
 
            int rank = 1;
            foreach (var value in list) {
                int temp = rank;
                foreach (var k in data.Keys) {
                    if (data[k] == value) {
                        Console.WriteLine(""{0} {1} {2}"", temp, value, k);
                        rank++;
                    }
                }
            }
 
            Console.WriteLine();
        }
 
        static void ModifiedRank(Dictionary<string, int> data) {
            Console.WriteLine(""Modified Rank"");
 
            var list = data.Values.Distinct().ToList();
            list.Sort((a, b) => b.CompareTo(a));
 
            int rank = 0;
            foreach (var value in list) {
                foreach (var k in data.Keys) {
                    if (data[k] == value) {
                        rank++;
                    }
                }
 
                foreach (var k in data.Keys) {
                    if (data[k] == value) {
                        Console.WriteLine(""{0} {1} {2}"", rank, data[k], k);
                    }
                }
            }
 
            Console.WriteLine();
        }
 
        static void DenseRank(Dictionary<string, int> data) {
            Console.WriteLine(""Dense Rank"");
 
            var list = data.Values.Distinct().ToList();
            list.Sort((a, b) => b.CompareTo(a));
 
            int rank = 1;
            foreach (var value in list) {
                foreach (var k in data.Keys) {
                    if (data[k] == value) {
                        Console.WriteLine(""{0} {1} {2}"", rank, data[k], k);
                    }
                }
                rank++;
            }
 
            Console.WriteLine();
        }
 
        static void OrdinalRank(Dictionary<string, int> data) {
            Console.WriteLine(""Ordinal Rank"");
 
            var list = data.Values.Distinct().ToList();
            list.Sort((a, b) => b.CompareTo(a));
 
            int rank = 1;
            foreach (var value in list) {
                foreach (var k in data.Keys) {
                    if (data[k] == value) {
                        Console.WriteLine(""{0} {1} {2}"", rank, data[k], k);
                        rank++;
                    }
                }
            }
 
            Console.WriteLine();
        }
 
        static void FractionalRank(Dictionary<string, int> data) {
            Console.WriteLine(""Fractional Rank"");
 
            var list = data.Values.Distinct().ToList();
            list.Sort((a, b) => b.CompareTo(a));
 
            int rank = 0;
            foreach (var value in list) {
                double avg = 0;
                int cnt = 0;
 
                foreach (var k in data.Keys) {
                    if (data[k] == value) {
                        rank++;
                        cnt++;
                        avg += rank;
                    }
                }
                avg /= cnt;
 
                foreach (var k in data.Keys) {
                    if (data[k] == value) {
                        Console.WriteLine(""{0:F1} {1} {2}"", avg, data[k], k);
                    }
                }
            }
 
            Console.WriteLine();
        }
    }
}",4060,137
24056,http://rosettacode.org/wiki/Range_consolidation,Range consolidation,"Define a range of numbers   R,   with bounds   b0   and   b1   covering all numbers between and including both bounds.



That range can be shown as:

 [b0, b1]
    or equally as:
 [b1, b0]


Given two ranges, the act of consolidation between them compares the two ranges:

   If one range covers all of the other then the result is that encompassing range.
   If the ranges touch or intersect then the result is   one   new single range covering the overlapping ranges.
   Otherwise the act of consolidation is to return the two non-touching ranges.


Given   N   ranges where   N > 2   then the result is the same as repeatedly replacing all combinations of two ranges by their consolidation until no further consolidation between range pairs is possible.

If   N < 2   then range consolidation has no strict meaning and the input can be returned.



Example 1

   Given the two ranges   [1, 2.5]   and   [3, 4.2]   then 
   there is no common region between the ranges and the result is the same as the input.


Example 2

   Given the two ranges   [1, 2.5]   and   [1.8, 4.7]   then 
   there is :   an overlap   [2.5, 1.8]   between the ranges and 
   the result is the single range   [1, 4.7]. 
   Note that order of bounds in a range is not (yet) stated.


Example 3

   Given the two ranges   [6.1, 7.2]   and   [7.2, 8.3]   then 
   they touch at   7.2   and 
   the result is the single range   [6.1, 8.3]. 


Example 4

   Given the three ranges   [1, 2]   and   [4, 8]   and   [2, 5] 
   then there is no intersection of the ranges   [1, 2]   and   [4, 8] 
   but the ranges   [1, 2]   and   [2, 5]   overlap and 
   consolidate to produce the range   [1, 5]. 
   This range, in turn, overlaps the other range   [4, 8],   and 
   so consolidates to the final output of the single range   [1, 8].


Task

Let a normalized range display show the smaller bound to the left;   and show the
range with the smaller lower bound to the left of other ranges when showing multiple ranges.

Output the normalized result of applying consolidation to these five sets of ranges: 

           [1.1, 2.2]
           [6.1, 7.2], [7.2, 8.3]
           [4, 3], [2, 1]
           [4, 3], [2, 1], [-1, -2], [3.9, 10]
           [1, 3], [-6, -1], [-4, -5], [8, 2], [-6, -6]  

Show all output here.



See also

 Set consolidation
 Set of real numbers

",#C.23,C#,"using static System.Math;
using System.Linq;
using System;
 
public static class RangeConsolidation
{
    public static void Main() {
        foreach (var list in new [] {
            new[] { (1.1, 2.2) }.ToList(),
            new[] { (6.1, 7.2), (7.2, 8.3) }.ToList(),
            new[] { (4d, 3d), (2, 1) }.ToList(),
            new[] { (4d, 3d), (2, 1), (-1, 2), (3.9, 10) }.ToList(),
            new[] { (1d, 3d), (-6, -1), (-4, -5), (8, 2), (-6, -6) }.ToList()
        })
        {
            for (int z = list.Count-1; z >= 1; z--) {
                for (int y = z - 1; y >= 0; y--) {
                    if (Overlap(list[z], list[y])) {
                        list[y] = Consolidate(list[z], list[y]);
                        list.RemoveAt(z);
                        break;
                    }
                }
            }
            Console.WriteLine(string.Join("", "", list.Select(Normalize).OrderBy(range => range.s)));
        }
    }
 
    private static bool Overlap((double s, double e) left, (double s, double e) right) =>
        Max(left.s, left.e) > Max(right.s, right.e)
        ? Max(right.s, right.e) >= Min(left.s, left.e)
        : Max(left.s, left.e) >= Min(right.s, right.e);
 
    private static (double s, double e) Consolidate((double s, double e) left, (double s, double e) right) =>
        (Min(Min(left.s, left.e), Min(right.s, right.e)), Max(Max(left.s, left.e), Max(right.s, right.e)));
 
    private static (double s, double e) Normalize((double s, double e) range) =>
        (Min(range.s, range.e), Max(range.s, range.e));
}",1568,39
24077,http://rosettacode.org/wiki/Rare_numbers,Rare numbers,"Definitions and restrictions

Rare   numbers are positive integers    n    where:

    n    is expressed in base ten
    r    is the reverse of    n      (decimal digits)
    n    must be non-palindromic   (n ≠ r)
    (n+r)    is the   sum
    (n-r)    is the   difference   and must be positive
   the   sum   and the   difference   must be perfect squares


Task

   find and show the first   5   rare   numbers
   find and show the first   8   rare   numbers       (optional)
   find and show more   rare   numbers                (stretch goal)


Show all output here, on this page.



References

   an   OEIS   entry:   A035519          rare numbers.
   an   OEIS   entry:   A059755   odd rare numbers.
   planetmath entry:   rare numbers.     (some hints)
   author's  website:   rare numbers   by Shyam Sunder Gupta.     (lots of hints and some observations).

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using static System.Console;
using UI = System.UInt64;
using LST = System.Collections.Generic.List<System.Collections.Generic.List<sbyte>>;
using Lst = System.Collections.Generic.List<sbyte>;
using DT = System.DateTime;
 
class Program {
 
    const sbyte MxD = 19;
 
    public struct term { public UI coeff; public sbyte a, b;
        public term(UI c, int a_, int b_) { coeff = c; a = (sbyte)a_; b = (sbyte)b_; } }
 
    static int[] digs;   static List<UI> res;   static sbyte count = 0;
    static DT st; static List<List<term>> tLst; static List<LST> lists;
    static Dictionary<int, LST> fml, dmd; static Lst dl, zl, el, ol, il;
    static bool odd; static int nd, nd2; static LST ixs;
    static int[] cnd, di; static LST dis; static UI Dif;
 
    // converts digs array to the ""difference""
    static UI ToDif() { UI r = 0; for (int i = 0; i < digs.Length; i++)
            r = r * 10 + (uint)digs[i]; return r; }
 
    // converts digs array to the ""sum""
    static UI ToSum() { UI r = 0; for (int i = digs.Length - 1; i >= 0; i--)
            r = r * 10 + (uint)digs[i]; return Dif + (r << 1); }
 
    // determines if the nmbr is square or not
    static bool IsSquare(UI nmbr) { if ((0x202021202030213 & (1 << (int)(nmbr & 63))) != 0)
        { UI r = (UI)Math.Sqrt((double)nmbr); return r * r == nmbr; } return false; }
 
    // returns sequence of sbytes
    static Lst Seq(sbyte from, int to, sbyte stp = 1) { Lst res = new Lst();
        for (sbyte item = from; item <= to; item += stp) res.Add(item); return res; }
 
    // Recursive closure to generate (n+r) candidates from (n-r) candidates
    static void Fnpr(int lev) { if (lev == dis.Count) { digs[ixs[0][0]] = fml[cnd[0]][di[0]][0];
            digs[ixs[0][1]] = fml[cnd[0]][di[0]][1]; int le = di.Length, i = 1;
            if (odd) digs[nd >> 1] = di[--le]; foreach (sbyte d in di.Skip(1).Take(le - 1)) {
                digs[ixs[i][0]] = dmd[cnd[i]][d][0]; digs[ixs[i][1]] = dmd[cnd[i++]][d][1]; }
            if (!IsSquare(ToSum())) return; res.Add(ToDif()); WriteLine(""{0,16:n0}{1,4}   ({2:n0})"",
                (DT.Now - st).TotalMilliseconds, ++count, res.Last()); }
        else foreach (var n in dis[lev]) { di[lev] = n; Fnpr(lev + 1); } }
 
    // Recursive closure to generate (n-r) candidates with a given number of digits.
    static void Fnmr (LST list, int lev) { if (lev == list.Count) { Dif = 0; sbyte i = 0;
            foreach (var t in tLst[nd2]) { if (cnd[i] < 0) Dif -= t.coeff * (UI)(-cnd[i++]);
                else Dif += t.coeff * (UI)cnd[i++]; } if (Dif <= 0 || !IsSquare(Dif)) return;
            dis = new LST { Seq(0, fml[cnd[0]].Count - 1) };
            foreach (int ii in cnd.Skip(1)) dis.Add(Seq(0, dmd[ii].Count - 1));
            if (odd) dis.Add(il); di = new int[dis.Count]; Fnpr(0);
        } else foreach(sbyte n in list[lev]) { cnd[lev] = n; Fnmr(list, lev + 1); } }
 
    static void init() { UI pow = 1;
        // terms of (n-r) expression for number of digits from 2 to maxDigits
        tLst = new List<List<term>>(); foreach (int r in Seq(2, MxD)) {
            List<term> terms = new List<term>(); pow *= 10; UI p1 = pow, p2 = 1;
            for (int i1 = 0, i2 = r - 1; i1 < i2; i1++, i2--) {
                terms.Add(new term(p1 - p2, i1, i2)); p1 /= 10; p2 *= 10; }
            tLst.Add(terms); }
        //  map of first minus last digits for 'n' to pairs giving this value
        fml = new Dictionary<int, LST> {
            [0] = new LST { new Lst { 2, 2 }, new Lst { 8, 8 } },
            [1] = new LST { new Lst { 6, 5 }, new Lst { 8, 7 } },
            [4] = new LST { new Lst { 4, 0 } },
            [6] = new LST { new Lst { 6, 0 }, new Lst { 8, 2 } } };
        // map of other digit differences for 'n' to pairs giving this value
        dmd = new Dictionary<int, LST>();
        for (sbyte i = 0; i < 10; i++) for (sbyte j = 0, d = i; j < 10; j++, d--) {
                if (dmd.ContainsKey(d)) dmd[d].Add(new Lst { i, j });
                else dmd[d] = new LST { new Lst { i, j } }; }
        dl = Seq(-9, 9);    // all differences
        zl = Seq( 0, 0);    // zero differences only
        el = Seq(-8, 8, 2); // even differences only
        ol = Seq(-9, 9, 2); // odd differences only
        il = Seq( 0, 9); lists = new List<LST>();
        foreach (sbyte f in fml.Keys) lists.Add(new LST { new Lst { f } }); }
 
    static void Main(string[] args) { init(); res = new List<UI>(); st = DT.Now; count = 0;
        WriteLine(""{0,5}{1,12}{2,4}{3,14}"", ""digs"", ""elapsed(ms)"", ""R/N"", ""Unordered Rare Numbers"");
        for (nd = 2, nd2 = 0, odd = false; nd <= MxD; nd++, nd2++, odd = !odd) { digs = new int[nd];
            if (nd == 4) { lists[0].Add(zl); lists[1].Add(ol); lists[2].Add(el); lists[3].Add(ol); }
            else if (tLst[nd2].Count > lists[0].Count) foreach (LST list in lists) list.Add(dl);
            ixs = new LST(); 
            foreach (term t in tLst[nd2]) ixs.Add(new Lst { t.a, t.b });
            foreach (LST list in lists) { cnd = new int[list.Count]; Fnmr(list, 0); }
            WriteLine(""  {0,2}  {1,10:n0}"", nd, (DT.Now - st).TotalMilliseconds); }
        res.Sort();
        WriteLine(""\nThe {0} rare numbers with up to {1} digits are:"", res.Count, MxD);
        count = 0; foreach (var rare in res) WriteLine(""{0,2}:{1,27:n0}"", ++count, rare);
        if (System.Diagnostics.Debugger.IsAttached) ReadKey(); }
}",5459,95
24194,http://rosettacode.org/wiki/Random_number_generator_(device),Random number generator (device),"Task

If your system has a means to generate random numbers involving not only a software algorithm   (like the /dev/urandom devices in Unix),   then:

show how to obtain a random 32-bit number from that mechanism.

Related task
 Random_number_generator_(included)

",#C.23,C#,"using System;
using System.Security.Cryptography;
 
private static int GetRandomInt()
{
  int result = 0;
  var rng = new RNGCryptoServiceProvider();
  var buffer = new byte[4];
 
  rng.GetBytes(buffer);
  result = BitConverter.ToInt32(buffer, 0);
 
  return result;
}",268,14
24223,http://rosettacode.org/wiki/Ramer-Douglas-Peucker_line_simplification,Ramer-Douglas-Peucker line simplification,"Ramer-Douglas-Peucker line simplification

You are encouraged to solve this task according to the task description, using any language you may know.
The   Ramer–Douglas–Peucker   algorithm is a line simplification algorithm for reducing the number of points used to define its shape.



Task

Using the   Ramer–Douglas–Peucker   algorithm, simplify the   2D   line defined by the points:

   (0,0)  (1,0.1)  (2,-0.1)  (3,5)  (4,6)  (5,7)  (6,8.1)  (7,9)  (8,9)  (9,9) 

The error threshold to be used is:   1.0.

Display the remaining points here.



Reference

   the Wikipedia article:   Ramer-Douglas-Peucker algorithm.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace LineSimplification {
    using Point = Tuple<double, double>;
 
    class Program {
        static double PerpendicularDistance(Point pt, Point lineStart, Point lineEnd) {
            double dx = lineEnd.Item1 - lineStart.Item1;
            double dy = lineEnd.Item2 - lineStart.Item2;
 
            // Normalize
            double mag = Math.Sqrt(dx * dx + dy * dy);
            if (mag > 0.0) {
                dx /= mag;
                dy /= mag;
            }
            double pvx = pt.Item1 - lineStart.Item1;
            double pvy = pt.Item2 - lineStart.Item2;
 
            // Get dot product (project pv onto normalized direction)
            double pvdot = dx * pvx + dy * pvy;
 
            // Scale line direction vector and subtract it from pv
            double ax = pvx - pvdot * dx;
            double ay = pvy - pvdot * dy;
 
            return Math.Sqrt(ax * ax + ay * ay);
        }
 
        static void RamerDouglasPeucker(List<Point> pointList, double epsilon, List<Point> output) {
            if (pointList.Count < 2) {
                throw new ArgumentOutOfRangeException(""Not enough points to simplify"");
            }
 
            // Find the point with the maximum distance from line between the start and end
            double dmax = 0.0;
            int index = 0;
            int end = pointList.Count - 1;
            for (int i = 1; i < end; ++i) {
                double d = PerpendicularDistance(pointList[i], pointList[0], pointList[end]);
                if (d > dmax) {
                    index = i;
                    dmax = d;
                }
            }
 
            // If max distance is greater than epsilon, recursively simplify
            if (dmax > epsilon) {
                List<Point> recResults1 = new List<Point>();
                List<Point> recResults2 = new List<Point>();
                List<Point> firstLine = pointList.Take(index + 1).ToList();
                List<Point> lastLine = pointList.Skip(index).ToList();
                RamerDouglasPeucker(firstLine, epsilon, recResults1);
                RamerDouglasPeucker(lastLine, epsilon, recResults2);
 
                // build the result list
                output.AddRange(recResults1.Take(recResults1.Count - 1));
                output.AddRange(recResults2);
                if (output.Count < 2) throw new Exception(""Problem assembling output"");
            }
            else {
                // Just return start and end points
                output.Clear();
                output.Add(pointList[0]);
                output.Add(pointList[pointList.Count - 1]);
            }
        }
 
        static void Main(string[] args) {
            List<Point> pointList = new List<Point>() {
                new Point(0.0,0.0),
                new Point(1.0,0.1),
                new Point(2.0,-0.1),
                new Point(3.0,5.0),
                new Point(4.0,6.0),
                new Point(5.0,7.0),
                new Point(6.0,8.1),
                new Point(7.0,9.0),
                new Point(8.0,9.0),
                new Point(9.0,9.0),
            };
            List<Point> pointListOut = new List<Point>();
            RamerDouglasPeucker(pointList, 1.0, pointListOut);
            Console.WriteLine(""Points remaining after simplification:"");
            pointListOut.ForEach(p => Console.WriteLine(p));
        }
    }
}",3449,90
24230,http://rosettacode.org/wiki/Random_numbers,Random numbers,"Task

Generate a collection filled with   1000   normally distributed random (or pseudo-random) numbers
with a mean of   1.0   and a   standard deviation   of   0.5



Many libraries only generate uniformly distributed random numbers. If so, you may use one of these algorithms.



Related task

   Standard deviation

",#C.23,C#," 
private static double randomNormal()
{
	return Math.Cos(2 * Math.PI * tRand.NextDouble()) * Math.Sqrt(-2 * Math.Log(tRand.NextDouble()));
}
 ",143,6
24233,http://rosettacode.org/wiki/Random_number_generator_(included),Random number generator (included),"The task is to:

 State the type of random number generator algorithm used in a language's built-in random number generator. If the language or its immediate libraries don't provide a random number generator, skip this task.
 If possible, give a link to a wider explanation of the algorithm used.
Note: the task is not to create an RNG, but to report on the languages in-built RNG that would be the most likely RNG used.

The main types of pseudo-random number generator (PRNG) that are in use are the Linear Congruential Generator (LCG), and the Generalized Feedback Shift Register (GFSR), (of which the Mersenne twister generator is a subclass). The last main type is where the output of one of the previous ones (typically a Mersenne twister) is fed through a cryptographic hash function to maximize unpredictability of individual bits.

Note that neither LCGs nor GFSRs should be used for the most demanding applications (cryptography) without additional steps.
",#C.23,C#,"#include <iostream>
#include <string>
#include <random>
 
int main()
{
    std::random_device rd;
    std::uniform_int_distribution<int> dist(1, 10);
    std::mt19937 mt(rd());
 
    std::cout << ""Random Number (hardware): "" << dist(rd) << std::endl;
    std::cout << ""Mersenne twister (hardware seeded): "" << dist(mt) << std::endl;
}",334,13
24292,http://rosettacode.org/wiki/Read_a_file_line_by_line,Read a file line by line,"Read a file one line at a time,
as opposed to reading the entire file at once.



Related tasks

 Read a file character by character
 Input loop.

",#C.23,C#,"foreach (string readLine in File.ReadLines(""FileName""))
  DoSomething(readLine);",80,2
24300,http://rosettacode.org/wiki/Random_Latin_squares,Random Latin squares,"A Latin square of size n is an arrangement of n symbols in an n-by-n square in such a way that each row and column has each symbol appearing exactly once.

A randomised Latin square generates random configurations of the symbols for any given n.

Example n=4 randomised Latin square

0 2 3 1
2 1 0 3
3 0 1 2
1 3 2 0
Task

 Create a function/routine/procedure/method/... that given n generates a randomised Latin square of size n.
 Use the function to generate and show here, two randomly generated squares of size 5.
Note
 
Strict Uniformity in the random generation is a hard problem and not a requirement of the task.

Reference

 Wikipedia: Latin square
 OEIS: A002860

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace RandomLatinSquares {
    using Matrix = List<List<int>>;
 
    // Taken from https://stackoverflow.com/a/1262619
    static class Helper {
        private static readonly Random rng = new Random();
 
        public static void Shuffle<T>(this IList<T> list) {
            int n = list.Count;
            while (n > 1) {
                n--;
                int k = rng.Next(n + 1);
                T value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }
    }
 
    class Program {
        static void PrintSquare(Matrix latin) {
            foreach (var row in latin) {
                Console.Write('[');
 
                var it = row.GetEnumerator();
                if (it.MoveNext()) {
                    Console.Write(it.Current);
                }
                while (it.MoveNext()) {
                    Console.Write("", "");
                    Console.Write(it.Current);
                }
 
                Console.WriteLine(']');
            }
            Console.WriteLine();
        }
 
        static void LatinSquare(int n) {
            if (n <= 0) {
                Console.WriteLine(""[]"");
                return;
            }
 
            var latin = new Matrix();
            for (int i = 0; i < n; i++) {
                List<int> temp = new List<int>();
                for (int j = 0; j < n; j++) {
                    temp.Add(j);
                }
                latin.Add(temp);
            }
            // first row
            latin[0].Shuffle();
 
            // middle row(s)
            for (int i = 1; i < n - 1; i++) {
                bool shuffled = false;
 
                while (!shuffled) {
                    latin[i].Shuffle();
                    for (int k = 0; k < i; k++) {
                        for (int j = 0; j < n; j++) {
                            if (latin[k][j] == latin[i][j]) {
                                goto shuffling;
                            }
                        }
                    }
                    shuffled = true;
 
                shuffling: { }
                }
            }
 
            // last row
            for (int j = 0; j < n; j++) {
                List<bool> used = new List<bool>();
                for (int i = 0; i < n; i++) {
                    used.Add(false);
                }
 
                for (int i = 0; i < n-1; i++) {
                    used[latin[i][j]] = true;
                }
                for (int k = 0; k < n; k++) {
                    if (!used[k]) {
                        latin[n - 1][j] = k;
                        break;
                    }
                }
            }
 
            PrintSquare(latin);
        }
 
        static void Main() {
            LatinSquare(5);
            LatinSquare(5);
            LatinSquare(10); // for good measure
        }
    }
}",2930,105
24323,http://rosettacode.org/wiki/Range_expansion,Range expansion,"A format for expressing an ordered list of integers is to use a comma separated list of either

 individual integers
 Or a range of integers denoted by the starting integer separated from the end integer in the range by a dash, '-'. (The range includes all integers in the interval including both endpoints)
 The range syntax is to be used only for, and for every range that expands to more than two values.
Example

The list of integers:

 -6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20
Is accurately expressed by the range expression:

 -6,-3-1,3-5,7-11,14,15,17-20
(And vice-versa).



Task

Expand the range description:

  -6,-3--1,3-5,7-11,14,15,17-20 

Note that the second element above,
is the range from minus 3 to minus 1. 



Related task

   Range extraction

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
 
class Program
{
    static void Main(string[] args)
    {
        var rangeString = ""-6,-3--1,3-5,7-11,14,15,17-20"";
        var matches = Regex.Matches(rangeString, @""(?<f>-?\d+)-(?<s>-?\d+)|(-?\d+)"");
        var values = new List<string>();
 
        foreach (var m in matches.OfType<Match>())
        {
            if (m.Groups[1].Success)
            {
                values.Add(m.Value);
                continue;
            }
 
            var start = Convert.ToInt32(m.Groups[""f""].Value);
            var end = Convert.ToInt32(m.Groups[""s""].Value) + 1;
 
            values.AddRange(Enumerable.Range(start, end - start).Select(v => v.ToString()));
        }
 
        Console.WriteLine(string.Join("", "", values));
    }
}",838,30
24402,http://rosettacode.org/wiki/Range_extraction,Range extraction,"A format for expressing an ordered list of integers is to use a comma separated list of either

 individual integers
 Or a range of integers denoted by the starting integer separated from the end integer in the range by a dash, '-'. (The range includes all integers in the interval including both endpoints)
 The range syntax is to be used only for, and for every range that expands to more than two values.
Example

The list of integers:

 -6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20
Is accurately expressed by the range expression:

 -6,-3-1,3-5,7-11,14,15,17-20
(And vice-versa).

Task

 Create a function that takes a list of integers in increasing order and returns a correctly formatted string in the range format. 
 Use the function to compute and print the range formatted version of the following ordered list of integers. (The correct answer is: 0-2,4,6-8,11,12,14-25,27-33,35-39).


    0,  1,  2,  4,  6,  7,  8, 11, 12, 14,
   15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
   25, 27, 28, 29, 30, 31, 32, 33, 35, 36,
   37, 38, 39

 Show the output of your program.


Related task

   Range expansion

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
class RangeExtraction
{
    static void Main()
    {
        const string testString = ""0,  1,  2,  4,  6,  7,  8, 11, 12, 14,15, 16, 17, 18, 19, 20, 21, 22, 23, 24,25, 27, 28, 29, 30, 31, 32, 33, 35, 36,37, 38, 39"";
        var result = String.Join("","", RangesToStrings(GetRanges(testString)));
        Console.Out.WriteLine(result);
    }
 
    public static IEnumerable<IEnumerable<int>> GetRanges(string testString)
    {
        var numbers = testString.Split(new[] { ',' }).Select(x => Convert.ToInt32(x));
        var current = new List<int>();
        foreach (var n in numbers)
        {
            if (current.Count == 0)
            {
                current.Add(n);
            }
            else
            {
                if (current.Max() + 1 == n)
                {
                    current.Add(n);
                }
                else
                {
                    yield return current;
                    current = new List<int> { n };
                }
            }
        }
        yield return current;
    }
 
    public static IEnumerable<string> RangesToStrings(IEnumerable<IEnumerable<int>> ranges)
    {
        foreach (var range in ranges)
        {
            if (range.Count() == 1)
            {
                yield return range.Single().ToString();
            }
            else if (range.Count() == 2)
            {
                yield return range.Min() + "","" + range.Max();
            }
            else
            {
                yield return range.Min() + ""-"" + range.Max();
            }
        }
    }
}
 ",1644,59
24513,http://rosettacode.org/wiki/Quickselect_algorithm,Quickselect algorithm,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Use the quickselect algorithm on the vector

 [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]
To show the first, second, third, ... up to the tenth largest member of the vector, in order, here on this page.

 Note: Quicksort has a separate task. 

",#C.23,C#,"// ----------------------------------------------------------------------------------------------
//  
//  Program.cs - QuickSelect
//  
// ----------------------------------------------------------------------------------------------
 
using System;
using System.Collections.Generic;
using System.Linq;
 
namespace QuickSelect
{
    internal static class Program
    {
        #region Static Members
 
        private static void Main()
        {
            var inputArray = new[] {9, 8, 7, 6, 5, 0, 1, 2, 3, 4};
            // Loop 10 times
            Console.WriteLine( ""Loop quick select 10 times."" );
            for( var i = 0 ; i < 10 ; i++ )
            {
                Console.Write( inputArray.NthSmallestElement( i ) );
                if( i < 9 )
                    Console.Write( "", "" );
            }
            Console.WriteLine();
 
            // And here is then more effective way to get N smallest elements from vector in order by using quick select algorithm
            // Basically we are here just sorting array (taking 10 smallest from array which length is 10)
            Console.WriteLine( ""Just sort 10 elements."" );
            Console.WriteLine( string.Join( "", "", inputArray.TakeSmallest( 10 ).OrderBy( v => v ).Select( v => v.ToString() ).ToArray() ) );
            // Here we are actually doing quick select once by taking only 4 smallest from array. 
            Console.WriteLine( ""Get 4 smallest and sort them."" );
            Console.WriteLine( string.Join( "", "", inputArray.TakeSmallest( 4 ).OrderBy( v => v ).Select( v => v.ToString() ).ToArray() ) );
            Console.WriteLine( ""< Press any key >"" );
            Console.ReadKey();
        }
 
        #endregion
    }
 
    internal static class ArrayExtension
    {
        #region Static Members
 
        /// <summary>
        ///  Return specified number of smallest elements from array.
        /// </summary>
        /// <typeparam name=""T"">The type of the elements of array. Type must implement IComparable(T) interface.</typeparam>
        /// <param name=""array"">The array to return elemnts from.</param>
        /// <param name=""count"">The number of smallest elements to return. </param>
        /// <returns>An IEnumerable(T) that contains the specified number of smallest elements of the input array. Returned elements are NOT sorted.</returns>
        public static IEnumerable<T> TakeSmallest<T>( this T[] array, int count ) where T : IComparable<T>
        {
            if( count < 0 )
                throw new ArgumentOutOfRangeException( ""count"", ""Count is smaller than 0."" );
            if( count == 0 )
                return new T[0];
            if( array.Length <= count )
                return array;
 
            return QuickSelectSmallest( array, count - 1 ).Take( count );
        }
 
        /// <summary>
        /// Returns N:th smallest element from the array.
        /// </summary>
        /// <typeparam name=""T"">The type of the elements of array. Type must implement IComparable(T) interface.</typeparam>
        /// <param name=""array"">The array to return elemnt from.</param>
        /// <param name=""n"">Nth element. 0 is smallest element, when array.Length - 1 is largest element.</param>
        /// <returns>N:th smalles element from the array.</returns>
        public static T NthSmallestElement<T>( this T[] array, int n ) where T : IComparable<T>
        {
            if( n < 0 || n > array.Length - 1 )
                throw new ArgumentOutOfRangeException( ""n"", n, string.Format( ""n should be between 0 and {0} it was {1}."", array.Length - 1, n ) );
            if( array.Length == 0 )
                throw new ArgumentException( ""Array is empty."", ""array"" );
            if( array.Length == 1 )
                return array[ 0 ];
 
            return QuickSelectSmallest( array, n )[ n ];
        }
 
        /// <summary>
        ///  Partially sort array such way that elements before index position n are smaller or equal than elemnt at position n. And elements after n are larger or equal. 
        /// </summary>
        /// <typeparam name=""T"">The type of the elements of array. Type must implement IComparable(T) interface.</typeparam>
        /// <param name=""input"">The array which elements are being partially sorted. This array is not modified.</param>
        /// <param name=""n"">Nth smallest element.</param>
        /// <returns>Partially sorted array.</returns>
        private static T[] QuickSelectSmallest<T>( T[] input, int n ) where T : IComparable<T>
        {
            // Let's not mess up with our input array
            // For very large arrays - we should optimize this somehow - or just mess up with our input
            var partiallySortedArray = (T[]) input.Clone();
 
            // Initially we are going to execute quick select to entire array
            var startIndex = 0;
            var endIndex = input.Length - 1;
 
            // Selecting initial pivot
            // Maybe we are lucky and array is sorted initially?
            var pivotIndex = n;
 
            // Loop until there is nothing to loop (this actually shouldn't happen - we should find our value before we run out of values)
            var r = new Random();
            while( endIndex > startIndex )
            {
                pivotIndex = QuickSelectPartition( partiallySortedArray, startIndex, endIndex, pivotIndex );
                if( pivotIndex == n )
                    // We found our n:th smallest value - it is stored to pivot index
                    break;
                if( pivotIndex > n )
                    // Array before our pivot index have more elements that we are looking for                    
                    endIndex = pivotIndex - 1;
                else                    
                    // Array before our pivot index has less elements that we are looking for                    
                    startIndex = pivotIndex + 1;
 
                // Omnipotent beings don't need to roll dices - but we do...
                // Randomly select a new pivot index between end and start indexes (there are other methods, this is just most brutal and simplest)
                pivotIndex = r.Next( startIndex,  endIndex );
            }
            return partiallySortedArray;
        }
 
        /// <summary>
        /// Sort elements in sub array between startIndex and endIndex, such way that elements smaller than or equal with value initially stored to pivot index are before
        /// new returned pivot value index.
        /// </summary>
        /// <typeparam name=""T"">The type of the elements of array. Type must implement IComparable(T) interface.</typeparam>
        /// <param name=""array"">The array that is being sorted.</param>
        /// <param name=""startIndex"">Start index of sub array.</param>
        /// <param name=""endIndex"">End index of sub array.</param>
        /// <param name=""pivotIndex"">Pivot index.</param>
        /// <returns>New pivot index. Value that was initially stored to <paramref name=""pivotIndex""/> is stored to this newly returned index. All elements before this index are 
        /// either smaller or equal with pivot value. All elements after this index are larger than pivot value.</returns>
        /// <remarks>This method modifies paremater array.</remarks>
        private static int QuickSelectPartition<T>( this T[] array, int startIndex, int endIndex, int pivotIndex ) where T : IComparable<T>
        {
            var pivotValue = array[ pivotIndex ];
            // Initially we just assume that value in pivot index is largest - so we move it to end (makes also for loop more straight forward)
            array.Swap( pivotIndex, endIndex );
            for( var i = startIndex ; i < endIndex ; i++ )
            {
                if( array[ i ].CompareTo( pivotValue ) > 0 )
                    continue;
 
                // Value stored to i was smaller than or equal with pivot value - let's move it to start
                array.Swap( i, startIndex );
                // Move start one index forward 
                startIndex++;
            }
            // Start index is now pointing to index where we should store our pivot value from end of array
            array.Swap( endIndex, startIndex );
            return startIndex;
        }
 
        private static void Swap<T>( this T[] array, int index1, int index2 )
        {
            if( index1 == index2 )
                return;
 
            var temp = array[ index1 ];
            array[ index1 ] = array[ index2 ];
            array[ index2 ] = temp;
        }
 
        #endregion
    }
}",8635,173
24562,http://rosettacode.org/wiki/Queue/Usage,Queue/Usage,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
 Illustration of FIFO behavior
Task

Create a queue data structure and demonstrate its operations.

(For implementations of queues, see the FIFO task.)



Operations:

   push       (aka enqueue) - add element
   pop         (aka dequeue) - pop first element
   empty     - return truth value when empty


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace RosettaCode
{
    class Program
    {
        static void Main()
        {
            // Create a queue and ""push"" items into it
            Queue<int> queue  = new Queue<int>();
            queue.Enqueue(1);
            queue.Enqueue(3);
            queue.Enqueue(5);
 
            // ""Pop"" items from the queue in FIFO order
            Console.WriteLine(queue.Dequeue()); // 1
            Console.WriteLine(queue.Dequeue()); // 3
            Console.WriteLine(queue.Dequeue()); // 5
 
            // To tell if the queue is empty, we check the count
            bool empty = queue.Count == 0;
            Console.WriteLine(empty); // ""True""
 
            // If we try to pop from an empty queue, an exception
            // is thrown.
            try
            {
                queue.Dequeue();
            }
            catch (InvalidOperationException exception)
            {
                Console.WriteLine(exception.Message); // ""Queue empty.""
            }
        }
    }
}",1049,37
24748,http://rosettacode.org/wiki/Quaternion_type,Quaternion type,"Quaternions   are an extension of the idea of   complex numbers.

A complex number has a real and complex part,   sometimes written as     a + bi,  

where     a     and     b     stand for real numbers, and     i     stands for the square root of minus 1.

An example of a complex number might be     -3 + 2i,    

where the real part,     a     is     -3.0     and the complex part,     b     is     +2.0.  

A quaternion has one real part and three imaginary parts,     i,       j,     and     k.  

A quaternion might be written as     a + bi + cj + dk.  

In the quaternion numbering system:

     i∙i = j∙j = k∙k = i∙j∙k = -1,         or more simply,
     ii  = jj  = kk  = ijk   = -1.  
The order of multiplication is important, as, in general, for two quaternions:

     q1     and     q2:         q1q2 ≠ q2q1.  
An example of a quaternion might be     1 +2i +3j +4k  

There is a list form of notation where just the numbers are shown and the imaginary multipliers    i,       j,     and     k     are assumed by position.

So the example above would be written as     (1, 2, 3, 4)  



Task

Given the three quaternions and their components: 

   q  = (1, 2, 3, 4) = (a,  b,  c,  d)
   q1 = (2, 3, 4, 5) = (a1, b1, c1, d1)
   q2 = (3, 4, 5, 6) = (a2, b2, c2, d2) 

And a wholly real number     r = 7.  



Create functions   (or classes)   to perform simple maths with quaternions including computing:

 The norm of a quaternion: 




=



a

2


+

b

2


+

c

2


+

d

2






{\displaystyle ={\sqrt {a^{2}+b^{2}+c^{2}+d^{2}}}}

 
 The negative of a quaternion: 
   = (-a, -b, -c, -d)  
 The conjugate of a quaternion: 
   = ( a, -b, -c, -d)  
 Addition of a real number     r     and a quaternion     q:  
  r + q = q + r = (a+r, b, c, d)  
 Addition of two quaternions: 
   q1 + q2 = (a1+a2, b1+b2, c1+c2, d1+d2)  
 Multiplication of a real number and a quaternion: 
   qr = rq = (ar, br, cr, dr)  
 Multiplication of two quaternions     q1     and   q2     is given by: 
   ( a1a2 − b1b2 − c1c2 − d1d2, 
   a1b2 + b1a2 + c1d2 − d1c2, 
   a1c2 − b1d2 + c1a2 + d1b2, 
   a1d2 + b1c2 − c1b2 + d1a2 )  
 Show that, for the two quaternions     q1     and     q2: 
 q1q2 ≠ q2q1  


If a language has built-in support for quaternions, then use it.



C.f.

   Vector products
   On Quaternions;   or on a new System of Imaginaries in Algebra.   By Sir William Rowan Hamilton LL.D, P.R.I.A., F.R.A.S., Hon. M. R. Soc. Ed. and Dub., Hon. or Corr. M. of the Royal or Imperial Academies of St. Petersburgh, Berlin, Turin and Paris, Member of the American Academy of Arts and Sciences, and of other Scientific Societies at Home and Abroad, Andrews' Prof. of Astronomy in the University of Dublin, and Royal Astronomer of Ireland.

",#C.23,C#,"using System;
 
struct Quaternion : IEquatable<Quaternion>
{
    public readonly double A, B, C, D;
 
    public Quaternion(double a, double b, double c, double d)
    {
        this.A = a;
        this.B = b;
        this.C = c;
        this.D = d;
    }
 
    public double Norm()
    {
        return Math.Sqrt(A * A + B * B + C * C + D * D);
    }
 
    public static Quaternion operator -(Quaternion q)
    {
        return new Quaternion(-q.A, -q.B, -q.C, -q.D);
    }
 
    public Quaternion Conjugate()
    {
        return new Quaternion(A, -B, -C, -D);
    }
 
    // implicit conversion takes care of real*quaternion and real+quaternion
    public static implicit operator Quaternion(double d)
    {
        return new Quaternion(d, 0, 0, 0);
    }
 
    public static Quaternion operator +(Quaternion q1, Quaternion q2)
    {
        return new Quaternion(q1.A + q2.A, q1.B + q2.B, q1.C + q2.C, q1.D + q2.D);
    }
 
    public static Quaternion operator *(Quaternion q1, Quaternion q2)
    {
        return new Quaternion(
            q1.A * q2.A - q1.B * q2.B - q1.C * q2.C - q1.D * q2.D,
            q1.A * q2.B + q1.B * q2.A + q1.C * q2.D - q1.D * q2.C,
            q1.A * q2.C - q1.B * q2.D + q1.C * q2.A + q1.D * q2.B,
            q1.A * q2.D + q1.B * q2.C - q1.C * q2.B + q1.D * q2.A);
    }
 
    public static bool operator ==(Quaternion q1, Quaternion q2)
    {
        return q1.A == q2.A && q1.B == q2.B && q1.C == q2.C && q1.D == q2.D;
    }
 
    public static bool operator !=(Quaternion q1, Quaternion q2)
    {
        return !(q1 == q2);
    }
 
    #region Object Members
 
    public override bool Equals(object obj)
    {
        if (obj is Quaternion)
            return Equals((Quaternion)obj);
 
        return false;
    }
 
    public override int GetHashCode()
    {
        return A.GetHashCode() ^ B.GetHashCode() ^ C.GetHashCode() ^ D.GetHashCode();
    }
 
    public override string ToString()
    {
        return string.Format(""Q({0}, {1}, {2}, {3})"", A, B, C, D);
    }
 
    #endregion
 
    #region IEquatable<Quaternion> Members
 
    public bool Equals(Quaternion other)
    {
        return other == this;
    }
 
    #endregion
}",2182,90
24854,http://rosettacode.org/wiki/Queue/Definition,Queue/Definition,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
 Illustration of FIFO behavior
Task

Implement a FIFO queue.

Elements are added at one side and popped from the other in the order of insertion.



Operations:

   push   (aka enqueue)    - add element
   pop     (aka dequeue)    - pop first element
   empty                             - return truth value when empty


Errors:

   handle the error of trying to pop from an empty queue (behavior depends on the language and platform)


See

   Queue/Usage   for the built-in FIFO or queue of your language or standard library.


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#C.23,C#,"public class FIFO<T>
{
  class Node
  {
    public T Item { get; set; }
    public Node Next { get; set; }
  }
  Node first = null;
  Node last = null;
  public void push(T item)
  {
    if (empty())
    {
      //Uses object initializers to set fields of new node
      first = new Node() { Item = item, Next = null };
      last = first;
    }
    else
    {
      last.Next = new Node() { Item = item, Next = null };
      last = last.Next;
    }
  }
  public T pop()
  {
    if (first == null)
      throw new System.Exception(""No elements""); 
    if (last == first)
      last = null;
    T temp = first.Item;
    first = first.Next;
    return temp;
  }
  public bool empty()
  {
    return first == null;
  }
}",717,38
24974,http://rosettacode.org/wiki/Quine,Quine,"A quine is a self-referential program that can,
without any external access, output its own source.



A   quine   (named after Willard Van Orman Quine)   is also known as:

   self-reproducing automata   (1972)
   self-replicating program         or   self-replicating computer program
   self-reproducing program      or   self-reproducing computer program
   self-copying program             or   self-copying computer program


It is named after the philosopher and logician
who studied self-reference and quoting in natural language,
as for example in the paradox ""'Yields falsehood when preceded by its quotation' yields falsehood when preceded by its quotation.""

""Source"" has one of two meanings. It can refer to the text-based program source.
For languages in which program source is represented as a data structure, ""source"" may refer to the data structure: quines in these languages fall into two categories: programs which print a textual representation of themselves, or expressions which evaluate to a data structure which is equivalent to that expression.

The usual way to code a quine works similarly to this paradox: The program consists of two identical parts, once as plain code and once quoted in some way (for example, as a character string, or a literal data structure). The plain code then accesses the quoted code and prints it out twice, once unquoted and once with the proper quotation marks added. Often, the plain code and the quoted code have to be nested.



Task

Write a program that outputs its own source code in this way. If the language allows it, you may add a variant that accesses the code directly. You are not allowed to read any external files with the source code. The program should also contain some sort of self-reference, so constant expressions which return their own value which some top-level interpreter will print out. Empty programs producing no output are not allowed.

There are several difficulties that one runs into when writing a quine, mostly dealing with quoting:

 Part of the code usually needs to be stored as a string or structural literal in the language, which needs to be quoted somehow. However, including quotation marks in the string literal itself would be troublesome because it requires them to be escaped, which then necessitates the escaping character (e.g. a backslash) in the string, which itself usually needs to be escaped, and so on.
 Some languages have a function for getting the ""source code representation"" of a string (i.e. adds quotation marks, etc.); in these languages, this can be used to circumvent the quoting problem.
 Another solution is to construct the quote character from its character code, without having to write the quote character itself. Then the character is inserted into the string at the appropriate places. The ASCII code for double-quote is 34, and for single-quote is 39.
 Newlines in the program may have to be reproduced as newlines in the string, which usually requires some kind of escape sequence (e.g. ""\n""). This causes the same problem as above, where the escaping character needs to itself be escaped, etc.
 If the language has a way of getting the ""source code representation"", it usually handles the escaping of characters, so this is not a problem.
 Some languages allow you to have a string literal that spans multiple lines, which embeds the newlines into the string without escaping.
 Write the entire program on one line, for free-form languages (as you can see for some of the solutions here, they run off the edge of the screen), thus removing the need for newlines. However, this may be unacceptable as some languages require a newline at the end of the file; and otherwise it is still generally good style to have a newline at the end of a file. (The task is not clear on whether a newline is required at the end of the file.) Some languages have a print statement that appends a newline; which solves the newline-at-the-end issue; but others do not.

Next to the Quines presented here, many other versions can be found on the Quine page.



Related task

   print itself.

",#C.23,C#,"class Program { static void Main() { var s = ""class Program {{ static void Main() {{ var s = {0}{1}{0}; System.Console.WriteLine(s, (char)34, s); }} }}""; System.Console.WriteLine(s, (char)34, s); } }",199,1
25616,http://rosettacode.org/wiki/Pythagorean_quadruples,Pythagorean quadruples,"

One form of   Pythagorean quadruples   is   (for positive integers   a,   b,   c,   and   d):



    a2   +   b2   +   c2     =     d2 


An example:

    22   +   32   +   62     =     72 
 which is:
    4    +   9    +   36     =     49 


Task

For positive integers up   2,200   (inclusive),   for all values of   a,  
b,   c,   and   d,

find   (and show here)   those values of   d   that   can't   be represented.

Show the values of   d   on one line of output   (optionally with a title).



Related tasks

   Euler's sum of powers conjecture. 
   Pythagorean triples.


Reference

   the Wikipedia article:   Pythagorean quadruple.

",#C.23,C#,"using System;
 
namespace PythagoreanQuadruples {
    class Program {
        const int MAX = 2200;
        const int MAX2 = MAX * MAX * 2;
 
        static void Main(string[] args) {
            bool[] found = new bool[MAX + 1]; // all false by default
            bool[] a2b2 = new bool[MAX2 + 1]; // ditto
            int s = 3;
 
            for(int a = 1; a <= MAX; a++) {
                int a2 = a * a;
                for (int b=a; b<=MAX; b++) {
                    a2b2[a2 + b * b] = true;
                }
            }
 
            for (int c = 1; c <= MAX; c++) {
                int s1 = s;
                s += 2;
                int s2 = s;
                for (int d = c + 1; d <= MAX; d++) {
                    if (a2b2[s1]) found[d] = true;
                    s1 += s2;
                    s2 += 2;
                }
            }
 
            Console.WriteLine(""The values of d <= {0} which can't be represented:"", MAX);
            for (int d = 1; d < MAX; d++) {
                if (!found[d]) Console.Write(""{0}  "", d);
            }
            Console.WriteLine();
        }
    }
}",1112,38
25780,http://rosettacode.org/wiki/Pythagorean_triples,Pythagorean triples,"A Pythagorean triple is defined as three positive integers 



(
a
,
b
,
c
)


{\displaystyle (a,b,c)}

 where 



a
<
b
<
c


{\displaystyle a<b<c}

, and 




a

2


+

b

2


=

c

2


.


{\displaystyle a^{2}+b^{2}=c^{2}.}



They are called primitive triples if 



a
,
b
,
c


{\displaystyle a,b,c}

 are co-prime, that is, if their pairwise greatest common divisors 





g
c
d


(
a
,
b
)
=


g
c
d


(
a
,
c
)
=


g
c
d


(
b
,
c
)
=
1


{\displaystyle {\rm {gcd}}(a,b)={\rm {gcd}}(a,c)={\rm {gcd}}(b,c)=1}

.

Because of their relationship through the Pythagorean theorem, a, b, and c are co-prime if a and b are co-prime (





g
c
d


(
a
,
b
)
=
1


{\displaystyle {\rm {gcd}}(a,b)=1}

).  

Each triple forms the length of the sides of a right triangle, whose perimeter is 



P
=
a
+
b
+
c


{\displaystyle P=a+b+c}

.



Task

The task is to determine how many Pythagorean triples there are with a perimeter no larger than 100 and the number of these that are primitive.



Extra credit
 
Deal with large values.   Can your program handle a maximum perimeter of 1,000,000?   What about 10,000,000?   100,000,000?

Note: the extra credit is not for you to demonstrate how fast your language is compared to others;   you need a proper algorithm to solve them in a timely manner.



Related tasks

   Euler's sum of powers conjecture 
   List comprehensions
   Pythagorean quadruples 

",#C.23,C#,"using System;
 
namespace RosettaCode.CSharp
{
    class Program
    {
        static void Count_New_Triangle(ulong A, ulong B, ulong C, ulong Max_Perimeter, ref ulong Total_Cnt, ref ulong Primitive_Cnt)
        {
            ulong Perimeter = A + B + C;
 
            if (Perimeter <= Max_Perimeter)
            {
                Primitive_Cnt = Primitive_Cnt + 1;
                Total_Cnt = Total_Cnt + Max_Perimeter / Perimeter;
                Count_New_Triangle(A + 2 * C - 2 * B, 2 * A + 2 * C - B, 2 * A + 3 * C - 2 * B, Max_Perimeter, ref Total_Cnt, ref Primitive_Cnt);
                Count_New_Triangle(A + 2 * B + 2 * C, 2 * A + B + 2 * C, 2 * A + 2 * B + 3 * C, Max_Perimeter, ref Total_Cnt, ref Primitive_Cnt);
                Count_New_Triangle(2 * B + 2 * C - A, B + 2 * C - 2 * A, 2 * B + 3 * C - 2 * A, Max_Perimeter, ref Total_Cnt, ref Primitive_Cnt);
            }
        }
 
        static void Count_Pythagorean_Triples()
        {
            ulong T_Cnt, P_Cnt;
 
            for (int I = 1; I <= 8; I++)
            {
                T_Cnt = 0;
                P_Cnt = 0;
                ulong ExponentNumberValue = (ulong)Math.Pow(10, I);
                Count_New_Triangle(3, 4, 5, ExponentNumberValue, ref T_Cnt, ref P_Cnt);
                Console.WriteLine(""Perimeter up to 10E"" + I + "" : "" + T_Cnt + "" Triples, "" + P_Cnt + "" Primitives"");
            }
        }
 
        static void Main(string[] args)
        {
            Count_Pythagorean_Triples();
        }
    }
}",1505,40
25801,http://rosettacode.org/wiki/QR_decomposition,QR decomposition,"Any rectangular 



m
×
n


{\displaystyle m\times n}

 matrix 





A




{\displaystyle {\mathit {A}}}

 can be decomposed to a product of an orthogonal matrix 





Q




{\displaystyle {\mathit {Q}}}

 and an upper (right) triangular matrix 





R




{\displaystyle {\mathit {R}}}

, as described in QR decomposition.

Task

Demonstrate the QR decomposition on the example matrix from the Wikipedia article:





A
=


(



12


−
51


4




6


167


−
68




−
4


24


−
41



)




{\displaystyle A={\begin{pmatrix}12&-51&4\\6&167&-68\\-4&24&-41\end{pmatrix}}}


and the usage for linear least squares problems on the example from Polynomial regression. The method of Householder reflections should be used:

Method

Multiplying a given vector 





a




{\displaystyle {\mathit {a}}}

, for example the first column of matrix 





A




{\displaystyle {\mathit {A}}}

, with the Householder matrix 





H




{\displaystyle {\mathit {H}}}

, which is given as





H
=
I
−


2


u

T


u



u

u

T




{\displaystyle H=I-{\frac {2}{u^{T}u}}uu^{T}}


reflects 





a




{\displaystyle {\mathit {a}}}

 about a plane given by its normal vector 





u




{\displaystyle {\mathit {u}}}

. When the normal vector of the plane 





u




{\displaystyle {\mathit {u}}}

 is given as





u
=
a
−
∥
a

∥

2




e

1




{\displaystyle u=a-\|a\|_{2}\;e_{1}}


then the transformation reflects 





a




{\displaystyle {\mathit {a}}}

 onto the first standard basis vector






e

1


=
[
1

0

0

.
.
.

]

T




{\displaystyle e_{1}=[1\;0\;0\;...]^{T}}


which means that all entries but the first become zero. To avoid numerical cancellation errors, we should take the opposite sign of 




a

1




{\displaystyle a_{1}}

:





u
=
a
+


sign


(

a

1


)
∥
a

∥

2




e

1




{\displaystyle u=a+{\textrm {sign}}(a_{1})\|a\|_{2}\;e_{1}}


and normalize with respect to the first element:





v
=


u

u

1






{\displaystyle v={\frac {u}{u_{1}}}}


The equation for 



H


{\displaystyle H}

 thus becomes:





H
=
I
−


2


v

T


v



v

v

T




{\displaystyle H=I-{\frac {2}{v^{T}v}}vv^{T}}


or, in another form





H
=
I
−
β
v

v

T




{\displaystyle H=I-\beta vv^{T}}


with





β
=


2


v

T


v





{\displaystyle \beta ={\frac {2}{v^{T}v}}}


Applying 





H




{\displaystyle {\mathit {H}}}

 on 





a




{\displaystyle {\mathit {a}}}

 then gives





H

a
=
−


sign


(

a

1


)

∥
a

∥

2




e

1




{\displaystyle H\;a=-{\textrm {sign}}(a_{1})\;\|a\|_{2}\;e_{1}}


and applying 





H




{\displaystyle {\mathit {H}}}

 on the matrix 





A




{\displaystyle {\mathit {A}}}

 zeroes all subdiagonal elements of the first column:






H

1



A
=


(




r

11





r

12





r

13






0


∗


∗




0


∗


∗



)




{\displaystyle H_{1}\;A={\begin{pmatrix}r_{11}&r_{12}&r_{13}\\0&*&*\\0&*&*\end{pmatrix}}}


In the second step, the second column of 





A




{\displaystyle {\mathit {A}}}

, we want to zero all elements but the first two, which means that we have to calculate 





H




{\displaystyle {\mathit {H}}}

 with the first column of the submatrix (denoted *), not on the whole second column of 





A




{\displaystyle {\mathit {A}}}

.

To get 




H

2




{\displaystyle H_{2}}

, we then embed the new 





H




{\displaystyle {\mathit {H}}}

 into an 



m
×
n


{\displaystyle m\times n}

 identity:






H

2


=


(



1


0


0




0


H





0





)




{\displaystyle H_{2}={\begin{pmatrix}1&0&0\\0&H&\\0&&\end{pmatrix}}}


This is how we can, column by column, remove all subdiagonal elements of 





A




{\displaystyle {\mathit {A}}}

 and thus transform it into 





R




{\displaystyle {\mathit {R}}}

.






H

n



.
.
.


H

3



H

2



H

1


A
=
R


{\displaystyle H_{n}\;...\;H_{3}H_{2}H_{1}A=R}


The product of all the Householder matrices 





H




{\displaystyle {\mathit {H}}}

, for every column, in reverse order, will then yield the orthogonal matrix 





Q




{\displaystyle {\mathit {Q}}}

.






H

1



H

2



H

3



.
.
.


H

n


=
Q


{\displaystyle H_{1}H_{2}H_{3}\;...\;H_{n}=Q}


The QR decomposition should then be used to solve linear least squares (Multiple regression) problems 





A


x
=
b


{\displaystyle {\mathit {A}}x=b}

 by solving





R

x
=

Q

T



b


{\displaystyle R\;x=Q^{T}\;b}


When 





R




{\displaystyle {\mathit {R}}}

 is not square, i.e. 



m
>
n


{\displaystyle m>n}

 we have to cut off the 





m


−
n


{\displaystyle {\mathit {m}}-n}

 zero padded bottom rows.





R
=


(




R

1






0



)




{\displaystyle R={\begin{pmatrix}R_{1}\\0\end{pmatrix}}}


and the same for the RHS:






Q

T



b
=


(




q

1







q

2





)




{\displaystyle Q^{T}\;b={\begin{pmatrix}q_{1}\\q_{2}\end{pmatrix}}}


Finally, solve the square upper triangular system by back substitution:






R

1



x
=

q

1




{\displaystyle R_{1}\;x=q_{1}}

",#C.23,C#,"using System;
using MathNet.Numerics.LinearAlgebra;
using MathNet.Numerics.LinearAlgebra.Double;
 
 
class Program
{
 
    static void Main(string[] args)
    {
        Matrix<double> A = DenseMatrix.OfArray(new double[,]
        {
                {  12,  -51,    4 },
                {   6,  167,  -68 },
                {  -4,   24,  -41 }
        });
        Console.WriteLine(""A:"");
        Console.WriteLine(A);
        var qr = A.QR();
        Console.WriteLine();
        Console.WriteLine(""Q:"");
        Console.WriteLine(qr.Q);
        Console.WriteLine();
        Console.WriteLine(""R:"");
        Console.WriteLine(qr.R);
    }
}",639,27
25874,http://rosettacode.org/wiki/Program_name,Program name,"The task is to programmatically obtain the name used to invoke the program. (For example determine whether the user ran ""python hello.py"", or ""python hellocaller.py"", a program importing the code from ""hello.py"".)

Sometimes a multiline shebang is necessary in order to provide the script name to a language's internal ARGV.

See also Command-line arguments

Examples from GitHub.
",#C.23,C#,"using System;
namespace ProgramName
{
	class Program
	{
		static void Main(string[] args)
		{
			Console.Write(Environment.CommandLine);
		}
	}
}",145,11
25920,http://rosettacode.org/wiki/Program_termination,Program termination,"

Task

Show the syntax for a complete stoppage of a program inside a   conditional.

This includes all threads/processes which are part of your program.

Explain the cleanup (or lack thereof) caused by the termination (allocated memory, database connections, open files, object finalizers/destructors, run-on-exit hooks, etc.).

Unless otherwise described, no special cleanup outside that provided by the operating system is provided.



",#C.23,C#,"if (problem)
{
   Environment.Exit(1);
}",40,4
26042,http://rosettacode.org/wiki/Problem_of_Apollonius,Problem of Apollonius,"
Task

Implement a solution to the Problem of Apollonius   (description on Wikipedia)   which is the problem of finding the circle that is tangent to three specified circles   (colored black in the diagram below to the right).

There is an   algebraic solution   which is pretty straightforward.



The solutions to the example in the code are shown in the diagram   (below and to the right).

The red circle is ""internally tangent"" to all three black circles,   and the green circle is ""externally tangent"" to all three black circles.



",#C.23,C#," 
using System;
 
namespace ApolloniusProblemCalc
{
    class Program
    {
        static float rs = 0;
        static float xs = 0;
        static float ys = 0;
 
        public static void Main(string[] args)
        {
            float gx1;
            float gy1;
            float gr1;
            float gx2;
            float gy2;
            float gr2;
            float gx3;
            float gy3;
            float gr3;
 
            //----------Enter values for the given circles here----------
            gx1 = 0;
            gy1 = 0;
            gr1 = 1;
            gx2 = 4;
            gy2 = 0;
            gr2 = 1;
            gx3 = 2;
            gy3 = 4;
            gr3 = 2;
            //-----------------------------------------------------------
 
            for (int i = 1; i <= 8; i++)
            {
                SolveTheApollonius(i, gx1, gy1, gr1, gx2, gy2, gr2, gx3, gy3, gr3);
 
 
                if (i == 1)
                {
                    Console.WriteLine(""X of point of the "" + i + ""st solution: "" + xs.ToString());
                    Console.WriteLine(""Y of point of the "" + i + ""st solution: "" + ys.ToString());
                    Console.WriteLine(i + ""st Solution circle's radius: "" + rs.ToString());
                }
                else if (i == 2)
                {
                    Console.WriteLine(""X of point of the "" + i + ""ed solution: "" + xs.ToString());
                    Console.WriteLine(""Y of point of the "" + i + ""ed solution: "" + ys.ToString());
                    Console.WriteLine(i + ""ed Solution circle's radius: "" + rs.ToString());
                }
                else if(i == 3)
                {
                    Console.WriteLine(""X of point of the "" + i + ""rd solution: "" + xs.ToString());
                    Console.WriteLine(""Y of point of the "" + i + ""rd solution: "" + ys.ToString());
                    Console.WriteLine(i + ""rd Solution circle's radius: "" + rs.ToString());
                }
                else
                {
                    Console.WriteLine(""X of point of the "" + i + ""th solution: "" + xs.ToString());
                    Console.WriteLine(""Y of point of the "" + i + ""th solution: "" + ys.ToString());
                    Console.WriteLine(i + ""th Solution circle's radius: "" + rs.ToString());
                }
 
                Console.WriteLine();
            }
 
 
            Console.ReadKey(true);
        }
 
        private static void SolveTheApollonius(int calcCounter, float x1, float y1, float r1, float x2, float y2, float r2, float x3, float y3, float r3)
        {
            float s1 = 1;
            float s2 = 1;
            float s3 = 1;
 
            if (calcCounter == 2)
            {
                s1 = -1;
                s2 = -1;
                s3 = -1;
            }
            else if (calcCounter == 3)
            {
                s1 = 1;
                s2 = -1;
                s3 = -1;
            }
            else if (calcCounter == 4)
            {
                s1 = -1;
                s2 = 1;
                s3 = -1;
            }
            else if (calcCounter == 5)
            {
                s1 = -1;
                s2 = -1;
                s3 = 1;
            }
            else if (calcCounter == 6)
            {
                s1 = 1;
                s2 = 1;
                s3 = -1;
            }
            else if (calcCounter == 7)
            {
                s1 = -1;
                s2 = 1;
                s3 = 1;
            }
            else if (calcCounter == 8)
            {
                s1 = 1;
                s2 = -1;
                s3 = 1;
            }
 
            //This calculation to solve for the solution circles is cited from the Java version 
            float v11 = 2 * x2 - 2 * x1;
            float v12 = 2 * y2 - 2 * y1;
            float v13 = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2 - r1 * r1 + r2 * r2;
            float v14 = 2 * s2 * r2 - 2 * s1 * r1;
 
            float v21 = 2 * x3 - 2 * x2;
            float v22 = 2 * y3 - 2 * y2;
            float v23 = x2 * x2 - x3 * x3 + y2 * y2 - y3 * y3 - r2 * r2 + r3 * r3;
            float v24 = 2 * s3 * r3 - 2 * s2 * r2;
 
            float w12 = v12 / v11;
            float w13 = v13 / v11;
            float w14 = v14 / v11;
 
            float w22 = v22 / v21 - w12;
            float w23 = v23 / v21 - w13;
            float w24 = v24 / v21 - w14;
 
            float P = -w23 / w22;
            float Q = w24 / w22;
            float M = -w12 * P - w13;
            float N = w14 - w12 * Q;
 
            float a = N * N + Q * Q - 1;
            float b = 2 * M * N - 2 * N * x1 + 2 * P * Q - 2 * Q * y1 + 2 * s1 * r1;
            float c = x1 * x1 + M * M - 2 * M * x1 + P * P + y1 * y1 - 2 * P * y1 - r1 * r1;
 
            float D = b * b - 4 * a * c;
 
            rs = (-b - float.Parse(Math.Sqrt(D).ToString())) / (2 * float.Parse(a.ToString()));
            xs = M + N * rs;
            ys = P + Q * rs;
        }
    }
}
 ",5007,158
26139,http://rosettacode.org/wiki/Prime_conspiracy,Prime conspiracy,"A recent discovery, quoted from   Quantamagazine   (March 13, 2016):

     Two mathematicians have uncovered a simple, previously unnoticed property of 
     prime numbers — those numbers that are divisible only by 1 and themselves.     
     Prime numbers, it seems, have decided preferences about the final digits of    
     the primes that immediately follow them.  

and

     This conspiracy among prime numbers seems, at first glance, to violate a     
     longstanding assumption in number theory:  that prime numbers behave much    
     like random numbers. 

                            ─── (original authors from Stanford University):      
                            ─── Kannan Soundararajan  and  Robert Lemke Oliver    



The task is to check this assertion, modulo 10.

Lets call    i -> j    a transition if    i    is the last decimal digit of a prime, and    j    the last decimal digit of the following prime.



Task

Considering the first one million primes.   Count, for any pair of successive primes, the number of transitions    i -> j    and print them along with their relative frequency, sorted by    i .

You can see that, for a given    i ,   frequencies are not evenly distributed.



Observation

(Modulo 10),   primes whose last digit is   9   ""prefer""   the digit   1   to the digit   9,   as its following prime.



Extra credit

Do the same for one hundred million primes.



Example for 10,000 primes

10000 first primes. Transitions prime % 10 → next-prime % 10.
1 → 1 count:        365 frequency: 3.65 %
1 → 3 count:        833 frequency: 8.33 %
1 → 7 count:        889 frequency: 8.89 %
1 → 9 count:        397 frequency: 3.97 %
2 → 3 count:          1 frequency: 0.01 %
3 → 1 count:        529 frequency: 5.29 %
3 → 3 count:        324 frequency: 3.24 %
3 → 5 count:          1 frequency: 0.01 %
3 → 7 count:        754 frequency: 7.54 %
3 → 9 count:        907 frequency: 9.07 %
5 → 7 count:          1 frequency: 0.01 %
7 → 1 count:        655 frequency: 6.55 %
7 → 3 count:        722 frequency: 7.22 %
7 → 7 count:        323 frequency: 3.23 %
7 → 9 count:        808 frequency: 8.08 %
9 → 1 count:        935 frequency: 9.35 %
9 → 3 count:        635 frequency: 6.35 %
9 → 7 count:        541 frequency: 5.41 %
9 → 9 count:        379 frequency: 3.79 % 


",#C.23,C#,"using System;
 
namespace PrimeConspiracy {
    class Program {
        static void Main(string[] args) {
            const int limit = 1_000_000;
            const int sieveLimit = 15_500_000;
 
            int[,] buckets = new int[10, 10];
            int prevDigit = 2;
            bool[] notPrime = Sieve(sieveLimit);
 
            for (int n = 3, primeCount = 1; primeCount < limit; n++) {
                if (notPrime[n]) continue;
 
                int digit = n % 10;
                buckets[prevDigit, digit]++;
                prevDigit = digit;
                primeCount++;
            }
 
            for (int i = 0; i < 10; i++) {
                for (int j = 0; j < 10; j++) {
                    if (buckets[i, j] != 0) {
                        Console.WriteLine(""{0} -> {1}  count: {2,5:d}  frequency : {3,6:0.00%}"", i, j, buckets[i, j], 1.0 * buckets[i, j] / limit);
                    }
                }
            }
        }
 
        public static bool[] Sieve(int limit) {
            bool[] composite = new bool[limit];
            composite[0] = composite[1] = true;
 
            int max = (int)Math.Sqrt(limit);
            for (int n = 2; n <= max; n++) {
                if (!composite[n]) {
                    for (int k = n * n; k < limit; k += n) {
                        composite[k] = true;
                    }
                }
            }
 
            return composite;
        }
    }
}",1434,47
26144,http://rosettacode.org/wiki/Priority_queue,Priority queue,"A priority queue is somewhat similar to a queue, with an important distinction: each item is added to a priority queue with a priority level, and will be later removed from the queue with the highest priority element first. That is, the items are (conceptually) stored in the queue in priority order instead of in insertion order.



Task

Create a priority queue.   The queue must support at least two operations:

   Insertion.   An element is added to the queue with a priority (a numeric value).
   Top item removal.   Deletes the element or one of the elements with the current top priority and return it.


Optionally, other operations may be defined, such as peeking (find what current top priority/top element is), merging (combining two priority queues into one), etc.



To test your implementation, insert a number of elements into the queue, each with some random priority.

Then dequeue them sequentially; now the elements should be sorted by priority.

You can use the following task/priority items as input data:

        Priority         Task
       ══════════   ════════════════
           3         Clear drains
           4         Feed cat
           5         Make tea
           1         Solve RC tasks
           2         Tax return



The implementation should try to be efficient.   A typical implementation has   O(log n)   insertion and extraction time,   where   n   is the number of items in the queue.

You may choose to impose certain limits such as small range of allowed priority levels, limited capacity, etc.   If so, discuss the reasons behind it.



",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace PriorityQueueExample
{
	class Program
	{
		static void Main(string[] args)
		{
			// Starting with .NET 6.0 preview 2 (released March 11th, 2021), there's a built-in priority queue
			var p = new PriorityQueue<string, int>();
			p.Enqueue(""Clear drains"", 3);
			p.Enqueue(""Feed cat"", 4);
			p.Enqueue(""Make tea"", 5);
			p.Enqueue(""Solve RC tasks"", 1);
			p.Enqueue(""Tax return"", 2);
			while (p.TryDequeue(out string task, out int priority))
			{
				Console.WriteLine($""{priority}\t{task}"");
			}
		}
	}
}
 
/* Output:
 
1       Solve RC tasks
2       Tax return
3       Clear drains
4       Feed cat
5       Make tea
 
 */",684,33
26165,http://rosettacode.org/wiki/Probabilistic_choice,Probabilistic choice,"Given a mapping between items and their required probability of occurrence, generate a million items randomly subject to the given probabilities and compare the target probability of occurrence versus the generated values.

The total of all the probabilities should equal one. (Because floating point arithmetic is involved, this is subject to rounding errors).

aleph   1/5.0
beth    1/6.0
gimel   1/7.0
daleth  1/8.0
he      1/9.0
waw     1/10.0
zayin   1/11.0
heth    1759/27720 # adjusted so that probabilities add to 1
Related task

 Random number generator (device)

",#C.23,C#," 
using System;
 
class Program
{
    static long TRIALS = 1000000L;
    private class Expv
    {
        public string name;
        public int probcount;
        public double expect;
        public double mapping;
 
        public Expv(string name, int probcount, double expect, double mapping)
        {
            this.name = name;
            this.probcount = probcount;
            this.expect = expect;
            this.mapping = mapping;
        }
    }
 
    static Expv[] items = {
        new Expv(""aleph"", 0, 0.0, 0.0), new Expv(""beth"", 0, 0.0, 0.0),
        new Expv(""gimel"", 0, 0.0, 0.0), new Expv(""daleth"", 0, 0.0, 0.0),
	new Expv(""he"", 0, 0.0, 0.0),    new Expv(""waw"", 0, 0.0, 0.0),
	new Expv(""zayin"", 0, 0.0, 0.0), new Expv(""heth"", 0, 0.0, 0.0)
    };
 
    static void Main(string[] args)
    {
        double rnum, tsum = 0.0;
        Random random = new Random();
 
        for (int i = 0, rnum = 5.0; i < 7; i++, rnum += 1.0)
        {
            items[i].expect = 1.0 / rnum;
            tsum += items[i].expect;
        }
        items[7].expect = 1.0 - tsum;
 
        items[0].mapping = 1.0 / 5.0;
        for (int i = 1; i < 7; i++)
            items[i].mapping = items[i - 1].mapping + 1.0 / ((double)i + 5.0);
        items[7].mapping = 1.0;
 
        for (int i = 0; i < TRIALS; i++)
        {
            rnum = random.NextDouble();
            for (int j = 0; j < 8; j++)
                if (rnum < items[j].mapping)
                {
                    items[j].probcount++;
                    break;
                }
        }
 
        Console.WriteLine(""Trials: {0}"", TRIALS);
        Console.Write(""Items:          "");
        for (int i = 0; i < 8; i++)
            Console.Write(items[i].name.PadRight(9));
        Console.WriteLine();
        Console.Write(""Target prob.:   "");
        for (int i = 0; i < 8; i++)
            Console.Write(""{0:0.000000} "", items[i].expect);
        Console.WriteLine();
        Console.Write(""Attained prob.: "");
        for (int i = 0; i < 8; i++)
            Console.Write(""{0:0.000000} "", (double)items[i].probcount / (double)TRIALS);
        Console.WriteLine();
    }
}
 ",2155,73
26209,http://rosettacode.org/wiki/Proper_divisors,Proper divisors,"The   proper divisors   of a positive integer N are those numbers, other than N itself, that divide N without remainder.

For N > 1 they will always include 1,   but for N == 1 there are no proper divisors.



Examples

The proper divisors of     6     are   1, 2, and 3.

The proper divisors of   100   are   1, 2, 4, 5, 10, 20, 25, and 50.



Task

 Create a routine to generate all the proper divisors of a number.
 use it to show the proper divisors of the numbers 1 to 10 inclusive.
 Find a number in the range 1 to 20,000 with the most proper divisors. Show the number and just the count of how many proper divisors it has.


Show all output here.



Related tasks

   Amicable pairs
   Abundant, deficient and perfect number classifications
   Aliquot sequence classifications
   Factors of an integer
   Prime decomposition

",#C.23,C#,"namespace RosettaCode.ProperDivisors
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
 
    internal static class Program
    {
        private static IEnumerable<int> ProperDivisors(int number)
        {
            return
                Enumerable.Range(1, number / 2)
                    .Where(divisor => number % divisor == 0);
        }
 
        private static void Main()
        {
            foreach (var number in Enumerable.Range(1, 10))
            {
                Console.WriteLine(""{0}: {{{1}}}"", number,
                    string.Join("", "", ProperDivisors(number)));
            }
 
            var record = Enumerable.Range(1, 20000).Select(number => new
            {
                Number = number,
                Count = ProperDivisors(number).Count()
            }).OrderByDescending(currentRecord => currentRecord.Count).First();
            Console.WriteLine(""{0}: {1}"", record.Number, record.Count);
        }
    }
}",979,32
26222,http://rosettacode.org/wiki/Primality_by_Wilson%27s_theorem,Primality by Wilson's theorem,"Task

Write a boolean function that tells whether a given integer is prime using Wilson's theorem.

By Wilson's theorem, a number p is prime if and only if p divides (p - 1)! + 1.

Remember that 1 and all non-positive integers are not prime.



See also

 Cut-the-knot: Wilson's theorem.
 Wikipedia: Wilson's theorem

",#C.23,C#,"using System;
using System.Linq;
using System.Collections;
using static System.Console;
using System.Collections.Generic;
using BI = System.Numerics.BigInteger;
 
class Program {
 
  // initialization
    const int fst = 120, skp = 1000, max = 1015; static double et1, et2; static DateTime st;
    static string ms1 = ""Wilson's theorem method"", ms2 = ""Sieve of Eratosthenes method"", 
       fmt = ""--- {0} ---\n\nThe first {1} primes are:"", fm2 = ""{0} prime thru the {1} prime:"";
    static List<int> lst = new List<int>();
 
  // dumps a chunk of the prime list (lst)
    static void Dump(int s, int t, string f) {
        foreach (var item in lst.Skip(s).Take(t)) Write(f, item); WriteLine(""\n""); }
 
  // returns the ordinal string representation of a number
    static string Ord(int x, string fmt = ""{0:n0}"") {
      var y = x % 10; if ((x % 100) / 10 == 10 || y > 3) y = 0;
      return string.Format(fmt, x) + ""thstndrd"".Substring(y << 1, 2); }
 
  // shows the results of one type of prime tabulation
    static void ShowOne(string title, ref double et) {
        WriteLine(fmt, title, fst); Dump(0, fst, ""{0,-3} "");
        WriteLine(fm2, Ord(skp), Ord(max)); Dump(skp - 1, max - skp + 1, ""{0,4} "");
        WriteLine(""Time taken: {0}ms\n"", et = (DateTime.Now - st).TotalMilliseconds); }
 
  // for stand-alone computation
    static BI factorial(int n) { BI res = 1; if (n < 2) return res;
        while (n > 0) res *= n--; return res; }
 
    static bool WTisPrimeSA(int n) { return ((factorial(n - 1) + 1) % n) == 0; }
 
    static BI[] facts;
 
    static void initFacts(int n) {
        facts = new BI[n]; facts[0] = facts[1] = 1;
        for (int i = 1, j = 2; j < n; i = j++)
            facts[j] = facts[i] * j; }
 
    static bool WTisPrime(int n) { return ((facts[n - 1] + 1) % n) == 0; }
  // end stand-alone
 
    static void Main(string[] args) { st = DateTime.Now;
        BI f = 1; for (int n = 2; lst.Count < max; f *= n++) if ((f + 1) % n == 0) lst.Add(n);
        ShowOne(ms1, ref et1);
        st = DateTime.Now; int lmt = lst.Last(); lst.Clear(); BitArray flags = new BitArray(lmt + 1);
        for (int n = 2; n <= lmt; n+=n==2?1:2) if (!flags[n]) {
                lst.Add(n); for (int k = n * n, n2=n<<1; k <= lmt; k += n2) flags[k] = true; }
        ShowOne(ms2, ref et2);
        WriteLine(""{0} was {1:0.0} times slower than the {2}."", ms1, et1 / et2, ms2);
 
      // stand-alone computation
        WriteLine(""\n"" + ms1 + "" stand-alone computation:"");
        WriteLine(""factorial computed for each item"");
        st = DateTime.Now;
        for (int x = lst[skp - 1]; x <= lst[max - 1]; x++) if (WTisPrimeSA(x)) Write(""{0,4} "", x);
        WriteLine(); WriteLine(""\nTime taken: {0}ms\n"", (DateTime.Now - st).TotalMilliseconds);
 
        WriteLine(""factorials precomputed up to highest item"");
        st = DateTime.Now; initFacts(lst[max - 1]);
        for (int x = lst[skp - 1]; x <= lst[max - 1]; x++) if (WTisPrime(x)) Write(""{0,4} "", x);
        WriteLine(); WriteLine(""\nTime taken: {0}ms\n"", (DateTime.Now - st).TotalMilliseconds);
    }
}",3083,68
26344,http://rosettacode.org/wiki/Polyspiral,Polyspiral,"A Polyspiral is a spiral made of multiple line segments, whereby each segment is larger (or smaller) than the previous one by a given amount. Each segment also changes direction at a given angle.



Task
Animate a series of polyspirals, by drawing a complete spiral then incrementing the angle, and (after clearing the background) drawing the next, and so on. Every spiral will be a frame of the animation. The animation may stop as it goes full circle or continue indefinitely. The given input values may be varied.

If animation is not practical in your programming environment, you may show a single frame instead.



Pseudo code
    set incr to 0.0

    // animation loop
    WHILE true 

        incr = (incr + 0.05) MOD 360
        x = width / 2
        y = height / 2
        length = 5
        angle = incr

        // spiral loop
        FOR 1 TO 150
            drawline
            change direction by angle
            length = length + 3
            angle = (angle + incr) MOD 360
        ENDFOR
    


",#C.23,C#,"using System;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Windows.Forms;
using System.Windows.Threading;
 
namespace Polyspiral
{
    public partial class Form1 : Form
    {
        private double inc;
 
        public Form1()
        {
            Width = Height = 640;
            StartPosition = FormStartPosition.CenterScreen;
            SetStyle(
                ControlStyles.AllPaintingInWmPaint |
                ControlStyles.UserPaint |
                ControlStyles.DoubleBuffer,
                true);
 
            var timer = new DispatcherTimer();
            timer.Tick += (s, e) => { inc = (inc + 0.05) % 360; Refresh(); };
            timer.Interval = new TimeSpan(0, 0, 0, 0, 40);
            timer.Start();
        }
 
        private void DrawSpiral(Graphics g, int len, double angleIncrement)
        {
            double x1 = Width / 2;
            double y1 = Height / 2;
            double angle = angleIncrement;
 
            for (int i = 0; i < 150; i++)
            {
                double x2 = x1 + Math.Cos(angle) * len;
                double y2 = y1 - Math.Sin(angle) * len;
                g.DrawLine(Pens.Blue, (int)x1, (int)y1, (int)x2, (int)y2);
                x1 = x2;
                y1 = y2;
 
                len += 3;
 
                angle = (angle + angleIncrement) % (Math.PI * 2);
            }
        }
 
        protected override void OnPaint(PaintEventArgs args)
        {
            var g = args.Graphics;
            g.SmoothingMode = SmoothingMode.AntiAlias;
            g.Clear(Color.White);
 
            DrawSpiral(g, 5, ToRadians(inc));
        }
 
        private double ToRadians(double angle)
        {
            return Math.PI * angle / 180.0;
        }
    }
}",1753,63
26471,http://rosettacode.org/wiki/Polymorphic_copy,Polymorphic copy,"An object is polymorphic when its specific type may vary.
The types a specific value may take, is called class.

It is trivial to copy an object if its type is known:

int x;
int y = x;
Here x is not polymorphic, so y is declared of same type (int) as x.
But if the specific type of x were unknown, then y could not be declared of any specific type.

The task: let a polymorphic object contain an instance of some specific type S derived from a type T.
The type T is known.
The type S is possibly unknown until run time.
The objective is to create an exact copy of such polymorphic object (not to create a reference, nor a pointer to).
Let further the type T have a method overridden by S.
This method is to be called on the copy to demonstrate that the specific type of the copy is indeed S.
",#C.23,C#,"using System;
 
class T
{
    public virtual string Name()
    {
        return ""T"";
    }
 
    public virtual T Clone()
    {
        return new T();
    }
}
 
class S : T
{
    public override string Name()
    {
        return ""S"";
    }
 
    public override T Clone()
    {
        return new S();
    }
}
 
class Program
{
    static void Main()
    {
        T original = new S();
        T clone = original.Clone();
 
        Console.WriteLine(original.Name());
        Console.WriteLine(clone.Name());
    }
}",519,39
26502,http://rosettacode.org/wiki/Price_fraction,Price fraction,"A friend of mine runs a pharmacy.   He has a specialized function in his Dispensary application which receives a decimal value of currency and replaces it to a standard value.   This value is regulated by a government department.



Task

Given a floating point value between   0.00   and   1.00,   rescale according to the following table:

>=  0.00  <  0.06  :=  0.10
>=  0.06  <  0.11  :=  0.18
>=  0.11  <  0.16  :=  0.26
>=  0.16  <  0.21  :=  0.32
>=  0.21  <  0.26  :=  0.38
>=  0.26  <  0.31  :=  0.44
>=  0.31  <  0.36  :=  0.50
>=  0.36  <  0.41  :=  0.54
>=  0.41  <  0.46  :=  0.58
>=  0.46  <  0.51  :=  0.62
>=  0.51  <  0.56  :=  0.66
>=  0.56  <  0.61  :=  0.70
>=  0.61  <  0.66  :=  0.74
>=  0.66  <  0.71  :=  0.78
>=  0.71  <  0.76  :=  0.82
>=  0.76  <  0.81  :=  0.86
>=  0.81  <  0.86  :=  0.90
>=  0.86  <  0.91  :=  0.94
>=  0.91  <  0.96  :=  0.98
>=  0.96  <  1.01  :=  1.00


",#C.23,C#,"namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int x = 0; x < 10; x++)
            {
                Console.WriteLine(""In: {0:0.00}, Out: {1:0.00}"", ((double)x) / 10, SpecialRound(((double)x) / 10));
            }
 
            Console.WriteLine();
 
            for (int x = 0; x < 10; x++)
            {
                Console.WriteLine(""In: {0:0.00}, Out: {1:0.00}"", ((double)x) / 10 + 0.05, SpecialRound(((double)x) / 10 + 0.05));
            }
 
            Console.WriteLine();
            Console.WriteLine(""In: {0:0.00}, Out: {1:0.00}"", 1.01, SpecialRound(1.01));
 
            Console.Read();
        }
 
        private static double SpecialRound(double inValue)
        {
            if (inValue > 1) return 1;
 
            double[] Splitters = new double[] { 
                   0.00 , 0.06 , 0.11 , 0.16 , 0.21 , 
                   0.26 , 0.31 , 0.36 , 0.41 , 0.46 , 
                   0.51 , 0.56 , 0.61 , 0.66 , 0.71 , 
                   0.76 , 0.81 , 0.86 , 0.91 , 0.96 };
 
            double[] replacements = new double[] { 
                    0.10 , 0.18 , 0.26 , 0.32 , 0.38 ,
                    0.44 , 0.50 , 0.54 , 0.58 , 0.62 , 
                    0.66 , 0.70 , 0.74 , 0.78 , 0.82 , 
                    0.86 , 0.90 , 0.94 , 0.98 , 1.00 };
 
            for (int x = 0; x < Splitters.Length - 1; x++)
            {
                if (inValue >= Splitters[x] &&
                    inValue < Splitters[x + 1])
                {
                    return replacements[x];
                }
            }
 
            return inValue;
        }
    }
}",1659,53
26522,http://rosettacode.org/wiki/Polynomial_long_division,Polynomial long division,"

 This page uses content from Wikipedia. The original article was at Polynomial long division. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

In algebra, polynomial long division is an algorithm for dividing a polynomial by another polynomial of the same or lower degree.
Let us suppose a polynomial is represented by a vector, 



x


{\displaystyle x}

 (i.e., an ordered collection of coefficients) so that the 



i


{\displaystyle i}

th element keeps the coefficient of 




x

i




{\displaystyle x^{i}}

, and the multiplication by a monomial is a shift of the vector's elements ""towards right"" (injecting ones from left) followed by a multiplication of each element by the coefficient of the monomial.

Then a pseudocode for the polynomial long division using the conventions described above could be:

degree(P):
  return the index of the last non-zero element of P;
         if all elements are 0, return -∞

polynomial_long_division(N, D) returns (q, r):
  // N, D, q, r are vectors
  if degree(D) < 0 then error
  q ← 0
  while degree(N) ≥ degree(D)
    d ← D shifted right by (degree(N) - degree(D))
    q(degree(N) - degree(D)) ← N(degree(N)) / d(degree(d))
    // by construction, degree(d) = degree(N) of course
    d ← d * q(degree(N) - degree(D))
    N ← N - d
  endwhile
  r ← N
  return (q, r)

Note: vector * scalar multiplies each element of the vector by the scalar; vectorA - vectorB subtracts each element of the vectorB from the element of the vectorA with ""the same index"". The vectors in the pseudocode are zero-based.

 Error handling (for allocations or for wrong inputs) is not mandatory.
 Conventions can be different; in particular, note that if the first coefficient in the vector is the highest power of x for the polynomial represented by the vector, then the algorithm becomes simpler.

Example for clarification


This example is from Wikipedia, but changed to show how the given pseudocode works.

      0    1    2    3
   ----------------------
N:  -42    0  -12    1        degree = 3
D:   -3    1    0    0        degree = 1

   d(N) - d(D) = 2, so let's shift D towards right by 2:

N:  -42    0  -12    1
d:    0    0   -3    1

   N(3)/d(3) = 1, so d is unchanged. Now remember that ""shifting by 2""
   is like multiplying by x2, and the final multiplication
   (here by 1) is the coefficient of this monomial. Let's store this
   into q:
                               0     1     2
                              ---------------
                          q:   0     0     1

   now compute N - d, and let it be the ""new"" N, and let's loop

N:  -42    0   -9    0        degree = 2
D:   -3    1    0    0        degree = 1

   d(N) - d(D) = 1, right shift D by 1 and let it be d

N:  -42    0   -9    0
d:    0   -3    1    0        * -9/1 = -9

                          q:   0    -9     1

d:    0   27   -9    0        

   N ← N - d

N:  -42  -27    0    0        degree = 1
D:   -3    1    0    0        degree = 1

   looping again... d(N)-d(D)=0, so no shift is needed; we
   multiply D by -27 (= -27/1) storing the result in d, then

                          q:  -27   -9     1

   and

N:  -42  -27    0    0        -
d:   81  -27    0    0        =
N: -123    0    0    0        (last N)

    d(N) < d(D), so now r ← N, and the result is:

       0   1  2
   -------------
q:   -27  -9  1   →  x2 - 9x - 27
r:  -123   0  0   →          -123



Related task

   Polynomial derivative

",#C.23,C#,"using System;
 
namespace PolynomialLongDivision {
    class Solution {
        public Solution(double[] q, double[] r) {
            Quotient = q;
            Remainder = r;
        }
 
        public double[] Quotient { get; }
        public double[] Remainder { get; }
    }
 
    class Program {
        static int PolyDegree(double[] p) {
            for (int i = p.Length - 1; i >= 0; --i) {
                if (p[i] != 0.0) return i;
            }
            return int.MinValue;
        }
 
        static double[] PolyShiftRight(double[] p, int places) {
            if (places <= 0) return p;
            int pd = PolyDegree(p);
            if (pd + places >= p.Length) {
                throw new ArgumentOutOfRangeException(""The number of places to be shifted is too large"");
            }
            double[] d = new double[p.Length];
            p.CopyTo(d, 0);
            for (int i = pd; i >= 0; --i) {
                d[i + places] = d[i];
                d[i] = 0.0;
            }
            return d;
        }
 
        static void PolyMultiply(double[] p, double m) {
            for (int i = 0; i < p.Length; ++i) {
                p[i] *= m;
            }
        }
 
        static void PolySubtract(double[] p, double[] s) {
            for (int i = 0; i < p.Length; ++i) {
                p[i] -= s[i];
            }
        }
 
        static Solution PolyLongDiv(double[] n, double[] d) {
            if (n.Length != d.Length) {
                throw new ArgumentException(""Numerator and denominator vectors must have the same size"");
            }
            int nd = PolyDegree(n);
            int dd = PolyDegree(d);
            if (dd < 0) {
                throw new ArgumentException(""Divisor must have at least one one-zero coefficient"");
            }
            if (nd < dd) {
                throw new ArgumentException(""The degree of the divisor cannot exceed that of the numerator"");
            }
            double[] n2 = new double[n.Length];
            n.CopyTo(n2, 0);
            double[] q = new double[n.Length];
            while (nd >= dd) {
                double[] d2 = PolyShiftRight(d, nd - dd);
                q[nd - dd] = n2[nd] / d2[nd];
                PolyMultiply(d2, q[nd - dd]);
                PolySubtract(n2, d2);
                nd = PolyDegree(n2);
            }
            return new Solution(q, n2);
        }
 
        static void PolyShow(double[] p) {
            int pd = PolyDegree(p);
            for (int i = pd; i >= 0; --i) {
                double coeff = p[i];
                if (coeff == 0.0) continue;
                if (coeff == 1.0) {
                    if (i < pd) {
                        Console.Write("" + "");
                    }
                } else if (coeff == -1.0) {
                    if (i < pd) {
                        Console.Write("" - "");
                    } else {
                        Console.Write(""-"");
                    }
                } else if (coeff < 0.0) {
                    if (i < pd) {
                        Console.Write("" - {0:F1}"", -coeff);
                    } else {
                        Console.Write(""{0:F1}"", coeff);
                    }
                } else {
                    if (i < pd) {
                        Console.Write("" + {0:F1}"", coeff);
                    } else {
                        Console.Write(""{0:F1}"", coeff);
                    }
                }
                if (i > 1) Console.Write(""x^{0}"", i);
                else if (i == 1) Console.Write(""x"");
            }
            Console.WriteLine();
        }
 
        static void Main(string[] args) {
            double[] n = { -42.0, 0.0, -12.0, 1.0 };
            double[] d = { -3.0, 1.0, 0.0, 0.0 };
            Console.Write(""Numerator   : "");
            PolyShow(n);
            Console.Write(""Denominator : "");
            PolyShow(d);
            Console.WriteLine(""-------------------------------------"");
            Solution sol = PolyLongDiv(n, d);
            Console.Write(""Quotient    : "");
            PolyShow(sol.Quotient);
            Console.Write(""Remainder   : "");
            PolyShow(sol.Remainder);
        }
    }
}",4186,123
26527,http://rosettacode.org/wiki/Polynomial_regression,Polynomial regression,"Find an approximating polynomial of known degree for a given data.

Example:
For input data:

x = {0,  1,  2,  3,  4,  5,  6,   7,   8,   9,   10};
y = {1,  6,  17, 34, 57, 86, 121, 162, 209, 262, 321};

The approximating polynomial is:

3 x2 + 2 x + 1

Here, the polynomial's coefficients are (3, 2, 1).

This task is intended as a subtask for Measure relative performance of sorting algorithms implementations.
",#C.23,C#,"        public static double[] Polyfit(double[] x, double[] y, int degree)
        {
            // Vandermonde matrix
            var v = new DenseMatrix(x.Length, degree + 1);
            for (int i = 0; i < v.RowCount; i++)
                for (int j = 0; j <= degree; j++) v[i, j] = Math.Pow(x[i], j);
            var yv = new DenseVector(y).ToColumnMatrix();
            QR<double> qr = v.QR();
            // Math.Net doesn't have an ""economy"" QR, so:
            // cut R short to square upper triangle, then recompute Q
            var r = qr.R.SubMatrix(0, degree + 1, 0, degree + 1);
            var q = v.Multiply(r.Inverse());
            var p = r.Inverse().Multiply(q.TransposeThisAndMultiply(yv));
            return p.Column(0).ToArray();
        }",764,15
26543,http://rosettacode.org/wiki/Prime_decomposition,Prime decomposition,"The prime decomposition of a number is defined as a list of prime numbers
which when all multiplied together, are equal to that number.



Example

 12 = 2 × 2 × 3,  so its prime decomposition is  {2, 2, 3}



Task

Write a function which returns an array or collection which contains the prime decomposition of a given number   



n


{\displaystyle n}

   greater than   1.

If your language does not have an isPrime-like function available,
you may assume that you have a function which determines
whether a number is prime (note its name before your code).

If you would like to test code from this task, you may use code from trial division or the Sieve of Eratosthenes.

Note: The program must not be limited by the word size of your computer or some other artificial limit; it should work for any number regardless of size (ignoring the physical limits of RAM etc).



Related tasks

   count in factors
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace PrimeDecomposition
{
    class Program
    {
        static void Main(string[] args)
        {
            GetPrimes(12);
        }
 
        static List<int> GetPrimes(decimal n)
        {
            List<int> storage = new List<int>();
            while (n > 1)
            {
                int i = 1;
                while (true)
                {
                    if (IsPrime(i))
                    {                        
                        if (((decimal)n / i) == Math.Round((decimal) n / i))
                        {
                            n /= i;
                            storage.Add(i);                            
                            break;
                        }
                    }
                    i++;
                }
            }
            return storage;
        }
 
        static bool IsPrime(int n)
        {
            if (n <= 1) return false;
            for (int i = 2; i <= Math.Sqrt(n); i++)
                if (n % i == 0) return false;
            return true;
        }
    }
}",1109,44
26573,http://rosettacode.org/wiki/Pointers_and_references,Pointers and references,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


In this task, the goal is to demonstrate common operations on pointers and references. These examples show pointer operations on the stack, which can be dangerous and is rarely done. Pointers and references are commonly used along with Memory allocation on the heap.
",#C.23,C#," 
static void Main(string[] args)
{
	int p;
 
	p = 1;
	Console.WriteLine(""Ref Before: "" + p);
	Value(ref p);
	Console.WriteLine(""Ref After : "" + p);
 
	p = 1;
	Console.WriteLine(""Val Before: "" + p);
	Value(p);
	Console.WriteLine(""Val After : "" + p);
 
	Console.ReadLine();
}
 
private static void Value(ref int Value)
{
	Value += 1;
}
private static void Value(int Value)
{
	Value += 1;
}
 ",390,27
26609,http://rosettacode.org/wiki/Poker_hand_analyser,Poker hand analyser,"Task

Create a program to parse a single five card poker hand and rank it according to this list of poker hands.



A poker hand is specified as a space separated list of five playing cards.

Each input card has two characters indicating face and suit.



Example

2d       (two of diamonds).


Faces are:    a, 2, 3, 4, 5, 6, 7, 8, 9, 10, j, q, k

Suits are:    h (hearts),   d (diamonds),   c (clubs),   and   s (spades),   or

alternatively,   the unicode card-suit characters:     ♥ ♦ ♣ ♠ 



Duplicate cards are illegal.

The program should analyze a single hand and produce one of the following outputs:

 straight-flush
 four-of-a-kind
 full-house
 flush
 straight
 three-of-a-kind
 two-pair
 one-pair
 high-card
 invalid



Examples

   2♥ 2♦ 2♣ k♣ q♦:   three-of-a-kind
   2♥ 5♥ 7♦ 8♣ 9♠:   high-card
   a♥ 2♦ 3♣ 4♣ 5♦:   straight
   2♥ 3♥ 2♦ 3♣ 3♦:   full-house
   2♥ 7♥ 2♦ 3♣ 3♦:   two-pair
   2♥ 7♥ 7♦ 7♣ 7♠:   four-of-a-kind 
   10♥ j♥ q♥ k♥ a♥:  straight-flush
   4♥ 4♠ k♠ 5♦ 10♠:  one-pair
   q♣ 10♣ 7♣ 6♣ q♣:  invalid

The programs output for the above examples should be displayed here on this page.



Extra credit

 use the playing card characters introduced with Unicode 6.0 (U+1F0A1 - U+1F0DE).
 allow two jokers
 use the symbol   joker
 duplicates would be allowed (for jokers only)
 five-of-a-kind would then be the highest hand


More extra credit examples

   joker  2♦  2♠  k♠  q♦:     three-of-a-kind
   joker  5♥  7♦  8♠  9♦:     straight
   joker  2♦  3♠  4♠  5♠:     straight
   joker  3♥  2♦  3♠  3♦:     four-of-a-kind
   joker  7♥  2♦  3♠  3♦:     three-of-a-kind
   joker  7♥  7♦  7♠  7♣:     five-of-a-kind
   joker  j♥  q♥  k♥  A♥:     straight-flush
   joker  4♣  k♣  5♦ 10♠:     one-pair
   joker  k♣  7♣  6♣  4♣:     flush
   joker  2♦  joker  4♠  5♠:  straight
   joker  Q♦  joker  A♠ 10♠:  straight
   joker  Q♦  joker  A♦ 10♦:  straight-flush
   joker  2♦  2♠  joker  q♦:  four-of-a-kind



Related tasks

 Playing cards
 Card shuffles
 Deal cards_for_FreeCell
 War Card_Game
 Go Fish

",#C.23,C#,"using System;
using System.Collections.Generic;
using static System.Linq.Enumerable;
 
public static class PokerHandAnalyzer
{
    private enum Hand {
        Invalid, High_Card, One_Pair, Two_Pair, Three_Of_A_Kind, Straight,
        Flush, Full_House, Four_Of_A_Kind, Straight_Flush, Five_Of_A_Kind
    }
 
    private const bool Y = true;
    private const char C = '♣', D = '♦', H = '♥', S = '♠';
    private const int rankMask = 0b11_1111_1111_1111;
    private const int suitMask = 0b1111 << 14;
    private static readonly string[] ranks = { ""a"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9"", ""10"", ""j"", ""q"", ""k"" };
    private static readonly string[] suits = { C + """", D + """", H + """", S + """" };
    private static readonly Card[] deck = (from suit in Range(1, 4) from rank in Range(1, 13) select new Card(rank, suit)).ToArray();
 
    public static void Main() {
        string[] hands = {
            ""2♥ 2♦ 2♣ k♣ q♦"",
            ""2♥ 5♥ 7♦ 8♣ 9♠"",
            ""a♥ 2♦ 3♣ 4♣ 5♦"",
            ""2♥ 3♥ 2♦ 3♣ 3♦"",
            ""2♥ 7♥ 2♦ 3♣ 3♦"",
            ""2♥ 7♥ 7♦ 7♣ 7♠"",
            ""10♥ j♥ q♥ k♥ a♥"",
            ""4♥ 4♠ k♠ 5♦ 10♠"",
            ""q♣ 10♣ 7♣ 6♣ 4♣"",
            ""4♥ 4♣ 4♥ 4♠ 4♦"", //duplicate card
            ""joker 2♦ 2♠ k♠ q♦"",
            ""joker 5♥ 7♦ 8♠ 9♦"",
            ""joker 2♦ 3♠ 4♠ 5♠"",
            ""joker 3♥ 2♦ 3♠ 3♦"",
            ""joker 7♥ 2♦ 3♠ 3♦"",
            ""joker 7♥ 7♦ 7♠ 7♣"",
            ""joker j♥ q♥ k♥ A♥"",
            ""joker 4♣ k♣ 5♦ 10♠"",
            ""joker k♣ 7♣ 6♣ 4♣"",
            ""joker 2♦ joker 4♠ 5♠"",
            ""joker Q♦ joker A♠ 10♠"",
            ""joker Q♦ joker A♦ 10♦"",
            ""joker 2♦ 2♠ joker q♦""
        };
        foreach (var h in hands) {
            Console.WriteLine($""{h}: {Analyze(h).Name()}"");
        }
    }
 
    static string Name(this Hand hand) => string.Join('-', hand.ToString().Split('_')).ToLower();
 
    static List<T> With<T>(this List<T> list, int index, T item) {
        list[index] = item;
        return list;
    }
 
    struct Card : IEquatable<Card>, IComparable<Card>
    {
        public static readonly Card Invalid = new Card(-1, -1);
        public static readonly Card Joker = new Card(0, 0);
 
        public Card(int rank, int suit) {
            (Rank, Suit, Code) = (rank, suit) switch {
                (_, -1) => (-1, -1, -1),
                (-1, _) => (-1, -1, -1),
                (0, _) => (0, 0, 0),
                (1, _) => (rank, suit, (1 << (13 + suit)) | ((1 << 13) | 1)),
                (_, _) => (rank, suit, (1 << (13 + suit)) | (1 << (rank - 1)))
            };
        }
 
        public static implicit operator Card((int rank, int suit) tuple) => new Card(tuple.rank, tuple.suit);
        public int Rank { get; }
        public int Suit { get; }
        public int Code { get; }
 
        public override string ToString() => Rank switch {
            -1 => ""invalid"",
            0 => ""joker"",
            _ => $""{ranks[Rank-1]}{suits[Suit-1]}""
        };
 
        public override int GetHashCode() => Rank << 16 | Suit;
        public bool Equals(Card other) => Rank == other.Rank && Suit == other.Suit;
 
        public int CompareTo(Card other) {
            int c = Rank.CompareTo(other.Rank);
            if (c != 0) return c;
            return Suit.CompareTo(other.Suit);
        }
    }
 
    static Hand Analyze(string hand) {
        var cards = ParseHand(hand);
        if (cards.Count != 5) return Hand.Invalid; //hand must consist of 5 cards
        cards.Sort();
        if (cards[0].Equals(Card.Invalid)) return Hand.Invalid;
        int jokers = cards.LastIndexOf(Card.Joker) + 1;
        if (jokers > 2) return Hand.Invalid; //more than 2 jokers
        if (cards.Skip(jokers).Distinct().Count() + jokers != 5) return Hand.Invalid; //duplicate cards
 
        if (jokers == 2) return (from c0 in deck from c1 in deck select Evaluate(cards.With(0, c0).With(1, c1))).Max();
        if (jokers == 1) return (from c0 in deck select Evaluate(cards.With(0, c0))).Max();
        return Evaluate(cards);
    }
 
    static List<Card> ParseHand(string hand) =>
        hand.Split(default(char[]), StringSplitOptions.RemoveEmptyEntries)
        .Select(card => ParseCard(card.ToLower())).ToList();
 
    static Card ParseCard(string card) => (card.Length, card) switch {
        (5, ""joker"") => Card.Joker,
        (3, _) when card[..2] == ""10"" => (10, ParseSuit(card[2])),
        (2, _) => (ParseRank(card[0]), ParseSuit(card[1])),
        (_, _) => Card.Invalid
    };
 
    static int ParseRank(char rank) => rank switch {
        'a' => 1,
        'j' => 11,
        'q' => 12,
        'k' => 13,
        _ when rank >= '2' && rank <= '9' => rank - '0',
        _ => -1
    };
 
    static int ParseSuit(char suit) => suit switch {
        C => 1, 'c' => 1,
        D => 2, 'd' => 2,
        H => 3, 'h' => 3,
        S => 4, 's' => 4,
        _ => -1
    };
 
    static Hand Evaluate(List<Card> hand) {
        var frequencies = hand.GroupBy(c => c.Rank).Select(g => g.Count()).OrderByDescending(c => c).ToArray();
        (int f0, int f1) = (frequencies[0], frequencies.Length > 1 ? frequencies[1] : 0);
 
        return (IsFlush(), IsStraight(), f0, f1) switch {
            (_, _, 5, _) => Hand.Five_Of_A_Kind,
            (Y, Y, _, _) => Hand.Straight_Flush,
            (_, _, 4, _) => Hand.Four_Of_A_Kind,
            (_, _, 3, 2) => Hand.Full_House,
            (Y, _, _, _) => Hand.Flush,
            (_, Y, _, _) => Hand.Straight,
            (_, _, 3, _) => Hand.Three_Of_A_Kind,
            (_, _, 2, 2) => Hand.Two_Pair,
            (_, _, 2, _) => Hand.One_Pair,
                        _ => Hand.High_Card
        };
 
        bool IsFlush() => hand.Aggregate(suitMask, (r, c) => r & c.Code) > 0;
 
        bool IsStraight() {
            int r = hand.Aggregate(0, (r, c) => r | c.Code) & rankMask;
            for (int i = 0; i < 4; i++) r &= r << 1;
            return r > 0;
        }
    }
 
}",5946,162
26669,http://rosettacode.org/wiki/Polymorphism,Polymorphism,"Task

Create two classes   Point(x,y)   and   Circle(x,y,r)   with a polymorphic function print, accessors for (x,y,r), copy constructor, assignment and destructor and every possible default constructors



",#C.23,C#,"using System;
class Point
{
  protected int x, y;
  public Point() : this(0) {}
  public Point(int x) : this(x,0) {}
  public Point(int x, int y) { this.x = x; this.y = y; }
  public int X { get { return x; } set { x = value; } }
  public int Y { get { return y; } set { y = value; } }
  public virtual void print() { System.Console.WriteLine(""Point""); }
}
 
public class Circle : Point
{
  private int r;
  public Circle(Point p) : this(p,0) { }
  public Circle(Point p, int r) : base(p) { this.r = r; }
  public Circle() : this(0) { }
  public Circle(int x) : this(x,0) { }
  public Circle(int x, int y) : this(x,y,0) { }
  public Circle(int x, int y, int r) : base(x,y) { this.r = r; }
  public int R { get { return r; } set { r = value; } }
  public override void print() { System.Console.WriteLine(""Circle""); }
 
  public static void main(String args[])
  {
    Point p = new Point();
    Point c = new Circle();
    p.print();
    c.print();
  }
}",953,32
26676,http://rosettacode.org/wiki/Power_set,Power set,"A   set   is a collection (container) of certain values,
without any particular order, and no repeated values.

It corresponds with a finite set in mathematics.

A set can be implemented as an associative array (partial mapping)
in which the value of each key-value pair is ignored.

Given a set S, the power set (or powerset) of S, written P(S), or 2S, is the set of all subsets of S.



Task

By using a library or built-in set type, or by defining a set type with necessary operations, write a function with a set S as input that yields the power set 2S of S.



For example, the power set of     {1,2,3,4}     is

 {{}, {1}, {2}, {1,2}, {3}, {1,3}, {2,3}, {1,2,3}, {4}, {1,4}, {2,4}, {1,2,4}, {3,4}, {1,3,4}, {2,3,4}, {1,2,3,4}}.
For a set which contains n elements, the corresponding power set has 2n elements, including the edge cases of empty set.


The power set of the empty set is the set which contains itself (20 = 1):


 





P




{\displaystyle {\mathcal {P}}}

(



∅


{\displaystyle \varnothing }

) = { 



∅


{\displaystyle \varnothing }

 }

And the power set of the set which contains only the empty set, has two subsets, the empty set and the set which contains the empty set (21 = 2):


 





P




{\displaystyle {\mathcal {P}}}

({



∅


{\displaystyle \varnothing }

}) = { 



∅


{\displaystyle \varnothing }

, { 



∅


{\displaystyle \varnothing }

 } }


Extra credit:  Demonstrate that your language supports these last two powersets.



",#C.23,C#," 
public IEnumerable<IEnumerable<T>> GetPowerSet<T>(List<T> list)
{
    return from m in Enumerable.Range(0, 1 << list.Count)
                  select
                      from i in Enumerable.Range(0, list.Count)
                      where (m & (1 << i)) != 0
                      select list[i];
}
 
public void PowerSetofColors()
{
    var colors = new List<KnownColor> { KnownColor.Red, KnownColor.Green, 
        KnownColor.Blue, KnownColor.Yellow };
 
    var result = GetPowerSet(colors);
 
    Console.Write( string.Join( Environment.NewLine, 
        result.Select(subset => 
            string.Join("","", subset.Select(clr => clr.ToString()).ToArray())).ToArray()));
}
 
 ",684,23
26829,http://rosettacode.org/wiki/Population_count,Population count,"Population count

You are encouraged to solve this task according to the task description, using any language you may know.
The   population count   is the number of   1s   (ones)   in the binary representation of a non-negative integer.

Population count   is also known as:

   pop count
   popcount 
   sideways sum
   bit summation 
   Hamming weight 


For example,   5   (which is   101   in binary)   has a population count of   2.


Evil numbers   are non-negative integers that have an   even   population count.

Odious numbers     are  positive integers that have an    odd   population count.



Task

 write a function (or routine) to return the population count of a non-negative integer.
 all computation of the lists below should start with   0   (zero indexed).
 display the   pop count   of the   1st   thirty powers of   3       (30,   31,   32,   33,   34,   ∙∙∙   329).
 display the   1st   thirty     evil     numbers.
 display the   1st   thirty   odious   numbers.
 display each list of integers on one line   (which may or may not include a title),   each set of integers being shown should be properly identified.


See also
 The On-Line Encyclopedia of Integer Sequences:   A000120 population count.
 The On-Line Encyclopedia of Integer Sequences:   A000069 odious numbers.
 The On-Line Encyclopedia of Integer Sequences:   A001969 evil numbers.

",#C.23,C#," 
using System;
using System.Linq;
 
namespace PopulationCount
{
    class Program
    {
        private static int PopulationCount(long n)
        {
            string binaryn = Convert.ToString(n, 2);
            return binaryn.ToCharArray().Where(t => t == '1').Count();
        }
 
        static void Main(string[] args)
        {
            Console.WriteLine(""Population Counts:"");
            Console.Write(""3^n :   "");
 
            int count = 0;
 
            while (count < 30)
            {
                double n = Math.Pow(3f, (double)count);
                int popCount = PopulationCount((long)n);
                Console.Write(string.Format(""{0} "", popCount));
                count++;
            }
 
            Console.WriteLine();
            Console.Write(""Evil:   "");
 
            count = 0;
            int i = 0;
 
            while (count < 30)
            {
                int popCount = PopulationCount(i);
 
                if (popCount % 2 == 0)
                {
                    count++;
                    Console.Write(string.Format(""{0} "", i));
                }
 
                i++;
            }
 
            Console.WriteLine();
            Console.Write(""Odious: "");
 
            count = 0;
            i = 0;
 
            while (count < 30)
            {
                int popCount = PopulationCount(i);
 
                if (popCount % 2 != 0)
                {
                    count++;
                    Console.Write(string.Format(""{0} "", i));
                }
 
                i++;
            }
 
            Console.ReadKey();
        }
    }
}
 ",1616,72
26926,http://rosettacode.org/wiki/Primality_by_trial_division,Primality by trial division,"Task

Write a boolean function that tells whether a given integer is prime.



Remember that   1   and all non-positive numbers are not prime.

Use trial division.

Even numbers greater than   2   may be eliminated right away.

A loop from   3   to   √ n    will suffice,   but other loops are allowed.



Related tasks

   count in factors
   prime decomposition
   AKS test for primes
   factors of an integer
   Sieve of Eratosthenes
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",#C.23,C#,"static bool isPrime(int n)
        {
            if (n <= 1) return false;
            for (int i = 2; i * i <= n; i++)            
                if (n % i == 0) return false;            
            return true;
        }",224,7
27578,http://rosettacode.org/wiki/Play_recorded_sounds,Play recorded sounds,"Load at least two prerecorded sounds, and demonstrate as many of these features as you can:

 playing them individually and simultaneously
 stopping before the end of the sound
 looping (preferably glitch-free)
 setting the volume of each sound
 stereo or 3D positional mixing
 performing other actions when marked times in the sound arrive
Describe:

 The supported audio formats, briefly.
 Whether it is suitable for game sound effects (low-latency start, resource efficiency, supports many simultaneous sounds, etc.)
 Whether it is suitable for playing music (long duration ).
[Note: If it seems to be a good idea, this task may be revised to specify a particular timeline rather than just 'demonstrate these features'.]

Where applicable, please categorize examples primarily by the audio facility used (library/API/program/platform) rather than the language if the language is incidental (e.g. ""Mac OS X CoreAudio"" or ""mplayer"" rather than ""C"" or ""bash"").
",#C.23,C#,"using System;
using System.Threading;
using System.Media;
 
class Program
{
    static void Main(string[] args)
    {
        //load sound file
        SoundPlayer s1 = new SoundPlayer(); //
        s1.SoundLocation = file; // or ""s1 = new SoundPlayer(file)""
 
        //play
        s1.Play();     
 
        //play for 0.1 seconds
        s1.Play();
        Thread.Sleep(100);
        s1.Stop();
 
        //loops
        s1.PlayLooping();
    }
}",449,24
27646,http://rosettacode.org/wiki/Pinstripe/Display,Pinstripe/Display," Sample image
The task is to demonstrate the creation of a series of vertical pinstripes across the entire width of the display.

 in the first quarter the pinstripes should alternate one pixel white, one pixel black = 1 pixel wide vertical pinestripes
 Quarter of the way down the display, we can switch to a wider 2 pixel wide vertical pinstripe pattern, alternating two pixels white, two pixels black. 
 Half way down the display, we switch to 3 pixels wide, 
 for the lower quarter of the display we use 4 pixels.


c.f. Colour_pinstripe/Display
",#C.23,C#," 
using System.Drawing;
 
public class Pinstripe
{
    static void Main(string[] args)
    {
        var pinstripe = MakePinstripeImage(1366, 768);
        pinstripe.Save(""pinstripe.png"");
    }
 
    public static Bitmap MakePinstripeImage(int width, int height)
    {
        var image = new Bitmap(width, height);
        var quarterHeight = height / 4;
 
        for (var y = 0; y < height; y++)
        {
            var stripeWidth = (y / quarterHeight) + 1;
 
            for (var x = 0; x < width; x++)
            {
                var color = ((x / stripeWidth) % 2) == 0 ? Color.White : Color.Black;
                image.SetPixel(x, y, color);
            }
        }
 
        return image;
    }
}
 ",713,31
27783,http://rosettacode.org/wiki/Pierpont_primes,Pierpont primes,"A Pierpont prime is a prime number of the form: 2u3v + 1 for some non-negative integers  u  and  v .



A Pierpont prime of the second kind is a prime number of the form: 2u3v - 1 for some non-negative integers  u  and  v .


The term ""Pierpont primes"" is generally understood to mean the first definition, but will be called ""Pierpont primes of the first kind"" on this page to distinguish them.



Task

 Write a routine (function, procedure, whatever) to find Pierpont primes of the first & second kinds.
 Use the routine to find and display here, on this page, the first 50 Pierpont primes of the first kind.
 Use the routine to find and display here, on this page, the first 50 Pierpont primes of the second kind
 If your language supports large integers, find and display here, on this page, the 250th Pierpont prime of the first kind and the 250th Pierpont prime of the second kind.


See also

 Wikipedia - Pierpont primes
 OEIS:A005109 - Class 1 -, or Pierpont primes
 OEIS:A005105 - Class 1 +, or Pierpont primes of the second kind

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Numerics;
 
namespace PierpontPrimes {
    public static class Helper {
        private static readonly Random rand = new Random();
        private static readonly List<int> primeList = new List<int>() {
              2,   3,   5,   7,  11,  13,  17,  19,  23,  29,  31,  37,  41,  43, 47,
             53,  59,  61,  67,  71,  73,  79,  83,  89,  97, 101, 103, 107, 109, 113,
            127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,
            199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281,
            283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,
            383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463,
            467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571,
            577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659,
            661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761,
            769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863,
            877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977,
        };
 
        public static BigInteger GetRandom(BigInteger min, BigInteger max) {
            var bytes = max.ToByteArray();
            BigInteger r;
 
            do {
                rand.NextBytes(bytes);
                bytes[bytes.Length - 1] &= (byte)0x7F; // force sign bit to positive
                r = new BigInteger(bytes);
            } while (r < min || r >= max);
 
            return r;
        }
 
        //Modified from https://rosettacode.org/wiki/Miller-Rabin_primality_test#Python
        public static bool IsProbablePrime(this BigInteger n) {
            if (n == 0 || n == 1) {
                return false;
            }
 
            bool Check(BigInteger num) {
                foreach (var prime in primeList) {
                    if (num == prime) {
                        return true;
                    }
                    if (num % prime == 0) {
                        return false;
                    }
                    if (prime * prime > num) {
                        return true;
                    }
                }
 
                return true;
            }
 
            if (Check(n)) {
                var large = primeList[primeList.Count - 1];
                if (n <= large) {
                    return true;
                }
            }
 
            var s = 0;
            var d = n - 1;
            while (d.IsEven) {
                d >>= 1;
                s++;
            }
 
            bool TrialComposite(BigInteger a) {
                if (BigInteger.ModPow(a, d, n) == 1) {
                    return false;
                }
                for (int i = 0; i < s; i++) {
                    var t = BigInteger.Pow(2, i);
                    if (BigInteger.ModPow(a, t * d, n) == n - 1) {
                        return false;
                    }
                }
                return true;
            }
 
            for (int i = 0; i < 8; i++) {
                var a = GetRandom(2, n);
                if (TrialComposite(a)) {
                    return false;
                }
            }
            return true;
        }
    }
 
    class Program {
        static List<List<BigInteger>> Pierpont(int n) {
            var p = new List<List<BigInteger>> {
                new List<BigInteger>(),
                new List<BigInteger>()
            };
            for (int i = 0; i < n; i++) {
                p[0].Add(0);
                p[1].Add(0);
            }
            p[0][0] = 2;
 
            var count = 0;
            var count1 = 1;
            var count2 = 0;
            List<BigInteger> s = new List<BigInteger> { 1 };
            var i2 = 0;
            var i3 = 0;
            var k = 1;
            BigInteger n2;
            BigInteger n3;
            BigInteger t;
 
            while (count < n) {
                n2 = s[i2] * 2;
                n3 = s[i3] * 3;
                if (n2 < n3) {
                    t = n2;
                    i2++;
                } else {
                    t = n3;
                    i3++;
                }
                if (t > s[k - 1]) {
                    s.Add(t);
                    k++;
                    t += 1;
                    if (count1 < n && t.IsProbablePrime()) {
                        p[0][count1] = t;
                        count1++;
                    }
                    t -= 2;
                    if (count2 < n && t.IsProbablePrime()) {
                        p[1][count2] = t;
                        count2++;
                    }
                    count = Math.Min(count1, count2);
                }
            }
 
            return p;
        }
 
        static void Main() {
            var p = Pierpont(250);
 
            Console.WriteLine(""First 50 Pierpont primes of the first kind:"");
            for (int i = 0; i < 50; i++) {
                Console.Write(""{0,8} "", p[0][i]);
                if ((i - 9) % 10 == 0) {
                    Console.WriteLine();
                }
            }
            Console.WriteLine();
 
            Console.WriteLine(""First 50 Pierpont primes of the second kind:"");
            for (int i = 0; i < 50; i++) {
                Console.Write(""{0,8} "", p[1][i]);
                if ((i - 9) % 10 == 0) {
                    Console.WriteLine();
                }
            }
            Console.WriteLine();
 
            Console.WriteLine(""250th Pierpont prime of the first kind: {0}"", p[0][249]);
            Console.WriteLine(""250th Pierpont prime of the second kind: {0}"", p[1][249]);
            Console.WriteLine();
        }
    }
}",5809,173
27790,http://rosettacode.org/wiki/Pig_the_dice_game,Pig the dice game,"The   game of Pig   is a multiplayer game played with a single six-sided die.   The
object of the game is to reach   100   points or more.  
Play is taken in turns.   On each person's turn that person has the option of either:

 Rolling the dice:   where a roll of two to six is added to their score for that turn and the player's turn continues as the player is given the same choice again;   or a roll of   1   loses the player's total points   for that turn   and their turn finishes with play passing to the next player.
 Holding:   the player's score for that round is added to their total and becomes safe from the effects of throwing a   1   (one).   The player's turn finishes with play passing to the next player.


Task

Create a program to score for, and simulate dice throws for, a two-person game.



Related task

   Pig the dice game/Player

",#C.23,C#," 
using System;
using System.IO;
 
namespace Pig {
 
	class Roll {
		public int TotalScore{get;set;}
		public int RollScore{get;set;}
		public bool Continue{get;set;}
	}
 
	class Player {
		public String Name{get;set;}
		public int Score {get;set;}
		Random rand;
 
		public Player() {
			Score = 0;
			rand = new Random();
		}
 
		public Roll Roll(int LastScore){
			Roll roll = new Roll();
			roll.RollScore = rand.Next(6) + 1;
 
			if(roll.RollScore == 1){
				roll.TotalScore = 0;
				roll.Continue = false;
				return roll;
			}
 
			roll.TotalScore = LastScore + roll.RollScore;
			roll.Continue = true;
			return roll;
		}
 
		public void FinalizeTurn(Roll roll){
			Score = Score + roll.TotalScore;
		}
	}
 
	public class Game {		
		public static void Main(String[] argv){
			String input = null;
			Player[] players = new Player[2];
 
			// Game loop
			while(true){								
				Console.Write(""Greetings! Would you like to play a game (y/n)?"");
				while(input == null){
					input = Console.ReadLine();
					if(input.ToLowerInvariant() == ""y""){
						players[0] = new Player();
						players[1] = new Player();
						Console.Write(""Player One, what's your name?"");
						input = Console.ReadLine();
						players[0].Name = input;
						Console.Write(""Player Two, what's your name?"");
						input = Console.ReadLine();
						players[1].Name = input;
						Console.WriteLine(players[0].Name + "" and "" + players[1].Name + "", prepare to do battle!"");
					} else if (input.ToLowerInvariant() == ""n""){
						goto Goodbye; /* Not considered harmful */
					} else {
						input = null;
						Console.Write(""I'm sorry, I don't understand. Play a game (y/n)?"");
					}
				}
 
				// Play the game
				int currentPlayer = 0;
				Roll roll = null;
				bool runTurn = true;
				while(runTurn){
					Player p = players[currentPlayer];
					roll = p.Roll( (roll !=null) ? roll.TotalScore : 0 );
					if(roll.Continue){
						if(roll.TotalScore + p.Score > 99){
							Console.WriteLine(""Congratulations, "" + p.Name + ""! You rolled a "" + roll.RollScore + "" for a final score of "" + (roll.TotalScore + p.Score) + ""!"");
							runTurn = false;
						} else {
							Console.Write(p.Name + "": Roll "" + roll.RollScore + ""/Turn "" + roll.TotalScore + ""/Total "" + (roll.TotalScore + p.Score) + "". Roll again (y/n)?"");
							input = Console.ReadLine();
							if(input.ToLowerInvariant() == ""y""){
								// Do nothing
							} else if (input.ToLowerInvariant() == ""n""){
								p.FinalizeTurn(roll);
								currentPlayer = Math.Abs(currentPlayer - 1);			
								Console.WriteLine();
							Console.WriteLine(players[0].Name + "": "" + players[0].Score + ""    "" + players[1].Name + "": "" + players[1].Score);					
								Console.WriteLine(players[currentPlayer].Name + "", your turn begins."");
								roll = null;
							} else {
								input = null;
								Console.Write(""I'm sorry, I don't understand. Play a game (y/n)?"");
							}
						}
					} else {
						Console.WriteLine(p.Name + @"", you rolled a 1 and lost your points for this turn.
Your current score:	"" + p.Score);
						Console.WriteLine();
						Console.WriteLine(players[0].Name + "": "" + players[0].Score + ""    "" + players[1].Name + "": "" + players[1].Score);
						currentPlayer = Math.Abs(currentPlayer - 1);
					}
				}
 
 
				input = null;
			}
			Goodbye:
			Console.WriteLine(""Thanks for playing, and remember: the house ALWAYS wins!"");
			System.Environment.Exit(0);
		}
	}
}
 ",3445,117
27864,http://rosettacode.org/wiki/Pick_random_element,Pick random element,"Demonstrate how to pick a random element from a list.



",#C.23,C#,"using System;
using System.Collections.Generic;
 
class RandomElementPicker {
  static void Main() {
    var list = new List<int>(new[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});
    var rng = new Random();
    var randomElement = list[rng.Next(list.Count)];
    Console.WriteLine(""I picked element {0}"", randomElement);
  }
}",315,11
27880,http://rosettacode.org/wiki/Phrase_reversals,Phrase reversals,"Task

Given a string of space separated words containing the following phrase:

 rosetta code phrase reversal

 Reverse the characters of the string.
 Reverse the characters of each individual word in the string, maintaining original word order within the string.
 Reverse the order of each word of the string, maintaining the order of characters in each word.


Show your output here.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.Linq;
namespace ConsoleApplication
{
    class Program
    {
        static void Main(string[] args)
        {
            //Reverse() is an extension method on IEnumerable<char>.
            //The constructor takes a char[], so we have to call ToArray()
            Func<string, string> reverse = s => new string(s.Reverse().ToArray());
 
            string phrase = ""rosetta code phrase reversal"";
            //Reverse the string
            Console.WriteLine(reverse(phrase));
            //Reverse each individual word in the string, maintaining original string order.
            Console.WriteLine(string.Join("" "", phrase.Split(' ').Select(word => reverse(word))));
            //Reverse the order of each word of the phrase, maintaining the order of characters in each word.
            Console.WriteLine(string.Join("" "", phrase.Split(' ').Reverse()));
        }
    }
}",904,22
27904,http://rosettacode.org/wiki/Playing_cards,Playing cards,"Task

Create a data structure and the associated methods to define and manipulate a deck of   playing cards.

The deck should contain 52 unique cards.

The methods must include the ability to:

   make a new deck
   shuffle (randomize) the deck
   deal from the deck
   print the current contents of a deck 
Each card must have a pip value and a suit value which constitute the unique value of the card.

Related tasks:

 Card shuffles
 Deal cards_for_FreeCell
 War Card_Game
 Poker hand_analyser
 Go Fish

",#C.23,C#,"using System;
using System.Linq;
using System.Collections.Generic;
 
public struct Card
{
    public Card(string rank, string suit) : this()
    {
        Rank = rank;
        Suit = suit;
    }
 
    public string Rank { get; }
    public string Suit { get; }
 
    public override string ToString() => $""{Rank} of {Suit}"";
}
 
public class Deck : IEnumerable<Card>
{
    static readonly string[] ranks = { ""Two"", ""Three"", ""Four"", ""Five"", ""Six"",
        ""Seven"", ""Eight"", ""Nine"", ""Ten"", ""Jack"", ""Queen"", ""King"", ""Ace"" };
    static readonly string[] suits = { ""Clubs"", ""Diamonds"", ""Hearts"", ""Spades"" };
    readonly List<Card> cards;
 
    public Deck() {
        cards = (from suit in suits
                from rank in ranks
                select new Card(rank, suit)).ToList();
    }
 
    public int Count => cards.Count;
 
    public void Shuffle() {
        // using Knuth Shuffle (see at http://rosettacode.org/wiki/Knuth_shuffle)
        var random = new Random();
        for (int i = 0; i < cards.Count; i++) {
            int r = random.Next(i, cards.Count);
            var temp = cards[i];
            cards[i] = cards[r];
            cards[r] = temp;
        }
    }
 
    public Card Deal() {
        int last = cards.Count - 1;
        Card card = cards[last];
        //Removing from the front will shift the other items back 1 spot,
        //so that would be an O(n) operation. Removing from the back is O(1).
        cards.RemoveAt(last);
        return card;
    }
 
    public IEnumerator<Card> GetEnumerator() {
        //Reverse enumeration of the list so that they are returned in the order they would be dealt.
        //LINQ's Reverse() copies the entire list. Let's avoid that.
        for (int i = cards.Count - 1; i >= 0; i--)
            yield return cards[i];
    }
 
    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();
}",1905,62
27951,http://rosettacode.org/wiki/Permutation_test,Permutation test,"Permutation test

You are encouraged to solve this task according to the task description, using any language you may know.
A new medical treatment was tested on a population of 



n
+
m


{\displaystyle n+m}


volunteers, with each volunteer randomly assigned either to a group of




n


{\displaystyle n}

 treatment subjects, or to a group of 



m


{\displaystyle m}

 control subjects.

Members of the treatment group were given the treatment,
and members of the control group were given a placebo.
The effect of the treatment or placebo on each volunteer
was measured and reported in this table.


 Table of experimental results


 Treatment group 
 Control group


 85 
 68


 88 
 41


 75 
 10


 66 
 49


 25 
 16


 29 
 65


 83 
 32


 39 
 92


 97 
 28


 
 98

Write a program that performs a
permutation test to judge
whether the treatment had a significantly stronger effect than the
placebo.

 Do this by considering every possible alternative assignment from the same pool of volunteers to a treatment group of size 



n


{\displaystyle n}

 and a control group of size 



m


{\displaystyle m}

 (i.e., the same group sizes used in the actual experiment but with the group members chosen differently), while assuming that each volunteer's effect remains constant regardless.
 Note that the number of alternatives will be the binomial coefficient 







(



n
+
m

n


)






{\displaystyle {\tbinom {n+m}{n}}}

.
 Compute the mean effect for each group and the difference in means between the groups in every case by subtracting the mean of the control group from the mean of the treatment group.
 Report the percentage of alternative groupings for which the difference in means is less or equal to the actual experimentally observed difference in means, and the percentage for which it is greater.
 Note that they should sum to 100%.


Extremely dissimilar values are evidence of an effect not entirely due
to chance, but your program need not draw any conclusions.

You may assume the experimental data are known at compile time if
that's easier than loading them at run time. Test your solution on the
data given above.



",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace PermutationTest {
    class Program {
        static readonly List<int> DATA = new List<int>{
            85, 88, 75, 66, 25, 29, 83, 39, 97,
            68, 41, 10, 49, 16, 65, 32, 92, 28, 98
        };
 
        static int Pick(int at, int remain, int accu, int treat) {
            if (remain == 0) {
                return (accu > treat) ? 1 : 0;
            }
            return Pick(at - 1, remain - 1, accu + DATA[at - 1], treat)
                + ((at > remain) ? Pick(at - 1, remain, accu, treat) : 0);
        }
 
        static void Main() {
            int treat = 0;
            double total = 1.0;
            for (int i = 0; i <= 8; i++) {
                treat += DATA[i];
            }
            for (int i = 19; i >= 11; i--) {
                total *= i;
            }
            for (int i = 9; i >= 1; --i) {
                total /= i;
            }
            int gt = Pick(19, 9, 0, treat);
            int le = (int) (total - gt);
            Console.WriteLine(""<= {0}%  {1}"", 100.0 * le / total, le);
            Console.WriteLine("" > {0}%  {1}"", 100.0 * gt / total, gt);
        }
    }
}",1179,37
27958,http://rosettacode.org/wiki/Pernicious_numbers,Pernicious numbers,"A   pernicious number   is a positive integer whose   population count   is a prime.

The   population count   is the number of   ones   in the binary representation of a non-negative integer.



Example
22   (which is   10110   in binary)   has a population count of   3,   which is prime,   and therefore

22   is a pernicious number.



Task
 display the first   25   pernicious numbers   (in decimal).
 display all pernicious numbers between   888,888,877   and   888,888,888   (inclusive).
 display each list of integers on one line   (which may or may not include a title).


See also
 Sequence   A052294 pernicious numbers on The On-Line Encyclopedia of Integer Sequences.
 Rosetta Code entry   population count, evil numbers, odious numbers.

",#C.23,C#,"using System;
using System.Linq;
 
namespace PerniciousNumbers
{
    class Program
    {
        public static int PopulationCount(long n)
        {
            int cnt = 0;
            do
            {
                if ((n & 1) != 0) 
                {
                    cnt++;
                }
            } while ((n >>= 1) > 0);
 
            return cnt;
        }
 
         public static bool isPrime(int x)
        {
            if (x <= 2 || (x & 1) == 0)
            {
                return x == 2;
            }
 
            var limit = Math.Sqrt(x);
            for (int i = 3; i <= limit; i += 2)
            {
                if (x % i == 0)
                {
                    return false;
                }
            }
 
            return true;
        }
 
        private static IEnumerable<int> Pernicious(int start, int count, int take)
        {
            return Enumerable.Range(start, count).Where(n => isPrime(PopulationCount(n))).Take(take);
        }
 
        static void Main(string[] args)
        {
            foreach (var n in Pernicious(0, int.MaxValue, 25))
            {
                Console.Write(""{0} "", n);
            }
 
            Console.WriteLine();
 
            foreach (var n in Pernicious(888888877, 11, 11))
            {
                Console.Write(""{0} "", n);
            }
 
            Console.ReadKey();
        }
    }
}",1393,63
27988,http://rosettacode.org/wiki/Pi,Pi,"
Create a program to continually calculate and output the next decimal digit of   



π


{\displaystyle \pi }

   (pi).

The program should continue forever (until it is aborted by the user) calculating and outputting each decimal digit in succession.

The output should be a decimal sequence beginning   3.14159265 ...



Note: this task is about   calculating   pi.   For information on built-in pi constants see Real constants and functions.



Related Task Arithmetic-geometric mean/Calculate Pi
",#C.23,C#,"using System;
using System.Numerics;
 
namespace PiCalc {
    internal class Program {
        private readonly BigInteger FOUR = new BigInteger(4);
        private readonly BigInteger SEVEN = new BigInteger(7);
        private readonly BigInteger TEN = new BigInteger(10);
        private readonly BigInteger THREE = new BigInteger(3);
        private readonly BigInteger TWO = new BigInteger(2);
 
        private BigInteger k = BigInteger.One;
        private BigInteger l = new BigInteger(3);
        private BigInteger n = new BigInteger(3);
        private BigInteger q = BigInteger.One;
        private BigInteger r = BigInteger.Zero;
        private BigInteger t = BigInteger.One;
 
        public void CalcPiDigits() {
            BigInteger nn, nr;
            bool first = true;
            while (true) {
                if ((FOUR*q + r - t).CompareTo(n*t) == -1) {
                    Console.Write(n);
                    if (first) {
                        Console.Write(""."");
                        first = false;
                    }
                    nr = TEN*(r - (n*t));
                    n = TEN*(THREE*q + r)/t - (TEN*n);
                    q *= TEN;
                    r = nr;
                } else {
                    nr = (TWO*q + r)*l;
                    nn = (q*(SEVEN*k) + TWO + r*l)/(t*l);
                    q *= k;
                    t *= l;
                    l += TWO;
                    k += BigInteger.One;
                    n = nn;
                    r = nr;
                }
            }
        }
 
        private static void Main(string[] args) {
            new Program().CalcPiDigits();
        }
    }
}",1668,50
28018,http://rosettacode.org/wiki/Permutations/Derangements,Permutations/Derangements,"A derangement is a permutation of the order of distinct items in which no item appears in its original place.

For example, the only two derangements of the three items (0, 1, 2) are (1, 2, 0), and (2, 0, 1).

The number of derangements of n distinct items is known as the subfactorial of n, sometimes written as !n.
There are various ways to calculate !n.



Task

 Create a named function/method/subroutine/... to generate derangements of the integers 0..n-1, (or 1..n if you prefer). 
 Generate and show all the derangements of 4 integers using the above routine.
 Create a function that calculates the subfactorial of n, !n.
 Print and show a table of the counted number of derangements of n vs. the calculated !n for n from 0..9 inclusive.


Optional stretch goal

   Calculate    !20 


Related tasks

   Anagrams/Deranged anagrams
   Best shuffle
   Left_factorials



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#," 
using System;
class Derangements
{
  static int n = 4;
  static int [] buf = new int [n];
  static bool [] used = new bool [n];
 
  static void Main()
  {
    for (int i = 0; i < n; i++) used [i] = false;
    rec(0);
  }
 
  static void rec(int ind)
  {
    for (int i = 0; i < n; i++)
    {
      if (!used [i] && i != ind)
      {
        used [i] = true;
        buf [ind] = i;
	if (ind + 1 < n) rec(ind + 1);
        else Console.WriteLine(string.Join("","", buf));
	used [i] = false;
      }
    }
  }
}
 ",510,30
28182,http://rosettacode.org/wiki/Perfect_shuffle,Perfect shuffle,"A perfect shuffle (or faro/weave shuffle) means splitting a deck of cards into equal halves, and perfectly interleaving them - so that you end up with the first card from the left half, followed by the first card from the right half, and so on:



 7♠ 8♠ 9♠ J♠ Q♠ K♠→7♠  8♠  9♠
  J♠  Q♠  K♠→7♠ J♠ 8♠ Q♠ 9♠ K♠


When you repeatedly perform perfect shuffles on an even-sized deck of unique cards, it will at some point arrive back at its original order. How many shuffles this takes, depends solely on the number of cards in the deck - for example for a deck of eight cards it takes three shuffles:





 original: 

1
2
3
4
5
6
7
8



 after 1st shuffle: 

1
5
2
6
3
7
4
8



 after 2nd shuffle: 

1
3
5
7
2
4
6
8



 after 3rd shuffle: 

1
2
3
4
5
6
7
8




The Task
 Write a function that can perform a perfect shuffle on an even-sized list of values.
 Call this function repeatedly to count how many shuffles are needed to get a deck back to its original order, for each of the deck sizes listed under ""Test Cases"" below.
 You can use a list of numbers (or anything else that's convenient) to represent a deck; just make sure that all ""cards"" are unique within each deck.
 Print out the resulting shuffle counts, to demonstrate that your program passes the test-cases.
Test Cases


 input (deck size) 
 output (number of shuffles required)


 8 
 3


 24 
 11


 52 
 8


 100 
 30


 1020 
 1018


 1024 
 10


 10000 
 300


",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
public static class PerfectShuffle
{
    static void Main()
    {
        foreach (int input in new [] {8, 24, 52, 100, 1020, 1024, 10000}) {
            int[] numbers = Enumerable.Range(1, input).ToArray();
            Console.WriteLine($""{input} cards: {ShuffleThrough(numbers).Count()}"");
        }
 
        IEnumerable<T[]> ShuffleThrough<T>(T[] original) {
            T[] copy = (T[])original.Clone();
            do {
                yield return copy = Shuffle(copy);
            } while (!Enumerable.SequenceEqual(original, copy));
        }
    }
 
    public static T[] Shuffle<T>(T[] array) {
        if (array.Length % 2 != 0) throw new ArgumentException(""Length must be even."");
        int half = array.Length / 2;
        T[] result = new T[array.Length];
        for (int t = 0, l = 0, r = half; l < half; t+=2, l++, r++) {
            result[t] = array[l];
            result[t+1] = array[r];
        }
        return result;
    }
 
}",1023,33
28200,http://rosettacode.org/wiki/Percentage_difference_between_images,Percentage difference between images,"basic bitmap storage
Useful for comparing two JPEG images saved with a different compression ratios.

You can use these pictures for testing (use the full-size version of each):



50% quality JPEG

100% quality JPEG







link to full size 50% image

link to full size 100% image

The expected difference for these two images is 1.62125%
",#C.23,C#,"using System;
using System.Drawing;
 
class Program
{
    static void Main()
    {
        Bitmap img1 = new Bitmap(""Lenna50.jpg"");
        Bitmap img2 = new Bitmap(""Lenna100.jpg"");
 
        if (img1.Size != img2.Size)
        {
            Console.Error.WriteLine(""Images are of different sizes"");
            return;
        }
 
        float diff = 0;
 
        for (int y = 0; y < img1.Height; y++)
        {
            for (int x = 0; x < img1.Width; x++)
            {
                Color pixel1 = img1.GetPixel(x, y);
                Color pixel2 = img2.GetPixel(x, y);
 
                diff += Math.Abs(pixel1.R - pixel2.R);
                diff += Math.Abs(pixel1.G - pixel2.G);
                diff += Math.Abs(pixel1.B - pixel2.B);
            }
        }
 
        Console.WriteLine(""diff: {0} %"", 100 * (diff / 255) / (img1.Width * img1.Height * 3));
    }
}",876,34
28201,http://rosettacode.org/wiki/Pentomino_tiling,Pentomino tiling,"A pentomino is a polyomino that consists of 5 squares. There are 12 pentomino shapes,
if you don't count rotations and reflections. Most pentominoes can form their own mirror image through
rotation, but some of them have to be flipped over.

        I                                                                        
        I     L       N                                                 Y        
 FF     I     L      NN     PP     TTT              V       W     X    YY      ZZ
FF      I     L      N      PP      T     U U       V      WW    XXX    Y      Z 
 F      I     LL     N      P       T     UUU     VVV     WW      X     Y     ZZ


A Pentomino tiling is an example of an exact cover problem and can take on many forms.
A traditional tiling presents an 8 by 8 grid, where 4 cells are left uncovered. The other cells are covered
by the 12 pentomino shapes, without overlaps, with every shape only used once.

The 4 uncovered cells should be chosen at random. Note that not all configurations are solvable.



Task
Create an 8 by 8 tiling and print the result.



Example
F I I I I I L N
F F F L L L L N
W F - X Z Z N N
W W X X X Z N V
T W W X - Z Z V
T T T P P V V V
T Y - P P U U U
Y Y Y Y P U - U


Related tasks
 Free polyominoes enumeration

",#C.23,C#,"using System;
using System.Linq;
 
namespace PentominoTiling
{
    class Program
    {
        static readonly char[] symbols = ""FILNPTUVWXYZ-"".ToCharArray();
 
        static readonly int nRows = 8;
        static readonly int nCols = 8;
        static readonly int target = 12;
        static readonly int blank = 12;
 
        static int[][] grid = new int[nRows][];
        static bool[] placed = new bool[target];
 
        static void Main(string[] args)
        {
            var rand = new Random();
 
            for (int r = 0; r < nRows; r++)
                grid[r] = Enumerable.Repeat(-1, nCols).ToArray();
 
            for (int i = 0; i < 4; i++)
            {
                int randRow, randCol;
                do
                {
                    randRow = rand.Next(nRows);
                    randCol = rand.Next(nCols);
                } 
                while (grid[randRow][randCol] == blank);
 
                grid[randRow][randCol] = blank;
            }
 
            if (Solve(0, 0))
            {
                PrintResult();
            }
            else
            {
                Console.WriteLine(""no solution"");
            }
 
            Console.ReadKey();
        }
 
        private static void PrintResult()
        {
            foreach (int[] r in grid)
            {
                foreach (int i in r)
                    Console.Write(""{0} "", symbols[i]);
                Console.WriteLine();
            }
        }
 
        private static bool Solve(int pos, int numPlaced)
        {
            if (numPlaced == target)
                return true;
 
            int row = pos / nCols;
            int col = pos % nCols;
 
            if (grid[row][col] != -1)
                return Solve(pos + 1, numPlaced);
 
            for (int i = 0; i < shapes.Length; i++)
            {
                if (!placed[i])
                {
                    foreach (int[] orientation in shapes[i])
                    {
                        if (!TryPlaceOrientation(orientation, row, col, i))
                            continue;
 
                        placed[i] = true;
 
                        if (Solve(pos + 1, numPlaced + 1))
                            return true;
 
                        RemoveOrientation(orientation, row, col);
                        placed[i] = false;
                    }
                }
            }
            return false;
        }
 
        private static void RemoveOrientation(int[] orientation, int row, int col)
        {
            grid[row][col] = -1;
            for (int i = 0; i < orientation.Length; i += 2)
                grid[row + orientation[i]][col + orientation[i + 1]] = -1;
        }
 
        private static bool TryPlaceOrientation(int[] orientation, int row, int col, int shapeIndex)
        {
            for (int i = 0; i < orientation.Length; i += 2)
            {
                int x = col + orientation[i + 1];
                int y = row + orientation[i];
                if (x < 0 || x >= nCols || y < 0 || y >= nRows || grid[y][x] != -1)
                    return false;
            }
 
            grid[row][col] = shapeIndex;
            for (int i = 0; i < orientation.Length; i += 2)
                grid[row + orientation[i]][col + orientation[i + 1]] = shapeIndex;
 
            return true;
        }
 
        // four (x, y) pairs are listed, (0,0) not included
        static readonly int[][] F = {
            new int[] {1, -1, 1, 0, 1, 1, 2, 1}, new int[] {0, 1, 1, -1, 1, 0, 2, 0},
            new int[] {1, 0, 1, 1, 1, 2, 2, 1}, new int[] {1, 0, 1, 1, 2, -1, 2, 0},
            new int[] {1, -2, 1, -1, 1, 0, 2, -1}, new int[] {0, 1, 1, 1, 1, 2, 2, 1},
            new int[] {1, -1, 1, 0, 1, 1, 2, -1}, new int[] {1, -1, 1, 0, 2, 0, 2, 1}};
 
        static readonly int[][] I = {
            new int[] { 0, 1, 0, 2, 0, 3, 0, 4 }, new int[] { 1, 0, 2, 0, 3, 0, 4, 0 } };
 
        static readonly int[][] L = {
            new int[] {1, 0, 1, 1, 1, 2, 1, 3}, new int[] {1, 0, 2, 0, 3, -1, 3, 0},
            new int[] {0, 1, 0, 2, 0, 3, 1, 3}, new int[] {0, 1, 1, 0, 2, 0, 3, 0},
            new int[] {0, 1, 1, 1, 2, 1, 3, 1}, new int[] {0, 1, 0, 2, 0, 3, 1, 0},
            new int[] {1, 0, 2, 0, 3, 0, 3, 1}, new int[] {1, -3, 1, -2, 1, -1, 1, 0}};
 
        static readonly int[][] N = {
            new int[] {0, 1, 1, -2, 1, -1, 1, 0}, new int[] {1, 0, 1, 1, 2, 1, 3, 1},
            new int[]  {0, 1, 0, 2, 1, -1, 1, 0}, new int[] {1, 0, 2, 0, 2, 1, 3, 1},
            new int[] {0, 1, 1, 1, 1, 2, 1, 3}, new int[] {1, 0, 2, -1, 2, 0, 3, -1},
            new int[] {0, 1, 0, 2, 1, 2, 1, 3}, new int[] {1, -1, 1, 0, 2, -1, 3, -1}};
 
        static readonly int[][] P = {
            new int[] {0, 1, 1, 0, 1, 1, 2, 1}, new int[] {0, 1, 0, 2, 1, 0, 1, 1},
            new int[] {1, 0, 1, 1, 2, 0, 2, 1}, new int[] {0, 1, 1, -1, 1, 0, 1, 1},
            new int[] {0, 1, 1, 0, 1, 1, 1, 2}, new int[] {1, -1, 1, 0, 2, -1, 2, 0},
            new int[] {0, 1, 0, 2, 1, 1, 1, 2}, new int[] {0, 1, 1, 0, 1, 1, 2, 0}};
 
        static readonly int[][] T = {
            new int[] {0, 1, 0, 2, 1, 1, 2, 1}, new int[] {1, -2, 1, -1, 1, 0, 2, 0},
            new int[] {1, 0, 2, -1, 2, 0, 2, 1}, new int[] {1, 0, 1, 1, 1, 2, 2, 0}};
 
        static readonly int[][] U = {
            new int[] {0, 1, 0, 2, 1, 0, 1, 2}, new int[] {0, 1, 1, 1, 2, 0, 2, 1},
            new int[]  {0, 2, 1, 0, 1, 1, 1, 2}, new int[] {0, 1, 1, 0, 2, 0, 2, 1}};
 
        static readonly int[][] V = {
            new int[] {1, 0, 2, 0, 2, 1, 2, 2}, new int[] {0, 1, 0, 2, 1, 0, 2, 0},
            new int[] {1, 0, 2, -2, 2, -1, 2, 0}, new int[] {0, 1, 0, 2, 1, 2, 2, 2}};
 
        static readonly int[][] W = {
            new int[] {1, 0, 1, 1, 2, 1, 2, 2}, new int[] {1, -1, 1, 0, 2, -2, 2, -1},
            new int[] {0, 1, 1, 1, 1, 2, 2, 2}, new int[] {0, 1, 1, -1, 1, 0, 2, -1}};
 
        static readonly int[][] X = { new int[] { 1, -1, 1, 0, 1, 1, 2, 0 } };
 
        static readonly int[][] Y = {
            new int[] {1, -2, 1, -1, 1, 0, 1, 1}, new int[] {1, -1, 1, 0, 2, 0, 3, 0},
            new int[] {0, 1, 0, 2, 0, 3, 1, 1}, new int[] {1, 0, 2, 0, 2, 1, 3, 0},
            new int[] {0, 1, 0, 2, 0, 3, 1, 2}, new int[] {1, 0, 1, 1, 2, 0, 3, 0},
            new int[] {1, -1, 1, 0, 1, 1, 1, 2}, new int[] {1, 0, 2, -1, 2, 0, 3, 0}};
 
        static readonly int[][] Z = {
            new int[] {0, 1, 1, 0, 2, -1, 2, 0}, new int[] {1, 0, 1, 1, 1, 2, 2, 2},
            new int[] {0, 1, 1, 1, 2, 1, 2, 2}, new int[] {1, -2, 1, -1, 1, 0, 2, -2}};
 
        static readonly int[][][] shapes = { F, I, L, N, P, T, U, V, W, X, Y, Z };
    }
}",6683,175
28520,http://rosettacode.org/wiki/Perfect_numbers,Perfect numbers,"Write a function which says whether a number is perfect.


A perfect number is a positive integer that is the sum of its proper positive divisors excluding the number itself.

Equivalently, a perfect number is a number that is half the sum of all of its positive divisors (including itself).



Note:   The faster   Lucas-Lehmer test   is used to find primes of the form    2n-1,   all known perfect numbers can be derived from these primes
using the formula    (2n - 1) × 2n - 1.

It is not known if there are any odd perfect numbers (any that exist are larger than 102000).

The number of   known   perfect numbers is   51   (as of December, 2018),   and the largest known perfect number contains  49,724,095  decimal digits.



See also

   Rational Arithmetic
   Perfect numbers on OEIS
   Odd Perfect showing the current status of bounds on odd perfect numbers.

",#C.23,C#,"static void Main(string[] args)
{
	Console.WriteLine(""Perfect numbers from 1 to 33550337:"");
 
	for (int x = 0; x < 33550337; x++)
	{
		if (IsPerfect(x))
			Console.WriteLine(x + "" is perfect."");
	}
 
	Console.ReadLine();
}
 
static bool IsPerfect(int num) 
{
	int sum = 0;
	for (int i = 1; i < num; i++)
	{
		if (num % i == 0)
			sum += i;
	}
 
	return sum == num ;
}",368,24
28561,http://rosettacode.org/wiki/Permutations,Permutations,"Task

Write a program that generates all   permutations   of   n   different objects.   (Practically numerals!)



Related tasks
 
   Find the missing permutation
   Permutations/Derangements



 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",#C.23,C#,"public static class Extension
{
    public static IEnumerable<IEnumerable<T>> Permutations<T>(this IEnumerable<T> values) where T : IComparable<T>
    {
        if (values.Count() == 1)
            return new[] { values };
        return values.SelectMany(v => Permutations(values.Where(x => x.CompareTo(v) != 0)), (v, p) => p.Prepend(v));
    }
}",347,9
29021,http://rosettacode.org/wiki/Pell%27s_equation,Pell's equation,"Pell's equation   (also called the Pell–Fermat equation)   is a   Diophantine equation   of the form:

   x2   -   ny2   =   1  
with integer solutions for   x   and   y,   where   n   is a given non-square positive integer.



Task requirements

   find the smallest solution in positive integers to Pell's equation for   n = {61, 109, 181, 277}.


See also

   Wikipedia entry: Pell's equation.

",#C.23,C#,"using System;
using System.Numerics;
 
static class Program
{
    static void Fun(ref BigInteger a, ref BigInteger b, int c)
    {
        BigInteger t = a; a = b; b = b * c + t;
    }
 
    static void SolvePell(int n, ref BigInteger a, ref BigInteger b)
    {
        int x = (int)Math.Sqrt(n), y = x, z = 1, r = x << 1;
        BigInteger e1 = 1, e2 = 0, f1 = 0, f2 = 1;
        while (true)
        {
            y = r * z - y; z = (n - y * y) / z; r = (x + y) / z;
            Fun(ref e1, ref e2, r); Fun(ref f1, ref f2, r); a = f2; b = e2; Fun(ref b, ref a, x);
            if (a * a - n * b * b == 1) return;
        }
    }
 
    static void Main()
    {
        BigInteger x, y; foreach (int n in new[] { 61, 109, 181, 277 })
        {
            SolvePell(n, ref x, ref y);
            Console.WriteLine(""x^2 - {0,3} * y^2 = 1 for x = {1,27:n0} and y = {2,25:n0}"", n, x, y);
        }
    }
}",903,31
29072,http://rosettacode.org/wiki/Penney%27s_game,Penney's game,"Penney's game is a game where two players bet on being the first to see a particular sequence of heads or tails in consecutive tosses of a fair coin.

It is common to agree on a sequence length of three then one player will openly choose a sequence, for example:

 Heads,  Tails,  Heads, or HTH for short.

The other player on seeing the first players choice will choose his sequence. The coin is tossed and the first player to see his sequence in the sequence of coin tosses wins.



Example

One player might choose the sequence HHT and the other THT.

Successive coin tosses of HTTHT gives the win to the second player as the last three coin tosses are his sequence.



Task
Create a program that tosses the coin, keeps score and plays Penney's game against a human opponent.

 Who chooses and shows their sequence of three should be chosen randomly.
 If going first, the computer should randomly choose its sequence of three.
 If going second, the computer should automatically play the optimum sequence.
 Successive coin tosses should be shown.


Show output of a game where the computer chooses first and a game where the user goes first here on this page.



See also
 The Penney Ante Part 1 (Video).
 The Penney Ante Part 2 (Video).

",#C.23,C#,"using static System.Console;
using static System.Threading.Thread;
using System;
 
public static class PenneysGame
{
    const int pause = 500;
    const int N = 3;
    static Random rng = new Random();
 
    static int Toss() => rng.Next(2);
 
    static string AsString(this int sequence) {
        string s = """";
        for (int b = 0b100; b > 0; b >>= 1) {
            s += (sequence & b) > 0 ? 'T' : 'H';
        }
        return s;
    }
 
    static int UserInput() {
        while (true) {
            switch (ReadKey().Key) {
                case ConsoleKey.Escape: return -1;
                case ConsoleKey.H: return 0;
                case ConsoleKey.T: return 1;
            }
            Console.Write('\b');
        }
    }
 
    public static void Main2() {
        int yourScore = 0, myScore = 0;
        while (true) {
            WriteLine($""Your score: {yourScore}, My score: {myScore}"");
            WriteLine(""Determining who goes first..."");
            Sleep(pause);
            bool youStart = Toss() == 1;
            WriteLine(youStart ? ""You go first."" : ""I go first."");
            int yourSequence = 0, mySequence = 0;
            if (youStart) {
                WriteLine(""Choose your sequence of (H)eads and (T)ails (or press Esc to exit)"");
                int userChoice;
                for (int i = 0; i < N; i++) {
                    if ((userChoice = UserInput()) < 0) return;
                    yourSequence = (yourSequence << 1) + userChoice;
                }
                mySequence = ((~yourSequence << 1) & 0b100) | (yourSequence >> 1);
            } else {
                for (int i = 0; i < N; i++) {
                    mySequence = (mySequence << 1) + Toss();
                }
 
                WriteLine(""I chose "" + mySequence.AsString());
                do {
                    WriteLine(""Choose your sequence of (H)eads and (T)ails (or press Esc to exit)"");
                    int choice;
                    yourSequence = 0;
                    for (int i = 0; i < N; i++) {
                        if ((choice = UserInput()) < 0) return;
                        yourSequence = (yourSequence << 1) + choice;
                    }
                    if (yourSequence == mySequence) {
                        WriteLine();
                        WriteLine(""You cannot choose the same sequence."");
                    }
                } while (yourSequence == mySequence);
            }
 
            WriteLine();
            WriteLine($""Your sequence: {yourSequence.AsString()}, My sequence: {mySequence.AsString()}"");
            WriteLine(""Tossing..."");
            int sequence = 0;
            for (int i = 0; i < N; i++) {
                Sleep(pause);
                int toss = Toss();
                sequence = (sequence << 1) + toss;
                Write(toss > 0 ? 'T' : 'H');
            }
            while (true) {
                if (sequence == yourSequence) {
                    WriteLine();
                    WriteLine(""You win!"");
                    yourScore++;
                    break;
                } else if (sequence == mySequence) {
                    WriteLine();
                    WriteLine(""I win!"");
                    myScore++;
                    break;
                }
                Sleep(pause);
                int toss = Toss();
                sequence = ((sequence << 1) + toss) & 0b111;
                Write(toss > 0 ? 'T' : 'H');
            }
            WriteLine(""Press a key."");
            ReadKey();
            Clear();
        }
    }
 
}
 ",3571,104
29073,http://rosettacode.org/wiki/Pathological_floating_point_problems,Pathological floating point problems,"Most programmers are familiar with the inexactness of floating point calculations in a binary processor.

The classic example being:

0.1 + 0.2 =  0.30000000000000004

In many situations the amount of error in such calculations is very small and can be overlooked or eliminated with rounding.

There are pathological problems however, where seemingly simple, straight-forward calculations are extremely sensitive to even tiny amounts of imprecision.

This task's purpose is to show how your language deals with such classes of problems.


A sequence that seems to converge to a wrong limit.

Consider the sequence:

  v1 = 2 
  v2 = -4 
  vn = 111   -   1130   /   vn-1   +   3000  /   (vn-1 * vn-2) 


As   n   grows larger, the series should converge to   6   but small amounts of error will cause it to approach   100.



Task 1

Display the values of the sequence where   n =   3, 4, 5, 6, 7, 8, 20, 30, 50 & 100   to at least 16 decimal places.

    n = 3     18.5
    n = 4      9.378378
    n = 5      7.801153
    n = 6      7.154414
    n = 7      6.806785
    n = 8      6.5926328
    n = 20     6.0435521101892689
    n = 30     6.006786093031205758530554
    n = 50     6.0001758466271871889456140207471954695237
    n = 100    6.000000019319477929104086803403585715024350675436952458072592750856521767230266



Task 2

The Chaotic Bank Society   is offering a new investment account to their customers.

You first deposit   $e - 1   where   e   is   2.7182818...   the base of natural logarithms.

After each year, your account balance will be multiplied by the number of years that have passed, and $1 in service charges will be removed.

So ...

 after 1 year, your balance will be multiplied by 1 and $1 will be removed for service charges.
 after 2 years your balance will be doubled and $1 removed.
 after 3 years your balance will be tripled and $1 removed.
  ... 
 after 10 years, multiplied by 10 and $1 removed, and so on. 


What will your balance be after   25   years?

   Starting balance: $e-1
   Balance = (Balance * year) - 1 for 25 years
   Balance after 25 years: $0.0399387296732302



Task 3, extra credit

Siegfried Rump's example.   Consider the following function, designed by Siegfried Rump in 1988.

  f(a,b) = 333.75b6 + a2( 11a2b2 - b6 - 121b4 - 2 ) + 5.5b8 + a/(2b) 
  compute    f(a,b)    where    a=77617.0    and    b=33096.0 
  f(77617.0, 33096.0)   =   -0.827396059946821 


Demonstrate how to solve at least one of the first two problems, or both, and the third if you're feeling particularly jaunty.



See also;
   Floating-Point Arithmetic   Section 1.3.2 Difficult problems.

",#C.23,C#,"#define USE_BIGRATIONAL
#define BANDED_ROWS
#define INCREASED_LIMITS
 
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Numerics;
using Numerics;
 
using static Common;
using static Task1;
using static Task2;
using static Task3;
 
#if !USE_BIGRATIONAL
// Mock structure to make test code work.
struct BigRational
{
    public override string ToString() => ""NOT USING BIGRATIONAL"";
    public static explicit operator decimal(BigRational value) => -1;
}
#endif
 
static class Common
{
    public const string FMT_STR = ""{0,4}   {1,-15:G9}   {2,-24:G17}   {3,-32}   {4,-32}"";
    public static string Headings { get; } =
        string.Format(
            CultureInfo.InvariantCulture,
            FMT_STR,
            new[] { ""N"", ""Single"", ""Double"", ""Decimal"", ""BigRational (rounded as Decimal)"" });
 
    [Conditional(""BANDED_ROWS"")]
    static void SetConsoleFormat(int n)
    {
        if (n % 2 == 0)
        {
            Console.BackgroundColor = ConsoleColor.Black;
            Console.ForegroundColor = ConsoleColor.White;
        }
        else
        {
            Console.BackgroundColor = ConsoleColor.White;
            Console.ForegroundColor = ConsoleColor.Black;
        }
    }
 
    public static string FormatOutput(int n, (float sn, double db, decimal dm, BigRational br) x)
    {
        SetConsoleFormat(n);
        return string.Format(CultureInfo.CurrentCulture, FMT_STR, n, x.sn, x.db, x.dm, (decimal)x.br);
    }
 
    static void Main()
    {
        WrongConvergence();
 
        Console.WriteLine();
        ChaoticBankSociety();
 
        Console.WriteLine();
        SiegfriedRump();
 
        SetConsoleFormat(0);
    }
}",1739,69
29135,http://rosettacode.org/wiki/Peaceful_chess_queen_armies,Peaceful chess queen armies,"In chess, a queen attacks positions from where it is, in straight lines up-down and left-right as well as on both its diagonals. It attacks only pieces not of its own colour.






⇖
⇑
⇗



⇐
⇐
♛
⇒
⇒



⇙
⇓
⇘



⇙

⇓

⇘




⇓






The goal of Peaceful chess queen armies is to arrange m black queens and m white queens on an n-by-n square grid, (the board), so that no queen attacks another of a different colour.



Task

 Create a routine to represent two-colour queens on a 2-D board. (Alternating black/white background colours, Unicode chess pieces and other embellishments are not necessary, but may be used at your discretion).
 Create a routine to generate at least one solution to placing m equal numbers of black and white queens on an n square board.
 Display here results for the m=4, n=5 case.


References

 Peaceably Coexisting Armies of Queens (Pdf) by Robert A. Bosch. Optima, the Mathematical Programming Socity newsletter, issue 62.
 A250000 OEIS

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace PeacefulChessQueenArmies {
    using Position = Tuple<int, int>;
 
    enum Piece {
        Empty,
        Black,
        White
    }
 
    class Program {
        static bool IsAttacking(Position queen, Position pos) {
            return queen.Item1 == pos.Item1
                || queen.Item2 == pos.Item2
                || Math.Abs(queen.Item1 - pos.Item1) == Math.Abs(queen.Item2 - pos.Item2);
        }
 
        static bool Place(int m, int n, List<Position> pBlackQueens, List<Position> pWhiteQueens) {
            if (m == 0) {
                return true;
            }
            bool placingBlack = true;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    var pos = new Position(i, j);
                    foreach (var queen in pBlackQueens) {
                        if (queen.Equals(pos) || !placingBlack && IsAttacking(queen, pos)) {
                            goto inner;
                        }
                    }
                    foreach (var queen in pWhiteQueens) {
                        if (queen.Equals(pos) || placingBlack && IsAttacking(queen, pos)) {
                            goto inner;
                        }
                    }
                    if (placingBlack) {
                        pBlackQueens.Add(pos);
                        placingBlack = false;
                    } else {
                        pWhiteQueens.Add(pos);
                        if (Place(m - 1, n, pBlackQueens, pWhiteQueens)) {
                            return true;
                        }
                        pBlackQueens.RemoveAt(pBlackQueens.Count - 1);
                        pWhiteQueens.RemoveAt(pWhiteQueens.Count - 1);
                        placingBlack = true;
                    }
                inner: { }
                }
            }
            if (!placingBlack) {
                pBlackQueens.RemoveAt(pBlackQueens.Count - 1);
            }
            return false;
        }
 
        static void PrintBoard(int n, List<Position> blackQueens, List<Position> whiteQueens) {
            var board = new Piece[n * n];
 
            foreach (var queen in blackQueens) {
                board[queen.Item1 * n + queen.Item2] = Piece.Black;
            }
            foreach (var queen in whiteQueens) {
                board[queen.Item1 * n + queen.Item2] = Piece.White;
            }
 
            for (int i = 0; i < board.Length; i++) {
                if (i != 0 && i % n == 0) {
                    Console.WriteLine();
                }
                switch (board[i]) {
                    case Piece.Black:
                        Console.Write(""B "");
                        break;
                    case Piece.White:
                        Console.Write(""W "");
                        break;
                    case Piece.Empty:
                        int j = i / n;
                        int k = i - j * n;
                        if (j % 2 == k % 2) {
                            Console.Write(""  "");
                        } else {
                            Console.Write(""# "");
                        }
                        break;
                }
            }
 
            Console.WriteLine(""\n"");
        }
 
        static void Main() {
            var nms = new int[,] {
                {2, 1}, {3, 1}, {3, 2}, {4, 1}, {4, 2}, {4, 3},
                {5, 1}, {5, 2}, {5, 3}, {5, 4}, {5, 5},
                {6, 1}, {6, 2}, {6, 3}, {6, 4}, {6, 5}, {6, 6},
                {7, 1}, {7, 2}, {7, 3}, {7, 4}, {7, 5}, {7, 6}, {7, 7},
            };
            for (int i = 0; i < nms.GetLength(0); i++) {
                Console.WriteLine(""{0} black and {0} white queens on a {1} x {1} board:"", nms[i, 1], nms[i, 0]);
                List<Position> blackQueens = new List<Position>();
                List<Position> whiteQueens = new List<Position>();
                if (Place(nms[i, 1], nms[i, 0], blackQueens, whiteQueens)) {
                    PrintBoard(nms[i, 0], blackQueens, whiteQueens);
                } else {
                    Console.WriteLine(""No solution exists.\n"");
                }
            }
        }
    }
}",4244,114
29148,http://rosettacode.org/wiki/Password_generator,Password generator,"Create a password generation program which will generate passwords containing random ASCII characters from the following groups:

         lower-case letters:  a ──► z
         upper-case letters:  A ──► Z
                     digits:  0 ──► 9
 other printable characters:  !""#$%&'()*+,-./:;<=>?@[]^_{|}~ 
 (the above character list excludes white-space, backslash and grave) 



The generated password(s) must include   at least one   (of each of the four groups):

   lower-case letter, 
   upper-case letter,
   digit  (numeral),   and 
   one  ""other""  character. 



The user must be able to specify the password length and the number of passwords to generate.

The passwords should be displayed or written to a file, one per line.

The randomness should be from a system source or library.

The program should implement a help option or button which should describe the program and options when invoked.

You may also allow the user to specify a seed value, and give the option of excluding visually similar characters.

For example:            Il1     O0     5S     2Z            where the characters are:

   capital eye, lowercase ell, the digit one
   capital oh, the digit zero 
   the digit five, capital ess
   the digit two, capital zee

",#C.23,C#,"using System;
using System.Linq;
 
class Program
{
    const string Lower = ""abcdefghijklmnopqrstuvwxyz"";
    const string Upper = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    const string Digits = ""0123456789"";
    const string Symbols = ""!\""#$%&'()*+,-./:;<=>?@[]^_{|}~"";
    static readonly string[] Full = {Lower, Upper, Digits, Symbols, Lower + Upper + Digits + Symbols};
 
    const string Similar = ""Il1O05S2Z"";
    static readonly string[] Excluded = Full.Select(x => new string(x.Except(Similar).ToArray())).ToArray();
 
    static Random _rng = new Random();
    static string[] _symbolSet = Full;
 
    static void Main(string[] args)
    {
        int length = 12, count = 1;
        try
        {
            foreach (var x in args.Select(arg => arg.Split(':')))
            {
                switch (x[0])
                {
                    case ""-l"": length = int.Parse(x[1]); break;
                    case ""-c"": count = int.Parse(x[1]); break;
                    case ""-s"": _rng = new Random(x[1].GetHashCode()); break;
                    case ""-x"": _symbolSet = bool.Parse(x[1]) ? Excluded : Full; break;
                    default: throw new FormatException(""Could not parse arguments"");
                }
            }
        }
        catch { ShowUsage(); return; }
        try
        {
            for (int i = 0; i < count; i++)
                Console.WriteLine(GeneratePass(length));
        }
        catch (Exception ex) { Console.WriteLine(""Error: "" + ex.Message); }
    }
 
    static void ShowUsage()
    {
        Console.WriteLine(""Usage: PASSGEN [-l:length] [-c:count] [-s:seed] [-x:(true|false)]"");
        Console.WriteLine(""\t-l: the length of the generated passwords"");
        Console.WriteLine(""\t-c: the number of passwords to generate"");
        Console.WriteLine(""\t-s: seed for the random number generator"");
        Console.WriteLine(""\t-x: exclude similar characters: "" + Similar);
        Console.WriteLine(""Example: PASSGEN -l:10 -c:5 -s:\""Sample Seed\"" -x:true"");
    }
 
    static string GeneratePass(int length)
    {
        var minLength = _symbolSet.Length - 1;
        if(length < minLength)
            throw new Exception(""password length must be "" + minLength + "" or greater"");
 
        int[] usesRemaining = Enumerable.Repeat(1, _symbolSet.Length).ToArray();
        usesRemaining[minLength] = length - minLength;
        var password = new char[length];
        for (int ii = 0; ii < length; ii++)
        {
            int set = _rng.Next(0, _symbolSet.Length);
            if (usesRemaining[set] > 0)
            {
                usesRemaining[set]--;
                password[ii] = _symbolSet[set][_rng.Next(0, _symbolSet[set].Length)];
            }
            else ii--;
        }
        return new string(password);
    }
}",2791,75
29179,http://rosettacode.org/wiki/Pascal%27s_triangle/Puzzle,Pascal's triangle/Puzzle,"This puzzle involves a Pascals Triangle, also known as a Pyramid of Numbers.

           [ 151]
          [  ][  ]
        [40][  ][  ]
      [  ][  ][  ][  ]
    [ X][11][ Y][ 4][ Z]

Each brick of the pyramid is the sum of the two bricks situated below it.

Of the three missing numbers at the base of the pyramid,
the middle one is the sum of the other two (that is, Y = X + Z).



Task

Write a program to find a solution to this puzzle.



",#C.23,C#," 
using System;
 
namespace Pyramid_of_Numbers
{
        class Program
	{
		public static void Main(string[] args)
		{
			// Set console properties
			Console.Title = "" Pyramid of Numbers  /  Pascal's triangle Puzzle"";
			Console.SetBufferSize(80,1000);
			Console.SetWindowSize(80,60);
			Console.ForegroundColor = ConsoleColor.Green;
 
 
			// Main Program Loop
			ConsoleKeyInfo k = new ConsoleKeyInfo('Y', ConsoleKey.Y,true,true,true);
			while (k.Key == ConsoleKey.Y)
			{
				Console.Clear();
 
				Console.WriteLine(""----------------------------------------------"");
				Console.WriteLine("" Pyramid of Numbers / Pascal's triangle Puzzle"");
				Console.WriteLine(""----------------------------------------------"");
				Console.WriteLine();
 
 
 
				//
				// Declare new Pyramid array
				//
				int r = 5;// Number of rows
				int [,] Pyramid = new int[r,r];
 
				// Set initial Pyramid values
				for (int i = 0; i < r; i++)
				{
					for(int j = 0; j < r; j++)
					{
						Pyramid[i,j] = 0;
					}
				}
				// Show info on created array
				Console.WriteLine("" Pyramid has "" + r + "" rows"");
				Console.WriteLine(""--------------------------------------------"");
 
				// Enter Pyramid values
				for(int i = 0; i <= r-1; i++)
				{
					Console.WriteLine("" Enter "" + (i+1).ToString() + "". row values:"");
					Console.WriteLine(""--------------------------------------------"");
 
					for(int j = 0; j < i+1; j++)
					{
						Console.Write("" "" + (j+1).ToString() + "". value = "");
						int v = int.Parse(Console.ReadLine());
 
						Pyramid[i,j] = v;
					}
					Console.WriteLine(""--------------------------------------------"");
				}
 
				//
				// Show initial Pyramid values
				//
				Console.WriteLine();
				Console.WriteLine("" Initial Pyramid Values "");
				Console.WriteLine();
 
				// Show Pyramid values
				for(int i = 0; i <= r-1; i++)
				{
					for(int j = 0; j < i+1; j++)
					{
						Console.Write(""{0,4}"",Pyramid[i,j]);
					}
					Console.WriteLine();
				}
				Console.WriteLine(""--------------------------------------------"");
 
				// Find solution
				Solve_Pyramid(Pyramid);
 
				Console.WriteLine();
				Console.Write("" Start new calculation <Y/N>  . . . "");
				k = Console.ReadKey(true);
			}
		}
 
                //
                // Solve Function
                //
		public static void Solve_Pyramid(int [,] Pyramid)
		{
			int r = 5; // Number of rows
 
			// Calculate Y
			int a = Pyramid[r-1,1];
			int b = Pyramid[r-1,3];
			int c = Pyramid[0,0];
 
			int y =  (c - (4*a) - (4*b))/7;
			Pyramid[r-1,2] = y;
 
 
			// Create copy of Pyramid
			int [,] Pyramid_Copy = new int[r,r];
			Array.Copy(Pyramid,Pyramid_Copy,r*r);
 
			int n = 0; // solution counter
			for(int x = 0; x < y + 1; x++)
			{
				for(int z = 0; z < y + 1; z++)
				{
					if( (x+z) == y)
					{
						Pyramid[r-1,0]   = x;
						Pyramid[r-1,r-1] = z;
 
						// Recalculate Pyramid values
						for(int i = r-1; i > 0; i--)
						{
							for(int j = 0; j < i; j++)
							{
								Pyramid[i-1,j] = Pyramid[i,j]+Pyramid[i,j+1];
							}
						}
 
 
						// Compare Pyramid values
						bool solved = true;
						for(int i = 0; i < r-1; i++)
						{
							for(int j = 0; j < i+1; j++)
							{
								if(Pyramid_Copy[i,j]>0)
								{
									if(Pyramid[i,j] != Pyramid_Copy[i,j])
									{
										solved = false;
										i = r;
										break;
									}
								}
							}
						}
 
						if(solved)
						{
							n++;
							Console.WriteLine();
							Console.WriteLine("" Solved Pyramid Values no."" + n);
							Console.WriteLine();
 
							// Show Pyramid values
							for(int i = 0; i <= r-1; i++)
							{
								for(int j = 0; j < i+1; j++)
								{
									Console.Write(""{0,4}"",Pyramid[i,j]);
								}
								Console.WriteLine();
							}
							Console.WriteLine();
							Console.WriteLine("" X = "" + Pyramid[r-1,0] + ""   "" +
							                  "" Y = "" + Pyramid[r-1,2] + ""   "" +
							                  "" Z = "" + Pyramid[r-1,4]);
							Console.WriteLine();
							Console.WriteLine(""--------------------------------------------"");
						}
 
						Array.Copy(Pyramid_Copy,Pyramid,r*r);
					}
				}
			}
 
			if(n == 0)
			{
				Console.WriteLine();
				Console.WriteLine("" Pyramid has no solution "");
				Console.WriteLine();
			}
		}
 
	}
}
 ",4306,188
29189,http://rosettacode.org/wiki/Partition_an_integer_x_into_n_primes,Partition an integer x into n primes,"Task

Partition a positive integer   X   into   N   distinct primes.



Or, to put it in another way:

Find   N   unique primes such that they add up to   X.



Show in the output section the sum   X   and the   N   primes in ascending order separated by plus (+) signs:

     •    partition  99809  with   1 prime.
     •    partition    18   with   2 primes.
     •    partition    19   with   3 primes.
     •    partition    20   with   4 primes.
     •    partition   2017  with  24 primes.
     •    partition  22699  with   1,  2,  3,  and  4  primes.
     •    partition  40355  with   3 primes.

The output could/should be shown in a format such as:

    Partitioned  19  with  3  primes:  3+5+11

   Use any spacing that may be appropriate for the display.
   You need not validate the input(s).
   Use the lowest primes possible;   use  18 = 5+13,   not   18 = 7+11.
   You only need to show one solution.
This task is similar to factoring an integer.



Related tasks

   Count in factors
   Prime decomposition
   Factors of an integer
   Sieve of Eratosthenes
   Primality by trial division
   Factors of a Mersenne number
   Factors of a Mersenne number
   Sequence of primes by trial division

",#C.23,C#,"using System;
using System.Collections;
using System.Collections.Generic;
using static System.Linq.Enumerable;
 
public static class Rosetta
{
    static void Main()
    {
        foreach ((int x, int n) in new [] {
            (99809, 1),
            (18, 2),
            (19, 3),
            (20, 4),
            (2017, 24),
            (22699, 1),
            (22699, 2),
            (22699, 3),
            (22699, 4),
            (40355, 3)
        }) {
            Console.WriteLine(Partition(x, n));
        }
    }
 
    public static string Partition(int x, int n) {
        if (x < 1 || n < 1) throw new ArgumentOutOfRangeException(""Parameters must be positive."");
        string header = $""{x} with {n} {(n == 1 ? ""prime"" : ""primes"")}: "";
        int[] primes = SievePrimes(x).ToArray();
        if (primes.Length < n) return header + ""not enough primes"";
        int[] solution = CombinationsOf(n, primes).FirstOrDefault(c => c.Sum() == x);
        return header + (solution == null ? ""not possible"" : string.Join(""+"", solution);
    }
 
    static IEnumerable<int> SievePrimes(int bound) {
        if (bound < 2) yield break;
        yield return 2;
 
        BitArray composite = new BitArray((bound - 1) / 2);
        int limit = ((int)(Math.Sqrt(bound)) - 1) / 2;
        for (int i = 0; i < limit; i++) {
            if (composite[i]) continue;
            int prime = 2 * i + 3;
            yield return prime;
            for (int j = (prime * prime - 2) / 2; j < composite.Count; j += prime) composite[j] = true;
        }
        for (int i = limit; i < composite.Count; i++) {
            if (!composite[i]) yield return 2 * i + 3;
        }
    }
 
    static IEnumerable<int[]> CombinationsOf(int count, int[] input) {
        T[] result = new T[count];
        foreach (int[] indices in Combinations(input.Length, count)) {
            for (int i = 0; i < count; i++) result[i] = input[indices[i]];
            yield return result;
        }
    }
 
    static IEnumerable<int[]> Combinations(int n, int k) {
        var result = new int[k];
        var stack = new Stack<int>();
        stack.Push(0);
        while (stack.Count > 0) {
            int index = stack.Count - 1;
            int value = stack.Pop();
            while (value < n) {
                result[index++] = value++;
                stack.Push(value);
                if (index == k) {
                    yield return result;
                    break;
                }
            }
        }
    }
 
}",2503,78
29298,http://rosettacode.org/wiki/Partial_function_application,Partial function application,"Partial function application   is the ability to take a function of many
parameters and apply arguments to some of the parameters to create a new
function that needs only the application of the remaining arguments to
produce the equivalent of applying all arguments to the original function.

E.g:

 Given values v1, v2
 Given f(param1, param2)
 Then partial(f, param1=v1) returns f'(param2)
 And f(param1=v1, param2=v2) == f'(param2=v2) (for any value v2)


Note that in the partial application of a parameter, (in the above case param1), other parameters are not explicitly mentioned. This is a recurring feature of partial function application.



Task 
 Create a function fs( f, s ) that takes a function, f( n ), of one value and a sequence of values s.
 Function fs should return an ordered sequence of the result of applying function f to every value of s in turn.
 Create function f1 that takes a value and returns it multiplied by 2.
 Create function f2 that takes a value and returns it squared.
 Partially apply f1 to fs to form function fsf1( s )
 Partially apply f2 to fs to form function fsf2( s )
 Test fsf1 and fsf2 by evaluating them with s being the sequence of integers from 0 to 3 inclusive and then the sequence of even integers from 2 to 8 inclusive.


Notes
 In partially applying the functions f1 or f2 to fs, there should be no explicit mention of any other parameters to fs, although introspection of fs within the partial applicator to find its parameters is allowed.
 This task is more about how results are generated rather than just getting results.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
class PartialFunctionApplication
{
    static Func<T1, TResult> PartiallyApply<T1, T2, TResult>(Func<T1, T2, TResult> function, T2 argument2)
    {
        return argument1 => function(argument1, argument2);
    }
 
    static void Main()
    {
        var fs = (Func<IEnumerable<int>, Func<int, int>, IEnumerable<int>>)Enumerable.Select;
        var f1 = (Func<int, int>)(n => n * 2);
        var f2 = (Func<int, int>)(n => n * n);
        var fsf1 = PartiallyApply(fs, f1);
        var fsf2 = PartiallyApply(fs, f2);
 
        var s = new[] { 0, 1, 2, 3 };
        Console.WriteLine(string.Join("", "", fsf1(s)));
        Console.WriteLine(string.Join("", "", fsf2(s)));
 
        s = new[] { 2, 4, 6, 8 };
        Console.WriteLine(string.Join("", "", fsf1(s)));
        Console.WriteLine(string.Join("", "", fsf2(s)));
    }
}",891,28
29315,http://rosettacode.org/wiki/Parametric_polymorphism,Parametric polymorphism,"Parametric Polymorphism
type variables


Task

Write a small example for a type declaration that is parametric over another type, together with a short bit of code (and its type signature) that uses it.



A good example is a container type, let's say a binary tree, together with some function that traverses the tree, say, a map-function that operates on every element of the tree.

This language feature only applies to statically-typed languages.



",#C.23,C#,"using System;
 
class BinaryTree<T>
{
    public T value;
    public BinaryTree<T> left;
    public BinaryTree<T> right;
 
    public BinaryTree(T value)
    {
        this.value = value;
    }
 
    public BinaryTree<U> Map<U>(Func<T, U> f)
    {
        BinaryTree<U> tree = new BinaryTree<U>(f(this.value));
        if (this.left != null)
        {
            tree.left = this.left.Map(f);
        }
        if (this.right != null)
        {
            tree.right = this.right.Map(f);
        }
        return tree;
    }
}",528,27
29380,http://rosettacode.org/wiki/Parsing/Shunting-yard_algorithm,Parsing/Shunting-yard algorithm,"Task

Given the operator characteristics and input from the Shunting-yard algorithm page and tables, use the algorithm to show the changes in the operator stack and RPN output
as each individual token is processed.

 Assume an input of a correct, space separated, string of tokens representing an infix expression
 Generate a space separated output string representing the RPN
 Test with the input string:
  3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3  
 print and display the output here.
 Operator precedence is given in this table:


 operator 
 precedence 
 associativity 
 operation


  ^  
 4 
 right 
 exponentiation


  *  
 3 
 left 
 multiplication


  /  
 3 
 left 
 division


  +  
 2 
 left 
 addition


  -  
 2 
 left 
 subtraction



Extra credit
Add extra text explaining the actions and an optional comment for the action on receipt of each token.



Note
The handling of functions and arguments is not required.



See also

 Parsing/RPN calculator algorithm for a method of calculating a final value from this output RPN expression.
 Parsing/RPN to infix conversion.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
public class Program
{
    public static void Main() {
        string infix = ""3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3"";
        Console.WriteLine(infix.ToPostfix());
    }
}
 
public static class ShuntingYard
{
    private static readonly Dictionary<string, (string symbol, int precedence, bool rightAssociative)> operators
        = new (string symbol, int precedence, bool rightAssociative) [] {
            (""^"", 4, true),
            (""*"", 3, false),
            (""/"", 3, false),
            (""+"", 2, false),
            (""-"", 2, false)
    }.ToDictionary(op => op.symbol);
 
    public static string ToPostfix(this string infix) {
        string[] tokens = infix.Split(' ');
        var stack = new Stack<string>();
        var output = new List<string>();
        foreach (string token in tokens) {
            if (int.TryParse(token, out _)) {
                output.Add(token);
                Print(token);
            } else if (operators.TryGetValue(token, out var op1)) {
                while (stack.Count > 0 && operators.TryGetValue(stack.Peek(), out var op2)) {
                    int c = op1.precedence.CompareTo(op2.precedence);
                    if (c < 0 || !op1.rightAssociative && c <= 0) {
                        output.Add(stack.Pop());
                    } else {
                        break;
                    }
                }
                stack.Push(token);
                Print(token);
            } else if (token == ""("") {
                stack.Push(token);
                Print(token);
            } else if (token == "")"") {
                string top = """";
                while (stack.Count > 0 && (top = stack.Pop()) != ""("") {
                    output.Add(top);
                }
                if (top != ""("") throw new ArgumentException(""No matching left parenthesis."");
                Print(token);
            }
        }
        while (stack.Count > 0) {
            var top = stack.Pop();
            if (!operators.ContainsKey(top)) throw new ArgumentException(""No matching right parenthesis."");
            output.Add(top);
        }
        Print(""pop"");
        return string.Join("" "", output);
 
        //Yikes!
        void Print(string action) => Console.WriteLine($""{action + "":"",-4} {$""stack[ {string.Join("" "", stack.Reverse())} ]"",-18} {$""out[ {string.Join("" "", output)} ]""}"");
        //A little more readable?
        void Print(string action) => Console.WriteLine(""{0,-4} {1,-18} {2}"", action + "":"", $""stack[ {string.Join("" "", stack.Reverse())} ]"", $""out[ {string.Join("" "", output)} ]"");
    }
}",2630,68
29388,http://rosettacode.org/wiki/Parsing/RPN_to_infix_conversion,Parsing/RPN to infix conversion,"Parsing/RPN to infix conversion

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a program that takes an RPN representation of an expression formatted as a space separated sequence of tokens and generates the equivalent expression in infix notation.

 Assume an input of a correct, space separated, string of tokens
 Generate a space separated output string representing the same expression in infix notation
 Show how the major datastructure of your algorithm changes with each new token parsed.
 Test with the following input RPN strings then print and display the output here.


 RPN input 
 sample output


 3 4 2 * 1 5 - 2 3 ^ ^ / +
 3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3


 1 2 + 3 4 + ^ 5 6 + ^
 ( ( 1 + 2 ) ^ ( 3 + 4 ) ) ^ ( 5 + 6 )

 Operator precedence and operator associativity is given in this table:


 operator 
 precedence 
 associativity 
 operation


  ^  
 4 
 right 
 exponentiation


  *  
 3 
 left 
 multiplication


  /  
 3 
 left 
 division


  +  
 2 
 left 
 addition


  -  
 2 
 left 
 subtraction



See also

   Parsing/Shunting-yard algorithm   for a method of generating an RPN from an infix expression.
   Parsing/RPN calculator algorithm   for a method of calculating a final value from this output RPN expression.
   Postfix to infix   from the RubyQuiz site.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
 
namespace PostfixToInfix
{
    class Program
    {
        class Operator
        {
            public Operator(char t, int p, bool i = false)
            {
                Token = t;
                Precedence = p;
                IsRightAssociative = i;
            }
 
            public char Token { get; private set; }
            public int Precedence { get; private set; }
            public bool IsRightAssociative { get; private set; }
        }
 
        static IReadOnlyDictionary<char, Operator> operators = new Dictionary<char, Operator>
        {
            { '+', new Operator('+', 2) },
            { '-', new Operator('-', 2) },
            { '/', new Operator('/', 3) },
            { '*', new Operator('*', 3) },
            { '^', new Operator('^', 4, true) }
        };
 
        class Expression
        {
            public String ex;
            public Operator op;
 
            public Expression(String e)
            {
                ex = e;
            }
 
            public Expression(String e1, String e2, Operator o)
            {
                ex = String.Format(""{0} {1} {2}"", e1, o.Token, e2);
                op = o;
            }
        }
 
        static String PostfixToInfix(String postfix)
        {
            var stack = new Stack<Expression>();
 
            foreach (var token in Regex.Split(postfix, @""\s+""))
            {
                char c = token[0];
 
                var op = operators.FirstOrDefault(kv => kv.Key == c).Value;
                if (op != null && token.Length == 1)
                {
                    Expression rhs = stack.Pop();
                    Expression lhs = stack.Pop();
 
                    int opPrec = op.Precedence;
 
                    int lhsPrec = lhs.op != null ? lhs.op.Precedence : int.MaxValue;
                    int rhsPrec = rhs.op != null ? rhs.op.Precedence : int.MaxValue;
 
                    if ((lhsPrec < opPrec || (lhsPrec == opPrec && c == '^')))
                        lhs.ex = '(' + lhs.ex + ')';
 
                    if ((rhsPrec < opPrec || (rhsPrec == opPrec && c != '^')))
                        rhs.ex = '(' + rhs.ex + ')';
 
                    stack.Push(new Expression(lhs.ex, rhs.ex, op));
                }
                else
                {
                    stack.Push(new Expression(token));
                }
 
                // print intermediate result
                Console.WriteLine(""{0} -> [{1}]"", token,
                    string.Join("", "", stack.Reverse().Select(e => e.ex)));
            }
            return stack.Peek().ex;
        }
 
        static void Main(string[] args)
        {
            string[] inputs = { ""3 4 2 * 1 5 - 2 3 ^ ^ / +"", ""1 2 + 3 4 + ^ 5 6 + ^"" };
            foreach (var e in inputs)
            {
                Console.WriteLine(""Postfix : {0}"", e);
                Console.WriteLine(""Infix : {0}"", PostfixToInfix(e));
                Console.WriteLine(); ;
            }
            Console.ReadLine();
        }
    }
}",3113,101
29404,http://rosettacode.org/wiki/Parallel_calculations,Parallel calculations,"Many programming languages allow you to specify computations to be run in parallel.
While Concurrent computing is focused on concurrency,
the purpose of this task is to distribute time-consuming calculations
on as many CPUs as possible.

Assume we have a collection of numbers, and want to find the one
with the largest minimal prime factor
(that is, the one that contains relatively large factors).
To speed up the search, the factorization should be done
in parallel using separate threads or processes,
to take advantage of multi-core CPUs.

Show how this can be formulated in your language.
Parallelize the factorization of those numbers,
then search the returned list of numbers and factors
for the largest minimal factor,
and return that number and its prime factors.

For the prime number decomposition
you may use the solution of the Prime decomposition task.
",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
class Program
{
    public static List<int> PrimeFactors(int number)
    {
        var primes = new List<int>();
        for (int div = 2; div <= number; div++)
        {
            while (number % div == 0)
            {
                primes.Add(div);
                number = number / div;
            }
        }
        return primes;
    }
 
    static void Main(string[] args)
    {
        int[] n = { 12757923, 12878611, 12757923, 15808973, 15780709, 197622519 };
        // Calculate each of those numbers' prime factors, in parallel
        var factors = n.AsParallel().Select(PrimeFactors).ToList();
        // Make a new list showing the smallest factor for each
        var smallestFactors = factors.Select(thisNumbersFactors => thisNumbersFactors.Min()).ToList();
        // Find the index that corresponds with the largest of those factors
        int biggestFactor = smallestFactors.Max();
        int whatIndexIsThat = smallestFactors.IndexOf(biggestFactor);
        Console.WriteLine(""{0} has the largest minimum prime factor: {1}"", n[whatIndexIsThat], biggestFactor);
        Console.WriteLine(string.Join("" "", factors[whatIndexIsThat]));
    }
}",1237,34
29408,http://rosettacode.org/wiki/Pascal_matrix_generation,Pascal matrix generation,"A pascal matrix is a two-dimensional square matrix holding numbers from   Pascal's triangle,   also known as   binomial coefficients   and which can be shown as   nCr.

Shown below are truncated   5-by-5   matrices   M[i, j]   for   i,j   in range   0..4. 


A Pascal upper-triangular matrix that is populated with   jCi:

[[1, 1, 1, 1, 1],
 [0, 1, 2, 3, 4],
 [0, 0, 1, 3, 6],
 [0, 0, 0, 1, 4],
 [0, 0, 0, 0, 1]]

A Pascal lower-triangular matrix that is populated with   iCj   (the transpose of the upper-triangular matrix):

[[1, 0, 0, 0, 0],
 [1, 1, 0, 0, 0],
 [1, 2, 1, 0, 0],
 [1, 3, 3, 1, 0],
 [1, 4, 6, 4, 1]]

A Pascal symmetric matrix that is populated with   i+jCi:

[[1, 1, 1, 1, 1],
 [1, 2, 3, 4, 5],
 [1, 3, 6, 10, 15],
 [1, 4, 10, 20, 35],
 [1, 5, 15, 35, 70]]



Task

Write functions capable of generating each of the three forms of   n-by-n   matrices.

Use those functions to display upper, lower, and symmetric Pascal   5-by-5   matrices on this page.

The output should distinguish between different matrices and the rows of each matrix   (no showing a list of 25 numbers assuming the reader should split it into rows).



Note
 
The   Cholesky decomposition   of a Pascal symmetric matrix is the Pascal lower-triangle matrix of the same size.



",#C.23,C#,"using System;
 
public static class PascalMatrixGeneration
{
    public static void Main() {
        Print(GenerateUpper(5));
        Console.WriteLine();
        Print(GenerateLower(5));
        Console.WriteLine();
        Print(GenerateSymmetric(5));
    }
 
    static int[,] GenerateUpper(int size) {
        int[,] m = new int[size, size];
        for (int c = 0; c < size; c++) m[0, c] = 1;
        for (int r = 1; r < size; r++) {
            for (int c = r; c < size; c++) {
                m[r, c] = m[r-1, c-1] + m[r, c-1];
            }
        }
        return m;
    }
 
    static int[,] GenerateLower(int size) {
        int[,] m = new int[size, size];
        for (int r = 0; r < size; r++) m[r, 0] = 1;
        for (int c = 1; c < size; c++) {
            for (int r = c; r < size; r++) {
                m[r, c] = m[r-1, c-1] + m[r-1, c];
            }
        }
        return m;
    }
 
    static int[,] GenerateSymmetric(int size) {
        int[,] m = new int[size, size];
        for (int i = 0; i < size; i++) m[0, i] = m[i, 0] = 1;
        for (int r = 1; r < size; r++) {
            for (int c = 1; c < size; c++) {
                m[r, c] = m[r-1, c] + m[r, c-1];
            }
        }
        return m;
    }
 
    static void Print(int[,] matrix) {
        string[,] m = ToString(matrix);
        int width = m.Cast<string>().Select(s => s.Length).Max();
        int rows = matrix.GetLength(0), columns = matrix.GetLength(1);
        for (int row = 0; row < rows; row++) {
            Console.WriteLine(""|"" + string.Join("" "", Range(0, columns).Select(column => m[row, column].PadLeft(width, ' '))) + ""|"");
        }
    }
 
    static string[,] ToString(int[,] matrix) {
        int rows = matrix.GetLength(0), columns = matrix.GetLength(1);
        string[,] m = new string[rows, columns];
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < columns; c++) {
                m[r, c] = matrix[r, c].ToString();
            }
        }
        return m;
    }
 
}",2015,66
29409,http://rosettacode.org/wiki/Parameterized_SQL_statement,Parameterized SQL statement,"SQL injection
Using a SQL update statement like this one (spacing is optional):

UPDATE players
   SET name = 'Smith, Steve', score = 42, active = TRUE
   WHERE jerseyNum = 99
Non-parameterized SQL is the GoTo statement of database programming. Don't do it, and make sure your coworkers don't either.",#C.23,C#,"using System.Data.Sql;
using System.Data.SqlClient;
 
namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            SqlConnection tConn = new SqlConnection(""ConnectionString"");
 
            SqlCommand tCommand = new SqlCommand();
            tCommand.Connection = tConn;
            tCommand.CommandText = ""UPDATE players SET name = @name, score = @score, active = @active WHERE jerseyNum = @jerseyNum"";
 
            tCommand.Parameters.Add(new SqlParameter(""@name"", System.Data.SqlDbType.VarChar).Value = ""Smith, Steve"");
            tCommand.Parameters.Add(new SqlParameter(""@score"", System.Data.SqlDbType.Int).Value = ""42"");
            tCommand.Parameters.Add(new SqlParameter(""@active"", System.Data.SqlDbType.Bit).Value = true);
            tCommand.Parameters.Add(new SqlParameter(""@jerseyNum"", System.Data.SqlDbType.Int).Value = ""99"");
 
            tCommand.ExecuteNonQuery();
        }
    }
}",960,24
29427,http://rosettacode.org/wiki/Parallel_brute_force,Parallel brute force,"Task

Find, through brute force, the five-letter passwords corresponding with the following SHA-256 hashes:

1. 1115dd800feaacefdf481f1f9070374a2a81e27880f187396db67958b207cbad
2. 3a7bd3e2360a3d29eea436fcfb7e44c735d117c42d1c1835420b6b9942dd4f1b
3. 74e1bb62f8dabb8125a58852b63bdf6eaef667cb56ac7f7cdba6d7305c50a22f

Your program should naively iterate through all possible passwords consisting only of five lower-case ASCII English letters. It should use concurrent or parallel processing, if your language supports that feature. You may calculate SHA-256 hashes by calling a library or through a custom implementation. Print each matching password, along with its SHA-256 hash.

Related task: SHA-256
",#C.23,C#,"using System;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
class Program
{
    static void Main(string[] args)
    {
        Parallel.For(0, 26, a => {
            byte[] password = new byte[5];
            byte[] hash;
            byte[] one = StringHashToByteArray(""1115dd800feaacefdf481f1f9070374a2a81e27880f187396db67958b207cbad"");
            byte[] two = StringHashToByteArray(""3a7bd3e2360a3d29eea436fcfb7e44c735d117c42d1c1835420b6b9942dd4f1b"");
            byte[] three = StringHashToByteArray(""74e1bb62f8dabb8125a58852b63bdf6eaef667cb56ac7f7cdba6d7305c50a22f"");
            password[0] = (byte)(97 + a);
            var sha = System.Security.Cryptography.SHA256.Create();
            for (password[1] = 97; password[1] < 123; password[1]++)
                for (password[2] = 97; password[2] < 123; password[2]++)
                    for (password[3] = 97; password[3] < 123; password[3]++)
                        for (password[4] = 97; password[4] < 123; password[4]++)
                        {
                            hash = sha.ComputeHash(password);
                            if (matches(one, hash) || matches(two, hash) || matches(three, hash))
                                Console.WriteLine(Encoding.ASCII.GetString(password) + "" => ""
                                    + BitConverter.ToString(hash).ToLower().Replace(""-"", """"));
                        }
        });
    }
    static byte[] StringHashToByteArray(string s)
    {
        return Enumerable.Range(0, s.Length / 2).Select(i => (byte)Convert.ToInt16(s.Substring(i * 2, 2), 16)).ToArray();
    }
    static bool matches(byte[] a, byte[] b)
    {
        for (int i = 0; i < 32; i++)
            if (a[i] != b[i])
                return false;
        return true;
    }
}",1783,41
29537,http://rosettacode.org/wiki/Parsing/RPN_calculator_algorithm,Parsing/RPN calculator algorithm,"Task

Create a stack-based evaluator for an expression in   reverse Polish notation (RPN)   that also shows the changes in the stack as each individual token is processed as a table.



 Assume an input of a correct, space separated, string of tokens of an RPN expression
 Test with the RPN expression generated from the   Parsing/Shunting-yard algorithm   task: 

         3 4 2 * 1 5 - 2 3 ^ ^ / + 

 Print or display the output here


Notes

    ^    means exponentiation in the expression above.
    /    means division.


See also

   Parsing/Shunting-yard algorithm for a method of generating an RPN from an infix expression.
   Several solutions to 24 game/Solve make use of RPN evaluators (although tracing how they work is not a part of that task).
   Parsing/RPN to infix conversion.
   Arithmetic evaluation.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Globalization;
using System.Threading;
 
namespace RPNEvaluator
{
    class RPNEvaluator
    {
        static void Main(string[] args)
        {
            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
 
            string rpn = ""3 4 2 * 1 5 - 2 3 ^ ^ / +"";
            Console.WriteLine(""{0}\n"", rpn);
 
            decimal result = CalculateRPN(rpn);
            Console.WriteLine(""\nResult is {0}"", result);
        }
 
        static decimal CalculateRPN(string rpn)
        {
            string[] rpnTokens = rpn.Split(' ');
            Stack<decimal> stack = new Stack<decimal>();
            decimal number = decimal.Zero;
 
            foreach (string token in rpnTokens)
            {
                if (decimal.TryParse(token, out number))
                {
                    stack.Push(number);
                }
                else
                {
                    switch (token)
                    {
                        case ""^"":
                        case ""pow"":
                            {
                                number = stack.Pop();
                                stack.Push((decimal)Math.Pow((double)stack.Pop(), (double)number));
                                break;
                            }
                        case ""ln"":
                            {
                                stack.Push((decimal)Math.Log((double)stack.Pop(), Math.E));
                                break;
                            }
                        case ""sqrt"":
                            {
                                stack.Push((decimal)Math.Sqrt((double)stack.Pop()));
                                break;
                            }
                        case ""*"":
                            {
                                stack.Push(stack.Pop() * stack.Pop());
                                break;
                            }
                        case ""/"":
                            {
                                number = stack.Pop();
                                stack.Push(stack.Pop() / number);
                                break;
                            }
                        case ""+"":
                            {
                                stack.Push(stack.Pop() + stack.Pop());
                                break;
                            }
                        case ""-"":
                            {
                                number = stack.Pop();
                                stack.Push(stack.Pop() - number);
                                break;
                            }
                        default:
                            Console.WriteLine(""Error in CalculateRPN(string) Method!"");
                            break;
                    }
                }
                PrintState(stack);
            }
 
            return stack.Pop();
        }
 
        static void PrintState(Stack<decimal> stack)
        {
            decimal[] arr = stack.ToArray();
 
            for (int i = arr.Length - 1; i >= 0; i--)
            {
                Console.Write(""{0,-8:F3}"", arr[i]);
            }
 
            Console.WriteLine();
        }
    }
}",3297,100
29686,http://rosettacode.org/wiki/Pascal%27s_triangle,Pascal's triangle,"Pascal's triangle is an arithmetic and geometric figure often associated with the name of Blaise Pascal, but also studied centuries earlier in India, Persia, China and elsewhere.

Its first few rows look like this: 

    1
   1 1
  1 2 1
 1 3 3 1 

where each element of each row is either 1 or the sum of the two elements right above it.

For example, the next row of the triangle would be:

   1   (since the first element of each row doesn't have two elements above it)
   4   (1 + 3)
   6   (3 + 3)
   4   (3 + 1)
   1   (since the last element of each row doesn't have two elements above it) 
So the triangle now looks like this: 

    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1 

Each row    n    (starting with row   0   at the top) shows the coefficients of the binomial expansion of    (x + y)n. 



Task

Write a function that prints out the first    n    rows of the triangle   (with    f(1)    yielding the row consisting of only the element 1).

This can be done either by summing elements from the previous rows or using a binary coefficient or combination function.

Behavior for    n ≤ 0    does not need to be uniform, but should be noted.



See also

 Evaluate binomial coefficients

",#C.23,C#,"using System;
 
namespace RosettaCode {
 
    class PascalsTriangle {
 
        public static void CreateTriangle(int n) {
            if (n > 0) {
                for (int i = 0; i < n; i++) {
                    int c = 1;
                    Console.Write("" "".PadLeft(2 * (n - 1 - i)));
                    for (int k = 0; k <= i; k++) {
                        Console.Write(""{0}"", c.ToString().PadLeft(3));
                        c = c * (i - k) / (k + 1);
                    }
                    Console.WriteLine();
                }
            }
        }
 
        public static void Main() {
            CreateTriangle(8);
        }
    }
}",654,25
29816,http://rosettacode.org/wiki/Pangram_checker,Pangram checker,"Pangram checker

You are encouraged to solve this task according to the task description, using any language you may know.
A pangram is a sentence that contains all the letters of the English alphabet at least once.

For example:   The quick brown fox jumps over the lazy dog.



Task

Write a function or method to check a sentence to see if it is a   pangram   (or not)   and show its use.



Related tasks

   determine if a string has all the same characters
   determine if a string has all unique characters

",#C.23,C#,"using System;
using System.Linq;
 
static class Program
{
    static bool IsPangram(this string text, string alphabet = ""abcdefghijklmnopqrstuvwxyz"")
    {
        return alphabet.All(text.ToLower().Contains);
    }
 
    static void Main(string[] arguments)
    {
        Console.WriteLine(arguments.Any() && arguments.First().IsPangram());
    }
}",349,15
30073,http://rosettacode.org/wiki/Palindrome_detection,Palindrome detection,"A palindrome is a phrase which reads the same backward and forward.

Task[edit]
Write a function or program that checks whether a given sequence of characters (or, if you prefer, bytes)
is a palindrome.

For extra credit:

 Support Unicode characters.
 Write a second function (possibly as a wrapper to the first) which detects inexact palindromes, i.e. phrases that are palindromes if white-space and punctuation is ignored and case-insensitive comparison is used.
Hints
 It might be useful for this task to know how to reverse a string.
 This task's entries might also form the subjects of the task Test a function.
Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
 
class Program
{
    static string Reverse(string value)
    {
        char[] chars = value.ToCharArray();
        Array.Reverse(chars);
        return new string(chars);
    }
 
    static bool IsPalindrome(string value)
    {
        return value == Reverse(value);
    }
 
    static void Main(string[] args)
    {
        Console.WriteLine(IsPalindrome(""ingirumimusnocteetconsumimurigni""));
    }
}",417,21
30278,http://rosettacode.org/wiki/Ordered_partitions,Ordered partitions,"In this task we want to find the ordered partitions into fixed-size blocks.

This task is related to Combinations in that it has to do with discrete mathematics and moreover a helper function to compute combinations is (probably) needed to solve this task.





p
a
r
t
i
t
i
o
n
s
(



a
r
g



1


,



a
r
g



2


,
.
.
.
,



a
r
g



n


)


{\displaystyle partitions({\mathit {arg}}_{1},{\mathit {arg}}_{2},...,{\mathit {arg}}_{n})}

 should generate all distributions of the elements in 



{
1
,
.
.
.
,

Σ

i
=
1


n





a
r
g



i


}


{\displaystyle \{1,...,\Sigma _{i=1}^{n}{\mathit {arg}}_{i}\}}

 into 



n


{\displaystyle n}

 blocks of respective size 






a
r
g



1


,



a
r
g



2


,
.
.
.
,



a
r
g



n




{\displaystyle {\mathit {arg}}_{1},{\mathit {arg}}_{2},...,{\mathit {arg}}_{n}}

.

Example 1: 



p
a
r
t
i
t
i
o
n
s
(
2
,
0
,
2
)


{\displaystyle partitions(2,0,2)}

 would create:

{({1, 2}, {}, {3, 4}), 
 ({1, 3}, {}, {2, 4}), 
 ({1, 4}, {}, {2, 3}), 
 ({2, 3}, {}, {1, 4}), 
 ({2, 4}, {}, {1, 3}), 
 ({3, 4}, {}, {1, 2})}

Example 2: 



p
a
r
t
i
t
i
o
n
s
(
1
,
1
,
1
)


{\displaystyle partitions(1,1,1)}

 would create:

{({1}, {2}, {3}), 
 ({1}, {3}, {2}), 
 ({2}, {1}, {3}), 
 ({2}, {3}, {1}), 
 ({3}, {1}, {2}), 
 ({3}, {2}, {1})}

Note that the number of elements in the list is








(






a
r
g



1


+



a
r
g



2


+
.
.
.
+



a
r
g



n






a
r
g



1




)



⋅



(






a
r
g



2


+



a
r
g



3


+
.
.
.
+



a
r
g



n






a
r
g



2




)



⋅
…
⋅



(





a
r
g



n





a
r
g



n




)





{\displaystyle {{\mathit {arg}}_{1}+{\mathit {arg}}_{2}+...+{\mathit {arg}}_{n} \choose {\mathit {arg}}_{1}}\cdot {{\mathit {arg}}_{2}+{\mathit {arg}}_{3}+...+{\mathit {arg}}_{n} \choose {\mathit {arg}}_{2}}\cdot \ldots \cdot {{\mathit {arg}}_{n} \choose {\mathit {arg}}_{n}}}


(see the definition of the binomial coefficient if you are not familiar with this notation) and the number of elements remains the same regardless of how the argument is permuted
(i.e. the multinomial coefficient).

Also, 



p
a
r
t
i
t
i
o
n
s
(
1
,
1
,
1
)


{\displaystyle partitions(1,1,1)}

 creates the permutations of 



{
1
,
2
,
3
}


{\displaystyle \{1,2,3\}}

 and thus there would be 



3
!
=
6


{\displaystyle 3!=6}

 elements in the list.

Note: Do not use functions that are not in the standard library of the programming language you use. Your file should be written so that it can be executed on the command line and by default outputs the result of 



p
a
r
t
i
t
i
o
n
s
(
2
,
0
,
2
)


{\displaystyle partitions(2,0,2)}

. If the programming language does not support polyvariadic functions pass a list as an argument.

Notation

Here are some explanatory remarks on the notation used in the task description:





{
1
,
…
,
n
}


{\displaystyle \{1,\ldots ,n\}}

 denotes the set of consecutive numbers from 



1


{\displaystyle 1}

 to 



n


{\displaystyle n}

, e.g. 



{
1
,
2
,
3
}


{\displaystyle \{1,2,3\}}

 if 



n
=
3


{\displaystyle n=3}

.





Σ


{\displaystyle \Sigma }

 is the mathematical notation for summation, e.g. 




Σ

i
=
1


3


i
=
6


{\displaystyle \Sigma _{i=1}^{3}i=6}

 (see also [1]).








a
r
g



1


,



a
r
g



2


,
.
.
.
,



a
r
g



n




{\displaystyle {\mathit {arg}}_{1},{\mathit {arg}}_{2},...,{\mathit {arg}}_{n}}

 are the arguments — natural numbers — that the sought function receives.



",#C.23,C#,"using System;
using System.Linq;
using System.Collections.Generic;
 
public static class OrderedPartitions
{
    public static void Main() {
        var input = new [] { new[] { 0, 0, 0, 0, 0 }, new[] { 2, 0, 2 }, new[] { 1, 1, 1 } };
        foreach (int[] sizes in input) {
            foreach (var partition in Partitions(sizes)) {
                Console.WriteLine(partition.Select(set => set.Delimit("", "").Encase('{','}')).Delimit("", "").Encase('(', ')'));
            }
            Console.WriteLine();
        }
    }
 
    static IEnumerable<IEnumerable<int[]>> Partitions(params int[] sizes) {
        var enumerators = new IEnumerator<int[]>[sizes.Length];
        var unused = Enumerable.Range(1, sizes.Sum()).ToSortedSet();
        var arrays = sizes.Select(size => new int[size]).ToArray();
 
        for (int s = 0; s >= 0; ) {
            if (s == sizes.Length) {
                yield return arrays;
                s--;
            }
            if (enumerators[s] == null) {
                enumerators[s] = Combinations(sizes[s], unused.ToArray()).GetEnumerator();
            } else {
                unused.UnionWith(arrays[s]);
            }
            if (enumerators[s].MoveNext()) {
                enumerators[s].Current.CopyTo(arrays[s], 0);
                unused.ExceptWith(arrays[s]);
                s++;
            } else {
                enumerators[s] = null;
                s--;
            }
        }
    }
 
    static IEnumerable<T[]> Combinations<T>(int count, params T[] array) {
        T[] result = new T[count];
        foreach (int pattern in BitPatterns(array.Length - count, array.Length)) {
            for (int b = 1 << (array.Length - 1), i = 0, r = 0; b > 0; b >>= 1, i++) {
                if ((pattern & b) == 0) result[r++] = array[i];
            }
            yield return result;
        }
    }
 
    static IEnumerable<int> BitPatterns(int ones, int length) {
        int initial = (1 << ones) - 1;
        int blockMask = (1 << length) - 1;
        for (int v = initial; v >= initial; ) {
            yield return v;
            if (v == 0) break;
 
            int w = (v | (v - 1)) + 1;
            w |= (((w & -w) / (v & -v)) >> 1) - 1;
            v = w & blockMask;
        }
    }
 
    static string Delimit<T>(this IEnumerable<T> source, string separator) => string.Join(separator, source);
    static string Encase(this string s, char start, char end) => start + s + end;
}",2445,68
30315,http://rosettacode.org/wiki/Palindrome_dates,Palindrome dates,"Today   (2020-02-02,   at the time of this writing)   happens to be a palindrome,   without the hyphens,   not only for those countries which express their dates in the   yyyy-mm-dd   format but,   unusually,   also for countries which use the   dd-mm-yyyy   format.



Task
Write a program which calculates and shows the next 15 palindromic dates for those countries which express their dates in the   yyyy-mm-dd   format.



",#C.23,C#,"using System;
using System.Linq;
using System.Collections.Generic;
 
public class Program
{
    static void Main()
    {
        foreach (var date in PalindromicDates(2021).Take(15)) WriteLine(date.ToString(""yyyy-MM-dd""));
    }
 
    public static IEnumerable<DateTime> PalindromicDates(int startYear) {
        for (int y = startYear; ; y++) {
            int m = Reverse(y % 100);
            int d = Reverse(y / 100);
            if (IsValidDate(y, m, d, out var date)) yield return date;
        }
 
        int Reverse(int x) => x % 10 * 10 + x / 10;
        bool IsValidDate(int y, int m, int d, out DateTime date) => DateTime.TryParse($""{y}-{m}-{d}"", out date);
    }
}",677,22
30481,http://rosettacode.org/wiki/Ordered_words,Ordered words,"An   ordered word   is a word in which the letters appear in alphabetic order.

Examples include   abbey   and   dirt.

Task[edit]
Find and display all the ordered words in the dictionary   unixdict.txt   that have the longest word length.

(Examples that access the dictionary file locally assume that you have downloaded this file yourself.)

The display needs to be shown on this page.

Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.Linq;
using System.Net;
 
static class Program
{
    static void Main(string[] args)
    {
        WebClient client = new WebClient();
        string text = client.DownloadString(""http://www.puzzlers.org/pub/wordlists/unixdict.txt"");
        string[] words = text.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
 
        var query = from w in words
                    where IsOrderedWord(w)
                    group w by w.Length into ows
                    orderby ows.Key descending
                    select ows;
 
        Console.WriteLine(string.Join("", "", query.First().ToArray()));
    }
 
    private static bool IsOrderedWord(string w)
    {
        for (int i = 1; i < w.Length; i++)
            if (w[i] < w[i - 1])
                return false;
 
        return true;
    }
}",844,30
30497,http://rosettacode.org/wiki/P-value_correction,P-value correction,"Given a list of p-values, adjust the p-values for multiple comparisons. This is done in order to control the false positive, or Type 1 error rate.

This is also known as the ""false discovery rate"" (FDR). After adjustment, the p-values will be higher but still inside [0,1].

The adjusted p-values are sometimes called ""q-values"".



Task

Given one list of p-values, return the p-values correcting for multiple comparisons

   p = {4.533744e-01, 7.296024e-01, 9.936026e-02, 9.079658e-02, 1.801962e-01,
        8.752257e-01, 2.922222e-01, 9.115421e-01, 4.355806e-01, 5.324867e-01,
        4.926798e-01, 5.802978e-01, 3.485442e-01, 7.883130e-01, 2.729308e-01,
        8.502518e-01, 4.268138e-01, 6.442008e-01, 3.030266e-01, 5.001555e-02,
        3.194810e-01, 7.892933e-01, 9.991834e-01, 1.745691e-01, 9.037516e-01,
        1.198578e-01, 3.966083e-01, 1.403837e-02, 7.328671e-01, 6.793476e-02,
        4.040730e-03, 3.033349e-04, 1.125147e-02, 2.375072e-02, 5.818542e-04,
        3.075482e-04, 8.251272e-03, 1.356534e-03, 1.360696e-02, 3.764588e-04,
        1.801145e-05, 2.504456e-07, 3.310253e-02, 9.427839e-03, 8.791153e-04,
        2.177831e-04, 9.693054e-04, 6.610250e-05, 2.900813e-02, 5.735490e-03}



There are several methods to do this, see:

 Yoav Benjamini, Yosef Hochberg ""Controlling the False Discovery Rate: A Practical and Powerful Approach to Multiple Testing"", Journal of the Royal Statistical Society. Series B, Vol. 57, No. 1 (1995), pp. 289-300, JSTOR:2346101
 Yoav Benjamini, Daniel Yekutieli, ""The control of the false discovery rate in multiple testing under dependency"", Ann. Statist., Vol. 29, No. 4 (2001), pp. 1165-1188, DOI:10.1214/aos/1013699998 JSTOR:2674075
 Sture Holm, ""A Simple Sequentially Rejective Multiple Test Procedure"", Scandinavian Journal of Statistics, Vol. 6, No. 2 (1979), pp. 65-70, JSTOR:4615733
 Yosef Hochberg, ""A sharper Bonferroni procedure for multiple tests of significance"", Biometrika, Vol. 75, No. 4 (1988), pp 800–802, DOI:10.1093/biomet/75.4.800 JSTOR:2336325
 Gerhard Hommel, ""A stagewise rejective multiple test procedure based on a modified Bonferroni test"", Biometrika, Vol. 75, No. 2 (1988), pp 383–386, DOI:10.1093/biomet/75.2.383 JSTOR:2336190


Each method has its own advantages and disadvantages.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace PValueCorrection {
    class Program {
        static List<int> SeqLen(int start, int end) {
            var result = new List<int>();
            if (start == end) {
                for (int i = 0; i < end + 1; ++i) {
                    result.Add(i + 1);
                }
            } else if (start < end) {
                for (int i = 0; i < end - start + 1; ++i) {
                    result.Add(start + i);
                }
            } else {
                for (int i = 0; i < start - end + 1; ++i) {
                    result.Add(start - i);
                }
            }
            return result;
        }
 
        static List<int> Order(List<double> array, bool decreasing) {
            List<int> idx = new List<int>();
            for (int i = 0; i < array.Count; ++i) {
                idx.Add(i);
            }
 
            IComparer<int> cmp;
            if (decreasing) {
                cmp = Comparer<int>.Create((a, b) => array[a] < array[b] ? 1 : array[b] < array[a] ? -1 : 0);
            } else {
                cmp = Comparer<int>.Create((a, b) => array[b] < array[a] ? 1 : array[a] < array[b] ? -1 : 0);
            }
 
            idx.Sort(cmp);
            return idx;
        }
 
        static List<double> Cummin(List<double> array) {
            if (array.Count < 1) throw new ArgumentOutOfRangeException(""cummin requires at least one element"");
            var output = new List<double>();
            double cumulativeMin = array[0];
            for (int i = 0; i < array.Count; ++i) {
                if (array[i] < cumulativeMin) cumulativeMin = array[i];
                output.Add(cumulativeMin);
            }
            return output;
        }
 
        static List<double> Cummax(List<double> array) {
            if (array.Count < 1) throw new ArgumentOutOfRangeException(""cummax requires at least one element"");
            var output = new List<double>();
            double cumulativeMax = array[0];
            for (int i = 0; i < array.Count; ++i) {
                if (array[i] > cumulativeMax) cumulativeMax = array[i];
                output.Add(cumulativeMax);
            }
            return output;
        }
 
        static List<double> Pminx(List<double> array, double x) {
            if (array.Count < 1) throw new ArgumentOutOfRangeException(""pmin requires at least one element"");
            var result = new List<double>();
            for (int i = 0; i < array.Count; ++i) {
                if (array[i] < x) {
                    result.Add(array[i]);
                } else {
                    result.Add(x);
                }
            }
            return result;
        }
 
        static void Say(List<double> array) {
            Console.Write(""[ 1] {0:E}"", array[0]);
            for (int i = 1; i < array.Count; ++i) {
                Console.Write("" {0:E}"", array[i]);
                if ((i + 1) % 5 == 0) Console.Write(""\n[{0,2}]"", i + 1);
            }
            Console.WriteLine();
        }
 
        static List<double> PAdjust(List<double> pvalues, string str) {
            var size = pvalues.Count;
            if (size < 1) throw new ArgumentOutOfRangeException(""pAdjust requires at least one element"");
 
            int type;
            switch (str.ToLower()) {
                case ""bh"":
                case ""fdr"":
                    type = 0;
                    break;
                case ""by"":
                    type = 1;
                    break;
                case ""bonferroni"":
                    type = 2;
                    break;
                case ""hochberg"":
                    type = 3;
                    break;
                case ""holm"":
                    type = 4;
                    break;
                case ""hommel"":
                    type = 5;
                    break;
                default:
                    throw new ArgumentException(str + "" doesn't match any accepted FDR types"");
            }
 
            if (2 == type) { // Bonferroni method
                var result2 = new List<double>();
                for (int i = 0; i < size; ++i) {
                    double b = pvalues[i] * size;
                    if (b >= 1) {
                        result2.Add(1);
                    } else if (0 <= b && b < 1) {
                        result2.Add(b);
                    } else {
                        throw new Exception(b + "" is outside [0, 1)"");
                    }
                }
                return result2;
            } else if (4 == type) { // Holm method
                var o4 = Order(pvalues, false);
                var o4d = o4.ConvertAll(x => (double)x);
                var cummaxInput = new List<double>();
                for (int i = 0; i < size; ++i) {
                    cummaxInput.Add((size - i) * pvalues[o4[i]]);
                }
                var ro4 = Order(o4d, false);
                var cummaxOutput = Cummax(cummaxInput);
                var pmin4 = Pminx(cummaxOutput, 1.0);
                var hr = new List<double>();
                for (int i = 0; i < size; ++i) {
                    hr.Add(pmin4[ro4[i]]);
                }
                return hr;
            } else if (5 == type) { // Hommel method
                var indices = SeqLen(size, size);
                var o5 = Order(pvalues, false);
                var p = new List<double>();
                for (int i = 0; i < size; ++i) {
                    p.Add(pvalues[o5[i]]);
                }
                var o5d = o5.ConvertAll(x => (double)x);
                var ro5 = Order(o5d, false);
                var q = new List<double>();
                var pa = new List<double>();
                var npi = new List<double>();
                for (int i = 0; i < size; ++i) {
                    npi.Add(p[i] * size / indices[i]);
                }
                double min = npi.Min();
                q.AddRange(Enumerable.Repeat(min, size));
                pa.AddRange(Enumerable.Repeat(min, size));
                for (int j = size; j >= 2; --j) {
                    var ij = SeqLen(1, size - j + 1);
                    for (int i = 0; i < size - j + 1; ++i) {
                        ij[i]--;
                    }
                    int i2Length = j - 1;
                    var i2 = new List<int>();
                    for (int i = 0; i < i2Length; ++i) {
                        i2.Add(size - j + 2 + i - 1);
                    }
                    double q1 = j * p[i2[0]] / 2.0;
                    for (int i = 1; i < i2Length; ++i) {
                        double temp_q1 = p[i2[i]] * j / (2.0 + i);
                        if (temp_q1 < q1) q1 = temp_q1;
                    }
                    for (int i = 0; i < size - j + 1; ++i) {
                        q[ij[i]] = Math.Min(p[ij[i]] * j, q1);
                    }
                    for (int i = 0; i < i2Length; ++i) {
                        q[i2[i]] = q[size - j];
                    }
                    for (int i = 0; i < size; ++i) {
                        if (pa[i] < q[i]) {
                            pa[i] = q[i];
                        }
                    }
                }
                for (int i = 0; i < size; ++i) {
                    q[i] = pa[ro5[i]];
                }
                return q;
            }
 
            var ni = new List<double>();
            var o = Order(pvalues, true);
            var od = o.ConvertAll(x => (double)x);
            for (int i = 0; i < size; ++i) {
                if (pvalues[i] < 0 || pvalues[i] > 1) {
                    throw new Exception(""array["" + i + ""] = "" + pvalues[i] + "" is outside [0, 1]"");
                }
                ni.Add((double)size / (size - i));
            }
            var ro = Order(od, false);
            var cumminInput = new List<double>();
            if (0 == type) {       // BH method
                for (int i = 0; i < size; ++i) {
                    cumminInput.Add(ni[i] * pvalues[o[i]]);
                }
            } else if (1 == type) { // BY method
                double q = 0;
                for (int i = 1; i < size + 1; ++i) {
                    q += 1.0 / i;
                }
                for (int i = 0; i < size; ++i) {
                    cumminInput.Add(q * ni[i] * pvalues[o[i]]);
                }
            } else if (3 == type) { // Hochberg method
                for (int i = 0; i < size; ++i) {
                    cumminInput.Add((i + 1) * pvalues[o[i]]);
                }
            }
            var cumminArray = Cummin(cumminInput);
            var pmin = Pminx(cumminArray, 1.0);
            var result = new List<double>();
            for (int i = 0; i < size; ++i) {
                result.Add(pmin[ro[i]]);
            }
            return result;
        }
 
        static void Main(string[] args) {
            var pvalues = new List<double> {
                4.533744e-01, 7.296024e-01, 9.936026e-02, 9.079658e-02, 1.801962e-01,
                8.752257e-01, 2.922222e-01, 9.115421e-01, 4.355806e-01, 5.324867e-01,
                4.926798e-01, 5.802978e-01, 3.485442e-01, 7.883130e-01, 2.729308e-01,
                8.502518e-01, 4.268138e-01, 6.442008e-01, 3.030266e-01, 5.001555e-02,
                3.194810e-01, 7.892933e-01, 9.991834e-01, 1.745691e-01, 9.037516e-01,
                1.198578e-01, 3.966083e-01, 1.403837e-02, 7.328671e-01, 6.793476e-02,
                4.040730e-03, 3.033349e-04, 1.125147e-02, 2.375072e-02, 5.818542e-04,
                3.075482e-04, 8.251272e-03, 1.356534e-03, 1.360696e-02, 3.764588e-04,
                1.801145e-05, 2.504456e-07, 3.310253e-02, 9.427839e-03, 8.791153e-04,
                2.177831e-04, 9.693054e-04, 6.610250e-05, 2.900813e-02, 5.735490e-03
            };
            var correctAnswers = new List<List<double>> {
                new List<double> { // Benjamini-Hochberg
                    6.126681e-01, 8.521710e-01, 1.987205e-01, 1.891595e-01, 3.217789e-01,
                    9.301450e-01, 4.870370e-01, 9.301450e-01, 6.049731e-01, 6.826753e-01,
                    6.482629e-01, 7.253722e-01, 5.280973e-01, 8.769926e-01, 4.705703e-01,
                    9.241867e-01, 6.049731e-01, 7.856107e-01, 4.887526e-01, 1.136717e-01,
                    4.991891e-01, 8.769926e-01, 9.991834e-01, 3.217789e-01, 9.301450e-01,
                    2.304958e-01, 5.832475e-01, 3.899547e-02, 8.521710e-01, 1.476843e-01,
                    1.683638e-02, 2.562902e-03, 3.516084e-02, 6.250189e-02, 3.636589e-03,
                    2.562902e-03, 2.946883e-02, 6.166064e-03, 3.899547e-02, 2.688991e-03,
                    4.502862e-04, 1.252228e-05, 7.881555e-02, 3.142613e-02, 4.846527e-03,
                    2.562902e-03, 4.846527e-03, 1.101708e-03, 7.252032e-02, 2.205958e-02
                },
                new List<double> { // Benjamini & Yekutieli
                    1.000000e+00, 1.000000e+00, 8.940844e-01, 8.510676e-01, 1.000000e+00,
                    1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
                    1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
                    1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 5.114323e-01,
                    1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
                    1.000000e+00, 1.000000e+00, 1.754486e-01, 1.000000e+00, 6.644618e-01,
                    7.575031e-02, 1.153102e-02, 1.581959e-01, 2.812089e-01, 1.636176e-02,
                    1.153102e-02, 1.325863e-01, 2.774239e-02, 1.754486e-01, 1.209832e-02,
                    2.025930e-03, 5.634031e-05, 3.546073e-01, 1.413926e-01, 2.180552e-02,
                    1.153102e-02, 2.180552e-02, 4.956812e-03, 3.262838e-01, 9.925057e-02
                },
                new List<double> { // Bonferroni
                    1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
                    1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
                    1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
                    1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
                    1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
                    1.000000e+00, 1.000000e+00, 7.019185e-01, 1.000000e+00, 1.000000e+00,
                    2.020365e-01, 1.516674e-02, 5.625735e-01, 1.000000e+00, 2.909271e-02,
                    1.537741e-02, 4.125636e-01, 6.782670e-02, 6.803480e-01, 1.882294e-02,
                    9.005725e-04, 1.252228e-05, 1.000000e+00, 4.713920e-01, 4.395577e-02,
                    1.088915e-02, 4.846527e-02, 3.305125e-03, 1.000000e+00, 2.867745e-01
                },
                new List<double> { // Hochberg
                    9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01,
                    9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01,
                    9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01,
                    9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01,
                    9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01,
                    9.991834e-01, 9.991834e-01, 4.632662e-01, 9.991834e-01, 9.991834e-01,
                    1.575885e-01, 1.383967e-02, 3.938014e-01, 7.600230e-01, 2.501973e-02,
                    1.383967e-02, 3.052971e-01, 5.426136e-02, 4.626366e-01, 1.656419e-02,
                    8.825610e-04, 1.252228e-05, 9.930759e-01, 3.394022e-01, 3.692284e-02,
                    1.023581e-02, 3.974152e-02, 3.172920e-03, 8.992520e-01, 2.179486e-01
                },
                new List<double> { // Holm
                    1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
                    1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
                    1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
                    1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
                    1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00, 1.000000e+00,
                    1.000000e+00, 1.000000e+00, 4.632662e-01, 1.000000e+00, 1.000000e+00,
                    1.575885e-01, 1.395341e-02, 3.938014e-01, 7.600230e-01, 2.501973e-02,
                    1.395341e-02, 3.052971e-01, 5.426136e-02, 4.626366e-01, 1.656419e-02,
                    8.825610e-04, 1.252228e-05, 9.930759e-01, 3.394022e-01, 3.692284e-02,
                    1.023581e-02, 3.974152e-02, 3.172920e-03, 8.992520e-01, 2.179486e-01
                },
                new List<double> { // Hommel
                    9.991834e-01, 9.991834e-01, 9.991834e-01, 9.987624e-01, 9.991834e-01,
                    9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01,
                    9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01,
                    9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.595180e-01,
                    9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01, 9.991834e-01,
                    9.991834e-01, 9.991834e-01, 4.351895e-01, 9.991834e-01, 9.766522e-01,
                    1.414256e-01, 1.304340e-02, 3.530937e-01, 6.887709e-01, 2.385602e-02,
                    1.322457e-02, 2.722920e-01, 5.426136e-02, 4.218158e-01, 1.581127e-02,
                    8.825610e-04, 1.252228e-05, 8.743649e-01, 3.016908e-01, 3.516461e-02,
                    9.582456e-03, 3.877222e-02, 3.172920e-03, 8.122276e-01, 1.950067e-01
                }
            };
 
            string[] types = { ""bh"", ""by"", ""bonferroni"", ""hochberg"", ""holm"", ""hommel"" };
            for (int type = 0; type < types.Length; ++type) {
                var q = PAdjust(pvalues, types[type]);
                double error = 0.0;
                for (int i = 0; i < pvalues.Count; ++i) {
                    error += Math.Abs(q[i] - correctAnswers[type][i]);
                }
                Say(q);
                Console.WriteLine(""type {0} = '{1}' has a cumulative error of {2:E}"", type, types[type], error);
                Console.WriteLine();
            }
        }
    }
}",16313,332
30629,http://rosettacode.org/wiki/OpenGL,OpenGL,"

Task

Display a smooth shaded triangle with OpenGL.

 Triangle created using C example compiled with GCC 4.1.2 and freeglut3.

",#C.23,C#,"using OpenTK;
using OpenTK.Graphics;
namespace OpenGLTest
{
    class Program
    {
        static void Main(string[] args)
        {
            //Create the OpenGL window
            GameWindow window = new GameWindow(640, 480, GraphicsMode.Default, ""OpenGL Example"");
 
            GL.MatrixMode(MatrixMode.Projection);
            GL.LoadIdentity();
            GL.Ortho(-30.0, 30.0, -30.0, 30.0, -30.0, 30.0);
            GL.MatrixMode(MatrixMode.Modelview);
 
            //Add event handler to render to the window when called
            window.RenderFrame += new RenderFrameEvent(a_RenderFrame);
            //Starts the window's updating/rendering events
            window.Run();
        }
        static void a_RenderFrame(GameWindow sender, RenderFrameEventArgs e)
        {
            GL.ClearColor(0.3f, 0.3f, 0.3f, 0f);
            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
 
            GL.ShadeModel(ShadingModel.Smooth);
 
            GL.LoadIdentity();
            GL.Translate(-15.0f, -15.0f, 0.0f);
 
            GL.Begin(BeginMode.Triangles);
            GL.Color3(1.0f, 0.0f, 0.0f);
            GL.Vertex2(0.0f, 0.0f);
            GL.Color3(0.0f, 1.0f, 0.0f);
            GL.Vertex2(30f, 0.0f);
            GL.Color3(0.0f, 0.0f, 1.0f);
            GL.Vertex2(0.0f, 30.0f);
            GL.End();
            //Swaps the buffers on the window so that what we draw becomes visible
            sender.SwapBuffers();
        }
    }
}",1487,44
30635,http://rosettacode.org/wiki/Order_two_numerical_lists,Order two numerical lists,"sorting

Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Write a function that orders two lists or arrays filled with numbers.
The function should accept two lists as arguments and return true if the first list should be ordered before the second, and false otherwise.

The order is determined by lexicographic order: Comparing the first element of each list.
If the first elements are equal, then the second elements should be compared, and so on, until one of the list has no more elements.
If the first list runs out of elements the result is true.
If the second list or both run out of elements the result is false.

Note: further clarification of lexicographical ordering is expounded on the talk page here and here.
",#C.23,C#,"namespace RosettaCode.OrderTwoNumericalLists
{
    using System;
    using System.Collections.Generic;
 
    internal static class Program
    {
        private static bool IsLessThan(this IEnumerable<int> enumerable,
            IEnumerable<int> otherEnumerable)
        {
            using (
                IEnumerator<int> enumerator = enumerable.GetEnumerator(),
                    otherEnumerator = otherEnumerable.GetEnumerator())
            {
                while (true)
                {
                    if (!otherEnumerator.MoveNext())
                    {
                        return false;
                    }
 
                    if (!enumerator.MoveNext())
                    {
                        return true;
                    }
 
                    if (enumerator.Current == otherEnumerator.Current)
                    {
                        continue;
                    }
 
                    return enumerator.Current < otherEnumerator.Current;
                }
            }
        }
 
        private static void Main()
        {
            Console.WriteLine(
                new[] {1, 2, 1, 3, 2}.IsLessThan(new[] {1, 2, 0, 4, 4, 0, 0, 0}));
        }
    }
}",1212,43
30742,http://rosettacode.org/wiki/One_of_n_lines_in_a_file,One of n lines in a file,"A method of choosing a line randomly from a file:

 Without reading the file more than once
 When substantial parts of the file cannot be held in memory
 Without knowing how many lines are in the file
Is to:

 keep the first line of the file as a possible choice, then
 Read the second line of the file if possible and make it the possible choice if a uniform random value between zero and one is less than 1/2.
 Read the third line of the file if possible and make it the possible choice if a uniform random value between zero and one is less than 1/3.
 ...
 Read the Nth line of the file if possible and make it the possible choice if a uniform random value between zero and one is less than 1/N
 Return the computed possible choice when no further lines exist in the file.


Task

 Create a function/method/routine called one_of_n that given n, the number of actual lines in a file, follows the algorithm above to return an integer - the line number of the line chosen from the file. 
The number returned can vary, randomly, in each run.
 Use one_of_n in a simulation to find what woud be the chosen line of a 10 line file simulated 1,000,000 times.
 Print and show how many times each of the 10 lines is chosen as a rough measure of how well the algorithm works.


Note: You may choose a smaller number of repetitions if necessary, but mention this up-front.

Note: This is a specific version of a Reservoir Sampling algorithm: https://en.wikipedia.org/wiki/Reservoir_sampling
",#C.23,C#," 
    class Program
    {
        private static Random rnd = new Random();
        public static int one_of_n(int n)
        {
            int currentChoice = 1;
            for (int i = 2; i <= n; i++)
            {
                double outerLimit = 1D / (double)i;
                if (rnd.NextDouble() < outerLimit)
                    currentChoice = i;
            }
            return currentChoice;
        }
 
        static void Main(string[] args)
        {
            Dictionary<int, int> results = new Dictionary<int, int>();
            for (int i = 1; i < 11; i++)
                results.Add(i, 0);
 
            for (int i = 0; i < 1000000; i++)
            {
                int result = one_of_n(10);
                results[result] = results[result] + 1;
            }
 
            for (int i = 1; i < 11; i++)
                Console.WriteLine(""{0}\t{1}"", i, results[i]);
            Console.ReadLine();
        }
    }
 ",945,34
30780,http://rosettacode.org/wiki/Object_serialization,Object serialization,"Create a set of data types based upon inheritance. Each data type or class should have a print command that displays the contents of an instance of that class to standard output. Create instances of each class in your inheritance hierarchy and display them to standard output. Write each of the objects to a file named objects.dat in binary form using serialization or marshalling. Read the file objects.dat and print the contents of each serialized object.
",#C.23,C#,"using System;
using System.IO;
using System.Collections.Generic;
using System.Runtime.Serialization.Formatters.Binary;
 
namespace Object_serialization
{
  [Serializable] public class Being
  {
    public bool Alive { get; set; }
  }
 
  [Serializable] public class Animal: Being
  {
    public Animal() { }
 
    public Animal(long id, string name, bool alive = true)
    {
      Id = id;
      Name = name;
      Alive = alive;
    }
 
    public long Id { get; set; }
    public string Name { get; set; }
 
    public void Print() { Console.WriteLine(""{0}, id={1} is {2}"",
      Name, Id, Alive ? ""alive"" : ""dead""); }
  }
 
 
  internal class Program
  {
    private static void Main()
    {
      string path = 
        Environment.GetFolderPath(Environment.SpecialFolder.Desktop)+""\\objects.dat"";
 
      var n = new List<Animal>
              {
                new Animal(1, ""Fido""),
                new Animal(2, ""Lupo""),
                new Animal(7, ""Wanda""),
                new Animal(3, ""Kiki"", alive: false)
              };
 
      foreach(Animal animal in n)
        animal.Print();
 
      using(var stream = new FileStream(path, FileMode.Create, FileAccess.Write))
        new BinaryFormatter().Serialize(stream, n);
 
      n.Clear();
      Console.WriteLine(""---------------"");
      List<Animal> m;
 
      using(var stream = new FileStream(path, FileMode.Open, FileAccess.Read))
        m = (List<Animal>) new BinaryFormatter().Deserialize(stream);
 
      foreach(Animal animal in m)
        animal.Print();
    }
  }
}",1541,64
30822,http://rosettacode.org/wiki/Numbers_which_are_not_the_sum_of_distinct_squares,Numbers which are not the sum of distinct squares,"

Integer squares are the set of integers multiplied by themselves: 1 x 1 = 1, 2 × 2 = 4, 3 × 3 = 9, etc. ( 1, 4, 9, 16 ... )

Most positive integers can be generated as the sum of 1 or more distinct integer squares.

     1 == 1
     5 == 4 + 1
    25 == 16 + 9
    77 == 36 + 25 + 16
   103 == 49 + 25 + 16 + 9 + 4

Many can be generated in multiple ways:

    90 == 36 + 25 + 16 + 9 + 4 == 64 + 16 + 9 + 1 == 49 + 25 + 16 == 64 + 25 + 1 == 81 + 9
   130 == 64 + 36 + 16 + 9 + 4 + 1 == 49 + 36 + 25 + 16 + 4 == 100 + 16 + 9 + 4 + 1 == 81 + 36 + 9 + 4 == 64 + 49 + 16 + 1 == 100 + 25 + 4 + 1 == 81 + 49 == 121 + 9    

The number of positive integers that cannot be generated by any combination of distinct squares is in fact finite:

   2, 3, 6, 7, etc.



Task
Find and show here, on this page, every positive integer than cannot be generated as the sum of distinct squares.

Do not use magic numbers or pre-determined limits. Justify your answer mathematically.



See also
 OEIS: A001422 Numbers which are not the sum of distinct squares

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
class Program {
 
  // recursively permutates the list of squares to seek a matching sum
  static bool soms(int n, IEnumerable<int> f) {
    if (n <= 0) return false;
    if (f.Contains(n)) return true;
    switch(n.CompareTo(f.Sum())) {
      case 1: return false;
      case 0: return true;
      case -1:
        var rf = f.Reverse().Skip(1).ToList();
        return soms(n - f.Last(), rf) || soms(n, rf);
    }
    return false;
  }
 
  static void Main() {
    var sw = System.Diagnostics.Stopwatch.StartNew();
    int c = 0, r, i, g; var s = new List<int>(); var a = new List<int>();
    var sf = ""stopped checking after finding {0} sequential non-gaps after the final gap of {1}"";
    for (i = 1, g = 1; g >= (i >> 1); i++) {
      if ((r = (int)Math.Sqrt(i)) * r == i) s.Add(i);
      if (!soms(i, s)) a.Add(g = i);
    }
    sw.Stop();
    Console.WriteLine(""Numbers which are not the sum of distinct squares:"");
    Console.WriteLine(string.Join("", "", a));
    Console.WriteLine(sf, i - g, g);
    Console.Write(""found {0} total in {1} ms"",
      a.Count, sw.Elapsed.TotalMilliseconds);
  }
}",1171,36
30882,http://rosettacode.org/wiki/Numerical_integration/Gauss-Legendre_Quadrature,Numerical integration/Gauss-Legendre Quadrature,"

In a general Gaussian quadrature rule, an definite integral of 



f
(
x
)


{\displaystyle f(x)}

 is first approximated over the interval 



[
−
1
,
1
]


{\displaystyle [-1,1]}

 by a polynomial approximable function 



g
(
x
)


{\displaystyle g(x)}

 and a known weighting function 



W
(
x
)


{\displaystyle W(x)}

.






∫

−
1


1


f
(
x
)

d
x
=

∫

−
1


1


W
(
x
)
g
(
x
)

d
x


{\displaystyle \int _{-1}^{1}f(x)\,dx=\int _{-1}^{1}W(x)g(x)\,dx}




Those are then approximated by a sum of function values at specified points 




x

i




{\displaystyle x_{i}}

 multiplied by some weights 




w

i




{\displaystyle w_{i}}

:






∫

−
1


1


W
(
x
)
g
(
x
)

d
x
≈

∑

i
=
1


n



w

i


g
(

x

i


)


{\displaystyle \int _{-1}^{1}W(x)g(x)\,dx\approx \sum _{i=1}^{n}w_{i}g(x_{i})}




In the case of Gauss-Legendre quadrature, the weighting function 



W
(
x
)
=
1


{\displaystyle W(x)=1}

, so we can approximate an integral of 



f
(
x
)


{\displaystyle f(x)}

 with:






∫

−
1


1


f
(
x
)

d
x
≈

∑

i
=
1


n



w

i


f
(

x

i


)


{\displaystyle \int _{-1}^{1}f(x)\,dx\approx \sum _{i=1}^{n}w_{i}f(x_{i})}





For this, we first need to calculate the nodes and the weights, but after we have them, we can reuse them for numerious integral evaluations, which greatly speeds up the calculation compared to more simple numerical integration methods.



The 



n


{\displaystyle n}

 evaluation points 




x

i




{\displaystyle x_{i}}

 for a n-point rule, also called ""nodes"", are roots of n-th order Legendre Polynomials 




P

n


(
x
)


{\displaystyle P_{n}(x)}

. Legendre polynomials are defined by the following recursive rule:






P

0


(
x
)
=
1


{\displaystyle P_{0}(x)=1}







P

1


(
x
)
=
x


{\displaystyle P_{1}(x)=x}






n

P

n


(
x
)
=
(
2
n
−
1
)
x

P

n
−
1


(
x
)
−
(
n
−
1
)

P

n
−
2


(
x
)


{\displaystyle nP_{n}(x)=(2n-1)xP_{n-1}(x)-(n-1)P_{n-2}(x)}





There is also a recursive equation for their derivative:






P

n

′

(
x
)
=


n


x

2


−
1




(
x

P

n


(
x
)
−

P

n
−
1


(
x
)
)



{\displaystyle P_{n}'(x)={\frac {n}{x^{2}-1}}\left(xP_{n}(x)-P_{n-1}(x)\right)}




The roots of those polynomials are in general not analytically solvable, so they have to be approximated numerically, for example by Newton-Raphson iteration:






x

n
+
1


=

x

n


−



f
(

x

n


)



f
′

(

x

n


)





{\displaystyle x_{n+1}=x_{n}-{\frac {f(x_{n})}{f'(x_{n})}}}




The first guess 




x

0




{\displaystyle x_{0}}

 for the 



i


{\displaystyle i}

-th root of a 



n


{\displaystyle n}

-order polynomial 




P

n




{\displaystyle P_{n}}

 can be given by






x

0


=
cos
⁡

(
π




i
−


1
4




n
+


1
2





)



{\displaystyle x_{0}=\cos \left(\pi \,{\frac {i-{\frac {1}{4}}}{n+{\frac {1}{2}}}}\right)}




After we get the nodes 




x

i




{\displaystyle x_{i}}

, we compute the appropriate weights by:






w

i


=


2


(
1
−

x

i


2


)

[

P

n

′

(

x

i


)

]

2







{\displaystyle w_{i}={\frac {2}{\left(1-x_{i}^{2}\right)[P'_{n}(x_{i})]^{2}}}}




After we have the nodes and the weights for a n-point quadrature rule, we can approximate an integral over any interval 



[
a
,
b
]


{\displaystyle [a,b]}

 by






∫

a


b


f
(
x
)

d
x
≈



b
−
a

2



∑

i
=
1


n



w

i


f

(



b
−
a

2



x

i


+



a
+
b

2


)



{\displaystyle \int _{a}^{b}f(x)\,dx\approx {\frac {b-a}{2}}\sum _{i=1}^{n}w_{i}f\left({\frac {b-a}{2}}x_{i}+{\frac {a+b}{2}}\right)}




Task description

Similar to the task Numerical Integration, the task here is to calculate the definite integral of a function 



f
(
x
)


{\displaystyle f(x)}

, but by applying an n-point Gauss-Legendre quadrature rule, as described here, for example. The input values should be an function f to integrate, the bounds of the integration interval a and b, and the number of gaussian evaluation points n. An reference implementation in Common Lisp is provided for comparison.

To demonstrate the calculation, compute the weights and nodes for an 5-point quadrature rule and then use them to compute:

         
  
    
      
        
          ∫
          
            −
            3
          
          
            3
          
        
        exp
        ⁡
        (
        x
        )
        
        d
        x
        ≈
        
          ∑
          
            i
            =
            1
          
          
            5
          
        
        
          w
          
            i
          
        
        
        exp
        ⁡
        (
        
          x
          
            i
          
        
        )
        ≈
        20.036
      
    
    {\displaystyle \int _{-3}^{3}\exp(x)\,dx\approx \sum _{i=1}^{5}w_{i}\;\exp(x_{i})\approx 20.036}
  



",#C.23,C#," 
using System;
//Works in .NET 6+
//Tested using https://dotnetfiddle.net because im lazy
 
public class Program {
 
    public static double[][] legeCoef(int N) {
        //Initialising Jagged Array
        double[][] lcoef = new double[N+1][];
        for (int i=0; i < lcoef.Length; ++i) 
            lcoef[i] = new double[N+1];
 
 
        lcoef[0][0] = lcoef[1][1] = 1;
        for (int n = 2; n <= N; n++) {
            lcoef[n][0] = -(n - 1) * lcoef[n - 2][0] / n;
            for (int i = 1; i <= n; i++) 
                lcoef[n][i] = ((2*n - 1) * lcoef[n-1][i-1] 
                               - (n-1) * lcoef[n-2][i] ) / n;
        }
        return lcoef;
    }
 
 
    static double legeEval(double[][] lcoef, int N, double x) {
        double s = lcoef[N][N];
        for (int i = N; i > 0; --i)
            s = s * x + lcoef[N][i-1];
        return s;
    }
 
    static double legeDiff(double[][] lcoef, int N, double x) {
        return N * (x * legeEval(lcoef, N, x) - legeEval(lcoef, N-1, x)) / (x*x - 1);
    }
 
    static void legeRoots(double[][] lcoef, int N, out double[] lroots,  out double[] weight) {
        lroots = new double[N];
        weight = new double[N];
 
        double x, x1;
        for (int i = 1; i <= N; i++) {
            x = Math.Cos(Math.PI * (i - 0.25) / (N + 0.5));
            do { 
                x1 = x;
                x -= legeEval(lcoef, N, x) / legeDiff(lcoef, N, x);
            } 
            while (x != x1);
            lroots[i-1] = x;
 
            x1 = legeDiff(lcoef, N, x);
            weight[i-1] = 2 / ((1 - x*x) * x1*x1);
        }
    }
 
 
 
    static double legeInte(Func<Double, Double> f, int N, double[] weights, double[] lroots, double a, double b) {
        double c1 = (b - a) / 2, c2 = (b + a) / 2, sum = 0;
        for (int i = 0; i < N; i++)
            sum += weights[i] * f.Invoke(c1 * lroots[i] + c2);
        return c1 * sum;
    }
 
    //..................Main...............................
    public static string Combine(double[] arrayD) {
        return string.Join("", "", arrayD);	
    }
 
    public static void Main() {
        int N = 5;
 
        var lcoeff = legeCoef(N);
 
        double[] roots;
        double[] weights;
        legeRoots(lcoeff, N, out roots, out weights);
 
        var integrateResult = legeInte(x=>Math.Exp(x), N, weights, roots, -3, 3);
 
        Console.WriteLine(""Roots:   "" + Combine(roots));
        Console.WriteLine(""Weights: "" + Combine(weights)+ ""\n"" );
        Console.WriteLine(""integral: "" + integrateResult );
        Console.WriteLine(""actual:   "" + (Math.Exp(3)-Math.Exp(-3)) );
    }
 
 
}",2629,88
30975,http://rosettacode.org/wiki/Old_lady_swallowed_a_fly,Old lady swallowed a fly,"Task

Present a program which emits the lyrics to the song   I Knew an Old Lady Who Swallowed a Fly,   taking advantage of the repetitive structure of the song's lyrics. 

This song has multiple versions with slightly different lyrics, so all these programs might not emit identical output.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
 
namespace OldLady
{
    internal class Program
    {
        private const string reason = ""She swallowed the {0} to catch the {1}"";
        private static readonly string[] creatures = {""fly"", ""spider"", ""bird"", ""cat"", ""dog"", ""goat"", ""cow"", ""horse""};
 
        private static readonly string[] comments =
        {
            ""I don't know why she swallowed that fly.\nPerhaps she'll die\n"",
            ""That wiggled and jiggled and tickled inside her"",
            ""How absurd, to swallow a bird"",
            ""Imagine that. She swallowed a cat"",
            ""What a hog to swallow a dog"",
            ""She just opened her throat and swallowed that goat"",
            ""I don't know how she swallowed that cow"",
            ""She's dead of course""
        };
 
        private static void Main()
        {
            int max = creatures.Length;
            for (int i = 0; i < max; i++)
            {
                Console.WriteLine(""There was an old lady who swallowed a {0}"", creatures[i]);
                Console.WriteLine(comments[i]);
                for (int j = i; j > 0 && i < max - 1; j--)
                {
                    Console.WriteLine(reason, creatures[j], creatures[j - 1]);
                    if (j == 1)
                    {
                        Console.WriteLine(comments[j - 1]);
                    }
                }
            }
            Console.Read();
        }
    }
}",1430,41
31094,http://rosettacode.org/wiki/Numerical_integration,Numerical integration,"Write functions to calculate the definite integral of a function  ƒ(x)  using all five of the following methods:

 rectangular
 left
 right
 midpoint
 trapezium
 Simpson's
 composite
Your functions should take in the upper and lower bounds (a and b), and the number of approximations to make in that range (n).

Assume that your example already has a function that gives values for  ƒ(x) .

Simpson's method is defined by the following pseudo-code:


 Pseudocode: Simpson's method, composite



procedure quad_simpson_composite(f, a, b, n)
    h := (b - a) / n
    sum1 := f(a + h/2)
    sum2 := 0

    loop on i from 1 to (n - 1)
        sum1 := sum1 + f(a + h * i + h/2)
        sum2 := sum2 + f(a + h * i)
                                            
    answer := (h / 6) * (f(a) + f(b) + 4*sum1 + 2*sum2)




Demonstrate your function by showing the results for:

   ƒ(x) = x3,       where   x   is     [0,1],       with           100 approximations.   The exact result is     0.25               (or 1/4)
   ƒ(x) = 1/x,     where   x   is   [1,100],     with        1,000 approximations.   The exact result is     4.605170+     (natural log of 100)
   ƒ(x) = x,         where   x   is   [0,5000],   with 5,000,000 approximations.   The exact result is   12,500,000
   ƒ(x) = x,         where   x   is   [0,6000],   with 6,000,000 approximations.   The exact result is   18,000,000


See also

   Active object for integrating a function of real time.
   Special:PrefixIndex/Numerical integration for other integration methods.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
public class Interval
{
    public Interval(double leftEndpoint, double size)
    {
        LeftEndpoint = leftEndpoint;
        RightEndpoint = leftEndpoint + size;
    }
 
    public double LeftEndpoint
    {
        get;
        set;
    }
 
    public double RightEndpoint
    {
        get;
        set;
    }
 
    public double Size
    {
        get
        {
            return RightEndpoint - LeftEndpoint;
        }
    }
 
    public double Center
    {
        get
        {
            return (LeftEndpoint + RightEndpoint) / 2;
        }
    }
 
    public IEnumerable<Interval> Subdivide(int subintervalCount)
    {
        double subintervalSize = Size / subintervalCount;
        return Enumerable.Range(0, subintervalCount).Select(index => new Interval(LeftEndpoint + index * subintervalSize, subintervalSize));
    }
}
 
public class DefiniteIntegral
{
    public DefiniteIntegral(Func<double, double> integrand, Interval domain)
    {
        Integrand = integrand;
        Domain = domain;
    }
 
    public Func<double, double> Integrand
    {
        get;
        set;
    }
 
    public Interval Domain
    {
        get;
        set;
    }
 
    public double SampleIntegrand(ApproximationMethod approximationMethod, Interval subdomain)
    {
        switch (approximationMethod)
        {
            case ApproximationMethod.RectangleLeft:
                return Integrand(subdomain.LeftEndpoint);
            case ApproximationMethod.RectangleMidpoint:
                return Integrand(subdomain.Center);
            case ApproximationMethod.RectangleRight:
                return Integrand(subdomain.RightEndpoint);
            case ApproximationMethod.Trapezium:
                return (Integrand(subdomain.LeftEndpoint) + Integrand(subdomain.RightEndpoint)) / 2;
            case ApproximationMethod.Simpson:
                return (Integrand(subdomain.LeftEndpoint) + 4 * Integrand(subdomain.Center) + Integrand(subdomain.RightEndpoint)) / 6;
            default:
                throw new NotImplementedException();
        }
    }
 
    public double Approximate(ApproximationMethod approximationMethod, int subdomainCount)
    {
        return Domain.Size * Domain.Subdivide(subdomainCount).Sum(subdomain => SampleIntegrand(approximationMethod, subdomain)) / subdomainCount;
    }
 
    public enum ApproximationMethod
    {
        RectangleLeft,
        RectangleMidpoint,
        RectangleRight,
        Trapezium,
        Simpson
    }
}
 
public class Program
{
    private static void TestApproximationMethods(DefiniteIntegral integral, int subdomainCount)
    {
        foreach (DefiniteIntegral.ApproximationMethod approximationMethod in Enum.GetValues(typeof(DefiniteIntegral.ApproximationMethod)))
        {
            Console.WriteLine(integral.Approximate(approximationMethod, subdomainCount));
        }
    }
 
    public static void Main()
    {
        TestApproximationMethods(new DefiniteIntegral(x => x * x * x, new Interval(0, 1)), 10000);
        TestApproximationMethods(new DefiniteIntegral(x => 1 / x, new Interval(1, 99)), 1000);
        TestApproximationMethods(new DefiniteIntegral(x => x, new Interval(0, 5000)), 500000);
        TestApproximationMethods(new DefiniteIntegral(x => x, new Interval(0, 6000)), 6000000);
    }
}",3360,119
31149,http://rosettacode.org/wiki/One-dimensional_cellular_automata,One-dimensional cellular automata,"Assume an array of cells with an initial distribution of live and dead cells,
and imaginary cells off the end of the array having fixed values.

Cells in the next generation of the array are calculated based on the value of the cell and its left and right nearest neighbours in the current generation.

If, in the following table, a live cell is represented by 1 and a dead cell by 0 then to generate the value of the cell at a particular index in the array of cellular values you use the following table:

000 -> 0  # 
001 -> 0  #
010 -> 0  # Dies without enough neighbours
011 -> 1  # Needs one neighbour to survive
100 -> 0  #
101 -> 1  # Two neighbours giving birth
110 -> 1  # Needs one neighbour to survive
111 -> 0  # Starved to death.
",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace prog
{
	class MainClass
	{	
		const int n_iter = 10;
		static int[] f = { 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0 };
 
		public static void Main (string[] args)
		{
			for( int i=0; i<f.Length; i++ )
				Console.Write( f[i]==0 ? ""-"" : ""#"" );
			Console.WriteLine("""");			
 
			int[] g = new int[f.Length];
			for( int n=n_iter; n!=0; n-- )
			{
				for( int i=1; i<f.Length-1; i++ )
				{
					if ( (f[i-1] ^ f[i+1]) == 1 ) g[i] = f[i];
					else if ( f[i] == 0 && (f[i-1] & f[i+1]) == 1 ) g[i] = 1;
					else g[i] = 0;
				}
				g[0] = ( (f[0] & f[1]) == 1 ) ? 1 : 0;
				g[g.Length-1] = ( (f[f.Length-1] & f[f.Length-2]) == 1 ) ? 1 : 0;
 
				int[] tmp = f;
				f = g;
				g = tmp;
 
				for( int i=0; i<f.Length; i++ )
					Console.Write( f[i]==0 ? ""-"" : ""#"" );
				Console.WriteLine("""");
			}			
		}
	}
}",886,39
31249,http://rosettacode.org/wiki/Null_object,Null object,"
Null (or nil) is the computer science concept of an undefined or unbound object.
Some languages have an explicit way to access the null object, and some don't.
Some languages distinguish the null object from undefined values, and some don't.



Task

Show how to access null in your language by checking to see if an object is equivalent to the null object.


This task is not about whether a variable is defined. The task is about ""null""-like values in various languages, which may or may not be related to the defined-ness of variables in your language.
",#C.23,C#,"if (foo == null)
    Console.WriteLine(""foo is null"");",54,2
31335,http://rosettacode.org/wiki/Number_reversal_game,Number reversal game,"Task

Given a jumbled list of the numbers   1   to   9   that are definitely   not   in
ascending order.

Show the list,   and then ask the player how many digits from the
left to reverse.

Reverse those digits,   then ask again,   until all the digits end up in ascending order.



The score is the count of the reversals needed to attain the ascending order.



Note: Assume the player's input does not need extra validation.



Related tasks

   Sorting algorithms/Pancake sort
   Pancake sorting.
   Topswops

",#C.23,C#,"using System;
using System.Linq;
 
class Program
{
    static void Main(string[] args)
    {
        var r = new Random();
 
        var tries = 1;
        var sorted = Enumerable.Range(1, 9).ToList();
        var values = sorted.OrderBy(x => r.Next(-1, 1)).ToList();
 
        while (Enumerable.SequenceEqual(sorted, values)) {
            values = sorted.OrderBy(x => r.Next(-1, 1)).ToList();
        }
 
        //values = ""1 3 9 2 7 5 4 8 6"".Split().Select(x => int.Parse(x)).ToList();
 
        while (!Enumerable.SequenceEqual(sorted, values))
        {
            Console.Write(""# {0}: LIST: {1} - Flip how many? "", tries, String.Join("" "", values));
 
            values.Reverse(0, int.Parse(Console.ReadLine()));
            tries += 1;
        }
 
        Console.WriteLine(""\nYou took {0} attempts to put the digits in order!"", tries - 1);
        Console.ReadLine();
    }
}",886,31
31416,http://rosettacode.org/wiki/Number_names,Number names,"Task

Show how to spell out a number in English.

You can use a preexisting implementation or roll your own, but you should support inputs up to at least one million (or the maximum value of your language's default bounded integer type, if that's less).

Support for inputs other than positive integers (like zero, negative integers, and floating-point numbers) is optional.



Related task

   Spelling of ordinal numbers.

",#C.23,C#,"using System;
 
class NumberNamer {
    static readonly string[] incrementsOfOne =
            { ""zero"",    ""one"",     ""two"",       ""three"",    ""four"",
              ""five"",    ""six"",     ""seven"",     ""eight"",    ""nine"",
              ""ten"",     ""eleven"",  ""twelve"",    ""thirteen"", ""fourteen"",
              ""fifteen"", ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen"" };
 
    static readonly string[] incrementsOfTen =
            { """",      """",      ""twenty"",  ""thirty"", ""fourty"",
              ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety"" };
 
    const string millionName = ""million"",
                 thousandName = ""thousand"",
                 hundredName = ""hundred"",
                 andName = ""and"";
 
 
    public static string GetName( int i ) {
        string output = """";
        if( i >= 1000000 ) {
            output += ParseTriplet( i / 1000000 ) + "" "" + millionName;
            i %= 1000000;
            if( i == 0 ) return output;
        }
 
        if( i >= 1000 ) {
            if( output.Length > 0 ) {
                output += "", "";
            }
            output += ParseTriplet( i / 1000 ) + "" "" + thousandName;
            i %= 1000;
            if( i == 0 ) return output;
        }
 
        if( output.Length > 0 ) {
            output += "", "";
        }
        output += ParseTriplet( i );
        return output;
    }
 
 
    static string ParseTriplet( int i ) {
        string output = """";
        if( i >= 100 ) {
            output += incrementsOfOne[i / 100] + "" "" + hundredName;
            i %= 100;
            if( i == 0 ) return output;
        }
 
        if( output.Length > 0 ) {
            output += "" "" + andName + "" "";
        }
        if( i >= 20 ) {
            output += incrementsOfTen[i / 10];
            i %= 10;
            if( i == 0 ) return output;
        }
 
        if( output.Length > 0 ) {
            output += "" "";
        }
        output += incrementsOfOne[i];
        return output;
    }
}
 
 
class Program { // Test class
    static void Main( string[] args ) {
        Console.WriteLine( NumberNamer.GetName( 1 ) );
        Console.WriteLine( NumberNamer.GetName( 234 ) );
        Console.WriteLine( NumberNamer.GetName( 31337 ) );
        Console.WriteLine( NumberNamer.GetName( 987654321 ) );
    }
}
 ",2285,79
31847,http://rosettacode.org/wiki/Nonoblock,Nonoblock,"Nonoblock is a chip off the old Nonogram puzzle.



Given

 The number of cells in a row.
 The size of each, (space separated), connected block of cells to fit in the row, in left-to right order.


Task
 
 show all possible positions. 
 show the number of positions of the blocks for the following cases within the row. 
 show all output on this page. 
 use a ""neat"" diagram of the block positions.


Enumerate the following configurations

   5   cells   and   [2, 1]   blocks
   5   cells   and   []   blocks   (no blocks)
   10   cells   and   [8]   blocks
   15   cells   and   [2, 3, 2, 3]   blocks
   5   cells   and   [2, 3]   blocks   (should give some indication of this not being possible)


Example

Given a row of five cells and a block of two cells followed by a block of one cell - in that order, the example could be shown as:

   |_|_|_|_|_| # 5 cells and [2, 1] blocks

And would expand to the following 3 possible rows of block positions:

   |A|A|_|B|_|
   |A|A|_|_|B|
   |_|A|A|_|B|



Note how the sets of blocks are always separated by a space.

Note also that it is not necessary for each block to have a separate letter.
Output approximating

This:

                       |#|#|_|#|_|
                       |#|#|_|_|#|
                       |_|#|#|_|#|

This would also work:

                       ##.#.
                       ##..#
                      .##.#



An algorithm

 Find the minimum space to the right that is needed to legally hold all but the leftmost block of cells (with a space between blocks remember).
 The leftmost cell can legitimately be placed in all positions from the LHS up to a RH position that allows enough room for the rest of the blocks.
 for each position of the LH block recursively compute the position of the rest of the blocks in the remaining space to the right of the current placement of the LH block.
(This is the algorithm used in the Nonoblock#Python solution).



Reference

 The blog post Nonogram puzzle solver (part 1) Inspired this task and donated its Nonoblock#Python solution.

",#C.23,C#,"using System;
using System.Linq;
using System.Text;
 
public static class Nonoblock
{
    public static void Main() {
        Positions(5, 2,1);
        Positions(5);
        Positions(10, 8);
        Positions(15, 2,3,2,3);
        Positions(5, 2,3);
    }
 
    public static void Positions(int cells, params int[] blocks) {
        if (cells < 0 || blocks == null || blocks.Any(b => b < 1)) throw new ArgumentOutOfRangeException();
        Console.WriteLine($""{cells} cells with [{string.Join("", "", blocks)}]"");
        if (blocks.Sum() + blocks.Length - 1 > cells) {
            Console.WriteLine(""No solution"");
            return;
        }
        var spaces = new int[blocks.Length + 1];
        int total = -1;
        for (int i = 0; i < blocks.Length; i++) {
            total += blocks[i] + 1;
            spaces[i+1] = total;
        }
        spaces[spaces.Length - 1] = cells - 1;
        var sb = new StringBuilder(string.Join(""."", blocks.Select(b => new string('#', b))).PadRight(cells, '.'));
        Iterate(sb, spaces, spaces.Length - 1, 0);
        Console.WriteLine();
    }
 
    private static void Iterate(StringBuilder output, int[] spaces, int index, int offset) {
        Console.WriteLine(output.ToString());
        if (index <= 0) return;
        int count = 0;
        while (output[spaces[index] - offset] != '#') {
            count++;
            output.Remove(spaces[index], 1);
            output.Insert(spaces[index-1], '.');
            spaces[index-1]++;
            Iterate(output, spaces, index - 1, 1);
        }
        if (offset == 0) return;
        spaces[index-1] -= count;
        output.Remove(spaces[index-1], count);
        output.Insert(spaces[index] - count, ""."", count);
    }
 
}",1737,51
31899,http://rosettacode.org/wiki/Non-decimal_radices/Input,Non-decimal radices/Input,"It is common to have a string containing a number written in some format, with the most common ones being decimal, hexadecimal, octal and binary. Such strings are found in many places (user interfaces, configuration files, XML data, network protocols, etc.)

This task requires parsing of such a string (which may be assumed to contain nothing else) using the language's built-in facilities if possible. Parsing of decimal strings is required, parsing of other formats is optional but should be shown (i.e., if the language can parse in base-19 then that should be illustrated).

The solutions may assume that the base of the number in the string is known. In particular, if your language has a facility to guess the base of a number by looking at a prefix (e.g. ""0x"" for hexadecimal) or other distinguishing syntax as it parses it, please show that.

The reverse operation is in task Non-decimal radices/Output

For general number base conversion, see Non-decimal radices/Convert.
",#C.23,C#,"using System;
 
class Program
{
    static void Main()
    {
        var value = ""100"";
        var fromBases = new[] { 2, 8, 10, 16 };
        var toBase = 10;
        foreach (var fromBase in fromBases)
        {
            Console.WriteLine(""{0} in base {1} is {2} in base {3}"",
                value, fromBase, Convert.ToInt32(value, fromBase), toBase);
        }
    }
}",376,16
31926,http://rosettacode.org/wiki/Non-decimal_radices/Output,Non-decimal radices/Output,"Programming languages often have built-in routines to convert a non-negative integer for printing in different number bases. Such common number bases might include binary, Octal and Hexadecimal.



Task

Print a small range of integers in some different bases, as supported by standard routines of your programming language.



Note

This is distinct from Number base conversion as a user-defined conversion function is not asked for.)

The reverse operation is Common number base parsing.



",#C.23,C#," 
using System;
 
namespace NonDecimalRadicesOutput
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int i = 0; i < 42; i++)
            {
                string binary = Convert.ToString(i, 2);
                string octal = Convert.ToString(i, 8);
                string hexadecimal = Convert.ToString(i, 16);
                Console.WriteLine(string.Format(""Decimal: {0}, Binary: {1}, Octal: {2}, Hexadecimal: {3}"", i, binary, octal, hexadecimal));
            }
 
            Console.ReadKey();
        }
    }
}
 ",562,22
31944,http://rosettacode.org/wiki/Nonogram_solver,Nonogram solver,"A nonogram is a puzzle that provides
numeric clues used to fill in a grid of cells,
establishing for each cell whether it is filled or not.
The puzzle solution is typically a picture of some kind.

Each row and column of a rectangular grid is annotated with the lengths
of its distinct runs of occupied cells.
Using only these lengths you should find one valid configuration
of empty and occupied cells, or show a failure message.

Example
Problem:                 Solution:

. . . . . . . .  3       . # # # . . . .  3
. . . . . . . .  2 1     # # . # . . . .  2 1
. . . . . . . .  3 2     . # # # . . # #  3 2
. . . . . . . .  2 2     . . # # . . # #  2 2
. . . . . . . .  6       . . # # # # # #  6
. . . . . . . .  1 5     # . # # # # # .  1 5
. . . . . . . .  6       # # # # # # . .  6
. . . . . . . .  1       . . . . # . . .  1
. . . . . . . .  2       . . . # # . . .  2
1 3 1 7 5 3 4 3          1 3 1 7 5 3 4 3
2 1 5 1                  2 1 5 1
The problem above could be represented by two lists of lists:

x = [[3], [2,1], [3,2], [2,2], [6], [1,5], [6], [1], [2]]
y = [[1,2], [3,1], [1,5], [7,1], [5], [3], [4], [3]]
A more compact representation of the same problem uses strings,
where the letters represent the numbers, A=1, B=2, etc:

x = ""C BA CB BB F AE F A B""
y = ""AB CA AE GA E C D C""
Task
For this task, try to solve the 4 problems below, read from a “nonogram_problems.txt” file that has this content
(the blank lines are separators):

C BA CB BB F AE F A B
AB CA AE GA E C D C

F CAC ACAC CN AAA AABB EBB EAA ECCC HCCC
D D AE CD AE A DA BBB CC AAB BAA AAB DA AAB AAA BAB AAA CD BBA DA

CA BDA ACC BD CCAC CBBAC BBBBB BAABAA ABAD AABB BBH BBBD ABBAAA CCEA AACAAB BCACC ACBH DCH ADBE ADBB DBE ECE DAA DB CC
BC CAC CBAB BDD CDBDE BEBDF ADCDFA DCCFB DBCFC ABDBA BBF AAF BADB DBF AAAAD BDG CEF CBDB BBB FC

E BCB BEA BH BEK AABAF ABAC BAA BFB OD JH BADCF Q Q R AN AAN EI H G
E CB BAB AAA AAA AC BB ACC ACCA AGB AIA AJ AJ ACE AH BAF CAG DAG FAH FJ GJ ADK ABK BL CM
Extra credit: generate nonograms with unique solutions, of desired height and width.



This task is the problem n.98 of the ""99 Prolog Problems"" by Werner Hett (also thanks to Paul Singleton for the idea and the examples).




 Related tasks
 Nonoblock.


See also
 Arc Consistency Algorithm
 http://www.haskell.org/haskellwiki/99_questions/Solutions/98 (Haskell)
 http://twanvl.nl/blog/haskell/Nonograms (Haskell)
 http://picolisp.com/5000/!wiki?99p98 (PicoLisp)

",#C.23,C#,"using System;
using System.Collections.Generic;
using static System.Linq.Enumerable;
 
public static class NonogramSolver
{
    public static void Main2() {
        foreach (var (x, y) in new [] {
            (""C BA CB BB F AE F A B"", ""AB CA AE GA E C D C""),
            (""F CAC ACAC CN AAA AABB EBB EAA ECCC HCCC"",
                ""D D AE CD AE A DA BBB CC AAB BAA AAB DA AAB AAA BAB AAA CD BBA DA""),
            (""CA BDA ACC BD CCAC CBBAC BBBBB BAABAA ABAD AABB BBH BBBD ABBAAA CCEA AACAAB BCACC ACBH DCH ADBE ADBB DBE ECE DAA DB CC"",
                ""BC CAC CBAB BDD CDBDE BEBDF ADCDFA DCCFB DBCFC ABDBA BBF AAF BADB DBF AAAAD BDG CEF CBDB BBB FC""),
            (""E BCB BEA BH BEK AABAF ABAC BAA BFB OD JH BADCF Q Q R AN AAN EI H G"",
                ""E CB BAB AAA AAA AC BB ACC ACCA AGB AIA AJ AJ ACE AH BAF CAG DAG FAH FJ GJ ADK ABK BL CM"")
            })
        {
            Solve(x, y);
            Console.WriteLine();
        }
    }
 
    static void Solve(string rowLetters, string columnLetters) {
        var r = rowLetters.Split("" "").Select(row => row.Select(s => s - 'A' + 1).ToArray()).ToArray();
        var c = columnLetters.Split("" "").Select(column => column.Select(s => s - 'A' + 1).ToArray()).ToArray();
        Solve(r, c);
    }
 
    static void Solve(int[][] rowRuns, int[][] columnRuns) {
        int len = columnRuns.Length;
        var rows = rowRuns.Select(row => Generate(len, row)).ToList();
        var columns = columnRuns.Select(column => Generate(rowRuns.Length, column)).ToList();
        Reduce(rows, columns);
        foreach (var list in rows) {
            if (list.Count != 1) Console.WriteLine(Repeat('?', len).Spaced());
            else Console.WriteLine(list[0].ToString().PadLeft(len, '0').Replace('1', '#').Replace('0', '.').Reverse().Spaced());
        }
    }
 
    static List<BitSet> Generate(int length, params int[] runs) {
        var list = new List<BitSet>();
        BitSet initial = BitSet.Empty;
        int[] sums = new int[runs.Length];
        sums[0] = 0;
        for (int i = 1; i < runs.Length; i++) sums[i] = sums[i - 1] + runs[i - 1] + 1;
        for (int r = 0; r < runs.Length; r++) initial = initial.AddRange(sums[r], runs[r]);
        Generate(list, BitSet.Empty.Add(length), runs, sums, initial, 0, 0);
        return list;
    }
 
    static void Generate(List<BitSet> result, BitSet max, int[] runs, int[] sums, BitSet current, int index, int shift) {
        if (index == runs.Length) {
            result.Add(current);
            return;
        }
        while (current.Value < max.Value) {
            Generate(result, max, runs, sums, current, index + 1, shift);
            current = current.ShiftLeftAt(sums[index] + shift);
            shift++;
        }
    }
 
    static void Reduce(List<List<BitSet>> rows, List<List<BitSet>> columns) {
        for (int count = 1; count > 0; ) {
            foreach (var (rowIndex, row) in rows.WithIndex()) {
                var allOn  = row.Aggregate((a, b) => a & b);
                var allOff = row.Aggregate((a, b) => a | b);
                foreach (var (columnIndex, column) in columns.WithIndex()) {
                    count  = column.RemoveAll(c => allOn.Contains(columnIndex) && !c.Contains(rowIndex));
                    count += column.RemoveAll(c => !allOff.Contains(columnIndex) && c.Contains(rowIndex));
                }
            }
            foreach (var (columnIndex, column) in columns.WithIndex()) {
                var allOn  = column.Aggregate((a, b) => a & b);
                var allOff = column.Aggregate((a, b) => a | b);
                foreach (var (rowIndex, row) in rows.WithIndex()) {
                    count += row.RemoveAll(r => allOn.Contains(rowIndex) && !r.Contains(columnIndex));
                    count += row.RemoveAll(r => !allOff.Contains(rowIndex) && r.Contains(columnIndex));
                }
            }
        }
    }
 
    static IEnumerable<(int index, T element)> WithIndex<T>(this IEnumerable<T> source) {
        int i = 0;
        foreach (T element in source) {
            yield return (i++, element);
        }
    }
 
    static string Reverse(this string s) {
        char[] array = s.ToCharArray();
        Array.Reverse(array);
        return new string(array);
    }
 
    static string Spaced(this IEnumerable<char> s) => string.Join("" "", s);
 
    struct BitSet //Unused functionality elided.
    {
        public static BitSet Empty => default;
        private readonly int bits;
        public int Value => bits;
 
        private BitSet(int bits) => this.bits = bits;
 
        public BitSet Add(int item) => new BitSet(bits | (1 << item));
        public BitSet AddRange(int start, int count) => new BitSet(bits | (((1 << (start + count)) - 1) - ((1 << start) - 1)));
        public bool Contains(int item) => (bits & (1 << item)) != 0;
        public BitSet ShiftLeftAt(int index)  => new BitSet((bits >> index << (index + 1)) | (bits & ((1 << index) - 1)));
        public override string ToString() => Convert.ToString(bits, 2);
 
        public static BitSet operator &(BitSet a, BitSet b) => new BitSet(a.bits & b.bits);
        public static BitSet operator |(BitSet a, BitSet b) => new BitSet(a.bits | b.bits);
    }
 
}",5229,117
31990,http://rosettacode.org/wiki/Non-continuous_subsequences,Non-continuous subsequences,"Consider some sequence of elements. (It differs from a mere set of elements by having an ordering among members.)

A subsequence contains some subset of the elements of this sequence, in the same order.

A continuous subsequence is one in which no elements are missing between the first and last elements of the subsequence.

Note: Subsequences are defined structurally, not by their contents.
So a sequence a,b,c,d will always have the same subsequences and continuous subsequences, no matter which values are substituted; it may even be the same value.


Task: Find all non-continuous subsequences for a given sequence.



Example

For the sequence   1,2,3,4,   there are five non-continuous subsequences, namely:

   1,3
   1,4
   2,4
   1,3,4
   1,2,4


Goal

There are different ways to calculate those subsequences.

Demonstrate algorithm(s) that are natural for the language.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
class Program
{
    public static void Main() {
        var sequence = new[] { ""A"", ""B"", ""C"", ""D"" };
        foreach (var subset in Subsets(sequence.Length).Where(s => !IsContinuous(s))) {
            Console.WriteLine(string.Join("" "", subset.Select(i => sequence[i])));
        }
    }
 
    static IEnumerable<List<int>> Subsets(int length) {
        int[] values = Enumerable.Range(0, length).ToArray();
        var stack = new Stack<int>(length);
        for (int i = 0; stack.Count > 0 || i < length; ) {
            if (i < length) {
                stack.Push(i++);
                yield return (from index in stack.Reverse() select values[index]).ToList();
            } else {
                i = stack.Pop() + 1;
                if (stack.Count > 0) i = stack.Pop() + 1;
            }
        }
    }
 
    static bool IsContinuous(List<int> list) => list[list.Count - 1] - list[0] + 1 == list.Count;
 
}",983,30
32110,http://rosettacode.org/wiki/Nim_game,Nim game,"Nim game

You are encouraged to solve this task according to the task description, using any language you may know.
Nim is a simple game where the second player ─── if they know the trick ─── will always win.



The game has only 3 rules:

   start with   12   tokens
   each player takes   1,  2,  or  3   tokens in turn
  the player who takes the last token wins.


To win every time,   the second player simply takes 4 minus the number the first player took.   So if the first player takes 1,   the second takes 3 ─── if the first player takes 2,   the second should take 2 ─── and if the first player takes 3,   the second player will take 1.



Task

Design a simple Nim game where the human player goes first, and the computer always wins. The game should enforce the rules.



",#C.23,C#," 
using System;
 
namespace nimGame
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(""There are twelve tokens.\n"" +
                    ""You can take 1, 2, or 3 on your turn.\n"" +
                    ""Whoever takes the last token wins.\n"");
 
            int tokens = 12;
 
            while (tokens > 0)
            {
                Console.WriteLine(""There are "" + tokens + "" remaining."");
                Console.WriteLine(""How many do you take?"");
                int playertake = Convert.ToInt32(Console.ReadLine());
 
                if (playertake < 1 | playertake > 3)
                {
                    Console.WriteLine(""1, 2, or 3 only."");
                }
                else
                {
                    tokens -= playertake;
                    Console.WriteLine(""I take "" + (4 - playertake) + ""."");
                    tokens -= (4 - playertake);
                }
            }
            Console.WriteLine(""I win again."");
            Console.ReadLine();
        }
 
    }
}
 ",1066,39
32113,http://rosettacode.org/wiki/Nested_function,Nested function,"In many languages, functions can be nested, resulting in outer functions and inner functions. The inner function can access variables from the outer function. In most languages, the inner function can also modify variables in the outer function.



Task
 
Write a program consisting of two nested functions that prints the following text.

1. first
2. second
3. third

The outer function (called MakeList or equivalent) is responsible for creating the list as a whole and is given the separator "". "" as argument. It also defines a counter variable to keep track of the item number. This demonstrates how the inner function can influence the variables in the outer function.

The inner function (called MakeItem or equivalent) is responsible for creating a list item. It accesses the separator from the outer function and modifies the counter.



References

 Nested function

",#C.23,C#,"string MakeList(string separator)
{
    int counter = 1;
 
    Func<string, string> makeItem = item => counter++ + separator + item + ""\n"";
 
    return makeItem(""first"") + makeItem(""second"") + makeItem(""third"");
}
 
Console.WriteLine(MakeList("". ""));",251,10
32167,http://rosettacode.org/wiki/Negative_base_numbers,Negative base numbers,"Negative base numbers are an alternate way to encode numbers without the need for a minus sign. Various negative bases may be used including negadecimal (base -10), negabinary (-2) and negaternary (-3).[1][2]



Task

Encode the decimal number 10 as negabinary (expect 11110)
Encode the decimal number 146 as negaternary (expect 21102)
Encode the decimal number 15 as negadecimal (expect 195)
In each of the above cases, convert the encoded number back to decimal.


extra credit

 supply an integer, that when encoded to base   -62   (or something ""higher""),   expresses the 
name of the language being used   (with correct capitalization).   If the computer language has 
non-alphanumeric characters,   try to encode them into the negatory numerals,   or use other 
characters instead.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace NegativeBaseNumbers {
    class Program {
        const string DIGITS = ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"";
 
        static string EncodeNegativeBase(long n, int b) {
            if (b < -62 || b > -1) {
                throw new ArgumentOutOfRangeException(""b"");
            }
            if (n == 0) {
                return ""0"";
            }
            StringBuilder output = new StringBuilder();
            long nn = n;
            while (nn != 0) {
                int rem = (int)(nn % b);
                nn /= b;
                if (rem < 0) {
                    nn++;
                    rem -= b;
                }
                output.Append(DIGITS[rem]);
            }
            return new string(output.ToString().Reverse().ToArray());
        }
 
        static long DecodeNegativeBase(string ns, int b) {
            if (b < -62 || b > -1) {
                throw new ArgumentOutOfRangeException(""b"");
            }
            if (ns == ""0"") {
                return 0;
            }
            long total = 0;
            long bb = 1;
            for (int i = ns.Length - 1; i >= 0; i--) {
                char c = ns[i];
                total += DIGITS.IndexOf(c) * bb;
                bb *= b;
            }
            return total;
        }
 
        static void Main(string[] args) {
            List<Tuple<long, int>> nbl = new List<Tuple<long, int>>() {
                new Tuple<long, int>(10,-2),
                new Tuple<long, int>(146,-3),
                new Tuple<long, int>(15,-10),
                new Tuple<long, int>(-34025238427,-62),
            };
            foreach (var p in nbl) {
                string ns = EncodeNegativeBase(p.Item1, p.Item2);
                Console.WriteLine(""{0,12} encoded in base {1,-3} = {2}"", p.Item1, p.Item2, ns);
                long n = DecodeNegativeBase(ns, p.Item2);
                Console.WriteLine(""{0,12} decoded in base {1,-3} = {2}"", ns, p.Item2, n);
                Console.WriteLine();
            }
        }
    }
}",2139,64
32184,http://rosettacode.org/wiki/Non-decimal_radices/Convert,Non-decimal radices/Convert,"Number base conversion is when you express a stored integer in an integer base, such as in octal (base 8) or binary (base 2). It also is involved when you take a string representing a number in a given base and convert it to the stored integer form. Normally, a stored integer is in binary, but that's typically invisible to the user, who normally enters or sees stored integers as decimal.



Task

Write a function (or identify the built-in function) which is passed a non-negative integer to convert, and another integer representing the base.

It should return a string containing the digits of the resulting number, without leading zeros except for the number   0   itself.

For the digits beyond 9, one should use the lowercase English alphabet, where the digit   a = 9+1,   b = a+1,   etc.

For example:   the decimal number   26   expressed in base   16   would be   1a.

Write a second function which is passed a string and an integer base, and it returns an integer representing that string interpreted in that base.

The programs may be limited by the word size or other such constraint of a given language. There is no need to do error checking for negatives, bases less than 2, or inappropriate digits.



",#C.23,C#," 
public static class BaseConverter {
 
    /// <summary>
    /// Converts a string to a number
    /// </summary>
    /// <returns>The number.</returns>
    /// <param name=""s"">The string to convert.</param>
    /// <param name=""b"">The base number (between 2 and 36).</param>
    public static long stringToLong(string s, int b) {
 
        if ( b < 2 || b > 36 )
            throw new ArgumentException(""Base must be between 2 and 36"", ""b"");
 
        checked {
 
            int slen = s.Length;
            long result = 0;
            bool isNegative = false;
 
            for ( int i = 0; i < slen; i++ ) {
 
                char c = s[i];
                int num;
 
                if ( c == '-' ) {
                    // Negative sign
                    if ( i != 0 )
                        throw new ArgumentException(""A negative sign is allowed only as the first character of the string."", ""s"");
 
                    isNegative = true;
                    continue;
                }
 
                if ( c > 0x2F && c < 0x3A )
                    // Numeric character (subtract from 0x30 ('0') to get numerical value)
                    num = c - 0x30;
                else if ( c > 0x40 && c < 0x5B )
                    // Uppercase letter
                    // Subtract from 0x41 ('A'), then add 10
                    num = c - 0x37;  // 0x37 = 0x41 - 10
                else if ( c > 0x60 && c < 0x7B )
                    // Lowercase letter
                    // Subtract from 0x61 ('a'), then add 10
                    num = c - 0x57;  // 0x57 = 0x61 - 10
                else
                    throw new ArgumentException(""The string contains an invalid character '"" + c + ""'"", ""s"");
 
                // Check that the digit is allowed by the base.
 
                if ( num >= b )
                    throw new ArgumentException(""The string contains a character '"" + c + ""' which is not allowed in base "" + b, ""s"");
 
                // Multiply the result by the base, then add the next digit
 
                result *= b;
                result += num;
 
            }
 
            if ( isNegative )
                result = -result;
 
            return result;
 
        }
 
    }
 
    /// <summary>
    /// Converts a number to a string.
    /// </summary>
    /// <returns>The string.</returns>
    /// <param name=""n"">The number to convert.</param>
    /// <param name=""b"">The base number (between 2 and 36).</param>
    public static string longToString(long n, int b) {
 
        // This uses StringBuilder, so it only works with .NET 4.0 or higher. For earlier versions, the StringBuilder
        // can be replaced with simple string concatenation.
 
        if ( b < 2 || b > 36 )
            throw new ArgumentException(""Base must be between 2 and 36"", ""b"");
 
        // If the base is 10, call ToString() directly, which returns a base-10 string.
 
        if ( b == 10 )
            return n.ToString();
 
        checked {
            long longBase = b;
 
            StringBuilder sb = new StringBuilder();
 
            if ( n < 0 ) {
                // Negative numbers
                n = -n;
                sb.Append('-');
            }
 
            long div = 1;
            while ( n / div >= b )
                // Continue multiplying the dividend by the base until it reaches the greatest power of
                // the base which is less than or equal to the number.
                div *= b;
 
            while ( true ) {
                byte digit = (byte) (n / div);
 
                if ( digit < 10 )
                    // Numeric character (0x30 = '0')
                    sb.Append((char) (digit + 0x30));
                else
                    // Alphabetic character (for digits > 10) (0x61 = 'a')
                    sb.Append((char) (digit + 0x57));  // 0x61 - 10
 
                if ( div == 1 )
                    // Stop when the dividend reaches 1
                    break;
 
                n %= div;
                div /= b;
            }
 
            return sb.ToString();
        }
 
    }
 
}
 ",4093,130
32221,http://rosettacode.org/wiki/Narcissist,Narcissist,"Quoting from the Esolangs wiki page:


A narcissist (or Narcissus program) is the decision-problem version of a quine.



A quine, when run, takes no input, but produces a copy of its own source code at its output. In contrast, a narcissist reads a string of symbols from its input, and produces no output except a ""1"" or ""accept"" if that string matches its own source code, or a ""0"" or ""reject"" if it does not.


For concreteness, in this task we shall assume that symbol = character.

The narcissist should be able to cope with any finite input, whatever its length.

Any form of output is allowed, as long as the program always halts, and ""accept"", ""reject"" and ""not yet finished"" are distinguishable.



",#C.23,C#," 
using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
namespace Narcisisst
{
	class Program
	{
		public static void Main(string[] args)
		{
			const string path = @""E:\Narcisisst"";
			string[] thisFile = Directory.GetFiles(path , ""Program.cs"");
			StringBuilder sb = new StringBuilder();
 
				foreach (string readLine in File.ReadLines(thisFile[0]))
				{
					sb.Append(readLine);
					sb.Append(""\n"");
				}
 
			Console.WriteLine(sb);
			string input =String.Empty;
			       	input = Console.ReadLine();
			       	Console.WriteLine((Regex.IsMatch(sb.ToString(),input))?""accept"":""reject"");
			       	Console.ReadKey();
			 }
	}
}
 ",673,30
32373,http://rosettacode.org/wiki/Naming_conventions,Naming conventions,"Many languages have naming conventions regarding the identifiers used in the language, its libraries, and programs written in the language. Such conventions, which may be classified as de facto or de jure depending on how they are enforced,
often take the form of rules regarding prefixes, suffixes, and the use of upper-case and lower-case characters.

The naming conventions are sometimes a bit haphazard, especially if the language and/or library has gone through periods of evolution. (In this case: give a brief example and description.)

Document (with simple examples where possible) the evolution and current status of these naming conventions.
For example, name conventions for:

 Procedure and operator names. (Intrinsic or external)
 Class, Subclass and instance names.
 Built-in versus libraries names.


If possible, indicate where the naming conventions are implicit, explicit, mandatory or discretionary.
Any tools that enforced the the naming conventions.
Any cases where the naming convention as commonly violated.

If possible, indicate where the convention is used to hint at other issues. For example the C standard library uses a prefix of ""_"" to ""hide"" raw Operating System calls from the non systems-programmer, whereas Python embeds member functions in between ""__"" to make a member function ""private"".

See also

 Wikipedia: Naming convention (programming)

",#C.23,C#,"public enum Planet {
    Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
}
 
[Flags]
public enum Days {
    None = 0,
    Sunday = 1,
    Monday = 2,
    Tuesday = 4,
    Wednesday = 8,
    Thursday = 16,
    Friday = 32,
    Saturday = 64,
    Workdays = Monday | Tuesday | Wednesday | Thursday | Friday
    AllWeek = Sunday | Saturday | Workdays
}",363,17
32391,http://rosettacode.org/wiki/Nth_root,Nth root,"Task

Implement the algorithm to compute the principal   nth   root   





A

n





{\displaystyle {\sqrt[{n}]{A}}}

   of a positive real number   A,   as explained at the   Wikipedia page.


",#C.23,C#," 
static void Main(string[] args)
{
	Console.WriteLine(NthRoot(81,2,.001));
        Console.WriteLine(NthRoot(1000,3,.001));
        Console.ReadLine();
}
 
public static double NthRoot(double A,int n,  double p)
{
	double _n= (double) n;
	double[] x = new double[2];		
	x[0] = A;
	x[1] = A/_n;
	while(Math.Abs(x[0] -x[1] ) > p)
	{
		x[1] = x[0];
		x[0] = (1/_n)*(((_n-1)*x[1]) + (A/Math.Pow(x[1],_n-1)));
 
	}
	return x[0];
}
 ",428,23
32530,http://rosettacode.org/wiki/Named_parameters,Named parameters,"Create a function which takes in a number of arguments which are specified by name rather than (necessarily) position, and show how to call the function. If the language supports reordering the arguments or optionally omitting some of them, note this.

Note:

 Named parameters relies on being able to use the names given to function parameters when the function is defined, when assigning arguments when the function is called.
 For example, if a function were to be defined as define func1( paramname1, paramname2); then it could be called normally as func1(argument1, argument2) and in the called function paramname1 would be associated with argument1 and paramname2 with argument2.
 func1 must also be able to be called in a way that visually binds each parameter to its respective argument, irrespective of argument order, for example: func1(paramname2=argument2, paramname1=argument1) which explicitly makes the same parameter/argument bindings as before.
 Named parameters are often a feature of languages used in safety critical areas such as Verilog and VHDL.
See also:

 Varargs
 Optional parameters
 Wikipedia: Named parameter

",#C.23,C#,"using System;
 
namespace NamedParams
{
    class Program
    {
        static void AddWidget(string parent, float x = 0, float y = 0, string text = ""Default"")
        {
            Console.WriteLine(""parent = {0}, x = {1}, y = {2}, text = {3}"", parent, x, y, text);
        }
 
        static void Main(string[] args)
        {
            AddWidget(""root"", 320, 240, ""First"");
            AddWidget(""root"", text: ""Origin"");
            AddWidget(""root"", 500);
            AddWidget(""root"", text: ""Footer"", y: 400);
        }
    }
}",534,20
32556,http://rosettacode.org/wiki/N-smooth_numbers,N-smooth numbers,"n-smooth   numbers are positive integers which have no prime factors  >  n.

The   n   (when using it in the expression)   n-smooth   is always prime,

there are   no   9-smooth numbers.

1   (unity)   is always included in n-smooth numbers.




2-smooth   numbers are non-negative powers of two.

5-smooth   numbers are also called   Hamming numbers.

7-smooth   numbers are also called    humble   numbers.



A way to express   11-smooth   numbers is:

  11-smooth  =  2i × 3j × 5k × 7m × 11p

           where     i, j, k, m, p ≥ 0  



Task

   calculate and show the first   25   n-smooth numbers   for   n=2   ───►   n=29
   calculate and show   three numbers starting with   3,000   n-smooth numbers   for   n=3   ───►   n=29
   calculate and show twenty numbers starting with  30,000   n-smooth numbers   for   n=503   ───►   n=521   (optional)


All ranges   (for   n)   are to be inclusive, and only prime numbers are to be used.

The (optional) n-smooth numbers for the third range are:   503,   509,   and   521.

Show all n-smooth numbers for any particular   n   in a horizontal list.

Show all output here on this page.



Related tasks

   Hamming numbers
   humble numbers


References

   Wikipedia entry:   Hamming numbers     (this link is re-directed to   Regular number).
   Wikipedia entry:   Smooth number
   OEIS entry:   A000079    2-smooth numbers or non-negative powers of two
   OEIS entry:   A003586    3-smooth numbers
   OEIS entry:   A051037    5-smooth numbers or Hamming numbers
   OEIS entry:   A002473    7-smooth numbers or humble numbers
   OEIS entry:   A051038   11-smooth numbers
   OEIS entry:   A080197   13-smooth numbers
   OEIS entry:   A080681   17-smooth numbers
   OEIS entry:   A080682   19-smooth numbers
   OEIS entry:   A080683   23-smooth numbers

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
 
namespace NSmooth {
    class Program {
        static readonly List<BigInteger> primes = new List<BigInteger>();
        static readonly List<int> smallPrimes = new List<int>();
 
        static Program() {
            primes.Add(2);
            smallPrimes.Add(2);
 
            BigInteger i = 3;
            while (i <= 521) {
                if (IsPrime(i)) {
                    primes.Add(i);
                    if (i <= 29) {
                        smallPrimes.Add((int)i);
                    }
                }
                i += 2;
            }
        }
 
        static bool IsPrime(BigInteger value) {
            if (value < 2) return false;
 
            if (value % 2 == 0) return value == 2;
            if (value % 3 == 0) return value == 3;
 
            if (value % 5 == 0) return value == 5;
            if (value % 7 == 0) return value == 7;
 
            if (value % 11 == 0) return value == 11;
            if (value % 13 == 0) return value == 13;
 
            if (value % 17 == 0) return value == 17;
            if (value % 19 == 0) return value == 19;
 
            if (value % 23 == 0) return value == 23;
 
            BigInteger t = 29;
            while (t * t < value) {
                if (value % t == 0) return false;
                value += 2;
 
                if (value % t == 0) return false;
                value += 4;
            }
 
            return true;
        }
 
        static List<BigInteger> NSmooth(int n, int size) {
            if (n < 2 || n > 521) {
                throw new ArgumentOutOfRangeException(""n"");
            }
            if (size < 1) {
                throw new ArgumentOutOfRangeException(""size"");
            }
 
            BigInteger bn = n;
            bool ok = false;
            foreach (var prime in primes) {
                if (bn == prime) {
                    ok = true;
                    break;
                }
            }
            if (!ok) {
                throw new ArgumentException(""must be a prime number"", ""n"");
            }
 
            BigInteger[] ns = new BigInteger[size];
            ns[0] = 1;
            for (int i = 1; i < size; i++) {
                ns[i] = 0;
            }
 
            List<BigInteger> next = new List<BigInteger>();
            foreach (var prime in primes) {
                if (prime > bn) {
                    break;
                }
                next.Add(prime);
            }
 
            int[] indices = new int[next.Count];
            for (int i = 0; i < indices.Length; i++) {
                indices[i] = 0;
            }
            for (int m = 1; m < size; m++) {
                ns[m] = next.Min();
                for (int i = 0; i < indices.Length; i++) {
                    if (ns[m] == next[i]) {
                        indices[i]++;
                        next[i] = primes[i] * ns[indices[i]];
                    }
                }
            }
 
            return ns.ToList();
        }
 
        static void Println<T>(IEnumerable<T> nums) {
            Console.Write('[');
 
            var it = nums.GetEnumerator();
            if (it.MoveNext()) {
                Console.Write(it.Current);
            }
            while (it.MoveNext()) {
                Console.Write("", "");
                Console.Write(it.Current);
            }
 
            Console.WriteLine(']');
        }
 
        static void Main() {
            foreach (var i in smallPrimes) {
                Console.WriteLine(""The first {0}-smooth numbers are:"", i);
                Println(NSmooth(i, 25));
                Console.WriteLine();
            }
            foreach (var i in smallPrimes.Skip(1)) {
                Console.WriteLine(""The 3,000 to 3,202 {0}-smooth numbers are:"", i);
                Println(NSmooth(i, 3_002).Skip(2_999));
                Console.WriteLine();
            }
            foreach (var i in new int[] { 503, 509, 521 }) {
                Console.WriteLine(""The 30,000 to 3,019 {0}-smooth numbers are:"", i);
                Println(NSmooth(i, 30_019).Skip(29_999));
                Console.WriteLine();
            }
        }
    }
}",4220,140
32692,http://rosettacode.org/wiki/Narcissistic_decimal_number,Narcissistic decimal number,"A   Narcissistic decimal number   is a non-negative integer,   



n


{\displaystyle n}

,   that is equal to the sum of the   



m


{\displaystyle m}

-th   powers of each of the digits in the decimal representation of   



n


{\displaystyle n}

,   where   



m


{\displaystyle m}

   is the number of digits in the decimal representation of   



n


{\displaystyle n}

.



Narcissistic (decimal) numbers are sometimes called   Armstrong   numbers, named after Michael F. Armstrong.

They are also known as   Plus Perfect   numbers.



An example

   if   



n


{\displaystyle n}

   is   153 
   then   



m


{\displaystyle m}

,   (the number of decimal digits)   is   3 
   we have    13 + 53 + 33   =   1 + 125 + 27   =   153  
   and so   153   is a narcissistic decimal number


Task

Generate and show here the first   25   narcissistic decimal numbers.



Note:   




0

1


=
0


{\displaystyle 0^{1}=0}

,   the first in the series.



See also

   the  OEIS entry:     Armstrong (or Plus Perfect, or narcissistic) numbers.
   MathWorld entry:   Narcissistic Number.
   Wikipedia entry:     Narcissistic number.

",#C.23,C#," 
using System;
 
namespace Narcissistic
{
    class Narcissistic
    {
        public bool isNarcissistic(int z)
        {
            if (z < 0) return false;
            string n = z.ToString();
            int t = 0, l = n.Length;
            foreach (char c in n)
                t += Convert.ToInt32(Math.Pow(Convert.ToDouble(c - 48), l));
 
            return t == z;
        }
    }
 
    class Program
    {
        static void Main(string[] args)
        {
            Narcissistic n = new Narcissistic();
            int c = 0, x = 0;
            while (c < 25)
            {
                if (n.isNarcissistic(x))
                {
                    if (c % 5 == 0) Console.WriteLine();
                    Console.Write(""{0,7} "", x);
                    c++;
                }
                x++;
            }
            Console.WriteLine(""\n\nPress any key to continue..."");
            Console.ReadKey();
        }
    }
}
 ",946,41
32711,http://rosettacode.org/wiki/Munching_squares,Munching squares,"Render a graphical pattern where each pixel is colored by the value of 'x xor y' from an arbitrary color table.
",#C.23,C#,"using System.Drawing;
using System.Drawing.Imaging;
using System.Linq;
 
class XORPattern
{
    static void Main()
    {
        var size = 0x100;
        var black = Color.Black.ToArgb();
        var palette = Enumerable.Range(black, size).Select(Color.FromArgb).ToArray();
        using (var image = new Bitmap(size, size))
        {
            for (var x = 0; x < size; x++)
            {
                for (var y = 0; y < size; y++)
                {
                    image.SetPixel(x, y, palette[x ^ y]);
                }
            }
            image.Save(""XORPatternCSharp.png"", ImageFormat.Png);
        }
    }
}",630,24
32827,http://rosettacode.org/wiki/Multisplit,Multisplit,"It is often necessary to split a string into pieces
based on several different (potentially multi-character) separator strings,
while still retaining the information about which separators were present in the input.

This is particularly useful when doing small parsing tasks. 

The task is to write code to demonstrate this.

The function (or procedure or method, as appropriate) should
take an input string and an ordered collection of separators.

The order of the separators is significant: 

The delimiter order represents priority in matching, with the first defined delimiter having the highest priority.
In cases where there would be an ambiguity as to
which separator to use at a particular point
(e.g., because one separator is a prefix of another)
the separator with the highest priority should be used.
Delimiters can be reused and the output from the function should be an ordered sequence of substrings.

Test your code using the input string “a!===b=!=c” and the separators “==”, “!=” and “=”.

For these inputs the string should be parsed as ""a"" (!=) """" (==) ""b"" (=) """" (!=) ""c"", where matched delimiters are shown in parentheses, and separated strings are quoted, so our resulting output is ""a"", empty string, ""b"", empty string, ""c"".
Note that the quotation marks are shown for clarity and do not form part of the output.

Extra Credit: provide information that indicates which separator was matched at each separation point and where in the input string that separator was matched.
",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace Multisplit
{
    internal static class Program
    {
        private static void Main(string[] args)
        {
            foreach (var s in ""a!===b=!=c"".Multisplit(true, ""=="", ""!="", ""="")) // Split the string and return the separators.
            {
                Console.Write(s); // Write the returned substrings and separators to the console.
            }
            Console.WriteLine();
        }
 
        private static IEnumerable<string> Multisplit(this string s, bool returnSeparators = false,
                                                      params string[] delimiters)
        {
            var currentString = new StringBuilder(); /* Initiate the StringBuilder. This will hold the current string to return
                                                      * once we find a separator. */
 
            int index = 0; // Initiate the index counter at 0. This tells us our current position in the string to read.
 
            while (index < s.Length) // Loop through the string.
            {
                // This will get the highest priority separator found at the current index, or null if there are none.
                string foundDelimiter =
                    (from delimiter in delimiters
                     where s.Length >= index + delimiter.Length &&
                           s.Substring(index, delimiter.Length) == delimiter
                     select delimiter).FirstOrDefault();
 
                if (foundDelimiter != null)
                {
                    yield return currentString.ToString(); // Return the current string.
                    if (returnSeparators) // Return the separator, if the user specified to do so.
                        yield return
                            string.Format(""{{\""{0}\"", ({1}, {2})}}"",
                                          foundDelimiter,
                                          index, index + foundDelimiter.Length);
                    currentString.Clear(); // Clear the current string.
                    index += foundDelimiter.Length; // Move the index past the current separator.
                }
                else
                {
                    currentString.Append(s[index++]); // Add the character at this index to the current string.
                }
            }
 
            if (currentString.Length > 0)
                yield return currentString.ToString(); // If we have anything left over, return it.
        }
    }
}",2553,57
32888,http://rosettacode.org/wiki/N%27th,N'th,"Write a function/method/subroutine/... that when given an integer greater than or equal to zero returns a string of the number followed by an apostrophe then the ordinal suffix.



Example

Returns would include 1'st 2'nd 3'rd 11'th 111'th 1001'st 1012'th



Task

Use your routine to show here the output for at least the following (inclusive) ranges of integer inputs:
0..25, 250..265, 1000..1025


Note: apostrophes are now optional to allow correct apostrophe-less English.



",#C.23,C#,"using System;
using System.Linq;
 
class Program
{
    private static string Ordinalize(int i)
    {
        i = Math.Abs(i);
 
        if (new[] {11, 12, 13}.Contains(i%100))
            return i + ""th"";
 
        switch (i%10)
        {
            case 1:
                return i + ""st"";
            case 2:
                return i + ""nd"";
            case 3:
                return i + ""rd"";
            default:
                return i + ""th"";
        }
    }
 
    static void Main()
    {
        Console.WriteLine(string.Join("" "", Enumerable.Range(0, 26).Select(Ordinalize)));
        Console.WriteLine(string.Join("" "", Enumerable.Range(250, 16).Select(Ordinalize)));
        Console.WriteLine(string.Join("" "", Enumerable.Range(1000, 26).Select(Ordinalize)));
    }
}",778,32
32964,http://rosettacode.org/wiki/Munchausen_numbers,Munchausen numbers,"A Munchausen number is a natural number n the sum of whose digits (in base 10), each raised to the power of itself, equals n.

(Munchausen is also spelled: Münchhausen.)

For instance:    3435 = 33 + 44 + 33 + 55 



Task
Find all Munchausen numbers between   1   and   5000.



Also see

 The OEIS entry:  A046253
 The Wikipedia entry:  Perfect digit-to-digit invariant, redirected from Munchausen Number

",#C.23,C#,"Func<char, int> toInt = c => c-'0';
 
foreach (var i in Enumerable.Range(1,5000)
	.Where(n => n == n.ToString()
		.Sum(x => Math.Pow(toInt(x), toInt(x)))))
	Console.WriteLine(i);",178,6
33029,http://rosettacode.org/wiki/Mutual_recursion,Mutual recursion,"Two functions are said to be mutually recursive if the first calls the second,
and in turn the second calls the first.

Write two mutually recursive functions that compute members of the Hofstadter Female and Male sequences defined as:










F
(
0
)



=
1
 
;
 
M
(
0
)
=
0




F
(
n
)



=
n
−
M
(
F
(
n
−
1
)
)
,

n
>
0




M
(
n
)



=
n
−
F
(
M
(
n
−
1
)
)
,

n
>
0.






{\displaystyle {\begin{aligned}F(0)&=1\ ;\ M(0)=0\\F(n)&=n-M(F(n-1)),\quad n>0\\M(n)&=n-F(M(n-1)),\quad n>0.\end{aligned}}}





(If a language does not allow for a solution using mutually recursive functions
then state this rather than give a solution by other means).



",#C.23,C#,"namespace RosettaCode {
    class Hofstadter {
        static public int F(int n) {
            int result = 1;
            if (n > 0) {
                result = n - M(F(n-1));
            }
 
            return result;
        }
 
        static public int M(int n) {
            int result = 0;
            if (n > 0) {
                result = n - F(M(n - 1));
            }
 
            return result;
        }
    }
}",424,21
33140,http://rosettacode.org/wiki/N-queens_problem,N-queens problem,"

Solve the eight queens puzzle.



You can extend the problem to solve the puzzle with a board of size   NxN.

For the number of solutions for small values of   N,   see   OEIS: A000170.



Related tasks

 A* search algorithm
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Knight's tour
 Peaceful chess queen armies
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle

",#C.23,C#,"using System.Collections.Generic;
using static System.Linq.Enumerable;
using static System.Console;
using static System.Math;
 
namespace N_Queens
{
    static class Program
    {
        static void Main(string[] args)
        {
            var n = 8;
            var cols = Range(0, n);
            var combs = cols.Combinations(2).Select(pairs=> pairs.ToArray());
            var solved = from v in cols.Permutations().Select(p => p.ToArray())
                         where combs.All(c => Abs(v[c[0]] - v[c[1]]) != Abs(c[0] - c[1]))
                         select v;
 
            WriteLine($""{n}-queens has {solved.Count()} solutions"");
            WriteLine(""Position is row, value is column:-"");
            var first = string.Join("" "", solved.First());
            WriteLine($""First Solution: {first}"");
            Read();
        }
 
        //Helpers 
        public static IEnumerable<IEnumerable<T>> Permutations<T>(this IEnumerable<T> values)
        {
            if (values.Count() == 1)
                return values.ToSingleton();
 
            return values.SelectMany(v => Permutations(values.Except(v.ToSingleton())), (v, p) => p.Prepend(v));
        }
 
        public static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq) =>
            seq.Aggregate(Empty<T>().ToSingleton(), (a, b) => a.Concat(a.Select(x => x.Append(b))));
 
        public static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq, int numItems) =>
            seq.Combinations().Where(s => s.Count() == numItems);
 
        public static IEnumerable<T> ToSingleton<T>(this T item) { yield return item; }
    }
}",1645,43
33153,http://rosettacode.org/wiki/Multiplicative_order,Multiplicative order,"The multiplicative order of a relative to m is the least positive integer n such that a^n is 1 (modulo m).



Example

The multiplicative order of 37 relative to 1000 is 100 because 37^100 is 1 (modulo 1000), and no number smaller than 100 would do.



One possible algorithm that is efficient also for large numbers is the following: By the Chinese Remainder Theorem, it's enough to calculate the multiplicative order for each prime exponent p^k of m, and
combine the results with the least common multiple operation.

Now the order of a with regard to p^k must divide Φ(p^k). Call this number t, and determine it's factors q^e. Since each multiple of the order will also yield 1 when used as exponent for a, it's enough to find the least d such that (q^d)*(t/(q^e)) yields 1 when used as exponent.



Task

Implement a routine to calculate the multiplicative order along these lines. You may assume that routines to determine the factorization into prime powers are available in some library.


An algorithm for the multiplicative order can be found in Bach & Shallit, Algorithmic Number Theory, Volume I: Efficient Algorithms, The MIT Press, 1996:

Exercise 5.8, page 115:
Suppose you are given a prime p and a complete factorization
of p-1.   Show how to compute the order of an
element a in (Z/(p))* using O((lg p)4/(lg lg p)) bit
operations.
Solution, page 337:
Let the prime factorization of p-1  be q1e1q2e2...qkek . We use the following observation:
if x^((p-1)/qifi) = 1 (mod p) , 
and fi=ei or x^((p-1)/qifi+1) != 1 (mod p) , then qiei-fi||ordp x.   (This follows by combining Exercises 5.1 and 2.10.)
Hence it suffices to find, for each i , the exponent fi  such that the condition above holds.
This can be done as follows: first compute q1e1, q2e2, ... ,
qkek .  This can be done using O((lg p)2) bit operations. Next, compute y1=(p-1)/q1e1, ... , yk=(p-1)/qkek . 
This can be done using O((lg p)2) bit operations. Now, using the binary method,
compute x1=ay1(mod p), ... , xk=ayk(mod p) . 
This can be done using O(k(lg p)3) bit operations, and k=O((lg p)/(lg lg p)) by Theorem 8.8.10.
Finally, for each i , repeatedly raise xi to the qi-th power (mod p) (as many as ei-1  times), checking to see when 1 is obtained.
This can be done using O((lg p)3) steps.
The total cost is dominated by O(k(lg p)3) , which is O((lg p)4/(lg lg p)).



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Numerics;
using System.Threading;
 
namespace MultiplicativeOrder {
    // Taken from https://stackoverflow.com/a/33918233
    public static class PrimeExtensions {
        // Random generator (thread safe)
        private static ThreadLocal<Random> s_Gen = new ThreadLocal<Random>(
          () => {
              return new Random();
          }
        );
 
        // Random generator (thread safe)
        private static Random Gen {
            get {
                return s_Gen.Value;
            }
        }
 
        public static bool IsProbablyPrime(this BigInteger value, int witnesses = 10) {
            if (value <= 1)
                return false;
 
            if (witnesses <= 0)
                witnesses = 10;
 
            BigInteger d = value - 1;
            int s = 0;
 
            while (d % 2 == 0) {
                d /= 2;
                s += 1;
            }
 
            byte[] bytes = new byte[value.ToByteArray().LongLength];
            BigInteger a;
 
            for (int i = 0; i < witnesses; i++) {
                do {
                    Gen.NextBytes(bytes);
 
                    a = new BigInteger(bytes);
                }
                while (a < 2 || a >= value - 2);
 
                BigInteger x = BigInteger.ModPow(a, d, value);
                if (x == 1 || x == value - 1)
                    continue;
 
                for (int r = 1; r < s; r++) {
                    x = BigInteger.ModPow(x, 2, value);
 
                    if (x == 1)
                        return false;
                    if (x == value - 1)
                        break;
                }
 
                if (x != value - 1)
                    return false;
            }
 
            return true;
        }
    }
 
    static class Helper {
        public static BigInteger Sqrt(this BigInteger self) {
            BigInteger b = self;
            while (true) {
                BigInteger a = b;
                b = self / a + a >> 1;
                if (b >= a) return a;
            }
        }
 
        public static long BitLength(this BigInteger self) {
            BigInteger bi = self;
            long bitlength = 0;
            while (bi != 0) {
                bitlength++;
                bi >>= 1;
            }
            return bitlength;
        }
 
        public static bool BitTest(this BigInteger self, int pos) {
            byte[] arr = self.ToByteArray();
            int idx = pos / 8;
            int mod = pos % 8;
            if (idx >= arr.Length) {
                return false;
            }
            return (arr[idx] & (1 << mod)) > 0;
        }
    }
 
    class PExp {
        public PExp(BigInteger prime, int exp) {
            Prime = prime;
            Exp = exp;
        }
 
        public BigInteger Prime { get; }
 
        public int Exp { get; }
    }
 
    class Program {
        static void MoTest(BigInteger a, BigInteger n) {
            if (!n.IsProbablyPrime(20)) {
                Console.WriteLine(""Not computed. Modulus must be prime for this algorithm."");
                return;
            }
            if (a.BitLength() < 100) {
                Console.Write(""ord({0})"", a);
            } else {
                Console.Write(""ord([big])"");
            }
            if (n.BitLength() < 100) {
                Console.Write("" mod {0} "", n);
            } else {
                Console.Write("" mod [big] "");
            }
            BigInteger mob = MoBachShallit58(a, n, Factor(n - 1));
            Console.WriteLine(""= {0}"", mob);
        }
 
        static BigInteger MoBachShallit58(BigInteger a, BigInteger n, List<PExp> pf) {
            BigInteger n1 = n - 1;
            BigInteger mo = 1;
            foreach (PExp pe in pf) {
                BigInteger y = n1 / BigInteger.Pow(pe.Prime, pe.Exp);
                int o = 0;
                BigInteger x = BigInteger.ModPow(a, y, BigInteger.Abs(n));
                while (x > 1) {
                    x = BigInteger.ModPow(x, pe.Prime, BigInteger.Abs(n));
                    o++;
                }
                BigInteger o1 = BigInteger.Pow(pe.Prime, o);
                o1 = o1 / BigInteger.GreatestCommonDivisor(mo, o1);
                mo = mo * o1;
            }
            return mo;
        }
 
        static List<PExp> Factor(BigInteger n) {
            List<PExp> pf = new List<PExp>();
            BigInteger nn = n;
            int e = 0;
            while (!nn.BitTest(e)) e++;
            if (e > 0) {
                nn = nn >> e;
                pf.Add(new PExp(2, e));
            }
            BigInteger s = nn.Sqrt();
            BigInteger d = 3;
            while (nn > 1) {
                if (d > s) d = nn;
                e = 0;
                while (true) {
                    BigInteger div = BigInteger.DivRem(nn, d, out BigInteger rem);
                    if (rem.BitLength() > 0) break;
                    nn = div;
                    e++;
                }
                if (e > 0) {
                    pf.Add(new PExp(d, e));
                    s = nn.Sqrt();
                }
                d = d + 2;
            }
 
            return pf;
        }
 
        static void Main(string[] args) {
            MoTest(37, 3343);
            MoTest(BigInteger.Pow(10, 100) + 1, 7919);
            MoTest(BigInteger.Pow(10, 1000) + 1, 15485863);
            MoTest(BigInteger.Pow(10, 10000) - 1, 22801763489);
            MoTest(1511678068, 7379191741);
            MoTest(3047753288, 2257683301);
        }
    }
}",5583,189
33224,http://rosettacode.org/wiki/Multiple_distinct_objects,Multiple distinct objects,"Create a sequence (array, list, whatever) consisting of n distinct, initialized items of the same type. n should be determined at runtime.

By distinct we mean that if they are mutable, changes to one do not affect all others; if there is an appropriate equality operator they are considered unequal; etc. The code need not specify a particular kind of distinction, but do not use e.g. a numeric-range generator which does not generalize.

By initialized we mean that each item must be in a well-defined state appropriate for its type, rather than e.g. arbitrary previous memory contents in an array allocation. Do not show only an initialization technique which initializes only to ""zero"" values (e.g. calloc() or int a[n] = {}; in C), unless user-defined types can provide definitions of ""zero"" for that type.

This task was inspired by the common error of intending to do this, but instead creating a sequence of n references to the same mutable object; it might be informative to show the way to do that as well, both as a negative example and as how to do it when that's all that's actually necessary.

This task is most relevant to languages operating in the pass-references-by-value style (most object-oriented, garbage-collected, and/or 'dynamic' languages).

See also: Closures/Value capture
",#C.23,C#,"using System;
using System.Linq;
using System.Collections.Generic;
 
List<Foo> foos = Enumerable.Range(1, n).Select(x => new Foo()).ToList();",141,5
33332,http://rosettacode.org/wiki/Multi-dimensional_array,Multi-dimensional array,"For the purposes of this task, the actual memory layout or access method of this data structure is not mandated.

It is enough to:

 State the number and extent of each index to the array.
 Provide specific, ordered, integer indices for all dimensions of the array together with a new value to update the indexed value.
 Provide specific, ordered, numeric indices for all dimensions of the array to obtain the arrays value at that indexed position.


Task

 State if the language supports multi-dimensional arrays in its syntax and usual implementation.
 State whether the language uses row-major or column major order for multi-dimensional array storage, or any other relevant kind of storage.
 Show how to create a four dimensional array in your language and set, access, set to another value; and access the new value of an integer-indexed item of the array.
 The idiomatic method for the language is preferred.
 The array should allow a range of five, four, three and two (or two three four five if convenient), in each of the indices, in order. (For example, if indexing starts at zero for the first index then a range of 0..4 inclusive would suffice).
 State if memory allocation is optimised for the array - especially if contiguous memory is likely to be allocated.
 If the language has exceptional native multi-dimensional array support such as optional bounds checking, reshaping, or being able to state both the lower and upper bounds of index ranges, then this is the task to mention them.


Show all output here, (but you may judiciously use ellipses to shorten repetitive output text).



",#C.23,C#,"var array = new int[,] { //Dimensions are inferred
    { 1, 2, 3 },
    { 4, 5, 6}
}
//Accessing a single element:
array[0, 0] = 999;
 
//To create a 4-dimensional array with all zeroes:
var array = new int[5, 4, 3, 2];",219,9
33354,http://rosettacode.org/wiki/Multiple_regression,Multiple regression,"Task

Given a set of data vectors in the following format:

   
  
    
      
        y
        =
        {
        
          y
          
            1
          
        
        ,
        
          y
          
            2
          
        
        ,
        .
        .
        .
        ,
        
          y
          
            n
          
        
        }
        
      
    
    {\displaystyle y=\{y_{1},y_{2},...,y_{n}\}\,}
  


   
  
    
      
        
          X
          
            i
          
        
        =
        {
        
          x
          
            i
            1
          
        
        ,
        
          x
          
            i
            2
          
        
        ,
        .
        .
        .
        ,
        
          x
          
            i
            n
          
        
        }
        ,
        i
        ∈
        1..
        k
        
      
    
    {\displaystyle X_{i}=\{x_{i1},x_{i2},...,x_{in}\},i\in 1..k\,}
  


Compute the vector 



β
=
{

β

1


,

β

2


,
.
.
.
,

β

k


}


{\displaystyle \beta =\{\beta _{1},\beta _{2},...,\beta _{k}\}}

 using ordinary least squares regression using the following equation:

   
  
    
      
        
          y
          
            j
          
        
        =
        
          Σ
          
            i
          
        
        
          β
          
            i
          
        
        ⋅
        
          x
          
            i
            j
          
        
        ,
        j
        ∈
        1..
        n
      
    
    {\displaystyle y_{j}=\Sigma _{i}\beta _{i}\cdot x_{ij},j\in 1..n}
  


You can assume  y  is given to you as a vector (a one-dimensional array), and  X  is given to you as a two-dimensional array (i.e. matrix).



",#C.23,C#,"using System;
using MathNet.Numerics.LinearRegression;
using MathNet.Numerics.LinearAlgebra;
using MathNet.Numerics.LinearAlgebra.Double;
 
class Program
{
    static void Main(string[] args)
    {
        var col = DenseVector.OfArray(new double[] { 1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65,
            1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83 });
        var X = DenseMatrix.OfColumns(new Vector<double>[] { col.PointwisePower(0), col, col.PointwisePower(2) });
        var y = DenseVector.OfArray(new double[] { 52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93,
            61.29, 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46 });
        var β = MultipleRegression.QR(X, y);
        Console.WriteLine(β);
    }
}",724,18
33395,http://rosettacode.org/wiki/Motzkin_numbers,Motzkin numbers,"Definition
The nth Motzkin number (denoted by M[n]) is the number of different ways of drawing non-intersecting chords between n points on a circle (not necessarily touching every point by a chord).

By convention M[0] = 1.



Task
Compute and show on this page the first 42 Motzkin numbers or, if your language does not support 64 bit integers, as many such numbers as you can. Indicate which of these numbers are prime.



See also
 oeis:A001006 Motzkin numbers 

",#C.23,C#,"using System;
using BI = System.Numerics.BigInteger;
 
class Program {
 
  // has multiple factors (other than 1 and x)
  static bool hmf(BI x) {
    if (x < 4) return x == 1;
    if ((x & 1) == 0 || x % 3 == 0) return true;
    int l = (int)Math.Sqrt((double)x); // this limit works because the 40th to 80th Motzkin numbers have factors of 2 or 3
    for (int j = 5, d = 4; j <= l; j += d = 6 - d)
      if (x % j == 0) return x > j;
    return false;
  }
 
  static void Main(string[] args) {
    BI a = 0, b = 1, t;
    int n = 1, s = 0, d = 1, c = 0, f = 1;
    while (n <= 80)
      Console.WriteLine(""{0,46:n0} {1}"",
        t = b / n++,
        hmf(t) ? """" : ""is prime."",
        t = b,
        b = ((c += d * 3 + 3) * a +
             (f += d * 2 + 3) * b) /
             (s += d += 2),
        a = t);
  }
}",816,29
33396,http://rosettacode.org/wiki/Move-to-front_algorithm,Move-to-front algorithm,"Given a symbol table of a zero-indexed array of all possible input symbols
this algorithm reversibly transforms a sequence
of input symbols into an array of output numbers (indices).

The transform in many cases acts to give frequently repeated input symbols
lower indices which is  useful in some compression algorithms.



Encoding algorithm

    for each symbol of the input sequence:
        output the index of the symbol in the symbol table
        move that symbol to the front of the symbol table



Decoding algorithm

    # Using the same starting symbol table
    for each index of the input sequence:
        output the symbol at that index of the symbol table
        move that symbol to the front of the symbol table



Example

Encoding the string of character symbols 'broood' using a symbol table of the lowercase characters   a-to-z



 Input

 Output

 SymbolTable


 broood

 1

 'abcdefghijklmnopqrstuvwxyz'


 broood

 1 17

 'bacdefghijklmnopqrstuvwxyz'


 broood

 1 17 15

 'rbacdefghijklmnopqstuvwxyz'


 broood

 1 17 15 0

 'orbacdefghijklmnpqstuvwxyz'


 broood

 1 17 15 0 0

 'orbacdefghijklmnpqstuvwxyz'


 broood

 1 17 15 0 0 5

 'orbacdefghijklmnpqstuvwxyz'



Decoding the indices back to the original symbol order:



 Input

 Output

 SymbolTable


 1 17 15 0 0 5

 b

 'abcdefghijklmnopqrstuvwxyz'


 1 17 15 0 0 5

 br

 'bacdefghijklmnopqrstuvwxyz'


 1 17 15 0 0 5

 bro

 'rbacdefghijklmnopqstuvwxyz'


 1 17 15 0 0 5

 broo

 'orbacdefghijklmnpqstuvwxyz'


 1 17 15 0 0 5

 brooo

 'orbacdefghijklmnpqstuvwxyz'


 1 17 15 0 0 5

 broood

 'orbacdefghijklmnpqstuvwxyz'



Task

   Encode and decode the following three strings of characters using the symbol table of the lowercase characters   a-to-z   as above. 
   Show the strings and their encoding here.
   Add a check to ensure that the decoded string is the same as the original.


The strings are:

   broood          
   bananaaa     
   hiphophiphop  


(Note the misspellings in the above strings.)
",#C.23,C#," 
using System;
using System.Collections.Generic;
using System.Text;
 
namespace MoveToFront
{
    class Program
    {
        private static char[] symbolTable;
        private static void setSymbolTable()
        {
            symbolTable = ""abcdefghijklmnopqrstuvwxyz"".ToCharArray();
        }
 
        private static void moveToFront(int charIndex)
        {
            char toFront = symbolTable[charIndex];
            for (int j = charIndex; j > 0; j--)
            {
                symbolTable[j] = symbolTable[j - 1];
            }
            symbolTable[0] = toFront;
        }
 
        public static int[] Encode(string input)
        {
            setSymbolTable();
            var output = new List<int>();
            foreach (char c in input)
            {
                for (int i = 0; i < 26; i++)
                {
                    if (symbolTable[i] == c)
                    {
                        output.Add(i);
                        moveToFront(i);
                        break;
                    }
                }
            }         
            return output.ToArray();
        }
 
        public static string Decode(int[] input)
        {
            setSymbolTable();
            var output = new StringBuilder(input.Length);
            foreach (int n in input)
            {
                output.Append(symbolTable[n]);
                moveToFront(n);
            }
            return output.ToString();
        }
 
        static void Main(string[] args)
        {
            string[] testInputs = new string[] { ""broood"", ""bananaaa"", ""hiphophiphop"" };
            int[] encoding;
            foreach (string s in testInputs) 
            {
                Console.WriteLine($""Encoding for '{s}':"");
                encoding = Encode(s);
                foreach (int i in encoding)
                {
                    Console.Write($""{i} "");
                }
                Console.WriteLine($""\nDecoding for '{s}':"");
                Console.WriteLine($""{Decode(encoding)}\n"");
            }
        }
    }
}
 ",2072,75
33439,http://rosettacode.org/wiki/Multifactorial,Multifactorial,"The factorial of a number, written as 



n
!


{\displaystyle n!}

, is defined as 



n
!
=
n
(
n
−
1
)
(
n
−
2
)
.
.
.
(
2
)
(
1
)


{\displaystyle n!=n(n-1)(n-2)...(2)(1)}

.

Multifactorials generalize factorials as follows:

 



n
!
=
n
(
n
−
1
)
(
n
−
2
)
.
.
.
(
2
)
(
1
)


{\displaystyle n!=n(n-1)(n-2)...(2)(1)}


 



n
!
!
=
n
(
n
−
2
)
(
n
−
4
)
.
.
.


{\displaystyle n!!=n(n-2)(n-4)...}


 



n
!
!
!
=
n
(
n
−
3
)
(
n
−
6
)
.
.
.


{\displaystyle n!!!=n(n-3)(n-6)...}


 



n
!
!
!
!
=
n
(
n
−
4
)
(
n
−
8
)
.
.
.


{\displaystyle n!!!!=n(n-4)(n-8)...}


 



n
!
!
!
!
!
=
n
(
n
−
5
)
(
n
−
10
)
.
.
.


{\displaystyle n!!!!!=n(n-5)(n-10)...}


In all cases, the terms in the products are positive integers.

If we define the degree of the multifactorial as the difference in successive terms that are multiplied together for a multifactorial (the number of exclamation marks), then the task is twofold:

 Write a function that given n and the degree, calculates the multifactorial.
 Use the function to generate and display here a table of the first ten members (1 to 10) of the first five degrees of multifactorial.

Note: The wikipedia entry on multifactorials gives a different formula. This task uses the Wolfram mathworld definition.
",#C.23,C#,"namespace RosettaCode.Multifactorial
{
    using System;
    using System.Linq;
 
    internal static class Program
    {
        private static void Main()
        {
            Console.WriteLine(string.Join(Environment.NewLine,
                                          Enumerable.Range(1, 5)
                                                    .Select(
                                                        degree =>
                                                        string.Join("" "",
                                                                    Enumerable.Range(1, 10)
                                                                              .Select(
                                                                                  number =>
                                                                                  Multifactorial(number, degree))))));
        }
 
        private static int Multifactorial(int number, int degree)
        {
            if (degree < 1)
            {
                throw new ArgumentOutOfRangeException(""degree"");
            }
 
            var count = 1 + (number - 1) / degree;
            if (count < 1)
            {
                throw new ArgumentOutOfRangeException(""number"");
            }
 
            return Enumerable.Range(0, count)
                             .Aggregate(1, (accumulator, index) => accumulator * (number - degree * index));
        }
    }
}",1441,38
33630,http://rosettacode.org/wiki/Monads/Maybe_monad,Monads/Maybe monad,"Demonstrate in your programming language the following:

Construct a Maybe Monad by writing the 'bind' function and the 'unit' (sometimes known as 'return') function for that Monad (or just use what the language already has implemented)
Make two functions, each which take a number and return a monadic number, e.g. Int -> Maybe Int and Int -> Maybe String
Compose the two functions with bind


A Monad is a single type which encapsulates several other types, eliminating boilerplate code. In practice it acts like a dynamically typed computational sequence, though in many cases the type issues can be resolved at compile time.

A Maybe Monad is a monad which specifically encapsulates the type of an undefined value.
",#C.23,C#,"using System;
 
namespace RosettaMaybe
{
    // courtesy of https://www.dotnetcurry.com/patterns-practices/1510/maybe-monad-csharp
    public abstract class Maybe<T>
    {
        public sealed class Some : Maybe<T>
        {
            public Some(T value) => Value = value;
            public T Value { get; }
        }
        public sealed class None : Maybe<T> { }
    }
 
    class Program
    {
        static Maybe<double> MonadicSquareRoot(double x)
        {
            if (x >= 0)
            {
                return new Maybe<double>.Some(Math.Sqrt(x));
            }
            else
            {
                return new Maybe<double>.None();
            }
        }
        static void Main(string[] args)
        {
            foreach (double x in new double[] { 4.0D, 8.0D, -15.0D, 16.23D, -42 })
            {
                Maybe<double> maybe = MonadicSquareRoot(x);
                if (maybe is Maybe<double>.Some some)
                {
                    Console.WriteLine($""The square root of {x} is "" + some.Value);
                }
                else
                {
                    Console.WriteLine($""Square root of {x} is undefined."");
                }
            }
        }
    }
}",1231,45
33790,http://rosettacode.org/wiki/Modular_inverse,Modular inverse,"From Wikipedia:

In modular arithmetic,   the modular multiplicative inverse of an integer    a    modulo    m    is an integer    x    such that





a

x
≡
1


(
mod

m
)

.


{\displaystyle a\,x\equiv 1{\pmod {m}}.}


Or in other words, such that:





∃
k
∈

Z

,

a

x
=
1
+
k

m


{\displaystyle \exists k\in \mathbb {Z} ,\qquad a\,x=1+k\,m}


It can be shown that such an inverse exists   if and only if    a    and    m    are coprime,   but we will ignore this for this task.



Task

Either by implementing the algorithm, by using a dedicated library or by using a built-in function in
your language,   compute the modular inverse of   42 modulo 2017.



",#C.23,C#,"public class Program
{
    static void Main()
    {
        System.Console.WriteLine(42.ModInverse(2017));
    }
}
 
public static class IntExtensions
{
    public static int ModInverse(this int a, int m)
    {
        if (m == 1) return 0;
        int m0 = m;
        (int x, int y) = (1, 0);
 
        while (a > 1) {
            int q = a / m;
            (a, m) = (m, a % m);
            (x, y) = (y, x - q * y);
        }
        return x < 0 ? x + m0 : x;
    }
}",469,24
33828,http://rosettacode.org/wiki/Monte_Carlo_methods,Monte Carlo methods,"A Monte Carlo Simulation is a way of approximating the value of a function
where calculating the actual value is difficult or impossible. 

It uses random sampling to define constraints on the value
and then makes a sort of ""best guess.""

A simple Monte Carlo Simulation can be used to calculate the value for 



π


{\displaystyle \pi }

.

If you had a circle and a square where the length of a side of the square
was the same as the diameter of the circle, the ratio of the area of the circle
to the area of the square would be 



π

/

4


{\displaystyle \pi /4}

.

So, if you put this circle inside the square and select many random points
inside the square, the number of points inside the circle
divided by the number of points inside the square and the circle
would be approximately 



π

/

4


{\displaystyle \pi /4}

.



Task

Write a function to run a simulation like this, with a variable number of random points to select.

Also, show the results of a few different sample sizes.

For software where the number 



π


{\displaystyle \pi }

 is not built-in,
we give 



π


{\displaystyle \pi }

 as a number of digits:

            3.141592653589793238462643383280


",#C.23,C#,"using System;
 
class Program {
    static double MonteCarloPi(int n) {
        int inside = 0;
        Random r = new Random();
 
        for (int i = 0; i < n; i++) {
            if (Math.Pow(r.NextDouble(), 2)+ Math.Pow(r.NextDouble(), 2) <= 1) {
                inside++;
            }
        }
 
        return 4.0 * inside / n;
    }
 
    static void Main(string[] args) {
        int value = 1000;
        for (int n = 0; n < 5; n++) {
            value *= 10;
            Console.WriteLine(""{0}:{1}"", value.ToString(""#,###"").PadLeft(11, ' '), MonteCarloPi(value));
        }
    }
}",592,24
33909,http://rosettacode.org/wiki/Morse_code,Morse code,"Morse code
It has been in use for more than 175 years — longer than any other electronic encoding system.



Task

Send a string as audible Morse code to an audio device   (e.g., the PC speaker).



As the standard Morse code does not contain all possible characters,
you may either ignore unknown characters in the file,
or indicate them somehow   (e.g. with a different pitch).



",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace Morse
{
    class Morse
    {
        static void Main(string[] args)
        {
            string word = ""sos"";
            Dictionary<string, string> Codes = new Dictionary<string, string>
            {
                {""a"", "".-   ""}, {""b"", ""-... ""}, {""c"", ""-.-. ""}, {""d"", ""-..  ""}, 
                {""e"", "".    ""}, {""f"", ""..-. ""}, {""g"", ""--.  ""}, {""h"", "".... ""},
                {""i"", ""..   ""}, {""j"", "".--- ""}, {""k"", ""-.-  ""}, {""l"", "".-.. ""},
                {""m"", ""--   ""}, {""n"", ""-.   ""}, {""o"", ""---  ""}, {""p"", "".--. ""}, 
                {""q"", ""--.- ""}, {""r"", "".-.  ""}, {""s"", ""...  ""}, {""t"", ""-    ""}, 
                {""u"", ""..-  ""}, {""v"", ""...- ""}, {""w"", "".--  ""}, {""x"", ""-..- ""}, 
                {""y"", ""-.-- ""}, {""z"", ""--.. ""}, {""0"", ""-----""}, {""1"", "".----""}, 
                {""2"", ""..---""}, {""3"", ""...--""}, {""4"", ""....-""}, {""5"", "".....""}, 
                {""6"", ""-....""}, {""7"", ""--...""}, {""8"", ""---..""}, {""9"", ""----.""}    
            };
 
            foreach (char c in word.ToCharArray())
            {
                string rslt = Codes[c.ToString()].Trim();
                foreach (char c2 in rslt.ToCharArray())
                {
                    if (c2 == '.')
                        Console.Beep(1000, 250);
                    else
                        Console.Beep(1000, 750);
                }
                System.Threading.Thread.Sleep(50);
            }
        }
    }
}
 ",1468,39
33910,http://rosettacode.org/wiki/Monty_Hall_problem,Monty Hall problem,"
Suppose you're on a game show and you're given the choice of three doors.

Behind one door is a car; behind the others, goats.

The car and the goats were placed randomly behind the doors before the show.



Rules of the game

After you have chosen a door, the door remains closed for the time being.

The game show host, Monty Hall, who knows what is behind the doors, now has to open one of the two remaining doors, and the door he opens must have a goat behind it.

If both remaining doors have goats behind them, he chooses one randomly.

After Monty Hall opens a door with a goat, he will ask you to decide whether you want to stay with your first choice or to switch to the last remaining door.

Imagine that you chose Door 1 and the host opens Door 3, which has a goat.

He then asks you ""Do you want to switch to Door Number 2?""



The question

Is it to your advantage to change your choice?



Note

The player may initially choose any of the three doors (not just Door 1), that the host opens a different door revealing a goat (not necessarily Door 3), and that he gives the player a second choice between the two remaining unopened doors.



Task

Run random simulations of the Monty Hall game. Show the effects of a strategy of the contestant always keeping his first guess so it can be contrasted with the strategy of the contestant always switching his guess.

Simulate at least a thousand games using three doors for each strategy and show the results in such a way as to make it easy to compare the effects of each strategy.



References

 Stefan Krauss, X. T. Wang, ""The psychology of the Monty Hall problem: Discovering psychological mechanisms for solving a tenacious brain teaser."", Journal of Experimental Psychology: General, Vol 132(1), Mar 2003, 3-22 DOI: 10.1037/0096-3445.132.1.3
 A YouTube video:   Monty Hall Problem - Numberphile. 

",#C.23,C#,"using System;
 
class Program
{
    static void Main(string[] args)
    {
        int switchWins = 0;
        int stayWins = 0;
 
        Random gen = new Random();
 
        for(int plays = 0; plays < 1000000; plays++ )
        {
            int[] doors = {0,0,0};//0 is a goat, 1 is a car
 
            var winner = gen.Next(3);
            doors[winner] = 1; //put a winner in a random door
 
	    int choice = gen.Next(3); //pick a door, any door
	    int shown; //the shown door
	    do
            {
	        shown = gen.Next(3);
	    }
            while (doors[shown] == 1 || shown == choice); //don't show the winner or the choice
 
	    stayWins += doors[choice]; //if you won by staying, count it
 
            //the switched (last remaining) door is (3 - choice - shown), because 0+1+2=3
            switchWins += doors[3 - choice - shown];
        }
 
        Console.Out.WriteLine(""Staying wins "" + stayWins + "" times."");
        Console.Out.WriteLine(""Switching wins "" + switchWins + "" times."");
    }
}",1017,36
34027,http://rosettacode.org/wiki/Multiplication_tables,Multiplication tables,"Task

Produce a formatted   12×12   multiplication table of the kind memorized by rote when in primary (or elementary) school.



Only print the top half triangle of products.



",#C.23,C#,"using System;
 
namespace multtbl
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.Write("" X"".PadRight(4));
            for (int i = 1; i <= 12; i++)
                Console.Write(i.ToString(""####"").PadLeft(4));
 
            Console.WriteLine();
            Console.Write("" ___"");
 
            for (int i = 1; i <= 12; i++)
                Console.Write("" ___"");
 
            Console.WriteLine();
            for (int row = 1; row <= 12; row++)
            {
                Console.Write(row.ToString(""###"").PadLeft(3).PadRight(4));
                for (int col = 1; col <= 12; col++)
                {
                    if (row <= col)
                        Console.Write((row * col).ToString(""###"").PadLeft(4));
                    else
                        Console.Write("""".PadLeft(4));
                }
 
                Console.WriteLine();
            }
 
            Console.WriteLine();
            Console.ReadLine();
        }
    }
}
 ",1005,39
34504,http://rosettacode.org/wiki/Minimal_steps_down_to_1,Minimal steps down to 1,"

Given:

 A starting, positive integer (greater than one), N.
 A selection of possible integer perfect divisors, D.
 And a selection of possible subtractors, S.
The goal is find the minimum number of steps necessary to reduce N down to one.

At any step, the number may be:

 Divided by any member of D if it is perfectly divided by D, (remainder zero).
 OR have one of S subtracted from it, if N is greater than the member of S.


There may be many ways to reduce the initial N down to 1. Your program needs to:

 Find the minimum number of steps to reach 1.
 Show one way of getting fron N to 1 in those minimum steps.


Examples

No divisors, D. a single subtractor of 1.

Obviousely N will take N-1 subtractions of 1 to reach 1
Single divisor of 2; single subtractor of 1:

N = 7 Takes 4 steps N -1=> 6, /2=> 3, -1=> 2, /2=> 1
N = 23 Takes 7 steps N -1=>22, /2=>11, -1=>10, /2=> 5, -1=> 4, /2=> 2, /2=> 1
Divisors 2 and 3; subtractor 1:

N = 11 Takes 4 steps N -1=>10, -1=> 9, /3=> 3, /3=> 1
Task

Using the possible divisors D, of 2 and 3; together with a possible subtractor S, of 1:

1. Show the number of steps and possible way of diminishing the numbers 1 to 10 down to 1.
2. Show a count of, and the numbers that: have the maximum minimal_steps_to_1, in the range 1 to 2,000.
Using the possible divisors D, of 2 and 3; together with a possible subtractor S, of 2:

3. Show the number of steps and possible way of diminishing the numbers 1 to 10 down to 1.
4. Show a count of, and the numbers that: have the maximum minimal_steps_to_1, in the range 1 to 2,000.


Optional stretch goal

2a, and 4a: As in 2 and 4 above, but for N in the range 1 to 20_000


Reference

 Learn Dynamic Programming (Memoization & Tabulation) Video of similar task.",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
public static class MinimalSteps
{
    public static void Main() {
        var (divisors, subtractors) = (new int[] { 2, 3 }, new [] { 1 });
        var lookup = CreateLookup(2_000, divisors, subtractors);
        Console.WriteLine($""Divisors: [{divisors.Delimit()}], Subtractors: [{subtractors.Delimit()}]"");
        PrintRange(lookup, 10);
        PrintMaxMins(lookup);
        lookup = CreateLookup(20_000, divisors, subtractors);
        PrintMaxMins(lookup);
        Console.WriteLine();
 
        subtractors = new [] { 2 };
        lookup = CreateLookup(2_000, divisors, subtractors);
        Console.WriteLine($""Divisors: [{divisors.Delimit()}], Subtractors: [{subtractors.Delimit()}]"");
        PrintRange(lookup, 10);
        PrintMaxMins(lookup);
        lookup = CreateLookup(20_000, divisors, subtractors);
        PrintMaxMins(lookup);
    }
 
    private static void PrintRange((char op, int param, int steps)[] lookup, int limit) {
        for (int goal = 1; goal <= limit; goal++) {
            var x = lookup[goal];
            if (x.param == 0) {
                Console.WriteLine($""{goal} cannot be reached with these numbers."");
                continue;
            }
            Console.Write($""{goal} takes {x.steps} {(x.steps == 1 ? ""step"" : ""steps"")}: "");
            for (int n = goal; n > 1; ) {
                Console.Write($""{n},{x.op}{x.param}=> "");
                n = x.op == '/' ? n / x.param : n - x.param;
                x = lookup[n];
            }
            Console.WriteLine(""1"");
        }
    }
 
    private static void PrintMaxMins((char op, int param, int steps)[] lookup) {
        var maxSteps = lookup.Max(x => x.steps);
        var items = lookup.Select((x, i) => (i, x)).Where(t => t.x.steps == maxSteps).ToList();
        Console.WriteLine(items.Count == 1
            ? $""There is one number below {lookup.Length-1} that requires {maxSteps} steps: {items[0].i}""
            : $""There are {items.Count} numbers below {lookup.Length-1} that require {maxSteps} steps: {items.Select(t => t.i).Delimit()}""
        );
    }
 
    private static (char op, int param, int steps)[] CreateLookup(int goal, int[] divisors, int[] subtractors)
    {
        var lookup = new (char op, int param, int steps)[goal+1];
        lookup[1] = ('/', 1, 0);
        for (int n = 1; n < lookup.Length; n++) {
            var ln = lookup[n];
            if (ln.param == 0) continue;
            for (int d = 0; d < divisors.Length; d++) {
                int target = n * divisors[d];
                if (target > goal) break;
                if (lookup[target].steps == 0 || lookup[target].steps > ln.steps) lookup[target] = ('/', divisors[d], ln.steps + 1);
            }
            for (int s = 0; s < subtractors.Length; s++) {
                int target = n + subtractors[s];
                if (target > goal) break;
                if (lookup[target].steps == 0 || lookup[target].steps > ln.steps) lookup[target] = ('-', subtractors[s], ln.steps + 1);
            }
        }
        return lookup;
    }
 
    private static string Delimit<T>(this IEnumerable<T> source) => string.Join("", "", source);
}",3211,74
34516,http://rosettacode.org/wiki/Modular_arithmetic,Modular arithmetic,"Modular arithmetic is a form of arithmetic (a calculation technique involving the concepts of addition and multiplication) which is done on numbers with a defined equivalence relation called congruence.

For any positive integer 



p


{\displaystyle p}

 called the congruence modulus,
two numbers 



a


{\displaystyle a}

 and 



b


{\displaystyle b}

 are said to be congruent modulo p whenever there exists an integer 



k


{\displaystyle k}

 such that:





a
=
b
+
k

p


{\displaystyle a=b+k\,p}


The corresponding set of equivalence classes forms a ring denoted 






Z


p

Z






{\displaystyle {\frac {\mathbb {Z} }{p\mathbb {Z} }}}

.

Addition and multiplication on this ring have the same algebraic structure as in usual arithmetics, so that a function such as a polynomial expression could receive a ring element as argument and give a consistent result.

The purpose of this task is to show, if your programming language allows it,
how to redefine operators so that they can be used transparently on modular integers.
You can do it either by using a dedicated library, or by implementing your own class.

You will use the following function for demonstration:





f
(
x
)
=

x

100


+
x
+
1


{\displaystyle f(x)=x^{100}+x+1}


You will use 



13


{\displaystyle 13}

 as the congruence modulus and you will compute 



f
(
10
)


{\displaystyle f(10)}

.

It is important that the function 



f


{\displaystyle f}

 is agnostic about whether or not its argument is modular; it should behave the same way with normal and modular integers.
In other words, the function is an algebraic expression that could be used with any ring, not just integers.



",#C.23,C#,"using System;
 
namespace ModularArithmetic {
    interface IAddition<T> {
        T Add(T rhs);
    }
    interface IMultiplication<T> {
        T Multiply(T rhs);
    }
    interface IPower<T> {
        T Power(int pow);
    }
    interface IOne<T> {
        T One();
    }
 
    class ModInt : IAddition<ModInt>, IMultiplication<ModInt>, IPower<ModInt>, IOne<ModInt> {
        private int modulo;
 
        public ModInt(int value, int modulo) {
            Value = value;
            this.modulo = modulo;
        }
 
        public int Value { get; }
 
        public ModInt One() {
            return new ModInt(1, modulo);
        }
 
        public ModInt Add(ModInt rhs) {
            return this + rhs;
        }
 
        public ModInt Multiply(ModInt rhs) {
            return this * rhs;
        }
 
        public ModInt Power(int pow) {
            return Pow(this, pow);
        }
 
        public override string ToString() {
            return string.Format(""ModInt({0}, {1})"", Value, modulo);
        }
 
        public static ModInt operator +(ModInt lhs, ModInt rhs) {
            if (lhs.modulo != rhs.modulo) {
                throw new ArgumentException(""Cannot add rings with different modulus"");
            }
            return new ModInt((lhs.Value + rhs.Value) % lhs.modulo, lhs.modulo);
        }
 
        public static ModInt operator *(ModInt lhs, ModInt rhs) {
            if (lhs.modulo != rhs.modulo) {
                throw new ArgumentException(""Cannot add rings with different modulus"");
            }
            return new ModInt((lhs.Value * rhs.Value) % lhs.modulo, lhs.modulo);
        }
 
        public static ModInt Pow(ModInt self, int p) {
            if (p < 0) {
                throw new ArgumentException(""p must be zero or greater"");
            }
 
            int pp = p;
            ModInt pwr = self.One();
            while (pp-- > 0) {
                pwr *= self;
            }
            return pwr;
        }
    }
 
    class Program {
        static T F<T>(T x) where T : IAddition<T>, IMultiplication<T>, IPower<T>, IOne<T> {
            return x.Power(100).Add(x).Add(x.One());
        }
 
        static void Main(string[] args) {
            ModInt x = new ModInt(10, 13);
            ModInt y = F(x);
            Console.WriteLine(""x ^ 100 + x + 1 for x = {0} is {1}"", x, y);
        }
    }
}",2364,86
34555,http://rosettacode.org/wiki/Modular_exponentiation,Modular exponentiation,"Find the last   40   decimal digits of   




a

b




{\displaystyle a^{b}}

,   where

   



a
=
2988348162058574136915891421498819466320163312926952423791023078876139


{\displaystyle a=2988348162058574136915891421498819466320163312926952423791023078876139}


   



b
=
2351399303373464486466122544523690094744975233415544072992656881240319


{\displaystyle b=2351399303373464486466122544523690094744975233415544072992656881240319}




A computer is too slow to find the entire value of   




a

b




{\displaystyle a^{b}}

.

Instead, the program must use a fast algorithm for modular exponentiation:   




a

b



mod


m


{\displaystyle a^{b}\mod m}

.

The algorithm must work for any integers   



a
,
b
,
m


{\displaystyle a,b,m}

,     where   



b
≥
0


{\displaystyle b\geq 0}

   and   



m
>
0


{\displaystyle m>0}

.



",#C.23,C#,"using System;
using System.Numerics;
 
class Program
{
    static void Main() {
        var a = BigInteger.Parse(""2988348162058574136915891421498819466320163312926952423791023078876139"");
        var b = BigInteger.Parse(""2351399303373464486466122544523690094744975233415544072992656881240319"");
        var m = BigInteger.Pow(10, 40);
        Console.WriteLine(BigInteger.ModPow(a, b, m));
    }
}",398,12
34595,http://rosettacode.org/wiki/Minimum_positive_multiple_in_base_10_using_only_0_and_1,Minimum positive multiple in base 10 using only 0 and 1,"Every positive integer has infinitely many base-10 multiples that only use the digits 0 and 1. The goal of this task is to find and display the minimum multiple that has this property.

This is simple to do, but can be challenging to do efficiently.

To avoid repeating long, unwieldy phrases, the operation ""minimum positive multiple of a positive integer n in base 10 that only uses the digits 0 and 1"" will hereafter be referred to as ""B10"".

Task

Write a routine to find the B10 of a given integer.

E.G.

      n                  B10      n  × multiplier
      1                    1    ( 1  × 1         )
      2                   10    ( 2  × 5         )
      7                 1001    ( 7  x 143       )
      9            111111111    ( 9  x 12345679  )
     10                   10    ( 10 x 1         )

and so on.

Use the routine to find and display here, on this page, the B10 value for:

   1 through 10, 95 through 105, 297, 576, 594, 891, 909, 999

Optionally find B10 for:

   1998, 2079, 2251, 2277

Stretch goal; find B10 for:

   2439, 2997, 4878

There are many opportunities for optimizations, but avoid using magic numbers as much as possible. If you do use magic numbers, explain briefly why and what they do for your implementation.



See also

 OEIS:A004290 Least positive multiple of n that when written in base 10 uses only 0's and 1's.
 How to find Minimum Positive Multiple in base 10 using only 0 and 1",#C.23,C#,"using System;
using System.Collections.Generic;
using static System.Console;
 
class Program {
 
  static string B10(int n) {
    int[] pow = new int[n + 1], val = new int[29];
    for (int count = 0, ten = 1, x = 1; x <= n; x++) {
      val[x] = ten;
      for (int j = 0, t; j <= n; j++)
        if (pow[j] != 0 && pow[j] != x && pow[t = (j + ten) % n] == 0)
          pow[t] = x;
      if (pow[ten] == 0) pow[ten] = x;
      ten = (10 * ten) % n;
      if (pow[0] != 0) {
        x = n;
        string s = """"; 
        while (x != 0) {
          int p = pow[x % n];
          if (count > p) s += new string('0', count - p);
          count = p - 1;
          s += ""1"";
          x = (n + x - val[p]) % n;
        }
        if (count > 0) s += new string('0', count);
        return s;
      }
    } 
    return ""1"";
  }
 
  static void Main(string[] args) {
    string fmt = ""{0,4} * {1,24} = {2,-28}\n"";
    int[] m = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
      95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105,
      297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878 };
    string[] r = new string[m.Length]; 
    WriteLine(fmt + new string('-', 62), ""n"", ""multiplier"", ""B10"");
    var sw = System.Diagnostics.Stopwatch.StartNew();
    for (int i = 0; i < m.Length; i++) r[i] = B10(m[i]);
    sw.Stop();
    for (int i = 0; i < m.Length; i++) Write(fmt, m[i], decimal.Parse(r[i]) / m[i], r[i]);
    Write(""\nTook {0}ms"", sw.Elapsed.TotalMilliseconds);
  }
}",1488,46
34668,http://rosettacode.org/wiki/Minesweeper_game,Minesweeper game,"There is an n by m grid that has a random number (between 10% to 20% of the total number of tiles, though older implementations may use 20%..60% instead) of randomly placed mines that need to be found.

Positions in the grid are modified by entering their coordinates where the first coordinate is horizontal in the grid and the second vertical. The top left of the grid is position 1,1; the bottom right is at n,m.

 The total number of mines to be found is shown at the beginning of the game.
 Each mine occupies a single grid point, and its position is initially unknown to the player
 The grid is shown as a rectangle of characters between moves.
 You are initially shown all grids as obscured, by a single dot '.'
 You may mark what you think is the position of a mine which will show as a '?'
 You can mark what you think is free space by entering its coordinates.
 If the point is free space then it is cleared, as are any adjacent points that are also free space- this is repeated recursively for subsequent adjacent free points unless that point is marked as a mine or is a mine.
 Points marked as a mine show as a '?'.
 Other free points show as an integer count of the number of adjacent true mines in its immediate neighborhood, or as a single space ' ' if the free point is not adjacent to any true mines.
 Of course you lose if you try to clear space that has a hidden mine.
 You win when you have correctly identified all mines.
The Task is to create a program that allows you to play minesweeper on a 6 by 4 grid, and that assumes all user input is formatted correctly and so checking inputs for correct form may be omitted.
You may also omit all GUI parts of the task and work using text input and output.

Note: Changes may be made to the method of clearing mines to more closely follow a particular implementation of the game so long as such differences and the implementation that they more accurately follow are described.


C.F: wp:Minesweeper (computer game)
",#C.23,C#,"using System;
using System.Drawing;
using System.Windows.Forms;
 
class MineFieldModel
{
    public int RemainingMinesCount{
        get{
            var count = 0;
            ForEachCell((i,j)=>{
                if (Mines[i,j] && !Marked[i,j])
                    count++;
            });
            return count;
        }
    }
 
    public bool[,] Mines{get; private set;}
    public bool[,] Opened{get;private set;}
    public bool[,] Marked{get; private set;}
    public int[,] Values{get;private set; }
    public int Width{ get{return Mines.GetLength(1);} } 
    public int Height{ get{return Mines.GetLength(0);} }
 
    public MineFieldModel(bool[,] mines)
    {
        this.Mines = mines;
        this.Opened = new bool[Height, Width]; // filled with 'false' by default
        this.Marked = new bool[Height, Width];
        this.Values = CalculateValues();
    }
 
    private int[,] CalculateValues()
    {
        int[,] values = new int[Height, Width];
        ForEachCell((i,j) =>{
            var value = 0;
            ForEachNeighbor(i,j, (i1,j1)=>{
                if (Mines[i1,j1])
                    value++;
            });
            values[i,j] = value;
        });
        return values;
    }
 
    // Helper method for iterating over cells
    public void ForEachCell(Action<int,int> action)
    {
        for (var i = 0; i < Height; i++)
        for (var j = 0; j < Width; j++)
            action(i,j);
    }
 
    // Helper method for iterating over cells' neighbors
    public void ForEachNeighbor(int i, int j, Action<int,int> action)
    {
        for (var i1 = i-1; i1 <= i+1; i1++)
        for (var j1 = j-1; j1 <= j+1; j1++)               
            if (InBounds(j1, i1) && !(i1==i && j1 ==j))
                action(i1, j1);
    }
 
    private bool InBounds(int x, int y)
    {
        return y >= 0 && y < Height && x >=0 && x < Width;
    }
 
    public event Action Exploded = delegate{};
    public event Action Win = delegate{};
    public event Action Updated = delegate{};
 
    public void OpenCell(int i, int j){
        if(!Opened[i,j]){
            if (Mines[i,j])
                Exploded();
            else{
                OpenCellsStartingFrom(i,j);
                Updated();
                CheckForVictory();
            }
        }
    }
 
    void OpenCellsStartingFrom(int i, int j)
    {
            Opened[i,j] = true;
            ForEachNeighbor(i,j, (i1,j1)=>{
                if (!Mines[i1,j1] && !Opened[i1,j1] && !Marked[i1,j1])
                    OpenCellsStartingFrom(i1, j1);
            });
    }
 
    void CheckForVictory(){
        int notMarked = 0;
        int wrongMarked = 0;
        ForEachCell((i,j)=>{
            if (Mines[i,j] && !Marked[i,j])
                notMarked++;
            if (!Mines[i,j] && Marked[i,j])
                wrongMarked++;
        }); 
        if (notMarked == 0 && wrongMarked == 0)
            Win();
    }
 
    public void Mark(int i, int j){
        if (!Opened[i,j])
            Marked[i,j] = true;
            Updated();
            CheckForVictory();
    }
}
 
class MineFieldView: UserControl{
    public const int CellSize = 40;
 
    MineFieldModel _model;
    public MineFieldModel Model{
        get{ return _model; }
        set
        { 
            _model = value; 
            this.Size = new Size(_model.Width * CellSize+1, _model.Height * CellSize+2);
        }
    }
 
    public MineFieldView(){
        //Enable double-buffering to eliminate flicker
        this.SetStyle(ControlStyles.AllPaintingInWmPaint | ControlStyles.UserPaint | ControlStyles.DoubleBuffer,true);
        this.Font = new Font(FontFamily.GenericSansSerif, 14, FontStyle.Bold);
 
        this.MouseUp += (o,e)=>{
            Point cellCoords = GetCell(e.Location);
            if (Model != null)
            {
                if (e.Button == MouseButtons.Left)
                    Model.OpenCell(cellCoords.Y, cellCoords.X);
                else if (e.Button == MouseButtons.Right)
                    Model.Mark(cellCoords.Y, cellCoords.X);
            }
        };
    }
 
    Point GetCell(Point coords)
    {
        var rgn = ClientRectangle;
        var x = (coords.X - rgn.X)/CellSize;
        var y = (coords.Y - rgn.Y)/CellSize;
        return new Point(x,y);
    }
 
    static readonly Brush MarkBrush = new SolidBrush(Color.Blue);
    static readonly Brush ValueBrush = new SolidBrush(Color.Black);
    static readonly Brush UnexploredBrush = new SolidBrush(SystemColors.Control);
    static readonly Brush OpenBrush = new SolidBrush(SystemColors.ControlDark);
 
 
    protected override void OnPaint(PaintEventArgs e)
    {
        base.OnPaint(e);
        var g = e.Graphics;
        if (Model != null)
        {
            Model.ForEachCell((i,j)=>
            {
                var bounds = new Rectangle(j * CellSize, i * CellSize, CellSize, CellSize);
                if (Model.Opened[i,j])
                {
                    g.FillRectangle(OpenBrush, bounds);
                    if (Model.Values[i,j] > 0)
                    {
                        DrawStringInCenter(g, Model.Values[i,j].ToString(), ValueBrush, bounds);
                    }
                } 
                else 
                {
                    g.FillRectangle(UnexploredBrush, bounds);
                    if (Model.Marked[i,j])
                    {
                        DrawStringInCenter(g, ""?"", MarkBrush, bounds);
                    }
                    var outlineOffset = 1;
                    var outline = new Rectangle(bounds.X+outlineOffset, bounds.Y+outlineOffset, bounds.Width-2*outlineOffset, bounds.Height-2*outlineOffset);
                    g.DrawRectangle(Pens.Gray, outline);
                }
                g.DrawRectangle(Pens.Black, bounds);
            });
        }
 
    }
 
    static readonly StringFormat FormatCenter = new StringFormat
                            {
                                LineAlignment = StringAlignment.Center,
                                Alignment=StringAlignment.Center
                            };
 
    void DrawStringInCenter(Graphics g, string s, Brush brush, Rectangle bounds)
    {
        PointF center = new PointF(bounds.X + bounds.Width/2, bounds.Y + bounds.Height/2);
        g.DrawString(s, this.Font, brush, center, FormatCenter);
    }
 
}
 
class MineSweepForm: Form
{
 
    MineFieldModel CreateField(int width, int height)
{
        var field = new bool[height, width];
        int mineCount = (int)(0.2 * height * width);
        var rnd = new Random();
        while(mineCount > 0)
        {
            var x = rnd.Next(width);
            var y = rnd.Next(height);
            if (!field[y,x])
            {
                field[y,x] = true;
                mineCount--;
            }
        }
        return new MineFieldModel(field);
    }
 
    public MineSweepForm()
    {
        var model = CreateField(6, 4);
        var counter = new Label{ };
        counter.Text = model.RemainingMinesCount.ToString();
        var view = new MineFieldView
                        { 
                            Model = model, BorderStyle = BorderStyle.FixedSingle,
                        };
        var stackPanel = new FlowLayoutPanel
                        {
                            Dock = DockStyle.Fill,
                            FlowDirection = FlowDirection.TopDown,
                            Controls = {counter, view}
                        };
        this.Controls.Add(stackPanel);
        model.Updated += delegate{
            view.Invalidate();
            counter.Text = model.RemainingMinesCount.ToString();
        };
        model.Exploded += delegate {
            MessageBox.Show(""FAIL!"");
            Close();
        };
        model.Win += delegate {
            MessageBox.Show(""WIN!"");
            view.Enabled = false;
        };
 
    }
}
 
class Program
{
    static void Main()
    {
        Application.Run(new MineSweepForm());
    }
}",7981,266
34696,http://rosettacode.org/wiki/Metallic_ratios,Metallic ratios,"Many people have heard of the Golden ratio, phi (φ). Phi is just one of a series
of related ratios that are referred to as the ""Metallic ratios"".

The Golden ratio was discovered and named by ancient civilizations as it was
thought to be the most pure and beautiful (like Gold). The Silver ratio was was
also known to the early Greeks, though was not named so until later as a nod to
the Golden ratio to which it is closely related. The series has been extended to
encompass all of the related ratios and was given the general name Metallic ratios (or Metallic means).
Somewhat incongruously as the original Golden ratio referred to the adjective ""golden"" rather than the metal ""gold"".

Metallic ratios are the real roots of the general form equation:

         x2 - bx - 1 = 0 

where the integer b determines which specific one it is.

Using the quadratic equation:

         ( -b ± √(b2 - 4ac) ) / 2a = x 

Substitute in (from the top equation) 1 for a, -1 for c, and recognising that -b is negated we get:

         ( b ± √(b2 + 4) ) ) / 2 = x 

We only want the real root:

         ( b + √(b2 + 4) ) ) / 2 = x 

When we set b to 1, we get an irrational number: the Golden ratio.

         ( 1 + √(12 + 4) ) / 2  =  (1 + √5) / 2 = ~1.618033989... 

With b set to 2, we get a different irrational number: the Silver ratio.

         ( 2 + √(22 + 4) ) / 2  =  (2 + √8) / 2 = ~2.414213562... 

When the ratio b is 3, it is commonly referred to as the Bronze ratio, 4 and 5
are sometimes called the Copper and Nickel ratios, though they aren't as
standard. After that there isn't really any attempt at standardized names. They
are given names here on this page, but consider the names fanciful rather than
canonical.

Note that technically, b can be 0 for a ""smaller"" ratio than the Golden ratio.
We will refer to it here as the Platinum ratio, though it is kind-of a
degenerate case.

Metallic ratios where b > 0 are also defined by the irrational continued fractions:

         [b;b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b...] 



So, The first ten Metallic ratios are:


 Metallic ratios


Name
b
Equation
Value
Continued fraction
OEIS link


Platinum
0
(0 + √4) / 2
 1
-
-


Golden
1
(1 + √5) / 2
 1.618033988749895...
[1;1,1,1,1,1,1,1,1,1,1...]
OEIS:A001622


Silver
2
(2 + √8) / 2
 2.414213562373095...
[2;2,2,2,2,2,2,2,2,2,2...]
OEIS:A014176


Bronze
3
(3 + √13) / 2
 3.302775637731995...
[3;3,3,3,3,3,3,3,3,3,3...]
OEIS:A098316


Copper
4
(4 + √20) / 2
 4.23606797749979...
[4;4,4,4,4,4,4,4,4,4,4...]
OEIS:A098317


Nickel
5
(5 + √29) / 2
 5.192582403567252...
[5;5,5,5,5,5,5,5,5,5,5...]
OEIS:A098318


Aluminum
6
(6 + √40) / 2
 6.16227766016838...
[6;6,6,6,6,6,6,6,6,6,6...]
OEIS:A176398


Iron
7
(7 + √53) / 2
 7.140054944640259...
[7;7,7,7,7,7,7,7,7,7,7...]
OEIS:A176439


Tin
8
(8 + √68) / 2
 8.123105625617661...
[8;8,8,8,8,8,8,8,8,8,8...]
OEIS:A176458


Lead
9
(9 + √85) / 2
 9.109772228646444...
[9;9,9,9,9,9,9,9,9,9,9...]
OEIS:A176522




There are other ways to find the Metallic ratios; one, (the focus of this task)
is through successive approximations of Lucas sequences.

A traditional Lucas sequence is of the form:

   xn = P * xn-1 - Q * xn-2

and starts with the first 2 values 0, 1.

For our purposes in this task, to find the metallic ratios we'll use the form:

   xn = b * xn-1 + xn-2

( P is set to b and Q is set to -1. ) To avoid ""divide by zero"" issues we'll start the sequence with the first two terms 1, 1. The initial starting value has very little effect on the final ratio or convergence rate. Perhaps it would be more accurate to call it a Lucas-like sequence.

At any rate, when b = 1 we get:

   xn = xn-1 + xn-2

   1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144...

more commonly known as the Fibonacci sequence.

When b = 2:

   xn = 2 * xn-1 + xn-2

   1, 1, 3, 7, 17, 41, 99, 239, 577, 1393...



And so on.



To find the ratio by successive approximations, divide the (n+1)th term by the
nth. As n grows larger, the ratio will approach the b metallic ratio.

For b = 1 (Fibonacci sequence):

   1/1   = 1
   2/1   = 2
   3/2   = 1.5
   5/3   = 1.666667
   8/5   = 1.6
   13/8  = 1.625
   21/13 = 1.615385
   34/21 = 1.619048
   55/34 = 1.617647
   89/55 = 1.618182
   etc.

It converges, but pretty slowly. In fact, the Golden ratio has the slowest
possible convergence for any irrational number.



Task
For each of the first 10 Metallic ratios; b = 0 through 9:

 Generate the corresponding ""Lucas"" sequence.
 Show here, on this page, at least the first 15 elements of the ""Lucas"" sequence.
 Using successive approximations, calculate the value of the ratio accurate to 32 decimal places.
 Show the value of the approximation at the required accuracy.
 Show the value of n when the approximation reaches the required accuracy (How many iterations did it take?).
Optional, stretch goal - Show the value and number of iterations n, to approximate the Golden ratio to 256 decimal places.

You may assume that the approximation has been reached when the next iteration does not cause the value (to the desired places) to change.

See also
 Wikipedia: Metallic mean
 Wikipedia: Lucas sequence",#C.23,C#,"using static System.Math;
using static System.Console;
using BI = System.Numerics.BigInteger;
 
class Program {
 
    static BI IntSqRoot(BI v, BI res) { // res is the initial guess
        BI term = 0, d = 0, dl = 1; while (dl != d) { term = v / res; res = (res + term) >> 1;
            dl = d; d = term - res; } return term; }
 
    static string doOne(int b, int digs) { // calculates result via square root, not iterations
        int s = b * b + 4; BI g = (BI)(Sqrt((double)s) * Pow(10, ++digs)),
            bs = IntSqRoot(s * BI.Parse('1' + new string('0', digs << 1)), g);
        bs += b * BI.Parse('1' + new string('0', digs));
        bs >>= 1; bs += 4; string st = bs.ToString();
        return string.Format(""{0}.{1}"", st[0], st.Substring(1, --digs)); }
 
    static string divIt(BI a, BI b, int digs) { // performs division
        int al = a.ToString().Length, bl = b.ToString().Length;
        a *= BI.Pow(10, ++digs << 1); b *= BI.Pow(10, digs);
        string s = (a / b + 5).ToString(); return s[0] + ""."" + s.Substring(1, --digs); }
 
    // custom formating
    static string joined(BI[] x) { int[] wids = {1, 1, 2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};
        string res = """"; for (int i = 0; i < x.Length; i++) res += 
            string.Format(""{0,"" + (-wids[i]).ToString() + ""} "", x[i]); return res; }
 
    static void Main(string[] args) { // calculates and checks each ""metal""
        WriteLine(""Metal B Sq.Rt Iters /---- 32 decimal place value ----\\  Matches Sq.Rt Calc"");
        int k; string lt, t = """"; BI n, nm1, on; for (int b = 0; b < 10; b++) {
            BI[] lst = new BI[15]; lst[0] = lst[1] = 1;
            for (int i = 2; i < 15; i++) lst[i] = b * lst[i - 1] + lst[i - 2];
            // since all the iterations (except Pt) are > 15, continue iterating from the end of the list of 15
            n = lst[14]; nm1 = lst[13]; k = 0; for (int j = 13; k == 0; j++) {
                lt = t; if (lt == (t = divIt(n, nm1, 32))) k = b == 0 ? 1 : j;
                on = n; n = b * n + nm1; nm1 = on; }
            WriteLine(""{0,4}  {1}   {2,2}    {3, 2}  {4}  {5}\n{6,19} {7}"", ""Pt Au Ag CuSn Cu Ni Al Fe Sn Pb""
                .Split(' ')[b], b, b * b + 4, k, t, t == doOne(b, 32), """", joined(lst)); }
        // now calculate and check big one
        n = nm1 =1; k = 0; for (int j = 1; k == 0; j++) {
            lt = t; if (lt == (t = divIt(n, nm1, 256))) k = j;
                on = n; n += nm1; nm1 = on; }
        WriteLine(""\nAu to 256 digits:""); WriteLine(t);
        WriteLine(""Iteration count: {0}  Matched Sq.Rt Calc: {1}"", k, t == doOne(1, 256)); }
}",2606,45
34702,http://rosettacode.org/wiki/Metered_concurrency,Metered concurrency,"The goal of this task is to create a counting semaphore used to control the execution of a set of concurrent units. This task intends to demonstrate coordination of active concurrent units through the use of a passive concurrent unit. The operations for a counting semaphore are acquire, release, and count. Each active concurrent unit should attempt to acquire the counting semaphore before executing its assigned duties. In this case the active concurrent unit should report that it has acquired the semaphore. It should sleep for 2 seconds and then release the semaphore.
",#C.23,C#,"using System;
using System.Threading;
using System.Threading.Tasks;
 
namespace RosettaCode
{
  internal sealed class Program
  {
    private static void Worker(object arg, int id)
    {
      var sem = arg as SemaphoreSlim;
      sem.Wait();
      Console.WriteLine(""Thread {0} has a semaphore & is now working."", id);
      Thread.Sleep(2*1000);
      Console.WriteLine(""#{0} done."", id);
      sem.Release();
    }
 
    private static void Main()
    {
      var semaphore = new SemaphoreSlim(Environment.ProcessorCount*2, int.MaxValue);
 
      Console.WriteLine(""You have {0} processors availiabe"", Environment.ProcessorCount);
      Console.WriteLine(""This program will use {0} semaphores.\n"", semaphore.CurrentCount);
 
      Parallel.For(0, Environment.ProcessorCount*3, y => Worker(semaphore, y));
    }
  }
}",819,29
34709,http://rosettacode.org/wiki/Mian-Chowla_sequence,Mian-Chowla sequence,"The Mian–Chowla sequence is an integer sequence defined recursively.



Mian–Chowla is an infinite instance of a Sidon sequence, and belongs to the class known as B₂ sequences.



The sequence starts with:

a1 = 1
then for n > 1, an is the smallest positive integer such that every pairwise sum

ai + aj 
is distinct, for all i and j less than or equal to n.

The Task

 Find and display, here, on this page the first 30 terms of the Mian–Chowla sequence.
 Find and display, here, on this page the 91st through 100th terms of the Mian–Chowla sequence.


Demonstrating working through the first few terms longhand:

a1 = 1
1 + 1 = 2
Speculatively try a2 = 2

1 + 1 = 2
1 + 2 = 3
2 + 2 = 4
There are no repeated sums so 2 is the next number in the sequence.

Speculatively try a3 = 3

1 + 1 = 2
1 + 2 = 3 
1 + 3 = 4
2 + 2 = 4
2 + 3 = 5
3 + 3 = 6
Sum of 4 is repeated so 3 is rejected.

Speculatively try a3 = 4

1 + 1 = 2
1 + 2 = 3
1 + 4 = 5
2 + 2 = 4
2 + 4 = 6
4 + 4 = 8
There are no repeated sums so 4 is the next number in the sequence.

And so on...

See also

 OEIS:A005282 Mian-Chowla sequence",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
 
static class Program {
    static int[] MianChowla(int n) {
        int[] mc = new int[n - 1 + 1];
        HashSet<int> sums = new HashSet<int>(), ts = new HashSet<int>();
        int sum; mc[0] = 1; sums.Add(2);
        for (int i = 1; i <= n - 1; i++) {
            for (int j = mc[i - 1] + 1; ; j++) {
                mc[i] = j;
                for (int k = 0; k <= i; k++) {
                    sum = mc[k] + j;
                    if (sums.Contains(sum)) { ts.Clear(); break; }
                    ts.Add(sum);
                }
                if (ts.Count > 0) { sums.UnionWith(ts); break; }
            }
        }
        return mc;
    }
 
    static void Main(string[] args)
    {
        const int n = 100; Stopwatch sw = new Stopwatch();
        string str = "" of the Mian-Chowla sequence are:\n"";
        sw.Start(); int[] mc = MianChowla(n); sw.Stop();
        Console.Write(""The first 30 terms{1}{2}{0}{0}Terms 91 to 100{1}{3}{0}{0}"" +
            ""Computation time was {4}ms.{0}"", '\n', str, string.Join("" "", mc.Take(30)),
            string.Join("" "", mc.Skip(n - 10)), sw.ElapsedMilliseconds);
    }
}",1214,34
34727,http://rosettacode.org/wiki/Metaprogramming,Metaprogramming,"Name and briefly demonstrate any support your language has for metaprogramming. Your demonstration may take the form of cross-references to other tasks on Rosetta Code. When possible, provide links to relevant documentation.

For the purposes of this task, ""support for metaprogramming"" means any way the user can effectively modify the language's syntax that's built into the language (like Lisp macros) or that's conventionally used with the language (like the C preprocessor). Such facilities need not be very powerful: even user-defined infix operators count. On the other hand, in general, neither operator overloading nor eval count. The task author acknowledges that what qualifies as metaprogramming is largely a judgment call.
",#C.23,C#," 
(loop for count from 1
      for x in '(1 2 3 4 5)
      summing x into sum
      summing (* x x) into sum-of-squares
      finally
        (return
          (let* ((mean (/ sum count))
                 (spl-var (- (* count sum-of-squares) (* sum sum)))
                 (spl-dev (sqrt (/ spl-var (1- count))))) 
            (values mean spl-var spl-dev)))) ",360,11
34908,http://rosettacode.org/wiki/Merge_and_aggregate_datasets,Merge and aggregate datasets,"Merge and aggregate datasets



Task

Merge and aggregate two datasets as provided in   .csv   files into a new resulting dataset.

Use the appropriate methods and data structures depending on the programming language.

Use the most common libraries only when built-in functionality is not sufficient.



Note

Either load the data from the   .csv   files or create the required data structures hard-coded.


patients.csv   file contents:

PATIENT_ID,LASTNAME
1001,Hopper
4004,Wirth
3003,Kemeny
2002,Gosling
5005,Kurtz


visits.csv   file contents:

PATIENT_ID,VISIT_DATE,SCORE
2002,2020-09-10,6.8
1001,2020-09-17,5.5
4004,2020-09-24,8.4
2002,2020-10-08,
1001,,6.6
3003,2020-11-12,
4004,2020-11-05,7.0
1001,2020-11-19,5.3



Create a resulting dataset in-memory or output it to screen or file, whichever is appropriate for the programming language at hand.

Merge and group per patient id and last name,   get the maximum visit date,   and get the sum and average of the scores per patient to get the resulting dataset.



Note that the visit date is purposefully provided as ISO format,   so that it could also be processed as text and sorted alphabetically to determine the maximum date.

| PATIENT_ID | LASTNAME | LAST_VISIT |  SCORE_SUM | SCORE_AVG |
| 1001       |  Hopper  | 2020-11-19 |  17.4      | 5.80      |
| 2002       |  Gosling | 2020-10-08 |   6.8      | 6.80      |
| 3003       |  Kemeny  | 2020-11-12 |            |           |
| 4004       |  Wirth   | 2020-11-05 |  15.4      | 7.70      |
| 5005       |  Kurtz   |            |            |           |



Note

This task is aimed in particular at programming languages that are used in data science and data processing, such as F#, Python, R, SPSS, MATLAB etc.



Related tasks

 CSV data manipulation
 CSV to HTML translation
 Read entire file
 Read a file line by line

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.Serialization;
 
public static class MergeAndAggregateDatasets
{
    public static void Main()
    {
        string patientsCsv = @""
PATIENT_ID,LASTNAME
1001,Hopper
4004,Wirth
3003,Kemeny
2002,Gosling
5005,Kurtz"";
 
        string visitsCsv = @""
PATIENT_ID,VISIT_DATE,SCORE
2002,2020-09-10,6.8
1001,2020-09-17,5.5
4004,2020-09-24,8.4
2002,2020-10-08,
1001,,6.6
3003,2020-11-12,
4004,2020-11-05,7.0
1001,2020-11-19,5.3"";
 
        string format = ""yyyy-MM-dd"";
        var formatProvider = new DateTimeFormat(format).FormatProvider;
 
        var patients = ParseCsv(
            patientsCsv.Split(Environment.NewLine, StringSplitOptions.RemoveEmptyEntries),
            line => (PatientId: int.Parse(line[0]), LastName: line[1]));
 
        var visits = ParseCsv(
            visitsCsv.Split(Environment.NewLine, StringSplitOptions.RemoveEmptyEntries),
            line => (
                PatientId: int.Parse(line[0]),
                VisitDate: DateTime.TryParse(line[1], formatProvider, DateTimeStyles.None, out var date) ? date : default(DateTime?),
                Score: double.TryParse(line[2], out double score) ? score : default(double?)
            )
        );
 
        var results =
            patients.GroupJoin(visits,
                p => p.PatientId,
                v => v.PatientId,
                (p, vs) => (
                    p.PatientId,
                    p.LastName,
                    LastVisit: vs.Max(v => v.VisitDate),
                    ScoreSum: vs.Sum(v => v.Score),
                    ScoreAvg: vs.Average(v => v.Score)
                )
            ).OrderBy(r => r.PatientId);
 
        Console.WriteLine(""| PATIENT_ID | LASTNAME | LAST_VISIT | SCORE_SUM | SCORE_AVG |"");
        foreach (var r in results) {
            Console.WriteLine($""| {r.PatientId,-10} | {r.LastName,-8} | {r.LastVisit?.ToString(format) ?? """",-10} | {r.ScoreSum,9} | {r.ScoreAvg,9} |"");
        }
    }
 
    private static IEnumerable<T> ParseCsv<T>(string[] contents, Func<string[], T> constructor)
    {
        for (int i = 1; i < contents.Length; i++) {
            var line = contents[i].Split(',');
            yield return constructor(line);
        }
    }
 
}",2305,73
34929,http://rosettacode.org/wiki/Miller%E2%80%93Rabin_primality_test,Miller–Rabin primality test,"

 This page uses content from Wikipedia. The original article was at Miller–Rabin primality test. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The Miller–Rabin primality test or Rabin–Miller primality test is a primality test: an algorithm which determines whether a given number is prime or not.

The algorithm, as modified by Michael O. Rabin to avoid the generalized Riemann hypothesis, is a probabilistic algorithm.

The pseudocode, from Wikipedia is:

Input: n > 2, an odd integer to be tested for primality;
       k, a parameter that determines the accuracy of the test
Output: composite if n is composite, otherwise probably prime
write n − 1 as 2s·d with d odd by factoring powers of 2 from n − 1
LOOP: repeat k times:
   pick a randomly in the range [2, n − 1]
   x ← ad mod n
   if x = 1 or x = n − 1 then do next LOOP
   repeat s − 1 times:
      x ← x2 mod n
      if x = 1 then return composite
      if x = n − 1 then do next LOOP
   return composite
return probably prime

 The nature of the test involves big numbers, so the use of ""big numbers"" libraries (or similar features of the language of your choice) are suggested, but not mandatory.
 Deterministic variants of the test exist and can be implemented as extra (not mandatory to complete the task)

",#C.23,C#,"public static class RabinMiller
{
    public static bool IsPrime(int n, int k)
    {
        if ((n < 2) || (n % 2 == 0)) return (n == 2);
 
        int s = n - 1;
        while (s % 2 == 0)  s >>= 1;
 
        Random r = new Random();
        for (int i = 0; i < k; i++)
        {
            int a = r.Next(n - 1) + 1;
            int temp = s;
            long mod = 1;
            for (int j = 0; j < temp; ++j)  mod = (mod * a) % n;
            while (temp != n - 1 && mod != 1 && mod != n - 1)
            {
                mod = (mod * mod) % n;
                temp *= 2;
            }
 
            if (mod != n - 1 && temp % 2 == 0) return false;
        }
        return true;
    }
}",695,27
35030,http://rosettacode.org/wiki/Memory_allocation,Memory allocation,"Task

Show how to explicitly allocate and deallocate blocks of memory in your language.

Show access to different types of memory (i.e., heap, stack, shared, foreign) if applicable.



",#C.23,C#,"using System;
using System.Runtime.InteropServices;
 
public unsafe class Program
{
    public static unsafe void HeapMemory()
    {
        const int HEAP_ZERO_MEMORY = 0x00000008;
        const int size = 1000;
        int ph = GetProcessHeap();
        void* pointer = HeapAlloc(ph, HEAP_ZERO_MEMORY, size);
        if (pointer == null)
            throw new OutOfMemoryException();
        Console.WriteLine(HeapSize(ph, 0, pointer));
        HeapFree(ph, 0, pointer);
    }
 
    public static unsafe void StackMemory()
    {
        byte* buffer = stackalloc byte[1000];
        // buffer is automatically discarded when the method returns
    }
    public static void Main(string[] args)
    {
        HeapMemory();
        StackMemory();
    }
    [DllImport(""kernel32"")]
    static extern void* HeapAlloc(int hHeap, int flags, int size);
    [DllImport(""kernel32"")]
    static extern bool HeapFree(int hHeap, int flags, void* block);
    [DllImport(""kernel32"")]
    static extern int GetProcessHeap();
    [DllImport(""kernel32"")]
    static extern int HeapSize(int hHeap, int flags, void* block);
 
}",1109,37
35165,http://rosettacode.org/wiki/Menu,Menu,"Task

Given a prompt and a list containing a number of strings of which one is to be selected, create a function that:

 prints a textual menu formatted as an index value followed by its corresponding string for each item in the list;
 prompts the user to enter a number;
 returns the string corresponding to the selected index number.


The function should reject input that is not an integer or is out of range by redisplaying the whole menu before asking again for a number. The function should return an empty string if called with an empty list.

For test purposes use the following four phrases in a list:

   fee fie
   huff and puff
   mirror mirror
   tick tock

Note

This task is fashioned after the action of the Bash select statement.
",#C.23,C#," 
using System;
using System.Collections.Generic;
 
public class Menu
{
        static void Main(string[] args)
        {
            List<string> menu_items = new List<string>() { ""fee fie"", ""huff and puff"", ""mirror mirror"", ""tick tock"" };
            //List<string> menu_items = new List<string>();
            Console.WriteLine(PrintMenu(menu_items));
            Console.ReadLine();
        }
        private static string PrintMenu(List<string> items)
        {
            if (items.Count == 0)
                return """";
 
            string input = """";
            int i = -1;
            do
            {
                for (int j = 0; j < items.Count; j++)
                    Console.WriteLine(""{0}) {1}"", j, items[j]);
 
                Console.WriteLine(""What number?"");
                input = Console.ReadLine();
 
            } while (!int.TryParse(input, out i) || i >= items.Count || i < 0);
            return items[i];
        }
}
 ",953,33
35185,http://rosettacode.org/wiki/MD5/Implementation,MD5/Implementation,"The purpose of this task to code and validate an implementation of the MD5 Message Digest Algorithm by coding the algorithm directly (not using a call to a built-in or external hashing library). For details of the algorithm refer to MD5 on Wikipedia or the MD5 definition in IETF RFC (1321).

 The implementation needs to implement the key functionality namely producing a correct message digest for an input string. It is not necessary to mimic all of the calling modes such as adding to a digest one block at a time over subsequent calls. 
 In addition to coding and verifying your implementation, note any challenges your language presented implementing the solution, implementation choices made, or limitations of your solution. 
 Solutions on this page should implement MD5 directly and NOT use built in (MD5) functions, call outs to operating system calls or library routines written in other languages as is common in the original MD5 task.
 The following are acceptable:
 An original implementation from the specification, reference implementation, or pseudo-code
 A translation of a correct implementation from another language
 A library routine in the same language; however, the source must be included here.


The solutions shown here will provide practical illustrations of bit manipulation, unsigned integers, working with little-endian data. Additionally, the task requires an attention to details such as boundary conditions since being out by even 1 bit will produce dramatically different results. Subtle implementation bugs can result in some hashes being correct while others are wrong. Not only is it critical to get the individual sub functions working correctly, even small errors in padding, endianness, or data layout will result in failure.

RFC 1321
                            hash code <== string 
   0xd41d8cd98f00b204e9800998ecf8427e <== """"  
   0x0cc175b9c0f1b6a831c399e269772661 <== ""a""
   0x900150983cd24fb0d6963f7d28e17f72 <== ""abc""
   0xf96b697d7cb7938d525a2f31aaf161d0 <== ""message digest""
   0xc3fcd3d76192e4007dfb496cca67e13b <== ""abcdefghijklmnopqrstuvwxyz""
   0xd174ab98d277d9f5a5611c2c9f419d9f <== ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789""
   0x57edf4a22be3c955ac49da2e2107b67a <== ""12345678901234567890123456789012345678901234567890123456789012345678901234567890""
In addition, intermediate outputs to aid in developing an implementation can be found here.

The MD5 Message-Digest Algorithm was developed by RSA Data Security, Inc. in 1991.



 Warning
Rosetta Code is not a place you should rely on for examples of code in critical roles, including security.
Also, note that MD5 has been broken and should not be used in applications requiring security. For these consider SHA2 or the upcoming SHA3.
",#C.23,C#," 
	/// Represent digest with ABCD
	sealed public class Digest
	{
		public uint A;
		public uint B;
		public uint C;
		public uint D;
 
		public Digest()
		{
			A=(uint)MD5InitializerConstant.A;
			B=(uint)MD5InitializerConstant.B;
			C=(uint)MD5InitializerConstant.C;
			D=(uint)MD5InitializerConstant.D;
       	        }
 
		public override string ToString()
		{
			string st ;
			st= MD5Helper.ReverseByte(A).ToString(""X8"")+
			    MD5Helper.ReverseByte(B).ToString(""X8"")+
                            MD5Helper.ReverseByte(C).ToString(""X8"")+
			    MD5Helper.ReverseByte(D).ToString(""X8"");
			return st;
 
		}
	}
 
	public class MD5
	{
		/***********************VARIABLES************************************/
 
 
		/***********************Statics**************************************/
		/// <summary>
		/// lookup table 4294967296*sin(i)
		/// </summary>
		protected readonly static uint []  T =new uint[64] 
			{	0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee,
				0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501,
                0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be,
                0x6b901122,0xfd987193,0xa679438e,0x49b40821,
				0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa,
                0xd62f105d,0x2441453,0xd8a1e681,0xe7d3fbc8,
                0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed,
				0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a,
                0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c,
                0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70,
                0x289b7ec6,0xeaa127fa,0xd4ef3085,0x4881d05,
				0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665,
                0xf4292244,0x432aff97,0xab9423a7,0xfc93a039,
                0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1,
                0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1,
				0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391};
 
		/*****instance variables**************/
		/// <summary>
		/// X used to proces data in 
		///	512 bits chunks as 16 32 bit word
		/// </summary>
		protected  uint [] X = new uint [16];	
 
		/// <summary>
		/// the finger print obtained. 
		/// </summary>
		protected Digest dgFingerPrint;			
 
		/// <summary>
		/// the input bytes
		/// </summary>
		protected	byte [] m_byteInput;		
 
 
 
		/**********************EVENTS AND DELEGATES*******************************************/
 
		public delegate void ValueChanging (object sender,MD5ChangingEventArgs Changing);
		public delegate void ValueChanged (object sender,MD5ChangedEventArgs Changed);
 
 
		public event ValueChanging OnValueChanging;
		public event ValueChanged  OnValueChanged;
 
 
 
		/********************************************************************/
		/***********************PROPERTIES ***********************/
		/// <summary>
		///gets or sets as string
		/// </summary>
		public string Value
		{
			get
			{ 
				string st ;
				char [] tempCharArray= new Char[m_byteInput.Length];
 
				for(int i =0; i<m_byteInput.Length;i++)
					tempCharArray[i]=(char)m_byteInput[i];
 
				st= new String(tempCharArray);
				return st;
			}
			set
			{
				/// raise the event to notify the changing 
				if (this.OnValueChanging !=null)
					this.OnValueChanging(this,new MD5ChangingEventArgs(value));
 
 
				m_byteInput=new byte[value.Length];
				for (int i =0; i<value.Length;i++)
					m_byteInput[i]=(byte)value[i];
				dgFingerPrint=CalculateMD5Value();				
 
				/// raise the event to notify the change
				if (this.OnValueChanged !=null)
					this.OnValueChanged(this,new MD5ChangedEventArgs(value,dgFingerPrint.ToString()));
 
			}
		}		
 
		/// <summary>
		/// get/sets as  byte array 
		/// </summary>
		public byte [] ValueAsByte
		{
			get
			{
				byte [] bt = new byte[m_byteInput.Length];
				for (int i =0; i<m_byteInput.Length;i++)
					bt[i]=m_byteInput[i];
				return bt;
          }
			set
			{
				/// raise the event to notify the changing
				if (this.OnValueChanging !=null)
					this.OnValueChanging(this,new MD5ChangingEventArgs(value));
 
				m_byteInput=new byte[value.Length];
				for (int i =0; i<value.Length;i++)
					m_byteInput[i]=value[i];
				dgFingerPrint=CalculateMD5Value();
 
 
				/// notify the changed  value
				if (this.OnValueChanged !=null)
					this.OnValueChanged(this,new MD5ChangedEventArgs(value,dgFingerPrint.ToString()));
			}
		}
 
		//gets the signature/figner print as string
		public  string FingerPrint
		{
			get
			{
				return dgFingerPrint.ToString();
			}
		}
 
 
		/*************************************************************************/
		/// <summary>
		/// Constructor
		/// </summary>
		public MD5()
		{			
			Value="""";
		}
 
 
		/******************************************************************************/
		/*********************METHODS**************************/
 
		/// <summary>
		/// calculat md5 signature of the string in Input
		/// </summary>
		/// <returns> Digest: the finger print of msg</returns>
		protected Digest CalculateMD5Value()
		{
			/***********vairable declaration**************/
			byte [] bMsg;	//buffer to hold bits
			uint N;			//N is the size of msg as  word (32 bit) 
			Digest dg =new Digest();			//  the value to be returned
 
			// create a buffer with bits padded and length is alos padded
			bMsg=CreatePaddedBuffer();
 
			N=(uint)(bMsg.Length*8)/32;		//no of 32 bit blocks
 
			for (uint  i=0; i<N/16;i++)
			{
				CopyBlock(bMsg,i);
				PerformTransformation(ref dg.A,ref dg.B,ref dg.C,ref dg.D);
			}
			return dg;
		}
 
		/********************************************************
		 * TRANSFORMATIONS :  FF , GG , HH , II  acc to RFC 1321
		 * where each Each letter represnets the aux function used
		 *********************************************************/
 
 
 
		/// <summary>
		/// perform transformatio using f(((b&c) | (~(b)&d))
		/// </summary>
		protected void TransF(ref uint a, uint b, uint c, uint d,uint k,ushort s, uint i )
		{
			a = b + MD5Helper.RotateLeft((a + ((b&c) | (~(b)&d)) + X[k] + T[i-1]), s);
		}
 
		/// <summary>
		/// perform transformatio using g((b&d) | (c & ~d) )
		/// </summary>
		protected void TransG(ref uint a, uint b, uint c, uint d,uint k,ushort s, uint i )
		{
			a = b + MD5Helper.RotateLeft((a + ((b&d) | (c & ~d) ) + X[k] + T[i-1]), s);
		}
 
		/// <summary>
		/// perform transformatio using h(b^c^d)
		/// </summary>
		protected void TransH(ref uint a, uint b, uint c, uint d,uint k,ushort s, uint i )
		{
			a = b + MD5Helper.RotateLeft((a + (b^c^d) + X[k] + T[i-1]), s);
		}
 
		/// <summary>
		/// perform transformatio using i (c^(b|~d))
		/// </summary>
		protected void TransI(ref uint a, uint b, uint c, uint d,uint k,ushort s, uint i )
		{
			a = b + MD5Helper.RotateLeft((a + (c^(b|~d))+ X[k] + T[i-1]), s);
		}
 
 
 
		/// <summary>
		/// Perform All the transformation on the data
		/// </summary>
		/// <param name=""A"">A</param>
		/// <param name=""B"">B </param>
		/// <param name=""C"">C</param>
		/// <param name=""D"">D</param>
		protected void PerformTransformation(ref uint A,ref uint B,ref uint C, ref uint D)
		{
			//// saving  ABCD  to be used in end of loop
 
			uint AA,BB,CC,DD;
 
			AA=A;	
			BB=B;
			CC=C;
			DD=D;
 
			/* Round 1 
				* [ABCD  0  7  1]  [DABC  1 12  2]  [CDAB  2 17  3]  [BCDA  3 22  4]
				* [ABCD  4  7  5]  [DABC  5 12  6]  [CDAB  6 17  7]  [BCDA  7 22  8]
				* [ABCD  8  7  9]  [DABC  9 12 10]  [CDAB 10 17 11]  [BCDA 11 22 12]
				* [ABCD 12  7 13]  [DABC 13 12 14]  [CDAB 14 17 15]  [BCDA 15 22 16]
				*  * */
			TransF(ref A,B,C,D,0,7,1);TransF(ref D,A,B,C,1,12,2);TransF(ref C,D,A,B,2,17,3);TransF(ref B,C,D,A,3,22,4);
			TransF(ref A,B,C,D,4,7,5);TransF(ref D,A,B,C,5,12,6);TransF(ref C,D,A,B,6,17,7);TransF(ref B,C,D,A,7,22,8);
			TransF(ref A,B,C,D,8,7,9);TransF(ref D,A,B,C,9,12,10);TransF(ref C,D,A,B,10,17,11);TransF(ref B,C,D,A,11,22,12);
			TransF(ref A,B,C,D,12,7,13);TransF(ref D,A,B,C,13,12,14);TransF(ref C,D,A,B,14,17,15);TransF(ref B,C,D,A,15,22,16);
			/** rOUND 2
				**[ABCD  1  5 17]  [DABC  6  9 18]  [CDAB 11 14 19]  [BCDA  0 20 20]
				*[ABCD  5  5 21]  [DABC 10  9 22]  [CDAB 15 14 23]  [BCDA  4 20 24]
				*[ABCD  9  5 25]  [DABC 14  9 26]  [CDAB  3 14 27]  [BCDA  8 20 28]
				*[ABCD 13  5 29]  [DABC  2  9 30]  [CDAB  7 14 31]  [BCDA 12 20 32]
			*/
			TransG(ref A,B,C,D,1,5,17);TransG(ref D,A,B,C,6,9,18);TransG(ref C,D,A,B,11,14,19);TransG(ref B,C,D,A,0,20,20);
			TransG(ref A,B,C,D,5,5,21);TransG(ref D,A,B,C,10,9,22);TransG(ref C,D,A,B,15,14,23);TransG(ref B,C,D,A,4,20,24);
			TransG(ref A,B,C,D,9,5,25);TransG(ref D,A,B,C,14,9,26);TransG(ref C,D,A,B,3,14,27);TransG(ref B,C,D,A,8,20,28);
			TransG(ref A,B,C,D,13,5,29);TransG(ref D,A,B,C,2,9,30);TransG(ref C,D,A,B,7,14,31);TransG(ref B,C,D,A,12,20,32);
			/*  rOUND 3
				* [ABCD  5  4 33]  [DABC  8 11 34]  [CDAB 11 16 35]  [BCDA 14 23 36]
				* [ABCD  1  4 37]  [DABC  4 11 38]  [CDAB  7 16 39]  [BCDA 10 23 40]
				* [ABCD 13  4 41]  [DABC  0 11 42]  [CDAB  3 16 43]  [BCDA  6 23 44]
				* [ABCD  9  4 45]  [DABC 12 11 46]  [CDAB 15 16 47]  [BCDA  2 23 48]
			 * */
			TransH(ref A,B,C,D,5,4,33);TransH(ref D,A,B,C,8,11,34);TransH(ref C,D,A,B,11,16,35);TransH(ref B,C,D,A,14,23,36);
			TransH(ref A,B,C,D,1,4,37);TransH(ref D,A,B,C,4,11,38);TransH(ref C,D,A,B,7,16,39);TransH(ref B,C,D,A,10,23,40);
			TransH(ref A,B,C,D,13,4,41);TransH(ref D,A,B,C,0,11,42);TransH(ref C,D,A,B,3,16,43);TransH(ref B,C,D,A,6,23,44);
			TransH(ref A,B,C,D,9,4,45);TransH(ref D,A,B,C,12,11,46);TransH(ref C,D,A,B,15,16,47);TransH(ref B,C,D,A,2,23,48);
			/*ORUNF  4
				*[ABCD  0  6 49]  [DABC  7 10 50]  [CDAB 14 15 51]  [BCDA  5 21 52]
				*[ABCD 12  6 53]  [DABC  3 10 54]  [CDAB 10 15 55]  [BCDA  1 21 56]
				*[ABCD  8  6 57]  [DABC 15 10 58]  [CDAB  6 15 59]  [BCDA 13 21 60]
				*[ABCD  4  6 61]  [DABC 11 10 62]  [CDAB  2 15 63]  [BCDA  9 21 64]
						 * */
			TransI(ref A,B,C,D,0,6,49);TransI(ref D,A,B,C,7,10,50);TransI(ref C,D,A,B,14,15,51);TransI(ref B,C,D,A,5,21,52);
			TransI(ref A,B,C,D,12,6,53);TransI(ref D,A,B,C,3,10,54);TransI(ref C,D,A,B,10,15,55);TransI(ref B,C,D,A,1,21,56);
			TransI(ref A,B,C,D,8,6,57);TransI(ref D,A,B,C,15,10,58);TransI(ref C,D,A,B,6,15,59);TransI(ref B,C,D,A,13,21,60);
			TransI(ref A,B,C,D,4,6,61);TransI(ref D,A,B,C,11,10,62);TransI(ref C,D,A,B,2,15,63);TransI(ref B,C,D,A,9,21,64);
 
 
			A=A+AA;
			B=B+BB;
			C=C+CC;
			D=D+DD;
 
 
		}
 
 
		/// <summary>
		/// Create Padded buffer for processing , buffer is padded with 0 along 
		/// with the size in the end
		/// </summary>
		/// <returns>the padded buffer as byte array</returns>
		protected byte[] CreatePaddedBuffer()
		{
			uint pad;		//no of padding bits for 448 mod 512 
			byte [] bMsg;	//buffer to hold bits
			ulong sizeMsg;		//64 bit size pad
			uint sizeMsgBuff;	//buffer size in multiple of bytes
			int temp=(448-((m_byteInput.Length*8)%512)); //temporary 
 
 
			pad = (uint )((temp+512)%512);		//getting no of bits to  be pad
			if (pad==0)				///pad is in bits
				pad=512;			//at least 1 or max 512 can be added
 
			sizeMsgBuff= (uint) ((m_byteInput.Length)+ (pad/8)+8);
			sizeMsg=(ulong)m_byteInput.Length*8;
			bMsg=new byte[sizeMsgBuff];	///no need to pad with 0 coz new bytes 
			// are already initialize to 0 :)
 
 
 
 
			////copying string to buffer 
			for (int i =0; i<m_byteInput.Length;i++)
				bMsg[i]=m_byteInput[i];
 
			bMsg[m_byteInput.Length]|=0x80;		///making first bit of padding 1,
 
			//wrting the size value
			for (int i =8; i >0;i--)
				bMsg[sizeMsgBuff-i]=(byte) (sizeMsg>>((8-i)*8) & 0x00000000000000ff);
 
			return bMsg;
		}
 
 
		/// <summary>
		/// Copies a 512 bit block into X as 16 32 bit words
		/// </summary>
		/// <param name=""bMsg""> source buffer</param>
		/// <param name=""block"">no of block to copy starting from 0</param>
		protected void CopyBlock(byte[] bMsg,uint block)
		{
 
			block=block<<6;
			for (uint j=0; j<61;j+=4)
			{
				X[j>>2]=(((uint) bMsg[block+(j+3)]) <<24 ) |
						(((uint) bMsg[block+(j+2)]) <<16 ) |
						(((uint) bMsg[block+(j+1)]) <<8 ) |
						(((uint) bMsg[block+(j)]) ) ;
 
			}
		}
	}
 
 ",11959,371
35511,http://rosettacode.org/wiki/McNuggets_problem,McNuggets problem,"Wikipedia
The McNuggets version of the coin problem was introduced by Henri Picciotto,
who included it in his algebra textbook co-authored with Anita Wah. Picciotto
thought of the application in the 1980s while dining with his son at
McDonald's, working the problem out on a napkin. A McNugget number is
the total number of McDonald's Chicken McNuggets in any number of boxes.
In the United Kingdom, the original boxes (prior to the introduction of
the Happy Meal-sized nugget boxes) were of 6, 9, and 20 nuggets.

Task

Calculate (from 0 up to a limit of 100) the largest non-McNuggets
number (a number n which cannot be expressed with 6x + 9y + 20z = n
where x, y and z are natural numbers).



",#C.23,C#," 
using System;
 
public class McNuggets
{
   public static void Main()
   {
      bool[] isMcNuggetNumber = new bool[101];
 
      for (int x = 0; x <= 100/6; x++)
      {
         for (int y = 0; y <= 100/9; y++)
         {
            for (int z = 0; z <= 100/20; z++)
            {
               int mcNuggetNumber = x*6 + y*9 + z*20;
               if (mcNuggetNumber <= 100)
               {
                  isMcNuggetNumber[mcNuggetNumber] = true;
               }
            }
         } 
      }
 
      for (int mnnCheck = isMcNuggetNumber.Length-1; mnnCheck >= 0; mnnCheck--)
      {
         if (!isMcNuggetNumber[mnnCheck])
         {
            Console.WriteLine(""Largest non-McNuggett Number less than 100: "" + mnnCheck.ToString());
            break;
         }
      }
   }
}
 ",799,35
35521,http://rosettacode.org/wiki/MD4,MD4,"Find the MD4 message digest of a string of octets.
Use the ASCII encoded string “Rosetta Code” (without quotes).
You may either call an MD4 library, or implement MD4 in your language.

MD4 is an obsolete hash function that computes a 128-bit message digest that sometimes appears in obsolete protocols.

RFC 1320 specifies the MD4 algorithm. RFC 6150 declares that MD4 is obsolete.
",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
static class Md4
{
    public static string Md4Hash(this string input)
    {
        // get padded uints from bytes
        List<byte> bytes = Encoding.ASCII.GetBytes(input).ToList();
        uint bitCount = (uint)(bytes.Count) * 8;
        bytes.Add(128);
        while (bytes.Count % 64 != 56) bytes.Add(0);
        var uints = new List<uint>();
        for (int i = 0; i + 3 < bytes.Count; i += 4)
            uints.Add(bytes[i] | (uint)bytes[i + 1] << 8 | (uint)bytes[i + 2] << 16 | (uint)bytes[i + 3] << 24);
        uints.Add(bitCount);
        uints.Add(0);
 
        // run rounds
        uint a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476;
        Func<uint, uint, uint> rol = (x, y) => x << (int)y | x >> 32 - (int)y;
        for (int q = 0; q + 15 < uints.Count; q += 16)
        {
            var chunk = uints.GetRange(q, 16);
            uint aa = a, bb = b, cc = c, dd = d;
            Action<Func<uint, uint, uint, uint>, uint[]> round = (f, y) =>
            {
                foreach (uint i in new[] { y[0], y[1], y[2], y[3] })
                {
                    a = rol(a + f(b, c, d) + chunk[(int)(i + y[4])] + y[12], y[8]);
                    d = rol(d + f(a, b, c) + chunk[(int)(i + y[5])] + y[12], y[9]);
                    c = rol(c + f(d, a, b) + chunk[(int)(i + y[6])] + y[12], y[10]);
                    b = rol(b + f(c, d, a) + chunk[(int)(i + y[7])] + y[12], y[11]);
                }
            };
            round((x, y, z) => (x & y) | (~x & z), new uint[] { 0, 4, 8, 12, 0, 1, 2, 3, 3, 7, 11, 19, 0 });
            round((x, y, z) => (x & y) | (x & z) | (y & z), new uint[] { 0, 1, 2, 3, 0, 4, 8, 12, 3, 5, 9, 13, 0x5a827999 });
            round((x, y, z) => x ^ y ^ z, new uint[] { 0, 2, 1, 3, 0, 8, 4, 12, 3, 9, 11, 15, 0x6ed9eba1 });
            a += aa; b += bb; c += cc; d += dd;
        }
 
        // return hex encoded string
        byte[] outBytes = new[] { a, b, c, d }.SelectMany(BitConverter.GetBytes).ToArray();
        return BitConverter.ToString(outBytes).Replace(""-"", """").ToLower();
    }
    static void Main() { Console.WriteLine(""Rosetta Code"".Md4Hash()); }
}",2226,48
35604,http://rosettacode.org/wiki/Maximum_triangle_path_sum,Maximum triangle path sum,"Starting from the top of a pyramid of numbers like this, you can walk down going one step on the right or on the left, until you reach the bottom row:

                          55
                        94 48
                       95 30 96
                     77 71 26 67

One of such walks is 55 - 94 - 30 - 26.
You can compute the total of the numbers you have seen in such walk,
in this case it's 205.

Your problem is to find the maximum total among all possible paths from the top to the bottom row of the triangle. In the little example above it's 321.



Task

Find the maximum total in the triangle below:

                          55
                        94 48
                       95 30 96
                     77 71 26 67
                    97 13 76 38 45
                  07 36 79 16 37 68
                 48 07 09 18 70 26 06
               18 72 79 46 59 79 29 90
              20 76 87 11 32 07 07 49 18
            27 83 58 35 71 11 25 57 29 85
           14 64 36 96 27 11 58 56 92 18 55
         02 90 03 60 48 49 41 46 33 36 47 23
        92 50 48 02 36 59 42 79 72 20 82 77 42
      56 78 38 80 39 75 02 71 66 66 01 03 55 72
     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36
   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52
  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15
27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93

Such numbers can be included in the solution code, or read from a ""triangle.txt"" file.

This task is derived from the Euler Problem #18.



",#C.23,C#," 
using System;
 
namespace RosetaCode
{
	class MainClass
	{
		public static void Main (string[] args)
		{
			int[,] list = new int[18,19];
			string input = @""55
	                        94 48
	                       95 30 96
	                     77 71 26 67
	                    97 13 76 38 45
	                  07 36 79 16 37 68
	                 48 07 09 18 70 26 06
	               18 72 79 46 59 79 29 90
	              20 76 87 11 32 07 07 49 18
	            27 83 58 35 71 11 25 57 29 85
	           14 64 36 96 27 11 58 56 92 18 55
	         02 90 03 60 48 49 41 46 33 36 47 23
	        92 50 48 02 36 59 42 79 72 20 82 77 42
	      56 78 38 80 39 75 02 71 66 66 01 03 55 72
	     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36
	   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52
	  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15
	27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93"";
			var charArray = input.Split ('\n');
 
			for (int i=0; i < charArray.Length; i++) {
				var numArr = charArray[i].Trim().Split(' ');
 
				for (int j = 0; j<numArr.Length; j++)
				{
					int number = Convert.ToInt32 (numArr[j]);
					list [i, j] = number;
				}
			}
 
			for (int i = 16; i >= 0; i--) {
				for (int j = 0; j < 18; j++) {
					list[i,j] = Math.Max(list[i, j] + list[i+1, j], list[i,j] + list[i+1, j+1]);
				}
			}
			Console.WriteLine (string.Format(""Maximum total: {0}"", list [0, 0]));
		}
	}
}
 
 ",1421,51
35635,http://rosettacode.org/wiki/MD5,MD5,"Task

Encode a string using an MD5 algorithm.   The algorithm can be found on   Wikipedia.



Optionally, validate your implementation by running all of the test values in   IETF RFC (1321)   for MD5.

Additionally,   RFC 1321   provides more precise information on the algorithm than the Wikipedia article.



 Warning:   MD5 has known weaknesses, including collisions and forged signatures.   Users may consider a stronger alternative when doing production-grade cryptography, such as SHA-256 (from the SHA-2 family), or the upcoming SHA-3.

If the solution on this page is a library solution, see   MD5/Implementation   for an implementation from scratch.



",#C.23,C#,"using System.Text;
using System.Security.Cryptography;
 
byte[] data = Encoding.ASCII.GetBytes(""The quick brown fox jumped over the lazy dog's back"");
byte[] hash = MD5.Create().ComputeHash(data);
Console.WriteLine(BitConverter.ToString(hash).Replace(""-"", """").ToLower());",271,6
35685,http://rosettacode.org/wiki/Matrix-exponentiation_operator,Matrix-exponentiation operator,"Most programming languages have a built-in implementation of exponentiation for integers and reals only.



Task

Demonstrate how to implement matrix exponentiation as an operator.



",#C.23,C#,"using System;
using System.Collections;
using System.Collections.Generic;
using static System.Linq.Enumerable;
 
public static class MatrixExponentation
{
    public static double[,] Identity(int size) {
        double[,] matrix = new double[size, size];
        for (int i = 0; i < size; i++) matrix[i, i] = 1;
        return matrix;
    }
 
    public static double[,] Multiply(this double[,] left, double[,] right) {
        if (left.ColumnCount() != right.RowCount()) throw new ArgumentException();
        double[,] m = new double[left.RowCount(), right.ColumnCount()];
        foreach (var (row, column) in from r in Range(0, m.RowCount()) from c in Range(0, m.ColumnCount()) select (r, c)) {
            m[row, column] = Range(0, m.RowCount()).Sum(i => left[row, i] * right[i, column]);
        }
        return m;
    }
 
    public static double[,] Pow(this double[,] matrix, int exp) {
        if (matrix.RowCount() != matrix.ColumnCount()) throw new ArgumentException(""Matrix must be square."");
        double[,] accumulator = Identity(matrix.RowCount());
        for (int i = 0; i < exp; i++) {
            accumulator = accumulator.Multiply(matrix);
        }
        return accumulator;
    }
 
    private static int RowCount(this double[,] matrix) => matrix.GetLength(0);
    private static int ColumnCount(this double[,] matrix) => matrix.GetLength(1);
 
    private static void Print(this double[,] m) {
        foreach (var row in Rows()) {
            Console.WriteLine(""[ "" + string.Join(""   "", row) + "" ]"");
        }
        Console.WriteLine();
 
        IEnumerable<IEnumerable<double>> Rows() =>
            Range(0, m.RowCount()).Select(row => Range(0, m.ColumnCount()).Select(column => m[row, column]));
    }
 
    public static void Main() {
        var matrix = new double[,] {
            { 3, 2 },
            { 2, 1 }
        };
 
        matrix.Pow(0).Print();
        matrix.Pow(1).Print();
        matrix.Pow(2).Print();
        matrix.Pow(3).Print();
        matrix.Pow(4).Print();
        matrix.Pow(50).Print();
    }
 
}",2061,59
35688,http://rosettacode.org/wiki/Matrix_chain_multiplication,Matrix chain multiplication,"Problem
Using the most straightfoward algorithm (which we assume here), computing the product of two matrices of dimensions (n1,n2) and (n2,n3) requires n1*n2*n3 FMA operations. The number of operations required to compute the product of matrices A1, A2... An depends on the order of matrix multiplications, hence on where parens are put. Remember that the matrix product is associative, but not commutative, hence only the parens can be moved.

For instance, with four matrices, one can compute A(B(CD)), A((BC)D), (AB)(CD), (A(BC))D, (AB)C)D. The number of different ways to put the parens is a Catalan number, and grows exponentially with the number of factors.

Here is an example of computation of the total cost, for matrices A(5,6), B(6,3), C(3,1):

 AB costs 5*6*3=90 and produces a matrix of dimensions (5,3), then (AB)C costs 5*3*1=15. The total cost is 105.
 BC costs 6*3*1=18 and produces a matrix of dimensions (6,1), then A(BC) costs 5*6*1=30. The total cost is 48.
In this case, computing (AB)C requires more than twice as many operations as A(BC). The difference can be much more dramatic in real cases.

Task
Write a function which, given a list of the successive dimensions of matrices A1, A2... An, of arbitrary length, returns the optimal way to compute the matrix product, and the total cost. Any sensible way to describe the optimal solution is accepted. The input list does not duplicate shared dimensions: for the previous example of matrices A,B,C, one will only pass the list [5,6,3,1] (and not [5,6,6,3,3,1]) to mean the matrix dimensions are respectively (5,6), (6,3) and (3,1). Hence, a product of n matrices is represented by a list of n+1 dimensions.

Try this function on the following two lists:

 [1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2]
 [1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10]
To solve the task, it's possible, but not required, to write a function that enumerates all possible ways to parenthesize the product. This is not optimal because of the many duplicated computations, and this task is a classic application of dynamic programming.

See also Matrix chain multiplication on Wikipedia.
",#C.23,C#,"using System;
 
class MatrixChainOrderOptimizer {
    private int[,] m;
    private int[,] s;
 
    void OptimalMatrixChainOrder(int[] dims) {
        int n = dims.Length - 1;
        m = new int[n, n];
        s = new int[n, n];
        for (int len = 1; len < n; ++len) {
            for (int i = 0; i < n - len; ++i) {
                int j = i + len;
                m[i, j] = Int32.MaxValue;
                for (int k = i; k < j; ++k) {
                    int temp = dims[i] * dims[k + 1] * dims[j + 1];
                    int cost = m[i, k] + m[k + 1, j] + temp;
                    if (cost < m[i, j]) {
                        m[i, j] = cost;
                        s[i, j] = k;
                    }
                }
            }
        }
    }
 
    void PrintOptimalChainOrder(int i, int j) {
        if (i == j)
            Console.Write((char)(i + 65));
        else {
            Console.Write(""("");
            PrintOptimalChainOrder(i, s[i, j]);
            PrintOptimalChainOrder(s[i, j] + 1, j);
            Console.Write("")"");
        }
    }
 
    static void Main() {
        var mcoo = new MatrixChainOrderOptimizer();
        var dimsList = new int[3][];
        dimsList[0] = new int[4] {5, 6, 3, 1};
        dimsList[1] = new int[13] {1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2};
        dimsList[2] = new int[12] {1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10};
        for (int i = 0; i < dimsList.Length; ++i) {
            Console.Write(""Dims  : ["");
            int n = dimsList[i].Length;
            for (int j = 0; j < n; ++j) {
                Console.Write(dimsList[i][j]);
                if (j < n - 1)
                    Console.Write("", "");
                else
                    Console.WriteLine(""]"");
            }
            mcoo.OptimalMatrixChainOrder(dimsList[i]);
            Console.Write(""Order : "");
            mcoo.PrintOptimalChainOrder(0, n - 2);
            Console.WriteLine(""\nCost  : {0}\n"",  mcoo.m[0, n - 2]);
        }
    }
}",2007,60
35824,http://rosettacode.org/wiki/Make_directory_path,Make directory path,"Task

Create a directory and any missing parents.

This task is named after the posix mkdir -p command, and several libraries which implement the same behavior.

Please implement a function of a single path string (for example ./path/to/dir) which has the above side-effect.
If the directory already exists, return successfully.
Ideally implementations will work equally well cross-platform (on windows, linux, and OS X).

It's likely that your language implements such a function as part of its standard library. If so, please also show how such a function would be implemented.



",#C.23,C#,System.IO.Directory.CreateDirectory(path),41,1
35861,http://rosettacode.org/wiki/Maze_generation,Maze generation,"

 This page uses content from Wikipedia. The original article was at Maze generation algorithm. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)




Task

Generate and show a maze, using the simple Depth-first search algorithm.

Start at a random cell.
Mark the current cell as visited, and get a list of its neighbors. For each neighbor, starting with a randomly selected neighbor:
If that neighbor hasn't been visited, remove the wall between this cell and that neighbor, and then recurse with that neighbor as the current cell.


 Related tasks
 Maze solving.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Drawing;
 
namespace MazeGeneration
{
    public static class Extensions
    {
        public static IEnumerable<T> Shuffle<T>(this IEnumerable<T> source, Random rng)
        {
            var e = source.ToArray();
            for (var i = e.Length - 1; i >= 0; i--)
            {
                var swapIndex = rng.Next(i + 1);
                yield return e[swapIndex];
                e[swapIndex] = e[i];
            }
        }
 
        public static CellState OppositeWall(this CellState orig)
        {
            return (CellState)(((int) orig >> 2) | ((int) orig << 2)) & CellState.Initial;
        }
 
        public static bool HasFlag(this CellState cs,CellState flag)
        {
            return ((int)cs & (int)flag) != 0;
        }
    }
 
    [Flags]
    public enum CellState
    {
        Top = 1,
        Right = 2,
        Bottom = 4,
        Left = 8,
        Visited = 128,
        Initial = Top | Right | Bottom | Left,
    }
 
    public struct RemoveWallAction
    {
        public Point Neighbour;
        public CellState Wall;
    }
 
    public class Maze
    {
        private readonly CellState[,] _cells;
        private readonly int _width;
        private readonly int _height;
        private readonly Random _rng;
 
        public Maze(int width, int height)
        {
            _width = width;
            _height = height;
            _cells = new CellState[width, height];
            for(var x=0; x<width; x++)
                for(var y=0; y<height; y++)
                    _cells[x, y] = CellState.Initial;
            _rng = new Random();
            VisitCell(_rng.Next(width), _rng.Next(height));
        }
 
        public CellState this[int x, int y]
        {
            get { return _cells[x,y]; }
            set { _cells[x,y] = value; }
        }
 
        public IEnumerable<RemoveWallAction> GetNeighbours(Point p)
        {
            if (p.X > 0) yield return new RemoveWallAction {Neighbour = new Point(p.X - 1, p.Y), Wall = CellState.Left};
            if (p.Y > 0) yield return new RemoveWallAction {Neighbour = new Point(p.X, p.Y - 1), Wall = CellState.Top};
            if (p.X < _width-1) yield return new RemoveWallAction {Neighbour = new Point(p.X + 1, p.Y), Wall = CellState.Right};
            if (p.Y < _height-1) yield return new RemoveWallAction {Neighbour = new Point(p.X, p.Y + 1), Wall = CellState.Bottom};
        }
 
        public void VisitCell(int x, int y)
        {
            this[x,y] |= CellState.Visited;
            foreach (var p in GetNeighbours(new Point(x, y)).Shuffle(_rng).Where(z => !(this[z.Neighbour.X, z.Neighbour.Y].HasFlag(CellState.Visited))))
            {
                this[x, y] -= p.Wall;
                this[p.Neighbour.X, p.Neighbour.Y] -= p.Wall.OppositeWall();
                VisitCell(p.Neighbour.X, p.Neighbour.Y);
            }
        }
 
        public void Display()
        {
            var firstLine = string.Empty;
            for (var y = 0; y < _height; y++)
            {
                var sbTop = new StringBuilder();
                var sbMid = new StringBuilder();
                for (var x = 0; x < _width; x++)
                {
                    sbTop.Append(this[x, y].HasFlag(CellState.Top) ? ""+--"" : ""+  "");
                    sbMid.Append(this[x, y].HasFlag(CellState.Left) ? ""|  "" : ""   "");
                }
                if (firstLine == string.Empty)
                    firstLine = sbTop.ToString();
                Debug.WriteLine(sbTop + ""+"");
                Debug.WriteLine(sbMid + ""|"");
                Debug.WriteLine(sbMid + ""|"");
            }
            Debug.WriteLine(firstLine);
        }
    }
 
    class Program
    {
        static void Main(string[] args)
        {
            var maze = new Maze(20, 20);
            maze.Display();
        }
    }
}
 ",3951,126
35887,http://rosettacode.org/wiki/Magnanimous_numbers,Magnanimous numbers,"A magnanimous number is an integer where there is no place in the number where a + (plus sign) could be added between any two digits to give a non-prime sum.



E.G.
 6425 is a magnanimous number. 6 + 425 == 431 which is prime; 64 + 25 == 89 which is prime; 642 + 5 == 647 which is prime.
 3538 is not a magnanimous number. 3 + 538 == 541 which is prime; 35 + 38 == 73 which is prime; but 353 + 8 == 361 which is not prime.


Traditionally the single digit numbers 0 through 9 are included as magnanimous numbers as there is no place in the number where you can add a plus between two digits at all. (Kind of weaselly but there you are...) Except for the actual value 0, leading zeros are not permitted. Internal zeros are fine though, 1001 -> 1 + 001 (prime), 10 + 01 (prime) 100 + 1 (prime).

There are only 571 known magnanimous numbers. It is strongly suspected, though not rigorously proved, that there are no magnanimous numbers above 97393713331910, the largest one known.



Task
 Write a routine (procedure, function, whatever) to find magnanimous numbers. 
 Use that function to find and display, here on this page the first 45 magnanimous numbers.
 Use that function to find and display, here on this page the 241st through 250th magnanimous numbers.
 Stretch: Use that function to find and display, here on this page the 391st through 400th magnanimous numbers


See also
 OEIS:A252996 - Magnanimous numbers: numbers such that the sum obtained by inserting a ""+"" anywhere between two digits gives a prime.

",#C.23,C#,"using System; using static System.Console;
 
class Program {
 
  static bool[] np; // not-prime array
 
  static void ms(long lmt) { // populates array, a not-prime is true 
    np = new bool[lmt]; np[0] = np[1] = true;
    for (long n = 2, j = 1; n < lmt; n += j, j = 2) if (!np[n])
        for (long k = n * n; k < lmt; k += n) np[k] = true; }
 
  static bool is_Mag(long n) { long res, rem;
    for (long p = 10; n >= p; p *= 10) {
      res = Math.DivRem (n, p, out rem);
      if (np[res + rem]) return false; } return true; }
 
  static void Main(string[] args) { ms(100_009); string mn;
    WriteLine(""First 45{0}"", mn = "" magnanimous numbers:"");
    for (long l = 0, c = 0; c < 400; l++) if (is_Mag(l)) {
      if (c++ < 45 || (c > 240 && c <= 250) || c > 390)
        Write(c <= 45 ? ""{0,4} "" : ""{0,8:n0} "", l);
      if (c < 45 && c % 15 == 0) WriteLine();
      if (c == 240) WriteLine (""\n\n241st through 250th{0}"", mn);
      if (c == 390) WriteLine (""\n\n391st through 400th{0}"", mn); } }
}",1004,25
35944,http://rosettacode.org/wiki/Man_or_boy_test,Man or boy test,"Man or boy test

You are encouraged to solve this task according to the task description, using any language you may know.

Background: The man or boy test was proposed by computer scientist Donald Knuth as a means of evaluating implementations of the ALGOL 60 programming language. The aim of the test was to distinguish compilers that correctly implemented ""recursion and non-local references"" from those that did not.


I have written the following simple routine, which may separate the 'man-compilers' from the 'boy-compilers'
 — Donald Knuth
Task: Imitate Knuth's example in Algol 60 in another language, as far as possible.

Details: Local variables of routines are often kept in activation records (also call frames). In many languages, these records are kept on a call stack. In Algol (and e.g. in Smalltalk), they are allocated on a heap instead. Hence it is possible to pass references to routines that still can use and update variables from their call environment, even if the routine where those variables are declared already returned. This difference in implementations is sometimes called the Funarg Problem.

In Knuth's example, each call to A allocates an activation record for the variable A. When B is called from A, any access to k now refers to this activation record. Now B in turn calls A, but passes itself as an argument. This argument remains bound to the activation record. This call to A also ""shifts"" the variables xi by one place, so eventually the argument B (still bound to its particular
activation record) will appear as x4 or x5 in a call to A. If this happens when the expression x4 + x5 is evaluated, then this will again call B, which in turn will update k in the activation record it was originally bound to. As this activation record is shared with other instances of calls to A and B, it will influence the whole computation.

So all the example does is to set up a convoluted calling structure, where updates to k can influence the behavior
in completely different parts of the call tree.

Knuth used this to test the correctness of the compiler, but one can of course also use it to test that other languages can emulate the Algol behavior correctly. If the handling of activation records is correct, the computed value will be −67.

Performance and Memory: Man or Boy is intense and can be pushed to challenge any machine. Memory (both stack and heap) not CPU time is the constraining resource as the recursion creates a proliferation activation records which will quickly exhaust memory and present itself through a stack error. Each language may have ways of adjusting the amount of memory or increasing the recursion depth. Optionally, show how you would make such adjustments.

The table below shows the result, call depths, and total calls for a range of k:



 k

 0

 1

 2

 3

 4

 5

 6

 7

 8

 9

 10

 11

 12

 13

 14

 15

 16

 17

 18

 19

 20

 21

 22

 23

 24

 25

 26

 27

 28

 29

 30


 A

 1

 0

 -2

 0

 1

 0

 1

 -1

 -10

 -30

 -67

 -138

 -291

 -642

 -1,446

 -3,250

 -7,244

 -16,065

 -35,601

 -78,985

 -175,416

 -389,695

 -865,609

 -1,922,362

 -4,268,854

 -9,479,595

 -21,051,458

 -46,750,171

 -103,821,058

 -230,560,902

 -512,016,658


 A called

 1

 2

 3

 4

 8

 18

 38

 80

 167

 347

 722

 1,509

 3,168

 6,673

 14,091

 29,825

 63,287

 134,652

 287,264

 614,442

 1,317,533

 2,831,900

 6,100,852

 13,172,239

 28,499,827

 61,786,266

 134,202,509

 292,011,464

 

 

 


 A depth

 1

 2

 3

 4

 8

 16

 32

 64

 128

 256

 512

 1,024

 2,048

 4,096

 8,192

 16,384

 32,768

 65,536

 131,072

 262,144

 524,288

 1,048,576

 2,097,152

 4,194,304

 8,388,608

 

 

 

 

 

 


 B called

 0

 1

 2

 3

 7

 17

 37

 79

 166

 346

 721

 1,508

 3,167

 6,672

 14,090

 29,824

 63,286

 134,651

 287,263

 614,441

 1,317,532

 2,831,899

 6,100,851

 13,172,238

 28,499,826

 

 

 

 

 

 


 B depth

 0

 1

 2

 3

 7

 15

 31

 63

 127

 255

 511

 1,023

 2,047

 4,095

 8,191

 16,383

 32,767

 65,535

 131,071

 262,143

 524,287

 1,048,575

 2,097,151

 4,194,303

 8,388,607

 

 

 

 

 

 



Related tasks

   Jensen's Device

",#C.23,C#,"using System;
 
delegate T Func<T>();
 
class ManOrBoy
{
    static void Main()
    {
        Console.WriteLine(A(10, C(1), C(-1), C(-1), C(1), C(0)));
    }
 
    static Func<int> C(int i)
    {
        return delegate { return i; };
    }
 
    static int A(int k, Func<int> x1, Func<int> x2, Func<int> x3, Func<int> x4, Func<int> x5)
    {
        Func<int> b = null;
        b = delegate { k--; return A(k, b, x1, x2, x3, x4); };
        return k <= 0 ? x4() + x5() : b();
    }
}
 ",486,24
35953,http://rosettacode.org/wiki/Map_range,Map range,"Given two ranges:

   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}

   and 
   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}

; 
   then a value   



s


{\displaystyle s}

   in range   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}


   is linearly mapped to a value   



t


{\displaystyle t}

   in range   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}


   where:



   



t
=

b

1


+



(
s
−

a

1


)
(

b

2


−

b

1


)


(

a

2


−

a

1


)





{\displaystyle t=b_{1}+{(s-a_{1})(b_{2}-b_{1}) \over (a_{2}-a_{1})}}




Task

Write a function/subroutine/... that takes two ranges and a real number, and returns the mapping of the real number from the first to the second range.

Use this function to map values from the range    [0, 10]    to the range    [-1, 0]. 



Extra credit

Show additional idiomatic ways of performing the mapping, using tools available to the language.



",#C.23,C#,"using System;
using System.Linq;
 
public class MapRange
{
    public static void Main() {
        foreach (int i in Enumerable.Range(0, 11))
            Console.WriteLine($""{i} maps to {Map(0, 10, -1, 0, i)}"");
    }
 
    static double Map(double a1, double a2, double b1, double b2, double s) => b1 + (s - a1) * (b2 - b1) / (a2 - a1);
}",339,12
36091,http://rosettacode.org/wiki/Magic_squares_of_doubly_even_order,Magic squares of doubly even order,"A magic square is an   N×N  square matrix whose numbers consist of consecutive numbers arranged so that the sum of each row and column,   and   both diagonals are equal to the same sum   (which is called the magic number or magic constant).

A magic square of doubly even order has a size that is a multiple of four   (e.g.     4, 8, 12).

This means that the subsquares also have an even size, which plays a role in the construction.



1
2
62
61
60
59
7
8


9
10
54
53
52
51
15
16


48
47
19
20
21
22
42
41


40
39
27
28
29
30
34
33


32
31
35
36
37
38
26
25


24
23
43
44
45
46
18
17


49
50
14
13
12
11
55
56


57
58
6
5
4
3
63
64



Task
Create a magic square of   8 × 8.



Related tasks
 Magic squares of odd order
 Magic squares of singly even order



See also

 Doubly Even Magic Squares (1728.org)

",#C.23,C#,"using System;
 
namespace MagicSquareDoublyEven
{
    class Program
    {
        static void Main(string[] args)
        {
            int n = 8;
            var result = MagicSquareDoublyEven(n);
            for (int i = 0; i < result.GetLength(0); i++)
            {
                for (int j = 0; j < result.GetLength(1); j++)
                    Console.Write(""{0,2} "", result[i, j]);
                Console.WriteLine();
            }
            Console.WriteLine(""\nMagic constant: {0} "", (n * n + 1) * n / 2);
            Console.ReadLine();
        }
 
        private static int[,] MagicSquareDoublyEven(int n)
        {
            if (n < 4 || n % 4 != 0)
                throw new ArgumentException(""base must be a positive ""
                        + ""multiple of 4"");
 
            // pattern of count-up vs count-down zones
            int bits = 0b1001_0110_0110_1001;
            int size = n * n;
            int mult = n / 4;  // how many multiples of 4
 
            int[,] result = new int[n, n];
 
            for (int r = 0, i = 0; r < n; r++)
            {
                for (int c = 0; c < n; c++, i++)
                {
                    int bitPos = c / mult + (r / mult) * 4;
                    result[r, c] = (bits & (1 << bitPos)) != 0 ? i + 1 : size - i;
                }
            }
            return result;
        }
    }
}",1370,45
36163,http://rosettacode.org/wiki/Matrix_multiplication,Matrix multiplication,"Task

Multiply two matrices together.

They can be of any dimensions, so long as the number of columns of the first matrix is equal to the number of rows of the second matrix.



",#C.23,C#,"public class Matrix
{
	int n;
	int m;
	double[,] a;
 
	public Matrix(int n, int m)
	{
		if (n <= 0 || m <= 0)
			throw new ArgumentException(""Matrix dimensions must be positive"");
		this.n = n;
		this.m = m;
		a = new double[n, m];
	}
 
	//indices start from one
	public double this[int i, int j]
	{
		get { return a[i - 1, j - 1]; }
		set { a[i - 1, j - 1] = value; }
	}
 
	public int N { get { return n; } }
	public int M { get { return m; } }
 
	public static Matrix operator*(Matrix _a, Matrix b)
	{
		int n = _a.N;
		int m = b.M;
		int l = _a.M;
		if (l != b.N)
			throw new ArgumentException(""Illegal matrix dimensions for multiplication. _a.M must be equal b.N"");
		Matrix result = new Matrix(_a.N, b.M);
		for(int i = 0; i < n; i++)
			for (int j = 0; j < m; j++)
			{
				double sum = 0.0;
				for (int k = 0; k < l; k++)
					sum += _a.a[i, k]*b.a[k, j];
				result.a[i, j] = sum;
			}
		return result;
	}
}",917,44
36211,http://rosettacode.org/wiki/Matrix_transposition,Matrix transposition,"Transpose an arbitrarily sized rectangular Matrix.



",#C.23,C#,"using System;
using System.Text;
 
namespace prog
{
	class MainClass
	{						
		public static void Main (string[] args)
		{
			double[,] m = { {1,2,3},{4,5,6},{7,8,9} };
 
			double[,] t = Transpose( m );	
 
			for( int i=0; i<t.GetLength(0); i++ )
			{
				for( int j=0; j<t.GetLength(1); j++ )		
					Console.Write( t[i,j] + ""  "" );
				Console.WriteLine("""");
			}
		}
 
		public static double[,] Transpose( double[,] m )
		{
			double[,] t = new double[m.GetLength(1),m.GetLength(0)];
			for( int i=0; i<m.GetLength(0); i++ )
				for( int j=0; j<m.GetLength(1); j++ )
					t[j,i] = m[i,j];			
 
			return t;
		}
	}
}",619,32
36302,http://rosettacode.org/wiki/Mandelbrot_set,Mandelbrot set,"Mandelbrot set

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Generate and draw the Mandelbrot set.



Note that there are many algorithms to draw Mandelbrot set and there are many functions which generate it .



",#C.23,C#,"using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.Threading;
using System.Windows.Forms;
 
/// <summary>
/// Generates bitmap of Mandelbrot Set and display it on the form.
/// </summary>
public class MandelbrotSetForm : Form
{
    const double MaxValueExtent = 2.0;
    Thread thread;
 
    static double CalcMandelbrotSetColor(ComplexNumber c)
    {
        // from http://en.wikipedia.org/w/index.php?title=Mandelbrot_set
        const int MaxIterations = 1000;
        const double MaxNorm = MaxValueExtent * MaxValueExtent;
 
        int iteration = 0;
        ComplexNumber z = new ComplexNumber();
        do
        {
            z = z * z + c;
            iteration++;
        } while (z.Norm() < MaxNorm && iteration < MaxIterations);
        if (iteration < MaxIterations)
            return (double)iteration / MaxIterations;
        else
            return 0; // black
    }
 
    static void GenerateBitmap(Bitmap bitmap)
    {
        double scale = 2 * MaxValueExtent / Math.Min(bitmap.Width, bitmap.Height);
        for (int i = 0; i < bitmap.Height; i++)
        {
            double y = (bitmap.Height / 2 - i) * scale;
            for (int j = 0; j < bitmap.Width; j++)
            {
                double x = (j - bitmap.Width / 2) * scale;
                double color = CalcMandelbrotSetColor(new ComplexNumber(x, y));
                bitmap.SetPixel(j, i, GetColor(color));
            }
        }
    }
 
    static Color GetColor(double value)
    {
        const double MaxColor = 256;
        const double ContrastValue = 0.2;
        return Color.FromArgb(0, 0,
            (int)(MaxColor * Math.Pow(value, ContrastValue)));
    }
 
    public MandelbrotSetForm()
    {
        // form creation
        this.Text = ""Mandelbrot Set Drawing"";
        this.BackColor = System.Drawing.Color.Black;
        this.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Stretch;
        this.MaximizeBox = false;
        this.StartPosition = FormStartPosition.CenterScreen;
        this.FormBorderStyle = FormBorderStyle.FixedDialog;
        this.ClientSize = new Size(640, 640);
        this.Load += new System.EventHandler(this.MainForm_Load);
    }
 
    void MainForm_Load(object sender, EventArgs e)
    {
        thread = new Thread(thread_Proc);
        thread.IsBackground = true;
        thread.Start(this.ClientSize);
    }
 
    void thread_Proc(object args)
    {
        // start from small image to provide instant display for user
        Size size = (Size)args;
        int width = 16;
        while (width * 2 < size.Width)
        {
            int height = width * size.Height / size.Width;
            Bitmap bitmap = new Bitmap(width, height, PixelFormat.Format24bppRgb);
            GenerateBitmap(bitmap);
            this.BeginInvoke(new SetNewBitmapDelegate(SetNewBitmap), bitmap);
            width *= 2;
            Thread.Sleep(200);
        }
        // then generate final image
        Bitmap finalBitmap = new Bitmap(size.Width, size.Height, PixelFormat.Format24bppRgb);
        GenerateBitmap(finalBitmap);
        this.BeginInvoke(new SetNewBitmapDelegate(SetNewBitmap), finalBitmap);
    }
 
    void SetNewBitmap(Bitmap image)
    {
        if (this.BackgroundImage != null)
            this.BackgroundImage.Dispose();
        this.BackgroundImage = image;
    }
 
    delegate void SetNewBitmapDelegate(Bitmap image);
 
    static void Main()
    {
        Application.Run(new MandelbrotSetForm());
    }
}
 
struct ComplexNumber
{
    public double Re;
    public double Im;
 
    public ComplexNumber(double re, double im)
    {
        this.Re = re;
        this.Im = im;
    }
 
    public static ComplexNumber operator +(ComplexNumber x, ComplexNumber y)
    {
        return new ComplexNumber(x.Re + y.Re, x.Im + y.Im);
    }
 
    public static ComplexNumber operator *(ComplexNumber x, ComplexNumber y)
    {
        return new ComplexNumber(x.Re * y.Re - x.Im * y.Im,
            x.Re * y.Im + x.Im * y.Re);
    }
 
    public double Norm()
    {
        return Re * Re + Im * Im;
    }
}",4086,138
36814,http://rosettacode.org/wiki/MAC_Vendor_Lookup,MAC Vendor Lookup,"Every connected device around the world comes with a unique Media Access Control address, or a   MAC address.

A common task a network administrator may come across is being able to identify a network device's manufacturer when given only a MAC address.



Task

Interface with one (or numerous) APIs that exist on the internet and retrieve the device manufacturer based on a supplied MAC address.

A MAC address that does not return a valid result should return the String ""N/A"".   An error related to the network connectivity or the API should return a null result.

Many implementations on this page use http://api.macvendors.com/ which, as of 19th September 2021, is throttling requests. After only 2 calls, the following response is returned for all subsequent requests. If you are planning to use the same provider or going to run the examples on this page, consider building in a delay between two calls.

{""errors"":{""detail"":""Too Many Requests"",""message"":""Please slow down your requests or upgrade your plan at https://macvendors.com""}}
",#C.23,C#,"using System;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;
 
class Program
{
    static async Task<string> LookupMac(string MacAddress)
    {
        var uri = new Uri(""http://api.macvendors.com/"" + WebUtility.UrlEncode(MacAddress));
        using (var wc = new HttpClient())
            return await wc.GetStringAsync(uri);
    }
    static void Main(string[] args)
    {
        foreach (var mac in new string[] { ""88:53:2E:67:07:BE"", ""FC:FB:FB:01:FA:21"", ""D4:F4:6F:C9:EF:8D"" })
            Console.WriteLine(mac + ""\t"" + LookupMac(mac).Result);
        Console.ReadLine();
    }
}",609,20
36924,http://rosettacode.org/wiki/Magic_8-ball,Magic 8-ball,"Task

Create Magic 8-Ball.



See details at:   Magic 8-Ball.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#," 
using System;
 
namespace newProg
{
 
    class Program
    {
        static void Main(string[] args)
        {
            string[] answers =
            {
                ""It is certain."",
                ""It is decidedly so."",
                ""Without a doubt."",
                ""Yes – definitely."",
                ""You may rely on it."",
                ""As I see it, yes."",
                ""Most likely."",
                ""Outlook good."",
                ""Yes."",
                ""Signs point to yes."",
                ""Reply hazy, try again."",
                ""Ask again later"",
                ""Better not tell you now."",
                ""Cannot predict now."",
                ""Concentrate and ask again."",
                ""Don't count on it."",
                ""My reply is no."",
                ""My sources say no."",
                ""Outlook not so good."",
                ""Very doubtful.""
            };
 
            while (true)
            {
                Random rnd = new Random();
                int result = rnd.Next(0, 19);
 
                Console.WriteLine(""Magic 8 Ball! Ask question and hit a key for the answer!"");
 
                string inp = Console.ReadLine();
 
                Console.WriteLine(answers[result]);
 
            }
        }
    }
}
 
 
 ",1285,52
37028,http://rosettacode.org/wiki/Ludic_numbers,Ludic numbers,"Ludic numbers   are related to prime numbers as they are generated by a sieve quite like the Sieve of Eratosthenes is used to generate prime numbers.

The first ludic number is   1.

To generate succeeding ludic numbers create an array of increasing integers starting from   2.

2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ...
(Loop)

 Take the first member of the resultant array as the next ludic number   2.
 Remove every   2nd   indexed item from the array (including the first).
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ...
 (Unrolling a few loops...)
 Take the first member of the resultant array as the next ludic number   3.
 Remove every   3rd   indexed item from the array (including the first).
3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 ...
 Take the first member of the resultant array as the next ludic number   5.
 Remove every   5th   indexed item from the array (including the first).
5 7 11 13 17 19 23 25 29 31 35 37 41 43 47 49 53 55 59 61 65 67 71 73 77 ...
 Take the first member of the resultant array as the next ludic number   7.
 Remove every   7th   indexed item from the array (including the first).
7 11 13 17 23 25 29 31 37 41 43 47 53 55 59 61 67 71 73 77 83 85 89 91 97 ...
  ... 
 Take the first member of the current array as the next ludic number   L.
 Remove every   Lth   indexed item from the array (including the first).
  ... 


Task

 Generate and show here the first 25 ludic numbers.
 How many ludic numbers are there less than or equal to 1000?
 Show the 2000..2005th ludic numbers.


Stretch goal

Show all triplets of ludic numbers < 250.

 A triplet is any three numbers     



x
,


{\displaystyle x,}

   



x
+
2
,


{\displaystyle x+2,}

   



x
+
6


{\displaystyle x+6}

      where all three numbers are also ludic numbers. 

",#C.23,C#,"using System;
using System.Linq;
using System.Collections.Generic;
 
public class Program
{
    public static void Main()
    {
        Console.WriteLine(""First 25 ludic numbers:"");
        Console.WriteLine(string.Join("", "", LudicNumbers(150).Take(25)));
        Console.WriteLine();
 
        Console.WriteLine($""There are {LudicNumbers(1001).Count()} ludic numbers below 1000"");
        Console.WriteLine();
 
        foreach (var ludic in LudicNumbers(22000).Skip(1999).Take(6)
                .Select((n, i) => $""#{i+2000} = {n}"")) {
            Console.WriteLine(ludic);
        }
        Console.WriteLine();
 
        Console.WriteLine(""Triplets below 250:"");
        var queue = new Queue<int>(5);
        foreach (int x in LudicNumbers(255)) {
            if (queue.Count == 5) queue.Dequeue();
            queue.Enqueue(x);
            if (x - 6 < 250 && queue.Contains(x - 6) && queue.Contains(x - 4)) {
                Console.WriteLine($""{x-6}, {x-4}, {x}"");
            }
        }
    }
 
    public static IEnumerable<int> LudicNumbers(int limit) {
        yield return 1;
        //Like a linked list, but with value types.
        //Create 2 extra entries at the start to avoid ugly index calculations
        //and another at the end to avoid checking for index-out-of-bounds.
        Entry[] values = Enumerable.Range(0, limit + 1).Select(n => new Entry(n)).ToArray();
        for (int i = 2; i < limit; i = values[i].Next) {
            yield return values[i].N;
            int start = i;
            while (start < limit) {
                Unlink(values, start);
                for (int step = 0; step < i && start < limit; step++)
                    start = values[start].Next;
            }
        }
    }
 
    static void Unlink(Entry[] values, int index) {
        values[values[index].Prev].Next = values[index].Next;
        values[values[index].Next].Prev = values[index].Prev;
    }
 
}
 
struct Entry
{
    public Entry(int n) : this() {
        N = n;
        Prev = n - 1;
        Next = n + 1;
    }
 
    public int N { get; }
    public int Prev { get; set; }
    public int Next { get; set; }
}",2137,68
37065,http://rosettacode.org/wiki/Mad_Libs,Mad Libs,"

 This page uses content from Wikipedia. The original article was at Mad Libs. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Mad Libs is a phrasal template word game where one player prompts another for a list of words to substitute for blanks in a story, usually with funny results.



Task;
Write a program to create a Mad Libs like story.

The program should read an arbitrary multiline story from input.

The story will be terminated with a blank line.

Then, find each replacement to be made within the story, ask the user for a word to replace it with, and make all the replacements.

Stop when there are none left and print the final story.



The input should be an arbitrary story in the form:

<name> went for a walk in the park. <he or she>
found a <noun>. <name> decided to take it home.

Given this example, it should then ask for a name, a he or she and a noun (<name> gets replaced both times with the same value).




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
 
namespace MadLibs_RosettaCode
{
	class Program
	{
		static void Main(string[] args)
		{
			string madLibs = 
@""Write a program to create a Mad Libs like story.
The program should read an arbitrary multiline story from input.
The story will be terminated with a blank line.
Then, find each replacement to be made within the story, 
ask the user for a word to replace it with, and make all the replacements.
Stop when there are none left and print the final story.
The input should be an arbitrary story in the form:
<name> went for a walk in the park. <he or she>
found a <noun>. <name> decided to take it home.
Given this example, it should then ask for a name, 
a he or she and a noun (<name> gets replaced both times with the same value)."";
 
			StringBuilder sb = new StringBuilder();
			Regex pattern = new Regex(@""\<(.*?)\>"");
			string storyLine;
			string replacement;
 
			Console.WriteLine(madLibs + Environment.NewLine + Environment.NewLine);
			Console.WriteLine(""Enter a story: "");
 
			// Continue to get input while empty line hasn't been entered.
			do
			{
				storyLine = Console.ReadLine();
				sb.Append(storyLine + Environment.NewLine);
			} while (!string.IsNullOrEmpty(storyLine) && !string.IsNullOrWhiteSpace(storyLine));
 
			// Retrieve only the unique regex matches from the user entered story.
			Match nameMatch = pattern.Matches(sb.ToString()).OfType<Match>().Where(x => x.Value.Equals(""<name>"")).Select(x => x.Value).Distinct() as Match;
			if(nameMatch != null)
			{
				do
				{
					Console.WriteLine(""Enter value for: "" + nameMatch.Value);
					replacement = Console.ReadLine();
				} while (string.IsNullOrEmpty(replacement) || string.IsNullOrWhiteSpace(replacement));
				sb.Replace(nameMatch.Value, replacement);
			}
 
			foreach (Match match in pattern.Matches(sb.ToString()))
			{
				replacement = string.Empty;
				// Guarantee we get a non-whitespace value for the replacement
				do
				{
					Console.WriteLine(""Enter value for: "" + match.Value);
					replacement = Console.ReadLine();
				} while (string.IsNullOrEmpty(replacement) || string.IsNullOrWhiteSpace(replacement));
 
				int location = sb.ToString().IndexOf(match.Value);
				sb.Remove(location, match.Value.Length).Insert(location, replacement);
			}
 
			Console.WriteLine(Environment.NewLine + Environment.NewLine + ""--[ Here's your story! ]--"");
			Console.WriteLine(sb.ToString());
		}
	}
}
 ",2496,71
37132,http://rosettacode.org/wiki/LZW_compression,LZW compression,"The Lempel-Ziv-Welch (LZW) algorithm provides loss-less data compression.

You can read a complete description of it in the   Wikipedia article   on the subject.   It was patented, but it entered the public domain in 2004.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Text;
 
namespace LZW
{
    public class Program
    {
        public static void Main(string[] args)
        {
            List<int> compressed = Compress(""TOBEORNOTTOBEORTOBEORNOT"");
            Console.WriteLine(string.Join("", "", compressed));
            string decompressed = Decompress(compressed);
            Console.WriteLine(decompressed);
        }
 
        public static List<int> Compress(string uncompressed)
        {
            // build the dictionary
            Dictionary<string, int> dictionary = new Dictionary<string, int>();
            for (int i = 0; i < 256; i++)
                dictionary.Add(((char)i).ToString(), i);
 
            string w = string.Empty;
            List<int> compressed = new List<int>();
 
            foreach (char c in uncompressed)
            {
                string wc = w + c;
                if (dictionary.ContainsKey(wc))
                {
                    w = wc;
                }
                else
                {
                    // write w to output
                    compressed.Add(dictionary[w]);
                    // wc is a new sequence; add it to the dictionary
                    dictionary.Add(wc, dictionary.Count);
                    w = c.ToString();
                }
            }
 
            // write remaining output if necessary
            if (!string.IsNullOrEmpty(w))
                compressed.Add(dictionary[w]);
 
            return compressed;
        }
 
        public static string Decompress(List<int> compressed)
        {
            // build the dictionary
            Dictionary<int, string> dictionary = new Dictionary<int, string>();
            for (int i = 0; i < 256; i++)
                dictionary.Add(i, ((char)i).ToString());
 
            string w = dictionary[compressed[0]];
            compressed.RemoveAt(0);
            StringBuilder decompressed = new StringBuilder(w);
 
            foreach (int k in compressed)
            {
                string entry = null;
                if (dictionary.ContainsKey(k))
                    entry = dictionary[k];
                else if (k == dictionary.Count)
                    entry = w + w[0];
 
                decompressed.Append(entry);
 
                // new sequence; add it to the dictionary
                dictionary.Add(dictionary.Count, w + entry[0]);
 
                w = entry;
            }
 
            return decompressed.ToString();
        }
    }
}",2510,81
37155,http://rosettacode.org/wiki/Loops/Wrong_ranges,Loops/Wrong ranges,"Loops/Wrong ranges

You are encouraged to solve this task according to the task description, using any language you may know.
Some languages have syntax or function(s) to generate a range of numeric values from a start value, a stop value, and an increment.

The purpose of this task is to select the range syntax/function that would generate at least two increasing numbers when given a stop value more than the start value and a positive increment of less than half the difference.   You are then to use that same syntax/function but with different parameters; and show, here, what would happen.

Use these values if possible:



start 
stop 
increment 
Comment


 -2
2
1
Normal


 -2
2
0
Zero increment


 -2
2
-1
Increments away from stop value


 -2
2
10
First increment is beyond stop value


2
-2
1
Start more than stop: positive increment


2
2
1
Start equal stop: positive increment


2
2
-1
Start equal stop: negative increment


2
2
0
Start equal stop: zero increment


0
0
0
Start equal stop equal zero: zero increment

Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#C.23,C#,"using System;
using System.Collections.Generic;
 
static class Program
{
    static void Main()
    {
        Example(-2, 2, 1, ""Normal"");
        Example(-2, 2, 0, ""Zero increment"");
        Example(-2, 2, -1, ""Increments away from stop value"");
        Example(-2, 2, 10, ""First increment is beyond stop value"");
        Example(2, -2, 1, ""Start more than stop: positive increment"");
        Example(2, 2, 1, ""Start equal stop: positive increment"");
        Example(2, 2, -1, ""Start equal stop: negative increment"");
        Example(2, 2, 0, ""Start equal stop: zero increment"");
        Example(0, 0, 0, ""Start equal stop equal zero: zero increment"");
    }
 
    static IEnumerable<int> Range(int start, int stop, int increment)
    {
        // To replicate the (arguably more correct) behavior of VB.NET:
        //for (int i = start; increment >= 0 ? i <= stop : stop <= i; i += increment)
 
        // Decompiling the IL emitted by the VB compiler (uses shifting right by 31 as the signum function and bitwise xor in place of the conditional expression):
        //for (int i = start; ((increment >> 31) ^ i) <= ((increment >> 31) ^ stop); i += increment)
 
        // ""Naïve"" translation.
        for (int i = start; i <= stop; i += increment)
            yield return i;
    }
 
    static void Example(int start, int stop, int increment, string comment)
    {
        // Add a space, pad to length 50 with hyphens, and add another space.
        Console.Write((comment + "" "").PadRight(50, '-') + "" "");
 
        const int MAX_ITER = 9;
 
        int iteration = 0;
        foreach (int i in Range(start, stop, increment))
        {
            Console.Write(""{0,2} "", i);
 
            if (++iteration > MAX_ITER) break;
        }
 
        Console.WriteLine();
    }
}",1779,49
37216,http://rosettacode.org/wiki/Lucas-Lehmer_test,Lucas-Lehmer test,"Lucas-Lehmer Test:

for 



p


{\displaystyle p}

 an odd prime, the Mersenne number 




2

p


−
1


{\displaystyle 2^{p}-1}

 is prime if and only if 




2

p


−
1


{\displaystyle 2^{p}-1}

 divides 



S
(
p
−
1
)


{\displaystyle S(p-1)}

 where 



S
(
n
+
1
)
=
(
S
(
n
)

)

2


−
2


{\displaystyle S(n+1)=(S(n))^{2}-2}

, and 



S
(
1
)
=
4


{\displaystyle S(1)=4}

.



Task

Calculate all Mersenne primes up to the implementation's
maximum precision, or the 47th Mersenne prime   (whichever comes first).



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Numerics;
using System.Threading.Tasks;
 
namespace LucasLehmerTestForRosettaCode
{
    public class LucasLehmerTest
    {
        static BigInteger ZERO = new BigInteger(0);
        static BigInteger ONE = new BigInteger(1);
        static BigInteger TWO = new BigInteger(2);
        static BigInteger FOUR = new BigInteger(4);
 
        private static bool isMersennePrime(int p) 
        {
            if (p % 2 == 0) return (p == 2);
            else {
                for (int i = 3; i <= (int)Math.Sqrt(p); i += 2)
                    if (p % i == 0) return false; //not prime
                BigInteger m_p = BigInteger.Pow(TWO, p) - ONE;
                BigInteger s = FOUR;
                for (int i = 3; i <= p; i++)
                    s = (s * s - TWO) % m_p;
                return s == ZERO;
            } 
        }
 
        public static int[] GetMersennePrimeNumbers(int upTo)
        {
            List<int> response = new List<int>();
            Parallel.For(2, upTo + 1, i => {
                if (isMersennePrime(i)) response.Add(i);
            });
            response.Sort();
            return response.ToArray();
        }
 
        static void Main(string[] args)
        {
            int[] mersennePrimes = LucasLehmerTest.GetMersennePrimeNumbers(11213);
            foreach (int mp in mersennePrimes)
                Console.Write(""M"" + mp+"" "");
            Console.ReadLine();
        }
    }
}",1489,47
37247,http://rosettacode.org/wiki/Loops/With_multiple_ranges,Loops/With multiple ranges,"Loops/With multiple ranges

You are encouraged to solve this task according to the task description, using any language you may know.
Some languages allow multiple loop ranges, such as the PL/I example (snippet) below.

                                       /* all variables are DECLARED as integers. */
          prod=  1;                    /*start with a product of unity.           */
           sum=  0;                    /*  ""     ""  ""   sum    "" zero.            */
             x= +5;
             y= -5;
             z= -2;
           one=  1;
         three=  3;
         seven=  7;
                                       /*(below)  **  is exponentiation:  4**3=64 */
           do j=   -three  to     3**3        by three   ,
                   -seven  to   +seven        by   x     ,
                      555  to      550 - y               ,
                       22  to      -28        by -three  ,
                     1927  to     1939                   ,
                        x  to        y        by   z     ,
                    11**x  to    11**x + one;
                                                        /* ABS(n) = absolute value*/
           sum= sum + abs(j);                           /*add absolute value of J.*/
           if abs(prod)<2**27 & j¬=0  then prod=prod*j; /*PROD is small enough & J*/
           end;                                         /*not 0, then multiply it.*/
                     /*SUM and PROD are used for verification of J incrementation.*/
         display (' sum= ' ||  sum);                    /*display strings to term.*/
         display ('prod= ' || prod);                    /*   ""       ""     ""   ""  */


Task

Simulate/translate the above PL/I program snippet as best as possible in your
language,   with particular emphasis on the   do   loop construct.

The   do   index must be incremented/decremented in the same order shown.

If feasible, add commas to the two output numbers (being displayed).

Show all output here.

      A simple PL/I   DO  loop  (incrementing or decrementing)  has the construct of:
 
            DO variable = start_expression    {TO ending_expression]       {BY increment_expression} ;
                 ---or---
            DO variable = start_expression    {BY increment_expression}    {TO ending_expression]    ;  
 
      where it is understood that all expressions will have a value.  The  variable  is normally a 
      scaler variable,  but need not be  (but for this task, all variables and expressions are declared
      to be scaler integers).   If the   BY   expression is omitted,  a   BY   value of unity is used.
      All expressions are evaluated before the   DO   loop is executed,  and those values are used
      throughout the   DO   loop execution   (even though, for instance,  the value of   Z   may be
      changed within the   DO   loop.    This isn't the case here for this task.  
 
      A multiple-range   DO   loop can be constructed by using a comma (,) to separate additional ranges
      (the use of multiple   TO   and/or   BY   keywords).     This is the construct used in this task.
 
      There are other forms of   DO   loops in PL/I involving the  WHILE  clause,  but those won't be 
      needed here.    DO  loops without a   TO   clause might need a   WHILE   clause  or some other 
      means of exiting the loop  (such as  LEAVE,  RETURN,  SIGNAL,  GOTO,  or  STOP),  or some other 
      (possible error) condition that causes transfer of control outside the  DO  loop.
 
      Also, in PL/I, the check if the   DO   loop index value is outside the range is made at the 
      ""head""  (start)  of the   DO  loop,  so it's possible that the   DO   loop isn't executed,  but 
      that isn't the case for any of the ranges used in this task. 
 
      In the example above, the clause:                    x    to y       by z     
      will cause the variable   J   to have to following values  (in this order):  5  3  1  -1  -3  -5
 
      In the example above, the clause:                 -seven  to +seven  by x  
      will cause the variable   J   to have to following values  (in this order):  -7  -2   3  


Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
public static class LoopsWithMultipleRanges
{
    public static void Main() {
        int prod = 1;
        int sum = 0;
        int x = 5;
        int y = -5;
        int z = -2;
        int one = 1;
        int three = 3;
        int seven = 7; 
 
        foreach (int j in Concat(
            For(-three, 3.Pow(3), three),
            For(-seven, seven, x),
            For(555, 550 - y),
            For(22, -28, -three),
            For(1927, 1939),
            For(x, y, z),
            For(11.Pow(x), 11.Pow(x) + one)
        )) {
            sum += Math.Abs(j);
            if (Math.Abs(prod) < (1 << 27) && j != 0) prod *= j;
        }
        Console.WriteLine($"" sum = {sum:N0}"");
        Console.WriteLine($""prod = {prod:N0}"");
    }
 
    static IEnumerable<int> For(int start, int end, int by = 1) {
        for (int i = start; by > 0 ? (i <= end) : (i >= end); i += by) yield return i;
    }
 
    static IEnumerable<int> Concat(params IEnumerable<int>[] ranges) => ranges.Aggregate((acc, r) => acc.Concat(r));
    static int Pow(this int b, int e) => (int)Math.Pow(b, e);
}",1158,39
37380,http://rosettacode.org/wiki/Loops/Increment_loop_index_within_loop_body,Loops/Increment loop index within loop body,"Sometimes, one may need   (or want)   a loop which
its   iterator   (the index
variable)   is modified within the

loop body    in addition to the normal incrementation by the   (do)   loop structure index.



Goal

Demonstrate the best way to accomplish this.



Task

Write a loop which:

   starts the index (variable) at   42
   (at iteration time)   increments the index by unity
   if the index is prime:
   displays the count of primes found (so far) and the prime   (to the terminal)
   increments the index such that the new index is now the (old) index plus that prime
   terminates the loop when   42   primes are shown


Extra credit:   because of the primes get rather large, use commas
within the displayed primes to ease comprehension.



Show all output here.



Note

Not all programming languages allow the modification of a
loop's index.   If that is the case, then use whatever method that
is appropriate or idiomatic for that language.   Please add a note
if the loop's index isn't modifiable.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#C.23,C#," 
using System;
using System.Globalization;
 
namespace PrimeNumberLoopcs
{
    class Program
    {
        static bool isPrime(double number)
        {
            for(double i = number - 1; i > 1; i--)
            {
                if (number % i == 0)
                    return false;
            }
            return true;
        }
        static void Main(string[] args)
        {
            NumberFormatInfo nfi = new CultureInfo(""en-US"", false).NumberFormat;
            nfi.NumberDecimalDigits = 0;
            double i = 42;
            int n = 0;
            while (n < 42)
            {
                if (isPrime(i))
                {
                    n++;
                    Console.WriteLine(""n = {0,-20} {1,20}"", n, i.ToString(""N"", nfi));
                    i += i - 1;
                }
                i++;
            }
        }
    }
}",864,36
37496,http://rosettacode.org/wiki/Loops/Foreach,Loops/Foreach,"Loop through and print each element in a collection in order.

Use your language's ""for each"" loop if it has one, otherwise iterate through the collection in order with some other loop.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#C.23,C#,"string[] things = {""Apple"", ""Banana"", ""Coconut""};
 
foreach (string thing in things)
{
    Console.WriteLine(thing);
}",118,6
37543,http://rosettacode.org/wiki/Loops/N_plus_one_half,Loops/N plus one half,"Quite often one needs loops which, in the last iteration, execute only part of the loop body.



Goal

Demonstrate the best way to do this.



Task

Write a loop which writes the comma-separated list

1, 2, 3, 4, 5, 6, 7, 8, 9, 10

using separate output statements for the number
and the comma from within the body of the loop.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#C.23,C#,"using System;
 
class Program
{
    static void Main(string[] args)
    {
        for (int i = 1; ; i++)
        {
            Console.Write(i);
            if (i == 10) break;
            Console.Write("", "");
        }
        Console.WriteLine();
    }
}",256,15
37544,http://rosettacode.org/wiki/Loops/Nested,Loops/Nested,"Show a nested loop which searches a two-dimensional array filled with random numbers uniformly distributed over 



[
1
,
…
,
20
]


{\displaystyle [1,\ldots ,20]}

.

The loops iterate rows and columns of the array printing the elements until the value 



20


{\displaystyle 20}

 is met.

Specifically, this task also shows how to break out of nested loops.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#C.23,C#,"using System;
 
class Program {
    static void Main(string[] args) {
        int[,] a = new int[10, 10];
        Random r = new Random();
 
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                a[i, j] = r.Next(0, 21) + 1;
            }
        }
 
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                Console.Write("" {0}"", a[i, j]);
                if (a[i, j] == 20) {
                    goto Done;
                }
            }
            Console.WriteLine();
        }
    Done:
        Console.WriteLine();
    }
}",613,26
37613,http://rosettacode.org/wiki/Loops/While,Loops/While,"Task

Start an integer value at   1024.

Loop while it is greater than zero.

Print the value (with a newline) and divide it by two each time through the loop.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreachbas
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#C.23,C#,"int i = 1024;
while(i > 0){
   System.Console.WriteLine(i);
   i /= 2;
}",72,5
37696,http://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers,Luhn test of credit card numbers,"The Luhn test is used by some credit card companies to distinguish valid credit card numbers from what could be a random selection of digits.

Those companies using credit card numbers that can be validated by the Luhn test have numbers that pass the following test:

 Reverse the order of the digits in the number.
 Take the first, third, ... and every other odd digit in the reversed digits and sum them to form the partial sum s1
 Taking the second, fourth ... and every other even digit in the reversed digits:
 Multiply each digit by two and sum the digits if the answer is greater than nine to form partial sums for the even digits
 Sum the partial sums of the even digits to form s2
 If s1 + s2 ends in zero then the original number is in the form of a valid credit card number as verified by the Luhn test.


For example, if the trial number is 49927398716:

Reverse the digits:
  61789372994
Sum the odd digits:
  6 + 7 + 9 + 7 + 9 + 4 = 42 = s1
The even digits:
    1,  8,  3,  2,  9
  Two times each even digit:
    2, 16,  6,  4, 18
  Sum the digits of each multiplication:
    2,  7,  6,  4,  9
  Sum the last:
    2 + 7 + 6 + 4 + 9 = 28 = s2

s1 + s2 = 70 which ends in zero which means that 49927398716 passes the Luhn test


Task

Write a function/method/procedure/subroutine that will validate a number with the Luhn test, and

use it to validate the following numbers:

   49927398716
   49927398717
   1234567812345678
   1234567812345670



Related tasks

   SEDOL
   ISIN

",#C.23,C#," 
    public static class Luhn
    {
        public static bool LuhnCheck(this string cardNumber)
        {
            return LuhnCheck(cardNumber.Select(c => c - '0').ToArray());
        }
 
        private static bool LuhnCheck(this int[] digits)
        {
            return GetCheckValue(digits) == 0;
        }
 
        private static int GetCheckValue(int[] digits)
        {
            return digits.Select((d, i) => i % 2 == digits.Length % 2 ? ((2 * d) % 10) + d / 5 : d).Sum() % 10;
        }
    }
 
    public static class TestProgram
    {
        public static void Main()
        {
            long[] testNumbers = {49927398716, 49927398717, 1234567812345678, 1234567812345670};
            foreach (var testNumber in testNumbers)
                Console.WriteLine(""{0} is {1}valid"", testNumber, testNumber.ToString().LuhnCheck() ? """" : ""not "");
        }
    }
 ",881,29
37704,http://rosettacode.org/wiki/Loops/Infinite,Loops/Infinite,"Task

Print out        SPAM        followed by a   newline   in an infinite loop.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#C.23,C#,"while (true)
{
    Console.WriteLine(""SPAM"");
}",47,4
37801,http://rosettacode.org/wiki/Loops/Downward_for,Loops/Downward for,"Task

Write a    for    loop which writes a countdown from   10   to   0.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#C.23,C#,"for (int i = 10; i >= 0; i--)
{
   Console.WriteLine(i);
}",58,4
37853,http://rosettacode.org/wiki/Loops/For_with_a_specified_step,Loops/For with a specified step,"

Task

Demonstrate a   for-loop   where the step-value is greater than one.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#C.23,C#,"using System;
 
class Program {
    static void Main(string[] args) {    
        for (int i = 2; i <= 8; i+= 2) {        
            Console.Write(""{0}, "", i);
        }
 
        Console.WriteLine(""who do we appreciate?"");
    }
}",233,11
37940,http://rosettacode.org/wiki/Loops/Do-while,Loops/Do-while,"Start with a value at 0. Loop while value mod 6 is not equal to 0.
Each time through the loop, add 1 to the value then print it.
The loop must execute at least once.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges


Reference

 Do while loop Wikipedia.

",#C.23,C#,"int a = 0;
 
do
{
    a += 1;
    Console.WriteLine(a);
} while (a % 6 != 0);",77,7
38140,http://rosettacode.org/wiki/Loops/For,Loops/For,"“For”   loops are used to make some block of code be iterated a number of times, setting a variable or parameter to a monotonically increasing integer value for each execution of the block of code.

Common extensions of this allow other counting patterns or iterating over abstract structures other than the integers.



Task

Show how two loops may be nested within each other, with the number of iterations performed by the inner for loop being controlled by the outer for loop.

Specifically print out the following pattern by using one for loop nested in another:

*
**
***
****
*****


Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges




Reference

 For loop Wikipedia.

",#C.23,C#,"using System;
 
class Program {
    static void Main(string[] args)
    {
        for (int i = 0; i < 5; i++)
        {
            for (int j = 0; j <= i; j++)
            {
                Console.Write(""*"");
            }
            Console.WriteLine();
        }
    }
}",275,15
38590,http://rosettacode.org/wiki/Longest_increasing_subsequence,Longest increasing subsequence,"Calculate and show here a longest increasing subsequence of the list:





{
3
,
2
,
6
,
4
,
5
,
1
}


{\displaystyle \{3,2,6,4,5,1\}}


And of the list:





{
0
,
8
,
4
,
12
,
2
,
10
,
6
,
14
,
1
,
9
,
5
,
13
,
3
,
11
,
7
,
15
}


{\displaystyle \{0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15\}}


Note that a list may have more than one subsequence that is of the maximum length.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




Ref

 Dynamic Programming #1: Longest Increasing Subsequence on YouTube
 An efficient solution can be based on Patience sorting.

",#C.23,C#,"using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
 
public static class LIS
{
    public static IEnumerable<T> FindRec<T>(IList<T> values, IComparer<T> comparer = null) =>
        values == null ? throw new ArgumentNullException() :
            FindRecImpl(values, Sequence<T>.Empty, 0, comparer ?? Comparer<T>.Default).Reverse();
 
    private static Sequence<T> FindRecImpl<T>(IList<T> values, Sequence<T> current, int index, IComparer<T> comparer) {
        if (index == values.Count) return current;
        if (current.Length > 0 && comparer.Compare(values[index], current.Value) <= 0)
            return FindRecImpl(values, current, index + 1, comparer);
        return Max(
            FindRecImpl(values, current, index + 1, comparer),
            FindRecImpl(values, current + values[index], index + 1, comparer)
        );
    }
 
    private static Sequence<T> Max<T>(Sequence<T> a, Sequence<T> b) => a.Length < b.Length ? b : a;
 
    class Sequence<T> : IEnumerable<T>
    {
        public static readonly Sequence<T> Empty = new Sequence<T>(default(T), null);
 
        public Sequence(T value, Sequence<T> tail)
        {
            Value = value;
            Tail = tail;
            Length = tail == null ? 0 : tail.Length + 1;
        }
 
        public T Value { get; }
        public Sequence<T> Tail { get; }
        public int Length { get; }
 
        public static Sequence<T> operator +(Sequence<T> s, T value) => new Sequence<T>(value, s);
 
        public IEnumerator<T> GetEnumerator()
        {
            for (var s = this; s.Length > 0; s = s.Tail) yield return s.Value;
        }
 
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }
}",1734,48
38749,http://rosettacode.org/wiki/Longest_common_substring,Longest common substring,"Task

Write a function that returns the longest common substring of two strings.

Use it within a program that demonstrates sample output from the function, which will consist of the longest common substring between ""thisisatest"" and ""testing123testing"".

Note that substrings are consecutive characters within a string.   This distinguishes them from subsequences, which is any sequence of characters within a string, even if there are extraneous characters in between them.

Hence, the longest common subsequence between ""thisisatest"" and ""testing123testing"" is ""tsitest"", whereas the longest common substring is just ""test"".




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




References

Generalize Suffix Tree
Ukkonen’s Suffix Tree Construction

",#C.23,C#,"using System;
 
namespace LongestCommonSubstring
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(lcs(""thisisatest"", ""testing123testing""));
            Console.ReadKey(true);
        }
 
        public static string lcs(string a, string b)
        {
            var lengths = new int[a.Length, b.Length];
            int greatestLength = 0;
            string output = """";
            for (int i = 0; i < a.Length; i++)
            {
                for (int j = 0; j < b.Length; j++)
                {
                    if (a[i] == b[j])
                    {
                        lengths[i, j] = i == 0 || j == 0 ? 1 : lengths[i - 1, j - 1] + 1;
                        if (lengths[i, j] > greatestLength)
                        {
                            greatestLength = lengths[i, j];
                            output = a.Substring(i - greatestLength + 1, greatestLength);
                        }
                    }
                    else
                    {
                        lengths[i, j] = 0;
                    }
                }
            }
            return output;
        }
    }
}",1182,40
38777,http://rosettacode.org/wiki/Loops/Continue,Loops/Continue,"Task

Show the following output using one loop.

1, 2, 3, 4, 5
6, 7, 8, 9, 10



Try to achieve the result by forcing the next iteration within the loop
upon a specific condition, if your language allows it.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#C.23,C#,"using System;
 
class Program {
    static void Main(string[] args) {
        for (int i = 1; i <= 10; i++) {
            Console.Write(i);
 
            if (i % 5 == 0) {
                Console.WriteLine();
                continue;
            }
 
            Console.Write("", "");
        }
    }
}",301,16
38856,http://rosettacode.org/wiki/Long_primes,Long primes,"

A   long prime   (as defined here)   is a prime number whose reciprocal   (in decimal)   has
a   period length   of one less than the prime number.


Long primes   are also known as:

   base ten cyclic numbers
   full reptend primes
   golden primes
   long period primes
   maximal period primes
   proper primes


Another definition:   primes   p   such that the decimal expansion of   1/p   has period   p-1,   which is the greatest period possible for any integer.



Example

7   is the first long prime,   the reciprocal of seven
is   1/7,   which
is equal to the repeating decimal fraction   0.142857142857···

The length of the   repeating   part of the decimal fraction
is six,   (the underlined part)   which is one less
than the (decimal) prime number   7.

Thus   7   is a long prime.



There are other (more) general definitions of a   long prime   which
include wording/verbiage for bases other than ten.



Task

   Show all long primes up to   500   (preferably on one line).
   Show the   number   of long primes up to         500
   Show the   number   of long primes up to      1,000
   Show the   number   of long primes up to      2,000
   Show the   number   of long primes up to      4,000
   Show the   number   of long primes up to      8,000
   Show the   number   of long primes up to   16,000
   Show the   number   of long primes up to   32,000
   Show the   number   of long primes up to   64,000   (optional)
   Show all output here.


Also see

   Wikipedia: full reptend prime
   MathWorld: full reptend prime
   OEIS: A001913

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
public static class LongPrimes
{
    public static void Main() {
        var primes = SomePrimeGenerator.Primes(64000).Skip(1).Where(p => Period(p) == p - 1).Append(99999);
        Console.WriteLine(string.Join("" "", primes.TakeWhile(p => p <= 500)));
        int count = 0, limit = 500;
        foreach (int prime in primes) {
            if (prime > limit) {
                Console.WriteLine($""There are {count} long primes below {limit}"");
                limit *= 2;
            }
            count++;
        }
 
        int Period(int n) {
            int r = 1, rr;
            for (int i = 0; i <= n; i++) r = 10 * r % n;
            rr = r;
            for (int period = 1;; period++) {
                r = (10 * r) % n;
                if (r == rr) return period;
            }
        }
    }
 
}
 
static class SomePrimeGenerator {
 
    public static IEnumerable<int> Primes(int lim) {
        bool [] flags = new bool[lim + 1]; int j = 2;
        for (int d = 3, sq = 4; sq <= lim; j++, sq += d += 2)
            if (!flags[j]) {
                yield return j; for (int k = sq; k <= lim; k += j)
                    flags[k] = true;
            }
        for (; j<= lim; j++) if (!flags[j]) yield return j;
    }
}",1298,43
38925,http://rosettacode.org/wiki/Long_year,Long year,"Most years have 52 weeks, some have 53, according to ISO8601.



Task

Write a function which determines if a given year is long (53 weeks) or not, and demonstrate it.



",#C.23,C#,"using static System.Console;
using System.Collections.Generic;
using System.Linq;
using System.Globalization;
 
public static class Program
{
    public static void Main()
    {
        WriteLine(""Long years in the 21st century:"");
        WriteLine(string.Join("" "", 2000.To(2100).Where(y => ISOWeek.GetWeeksInYear(y) == 53)));
    }
 
    public static IEnumerable<int> To(this int start, int end) {
        for (int i = start; i < end; i++) yield return i;
    }
 
}",468,18
38976,http://rosettacode.org/wiki/Longest_common_subsequence,Longest common subsequence,"Introduction

Define a subsequence to be any output string obtained by deleting zero or more symbols from an input string.

The Longest Common Subsequence (LCS) is a subsequence of maximum length common to two or more strings.

Let A ≡ A[0]… A[m - 1] and B ≡ B[0]… B[n - 1], m < n be strings drawn from an alphabet Σ of size s, containing every distinct symbol in A + B.

An ordered pair (i, j) will be referred to as a match if A[i] = B[j], where 0 < i ≤ m and 0 < j ≤ n.

Define a non-strict product-order (≤) over ordered pairs, such that (i1, j1) ≤ (i2, j2) ⇔ i1 ≤ i2 and j1 ≤ j2. We define (≥) similarly.

We say m1, m2 are comparable if either m1 ≤ m2 or m1 ≥ m2 holds. If i1 < i2 and j2 < j1 (or i2 < i1 and j1 < j2) then neither m1 ≤ m2 nor m1 ≥ m2 are possible; and we say m1, m2 are incomparable.

We also define the strict product-order (<) over ordered pairs, such that (i1, j1) < (i2, j2) ⇔ i1 < i2 and j1 < j2. We define (>) similarly.

Given a set of matches M, a chain C is a subset of M consisting of at least one element m; and where either m1 < m2 or m1 > m2 for every pair of distinct elements m1 and m2. An antichain D is any subset of M in which every pair of distinct elements m1 and m2 are incomparable.

The set M represents a relation over match pairs: M[i, j] ⇔ (i, j) ∈ M. A chain C can be visualized as a curve which strictly increases as it passes through each match pair in the m*n coordinate space.

Finding an LCS can be restated as the problem of finding a chain of maximum cardinality p over the set of matches M.

According to [Dilworth 1950], this cardinality p equals the minimum number of disjoint antichains into which M can be decomposed. Note that such a decomposition into the minimal number p of disjoint antichains may not be unique.

Contours

Forward Contours FC[k] of class k are defined inductively, as follows:

FC[0] consists of those elements m1 for which there exists no element m2 such that m2 < m1.

FC[k] consists of those elements m1 for which there exists no element m2 such that m2 < m1; and where neither m1 nor m2 are contained in FC[l] for any class l < k.

Reverse Contours RC[k] of class k are defined similarly.

Members of the Meet (∧), or Infimum of a Forward Contour are referred to as its Dominant Matches: those m1 for which there exists no m2 such that m2 < m1.

Members of the Join (∨), or Supremum of a Reverse Contour are referred to as its Dominant Matches: those m1 for which there exists no m2 such that m2 > m1.

Where multiple Dominant Matches exist within a Meet (or within a Join, respectively) the Dominant Matches will be incomparable to each other.

Background

Where the number of symbols appearing in matches is small relative to the length of the input strings, reuse of the symbols increases; and the number of matches will tend towards quadratic, O(m*n) growth. This occurs, for example, in the Bioinformatics application of nucleotide and protein sequencing.

The divide-and-conquer approach of [Hirschberg 1975] limits the space required to O(n). However, this approach requires O(m*n) time even in the best case.

This quadratic time dependency may become prohibitive, given very long input strings. Thus, heuristics are often favored over optimal Dynamic Programming solutions.

In the application of comparing file revisions, records from the input files form a large symbol space; and the number of symbols approaches the length of the LCS. In this case the number of matches reduces to linear, O(n) growth.

A binary search optimization due to [Hunt and Szymanski 1977] can be applied to the basic Dynamic Programming approach, resulting in an expected performance of O(n log m). Performance can degrade to O(m*n log m) time in the worst case, as the number of matches grows to O(m*n).

Note

[Rick 2000] describes a linear-space algorithm with a time bound of O(n*s + p*min(m, n - p)).

Legend

A, B are input strings of lengths m, n respectively
p is the length of the LCS
M is the set of match pairs (i, j) such that A[i] = B[j]
r is the magnitude of M
s is the magnitude of the alphabet Σ of distinct symbols in A + B

References

[Dilworth 1950] ""A decomposition theorem for partially ordered sets""
by Robert P. Dilworth, published January 1950,
Annals of Mathematics [Volume 51, Number 1, pp. 161-166]

[Goeman and Clausen 2002] ""A New Practical Linear Space Algorithm for the Longest Common
Subsequence Problem"" by Heiko Goeman and Michael Clausen,
published 2002, Kybernetika [Volume 38, Issue 1, pp. 45-66]

[Hirschberg 1975] ""A linear space algorithm for computing maximal common subsequences""
by Daniel S. Hirschberg, published June 1975
Communications of the ACM [Volume 18, Number 6, pp. 341-343]

[Hunt and McIlroy 1976] ""An Algorithm for Differential File Comparison""
by James W. Hunt and M. Douglas McIlroy, June 1976
Computing Science Technical Report, Bell Laboratories 41

[Hunt and Szymanski 1977] ""A Fast Algorithm for Computing Longest Common Subsequences""
by James W. Hunt and Thomas G. Szymanski, published May 1977
Communications of the ACM [Volume 20, Number 5, pp. 350-353]

[Rick 2000] ""Simple and fast linear space computation of longest common subsequences""
by Claus Rick, received 17 March 2000, Information Processing Letters,
Elsevier Science [Volume 75, pp. 275–281]



Examples

The sequences ""1234"" and ""1224533324"" have an LCS of ""1234"":

1234
1224533324

For a string example, consider the sequences ""thisisatest"" and ""testing123testing"". An LCS would be ""tsitest"":

thisisatest
testing123testing

In this puzzle, your code only needs to deal with strings. Write a function which returns an LCS of two strings (case-sensitive). You don't need to show multiple LCS's.

For more information on this problem please see Wikipedia.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
 
namespace LCS
{
    class Program
    {
        static void Main(string[] args)
        {
            string word1 = ""thisisatest"";
            string word2 = ""testing123testing"";
 
            Console.WriteLine(lcsBack(word1, word2));
            Console.ReadKey();
        }
 
        public static string lcsBack(string a, string b)
        {
            string aSub = a.Substring(0, (a.Length - 1 < 0) ? 0 : a.Length - 1);
            string bSub = b.Substring(0, (b.Length - 1 < 0) ? 0 : b.Length - 1);
 
            if (a.Length == 0 || b.Length == 0)            
                return """";
            else if (a[a.Length - 1] == b[b.Length - 1])
                return lcsBack(aSub, bSub) + a[a.Length - 1];
            else
            {
                string x = lcsBack(a, bSub);
                string y = lcsBack(aSub, b);
                return (x.Length > y.Length) ? x : y;
            }
        }
    }
}",938,33
39013,http://rosettacode.org/wiki/Literals/Floating_point,Literals/Floating point,"Programming languages have different ways of expressing floating-point literals.



Task

Show how floating-point literals can be expressed in your language: decimal or other bases, exponential notation, and any other special features.

You may want to include a regular expression or BNF/ABNF/EBNF defining allowable formats for your language.



Related tasks

   Literals/Integer
   Extreme floating point values

",#C.23,C#,"double d = 1;
d = 1d;
d = 1D;
d = 1.2; //double is the default if there's no suffix
d = 1.2d; //The suffix is redundant here
d = .2;
d = 12e-12;
d = 12E-12;
d = 1_234e-1_2; //digit separators are allowed since C# 7
float f = 1;
f = 1f;
f = 1F;
f = 1.2f;
f = .2f;
f = 12e-12f;
f = 12E-12f;
f = 1_234e-1_2f;
decimal m = 1;
m = 1m;
m = 1m;
m = 1.2m;
m = .2m;
m = 12e-12m;
m = 12E-12m;
m = 1_234e-1_2m;",398,25
39063,http://rosettacode.org/wiki/Loops/Break,Loops/Break,"Task

Show a loop which prints random numbers (each number newly generated each loop) from 0 to 19 (inclusive).

If a number is 10, stop the loop after printing it, and do not generate any further numbers.

Otherwise, generate and print a second random number before restarting the loop.

If the number 10 is never generated as the first number in a loop, loop forever.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges

",#C.23,C#,"class Program
{
    static void Main(string[] args)
    {
        Random random = new Random();
        while (true)
        {
            int a = random.Next(20);
            Console.WriteLine(a);
            if (a == 10)
                break;
            int b = random.Next(20)
            Console.WriteLine(b);
        }
 
        Console.ReadLine();
    }       
}",370,18
39286,http://rosettacode.org/wiki/Look-and-say_sequence,Look-and-say sequence,"The   Look and say sequence   is a recursively defined sequence of numbers studied most notably by   John Conway.



The   look-and-say sequence   is also known as the   Morris Number Sequence,   after cryptographer Robert Morris,   and the puzzle   What is the next number in the sequence 1,   11,   21,   1211,   111221?   is sometimes referred to as the Cuckoo's Egg,   from a description of Morris in Clifford Stoll's book   The Cuckoo's Egg.


Sequence Definition

 Take a decimal number
 Look at the number, visually grouping consecutive runs of the same digit.
 Say the number, from left to right, group by group; as how many of that digit there are - followed by the digit grouped.
 This becomes the next number of the sequence.

An example:

 Starting with the number 1,   you have one 1 which produces 11
 Starting with 11,   you have two 1's.   I.E.:   21
 Starting with 21,   you have one 2, then one 1.   I.E.:   (12)(11) which becomes 1211
 Starting with 1211,   you have one 1, one 2, then two 1's.   I.E.:   (11)(12)(21) which becomes 111221


Task

Write a program to generate successive members of the look-and-say sequence.



Related tasks

   Fours is the number of letters in the ...
   Number names
   Self-describing numbers
   Self-referential sequence
   Spelling of ordinal numbers


See also

   Look-and-Say Numbers (feat John Conway), A Numberphile Video.
   This task is related to, and an application of, the Run-length encoding task.
   Sequence A005150 on The On-Line Encyclopedia of Integer Sequences.

",#C.23,C#,"using System;
using System.Text;
using System.Linq;
 
class Program
{
    static string lookandsay(string number)
    {
        StringBuilder result = new StringBuilder();
 
        char repeat = number[0];
        number = number.Substring(1, number.Length-1)+"" "";
        int times = 1;
 
        foreach (char actual in number)
        {
            if (actual != repeat)
            {
                result.Append(Convert.ToString(times)+repeat);
                times = 1;
                repeat = actual;
            }
            else
            {
                times += 1;
            }
        }
        return result.ToString();
    }
 
    static void Main(string[] args)
    {
        string num = ""1""; 
 
        foreach (int i in Enumerable.Range(1, 10)) {
             Console.WriteLine(num);
             num = lookandsay(num);             
        }
    }
}",878,40
39353,http://rosettacode.org/wiki/Literals/String,Literals/String,"Task

Show literal specification of characters and strings.

If supported, show how the following work:

   verbatim strings   (quotes where escape sequences are quoted literally)
   here-strings   


Also, discuss which quotes expand variables.



Related tasks
 
   Special characters
   Here document



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"string path = @""C:\Windows\System32"";
string multiline = @""Line 1.
Line 2.
Line 3."";",84,4
39362,http://rosettacode.org/wiki/Literals/Integer,Literals/Integer,"Some programming languages have ways of expressing integer literals in bases other than the normal base ten.



Task

Show how integer literals can be expressed in as many bases as your language allows.



Note:   this should not involve the calling of any functions/methods, but should be interpreted by the compiler or interpreter as an integer written to a given base.

Also show any other ways of expressing literals, e.g. for different types of integers.



Related task

   Literals/Floating point

",#C.23,C#,"int a = 42;
int b = 0x2a;",25,2
39373,http://rosettacode.org/wiki/Loop_over_multiple_arrays_simultaneously,Loop over multiple arrays simultaneously,"Task

Loop over multiple arrays   (or lists or tuples or whatever they're called in
your language)   and display the    i th    element of each.

Use your language's   ""for each""   loop if it has one, otherwise iterate
through the collection in order with some other loop.



For this example, loop over the arrays:

    (a,b,c)
    (A,B,C) 
    (1,2,3) 

to produce the output:

    aA1
    bB2
    cC3



If possible, also describe what happens when the arrays are of different lengths.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#C.23,C#,"class Program
{
    static void Main(string[] args)
    {
        char[] a = { 'a', 'b', 'c' };
        char[] b = { 'A', 'B', 'C' };
        int[] c = { 1, 2, 3 };
        int min = Math.Min(a.Length, b.Length);
        min = Math.Min(min, c.Length);
        for (int i = 0; i < min; i++)
            Console.WriteLine(""{0}{1}{2}"", a[i], b[i], c[i]);
    }             
}",372,13
39477,http://rosettacode.org/wiki/Long_multiplication,Long multiplication,"Task

Explicitly implement   long multiplication.

This is one possible approach to arbitrary-precision integer algebra.



For output, display the result of    264 * 264.

Optionally, verify your result against builtin arbitrary precision support.

The decimal representation of    264    is:

18,446,744,073,709,551,616

The output of    264 * 264    is    2128,    and is:

340,282,366,920,938,463,463,374,607,431,768,211,456


",#C.23,C#,"using System;
using static System.Console;
using BI = System.Numerics.BigInteger;
 
class Program {
 
  static decimal mx = 1E28M, hm = 1E14M, a;
 
  // allows for 56 digit representation, using 28 decimal digits from each decimal
  struct bi { public decimal hi, lo; }
 
  // sets up for squaring process
  static bi set4sq(decimal a) { bi r; r.hi = Math.Floor(a / hm); r.lo = a % hm; return r; }
 
  // outputs bi structure as string, optionally inserting commas
  static string toStr(bi a, bool comma = false) {
    string r = a.hi == 0 ? string.Format(""{0:0}"", a.lo) :
                           string.Format(""{0:0}{1:"" + new string('0', 28) + ""}"", a.hi, a.lo);
    if (!comma) return r;  string rc = """";
    for (int i = r.Length - 3; i > 0; i -= 3) rc = "","" + r.Substring(i, 3) + rc;
    return r.Substring(0, ((r.Length + 2) % 3) + 1) + rc; }
 
  // needed because Math.Pow() returns a double
  static decimal Pow_dec(decimal bas, uint exp) {
    if (exp == 0) return 1M; decimal tmp = Pow_dec(bas, exp >> 1); tmp *= tmp;
    if ((exp & 1) == 0) return tmp; return tmp * bas; }
 
  static void Main(string[] args) {
    for (uint p = 64; p < 95; p += 30) {        // show prescribed output and maximum power of 2 output
      bi x = set4sq(a = Pow_dec(2M, p)), y;     // setup for squaring process
      WriteLine(""The square of (2^{0}):                    {1,38:n0}"", p, a); BI BS = BI.Pow((BI)a, 2);
      y.lo = x.lo * x.lo; y.hi = x.hi * x.hi;   // square lo and hi parts
      a = x.hi * x.lo * 2M;                     // calculate midterm
      y.hi += Math.Floor(a / hm);               // increment hi part w/ high part of midterm
      y.lo += (a % hm) * hm;                    // increment lo part w/ low part of midterm
      while (y.lo > mx) { y.lo -= mx; y.hi++; } // check for overflow, adjust both parts as needed
      WriteLine("" is {0,75} (which {1} match the BigInteger computation)\n"", toStr(y, true),
          BS.ToString() == toStr(y) ? ""does"" : ""fails to""); } }
 
}",1997,40
39597,http://rosettacode.org/wiki/Logical_operations,Logical operations,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Write a function that takes two logical (boolean) values, and outputs the result of ""and"" and ""or"" on both arguments as well as ""not"" on the first arguments.

If the programming language doesn't provide a separate type for logical values, use the type most commonly used for that purpose.

If the language supports additional logical operations on booleans such as XOR, list them as well.



",#C.23,C#,"using System;
 
namespace LogicalOperations
{
    class Program
    {
        static void Main(string[] args)
        {
            bool a = true, b = false;
            Console.WriteLine(""a and b is {0}"", a && b);
            Console.WriteLine(""a or b is {0}"", a || b);
            Console.WriteLine(""Not a is {0}"", !a);
            Console.WriteLine(""a exclusive-or b is {0}"", a ^ b);
        }
    }
}",404,16
40984,http://rosettacode.org/wiki/List_comprehensions,List comprehensions,"A list comprehension is a special syntax in some programming languages to describe lists. It is similar to the way mathematicians describe sets, with a set comprehension, hence the name.

Some attributes of a list comprehension are:

 They should be distinct from (nested) for loops and the use of map and filter functions within the syntax of the language.
 They should return either a list or an iterator (something that returns successive members of a collection, in order).
 The syntax has parts corresponding to that of set-builder notation. 


Task

Write a list comprehension that builds the list of all Pythagorean triples with elements between   1   and   n.

If the language has multiple ways for expressing such a construct (for example, direct list comprehensions and generators), write one example for each.



",#C.23,C#,"using System.Linq;
 
static class Program
{
  static void Main()
  {
    var ts =
      from a in Enumerable.Range(1, 20)
      from b in Enumerable.Range(a, 21 - a)
      from c in Enumerable.Range(b, 21 - b)
      where a * a + b * b == c * c
      select new { a, b, c };
 
      foreach (var t in ts)
        System.Console.WriteLine(""{0}, {1}, {2}"", t.a, t.b, t.c);
  }
}
 ",378,18
41038,http://rosettacode.org/wiki/Leonardo_numbers,Leonardo numbers,"
Leonardo numbers   are also known as the   Leonardo series.



The   Leonardo numbers   are a sequence of numbers defined by:

       L(0) = 1                                          [1st equation]  
       L(1) = 1                                          [2nd equation]  
       L(n) = L(n-1)  +    L(n-2)   +  1                 [3rd equation]  
                    ─── also ───
       L(n) =      2  *  Fib(n+1)   -  1                 [4th equation]  

   where the   + 1   will herein be known as the   add   number.
   where the   FIB   is the   Fibonacci numbers.


This task will be using the 3rd equation (above) to calculate the Leonardo numbers.


Edsger W. Dijkstra   used   Leonardo numbers   as an integral part of
his   smoothsort   algorithm.



The first few Leonardo numbers are:

    1   1   3   5   9   15   25   41   67   109   177   287   465   753   1219   1973   3193   5167   8361  ··· 



Task

   show the 1st   25   Leonardo numbers, starting at L(0).
   allow the first two Leonardo numbers to be specified   [for L(0) and L(1)].
   allow the   add   number to be specified   (1 is the default).
   show the 1st   25   Leonardo numbers, specifying 0 and 1 for L(0) and L(1), and 0 for the add number.
(The last task requirement will produce the Fibonacci numbers.)



Show all output here on this page.



Related tasks

   Fibonacci number
   Fibonacci n-step number sequences 


See also

   Wikipedia, Leonardo numbers
   Wikipedia, Fibonacci numbers
   OEIS Leonardo numbers

",#C.23,C#,"using System;
using System.Linq;
 
public class Program
{
    public static void Main() {
        Console.WriteLine(string.Join("" "", Leonardo().Take(25)));
        Console.WriteLine(string.Join("" "", Leonardo(L0: 0, L1: 1, add: 0).Take(25)));
    }
 
    public static IEnumerable<int> Leonardo(int L0 = 1, int L1 = 1, int add = 1) {
        while (true) {
            yield return L0;
            (L0, L1) = (L1, L0 + L1 + add);
        }
    }
}",446,17
41105,http://rosettacode.org/wiki/Left_factorials,Left factorials,"Left factorials,   !n,   may refer to either   subfactorials   or to   factorial sums;

the same notation can be confusingly seen being used for the two different definitions.

Sometimes,   subfactorials   (also known as derangements)   may use any of the notations:

     !n`   
     !n  
     n¡  


(It may not be visually obvious, but the last example uses an upside-down exclamation mark.)



This Rosetta Code task will be using this formula   (factorial sums)   for   left factorial:


   



!
n
=

∑

k
=
0


n
−
1


k
!


{\displaystyle !n=\sum _{k=0}^{n-1}k!}




 where


   



!
0
=
0


{\displaystyle !0=0}






Task
Display the left factorials for:

   zero through ten     (inclusive)
   20   through   110   (inclusive)   by tens


Display the length (in decimal digits) of the left factorials for:

   1,000   through   10,000   (inclusive), by thousands.


Also see

   The OEIS entry: A003422 left factorials
   The MathWorld entry: left factorial
   The MathWorld entry: factorial sums
   The MathWorld entry: subfactorial


Related task

   permutations/derangements (subfactorials)

",#C.23,C#," 
using System;
using System.Numerics;
 
namespace LeftFactorial
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int i = 0; i <= 10; i++)
            {
                Console.WriteLine(string.Format(""!{0} = {1}"", i, LeftFactorial(i)));
            }
 
            for (int j = 20; j <= 110; j += 10)
            {
                Console.WriteLine(string.Format(""!{0} = {1}"", j, LeftFactorial(j)));
            }
 
            for (int k = 1000; k <= 10000; k += 1000)
            {
                Console.WriteLine(string.Format(""!{0} has {1} digits"", k, LeftFactorial(k).ToString().Length));
            }
 
            Console.ReadKey();
        }
 
        private static BigInteger Factorial(int number)
        {
            BigInteger accumulator = 1;
 
            for (int factor = 1; factor <= number; factor++)
            {
                accumulator *= factor;
            }
 
            return accumulator;
        }
 
        private static BigInteger LeftFactorial(int n)
        {
            BigInteger result = 0;
 
            for (int i = 0; i < n; i++)
            {
                result += Factorial(i);
            }
 
            return result;
        }
    }
}
 ",1240,54
41125,http://rosettacode.org/wiki/Linear_congruential_generator,Linear congruential generator,"The linear congruential generator is a very simple example of a random number generator.

All linear congruential generators use this formula:

 




r

n
+
1


=
a
×

r

n


+
c


(
mod

m
)



{\displaystyle r_{n+1}=a\times r_{n}+c{\pmod {m}}}




Where:

 




r

0




{\displaystyle r_{0}}

 is a seed.
 




r

1




{\displaystyle r_{1}}

, 




r

2




{\displaystyle r_{2}}

, 




r

3




{\displaystyle r_{3}}

, ..., are the random numbers.
 



a


{\displaystyle a}

, 



c


{\displaystyle c}

, 



m


{\displaystyle m}

 are constants.


If one chooses the values of 



a


{\displaystyle a}

, 



c


{\displaystyle c}

 and 



m


{\displaystyle m}

 with care, then the generator produces a uniform distribution of integers from 



0


{\displaystyle 0}

 to 



m
−
1


{\displaystyle m-1}

.

LCG numbers have poor quality. 




r

n




{\displaystyle r_{n}}

 and 




r

n
+
1




{\displaystyle r_{n+1}}

 are not independent, as true random numbers would be. Anyone who knows 




r

n




{\displaystyle r_{n}}

 can predict 




r

n
+
1




{\displaystyle r_{n+1}}

, therefore LCG is not cryptographically secure. The LCG is still good enough for simple tasks like Miller-Rabin primality test, or FreeCell deals. Among the benefits of the LCG, one can easily reproduce a sequence of numbers, from the same 




r

0




{\displaystyle r_{0}}

. One can also reproduce such sequence with a different programming language, because the formula is so simple.

The task is to replicate two historic random number generators. One is the rand() function from BSD libc, and the other is the rand() function from the Microsoft C Runtime (MSCVRT.DLL). Each replica must yield the same sequence of integers as the original generator, when starting from the same seed.

In these formulas, the seed becomes 



s
t
a
t

e

0




{\displaystyle state_{0}}

. The random sequence is 



r
a
n

d

1




{\displaystyle rand_{1}}

, 



r
a
n

d

2




{\displaystyle rand_{2}}

 and so on.



BSD formula

 



s
t
a
t

e

n
+
1


=
1103515245
×
s
t
a
t

e

n


+
12345


(
mod


2

31


)



{\displaystyle state_{n+1}=1103515245\times state_{n}+12345{\pmod {2^{31}}}}


 



r
a
n

d

n


=
s
t
a
t

e

n




{\displaystyle rand_{n}=state_{n}}


 



r
a
n

d

n




{\displaystyle rand_{n}}

 is in range 0 to 2147483647.


Microsoft formula

 



s
t
a
t

e

n
+
1


=
214013
×
s
t
a
t

e

n


+
2531011


(
mod


2

31


)



{\displaystyle state_{n+1}=214013\times state_{n}+2531011{\pmod {2^{31}}}}


 



r
a
n

d

n


=
s
t
a
t

e

n


÷

2

16




{\displaystyle rand_{n}=state_{n}\div 2^{16}}


 



r
a
n

d

n




{\displaystyle rand_{n}}

 is in range 0 to 32767.


The BSD formula was so awful that FreeBSD switched to a different formula.

More info is at Random number generator (included)#C.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using static System.Console;
 
namespace LinearCongruentialGenerator
{
    static class LinearCongruentialGenerator
    {
        static int _seed = (int)DateTime.Now.Ticks; // from bad random gens might as well have bad seed!
        static int _bsdCurrent = _seed;
        static int _msvcrtCurrent = _seed;
 
        static int Next(int seed, int a, int b) => (a * seed + b) & int.MaxValue;
 
        static int BsdRand() => _bsdCurrent = Next(_bsdCurrent, 1103515245, 12345); 
 
        static int MscvrtRand() => _msvcrtCurrent = Next (_msvcrtCurrent << 16,214013,2531011) >> 16;
 
        static void PrintRandom(int count, bool isBsd)
        {
            var name = isBsd ? ""BSD"" : ""MS"";
            WriteLine($""{name} next {count} Random"");
            var gen = isBsd ? (Func<int>)(BsdRand) : MscvrtRand;
            foreach (var r in Enumerable.Repeat(gen, count))
                WriteLine(r.Invoke());
        }
 
        static void Main(string[] args)
        {
            PrintRandom(10, true);
            PrintRandom(10, false);
            Read();
        }
    }
}",1153,36
41226,http://rosettacode.org/wiki/Levenshtein_distance,Levenshtein distance,"

 This page uses content from Wikipedia. The original article was at Levenshtein distance. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In information theory and computer science, the Levenshtein distance is a metric for measuring the amount of difference between two sequences (i.e. an edit distance). The Levenshtein distance between two strings is defined as the minimum number of edits needed to transform one string into the other, with the allowable edit operations being insertion, deletion, or substitution of a single character.



Example

The Levenshtein distance between ""kitten"" and ""sitting"" is 3, since the following three edits change one into the other, and there isn't a way to do it with fewer than three edits:

   kitten   sitten   (substitution of 'k' with 's')
   sitten   sittin   (substitution of 'e' with 'i')
   sittin   sitting   (insert 'g' at the end).

The Levenshtein distance between   ""rosettacode"",   ""raisethysword""   is   8.

The distance between two strings is same as that when both strings are reversed.



Task

Implements a Levenshtein distance function, or uses a library function, to show the Levenshtein distance between   ""kitten""   and   ""sitting"".



Related task

   Longest common subsequence



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
 
namespace LevenshteinDistance
{
    class Program
    {
        static int LevenshteinDistance(string s, string t)
        {
            int n = s.Length;
            int m = t.Length;
            int[,] d = new int[n + 1, m + 1];
 
	    if (n == 0)
	    {
		return m;
	    }
 
	    if (m == 0)
	    {
		return n;
	    }
 
            for (int i = 0; i <= n; i++)
                d[i, 0] = i;
            for (int j = 0; j <= m; j++)
                d[0, j] = j;
 
            for (int j = 1; j <= m; j++)
                for (int i = 1; i <= n; i++)
                    if (s[i - 1] == t[j - 1])
                        d[i, j] = d[i - 1, j - 1];  //no operation
                    else
                        d[i, j] = Math.Min(Math.Min(
                            d[i - 1, j] + 1,    //a deletion
                            d[i, j - 1] + 1),   //an insertion
                            d[i - 1, j - 1] + 1 //a substitution
                            );
            return d[n, m];
        }
 
        static void Main(string[] args)
        {
            if (args.Length == 2)
                Console.WriteLine(""{0} -> {1} = {2}"",
                    args[0], args[1], LevenshteinDistance(args[0], args[1]));
            else
                Console.WriteLine(""Usage:-\n\nLevenshteinDistance <string1> <string2>"");
        }
    }
}",1357,50
41244,http://rosettacode.org/wiki/Latin_Squares_in_reduced_form,Latin Squares in reduced form,"A Latin Square is in its reduced form if the first row and first column contain items in their natural order. The order n is the number of items. For any given n there is a set of reduced Latin Squares whose size increases rapidly with n. g is a number which identifies a unique element within the set of reduced Latin Squares of order n. The objective of this task is to construct the set of all Latin Squares of a given order and to provide a means which given suitable values for g any element within the set may be obtained.

For a reduced Latin Square the first row is always 1 to n. The second row is all Permutations/Derangements of 1 to n starting with 2. The third row is all Permutations/Derangements of 1 to n starting with 3 which do not clash (do not have the same item in any column) with row 2. The fourth row is all Permutations/Derangements of 1 to n starting with 4 which do not clash with rows 2 or 3. Likewise continuing to the nth row.

Demonstrate by:

 displaying the four reduced Latin Squares of order 4.
 for n = 1 to 6 (or more) produce the set of reduced Latin Squares; produce a table which shows the size of the set of reduced Latin Squares and compares this value times n! times (n-1)! with the values in OEIS A002860.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace LatinSquares {
    using matrix = List<List<int>>;
 
    class Program {
        static void Swap<T>(ref T a, ref T b) {
            var t = a;
            a = b;
            b = t;
        }
 
        static matrix DList(int n, int start) {
            start--; // use 0 basing
            var a = Enumerable.Range(0, n).ToArray();
            a[start] = a[0];
            a[0] = start;
            Array.Sort(a, 1, a.Length - 1);
            var first = a[1];
            // recursive closure permutes a[1:]
            matrix r = new matrix();
            void recurse(int last) {
                if (last == first) {
                    // bottom of recursion. you get here once for each permutation.
                    // test if permutation is deranged.
                    for (int j = 1; j < a.Length; j++) {
                        var v = a[j];
                        if (j == v) {
                            return; //no, ignore it
                        }
                    }
                    // yes, save a copy with 1 based indexing
                    var b = a.Select(v => v + 1).ToArray();
                    r.Add(b.ToList());
                    return;
                }
                for (int i = last; i >= 1; i--) {
                    Swap(ref a[i], ref a[last]);
                    recurse(last - 1);
                    Swap(ref a[i], ref a[last]);
                }
            }
            recurse(n - 1);
            return r;
        }
 
        static ulong ReducedLatinSquares(int n, bool echo) {
            if (n <= 0) {
                if (echo) {
                    Console.WriteLine(""[]\n"");
                }
                return 0;
            } else if (n == 1) {
                if (echo) {
                    Console.WriteLine(""[1]\n"");
                }
                return 1;
            }
 
            matrix rlatin = new matrix();
            for (int i = 0; i < n; i++) {
                rlatin.Add(new List<int>());
                for (int j = 0; j < n; j++) {
                    rlatin[i].Add(0);
                }
            }
            // first row
            for (int j = 0; j < n; j++) {
                rlatin[0][j] = j + 1;
            }
 
            ulong count = 0;
            void recurse(int i) {
                var rows = DList(n, i);
 
                for (int r = 0; r < rows.Count; r++) {
                    rlatin[i - 1] = rows[r];
                    for (int k = 0; k < i - 1; k++) {
                        for (int j = 1; j < n; j++) {
                            if (rlatin[k][j] == rlatin[i - 1][j]) {
                                if (r < rows.Count - 1) {
                                    goto outer;
                                }
                                if (i > 2) {
                                    return;
                                }
                            }
                        }
                    }
                    if (i < n) {
                        recurse(i + 1);
                    } else {
                        count++;
                        if (echo) {
                            PrintSquare(rlatin, n);
                        }
                    }
                outer: { }
                }
            }
 
            //remaing rows
            recurse(2);
            return count;
        }
 
        static void PrintSquare(matrix latin, int n) {
            foreach (var row in latin) {
                var it = row.GetEnumerator();
                Console.Write(""["");
                if (it.MoveNext()) {
                    Console.Write(it.Current);
                }
                while (it.MoveNext()) {
                    Console.Write("", {0}"", it.Current);
                }
                Console.WriteLine(""]"");
            }
            Console.WriteLine();
        }
 
        static ulong Factorial(ulong n) {
            if (n <= 0) {
                return 1;
            }
            ulong prod = 1;
            for (ulong i = 2; i < n + 1; i++) {
                prod *= i;
            }
            return prod;
        }
 
        static void Main() {
            Console.WriteLine(""The four reduced latin squares of order 4 are:\n"");
            ReducedLatinSquares(4, true);
 
            Console.WriteLine(""The size of the set of reduced latin squares for the following orders"");
            Console.WriteLine(""and hence the total number of latin squares of these orders are:\n"");
            for (int n = 1; n < 7; n++) {
                ulong nu = (ulong)n;
 
                var size = ReducedLatinSquares(n, false);
                var f = Factorial(nu - 1);
                f *= f * nu * size;
                Console.WriteLine(""Order {0}: Size {1} x {2}! x {3}! => Total {4}"", n, size, n, n - 1, f);
            }
        }
    }
}",4917,151
41245,http://rosettacode.org/wiki/Law_of_cosines_-_triples,Law of cosines - triples,"The Law of cosines states that for an angle γ, (gamma) of any triangle, if the sides adjacent to the angle are A and B and the side opposite is C; then the lengths of the sides are related by this formula:

           A2 + B2 - 2ABcos(γ) = C2 

Specific angles

For an angle of of   90º   this becomes the more familiar ""Pythagoras equation"":

           A2 + B2  =  C2           

For an angle of   60º   this becomes the less familiar equation:

           A2 + B2 - AB  =  C2       

And finally for an angle of   120º   this becomes the equation:

           A2 + B2 + AB  =  C2      



Task

   Find all integer solutions (in order) to the three specific cases, distinguishing between each angle being considered.
   Restrain all sides to the integers   1..13   inclusive.
   Show how many results there are for each of the three angles mentioned above.
   Display results on this page.


Note: Triangles with the same length sides but different order are to be treated as the same.

Optional Extra credit

 How many 60° integer triples are there for sides in the range 1..10_000 where the sides are not all of the same length.


Related Task
 Pythagorean triples


See also

 Visualising Pythagoras: ultimate proofs and crazy contortions Mathlogger Video

",#C.23,C#,"using System;
using System.Collections.Generic;
using static System.Linq.Enumerable;
 
public static class LawOfCosinesTriples
{
    public static void Main2() {
        PrintTriples(60, 13);
        PrintTriples(90, 13);
        PrintTriples(120, 13);
        PrintTriples(60, 10_000, true, false);
    }
 
    private static void PrintTriples(int degrees, int maxSideLength, bool notAllTheSameLength = false, bool print = true) {
        string s = $""{degrees} degree triangles in range 1..{maxSideLength}"";
        if (notAllTheSameLength) s += "" where not all sides are the same"";
        Console.WriteLine(s);
        int count = 0;
        var triples = FindTriples(degrees, maxSideLength);
        if (notAllTheSameLength) triples = triples.Where(NotAllTheSameLength);
        foreach (var triple in triples) {
            count++;
            if (print) Console.WriteLine(triple);
        }
        Console.WriteLine($""{count} solutions"");
    }
 
    private static IEnumerable<(int a, int b, int c)> FindTriples(int degrees, int maxSideLength) {
        double radians = degrees * Math.PI / 180;
        int coefficient = (int)Math.Round(Math.Cos(radians) * -2, MidpointRounding.AwayFromZero);
        int maxSideLengthSquared = maxSideLength * maxSideLength;
        return
            from a in Range(1, maxSideLength)
            from b in Range(1, a)
            let cc = a * a + b * b + a * b * coefficient
            where cc <= maxSideLengthSquared
            let c = (int)Math.Sqrt(cc)
            where c * c == cc
            select (a, b, c);
    }
 
    private static bool NotAllTheSameLength((int a, int b, int c) triple) => triple.a != triple.b || triple.a != triple.c;
}",1698,43
41359,http://rosettacode.org/wiki/Last_letter-first_letter,Last letter-first letter,"A certain children's game involves starting with a word in a particular category.   Each participant in turn says a word, but that word must begin with the final letter of the previous word.   Once a word has been given, it cannot be repeated.   If an opponent cannot give a word in the category, they fall out of the game.



For example, with   ""animals""   as the category,

Child 1: dog 
Child 2: goldfish
Child 1: hippopotamus
Child 2: snake
...



Task

Take the following selection of 70 English Pokemon names   (extracted from   Wikipedia's list of Pokemon)   and generate the/a sequence with the highest possible number of Pokemon names where the subsequent name starts with the final letter of the preceding name.

No Pokemon name is to be repeated.

audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon
cresselia croagunk darmanitan deino emboar emolga exeggcute gabite
girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan
kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine
nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2
porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking
sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko
tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask



Extra brownie points for dealing with the full list of   646   names.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            string pokemon_names = @""audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon
cresselia croagunk darmanitan deino emboar emolga exeggcute gabite
girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan
kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine
nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2
porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking
sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko
tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask"";
 
            string[] pokemon = pokemon_names.Split(new char[]{' ','\n'});
            List<string> chain = new List<string>(pokemon.Length);
 
            for (int i = 0; i < pokemon.Length; i++)
            {
                swap(ref pokemon[0], ref pokemon[i]);
                Search( pokemon, chain, 1 );               
                swap(ref pokemon[0], ref pokemon[i]);
            }
 
            foreach (string s in chain)
                Console.WriteLine(s);
 
            Console.ReadKey();
        }
 
        static void Search(string[] pokemon, List<string> longest_chain, int len )
        {
            if (len > longest_chain.Count)
            {
                longest_chain.Clear();
                for (int i = 0; i < len; i++)
                    longest_chain.Add(pokemon[i]);
            }
 
            char lastchar = pokemon[len - 1][pokemon[len-1].Length - 1];
            for (int i = len; i < pokemon.Length; i++)
            {
                if (pokemon[i][0] == lastchar)
                {
                    swap(ref pokemon[i], ref pokemon[len]);
                    Search(pokemon, longest_chain, len + 1);
                    swap(ref pokemon[i], ref pokemon[len]);
                }
            }
        }
 
        static void swap(ref string s1, ref string s2)
        {
            string tmp = s1;
            s1 = s2;
            s2 = tmp;
        }
    }
}",2235,65
41382,http://rosettacode.org/wiki/Largest_number_divisible_by_its_digits,Largest number divisible by its digits,"Task

Find the largest base 10 integer whose digits are all different,   and   is evenly divisible by each of its individual digits.



These numbers are also known as   Lynch-Bell numbers,   numbers   n   such that the
(base ten) digits are all different (and do not include zero)   and   n   is divisible by each of its individual digits.



Example

135   is evenly divisible by   1,   3,   and   5.



Note that the digit zero (0) can not be in the number as integer division by zero is undefined.

The digits must all be unique so a base ten number will have at most 9 digits.

Feel free to use analytics and clever algorithms to reduce the search space your example needs to visit, but it must do an actual search. (Don't just feed it the answer and verify it is correct.)



Stretch goal

Do the same thing for hexadecimal.



Related tasks

   gapful numbers.
   palindromic gapful numbers. 


Also see

   The OEIS sequence:   A115569: Lynch-Bell numbers. 

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace LargestNumber {
    class Program {
        static bool ChkDec(int num) {
            HashSet<int> set = new HashSet<int>();
 
            return num.ToString()
                .Select(c => c - '0')
                .All(d => (d != 0) && (num % d == 0) && set.Add(d));
        }
 
        static void Main() {
            int result = Enumerable.Range(0, 98764321)
                .Reverse()
                .Where(ChkDec)
                .First();
            Console.WriteLine(result);
        }
    }
}",583,23
41391,http://rosettacode.org/wiki/Letter_frequency,Letter frequency,"Task

Open a text file and count the occurrences of each letter.

Some of these programs count all characters (including punctuation),
but some only count letters A to Z.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
 
class Program
{
    static SortedDictionary<TItem, int> GetFrequencies<TItem>(IEnumerable<TItem> items)
    {
        var dictionary = new SortedDictionary<TItem, int>();
        foreach (var item in items)
        {
            if (dictionary.ContainsKey(item))
            {
                dictionary[item]++;
            }
            else
            {
                dictionary[item] = 1;
            }
        }
        return dictionary;
    }
 
    static void Main(string[] arguments)
    {
        var file = arguments.FirstOrDefault();
        if (File.Exists(file))
        {
            var text = File.ReadAllText(file);
            foreach (var entry in GetFrequencies(text))
            {
                Console.WriteLine(""{0}: {1}"", entry.Key, entry.Value);
            }
        }
    }
}",895,37
41422,http://rosettacode.org/wiki/Leap_year,Leap year,"Task

Determine whether a given year is a leap year in the Gregorian calendar.



See also

 Leap year (wiki)

",#C.23,C#,"using System;
 
class Program
{
    static void Main()
    {
        foreach (var year in new[] { 1900, 1994, 1996, DateTime.Now.Year })
        {
            Console.WriteLine(""{0} is {1}a leap year."",
                              year,
                              DateTime.IsLeapYear(year) ? string.Empty : ""not "");
        }
    }
}",338,14
41423,http://rosettacode.org/wiki/Kosaraju,Kosaraju,"

 This page uses content from Wikipedia. The original article was at Graph. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Kosaraju's algorithm (also known as the Kosaraju–Sharir algorithm) is a linear time algorithm to find the strongly connected components of a directed graph. Aho, Hopcroft and Ullman credit it to an unpublished paper from 1978 by S. Rao Kosaraju. The same algorithm was independently discovered by Micha Sharir and published by him in 1981. It makes use of the fact that the transpose graph (the same graph with the direction of every edge reversed) has exactly the same strongly connected components as the original graph.


For this task consider the directed graph with these connections:

 0 -> 1
 1 -> 2
 2 -> 0
 3 -> 1,  3 -> 2,  3 -> 4
 4 -> 3,  4 -> 5
 5 -> 2,  5 -> 6
 6 -> 5
 7 -> 4, 7  -> 6, 7 -> 7

And report the kosaraju strongly connected component for each node.



References

 The article on Wikipedia.",#C.23,C#,"using System;
using System.Collections.Generic;
 
class Node
{
	public enum Colors
	{
		Black, White, Gray
	}
 
	public Colors color { get; set; }
	public int N { get; }
 
	public Node(int n)
	{
		N = n;
		color = Colors.White;
	}
}
 
class Graph
{
	public HashSet<Node> V { get; }
	public Dictionary<Node, HashSet<Node>> Adj { get; }
 
	/// <summary>
	/// Kosaraju's strongly connected components algorithm
	/// </summary>
	public void Kosaraju()
	{
		var L = new HashSet<Node>();
 
		Action<Node> Visit = null;
		Visit = (u) =>
		{
			if (u.color == Node.Colors.White)
			{
				u.color = Node.Colors.Gray;
 
				foreach (var v in Adj[u])
					Visit(v);
 
				L.Add(u);
			}
		};
 
		Action<Node, Node> Assign = null;
		Assign = (u, root) =>
		{
			if (u.color != Node.Colors.Black)
			{
				if (u == root)
					Console.Write(""SCC: "");
 
				Console.Write(u.N + "" "");
				u.color = Node.Colors.Black;
 
				foreach (var v in Adj[u])
					Assign(v, root);
 
				if (u == root)
					Console.WriteLine();
			}
		};
 
		foreach (var u in V)
			Visit(u);
 
		foreach (var u in L)
			Assign(u, u);
	}
}",1097,72
41491,http://rosettacode.org/wiki/Kolakoski_sequence,Kolakoski sequence,"The Kolakoski sequence is an infinite sequence of natural numbers, (excluding zero); with the property that:

 if you form a new sequence from the counts of runs of the same number in the first sequence, this new sequence is the same as the first sequence.
Example

This is not a Kolakoski sequence:

1,1,2,2,2,1,2,2,1,2,...
Its sequence of run counts, (sometimes called a run length encoding, (RLE); but a true RLE also gives the character that each run encodes), is calculated like this:

 Starting from the leftmost number of the sequence we have 2 ones, followed by 3 twos, then 1 ones, 2 twos, 1 one, ...
The above gives the RLE of:

2, 3, 1, 2, 1, ...
The original sequence is different from its RLE in this case. It would be the same for a true Kolakoski sequence.

Creating a Kolakoski sequence

Lets start with the two numbers (1, 2) that we will cycle through; i.e. they will be used in this order:
 1,2,1,2,1,2,....

 We start the sequence s with the first item from the cycle c:
 1
 An index, k, into the, (expanding), sequence will step, or index through each item of the sequence s from the first, at its own rate.
 
We will arrange that the k'th item of s states how many times the last item of sshould appear at the end of s.

We started s with 1 and therefore s[k] states that it should appear only the 1 time.



Increment k
Get the next item from c and append it to the end of sequence s. s will then become:
 1, 2
k was moved to the second item in the list and s[k] states that it should appear two times, so append another of the last item to the sequence s:
 1, 2,2
Increment k
Append the next item from the cycle to the list:
 1, 2,2, 1
k is now at the third item in the list that states that the last item should appear twice so add another copy of the last item to the sequence s:
 1, 2,2, 1,1
increment k
...

Note that the RLE of 1, 2, 2, 1, 1, ... begins 1, 2, 2 which is the beginning of the original sequence. The generation algorithm ensures that this will always be the case.

Task

 Create a routine/proceedure/function/... that given an initial ordered list/array/tuple etc of the natural numbers (1, 2), returns the next number from the list when accessed in a cycle.
 Create another routine that when given the initial ordered list (1, 2) and the minimum length of the sequence to generate; uses the first routine and the algorithm above, to generate at least the requested first members of the kolakoski sequence.
 Create a routine that when given a sequence, creates the run length encoding of that sequence (as defined above) and returns the result of checking if sequence starts with the exact members of its RLE. (But note, due to sampling, do not compare the last member of the RLE).
 Show, on this page, (compactly), the first 20 members of the sequence generated from (1, 2)
 Check the sequence againt its RLE.
 Show, on this page, the first 20 members of the sequence generated from (2, 1)
 Check the sequence againt its RLE.
 Show, on this page, the first 30 members of the Kolakoski sequence generated from (1, 3, 1, 2)
 Check the sequence againt its RLE.
 Show, on this page, the first 30 members of the Kolakoski sequence generated from (1, 3, 2, 1)
 Check the sequence againt its RLE.
(There are rules on generating Kolakoski sequences from this method that are broken by the last example)
",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace KolakoskiSequence {
    class Crutch {
        public readonly int len;
        public int[] s;
        public int i;
 
        public Crutch(int len) {
            this.len = len;
            s = new int[len];
            i = 0;
        }
 
        public void Repeat(int count) {
            for (int j = 0; j < count; j++) {
                if (++i == len) return;
                s[i] = s[i - 1];
            }
        }
    }
 
    static class Extension {
        public static int NextInCycle(this int[] self, int index) {
            return self[index % self.Length];
        }
 
        public static int[] Kolakoski(this int[] self, int len) {
            Crutch c = new Crutch(len);
 
            int k = 0;
            while (c.i < len) {
                c.s[c.i] = self.NextInCycle(k);
                if (c.s[k] > 1) {
                    c.Repeat(c.s[k] - 1);
                }
                if (++c.i == len) return c.s;
                k++;
            }
            return c.s;
        }
 
        public static bool PossibleKolakoski(this int[] self) {
            int[] rle = new int[self.Length];
            int prev = self[0];
            int count = 1;
            int pos = 0;
            for (int i = 1; i < self.Length; i++) {
                if (self[i] == prev) {
                    count++;
                }
                else {
                    rle[pos++] = count;
                    count = 1;
                    prev = self[i];
                }
            }
            // no point adding final 'count' to rle as we're not going to compare it anyway
            for (int i = 0; i < pos; i++) {
                if (rle[i] != self[i]) {
                    return false;
                }
            }
            return true;
        }
 
        public static string AsString(this int[] self) {
            StringBuilder sb = new StringBuilder(""["");
            int count = 0;
            foreach (var item in self) {
                if (count > 0) {
                    sb.Append("", "");
                }
                sb.Append(item);
                count++;
            }
            return sb.Append(""]"").ToString();
        }
    }
 
    class Program {
        static void Main(string[] args) {
            int[][] ias = {
                new int[]{1, 2},
                new int[]{2, 1},
                new int[]{1, 3, 1, 2},
                new int[]{1, 3, 2, 1}
            };
            int[] lens = { 20, 20, 30, 30 };
 
            for (int i = 0; i < ias.Length; i++) {
                int len = lens[i];
                int[] kol = ias[i].Kolakoski(len);
 
                Console.WriteLine(""First {0} members of the sequence by {1}: "", len, ias[i].AsString());
                Console.WriteLine(kol.AsString());
                Console.WriteLine(""Possible Kolakoski sequence? {0}"", kol.PossibleKolakoski());
                Console.WriteLine();
            }
        }
    }
}",3070,106
41493,http://rosettacode.org/wiki/Lah_numbers,Lah numbers,"Lah numbers, sometimes referred to as Stirling numbers of the third kind, are coefficients of polynomial expansions expressing rising factorials in terms of falling factorials.

Unsigned Lah numbers count the number of ways a set of n elements can be partitioned into k non-empty linearly ordered subsets.

Lah numbers are closely related to Stirling numbers of the first & second kinds, and may be derived from them.

Lah numbers obey the identities and relations:

  L(n, 0), L(0, k) = 0   # for n, k > 0
  L(n, n) = 1
  L(n, 1) = n!
  L(n, k) =           ( n! * (n - 1)! ) / ( k! * (k - 1)! ) / (n - k)!      # For unsigned Lah numbers
     or
  L(n, k) = (-1)**n * ( n! * (n - 1)! ) / ( k! * (k - 1)! ) / (n - k)!      # For   signed Lah numbers

Task

 Write a routine (function, procedure, whatever) to find unsigned Lah numbers. There are several methods to generate unsigned Lah numbers. You are free to choose the most appropriate for your language. If your language has a built-in, or easily, publicly available library implementation, it is acceptable to use that.
 Using the routine, generate and show here, on this page, a table (or triangle) showing the unsigned Lah numbers, L(n, k), up to L(12, 12). it is optional to show the row / column for n == 0 and k == 0. It is optional to show places where L(n, k) == 0 (when k > n).
 If your language supports large integers, find and show here, on this page, the maximum value of L(n, k) where n == 100.


See also

 Wikipedia - Lah number
 OEIS:A105278 - Unsigned Lah numbers
 OEIS:A008297 - Signed Lah numbers


Related Tasks

 Stirling numbers of the first kind
 Stirling numbers of the second kind
 Bell numbers

",#C.23,C#,"using System;
using System.Linq;
using System.Numerics;
 
namespace LahNumbers {
    class Program {
        static BigInteger Factorial(BigInteger n) {
            if (n == 0) return 1;
            BigInteger res = 1;
            while (n > 0) {
                res *= n--;
            }
            return res;
        }
 
        static BigInteger Lah(BigInteger n, BigInteger k) {
            if (k == 1) return Factorial(n);
            if (k == n) return 1;
            if (k > n) return 0;
            if (k < 1 || n < 1) return 0;
            return (Factorial(n) * Factorial(n - 1)) / (Factorial(k) * Factorial(k - 1)) / Factorial(n - k);
        }
 
        static void Main() {
            Console.WriteLine(""Unsigned Lah numbers: L(n, k):"");
            Console.Write(""n/k "");
            foreach (var i in Enumerable.Range(0, 13)) {
                Console.Write(""{0,10} "", i);
            }
            Console.WriteLine();
            foreach (var row in Enumerable.Range(0, 13)) {
                Console.Write(""{0,-3}"", row);
                foreach (var i in Enumerable.Range(0, row + 1)) {
                    var l = Lah(row, i);
                    Console.Write(""{0,11}"", l);
                }
                Console.WriteLine();
            }
            Console.WriteLine(""\nMaximum value from the L(100, *) row:"");
            var maxVal = Enumerable.Range(0, 100).Select(a => Lah(100, a)).Max();
            Console.WriteLine(maxVal);
        }
    }
}",1479,44
41530,http://rosettacode.org/wiki/Least_common_multiple,Least common multiple,"Least common multiple

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Compute the   least common multiple   (LCM)   of two integers.

Given   m   and   n,   the least common multiple is the smallest positive integer that has both   m   and   n   as factors.



Example

The least common multiple of   12   and   18   is   36,       because:

   12   is a factor     (12 × 3 = 36),     and 
   18   is a factor     (18 × 2 = 36),     and 
   there is no positive integer less than   36   that has both factors. 


As a special case,   if either   m   or   n   is zero,   then the least common multiple is zero.



One way to calculate the least common multiple is to iterate all the multiples of   m,   until you find one that is also a multiple of   n.

If you already have   gcd   for greatest common divisor,   then this formula calculates   lcm.



 



lcm
⁡
(
m
,
n
)
=




|

m
×
n

|



gcd
⁡
(
m
,
n
)





{\displaystyle \operatorname {lcm} (m,n)={\frac {|m\times n|}{\operatorname {gcd} (m,n)}}}




One can also find   lcm   by merging the prime decompositions of both   m   and   n.



Related task
   greatest common divisor.


See also

   MathWorld entry:   Least Common Multiple.
   Wikipedia entry:   Least common multiple.

",#C.23,C#,"Using System;
class Program
{
    static int gcd(int m, int n)
    {
        return n == 0 ? Math.Abs(m) : gcd(n, n % m);
    }
    static int lcm(int m, int n)
    {
        return Math.Abs(m * n) / gcd(m, n);
    }
    static void Main()
    {
        Console.WriteLine(""lcm(12,18)="" + lcm(12,18));
    }
}
 ",310,17
41553,http://rosettacode.org/wiki/Largest_int_from_concatenated_ints,Largest int from concatenated ints,"Task
 
Given a set of positive integers, write a function to order the integers in such a way that the concatenation of the numbers forms the largest possible integer and return this integer.

Use the following two sets of integers as tests   and   show your program output here.

   {1, 34, 3, 98, 9, 76, 45, 4}
   {54, 546, 548, 60}


Possible algorithms

 A solution could be found by trying all combinations and return the best. 
 Another way to solve this is to note that in the best arrangement, for any two adjacent original integers X and Y, the concatenation X followed by Y will be numerically greater than or equal to the concatenation Y followed by X.
 Yet another way to solve this is to pad the integers to the same size by repeating the digits then sort using these repeated integers as a sort key.


See also

   Algorithms: What is the most efficient way to arrange the given numbers to form the biggest number?
   Constructing the largest number possible by rearranging a list

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
class Program
{
    static void Main(string[] args)
    {
        var source1 = new int[] { 1, 34, 3, 98, 9, 76, 45, 4 };
        var source2 = new int[] { 54, 546, 548, 60 };
 
        var largest1 = LargestPossibleSequence(source1);
        var largest2 = LargestPossibleSequence(source2);
 
        Console.WriteLine(""The largest possible integer from set 1 is: {0}"", largest1);
        Console.WriteLine(""The largest possible integer from set 2 is: {0}"", largest2);
    }
 
    static long LargestPossibleSequence(int[] ints)
    {
        return long.Parse(string.Join("""", ints.OrderBy(i => i, new IntConcatenationComparer()).Reverse()));
    }
}
 
class IntConcatenationComparer : IComparer<int>
{
    public int Compare(int x, int y)
    {
        var xy = int.Parse(x.ToString() + y.ToString());
        var yx = int.Parse(y.ToString() + x.ToString());
 
        return xy - yx;
    }
}
 ",965,35
41671,http://rosettacode.org/wiki/Last_Friday_of_each_month,Last Friday of each month,"Task

Write a program or a script that returns the date of the last Fridays of each month of a given year.

The year may be given through any simple input method in your language (command line, std in, etc).



Example of an expected output:

./last_fridays 2012
2012-01-27
2012-02-24
2012-03-30
2012-04-27
2012-05-25
2012-06-29
2012-07-27
2012-08-31
2012-09-28
2012-10-26
2012-11-30
2012-12-28



Related tasks
 Five weekends
 Day of the week
 Find the last Sunday of each month

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
 
namespace RosettaCode.LastFridaysOfYear
{
    internal static class Program
    {
        private static IEnumerable<DateTime> LastFridaysOfYear(int year)
        {
            for (var month = 1; month <= 12; month++)
            {
                var date = new DateTime(year, month, 1).AddMonths(1).AddDays(-1);
                while (date.DayOfWeek != DayOfWeek.Friday)
                {
                    date = date.AddDays(-1);
                }
                yield return date;
            }
        }
 
        private static void Main(string[] arguments)
        {
            int year;
            var argument = arguments.FirstOrDefault();
            if (string.IsNullOrEmpty(argument) || !int.TryParse(argument, out year))
            {
                year = DateTime.Today.Year;
            }
 
            foreach (var date in LastFridaysOfYear(year))
            {
                Console.WriteLine(date.ToString(""d"", CultureInfo.InvariantCulture));
            }
        }
    }
}",1100,38
41697,http://rosettacode.org/wiki/Kronecker_product,Kronecker product,"Kronecker product

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Implement the   Kronecker product   of two matrices (arbitrary sized) resulting in a block matrix. 




Test cases

Show results for each of the following two samples:




Sample 1 (from Wikipedia):



          ┌   ┐     ┌   ┐     ┌           ┐
          │1 2│     │0 5│     │ 0  5  0 10│
          │3 4│  x  │6 7│  =  │ 6  7 12 14│
	  └   ┘     └   ┘     │ 0 15  0 20│
	                      │18 21 24 28│
                              └           ┘ 

Sample 2:

          ┌     ┐     ┌       ┐     ┌                       ┐       
          │0 1 0│     │1 1 1 1│     │0 0 0 0 1 1 1 1 0 0 0 0│
          │1 1 1│  x  │1 0 0 1│  =  │0 0 0 0 1 0 0 1 0 0 0 0│
          │0 1 0│     │1 1 1 1│     │0 0 0 0 1 1 1 1 0 0 0 0│
	  └     ┘     └       ┘     │1 1 1 1 1 1 1 1 1 1 1 1│
                                    │1 0 0 1 1 0 0 1 1 0 0 1│
                                    │1 1 1 1 1 1 1 1 1 1 1 1│
                                    │0 0 0 0 1 1 1 1 0 0 0 0│
                                    │0 0 0 0 1 0 0 1 0 0 0 0│
                                    │0 0 0 0 1 1 1 1 0 0 0 0│
                                    └                       ┘



See implementations and results below in JavaScript and PARI/GP languages.



Related task

  Kronecker product based fractals. 

",#C.23,C#,"using System;
using System.Collections;
using System.Collections.Generic;
using static System.Linq.Enumerable;
 
public static class KroneckerProduct
{
    public static void Main() {
        int[,] left = { {1, 2}, {3, 4} };
        int[,] right = { {0, 5}, {6, 7} };
        Print(Multiply(left, right));
 
        left = new [,] { {0, 1, 0}, {1, 1, 1}, {0, 1, 0} };
        right = new [,] { {1, 1, 1, 1}, {1, 0, 0, 1}, {1, 1, 1, 1} };
        Print(Multiply(left, right));
    }
 
    static int[,] Multiply(int[,] left, int[,] right) {
        (int lRows, int lColumns) = (left.GetLength(0), left.GetLength(1));
        (int rRows, int rColumns) = (right.GetLength(0), right.GetLength(1));
        int[,] result = new int[lRows * rRows, lColumns * rColumns];
 
        foreach (var (r, c) in from r in Range(0, lRows) from c in Range(0, lColumns) select (r, c)) {
            Copy(r * rRows, c * rColumns, left[r, c]);
        }
        return result;
 
        void Copy(int startRow, int startColumn, int multiplier) {
            foreach (var (r, c) in from r in Range(0, rRows) from c in Range(0, rColumns) select (r, c)) {
                result[startRow + r, startColumn + c] = right[r, c] * multiplier;
            }
        }
    }
 
    static void Print(int[,] matrix) {
        (int rows, int columns) = (matrix.GetLength(0), matrix.GetLength(1));
        int width = matrix.Cast<int>().Select(LengthOf).Max();
        for (int row = 0; row < rows; row++) {
            Console.WriteLine(""| "" + string.Join("" "", Range(0, columns).Select(column => (matrix[row, column] + """").PadLeft(width, ' '))) + "" |"");
        }
        Console.WriteLine();
    }
 
    private static int LengthOf(int i) {
        if (i < 0) return LengthOf(-i) + 1;
        int length = 0;
        while (i > 0) {
            length++;
            i /= 10;
        }
        return length;
    }
 
}",1886,54
41940,http://rosettacode.org/wiki/Langton%27s_ant,Langton's ant,"Langton's ant is a cellular automaton that models an ant sitting on a plane of cells, all of which are white initially, the ant facing in one of four directions.

Each cell can either be black or white.

The ant moves according to the color of the cell it is currently sitting in, with the following rules:

   If the cell is black, it changes to white and the ant turns left;
   If the cell is white, it changes to black and the ant turns right;
   The ant then moves forward to the next cell, and repeat from step 1.

This rather simple ruleset leads to an initially chaotic movement pattern, and after about 10000 steps, a cycle appears where the ant moves steadily away from the starting location in a diagonal corridor about 10 cells wide.
Conceptually the ant can then walk infinitely far away.



Task

Start the ant near the center of a 100x100 field of cells, which is about big enough to contain the initial chaotic part of the movement.

Follow the movement rules for the ant, terminate when it moves out of the region, and show the cell colors it leaves behind.



The problem has received some analysis; for more details, please take a look at the Wikipedia article   (a link is below)..



See also

   Wikipedia:   Langton's ant.


Related task

   Rosetta Code:   Conway's Game of Life.

",#C.23,C#,"using System;
 
namespace LangtonAnt
{
    public struct Point
    {
        public int X;
        public int Y;
 
        public Point(int x, int y)
        {
            X = x;
            Y = y;
        }
    }
 
    enum Direction
    {
        North, East, West, South
    }
 
    public class Langton
    {
        public readonly bool [,] IsBlack;
        private Point _origin;
        private Point _antPosition = new Point(0, 0);
        public bool OutOfBounds { get; set;}
 
        // I don't see any mention of what direction the ant is supposed to start out in
        private Direction _antDirection = Direction.East;
 
        private readonly Direction[] _leftTurn = new[] { Direction.West, Direction.North, Direction.South, Direction.East };
        private readonly Direction[] _rightTurn = new[] { Direction.East, Direction.South, Direction.North, Direction.West };
        private readonly int[] _xInc = new[] { 0, 1,-1, 0};
        private readonly int[] _yInc = new[] {-1, 0, 0, 1};
 
        public Langton(int width, int height, Point origin)
        {
            _origin = origin;
            IsBlack = new bool[width, height];
            OutOfBounds = false;
        }
 
        public Langton(int width, int height) : this(width, height, new Point(width / 2, height / 2)) {}
 
        private void MoveAnt()
        {
            _antPosition.X += _xInc[(int)_antDirection];
            _antPosition.Y += _yInc[(int)_antDirection];
        }
 
        public Point Step()
        {
            if (OutOfBounds)
            {
                throw new InvalidOperationException(""Trying to step after ant is out of bounds"");
            }
            Point ptCur = new Point(_antPosition.X + _origin.X, _antPosition.Y + _origin.Y);
            bool leftTurn = IsBlack[ptCur.X, ptCur.Y];
            int iDirection = (int) _antDirection;
            _antDirection = leftTurn ? _leftTurn[iDirection] : _rightTurn[iDirection];
            IsBlack[ptCur.X, ptCur.Y] = !IsBlack[ptCur.X, ptCur.Y];
            MoveAnt();
            ptCur = new Point(_antPosition.X + _origin.X, _antPosition.Y + _origin.Y);
            OutOfBounds = 
                ptCur.X < 0 ||
                ptCur.X >= IsBlack.GetUpperBound(0) ||
                ptCur.Y < 0 ||
                ptCur.Y >= IsBlack.GetUpperBound(1);
            return _antPosition;
        }
    }
    class Program
    {
        static void Main()
        {
            Langton ant = new Langton(100, 100);
 
            while (!ant.OutOfBounds) ant.Step();
 
            for (int iRow = 0; iRow < 100; iRow++)
            {
                for (int iCol = 0; iCol < 100; iCol++)
                {
                    Console.Write(ant.IsBlack[iCol, iRow] ? ""#"" : "" "");
                }
                Console.WriteLine();
            }
 
            Console.ReadKey();
        }
    }
}
 ",2871,94
42575,http://rosettacode.org/wiki/Keyboard_input/Obtain_a_Y_or_N_response,Keyboard input/Obtain a Y or N response,"

Task

Obtain a valid   Y   or   N   response from the keyboard.

The keyboard should be flushed, so that any outstanding key-presses are removed, preventing any existing   Y   or   N   key-press from being evaluated.

The response should be obtained as soon as   Y   or   N   are pressed, and there should be no need to press an   enter   key.



",#C.23,C#,"using System;
 
namespace Y_or_N
{
    class Program
    {
        static void Main()
        {
            bool response = GetYorN();
        }
 
        static bool GetYorN()
        {
            ConsoleKey response; // Creates a variable to hold the user's response.
 
            do
            {
                while (Console.KeyAvailable) // Flushes the input queue.
                    Console.ReadKey();
 
                Console.Write(""Y or N? ""); // Asks the user to answer with 'Y' or 'N'.
                response = Console.ReadKey().Key; // Gets the user's response.
                Console.WriteLine(); // Breaks the line.
            } while (response != ConsoleKey.Y && response != ConsoleKey.N); // If the user did not respond with a 'Y' or an 'N', repeat the loop.
 
             /* 
              * Return true if the user responded with 'Y', otherwise false.
              * 
              * We know the response was either 'Y' or 'N', so we can assume 
              * the response is 'N' if it is not 'Y'.
              */
            return response == ConsoleKey.Y;
        }
    }
}",1109,35
42613,http://rosettacode.org/wiki/Knapsack_problem/Continuous,Knapsack problem/Continuous,"

A thief burgles a butcher's shop, where he can select from some items.

The thief knows the weights and prices of each items.   Because he has a knapsack with 15 kg maximal capacity, he wants to select the items such that he would have his profit maximized.   He may cut the items;   the item has a reduced price after cutting that is proportional to the original price by the ratio of masses.   That means:   half of an item has half the price of the original.



This is the item list in the butcher's shop:


 Table of potential knapsack items


 Item 
 Weight (kg) 
 Price (Value)


 beef 
 3.8 
 36


 pork 
 5.4 
 43


 ham 
 3.6 
 90


 greaves 
 2.4 
 45


 flitch 
 4.0 
 30


 brawn 
 2.5 
 56


 welt 
 3.7 
 67


 salami 
 3.0 
 95


 sausage 
 5.9 
 98


 Knapsack 
 <=15 kg 
 ?



Task

Show which items the thief carries in his knapsack so that their total weight does not exceed 15 kg, and their total value is maximized.



Related tasks

   Knapsack problem/Bounded
   Knapsack problem/Unbounded
   Knapsack problem/0-1


See also

   Wikipedia article:   continuous knapsack.

",#C.23,C#,"using System;  //4790@3.6
class Program
{
    static void Main()
    {
        Console.WriteLine(knapSack(15) + ""\n"");
        var sw = System.Diagnostics.Stopwatch.StartNew();
        for (int i = 1000; i > 0; i--) knapSack(15);
        Console.Write(sw.Elapsed); Console.Read();    // 0.60 µs
    }
 
    static string knapSack(double w1)
    {
        int k = w.Length; var q = new double[k];
        for (int i = 0; i < k; ) q[i] = v[i] / w[i++];
        var c = new double[k];
        Array.Copy(q, c, k); Array.Sort(c, w);
        Array.Copy(q, c, k); Array.Sort(c, v);
        Array.Sort(q, items);
        string str = """";
        for (k--; k >= 0; k--)
            if (w1 - w[k] > 0) { w1 -= w[k]; str += items[k] + ""\n""; }
            else break;
        return w1 > 0 && k >= 0 ? str + items[k] : str;
    }
 
    static double[] w = { 3.8, 5.4, 3.6, 2.4, 4.0, 2.5, 3.7, 3.0, 5.9 },
 
                    v = { 36, 43, 90, 45, 30, 56, 67, 95, 98 };
 
    static string[] items = {""beef"",""pork"",""ham"",""greaves"",""flitch"",
                             ""brawn"",""welt"",""salami"",""sausage""};
}",1097,33
42619,http://rosettacode.org/wiki/Knapsack_problem/Bounded,Knapsack problem/Bounded,"A tourist wants to make a good trip at the weekend with his friends.

They will go to the mountains to see the wonders of nature.   So he needs some items during the trip.   Food, clothing, etc.   He has a good knapsack for carrying the things, but he knows that he can carry only 4 kg weight in his knapsack, because they will make the trip from morning to evening.

He creates a list of what he wants to bring for the trip, but the total weight of all items is too much.   He adds a value to each item.   The value represents how important the thing for the tourist.

The list contains which items are the wanted things for the trip, what is the weight and value of an item, and how many units does he have from each items.



This is the list:


 Table of potential knapsack items


 item 
 weight (dag) (each) 
 value (each) 
 piece(s)


 map 
 9 
 150 
 1


 compass 
 13 
 35 
 1


 water 
 153 
 200 
 2


 sandwich 
 50 
 60 
 2


 glucose 
 15 
 60 
 2


 tin 
 68 
 45 
 3


 banana 
 27 
 60 
 3


 apple 
 39 
 40 
 3


 cheese 
 23 
 30 
 1


 beer 
 52 
 10 
 3


 suntan cream 
 11 
 70 
 1


 camera 
 32 
 30 
 1


 T-shirt 
 24 
 15 
 2


 trousers 
 48 
 10 
 2


 umbrella 
 73 
 40 
 1


 waterproof trousers 
 42 
 70 
 1


 waterproof overclothes 
 43 
 75 
 1


 note-case 
 22 
 80 
 1


 sunglasses 
 7 
 20 
 1


 towel 
 18 
 12 
 2


 socks 
 4 
 50 
 1


 book 
 30 
 10 
 2


 knapsack 
 ≤400 dag 
 ? 
 ?



The tourist can choose to take any combination of items from the list, and some number of each item is available   (see the column   piece(s)   in the list above).

He may not cut the items, so he can only take whole units of any item.



Task

Show which items does the tourist carry in his knapsack so that their total weight does not exceed 4 kg, and their total value is maximized.



Related tasks

   Knapsack problem/Unbounded
   Knapsack problem/Continuous
   Knapsack problem/0-1

",#C.23,C#,"using System;  // 4790@3.6
class program
{
    static void Main()
    {
        knapSack(40);
        var sw = System.Diagnostics.Stopwatch.StartNew();
        Console.Write(knapSack(400) + ""\n"" + sw.Elapsed);  // 51 µs
        Console.Read();
    }
 
    static string knapSack(uint w1)
    {
        init(); change();
        uint n = (uint)w.Length; var K = new uint[n + 1, w1 + 1];
        for (uint vi, wi, w0, x, i = 0; i < n; i++)
            for (vi = v[i], wi = w[i], w0 = 1; w0 <= w1; w0++)
            {
                x = K[i, w0];
                if (wi <= w0) x = max(vi + K[i, w0 - wi], x);
                K[i + 1, w0] = x;
            }
        string str = """";
        for (uint v1 = K[n, w1]; v1 > 0; n--)
            if (v1 != K[n - 1, w1])
            {
                v1 -= v[n - 1]; w1 -= w[n - 1]; str += items[n - 1] + ""\n"";
            }
        return str;
    }
 
    static uint max(uint a, uint b) { return a > b ? a : b; }
 
    static byte[] w, v; static string[] items;
 
    static byte[] p = { 1, 1, 2, 2, 2, 3, 3, 3, 1, 3, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2 };
 
    static void init()
    {
        w = new byte[] { 9, 13, 153, 50, 15, 68, 27, 39, 23, 52, 11,
                          32, 24, 48, 73, 42, 43, 22, 7, 18, 4, 30 };
 
        v = new byte[] { 150, 35, 200, 60, 60, 45, 60, 40, 30, 10, 70,
                          30, 15, 10, 40, 70, 75, 80, 20, 12, 50, 10 };
 
        items = new string[] {""map"",""compass"",""water"",""sandwich"",""glucose"",""tin"",
                              ""banana"",""apple"",""cheese"",""beer"",""suntan cream"",
                              ""camera"",""T-shirt"",""trousers"",""umbrella"",
                              ""waterproof trousers"",""waterproof overclothes"",
                              ""note-case"",""sunglasses"",""towel"",""socks"",""book""};
    }
 
    static void change()
    {
        int n = w.Length, s = 0, i, j, k; byte xi;
        for (i = 0; i < n; i++) s += p[i];
        {
            byte[] x = new byte[s];
            for (k = i = 0; i < n; i++)
                for (xi = w[i], j = p[i]; j > 0; j--) x[k++] = xi;
            w = x;
        }
        {
            byte[] x = new byte[s];
            for (k = i = 0; i < n; i++)
                for (xi = v[i], j = p[i]; j > 0; j--) x[k++] = xi;
            v = x;
        }
        string[] pItems = new string[s]; string itemI;
        for (k = i = 0; i < n; i++)
            for (itemI = items[i], j = p[i]; j > 0; j--) pItems[k++] = itemI;
        items = pItems;
    }
}",2504,74
42666,http://rosettacode.org/wiki/Knapsack_problem/Unbounded,Knapsack problem/Unbounded,"A traveler gets diverted and has to make an unscheduled stop in what turns out to be Shangri La.   Opting to leave, he is allowed to take as much as he likes of the following items, so long as it will fit in his knapsack, and he can carry it.

He knows that he can carry no more than   25   'weights' in total;   and that the capacity of his knapsack is   0.25   'cubic lengths'.

Looking just above the bar codes on the items he finds their weights and volumes.   He digs out his recent copy of a financial paper and gets the value of each item.

ItemExplanationValue (each)weightVolume (each)panacea
(vials of)Incredible healing properties30000.30.025ichor
(ampules of)Vampires blood18000.20.015gold
(bars)Shiney shiney25002.00.002KnapsackFor the carrying of-<=25<=0.25 



He can only take whole units of any item, but there is much more of any item than he could ever carry



Task

Show how many of each item does he take to maximize the value of items he is carrying away with him.



Note
 
   There are four solutions that maximize the value taken.   Only one need be given.


Related tasks

   Knapsack problem/Bounded
   Knapsack problem/Continuous
   Knapsack problem/0-1

",#C.23,C#,"/*    Items  Value  Weight  Volume
          a     30       3      25
          b     18       2      15
          c     25      20       2
 
                     <=250   <=250      */
using System;
class Program
{
    static void Main()
    {
        uint[] r = items1();
        Console.WriteLine(r[0] + "" v  "" + r[1] + "" a  "" + r[2] + "" b"");  // 0 15 11
        var sw = System.Diagnostics.Stopwatch.StartNew();
        for (int i = 1000; i > 0; i--) items1();
        Console.Write(sw.Elapsed); Console.Read();
    }
 
    static uint[] items0()  // 1.2 µs
    {
        uint v, v0 = 0, a, b, c, a0 = 0, b0 = 0, c0 = 0;
        for (a = 0; a <= 10; a++)
            for (b = 0; a * 5 + b * 3 <= 50; b++)
                for (c = 0; a * 25 + b * 15 + c * 2 <= 250 && a * 3 + b * 2 + c * 20 <= 250; c++)
                    if (v0 < (v = a * 30 + b * 18 + c * 25))
                    {
                        v0 = v; a0 = a; b0 = b; c0 = c;
                        //Console.WriteLine(""{0,5} {1,5} {2,5} {3,5}"", v, a, b, c);
                    }
        return new uint[] { a0, b0, c0 };
    }
 
    static uint[] items1()  // 0,22 µs 
    {
        uint v, v0 = 0, a, b, c, a0 = 0, b0 = 0, c0 = 0, c1 = 0;
        for (a = 0; a <= 10; a++)
            for (b = 0; a * 5 + b * 3 <= 50; b++)
            {
                c = (250 - a * 25 - b * 15) / 2;
                if ((c1 = (250 - a * 3 - b * 2) / 20) < c) c = c1;
                if (v0 < (v = a * 30 + b * 18 + c * 25))
                { v0 = v; a0 = a; b0 = b; c0 = c; }
            }
        return new uint[] { a0, b0, c0 };
    }
}",1598,46
42714,http://rosettacode.org/wiki/Keyboard_input/Keypress_check,Keyboard input/Keypress check,"

Determine if a key has been pressed and store this in a variable.

If no key has been pressed, the program should continue without waiting.



",#C.23,C#,"string chr = string.Empty;
if(Console.KeyAvailable)
  chr = Console.ReadKey().Key.ToString();",93,3
42904,http://rosettacode.org/wiki/Kernighans_large_earthquake_problem,Kernighans large earthquake problem,"Brian Kernighan, in a lecture at the University of Nottingham, described a problem on which this task is based.

Problem

You are given a a data file of thousands of lines; each of three `whitespace` separated fields: a date, a one word name and the magnitude of the event.

Example lines from the file would be lines like:

8/27/1883    Krakatoa            8.8
5/18/1980    MountStHelens       7.6
3/13/2009    CostaRica           5.1
Task

 Create a program or script invocation to find all the events with magnitude greater than 6
 Assuming an appropriate name e.g. ""data.txt"" for the file:
 Either: Show how your program is invoked to process a data file of that name.
 Or: Incorporate the file name into the program, (as it is assumed that the program is single use).

",#C.23,C#,"using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
 
public class Program
{
    static void Main() {
        foreach (var earthquake in LargeEarthquakes(""data.txt"", 6))
            Console.WriteLine(string.Join("" "", earthquake));
    }
 
    static IEnumerable<string[]> LargeEarthquakes(string filename, double limit) =>
        from line in File.ReadLines(filename)
        let parts = line.Split(default(char[]), StringSplitOptions.RemoveEmptyEntries)
        where double.Parse(parts[2]) > limit
        select parts;
 
}",558,19
42928,http://rosettacode.org/wiki/Jump_anywhere,Jump anywhere,"Imperative programs
conditional structures
loops
local jumps
This task is to demonstrate a local jump and a global jump and the various other types of jumps that the language supports.
For the purpose of this task, the jumps need not be used for a single purpose and you have the freedom to use these jumps for different purposes.
You may also defer to more specific tasks, like Exceptions or Generator.
This task provides a ""grab bag"" for several types of jumps. There are non-local jumps across function calls, or long jumps to anywhere within a program. Anywhere means not only to the tops of functions!

 Some languages can go to any global label in a program.
 Some languages can break multiple function calls, also known as unwinding the call stack.
 Some languages can save a continuation. The program can later continue from the same place. So you can jump anywhere, but only if you have a previous visit there (to save the continuation).

These jumps are not all alike.
A simple goto never touches the call stack.
A continuation saves the call stack, so you can continue a function call after it ends.



Task

Use your language to demonstrate the various types of jumps that it supports.

Because the possibilities vary by language, this task is not specific.
You have the freedom to use these jumps for different purposes.
You may also defer to more specific tasks, like Exceptions or Generator.



",#C.23,C#,"if (x > 0) goto positive;
else goto negative;
 
positive:
    Console.WriteLine(""pos\n""); goto both;
 
negative:
    Console.WriteLine(""neg\n"");
 
both:
    ...",160,11
42956,http://rosettacode.org/wiki/Knuth_shuffle,Knuth shuffle,"The   Knuth shuffle   (a.k.a. the Fisher-Yates shuffle)   is an algorithm for randomly shuffling the elements of an array.



Task

Implement the Knuth shuffle for an integer array (or, if possible, an array of any type).



Specification

Given an array items with indices ranging from 0 to last, the algorithm can be defined as follows (pseudo-code):

       for i from last downto 1 do:
           let j = random integer in range 0 
  
    
      
        ≤
      
    
    {\displaystyle \leq }
  
 j 
  
    
      
        ≤
      
    
    {\displaystyle \leq }
  
 i
           swap items[i] with items[j]

Notes

   It modifies the input array in-place. 
   If that is unreasonable in your programming language, you may amend the algorithm to return the shuffled items as a new array instead.
   The algorithm can also be amended to iterate from left to right, if that is more convenient.


Test cases



 Input array

 Possible output arrays


 []

 []


 [10]

 [10]


 [10, 20]

 [10, 20]
[20, 10]


 [10, 20, 30]

 [10, 20, 30]
[10, 30, 20]
[20, 10, 30]
[20, 30, 10]
[30, 10, 20]
[30, 20, 10]

(These are listed here just for your convenience; no need to demonstrate them on the page.)



Related task

 Sattolo cycle



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"public static void KnuthShuffle<T>(T[] array)
{
    System.Random random = new System.Random();
    for (int i = 0; i < array.Length; i++)
    {
        int j = random.Next(i, array.Length); // Don't select from the entire array on subsequent loops
        T temp = array[i]; array[i] = array[j]; array[j] = temp;
    }
}",321,9
43027,http://rosettacode.org/wiki/Julia_set,Julia set,"
Task
Generate and draw a Julia set.




Related tasks
   Mandelbrot Set

",#C.23,C#,"using System.Drawing;
// Note: You have to add the System.Drawing assembly 
//  (right-click ""references,"" Add Reference, Assemblies, Framework,
//    System.Drawing, OK)
using System.Linq;
 
namespace RosettaJuliaSet
{
    class Program
    {
        static void Main(string[] args)
        {
            const int w = 800;
            const int h = 600;
            const int zoom = 1;
            const int maxiter = 255;
            const int moveX = 0;
            const int moveY = 0;
            const double cX = -0.7;
            const double cY = 0.27015;
            double zx, zy, tmp;
            int i;
 
            var colors = (from c in Enumerable.Range(0, 256)
                          select Color.FromArgb((c >> 5) * 36, (c >> 3 & 7) * 36, (c & 3) * 85)).ToArray();
 
            var bitmap = new Bitmap(w, h);
            for (int x = 0; x < w; x++)
            {
                for (int y = 0; y < h; y++)
                {
                    zx = 1.5 * (x - w / 2) / (0.5 * zoom * w) + moveX;
                    zy = 1.0 * (y - h / 2) / (0.5 * zoom * h) + moveY;
                    i = maxiter;
                    while (zx * zx + zy * zy < 4 && i > 1)
                    {
                        tmp = zx * zx - zy * zy + cX;
                        zy = 2.0 * zx * zy + cY;
                        zx = tmp;
                        i -= 1;
                    }
                    bitmap.SetPixel(x, y, colors[i]);
                }
            }
            bitmap.Save(""julia-set.png"");
        }
    }
}
 ",1543,49
43093,http://rosettacode.org/wiki/Knight%27s_tour,Knight's tour,"
Task
Problem: you have a standard 8x8 chessboard, empty but for a single knight on some square. Your task is to emit a series of legal knight moves that result in the knight visiting every square on the chessboard exactly once. Note that it is not a requirement that the tour be ""closed""; that is, the knight need not end within a single move of its start position.

Input and output may be textual or graphical, according to the conventions of the programming environment. If textual, squares should be indicated in algebraic notation. The output should indicate the order in which the knight visits the squares, starting with the initial position. The form of the output may be a diagram of the board with the squares numbered according to visitation sequence, or a textual list of algebraic coordinates in order, or even an actual animation of the knight moving around the chessboard.

Input: starting square

Output: move sequence



Related tasks
 A* search algorithm
 N-queens problem
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace prog
{
	class MainClass
	{	
		const int N = 8;
 
		readonly static int[,] moves = { {+1,-2},{+2,-1},{+2,+1},{+1,+2},
			                         {-1,+2},{-2,+1},{-2,-1},{-1,-2} };
		struct ListMoves
		{
			public int x, y;			
			public ListMoves( int _x, int _y ) { x = _x; y = _y; }
		}		
 
		public static void Main (string[] args)
		{
			int[,] board = new int[N,N];
			board.Initialize();
 
			int x = 0,						// starting position
			    y = 0;
 
			List<ListMoves> list = new List<ListMoves>(N*N);
			list.Add( new ListMoves(x,y) );
 
			do
			{								
				if ( Move_Possible( board, x, y ) )
				{										
					int move = board[x,y];					
					board[x,y]++;
					x += moves[move,0];
					y += moves[move,1];			
					list.Add( new ListMoves(x,y) );							
				}
				else
				{					
					if ( board[x,y] >= 8 )
					{						
						board[x,y] = 0;																
						list.RemoveAt(list.Count-1);						
						if ( list.Count == 0 )
						{
							Console.WriteLine( ""No solution found."" );
							return;
						}		
						x = list[list.Count-1].x;
						y = list[list.Count-1].y;						
					}
					board[x,y]++;
				}				
			}
			while( list.Count < N*N );
 
			int last_x = list[0].x,
			    last_y = list[0].y;
			string letters = ""ABCDEFGH"";
			for( int i=1; i<list.Count; i++ )
			{				
				Console.WriteLine( string.Format(""{0,2}:  "", i) + letters[last_x] + (last_y+1) + "" - "" + letters[list[i].x] + (list[i].y+1) );
 
				last_x = list[i].x;
				last_y = list[i].y;
			}
		}
 
		static bool Move_Possible( int[,] board, int cur_x, int cur_y )
		{			
			if ( board[cur_x,cur_y] >= 8 ) 
				return false;
 
			int new_x = cur_x + moves[board[cur_x,cur_y],0],
			    new_y = cur_y + moves[board[cur_x,cur_y],1];
 
			if ( new_x >= 0 && new_x < N && new_y >= 0 && new_y < N && board[new_x,new_y] == 0 )
				return true;
 
			return false;
		}
	}
}",1915,84
43113,http://rosettacode.org/wiki/JSON,JSON,"Load a JSON string into a data structure.
Also, create a new data structure and serialize it into JSON.

Use objects and arrays (as appropriate for your language)
and make sure your JSON is valid (https://jsonformatter.org).
",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Web.Script.Serialization;
 
class Program
{
    static void Main()
    {
        var people = new Dictionary<string, object> {{""1"", ""John""}, {""2"", ""Susan""}};
        var serializer = new JavaScriptSerializer();
 
        var json = serializer.Serialize(people);
        Console.WriteLine(json);
 
        var deserialized = serializer.Deserialize<Dictionary<string, object>>(json);
        Console.WriteLine(deserialized[""2""]);
 
        var jsonObject = serializer.DeserializeObject(@""{ """"foo"""": 1, """"bar"""": [10, """"apples""""] }"");
        var data = jsonObject as Dictionary<string, object>;
        var array = data[""bar""] as object[];
        Console.WriteLine(array[1]);
    }
}",742,23
43157,http://rosettacode.org/wiki/Knapsack_problem/0-1,Knapsack problem/0-1,"A tourist wants to make a good trip at the weekend with his friends.

They will go to the mountains to see the wonders of nature, so he needs to pack well for the trip.

He has a good knapsack for carrying things, but knows that he can carry a maximum of only 4kg in it,   and it will have to last the whole day.

He creates a list of what he wants to bring for the trip but the total weight of all items is too much.

He then decides to add columns to his initial list detailing their weights and a numerical value representing how important the item is for the trip.



Here is the list:


 Table of potential knapsack items


 item 
 weight (dag) 
 value


 map 
 9 
 150


 compass 
 13 
 35


 water 
 153 
 200


 sandwich 
 50 
 160


 glucose 
 15 
 60


 tin 
 68 
 45


 banana 
 27 
 60


 apple 
 39 
 40


 cheese 
 23 
 30


 beer 
 52 
 10


 suntan cream 
 11 
 70


 camera 
 32 
 30


 T-shirt 
 24 
 15


 trousers 
 48 
 10


 umbrella 
 73 
 40


 waterproof trousers 
 42 
 70


 waterproof overclothes 
 43 
 75


 note-case 
 22 
 80


 sunglasses 
 7 
 20


 towel 
 18 
 12


 socks 
 4 
 50


 book 
 30 
 10


 knapsack 
 ≤400 dag 
 ?



The tourist can choose to take any combination of items from the list,
but only one of each item is available.

He may not cut or diminish the items, so he can only take whole units of any item.



Task

Show which items the tourist can carry in his knapsack so that their total weight does not
exceed 400 dag [4 kg],   and their total value is maximized.

[dag = decagram = 10 grams]



Related tasks

   Knapsack problem/Bounded
   Knapsack problem/Unbounded
   Knapsack problem/Continuous
   A* search algorithm

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace Tests_With_Framework_4
{
 
class Bag : IEnumerable<Bag.Item>
        {
            List<Item> items;
            const int MaxWeightAllowed = 400;
 
            public Bag()
            {
                items = new List<Item>();
            }
 
            void AddItem(Item i)
            {
                if ((TotalWeight + i.Weight) <= MaxWeightAllowed)
                    items.Add(i);
            }
 
            public void Calculate(List<Item> items)
            {
                foreach (Item i in Sorte(items))
                {
                    AddItem(i);
                }
            }
 
            List<Item> Sorte(List<Item> inputItems)
            {
                List<Item> choosenItems = new List<Item>();
                for (int i = 0; i < inputItems.Count; i++)
                {
                    int j = -1;
                    if (i == 0)
                    {
                        choosenItems.Add(inputItems[i]);
                    }
                    if (i > 0)
                    {
                        if (!RecursiveF(inputItems, choosenItems, i, choosenItems.Count - 1, false, ref j))
                        {
                            choosenItems.Add(inputItems[i]);
                        }
                    }
                }
                return choosenItems;
            }
 
            bool RecursiveF(List<Item> knapsackItems, List<Item> choosenItems, int i, int lastBound, bool dec, ref int indxToAdd)
            {
                if (!(lastBound < 0))
                {
                    if ( knapsackItems[i].ResultWV < choosenItems[lastBound].ResultWV )
                    {
                        indxToAdd = lastBound;
                    }
                    return RecursiveF(knapsackItems, choosenItems, i, lastBound - 1, true, ref indxToAdd);
                }
                if (indxToAdd > -1)
                {
                    choosenItems.Insert(indxToAdd, knapsackItems[i]);
                    return true;
                }
                return false;
            }
 
            #region IEnumerable<Item> Members
            IEnumerator<Item> IEnumerable<Item>.GetEnumerator()
            {
                foreach (Item i in items)
                    yield return i;
            }
            #endregion
 
            #region IEnumerable Members
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
            {
                return items.GetEnumerator();
            }
            #endregion
 
            public int TotalWeight
            {
                get
                {
                    var sum = 0;
                    foreach (Item i in this)
                    {
                        sum += i.Weight;
                    }
                    return sum;
                }
            }
 
            public class Item
            {
                public string Name { get; set; } public int Weight { get; set; } public int Value { get; set; } public int ResultWV { get { return  Weight-Value; } }
                public override string ToString()
                {
                    return ""Name : "" + Name + ""        Wieght : "" + Weight + ""       Value : "" + Value + ""     ResultWV : "" + ResultWV;
                }
            }
        }
 
    class Program
    {
        static void Main(string[] args)
        {List<Bag.Item> knapsackItems = new List<Bag.Item>();
            knapsackItems.Add(new Bag.Item() { Name = ""Map"", Weight = 9, Value = 150 });
            knapsackItems.Add(new Bag.Item() { Name = ""Water"", Weight = 153, Value = 200 });
            knapsackItems.Add(new Bag.Item() { Name = ""Compass"", Weight = 13, Value = 35 });
            knapsackItems.Add(new Bag.Item() { Name = ""Sandwitch"", Weight = 50, Value = 160 });
            knapsackItems.Add(new Bag.Item() { Name = ""Glucose"", Weight = 15, Value = 60 });
            knapsackItems.Add(new Bag.Item() { Name = ""Tin"", Weight = 68, Value = 45 });
            knapsackItems.Add(new Bag.Item() { Name = ""Banana"", Weight = 27, Value = 60 });
            knapsackItems.Add(new Bag.Item() { Name = ""Apple"", Weight = 39, Value = 40 });
            knapsackItems.Add(new Bag.Item() { Name = ""Cheese"", Weight = 23, Value = 30 });
            knapsackItems.Add(new Bag.Item() { Name = ""Beer"", Weight = 52, Value = 10 });
            knapsackItems.Add(new Bag.Item() { Name = ""Suntan Cream"", Weight = 11, Value = 70 });
            knapsackItems.Add(new Bag.Item() { Name = ""Camera"", Weight = 32, Value = 30 });
            knapsackItems.Add(new Bag.Item() { Name = ""T-shirt"", Weight = 24, Value = 15 });
            knapsackItems.Add(new Bag.Item() { Name = ""Trousers"", Weight = 48, Value = 10 });
            knapsackItems.Add(new Bag.Item() { Name = ""Umbrella"", Weight = 73, Value = 40 });
            knapsackItems.Add(new Bag.Item() { Name = ""WaterProof Trousers"", Weight = 42, Value = 70 });
            knapsackItems.Add(new Bag.Item() { Name = ""Note-Case"", Weight = 22, Value = 80 });
            knapsackItems.Add(new Bag.Item() { Name = ""Sunglasses"", Weight = 7, Value = 20 });
            knapsackItems.Add(new Bag.Item() { Name = ""Towel"", Weight = 18, Value = 12 });
            knapsackItems.Add(new Bag.Item() { Name = ""Socks"", Weight = 4, Value = 50 });
            knapsackItems.Add(new Bag.Item() { Name = ""Book"", Weight = 30, Value = 10 });
            knapsackItems.Add(new Bag.Item() { Name = ""waterproof overclothes "", Weight = 43, Value = 75 });
 
            Bag b = new Bag();
            b.Calculate(knapsackItems);
            b.All(x => { Console.WriteLine(x); return true; });
            Console.WriteLine(b.Sum(x => x.Weight));
            Console.ReadKey();
        }
    }
}",5800,142
43179,http://rosettacode.org/wiki/Kaprekar_numbers,Kaprekar numbers,"A positive integer is a Kaprekar number if:

 It is   1     (unity)
 The decimal representation of its square may be split once into two parts consisting of positive integers which sum to the original number. 

Note that a split resulting in a part consisting purely of 0s is not valid,
as 0 is not considered positive.



Example Kaprekar numbers

 



2223


{\displaystyle 2223}

 is a Kaprekar number, as 



2223
∗
2223
=
4941729


{\displaystyle 2223*2223=4941729}

, 



4941729


{\displaystyle 4941729}

 may be split to 



494


{\displaystyle 494}

 and 



1729


{\displaystyle 1729}

, and 



494
+
1729
=
2223


{\displaystyle 494+1729=2223}

.
 The series of Kaprekar numbers is known as A006886, and begins as 



1
,
9
,
45
,
55
,
.
.
.


{\displaystyle 1,9,45,55,...}

.


Example process

10000 (1002) splitting from left to right:

 The first split is [1, 0000], and is invalid; the 0000 element consists entirely of 0s, and 0 is not considered positive.
 Slight optimization opportunity: When splitting from left to right, once the right part consists entirely of 0s, no further testing is needed; all further splits would also be invalid.


Task

Generate and show all Kaprekar numbers less than 10,000.



Extra credit

Optionally, count (and report the count of) how many Kaprekar numbers are less than 1,000,000.



Extra extra credit

The concept of Kaprekar numbers is not limited to base 10 (i.e. decimal numbers);
if you can, show that Kaprekar numbers exist in other bases too.



For this purpose, do the following:

 Find all Kaprekar numbers for base 17 between 1 and 1,000,000 (one million);
 Display each of them in base 10 representation;
 Optionally, using base 17 representation (use letters 'a' to 'g' for digits 10(10) to 16(10)), display each of the numbers, its square, and where to split the square. 


225   d4  a52g  a5 + 2g


Reference

 The Kaprekar Numbers by Douglas E. Iannucci (2000). PDF version


Related task

   Casting out nines

",#C.23,C#,"using System;
using System.Collections.Generic;
 
public class KaprekarNumbers {
 
    /// <summary>
    /// The entry point of the program, where the program control starts and ends.
    /// </summary>
    public static void Main() {
        int count = 0;
 
        foreach ( ulong i in _kaprekarGenerator(999999) ) {
            Console.WriteLine(i);
            count++;
        }
 
        Console.WriteLine(""There are {0} Kaprekar numbers less than 1000000."", count);
    }
 
    /// <summary>
    /// Generator function which generates the Kaprekar numbers.
    /// </summary>
    /// <returns>The generator.</returns>
    /// <param name=""max"">The maximum value of the numbers generated.</param>
    private static IEnumerable<ulong> _kaprekarGenerator(ulong max) {
 
        ulong next = 1;
 
        // 1 is always a Kaprekar number.
        yield return next;
 
        for ( next = 2; next <= max; next++ ) {
 
            ulong square = next * next;
 
            for ( ulong check = 10; check <= 10000000000000000000; check *= 10 ) {
                // Check the square against each power of 10 from 10^1 to 10^19 (highest which can be
                // represented by a ulong)
 
                // If the power of 10 to be checked against is greater than or equal to the square, stop checking
                if ( square <= check )
                    break;
 
                // Given a power of 10 as 10^n, the remainder when dividing the square number by that power
                // of 10 is equal to the last n digits of the number (starting from the right) and the
                // quotient gives the remaining digits.
                // If the last n digits are all zeroes, then the remainder will be zero, which is not
                // accepted.
 
                ulong r = square % check;
                ulong q = (square - r) / check;
 
                if ( r != 0 && q + r == next ) {
                    yield return next;
                    break;
                }
            }
 
        }
 
    }
 
}",2039,63
43728,http://rosettacode.org/wiki/JortSort,JortSort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 Note:   jortSort is considered a work of satire.   It achieves its result in an intentionally roundabout way.   You are encouraged to write your solutions in the spirit of the original jortsort rather than trying to give the most concise or idiomatic solution.



JortSort is a sorting tool set that makes the user do the work and guarantees efficiency because you don't have to sort ever again.

It was originally presented by Jenn ""Moneydollars"" Schiffer at the
prestigious   JSConf.



JortSort is a function that takes a single array of comparable objects as its argument.

It then sorts the array in ascending order and compares the sorted array to the originally provided array.

If the arrays match   (i.e. the original array was already sorted),   the function returns   true.

If the arrays do not match (i.e. the original array was not sorted), the function returns   false.



",#C.23,C#,"using System;
 
class Program
{
  public static bool JortSort<T>(T[] array) where T : IComparable, IEquatable<T>
  {
    // sort the array
    T[] originalArray = (T[]) array.Clone();
    Array.Sort(array);
 
    // compare to see if it was originally sorted
    for (var i = 0; i < originalArray.Length; i++)
    {
      if (!Equals(originalArray[i], array[i]))
      {
        return false;
      }
    }
 
    return true;
  }
}",431,22
43742,http://rosettacode.org/wiki/Jensen%27s_Device,Jensen's Device,"Jensen's Device

You are encouraged to solve this task according to the task description, using any language you may know.
This task is an exercise in call by name.

Jensen's Device is a computer programming technique devised by Danish computer scientist Jørn Jensen after studying the ALGOL 60 Report.

The following program was proposed to illustrate the technique. It computes the 100th harmonic number:

begin
   integer i;
   real procedure sum (i, lo, hi, term);
      value lo, hi;
      integer i, lo, hi;
      real term;
      comment term is passed by-name, and so is i;
   begin
      real temp;
      temp := 0;
      for i := lo step 1 until hi do
         temp := temp + term;
      sum := temp
   end;
   comment note the correspondence between the mathematical notation and the call to sum;
   print (sum (i, 1, 100, 1/i))
end

The above exploits call by name to produce the correct answer (5.187...). It depends on the assumption that an expression passed as an actual parameter to a procedure would be re-evaluated in the caller's context every time the corresponding formal parameter's value was required. If the last parameter to sum had been passed by value, and assuming the initial value of i were 1, the result would have been 100 × 1/1 = 100.

Moreover, the first parameter to sum, representing the ""bound"" variable of the summation, must also be passed by name (or at least by reference), otherwise changes to it (made within sum) would not be visible in the caller's context when computing each of the values to be added.
(On the other hand, the global variable does not have to use the same identifier, in this case i, as the formal parameter.)

Donald Knuth later proposed the Man or Boy Test as a more rigorous exercise.



",#C.23,C#,"using System;
 
class JensensDevice
{    
    public static double Sum(ref int i, int lo, int hi, Func<double> term)
    {
        double temp = 0.0;
        for (i = lo; i <= hi; i++)
        {
            temp += term();
        }
        return temp;
    }
 
    static void Main()
    {
        int i = 0;
        Console.WriteLine(Sum(ref i, 1, 100, () => 1.0 / i));
    }
}",379,20
43770,http://rosettacode.org/wiki/Jewels_and_stones,Jewels and stones,"Jewels and stones

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a function which takes two string parameters: 'stones' and 'jewels' and returns an integer.

Both strings can contain any number of upper or lower case letters. However, in the case of 'jewels', all letters must be distinct.

The function should count (and return) how many 'stones' are 'jewels' or, in other words, how many letters in 'stones' are also letters in 'jewels'.



Note that:

 Only letters in the ISO basic Latin alphabet i.e. 'A to Z' or 'a to z' need be considered. 
 A lower case letter is considered to be different from its upper case equivalent for this purpose, i.e., 'a' != 'A'.
 The parameters do not need to have exactly the same names.
 Validating the arguments is unnecessary. 
So, for example, if passed ""aAAbbbb"" for 'stones' and ""aA"" for 'jewels', the function should return 3.

This task was inspired by this problem.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.Linq;
 
public class Program
{
    public static void Main() {
        Console.WriteLine(Count(""aAAbbbb"", ""Aa""));
        Console.WriteLine(Count(""ZZ"", ""z""));
    }
 
    private static int Count(string stones, string jewels) {
        var bag = jewels.ToHashSet();
        return stones.Count(bag.Contains);
    }
}",343,15
44119,http://rosettacode.org/wiki/Josephus_problem,Josephus problem,"Josephus problem is a math puzzle with a grim description: 



n


{\displaystyle n}

 prisoners are standing on a circle, sequentially numbered from 



0


{\displaystyle 0}

 to 



n
−
1


{\displaystyle n-1}

.

An executioner walks along the circle, starting from prisoner 



0


{\displaystyle 0}

,
removing every 



k


{\displaystyle k}

-th prisoner and killing him.

As the process goes on, the circle becomes smaller and smaller, until only one prisoner remains, who is then freed. >

For example, if there are 



n
=
5


{\displaystyle n=5}

 prisoners and 



k
=
2


{\displaystyle k=2}

, the order the prisoners are killed in (let's call it the ""killing sequence"") will be 1, 3, 0, and 4, and the survivor will be #2.



Task

Given any   



n
,
k
>
0


{\displaystyle n,k>0}

,   find out which prisoner will be the final survivor.

In one such incident, there were 41 prisoners and every 3rd prisoner was being killed   (



k
=
3


{\displaystyle k=3}

).

Among them was a clever chap name Josephus who worked out the problem, stood at the surviving position, and lived on to tell the tale.

Which number was he?



Extra

The captors may be especially kind and let 



m


{\displaystyle m}

 survivors free,

and Josephus might just have   



m
−
1


{\displaystyle m-1}

   friends to save.

Provide a way to calculate which prisoner is at any given position on the killing sequence.



Notes

 You can always play the executioner and follow the procedure exactly as described, walking around the circle, counting (and cutting off) heads along the way. This would yield the complete killing sequence and answer the above questions, with a complexity of probably 



O
(
k
n
)


{\displaystyle O(kn)}

. However, individually it takes no more than 



O
(
m
)


{\displaystyle O(m)}

 to find out which prisoner is the 



m


{\displaystyle m}

-th to die.
 If it's more convenient, you can number prisoners from   



1


{\displaystyle 1}

 to 



n


{\displaystyle n}

   instead.   If you choose to do so, please state it clearly.
 An alternative description has the people committing assisted suicide instead of being executed, and the last person simply walks away. These details are not relevant, at least not mathematically.

",#C.23,C#," 
namespace Josephus
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
 
    public class Program
    {
        public static int[] JosephusProblem(int n, int m)
        {
            var circle = new List<int>();
            var order = new int[n];
 
            for (var i = 0; i < n; ++i)
            {
                circle.Add(i);
            }
 
            var l = 0;
            var j = 0;
            var k = 0;
 
            while (circle.Count != 0)
            {
                j++;
                if (j == m)
                {
                    order[k] = circle[l];
                    circle.RemoveAt(l);
 
                    k++;
                    l--;
                    j = 0;
                }
 
                if (k == n - 1)
                {
                    order[k] = circle[0];
                    circle.RemoveAt(0);
                }
 
                if (l == circle.Count - 1)
                {
                    l = 0;
                }
                else
                {
                    l++;
                }
            }
 
            return order;
        }
 
        static void Main(string[] args)
        {
            try
            {
                var n = 7;
                var m = 2;
 
                var result = JosephusProblem(n, m);
 
               for (var i = 0; i < result.Length; i++)
               {
                   Console.WriteLine(result[i]);//1 3 5 0 4 2 6
               }
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
            }
            finally
            {
                Console.ReadLine();
            }
        }
 
    }
}
 ",1716,82
44134,http://rosettacode.org/wiki/Iterated_digits_squaring,Iterated digits squaring,"If you add the square of the digits of a Natural number (an integer bigger than zero), you always end with either 1 or 89:

15 -> 26 -> 40 -> 16 -> 37 -> 58 -> 89
7 -> 49 -> 97 -> 130 -> 10 -> 1
An example in Python:

>>> step = lambda x: sum(int(d) ** 2 for d in str(x))
>>> iterate = lambda x: x if x in [1, 89] else iterate(step(x))
>>> [iterate(x) for x in xrange(1, 20)]
[1, 89, 89, 89, 89, 89, 1, 89, 89, 1, 89, 89, 1, 89, 89, 89, 89, 89, 1]


Task

 Count how many number chains for integers 1 <= n < 100_000_000 end with a value 89.
Or, for much less credit - (showing that your algorithm and/or language is slow):

 Count how many number chains for integers 1 <= n < 1_000_000 end with a value 89.
This problem derives from the Project Euler problem 92.

For a quick algorithm for this task see the talk page



Related tasks

 Combinations with repetitions
 Digital root
 Digital root/Multiplicative digital root

",#C.23,C#,"using System;
public static class IteratedDigitsSquaring
{
    public static void Main() {
        Console.WriteLine(Count89s(1_000_000));
        Console.WriteLine(Count89s(100_000_000));
    }
 
    public static int Count89s(int limit) {
        if (limit < 1) return 0;
        int[] end = new int[Math.Min(limit, 9 * 9 * 9 + 2)];
        int result = 0;
 
        for (int i = 1; i < end.Length; i++) {
            for (end[i] = i; end[i] != 1 && end[i] != 89; end[i] = SquareDigitSum(end[i])) { }
            if (end[i] == 89) result++;
        }
        for (int i = end.Length; i < limit; i++) {
            if (end[SquareDigitSum(i)] == 89) result++;
        }
        return result;
 
        int SquareDigitSum(int n) {
            int sum = 0;
            while (n > 0) {
                int digit = n % 10;
                sum += digit * digit;
                n /= 10;
            }
            return sum;
        }
    }
 
}",940,34
44151,http://rosettacode.org/wiki/ISBN13_check_digit,ISBN13 check digit,"Task

Validate the check digit of an ISBN-13 code:

   Multiply every other digit by  3.
   Add these numbers and the other digits.
   Take the remainder of this number after division by  10.
   If it is  0,   the ISBN-13 check digit is correct.


Use the following codes for testing:

   978-1734314502       (good)
   978-1734314509         (bad)
   978-1788399081       (good)
   978-1788399083         (bad)


Show output here, on this page



See also

   for details:   13-digit ISBN method of validation.       (installs cookies.)

",#C.23,C#,"using System;
using System.Linq;
 
public class Program
{
    public static void Main() {
        Console.WriteLine(CheckISBN13(""978-1734314502""));
        Console.WriteLine(CheckISBN13(""978-1734314509""));
        Console.WriteLine(CheckISBN13(""978-1788399081""));
        Console.WriteLine(CheckISBN13(""978-1788399083""));
 
        static bool CheckISBN13(string code) {
            code = code.Replace(""-"", """").Replace("" "", """");
            if (code.Length != 13) return false;
            int sum = 0;
            foreach (var (index, digit) in code.Select((digit, index) => (index, digit))) {
                if (char.IsDigit(digit)) sum += (digit - '0') * (index % 2 == 0 ? 1 : 3);
                else return false;
            }
            return sum % 10 == 0;
        }
    }
}",786,23
44175,http://rosettacode.org/wiki/Isqrt_(integer_square_root)_of_X,Isqrt (integer square root) of X,"Sometimes a function is needed to find the integer square root of   X,   where   X   can be a
real non─negative number.

Often   X   is actually a non─negative integer.

For the purposes of this task,   X   can be an integer or a real number,   but if it
simplifies things in your computer programming language,   assume it's an integer.



One of the most common uses of   Isqrt   is in the division of an integer by all factors   (or
primes)   up to the   
√ X     of that
integer,   either to find the factors of that integer,   or to determine primality.



An alternative method for finding the   Isqrt   of a number is to
calculate:        floor( sqrt(X) ) 

   where   sqrt    is the   square root   function for non─negative real numbers,   and
   where   floor   is the   floor   function for real numbers.


If the hardware supports the computation of (real) square roots,   the above method might be a faster method for
small numbers that don't have very many significant (decimal) digits.

However, floating point arithmetic is limited in the number of   (binary or decimal)   digits that it can support.



Pseudo─code using quadratic residue

For this task, the integer square root of a non─negative number will be computed using a version
of   quadratic residue,   which has the advantage that no   floating point   calculations are
used,   only integer arithmetic.

Furthermore, the two divisions can be performed by bit shifting,   and the one multiplication can also be be performed by bit shifting or additions.

The disadvantage is the limitation of the size of the largest integer that a particular computer programming language can support.



Pseudo─code of a procedure for finding the integer square root of   X       (all variables are integers):

         q ◄── 1                                /*initialize  Q  to unity.  */
                                  /*find a power of 4 that's greater than X.*/
                  perform  while q <= x         /*perform while  Q <= X.    */
                  q ◄── q * 4                   /*multiply  Q  by  four.    */
                  end  /*perform*/
                                                /*Q  is now greater than  X.*/
         z ◄── x                                /*set  Z  to the value of X.*/
         r ◄── 0                                /*initialize  R  to zero.   */
                  perform  while q > 1          /*perform while  Q > unity. */
                  q ◄── q ÷ 4                   /*integer divide by  four.  */
                  t ◄── z - r - q               /*compute value of  T.      */
                  r ◄── r ÷ 2                   /*integer divide by  two.   */
                  if t >= 0  then do            
                                  z ◄── t       /*set  Z  to value of  T.   */
                                  r ◄── r + q   /*compute new value of  R.  */
                                  end
                  end  /*perform*/
                                                /*R  is now the  Isqrt(X).  */

         /* Sidenote: Also, Z is now the remainder after square root (i.e.  */
         /*           R^2 + Z = X, so if Z = 0 then X is a perfect square). */

Another version for the (above)   1st   perform   is:

                  perform  until q > X          /*perform until  Q > X.     */
                  q ◄── q * 4                   /*multiply  Q  by  four.    */
                  end  /*perform*/



Integer square roots of some values:

Isqrt( 0)  is   0               Isqrt(60)  is  7                Isqrt( 99)  is   9
Isqrt( 1)  is   1               Isqrt(61)  is  7                Isqrt(100)  is  10
Isqrt( 2)  is   1               Isqrt(62)  is  7                Isqrt(102)  is  10
Isqrt( 3)  is   1               Isqrt(63)  is  7
Isqrt( 4)  is   2               Isqrt(64)  is  8                Isqet(120)  is  10
Isqrt( 5)  is   2               Isqrt(65)  is  8                Isqrt(121)  is  11
Isqrt( 6)  is   2               Isqrt(66)  is  8                Isqrt(122)  is  11
Isqrt( 7)  is   2               Isqrt(67)  is  8
Isqrt( 8)  is   2               Isqrt(68)  is  8                Isqrt(143)  is  11
Isqrt( 9)  is   3               Isqrt(69)  is  8                Isqrt(144)  is  12
Isqrt(10)  is   3               Isqrt(70)  is  8                Isqrt(145)  is  12



Task

Compute and show all output here   (on this page)   for:

   the Isqrt of the     integers     from     0 ───► 65    (inclusive), shown in a horizontal format.
   the Isqrt of the   odd powers  from   71 ───► 773   (inclusive), shown in a   vertical   format.
   use commas in the displaying of larger numbers.


You can show more numbers for the 2nd requirement if the displays fits on one screen on Rosetta Code.

If your computer programming language only supports smaller integers,   show what you can.



Related tasks

   sequence of non-squares
   integer roots
   square root by hand

",#C.23,C#,"using System;
using static System.Console;
using BI = System.Numerics.BigInteger;
 
class Program {
 
    static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {
        q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }
 
    static void Main() { const int max = 73, smax = 65;
        int power_width = ((BI.Pow(7, max).ToString().Length / 3) << 2) + 3,
            isqrt_width = (power_width + 1) >> 1;
        WriteLine(""Integer square root for numbers 0 to {0}:"", smax);
        for (int n = 0; n <= smax; ++n) Write(""{0} "", 
            (n / 10).ToString().Replace(""0"", "" "")); WriteLine();
        for (int n = 0; n <= smax; ++n) Write(""{0} "", n % 10); WriteLine();
        WriteLine(new String('-', (smax << 1) + 1));
        for (int n = 0; n <= smax; ++n) Write(""{0} "", isqrt(n));
        WriteLine(""\n\nInteger square roots of odd powers of 7 from 1 to {0}:"", max);
        string s = string.Format(""[0,2] |[1,{0}:n0] |[2,{1}:n0]"",
            power_width, isqrt_width).Replace(""["", ""{"").Replace(""]"", ""}"");
        WriteLine(s, ""n"", ""7 ^ n"", ""isqrt(7 ^ n)"");
        WriteLine(new String('-', power_width + isqrt_width + 6));
        BI p = 7; for (int n = 1; n <= max; n += 2, p *= 49)
            WriteLine (s, n, p, isqrt(p)); }
}",1298,26
44214,http://rosettacode.org/wiki/Intersecting_number_wheels,Intersecting number wheels,"A number wheel has:

 A name which is an uppercase letter.
 A set of ordered values which are either numbers or names.

A number is generated/yielded from a named wheel by:

1. Starting at the first value of the named wheel and advancing through subsequent values and wrapping around to the first value to form a ""wheel"":
1.a If the value is a number, yield it.
1.b If the value is a name, yield the next value from the named wheel
1.c Advance the position of this wheel.
Given the wheel

 A: 1 2 3
the number 1 is first generated, then 2, then 3, 1, 2, 3, 1, ...

Note: When more than one wheel is defined as a set of intersecting wheels then the
first named wheel is assumed to be the one that values are generated from.

Examples

Given the wheels:

   A: 1 B 2
   B: 3 4

The series of numbers generated starts:

   1, 3, 2, 1, 4, 2, 1, 3, 2, 1, 4, 2, 1, 3, 2...

The intersections of number wheels can be more complex, (and might loop forever),
and wheels may be multiply connected. 


Note: If a named wheel is referenced more than
once by one or many other wheels, then there is only one position of the wheel
that is advanced by each and all references to it.

E.g.

 A:  1 D D
 D:  6 7 8
 Generates:
   1 6 7 1 8 6 1 7 8 1 6 7 1 8 6 1 7 8 1 6 ...    

Task

Generate and show the first twenty terms of the sequence of numbers generated
from these groups:

   Intersecting Number Wheel group:
     A:  1 2 3
   
   Intersecting Number Wheel group:
     A:  1 B 2
     B:  3 4
   
   Intersecting Number Wheel group:
     A:  1 D D
     D:  6 7 8
   
   Intersecting Number Wheel group:
     A:  1 B C
     B:  3 4
     C:  5 B

Show your output here, on this page.


",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
public static class IntersectingNumberWheels
{
    public static void Main() {
        TurnWheels(('A', ""123"")).Take(20).Print();
        TurnWheels(('A', ""1B2""), ('B', ""34"")).Take(20).Print();
        TurnWheels(('A', ""1DD""), ('D', ""678"")).Take(20).Print();
        TurnWheels(('A', ""1BC""), ('B', ""34""), ('C', ""5B"")).Take(20).Print();
    }
 
    static IEnumerable<char> TurnWheels(params (char name, string values)[] wheels) {
        var data = wheels.ToDictionary(wheel => wheel.name, wheel => wheel.values.Loop().GetEnumerator());
        var primary = data[wheels[0].name];
        while (true) {
            yield return Turn(primary);
        }
 
        char Turn(IEnumerator<char> sequence) {
            sequence.MoveNext();
            char c = sequence.Current;
            return char.IsDigit(c) ? c : Turn(data[c]);
        }
    }
 
    static IEnumerable<T> Loop<T>(this IEnumerable<T> seq) {
        while (true) {
            foreach (T element in seq) yield return element;
        }
    }
 
    static void Print(this IEnumerable<char> sequence) => Console.WriteLine(string.Join("" "", sequence));
}",1188,35
44226,http://rosettacode.org/wiki/Interactive_programming_(repl),Interactive programming (repl),"Many language implementations come with an interactive mode.

This is a command-line interpreter that reads lines from the user and evaluates these lines as statements or expressions.

An interactive mode may also be known as a command mode,   a read-eval-print loop (REPL),   or a shell.



Task

Show how to start this mode.

Then, as a small example of its use, interactively create a function of two strings and a separator that returns the strings separated by two concatenated instances of the separator   (the 3rd argument).



Example

             f('Rosetta',  'Code',  ':')   

should return

             'Rosetta::Code'               



Note

This task is   not   about creating your own interactive mode.



",#C.23,C#,"**********************************************************************
** Visual Studio 2017 Developer Command Prompt v15.9.14
** Copyright (c) 2017 Microsoft Corporation
**********************************************************************

C:\Program Files (x86)\Microsoft Visual Studio\2017\Community>csi /?
Microsoft (R) Visual C# Interactive Compiler version 2.10.0.0
Copyright (C) Microsoft Corporation. All rights reserved.

Usage: csi [option] ... [script-file.csx] [script-argument] ...

Executes script-file.csx if specified, otherwise launches an interactive REPL (Read Eval Print Loop).

Options:
  /help                          Display this usage message (alternative form: /?)
  /version                       Display the version and exit
  /i                             Drop to REPL after executing the specified script.
  /r:<file>                      Reference metadata from the specified assembly file (alternative form: /reference)
  /r:<file list>                 Reference metadata from the specified assembly files (alternative form: /reference)
  /lib:<path list>               List of directories where to look for libraries specified by #r directive.
                                 (alternative forms: /libPath /libPaths)
  /u:<namespace>                 Define global namespace using (alternative forms: /using, /usings, /import, /imports)
  @<file>                        Read response file for more options
  --                             Indicates that the remaining arguments should not be treated as options.",1546,24
44282,http://rosettacode.org/wiki/Introspection,Introspection,"Task

 verify the version/revision of your currently running (compiler/interpreter/byte-compiler/runtime environment/whatever your language uses) and exit if it is too old.
 check whether the variable ""bloop"" exists and whether the math-function ""abs()"" is available and if yes compute abs(bloop).


Extra credit

 Report the number of integer variables in global scope, and their sum.

",#C.23,C#,"using System;
using System.Reflection;
 
namespace Rosetta_Introspection
{
	static public class Program
	{
		static public int bloop = -10;
		static public int bloop2 = -20;
 
		public static void Main()
		{
			var asm = Assembly.GetExecutingAssembly();
			var version = int.Parse(asm.ImageRuntimeVersion.Split('.')[0].Substring(1));
			if (version < 4)
			{
				Console.WriteLine(""Get with the program!  I'm outta here!"");
				return;
			}
 
			FieldInfo bloopField = null;
 
			foreach (var type in asm.GetExportedTypes())
			{
				foreach (var field in type.GetFields())
				{
					if (field.Name != ""bloop"")
					{
						continue;
					}
					bloopField = field;
					if (bloopField.FieldType != typeof(int))
					{
						throw new InvalidProgramException(""bloop should be an integer"");
					}
					break;
				}
				if (bloopField != null)
				{
					break;
				}
			}
 
			if (bloopField == null)
			{
				throw new InvalidProgramException(""No bloop exported value"");
			}
			foreach (var refAsm in AppDomain.CurrentDomain.GetAssemblies())
			{
				foreach (var type in refAsm.GetExportedTypes())
				{
					if (type.Name == ""Math"")
					{
						var absMethod = type.GetMethod(""Abs"", new Type[] { typeof(int) });
						if (absMethod != null)
						{
							Console.WriteLine(""bloop's abs value = {0}"", absMethod.Invoke(null, new object[] { bloopField.GetValue(null) }));
						}
					}
				}
			}
 
			int intCount = 0;
			int total = 0;
 
			foreach (var type in asm.GetExportedTypes())
			{
				foreach (var field in type.GetFields())
				{
					if (field.FieldType == typeof(int))
					{
						intCount++;
						total += (int)field.GetValue(null);
					}
				}
			}
			Console.WriteLine(""{0} exported ints which total to {1}"", intCount, total);
			Console.ReadKey();
		}
	}
}
 ",1785,82
44295,http://rosettacode.org/wiki/Inverted_index,Inverted index,"An Inverted Index is a data structure used to create full text search.



Task

Given a set of text files, implement a program to create an inverted index.

Also create a user interface to do a search using that inverted index which returns a list of files that contain the query term / terms.

The search index can be in memory.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
 
class InvertedIndex
{
    static Dictionary<TItem, IEnumerable<TKey>> Invert<TKey, TItem>(Dictionary<TKey, IEnumerable<TItem>> dictionary)
    {
        return dictionary
            .SelectMany(keyValuePair => keyValuePair.Value.Select(item => new KeyValuePair<TItem, TKey>(item, keyValuePair.Key)))
            .GroupBy(keyValuePair => keyValuePair.Key)
            .ToDictionary(group => group.Key, group => group.Select(keyValuePair => keyValuePair.Value));
    }
 
    static void Main()
    {
        Console.Write(""files: "");
        var files = Console.ReadLine();
        Console.Write(""find: "");
        var find = Console.ReadLine();
        var dictionary = files.Split().ToDictionary(file => file, file => File.ReadAllText(file).Split().AsEnumerable());
        Console.WriteLine(""{0} found in: {1}"", find, string.Join("" "", Invert(dictionary)[find]));
    }
}",958,25
44360,http://rosettacode.org/wiki/Integer_overflow,Integer overflow,"Some languages support one or more integer types of the underlying processor.

This integer types have fixed size;   usually   8-bit,   16-bit,   32-bit,   or   64-bit.

The integers supported by such a type can be   signed   or   unsigned.

Arithmetic for machine level integers can often be done by single CPU instructions.

This allows high performance and is the main reason to support machine level integers.



Definition

An integer overflow happens when the result of a computation does not fit into the fixed size integer.
The result can be too small or too big to be representable in the fixed size integer.



Task

When a language has fixed size integer types, create a program that
does arithmetic computations for the fixed size integers of the language.

These computations must be done such that the result would overflow.

The program should demonstrate what the following expressions do.



For 32-bit signed integers:



Expression

Result that does not fit into a 32-bit signed integer


 -(-2147483647-1)

 2147483648


 2000000000 + 2000000000

 4000000000


 -2147483647 - 2147483647

 -4294967294


 46341 * 46341

 2147488281


 (-2147483647-1) / -1

 2147483648

For 64-bit signed integers:



Expression

Result that does not fit into a 64-bit signed integer


 -(-9223372036854775807-1)

 9223372036854775808


 5000000000000000000+5000000000000000000

 10000000000000000000


 -9223372036854775807 - 9223372036854775807

 -18446744073709551614


 3037000500 * 3037000500

 9223372037000250000


 (-9223372036854775807-1) / -1

 9223372036854775808

For 32-bit unsigned integers:



Expression

Result that does not fit into a 32-bit unsigned integer


 -4294967295

 -4294967295


 3000000000 + 3000000000

 6000000000


 2147483647 - 4294967295

 -2147483648


 65537 * 65537

 4295098369

For 64-bit unsigned integers:



Expression

Result that does not fit into a 64-bit unsigned integer


 -18446744073709551615

 -18446744073709551615


 10000000000000000000 + 10000000000000000000

 20000000000000000000


 9223372036854775807 - 18446744073709551615

 -9223372036854775808


 4294967296 * 4294967296

 18446744073709551616



Notes

   When the integer overflow does trigger an exception show how the exception is caught.
   When the integer overflow produces some value,   print it.
   It should be explicitly noted when an integer overflow is not recognized,   the program continues with wrong results.
   This should be done for signed and unsigned integers of various sizes supported by the computer programming language.
   When a language has no fixed size integer type,   or when no integer overflow can occur for other reasons,   this should be noted.
   It is okay to mention,   when a language supports unlimited precision integers,   but this task is NOT the place to demonstrate the 
  capabilities of unlimited precision integers.

",#C.23,C#,"using System;
 
public class IntegerOverflow
{
    public static void Main() {
        unchecked {
            Console.WriteLine(""For 32-bit signed integers:"");
            Console.WriteLine(-(-2147483647 - 1));
            Console.WriteLine(2000000000 + 2000000000);
            Console.WriteLine(-2147483647 - 2147483647);
            Console.WriteLine(46341 * 46341);
            Console.WriteLine((-2147483647 - 1) / -1);
            Console.WriteLine();
 
            Console.WriteLine(""For 64-bit signed integers:"");
            Console.WriteLine(-(-9223372036854775807L - 1));
            Console.WriteLine(5000000000000000000L + 5000000000000000000L);
            Console.WriteLine(-9223372036854775807L - 9223372036854775807L);
            Console.WriteLine(3037000500L * 3037000500L);
            Console.WriteLine((-9223372036854775807L - 1) / -1);
            Console.WriteLine();
 
            Console.WriteLine(""For 32-bit unsigned integers:"");
            //Negating a 32-bit unsigned integer will convert it to a signed 64-bit integer.
            Console.WriteLine(-4294967295U);
            Console.WriteLine(3000000000U + 3000000000U);
            Console.WriteLine(2147483647U - 4294967295U);
            Console.WriteLine(65537U * 65537U);
            Console.WriteLine();
 
            Console.WriteLine(""For 64-bit unsigned integers:"");
            // The - operator cannot be applied to 64-bit unsigned integers; it will always give a compile-time error.
            //Console.WriteLine(-18446744073709551615UL);
            Console.WriteLine(10000000000000000000UL + 10000000000000000000UL);
            Console.WriteLine(9223372036854775807UL - 18446744073709551615UL);
            Console.WriteLine(4294967296UL * 4294967296UL);
            Console.WriteLine();
        }
 
        int i = 2147483647;
        Console.WriteLine(i + 1);
        try {
            checked { Console.WriteLine(i + 1); }
        } catch (OverflowException) {
            Console.WriteLine(""Overflow!"");
        }
    }
 
}",2028,49
44382,http://rosettacode.org/wiki/Inheritance/Multiple,Inheritance/Multiple,"Multiple inheritance allows to specify that one  class is a subclass of several other classes.

Some languages allow multiple inheritance for arbitrary classes,   others restrict it to interfaces,   some don't allow it at all.



Task

Write two classes (or interfaces) Camera and MobilePhone,   then write a class CameraPhone which is both a Camera and a MobilePhone.

There is no need to implement any functions for those classes.



",#C.23,C#,"interface ICamera {
    // ...
}
 
class MobilePhone {
    // ...
}
 
class CameraPhone: ICamera, MobilePhone {
    // ...
}",124,11
44498,http://rosettacode.org/wiki/Inheritance/Single,Inheritance/Single," This task is about derived types;   for implementation inheritance, see Polymorphism.


Inheritance is an operation of type algebra that creates a new type from one or several parent types.

The obtained type is called derived type.

It inherits some of the properties of its parent types.

Usually inherited properties are:

   methods
   components
   parts of the representation


The  class of the new type is a   subclass   of the classes rooted in the parent types.

When all (in certain sense) properties of the parents are preserved by the derived type,   it is said to be a Liskov subtype.

When properties are preserved then the derived type is substitutable for its parents in all contexts.   Usually full substitutability is achievable only in some contexts.



Inheritance is

   single, when only one parent is allowed
    multiple, otherwise


Some single inheritance languages usually allow multiple inheritance for certain abstract types, interfaces in particular.

Inheritance can be considered as a relation parent-child.

Parent types are sometimes called supertype, the derived ones are subtype.   This relation is transitive and reflexive.

Types bound by the relation form a wp:Directed_acyclic_graph directed acyclic graph (ignoring reflexivity).

With single inheritance it becomes a tree.



Task

Show a tree of types which inherit from each other.

   At the top of the tree should be a class called   Animal. 
   The second level should have Dog and Cat. 
   Under   Dog   should be   Lab   and   Collie. 
   None of the classes need to have any functions,   the only thing they need to do is inherit from the specified superclasses 
   (overriding functions should be shown in Polymorphism). 


The tree should look like this:

                        Animal
                          /\
                         /  \
                        /    \
                      Dog    Cat
                      /\
                     /  \
                    /    \
                  Lab  Collie


",#C.23,C#,"class Animal
{ 
  /* ... */ 
  // ...
}
 
class Dog : Animal
{ 
  /* ... */ 
  // ...
}
 
class Lab : Dog
{ 
  /* ... */ 
  // ...
}
 
class Collie : Dog
{ 
  /* ... */
  // ... 
}
 
class Cat : Animal
{ 
  /* ... */
  // ... 
}",228,29
44538,http://rosettacode.org/wiki/Input_loop,Input loop,"Input loop is part of Short Circuit's Console Program Basics selection.
Task

Read from a text stream either word-by-word or line-by-line until the stream runs out of data.

The stream will have an unknown amount of data on it.



",#C.23,C#,"using System;
using System.IO;
 
class Program
{
    static void Main(string[] args)
    {
        // For stdin, you could use
        // new StreamReader(Console.OpenStandardInput(), Console.InputEncoding)
 
        using (var b = new StreamReader(""file.txt""))
        {
            string line;
            while ((line = b.ReadLine()) != null)
                Console.WriteLine(line);
        }
    }
}",405,18
44562,http://rosettacode.org/wiki/Integer_sequence,Integer sequence,"Task

Create a program that, when run, would display all integers from   1   to      ∞      (or any relevant implementation limit),   in sequence   (i.e.   1, 2, 3, 4, etc)   if given enough time.



An example may not be able to reach arbitrarily-large numbers based on implementations limits.   For example, if integers are represented as a 32-bit unsigned value with 0 as the smallest representable value, the largest representable value would be 4,294,967,295.   Some languages support arbitrarily-large numbers as a built-in feature, while others make use of a module or library.

If appropriate, provide an example which reflect the language implementation's common built-in limits as well as an example which supports arbitrarily large numbers, and describe the nature of such limitations—or lack thereof.



",#C.23,C#,"using System;
using System.Numerics;
 
class Program
{
    static void Main()
    {
        BigInteger i = 1;
        while (true)
        {
            Console.WriteLine(i++);
        }
    }
}",194,14
44629,http://rosettacode.org/wiki/Infinity,Infinity,"Task

Write a function which tests if infinity is supported for floating point numbers (this step should be omitted for languages where the language specification already demands the existence of infinity, e.g. by demanding IEEE numbers), and if so, returns positive infinity.   Otherwise, return the largest possible positive floating point number.

For languages with several floating point types, use the type of the literal constant   1.5   as floating point type.



Related task

   Extreme floating point values

",#C.23,C#,"using System;
 
class Program
{
    static double PositiveInfinity()
    {
        return double.PositiveInfinity;
    }
 
    static void Main()
    {
        Console.WriteLine(PositiveInfinity());
    }
}",206,14
44849,http://rosettacode.org/wiki/Imaginary_base_numbers,Imaginary base numbers,"Imaginary base numbers are a non-standard positional numeral system which uses an imaginary number as its radix. The most common is quater-imaginary with radix 2i.

The quater-imaginary numeral system was first proposed by Donald Knuth in 1955 as a submission for a high school science talent search. [Ref.]

Other imaginary bases are possible too but are not as widely discussed and aren't specifically named.

Task: Write a set of procedures (functions, subroutines, however they are referred to in your language) to convert base 10 numbers to an imaginary base and back.

At a minimum, support quater-imaginary (base 2i).

For extra kudos, support positive or negative bases 2i through 6i (or higher).

As a stretch goal, support converting non-integer numbers ( E.G. 227.65625+10.859375i ) to an imaginary base.

See Wikipedia: Quater-imaginary_base for more details.

For reference, here are some some decimal and complex numbers converted to quater-imaginary.






Base 10
Base 2i


1
 1


2
 2


3
 3


4
 10300


5
 10301


6
 10302


7
 10303


8
 10200


9
 10201


10
 10202


11
 10203


12
 10100


13
 10101


14
 10102


15
 10103


16
 10000






Base 10
Base 2i


−1
 103


−2
 102


−3
 101


−4
 100


−5
 203


−6
 202


−7
 201


−8
 200


−9
 303


−10
 302


−11
 301


−12
 300


−13
 1030003


−14
 1030002


−15
 1030001


−16
 1030000






Base 10
Base 2i


1i
10.2


2i
10.0


3i
20.2


4i
20.0


5i
30.2


6i
30.0


7i
103000.2


8i
103000.0


9i
103010.2


10i
103010.0


11i
103020.2


12i
103020.0


13i
103030.2


14i
103030.0


15i
102000.2


16i
102000.0






Base 10
Base 2i


−1i
0.2


−2i
1030.0


−3i
1030.2


−4i
1020.0


−5i
1020.2


−6i
1010.0


−7i
1010.2


−8i
1000.0


−9i
1000.2


−10i
2030.0


−11i
2030.2


−12i
2020.0


−13i
2020.2


−14i
2010.0


−15i
2010.2


−16i
2000.0




",#C.23,C#,"using System;
using System.Linq;
using System.Text;
 
namespace ImaginaryBaseNumbers {
    class Complex {
        private double real, imag;
 
        public Complex(int r, int i) {
            real = r;
            imag = i;
        }
 
        public Complex(double r, double i) {
            real = r;
            imag = i;
        }
 
        public static Complex operator -(Complex self) =>
            new Complex(-self.real, -self.imag);
 
        public static Complex operator +(Complex rhs, Complex lhs) =>
            new Complex(rhs.real + lhs.real, rhs.imag + lhs.imag);
 
        public static Complex operator -(Complex rhs, Complex lhs) =>
            new Complex(rhs.real - lhs.real, rhs.imag - lhs.imag);
 
        public static Complex operator *(Complex rhs, Complex lhs) =>
            new Complex(
                rhs.real * lhs.real - rhs.imag * lhs.imag,
                rhs.real * lhs.imag + rhs.imag * lhs.real
                );
 
        public static Complex operator *(Complex rhs, double lhs) =>
             new Complex(rhs.real * lhs, rhs.imag * lhs);
 
        public static Complex operator /(Complex rhs, Complex lhs) =>
            rhs * lhs.Inv();
 
        public Complex Inv() {
            double denom = real * real + imag * imag;
            return new Complex(real / denom, -imag / denom);
        }
 
        public QuaterImaginary ToQuaterImaginary() {
            if (real == 0.0 && imag == 0.0) return new QuaterImaginary(""0"");
            int re = (int)real;
            int im = (int)imag;
            int fi = -1;
            StringBuilder sb = new StringBuilder();
            while (re != 0) {
                int rem = re % -4;
                re /= -4;
                if (rem < 0) {
                    rem = 4 + rem;
                    re++;
                }
                sb.Append(rem);
                sb.Append(0);
            }
            if (im != 0) {
                double f = (new Complex(0.0, imag) / new Complex(0.0, 2.0)).real;
                im = (int)Math.Ceiling(f);
                f = -4.0 * (f - im);
                int index = 1;
                while (im != 0) {
                    int rem = im % -4;
                    im /= -4;
                    if (rem < 0) {
                        rem = 4 + rem;
                        im++;
                    }
                    if (index < sb.Length) {
                        sb[index] = (char)(rem + 48);
                    } else {
                        sb.Append(0);
                        sb.Append(rem);
                    }
                    index += 2;
                }
                fi = (int)f;
            }
            string reverse = new string(sb.ToString().Reverse().ToArray());
            sb.Length = 0;
            sb.Append(reverse);
            if (fi != -1) sb.AppendFormat("".{0}"", fi);
            string s = sb.ToString().TrimStart('0');
            if (s[0] == '.') s = ""0"" + s;
            return new QuaterImaginary(s);
        }
 
        public override string ToString() {
            double real2 = (real == -0.0) ? 0.0 : real;  // get rid of negative zero
            double imag2 = (imag == -0.0) ? 0.0 : imag;  // ditto
            if (imag2 == 0.0) {
                return string.Format(""{0}"", real2);
            }
            if (real2 == 0.0) {
                return string.Format(""{0}i"", imag2);
            }
            if (imag2 > 0.0) {
                return string.Format(""{0} + {1}i"", real2, imag2);
            }
            return string.Format(""{0} - {1}i"", real2, -imag2);
        }
    }
 
    class QuaterImaginary {
        internal static Complex twoI = new Complex(0.0, 2.0);
        internal static Complex invTwoI = twoI.Inv();
 
        private string b2i;
 
        public QuaterImaginary(string b2i) {
            if (b2i == """" || !b2i.All(c => ""0123."".IndexOf(c) > -1) || b2i.Count(c => c == '.') > 1) {
                throw new Exception(""Invalid Base 2i number"");
            }
            this.b2i = b2i;
        }
 
        public Complex ToComplex() {
            int pointPos = b2i.IndexOf(""."");
            int posLen = (pointPos != -1) ? pointPos : b2i.Length;
            Complex sum = new Complex(0.0, 0.0);
            Complex prod = new Complex(1.0, 0.0);
            for (int j = 0; j < posLen; j++) {
                double k = (b2i[posLen - 1 - j] - '0');
                if (k > 0.0) {
                    sum += prod * k;
                }
                prod *= twoI;
            }
            if (pointPos != -1) {
                prod = invTwoI;
                for (int j = posLen + 1; j < b2i.Length; j++) {
                    double k = (b2i[j] - '0');
                    if (k > 0.0) {
                        sum += prod * k;
                    }
                    prod *= invTwoI;
                }
            }
 
            return sum;
        }
 
        public override string ToString() {
            return b2i;
        }
    }
 
    class Program {
        static void Main(string[] args) {
            for (int i = 1; i <= 16; i++) {
                Complex c1 = new Complex(i, 0);
                QuaterImaginary qi = c1.ToQuaterImaginary();
                Complex c2 = qi.ToComplex();
                Console.Write(""{0,4} -> {1,8} -> {2,4}     "", c1, qi, c2);
                c1 = -c1;
                qi = c1.ToQuaterImaginary();
                c2 = qi.ToComplex();
                Console.WriteLine(""{0,4} -> {1,8} -> {2,4}"", c1, qi, c2);
            }
            Console.WriteLine();
            for (int i = 1; i <= 16; i++) {
                Complex c1 = new Complex(0, i);
                QuaterImaginary qi = c1.ToQuaterImaginary();
                Complex c2 = qi.ToComplex();
                Console.Write(""{0,4} -> {1,8} -> {2,4}     "", c1, qi, c2);
                c1 = -c1;
                qi = c1.ToQuaterImaginary();
                c2 = qi.ToComplex();
                Console.WriteLine(""{0,4} -> {1,8} -> {2,4}"", c1, qi, c2);
            }
        }
    }
}",6030,177
44946,http://rosettacode.org/wiki/Image_noise,Image noise,"Generate a random black and white   320x240   image continuously,
showing FPS (frames per second).



A sample image
 

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Imaging;
using System.Linq;
using System.Runtime.InteropServices;
using System.Windows.Forms;
 
class Program
{
    static Size size = new Size(320, 240);
    static Rectangle rectsize = new Rectangle(new Point(0, 0), size);
    static int numpixels = size.Width * size.Height;
    static int numbytes = numpixels * 3;
 
    static PictureBox pb;
    static BackgroundWorker worker;
 
    static double time = 0;
    static double frames = 0;
    static Random rand = new Random();
 
    static byte tmp;
    static byte white = 255;
    static byte black = 0;
    static int halfmax = int.MaxValue / 2; // more voodoo! calling Next() is faster than Next(2)!
 
    static IEnumerable<byte> YieldVodoo()
    {
        // Yield 3 times same number (i.e 255 255 255) for numpixels times. 
 
        for (int i = 0; i < numpixels; i++)
        {
            tmp = rand.Next() < halfmax ? black : white; // no more lists!  
 
            // no more loops! yield! yield! yield!
            yield return tmp;
            yield return tmp;
            yield return tmp;
        }
    }
 
    static Image Randimg()
    {
        // Low-level bitmaps  
        var bitmap = new Bitmap(size.Width, size.Height);
        var data = bitmap.LockBits(rectsize, ImageLockMode.WriteOnly, PixelFormat.Format24bppRgb);
 
        Marshal.Copy(
            YieldVodoo().ToArray<byte>(),// source
            0, // start
            data.Scan0, // scan0 is a pointer to low-level bitmap data
            numbytes); // number of bytes in source
 
        bitmap.UnlockBits(data);
        return bitmap;
    }
 
    [STAThread]
    static void Main()
    {
        var form = new Form();
 
        form.AutoSize = true;
        form.Size = new Size(0, 0);
        form.Text = ""Test"";
 
        form.FormClosed += delegate
        {
            Application.Exit();
        };
 
        worker = new BackgroundWorker();
 
        worker.DoWork += delegate
        {
            System.Threading.Thread.Sleep(500); // remove try/catch, just wait a bit before looping
 
            while (true)
            {
                var a = DateTime.Now;
                pb.Image = Randimg();
                var b = DateTime.Now;
 
                time += (b - a).TotalSeconds;
                frames += 1;
 
                if (frames == 30)
                {
                    Console.WriteLine(""{0} frames in {1:0.000} seconds. ({2:0} FPS)"", frames, time, frames / time);
 
                    time = 0;
                    frames = 0;
                }
            }
        };
 
        worker.RunWorkerAsync();
 
        FlowLayoutPanel flp = new FlowLayoutPanel();
        form.Controls.Add(flp);
 
        pb = new PictureBox();
        pb.Size = size;
 
        flp.AutoSize = true;
        flp.Controls.Add(pb);
 
        form.Show();
        Application.Run();
    }
}",2967,113
44981,http://rosettacode.org/wiki/Include_a_file,Include a file,"Task

Demonstrate the language's ability to include source code from other files.




See Also
 Compiler/Simple file inclusion pre processor



",#C.23,C#,"/* The C# language specification does not give a mechanism for 'including' one source file within another,
 * likely because there is no need - all code compiled within one 'assembly' (individual IDE projects
 * are usually compiled to separate assemblies) can 'see' all other code within that assembly.
 */",307,4
45060,http://rosettacode.org/wiki/Hunt_the_Wumpus,Hunt the Wumpus,"This task has been flagged for clarification. Code on this page in its current state may be flagged incorrect once this task has been clarified. See this page's Talk page for discussion.
Create a simple implementation of the classic textual game Hunt The Wumpus.

The rules are:

The game is set in a cave that consists of a 20 room labyrinth.
Each room is connected to 3 other rooms (the cave is modeled after the
vertices of a dodecahedron).
The objective of the player is to find and kill the horrendous beast Wumpus that lurks in the cave.

The player has 5 arrows.
If they run out of arrows before killing the Wumpus, the player loses the game.

In the cave there are:

 One Wumpus
 Two giant bats
 Two bottomless pits
If the player enters a room with the Wumpus, he is eaten by it and the game is lost.

If the player enters a room with a bottomless pit, he falls into it and the game is lost.

If the player enters a room with a giant bat, the bat takes him and transports him into a random empty room.

Each turn the player can either walk into an adjacent room or shoot into an adjacent room.

Whenever the player enters a room, he ""senses"" what happens in adjacent rooms.
The messages are:

 Nearby Wumpus: ""You smell something terrible nearby.""
 Nearby bat: ""You hear a rustling.""
 Nearby pit: ""You feel a cold wind blowing from a nearby cavern.""
When the player shoots, he wins the game if he is shooting in the room with the Wumpus.
If he shoots into another room, the Wumpus has a 75% of chance of waking up and moving into an adjacent room: if this is the room with the player, he eats him up and the game is lost.
",#C.23,C#," 
// constant value 2d array to represent the dodecahedron
// room structure
const static int adjacentRooms[20][3] = {
  {1, 4, 7},   {0, 2, 9},   {1, 3, 11},   {2, 4, 13},    {0, 3, 5},
  {4, 6, 14},  {5, 7, 16},    {0, 6, 8},   {7, 9, 17},   {1, 8, 10},
  {9, 11, 18}, {2, 10, 12}, {11, 13, 19},  {3, 12, 14},  {5, 13, 15},
  {14, 16, 19}, {6, 15, 17},  {8, 16, 18}, {10, 17, 19}, {12, 15, 18}
};
 
class WumpusGame {
 
    private:
      // Data Members
      int numRooms;
      int currentRoom, startingPosition; // currentRoom is an integer variable that stores the room the player is currently in (between 0-20)
      int wumpusRoom, batRoom1, batRoom2, pitRoom1, pitRoom2; // Stores the room numbers of the respective
      int wumpusStart, bat1Start, bat2Start;
      bool playerAlive, wumpusAlive; // Are the player and wumpus still alive? True or false.
      int numArrows; //store arrow count
 
      // private functions
      void PlacePits();
      void PlaceBats();
      void PlaceWumpus();
      void PlacePlayer();
      bool IsValidMove(int);
      bool IsRoomAdjacent(int, int);
      int Move(int);
      void InspectCurrentRoom();
      void PerformAction(int);
      void MoveStartledWumpus(int);
      void PlayGame();
      void PlayAgain();
      void PrintInstructions();
 
      // Access specifier
      public:
        //public functions
        void StartGame();
        WumpusGame();
};
 
#include <iostream>
#include <stdlib.h>     /* srand, rand */
#include <time.h>       /* time */
#include <vector>
#include <cstring>
using namespace std;
 
// default constructor
WumpusGame::WumpusGame() {
  numRooms = 20;
}
 
// This function prints the instructions for the game
// to the console
void WumpusGame::PrintInstructions() {
    char wait;
    cout << "" Welcome to 'Hunt the Wumpus'! "" << endl;
    cout << "" The wumpus lives in a cave of 20 rooms. Each room has 3 tunnels leading to"" << endl;
    cout << "" other rooms. (Look at a dodecahedron to see how this works - if you don't know"" << endl;
    cout << "" what a dodecahedron is, ask someone). \n"" << endl;
    cout << "" Hazards: \n"" << endl;
    cout << "" Bottomless pits - two rooms have bottomless pits in them. If you go there, you "" << endl;
    cout << "" fall into the pit (& lose!) \n"" << endl;
    cout << "" Super bats - two other rooms have super bats.  If you go there, a bat grabs you"" << endl;
    cout << "" and takes you to some other room at random. (Which may be troublesome). Once the"" << endl;
    cout << "" bat has moved you, that bat moves to another random location on the map.\n\n"" << endl;
 
    cout << "" Wumpus"" << endl;
    cout << "" The wumpus is not bothered by hazards (he has sucker feet and is too big for a"" << endl;
    cout << "" bat to lift).  Usually he is asleep.  Two things wake him up: you shooting an"" << endl;
    cout << "" arrow or you entering his room. If the wumpus wakes he moves (p=.75) one room or "" << endl;
    cout << "" stays still (p=.25). After that, if he is where you are, he eats you up and you lose!\n"" << endl;
 
    cout << "" You \n"" << endl;
    cout << "" Each turn you may move, save or shoot an arrow using the commands move, save, & shoot."" << endl;
    cout << "" Moving: you can move one room (thru one tunnel)."" << endl;
    cout << "" Arrows: you have 3 arrows. You lose when you run out. You aim by telling the"" << endl;
    cout << "" computer the rooms you want the arrow to go to.  If the arrow can't go that way"" << endl;
    cout << "" (if no tunnel), the arrow will not fire."" << endl;
 
    cout << "" Warnings"" << endl;
    cout << "" When you are one room away from a wumpus or hazard, the computer says:"" << endl;
 
    cout << "" Wumpus: 'I smell a wumpus'"" << endl;
    cout << "" Bat: 'Bats nearby'"" << endl;
    cout << "" Pit: 'I feel a draft'"" << endl;
 
    cout << endl;
    cout << ""Press Y to return to the main menu."" << endl;
    cin >> wait;
 
}
 
// This function will place two bats throughout the map
// this ensures that the bats will not be place in the same
// room as another bat or the wumpus
void WumpusGame::PlaceBats() {
  srand (time(NULL));
  bool validRoom = false;
  while(!validRoom){
      batRoom1 = rand() % 20 + 1;
      if(batRoom1 != wumpusRoom)
          validRoom = true;
  }
 
  validRoom = false;
  while(!validRoom){
      batRoom2 = rand() % 20 + 1;
      if(batRoom2 != wumpusRoom && batRoom2 != batRoom1)
          validRoom = true;
  }
  bat1Start = batRoom1;
  bat2Start = batRoom2;
}
 
// this function randomly places the pits
// throughout the map excluding room 0
void WumpusGame::PlacePits() {
    srand (time(NULL));
    pitRoom1 = rand() % 20 + 1;
    pitRoom2 = rand() % 20 + 1;
}
 
// this function randomly places the wumpus in a room
// without being in room number 0
void WumpusGame::PlaceWumpus() {
    srand (time(NULL));
    int randomRoom = rand() % 20 + 1;
    wumpusRoom = randomRoom;
    wumpusStart = wumpusRoom;
}
 
// place the player in room 0
void WumpusGame::PlacePlayer() {
    startingPosition = 0;
    currentRoom = Move(0);
}
 
// This is a  method that checks if the user inputted a valid room to move to or not.
// The room number has to be between 0 and 20, but also must be adjacent to the current room.
bool WumpusGame::IsValidMove(int roomID) {
    if (roomID < 0) return false;
    if (roomID > numRooms) return false;
    if (!IsRoomAdjacent(currentRoom, roomID)) return false;
 
    return true;
}
 
// This method returns true if roomB is adjacent to roomA, otherwise returns false.
// It is a helper method that loops through the adjacentRooms array to check.
// It will be used throughout the app to check if we are next to the wumpus, bats, or pits
// as well as check if we can make a valid move.
bool WumpusGame::IsRoomAdjacent(int roomA, int roomB)
{
    for (int j = 0; j < 3; j++)
    {
        if (adjacentRooms[roomA][j] == roomB){
          return true;
        }
    }
    return false;
}
 
// This method moves the player to a new room and returns the new room. It performs no checks on its own.
int WumpusGame::Move(int newRoom)
{
    return newRoom;
}
 
// Inspects the current room.
// This method check for Hazards such as being in the same room as the wumpus, bats, or pits
// It also checks if you are adjacent to a hazard and handle those cases
// Finally it will just print out the room description
void WumpusGame::InspectCurrentRoom() {
    srand (time(NULL));
    if (currentRoom == wumpusRoom)
    {
        cout << ""The Wumpus ate you!!!"" << endl;
        cout << ""LOSER!!!"" << endl;
        PlayAgain();
    }
    else if (currentRoom == batRoom1 || currentRoom == batRoom2)
    {
        int roomBatsLeft = currentRoom;
        bool validNewBatRoom = false;
        bool isBatRoom = false;
        cout << ""Snatched by superbats!!"" << endl;
        if(currentRoom == pitRoom1 || currentRoom == pitRoom2)
            cout << ""Luckily, the bats saved you from the bottomless pit!!"" << endl;
        while(!isBatRoom){
            currentRoom = Move(rand() % 20 + 1);
            if(currentRoom != batRoom1 && currentRoom != batRoom2)
                isBatRoom = true;
        }
        cout << ""The bats moved you to room "";
	      cout << currentRoom << endl;
        InspectCurrentRoom();
 
        if(roomBatsLeft == batRoom1){
            while(!validNewBatRoom){
                batRoom1 = rand() % 19 + 1;
                if(batRoom1 != wumpusRoom && batRoom1 != currentRoom)
                    validNewBatRoom = true;
            }
        } else {
            while(!validNewBatRoom){
                batRoom2 = rand() % 19 + 1;
                if(batRoom2 != wumpusRoom && batRoom2 != currentRoom)
                    validNewBatRoom = true;
            }
        }
    }
    else if(currentRoom == pitRoom1 || currentRoom == pitRoom2)
    {
        cout << ""YYYIIIIIEEEEE.... fell in a pit!!!"" << endl;
        cout << ""GAME OVER LOSER!!!"" << endl;
        PlayAgain();
    }
    else
    {
        cout << ""You are in room "";
        cout << currentRoom << endl;
        if (IsRoomAdjacent(currentRoom, wumpusRoom)){
            cout << ""You smell a horrid stench..."" << endl;
        }
        if (IsRoomAdjacent(currentRoom, batRoom1) || IsRoomAdjacent(currentRoom, batRoom2)){
            cout << ""Bats nearby..."" << endl;
        }
        if (IsRoomAdjacent(currentRoom, pitRoom1) || IsRoomAdjacent(currentRoom, pitRoom2)){
            cout << ""You feel a draft..."" << endl;
        }
        cout << ""Tunnels lead to rooms "" << endl;
        for (int j = 0; j < 3; j++)
        {
            cout << adjacentRooms[currentRoom][j];
            cout << "" "";
        }
        cout << endl;
    }
}
 
// Method accepts an int which is the command the user inputted.
// This method performs the action of the command or prints out an error.
void WumpusGame::PerformAction(int cmd) {
    int newRoom;
    switch (cmd)
    {
 
        case 1:
            cout << ""Which room? "" << endl;
            try
            {
                cin >> newRoom;
                // Check if the user inputted a valid room id, then simply tell the player to move there.
                if (IsValidMove(newRoom))
                {
                    currentRoom = Move(newRoom);
                    InspectCurrentRoom();
                }
                else
                {
                    cout << ""You cannot move there."" << endl;
                }
            }
            catch (...) // Try...Catch block will catch if the user inputs text instead of a number.
            {
                cout << ""You cannot move there."" << endl;
            }
            break;
        case 2:
            if(numArrows > 0){
                cout << ""Which room? "" << endl;
                try
                {
                    cin >> newRoom;
                    // Check if the user inputted a valid room id, then simply tell the player to move there.
                    if (IsValidMove(newRoom))
                    {
                        numArrows--;
                        if(newRoom == wumpusRoom){
                            cout << ""ARGH.. Splat!"" << endl;
                            cout << ""Congratulations! You killed the Wumpus! You Win."" << endl;
                            cout << ""Press 'Y' to return to the main menu."" << endl;
                            wumpusAlive = false;
                            cin >> newRoom;
                            cin.clear();
                            cin.ignore(10000, '\n');
                        }
                        else
                        {
                            cout << ""Miss! But you startled the Wumpus"" << endl;
                            MoveStartledWumpus(wumpusRoom);
                            cout << ""Arrows Left: "";
                            cout << numArrows << endl;
                            if(wumpusRoom == currentRoom){
                                cout << ""The wumpus attacked you! You've been killed."" << endl;
                                cout << ""Game Over!"" << endl;
                                PlayAgain();
                            }
 
                        }
                    }
                    else
                    {
                        cout << ""You cannot shoot there."" << endl;
                    }
                }
                catch (...) // Try...Catch block will catch if the user inputs text instead of a number.
                {
                    cout << ""You cannot shoot there."" << endl;
                }
            } else
            {
                cout << ""You do not have any arrows!"" << endl;
            }
            break;
        case 3:
            cout << ""Quitting the current game."" << endl;
            playerAlive = false;
            break;
        default:
            cout << ""You cannot do that. You can move, shoot, save or quit."" << endl;
            break;
    }
}
 
// this function moves the wumpus randomly to a room that is adjacent to
// the wumpus's current position
void WumpusGame::MoveStartledWumpus(int roomNum){
    srand (time(NULL));
    int rando = rand() % 3;
    if(rando != 3)
        wumpusRoom = adjacentRooms[roomNum][rando];
}
 
// This restarts the map from the begiinning
void WumpusGame::PlayAgain(){
    char reply;
    cout << ""Would you like to replay the same map? Enter Y to play again."" << endl;
    cin >> reply;
    if(reply == 'y' || reply == 'Y'){
        currentRoom = startingPosition;
        wumpusRoom = wumpusStart;
        batRoom1 = bat1Start;
        batRoom2 = bat2Start;
        cout << ""Try not to die this time. \n"" << endl;
        InspectCurrentRoom();
    } else {
        playerAlive = false;
    }
 
}
 
// PlayGame() method starts up the game.
// It houses the main game loop and when PlayGame() quits the game has ended.
void WumpusGame::PlayGame()
{
	int choice;
  bool validChoice = false;
 
	cout << ""Running the game..."" << endl;
 
  // Initialize the game
	PlaceWumpus();
	PlaceBats();
	PlacePits();
	PlacePlayer();
 
	// game set up
	playerAlive = true;
	wumpusAlive = true;
	numArrows = 3;
 
    //Inspects the initial room
    InspectCurrentRoom();
 
    // Main game loop.
    while (playerAlive && wumpusAlive)
    {
        cout << ""Enter an action choice."" << endl;
        cout << ""1) Move"" << endl;
        cout << ""2) Shoot"" << endl;
        cout << ""3) Quit"" << endl;
        cout << "">>> "";
 
        do
        {
            validChoice = true;
            cout << ""Please make a selection: "";
            try
            {
                cin >> choice;
                switch (choice)
                {
                    case 1:
                        PerformAction(choice);
                        break;
                    case 2:
                        PerformAction(choice);
                        break;
                    case 3:
                        PerformAction(choice);
                        break;
                    default:
                        validChoice = false;
                        cout << ""Invalid choice. Please try again."" << endl;
                        cin.clear();
		                    cin.ignore(10000, '\n');
                        break;
                }
            }
            catch (...)
            {
                validChoice = false;
                cout << ""Invalid choice. Please try again."" << endl;
                cin.clear();
                cin.ignore(10000, '\n');
            }
 
        } while (validChoice == false);
    }
}
 
// this function begins the game loop
void WumpusGame::StartGame() {
 
	srand (time(NULL));
	int choice;
  bool validChoice;
  bool keepPlaying;
  wumpusStart = bat1Start = bat2Start = -1;
 
  do {
      keepPlaying = true;
      cout << ""Welcome to Hunt The Wumpus."" << endl;
      cout << ""1) Play Game"" << endl;
      cout << ""2) Print Instructions"" << endl;
      cout << ""3) Quit"" << endl;
 
      do
      {
          validChoice = true;
          cout << ""Please make a selection: "";
          try
          {
              cin >> choice;
              switch (choice)
              {
                  case 1:
                      PlayGame();
                      break;
                  case 2:
                      PrintInstructions();
                      break;
                  case 3:
                      cout << ""Quitting."" << endl;
                      keepPlaying = false;
                      break;
                  default:
                      validChoice = false;
                      cout << ""Invalid choice. Please try again."" << endl;
                      cin.clear();
                      cin.ignore(10000, '\n');
                      break;
              }
          }
          catch (...)
          {
              validChoice = false;
              cout << ""Invalid choice. Please try again."" << endl;
              cin.clear();
              cin.ignore(10000, '\n');
          }
 
      } while (validChoice == false);
  } while (keepPlaying);
}
 
int main() {
    // create wumpus game object
    WumpusGame game;
    // start the game
    game.StartGame();
}
 
 ",16143,489
45281,http://rosettacode.org/wiki/Integer_comparison,Integer comparison,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Get two integers from the user.

Then,   display a message if the first integer is:

   less than, 
   equal to,   or 
   greater than
the second integer.



Test the condition   for each case separately,   so that   all three comparison operators are used   in the code.



Related task

   String comparison

",#C.23,C#,"using System;
 
class Program
{
    static void Main()
    {
        int a = int.Parse(Console.ReadLine());
        int b = int.Parse(Console.ReadLine());
        if (a < b)
            Console.WriteLine(""{0} is less than {1}"", a, b);
        if (a == b)
            Console.WriteLine(""{0} equals {1}"", a, b);
        if (a > b)
            Console.WriteLine(""{0} is greater than {1}"", a, b);
    }
}",400,16
45289,http://rosettacode.org/wiki/Humble_numbers,Humble numbers,"Humble numbers are positive integers which have   no   prime factors    >    7.



Humble numbers are also called   7-smooth numbers,   and sometimes called   highly composite,

although this conflicts with another meaning of   highly composite numbers.



Another way to express the above is:

  humble  =  2i × 3j × 5k × 7m 

           where     i, j, k, m ≥ 0 



Task

   show the first   50   humble numbers   (in a horizontal list)
   show the number of humble numbers that have   x   decimal digits for all   x's   up to   n   (inclusive).
   show   (as many as feasible or reasonable for above)   on separate lines
   show all output here on this page


Related tasks

   Hamming numbers


References

   Wikipedia: Smooth numbers, see the 2nd paragraph.
   OEIS A002473: humble numbers
   University of Ulm, The first 5842 terms of humble numbers

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace HumbleNumbers {
    class Program {
        static bool IsHumble(int i) {
            if (i <= 1) return true;
            if (i % 2 == 0) return IsHumble(i / 2);
            if (i % 3 == 0) return IsHumble(i / 3);
            if (i % 5 == 0) return IsHumble(i / 5);
            if (i % 7 == 0) return IsHumble(i / 7);
            return false;
        }
 
        static void Main() {
            var limit = short.MaxValue;
            Dictionary<int, int> humble = new Dictionary<int, int>();
            var count = 0;
            var num = 1;
 
            while (count < limit) {
                if (IsHumble(num)) {
                    var str = num.ToString();
                    var len = str.Length;
                    if (humble.ContainsKey(len)) {
                        humble[len]++;
                    } else {
                        humble[len] = 1;
                    }
                    if (count < 50) Console.Write(""{0} "", num);
                    count++;
                }
                num++;
            }
            Console.WriteLine(""\n"");
 
            Console.WriteLine(""Of the first {0} humble numbers:"", count);
            num = 1;
            while (num < humble.Count - 1) {
                if (humble.ContainsKey(num)) {
                    var c = humble[num];
                    Console.WriteLine(""{0,5} have {1,2} digits"", c, num);
                    num++;
                } else {
                    break;
                }
            }
        }
    }
}",1570,50
45352,http://rosettacode.org/wiki/Increment_a_numerical_string,Increment a numerical string,"Task

Increment a numerical string.



",#C.23,C#,"string s = ""12345"";
s = (int.Parse(s) + 1).ToString();
// The above functions properly for strings >= Int32.MinValue and
//  < Int32.MaxValue. ( -2147483648 to 2147483646 )
 
// The following will work for any arbitrary-length integer string.
//  (Assuming that the string fits in memory, leaving enough space
//  for the temporary BigInteger created, plus the resulting string):
using System.Numerics;
string bis = ""123456789012345678999999999"";
bis = (BigInteger.Parse(bis) + 1).ToString();
// Note that extremely long strings will take a long time to parse
//  and convert from a BigInteger back into a string.",613,13
45453,http://rosettacode.org/wiki/I_before_E_except_after_C,I before E except after C,"The phrase      ""I before E, except after C""     is a
widely known mnemonic which is supposed to help when spelling English words.



Task

Using the word list from   http://wiki.puzzlers.org/pub/wordlists/unixdict.txt,

check if the two sub-clauses of the phrase are plausible individually:

   ""I before E when not preceded by C""
   ""E before I when preceded by C""


If both sub-phrases are plausible then the original phrase can be said to be plausible.

Something is plausible if the number of words having the feature is more than two times the number of words having the opposite feature (where feature is 'ie' or 'ei' preceded or not by 'c' as appropriate).



Stretch goal

As a stretch goal use the entries from the table of Word Frequencies in Written and Spoken English: based on the British National Corpus, (selecting those rows with three space or tab separated words only), to see if the phrase is plausible when word frequencies are taken into account.


Show your output here as well as your program.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




cf.

 Schools to rethink 'i before e' - BBC news, 20 June 2009
 I Before E Except After C - QI Series 8 Ep 14, (humorous)
 Companion website for the book: ""Word Frequencies in Written and Spoken English: based on the British National Corpus"".

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.IO;
 
namespace IBeforeE {
    class Program {
        static bool IsOppPlausibleWord(string word) {
            if (!word.Contains(""c"") && word.Contains(""ei"")) {
                return true;
            }
            if (word.Contains(""cie"")) {
                return true;
            }
            return false;
        }
 
        static bool IsPlausibleWord(string word) {
            if (!word.Contains(""c"") && word.Contains(""ie"")) {
                return true;
            }
            if (word.Contains(""cei"")) {
                return true;
            }
            return false;
        }
 
        static bool IsPlausibleRule(string filename) {
            IEnumerable<string> wordSource = File.ReadLines(filename);
            int trueCount = 0;
            int falseCount = 0;
 
            foreach (string word in wordSource) {
                if (IsPlausibleWord(word)) {
                    trueCount++;
                }
                else if (IsOppPlausibleWord(word)) {
                    falseCount++;
                }
            }
 
            Console.WriteLine(""Plausible count: {0}"", trueCount);
            Console.WriteLine(""Implausible count: {0}"", falseCount);
            return trueCount > 2 * falseCount;
        }
 
        static void Main(string[] args) {
            if (IsPlausibleRule(""unixdict.txt"")) {
                Console.WriteLine(""Rule is plausible."");
            }
            else {
                Console.WriteLine(""Rule is not plausible."");
            }
        }
    }
}",1592,55
45463,http://rosettacode.org/wiki/IBAN,IBAN,"

 This page uses content from Wikipedia. The original article was at IBAN. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The   International Bank Account Number (IBAN)   is an internationally agreed means of identifying bank accounts across national borders with a reduced risk of propagating transcription errors.

The IBAN consists of up to 34 alphanumeric characters:

   first the two-letter ISO 3166-1 alpha-2 country code, 
   then two check digits, and 
   finally a country-specific Basic Bank Account Number (BBAN). 


The check digits enable a sanity check of the bank account number to confirm its integrity even before submitting a transaction.



Task

Validate the following fictitious IBAN:    GB82 WEST 1234 5698 7654 32 



Details of the algorithm can be found on the Wikipedia page.



",#C.23,C#,"    public class IbanValidator : IValidateTypes
    {
        public ValidationResult Validate(string value)
        {
            // Check if value is missing
            if (string.IsNullOrEmpty(value))
                return ValidationResult.ValueMissing;
 
            if (value.Length < 2)
                return ValidationResult.ValueTooSmall;
 
            var countryCode = value.Substring(0, 2).ToUpper();
 
            int lengthForCountryCode;
 
            var countryCodeKnown = Lengths.TryGetValue(countryCode, out lengthForCountryCode);
            if (!countryCodeKnown)
            {
                return ValidationResult.CountryCodeNotKnown;
            }
 
            // Check length.
            if (value.Length < lengthForCountryCode)
                return ValidationResult.ValueTooSmall;
 
            if (value.Length > lengthForCountryCode)
                return ValidationResult.ValueTooBig;
 
            value = value.ToUpper();
            var newIban = value.Substring(4) + value.Substring(0, 4);
 
            newIban = Regex.Replace(newIban, @""\D"", match => (match.Value[0] - 55).ToString());
 
            var remainder = BigInteger.Parse(newIban) % 97;
 
            if (remainder != 1)
                return ValidationResult.ValueFailsModule97Check;
 
            return ValidationResult.IsValid;
        }
 
        public enum ValidationResult
        {
            IsValid,
            ValueMissing,
            ValueTooSmall,
            ValueTooBig,
            ValueFailsModule97Check,
            CountryCodeNotKnown
        }
 
        private static readonly IDictionary<string, int> Lengths = new Dictionary<string, int>
        {
            {""AL"", 28},
            {""AD"", 24},
            {""AT"", 20},
            {""AZ"", 28},
            {""BE"", 16},
            {""BH"", 22},
            {""BA"", 20},
            {""BR"", 29},
            {""BG"", 22},
            {""CR"", 21},
            {""HR"", 21},
            {""CY"", 28},
            {""CZ"", 24},
            {""DK"", 18},
            {""DO"", 28},
            {""EE"", 20},
            {""FO"", 18},
            {""FI"", 18},
            {""FR"", 27},
            {""GE"", 22},
            {""DE"", 22},
            {""GI"", 23},
            {""GR"", 27},
            {""GL"", 18},
            {""GT"", 28},
            {""HU"", 28},
            {""IS"", 26},
            {""IE"", 22},
            {""IL"", 23},
            {""IT"", 27},
            {""KZ"", 20},
            {""KW"", 30},
            {""LV"", 21},
            {""LB"", 28},
            {""LI"", 21},
            {""LT"", 20},
            {""LU"", 20},
            {""MK"", 19},
            {""MT"", 31},
            {""MR"", 27},
            {""MU"", 30},
            {""MC"", 27},
            {""MD"", 24},
            {""ME"", 22},
            {""NL"", 18},
            {""NO"", 15},
            {""PK"", 24},
            {""PS"", 29},
            {""PL"", 28},
            {""PT"", 25},
            {""RO"", 24},
            {""SM"", 27},
            {""SA"", 24},
            {""RS"", 22},
            {""SK"", 24},
            {""SI"", 19},
            {""ES"", 24},
            {""SE"", 24},
            {""CH"", 21},
            {""TN"", 24},
            {""TR"", 26},
            {""AE"", 23},
            {""GB"", 22},
            {""VG"", 24}
        };
    }",3233,119
45652,http://rosettacode.org/wiki/Identity_matrix,Identity matrix,"Task

Build an   identity matrix   of a size known at run-time.



An identity matrix is a square matrix of size n × n,

where the diagonal elements are all 1s (ones),

and all the other elements are all 0s (zeroes).







I

n


=


[



1


0


0


⋯


0




0


1


0


⋯


0




0


0


1


⋯


0




⋮


⋮


⋮


⋱


⋮




0


0


0


⋯


1



]




{\displaystyle I_{n}={\begin{bmatrix}1&0&0&\cdots &0\\0&1&0&\cdots &0\\0&0&1&\cdots &0\\\vdots &\vdots &\vdots &\ddots &\vdots \\0&0&0&\cdots &1\\\end{bmatrix}}}





Related tasks

   Spiral matrix
   Zig-zag matrix 
   Ulam_spiral_(for_primes)

",#C.23,C#," 
using System;
using System.Linq;
 
namespace IdentityMatrix
{
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length != 1)
            {
                Console.WriteLine(""Requires exactly one argument"");
                return;
            }
            int n;
            if (!int.TryParse(args[0], out n))
            {
                Console.WriteLine(""Requires integer parameter"");
                return;
            }
 
            var identity =
                Enumerable.Range(0, n).Select(i => Enumerable.Repeat(0, n).Select((z,j) => j == i ? 1 : 0).ToList()).ToList();
            foreach (var row in identity)
            {
                foreach (var elem in row)
                {
                    Console.Write("" "" + elem);
                }
                Console.WriteLine();
            }
            Console.ReadKey();
        }
    }
}
 ",913,37
46046,http://rosettacode.org/wiki/HTTPS/Client-authenticated,HTTPS/Client-authenticated,"Demonstrate how to connect to a web server over HTTPS where that server requires that the client present a certificate to prove who (s)he is. Unlike with the HTTPS request with authentication task, it is not acceptable to perform the authentication by a username/password or a set cookie.

This task is in general useful for use with webservice clients as it offers a high level of assurance that the client is an acceptable counterparty for the server. For example, Amazon Web Services uses this style of authentication.
",#C.23,C#," 
using System;
using System.Net;
 
class Program
{
    class MyWebClient : WebClient
    {
        protected override WebRequest GetWebRequest(Uri address)
        {
            HttpWebRequest request = (HttpWebRequest)base.GetWebRequest(address);
            request.ClientCertificates.Add(new X509Certificate());
            return request;
        }
    }
    static void Main(string[] args)
    {
        var client = new MyWebClient();
 
        var data = client.DownloadString(""https://example.com"");
 
        Console.WriteLine(data);
    }
}
 ",553,25
46090,http://rosettacode.org/wiki/HTTPS/Authenticated,HTTPS/Authenticated,"The goal of this task is to demonstrate HTTPS requests with authentication.
Implementations of this task should not use client certificates for this: that is the subject of another task.
",#C.23,C#," 
using System;
using System.Net;
 
class Program
{
    static void Main(string[] args)
    {
        var client = new WebClient();
 
        // credentials of current user:
        client.Credentials = CredentialCache.DefaultCredentials;
        // or specify credentials manually:
        client.Credentials = new NetworkCredential(""User"", ""Password"");
 
        var data = client.DownloadString(""https://example.com"");
 
        Console.WriteLine(data);
    }
}
 ",466,21
46201,http://rosettacode.org/wiki/HTTPS,HTTPS,"Task

Send a GET request to obtain the resource located at the URL ""https://www.w3.org/"", then print it to the console.

Checking the host certificate for validity is recommended.

Do not authenticate. That is the subject of other tasks.

Readers may wish to contrast with the HTTP Request task, and also the task on HTTPS request with authentication.

",#C.23,C#," 
using System;
using System.Net;
 
class Program
{
    static void Main(string[] args)
    {
        var client = new WebClient();
        var data = client.DownloadString(""https://www.google.com"");
 
        Console.WriteLine(data);
    }
}
 ",244,15
46241,http://rosettacode.org/wiki/Host_introspection,Host introspection,"Print the word size and endianness of the host machine.

See also: Variable size/Get
",#C.23,C#,"static void Main()
{
  Console.WriteLine(""Word size = {0} bytes,"",sizeof(int));
 
  if (BitConverter.IsLittleEndian)
    Console.WriteLine(""Little-endian."");
  else
    Console.WriteLine(""Big-endian."");
}",204,9
46242,http://rosettacode.org/wiki/Hostname,Hostname,"Task

Find the name of the host on which the routine is running.



",#C.23,C#,System.Net.Dns.GetHostName();,29,1
46272,http://rosettacode.org/wiki/Huffman_coding,Huffman coding,"Huffman encoding is a way to assign binary codes to symbols that reduces the overall number of bits used to encode a typical string of those symbols.

For example, if you use letters as symbols and have details of the frequency of occurrence of those letters in typical strings, then you could just encode each letter with a fixed number of bits, such as in ASCII codes. You can do better than this by encoding more frequently occurring letters such as e and a, with smaller bit strings; and less frequently occurring letters such as q and x with longer bit strings.

Any string of letters will be encoded as a string of bits that are no-longer of the same length per letter. To successfully decode such as string, the smaller codes assigned to letters such as 'e' cannot occur as a prefix in the larger codes such as that for 'x'.

If you were to assign a code 01 for 'e' and code 011 for 'x', then if the bits to decode started as 011... then you would not know if you should decode an 'e' or an 'x'.
The Huffman coding scheme takes each symbol and its weight (or frequency of occurrence), and generates proper encodings for each symbol taking account of the weights of each symbol, so that higher weighted symbols have fewer bits in their encoding. (See the WP article for more information).

A Huffman encoding can be computed by first creating a tree of nodes:


 Create a leaf node for each symbol and add it to the priority queue.
 While there is more than one node in the queue:
 Remove the node of highest priority (lowest probability) twice to get two nodes.
 Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes' probabilities.
 Add the new node to the queue.
 The remaining node is the root node and the tree is complete.


Traverse the constructed binary tree from root to leaves assigning and accumulating a '0' for one branch and a '1' for the other at each node. The accumulated zeros and ones at each leaf constitute a Huffman encoding for those symbols and weights:



Task

Using the characters and their frequency from the string:

     this is an example for huffman encoding  
create a program to generate a Huffman encoding for each character as a table.



",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace Huffman_Encoding
{
    public class PriorityQueue<T> where T : IComparable
    {
        protected List<T> LstHeap = new List<T>();
 
        public virtual int Count
        {
            get { return LstHeap.Count; }
        }
 
        public virtual void Add(T val)
        {
            LstHeap.Add(val);
            SetAt(LstHeap.Count - 1, val);
            UpHeap(LstHeap.Count - 1);
        }
 
        public virtual T Peek()
        {
            if (LstHeap.Count == 0)
            {
                throw new IndexOutOfRangeException(""Peeking at an empty priority queue"");
            }
 
            return LstHeap[0];
        }
 
        public virtual T Pop()
        {
            if (LstHeap.Count == 0)
            {
                throw new IndexOutOfRangeException(""Popping an empty priority queue"");
            }
 
            T valRet = LstHeap[0];
 
            SetAt(0, LstHeap[LstHeap.Count - 1]);
            LstHeap.RemoveAt(LstHeap.Count - 1);
            DownHeap(0);
            return valRet;
        }
 
        protected virtual void SetAt(int i, T val)
        {
            LstHeap[i] = val;
        }
 
        protected bool RightSonExists(int i)
        {
            return RightChildIndex(i) < LstHeap.Count;
        }
 
        protected bool LeftSonExists(int i)
        {
            return LeftChildIndex(i) < LstHeap.Count;
        }
 
        protected int ParentIndex(int i)
        {
            return (i - 1) / 2;
        }
 
        protected int LeftChildIndex(int i)
        {
            return 2 * i + 1;
        }
 
        protected int RightChildIndex(int i)
        {
            return 2 * (i + 1);
        }
 
        protected T ArrayVal(int i)
        {
            return LstHeap[i];
        }
 
        protected T Parent(int i)
        {
            return LstHeap[ParentIndex(i)];
        }
 
        protected T Left(int i)
        {
            return LstHeap[LeftChildIndex(i)];
        }
 
        protected T Right(int i)
        {
            return LstHeap[RightChildIndex(i)];
        }
 
        protected void Swap(int i, int j)
        {
            T valHold = ArrayVal(i);
            SetAt(i, LstHeap[j]);
            SetAt(j, valHold);
        }
 
        protected void UpHeap(int i)
        {
            while (i > 0 && ArrayVal(i).CompareTo(Parent(i)) > 0)
            {
                Swap(i, ParentIndex(i));
                i = ParentIndex(i);
            }
        }
 
        protected void DownHeap(int i)
        {
            while (i >= 0)
            {
                int iContinue = -1;
 
                if (RightSonExists(i) && Right(i).CompareTo(ArrayVal(i)) > 0)
                {
                    iContinue = Left(i).CompareTo(Right(i)) < 0 ? RightChildIndex(i) : LeftChildIndex(i);
                }
                else if (LeftSonExists(i) && Left(i).CompareTo(ArrayVal(i)) > 0)
                {
                    iContinue = LeftChildIndex(i);
                }
 
                if (iContinue >= 0 && iContinue < LstHeap.Count)
                {
                    Swap(i, iContinue);
                }
 
                i = iContinue;
            }
        }
    }
 
    internal class HuffmanNode<T> : IComparable
    {
        internal HuffmanNode(double probability, T value)
        {
            Probability = probability;
            LeftSon = RightSon = Parent = null;
            Value = value;
            IsLeaf = true;
        }
 
        internal HuffmanNode(HuffmanNode<T> leftSon, HuffmanNode<T> rightSon)
        {
            LeftSon = leftSon;
            RightSon = rightSon;
            Probability = leftSon.Probability + rightSon.Probability;
            leftSon.IsZero = true;
            rightSon.IsZero = false;
            leftSon.Parent = rightSon.Parent = this;
            IsLeaf = false;
        }
 
        internal HuffmanNode<T> LeftSon { get; set; }
        internal HuffmanNode<T> RightSon { get; set; }
        internal HuffmanNode<T> Parent { get; set; }
        internal T Value { get; set; }
        internal bool IsLeaf { get; set; }
 
        internal bool IsZero { get; set; }
 
        internal int Bit
        {
            get { return IsZero ? 0 : 1; }
        }
 
        internal bool IsRoot
        {
            get { return Parent == null; }
        }
 
        internal double Probability { get; set; }
 
        public int CompareTo(object obj)
        {
            return -Probability.CompareTo(((HuffmanNode<T>) obj).Probability);
        }
    }
 
    public class Huffman<T> where T : IComparable
    {
        private readonly Dictionary<T, HuffmanNode<T>> _leafDictionary = new Dictionary<T, HuffmanNode<T>>();
        private readonly HuffmanNode<T> _root;
 
        public Huffman(IEnumerable<T> values)
        {
            var counts = new Dictionary<T, int>();
            var priorityQueue = new PriorityQueue<HuffmanNode<T>>();
            int valueCount = 0;
 
            foreach (T value in values)
            {
                if (!counts.ContainsKey(value))
                {
                    counts[value] = 0;
                }
                counts[value]++;
                valueCount++;
            }
 
            foreach (T value in counts.Keys)
            {
                var node = new HuffmanNode<T>((double) counts[value] / valueCount, value);
                priorityQueue.Add(node);
                _leafDictionary[value] = node;
            }
 
            while (priorityQueue.Count > 1)
            {
                HuffmanNode<T> leftSon = priorityQueue.Pop();
                HuffmanNode<T> rightSon = priorityQueue.Pop();
                var parent = new HuffmanNode<T>(leftSon, rightSon);
                priorityQueue.Add(parent);
            }
 
            _root = priorityQueue.Pop();
            _root.IsZero = false;
        }
 
        public List<int> Encode(T value)
        {
            var returnValue = new List<int>();
            Encode(value, returnValue);
            return returnValue;
        }
 
        public void Encode(T value, List<int> encoding)
        {
            if (!_leafDictionary.ContainsKey(value))
            {
                throw new ArgumentException(""Invalid value in Encode"");
            }
            HuffmanNode<T> nodeCur = _leafDictionary[value];
            var reverseEncoding = new List<int>();
            while (!nodeCur.IsRoot)
            {
                reverseEncoding.Add(nodeCur.Bit);
                nodeCur = nodeCur.Parent;
            }
 
            reverseEncoding.Reverse();
            encoding.AddRange(reverseEncoding);
        }
 
        public List<int> Encode(IEnumerable<T> values)
        {
            var returnValue = new List<int>();
 
            foreach (T value in values)
            {
                Encode(value, returnValue);
            }
            return returnValue;
        }
 
        public T Decode(List<int> bitString, ref int position)
        {
            HuffmanNode<T> nodeCur = _root;
            while (!nodeCur.IsLeaf)
            {
                if (position > bitString.Count)
                {
                    throw new ArgumentException(""Invalid bitstring in Decode"");
                }
                nodeCur = bitString[position++] == 0 ? nodeCur.LeftSon : nodeCur.RightSon;
            }
            return nodeCur.Value;
        }
 
        public List<T> Decode(List<int> bitString)
        {
            int position = 0;
            var returnValue = new List<T>();
 
            while (position != bitString.Count)
            {
                returnValue.Add(Decode(bitString, ref position));
            }
            return returnValue;
        }
    }
 
    internal class Program
    {
        private const string Example = ""this is an example for huffman encoding"";
 
        private static void Main()
        {
            var huffman = new Huffman<char>(Example);
            List<int> encoding = huffman.Encode(Example);
            List<char> decoding = huffman.Decode(encoding);
            var outString = new string(decoding.ToArray());
            Console.WriteLine(outString == Example ? ""Encoding/decoding worked"" : ""Encoding/Decoding failed"");
 
            var chars = new HashSet<char>(Example);
            foreach (char c in chars)
            {
                encoding = huffman.Encode(c);
                Console.Write(""{0}:  "", c);
                foreach (int bit in encoding)
                {
                    Console.Write(""{0}"", bit);
                }
                Console.WriteLine();
            }
            Console.ReadKey();
        }
    }
}",8697,314
46472,http://rosettacode.org/wiki/Horizontal_sundial_calculations,Horizontal sundial calculations,"Task

Create a program that calculates the hour, sun hour angle, dial hour line angle from 6am to 6pm for an operator entered location.



For example, the user is prompted for a location and inputs the latitude and longitude 4°57′S 150°30′W (4.95°S 150.5°W of Jules Verne's Lincoln Island, aka Ernest Legouve Reef), with a legal meridian of 150°W.

(Note: the ""meridian"" is approximately the same concept as the ""longitude"" - the distinction is that the meridian is used to determine when it is ""noon"" for official purposes. This will typically be slightly different from when the sun appears at its highest location, because of the structure of time zones. For most, but not all, time zones (hour wide zones with hour zero centred on Greenwich), the legal meridian will be an even multiple of 15 degrees.)

Wikipedia: A sundial is a device that measures time by the position of the Sun. In common designs such as the horizontal sundial, the sun casts a shadow from its style (also called its Gnomon, a thin rod or a sharp, straight edge) onto a flat surface marked with lines indicating the hours of the day (also called the dial face or dial plate). As the sun moves across the sky, the shadow-edge progressively aligns with different hour-lines on the plate. Such designs rely on the style being aligned with the axis of the Earth's rotation. Hence, if such a sundial is to tell the correct time, the style must point towards true north (not the north or south magnetic pole) and the style's angle with horizontal must equal the sundial's geographical latitude.



",#C.23,C#,"using System;
 
namespace RosettaCode
{
  internal sealed class Program
  {
    private static void Main()
    {
      Func<double> getDouble = () => Convert.ToDouble(Console.ReadLine());
      double h = 0, lat, lng, lme, slat, hra, hla;
 
      Console.Write(""Enter latitude       => "");
      lat = getDouble();
      Console.Write(""Enter longitude      => "");
      lng = getDouble();
      Console.Write(""Enter legal meridian => "");
      lme = getDouble();
 
      slat = Math.Sin(lat*2*Math.PI/360);
      Console.WriteLine(""\n    sine of latitude:   {0:0.000}"", slat);
      Console.WriteLine(""    diff longitude:     {0:0.000}\n"", lng-lme);
      Console.WriteLine(""Hour, sun hour angle, dial hour line angle from 6am to 6pm"");
      for (h = -6; h<6; h++)
      {
        hra = 15*h;
        hra -= lng-lme;
        hla = Math.Atan(slat*Math.Tan(hra*2*Math.PI/360))*360/(2*Math.PI);
        Console.WriteLine(""HR= {0,7:0.000}; HRA {1,7:0.000}; HLA= {2,7:0.000}"", h, hra, hla);
      }
    }
  }
}",1006,32
46537,http://rosettacode.org/wiki/Horner%27s_rule_for_polynomial_evaluation,Horner's rule for polynomial evaluation,"A fast scheme for evaluating a polynomial such as:

 



−
19
+
7
x
−
4

x

2


+
6

x

3





{\displaystyle -19+7x-4x^{2}+6x^{3}\,}


when

 



x
=
3



{\displaystyle x=3\;}

.
is to arrange the computation as follows:

 



(
(
(
(
0
)
x
+
6
)
x
+
(
−
4
)
)
x
+
7
)
x
+
(
−
19
)



{\displaystyle ((((0)x+6)x+(-4))x+7)x+(-19)\;}


And compute the result from the innermost brackets outwards as in this pseudocode:

coefficients := [-19, 7, -4, 6] # list coefficients of all x^0..x^n in order
x := 3
accumulator := 0
for i in length(coefficients) downto 1 do
    # Assumes 1-based indexing for arrays
    accumulator := ( accumulator * x ) + coefficients[i]
done
# accumulator now has the answer

Task Description

Create a routine that takes a list of coefficients of a polynomial in order of increasing powers of x; together with a value of x to compute its value at, and return the value of the polynomial at that value using Horner's rule.
Cf. Formal power series
",#C.23,C#,"using System;
using System.Linq;
 
class Program
{
    static double Horner(double[] coefficients, double variable)
    {
        return coefficients.Reverse().Aggregate(
                (accumulator, coefficient) => accumulator * variable + coefficient);
    }
 
    static void Main()
    {
        Console.WriteLine(Horner(new[] { -19.0, 7.0, -4.0, 6.0 }, 3.0));
    }
}",373,16
46581,http://rosettacode.org/wiki/HTTP,HTTP,"Task

Access and print a URL's content (the located resource) to the console.

There is a separate task for HTTPS Requests.



",#C.23,C#," 
using System;
using System.Text;
using System.Net;
 
class Program
{
    static void Main(string[] args)
    {
        WebClient wc = new WebClient();
        string content = wc.DownloadString(""http://www.google.com"");
        Console.WriteLine(content);
    }
}
 ",267,15
46615,http://rosettacode.org/wiki/History_variables,History variables,"Storing the history of objects in a program is a common task. 
Maintaining the history of an object in a program has traditionally required programmers either to write specific code for handling the historical data, or to use a library which supports history logging.

History variables are variables in a programming language which store not only their current value, but also the values they have contained in the past. Some existing languages do provide support for history variables. However these languages typically have many limits and restrictions on use of history variables.
 

[http://www.bod.com/index.php?id=3435&objk_id=148050 ""History Variables:
The Semantics, Formal Correctness, and Implementation of History Variables
in an Imperative Programming Language"" by Mallon and Takaoka]

Concept also discussed on LtU and Patents.com.

Task
 
Demonstrate History variable support:

 enable history variable support (if needed) 
 define a history variable
 assign three values
 non-destructively display the history
 recall the three values. 

For extra points, if the language of choice does not support history variables,
demonstrate how this might be implemented.



",#C.23,C#,"using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
 
namespace History
{
    class Program
    {
        static void Main(string[] args)
        {
            var h = new HistoryObject();
            h.Value = 5;
            h.Value = ""foo"";
            h.Value += ""bar"";
 
            var history = h.ToArray();
 
            for (int i = 0; i < history.Length; i++)
            {
                Console.Write(""{0}{1}"", history[i], ((i >= history.Length - 1) ? ""\n"" : "" <- ""));
            }
 
            h.Undo();
            h.Undo();
            h.Undo();
 
            Console.WriteLine(h.Value);
        }
 
        private class HistoryObject : IEnumerable<object>
        {
            public HistoryObject()
            {
                _history = new Stack<object>(); // Initiates the history stack.
            }
 
            public object Value
            {
                get // Returns the top value from the history if there is one. Otherwise null.
                {
                    if (_history.Count > 0)
                        return _history.Peek();
                    return null;
                }
                set { _history.Push(value); } // Adds the specified value to the history.
            }
 
            public void Undo()
            {
                if (_history.Count > 0)
                    _history.Pop(); // Removes the current value from the history.
            }
 
            // History stack that will hold all previous values of the object.
            private readonly Stack<object> _history;
 
            public IEnumerator<object> GetEnumerator()
            {
                return _history.GetEnumerator();
            }
 
            IEnumerator IEnumerable.GetEnumerator()
            {
                return GetEnumerator();
            }
        }
    }
}",1868,69
46619,http://rosettacode.org/wiki/Honeycombs,Honeycombs,"The task is to produce a matrix of 20 hexagon shaped widgets in a honeycomb arrangement. The matrix should be arranged in such a manner that there are five
columns of four hexagons. The hexagons in columns one, three and five are aligned horizontally, whereas the hexagons in columns two and four occupy a lower position within the arrangement. Each hexagon should be the same colour, and should
display a unique randomly selected single capital letter on the front. The application should now wait for the user to select a hexagon, either by using a pointing device, or by pressing a key that carries a corresponding letter on a hexagon. For platforms that support pointing devices and keyboards, the application should support both methods of selection. A record of the chosen letters should be maintained and the code should be suitably commented, at the point where the the selected letter has been determined. The selected hexagon should now change colour on the display. The cycle repeats until the user has chosen all of the letters. Note that each letter can only be selected once and previously selected hexagons retain their colour after selection. The program terminates when all letters have been chosen.

Optionally: output the list of selected letters and show the last selected letter, cater for a different number of columns or a different number of hexagons in each column, cater for two players, (turns alternate and the hexagons change a different colour depending on whether they were selected by player one or player two and records of both players selections are maintained.)


",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Shapes;
 
////////////////////////////////////////////////////////////////////////////////////////////////////
// namespace: Honeycombs
//
// summary:	WPF implementation of Rosetta Code Honeycombs task.  Uses Polygon shapes as hexes.
////////////////////////////////////////////////////////////////////////////////////////////////////
 
namespace Honeycombs
{
    public partial class MainWindow
    {
        private const int RowCount = 4;
        private const int ColCount = 5;
        private const int LabelSize = 20;
        private readonly char[] _permutedChars;
 
        public MainWindow()
        {
            if (RowCount * ColCount > 26)
#pragma warning disable 162
            {
                throw new ArgumentException(""Too many cells"");
            }
#pragma warning restore 162
            _permutedChars = GetPermutedChars(RowCount * ColCount);
 
            // VS Generated code not included
            InitializeComponent();
        }
 
        private static char[] GetPermutedChars(int characterCount)
        {
            const string allChars = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
            var rnd = new Random();
            var chars = new char[allChars.Length];
 
            for (int i = 0; i < allChars.Length; i++)
            {
                chars[i] = allChars[i];
            }
 
            for (int i = 0; i < characterCount; i++)
            {
                int swapIndex = rnd.Next() % (allChars.Length - i);
                char tmp = chars[swapIndex + i];
                chars[swapIndex + i] = chars[i];
                chars[i] = tmp;
            }
            return chars;
        }
 
        private void SetHexProperties(UIElementCollection hexes, double cellSize)
        {
            int charIndex = 0;
            List<Polygon> hexList = hexes.Cast<Polygon>().ToList();
 
            foreach (Polygon element in hexList)
            {
                SetHexProperties(element, _permutedChars[charIndex++], cellSize);
            }
        }
 
        private void SetHexProperties(Polygon hex, char charToSet, double cellSize)
        {
            var tag = (Tuple<int, int, double, double>) hex.Tag;
            double cellX = tag.Item3;
            double cellY = tag.Item4;
 
            // We place the text in a grid centered on the hex.
            // The grid will then center the text within itself.
 
            var centeringGrid = new Grid();
            centeringGrid.Width = centeringGrid.Height = 2 * cellSize;
            centeringGrid.SetValue(Canvas.LeftProperty, cellX - cellSize);
            centeringGrid.SetValue(Canvas.TopProperty, cellY - cellSize);
            centeringGrid.IsHitTestVisible = false;
            HoneycombCanvas.Children.Add(centeringGrid);
 
            var label = new TextBlock
                {
                    Text = new string(charToSet, 1),
                    FontFamily = new FontFamily(""Segoe""),
                    FontSize = LabelSize
                };
            label.HorizontalAlignment = HorizontalAlignment.Center;
            label.VerticalAlignment = VerticalAlignment.Center;
            label.IsHitTestVisible = false;
            centeringGrid.Children.Add(label);
 
            // Reset the tag to keep track of the character in the hex
            hex.Tag = charToSet;
            hex.Fill = new SolidColorBrush(Colors.Yellow);
            hex.Stroke = new SolidColorBrush(Colors.Black);
            hex.StrokeThickness = cellSize / 10;
 
            // Mouse down event handler for the hex
            hex.MouseDown += hex_MouseDown;
        }
 
        private void hex_MouseDown(object sender, MouseButtonEventArgs e)
        {
            var hex = sender as Shape;
            if (hex == null)
            {
                throw new InvalidCastException(""Non-shape in Honeycomb"");
            }
 
            // Get the letter for this hex
            var ch = (char) hex.Tag;
 
            // Add it to our Letters TextBlock
            Letters.Text = Letters.Text + ch;
 
            // Color the hex magenta
            hex.Fill = new SolidColorBrush(Colors.Magenta);
 
            // Remove the mouse down event handler so we won't hit on this hex again
            hex.MouseDown -= hex_MouseDown;
        }
 
        private static void GetCombSize(double actualHeight, double actualWidth, int columns, int rows,
                                        out double cellSize, out double combHeight, out double combWidth)
        {
            double columnFactor = (3 * columns + 1) / 2.0;
            double rowFactor = (Math.Sqrt(3) * (2 * rows + 1)) / 2.0;
            double cellFromWidth = actualWidth / columnFactor;
            double cellFromHeight = actualHeight / rowFactor;
            cellSize = Math.Min(cellFromWidth, cellFromHeight);
            combWidth = cellSize * columnFactor;
            combHeight = cellSize * rowFactor;
        }
 
        private static void AddCells(Canvas canvas, double cellSize, int columns, int rows)
        {
            double rowHeight = cellSize * Math.Sqrt(3) / 2;
 
            for (int row = 0; row < rows; row++)
            {
                AddRow(rowHeight, canvas, cellSize, columns, row);
                rowHeight += cellSize * Math.Sqrt(3);
            }
        }
 
        private static void AddRow(double rowHeight, Canvas canvas, double cellSize, int columnCount, int row)
        {
            double cellX = cellSize;
            double cellHeight = cellSize * Math.Sqrt(3);
 
            for (int col = 0; col < columnCount; col++)
            {
                double cellY = rowHeight + ((col & 1) == 1 ? cellHeight / 2 : 0);
                Polygon hex = GetCenteredHex(cellSize, cellX, cellY, cellHeight);
                hex.Tag = Tuple.Create(col, row, cellX, cellY);
                canvas.Children.Add(hex);
                cellX += 3 * cellSize / 2;
            }
        }
 
        private static Polygon GetCenteredHex(double cellSize, double cellX, double cellY, double cellHeight)
        {
            var hex = new Polygon();
            hex.Points.Add(new Point(cellX - cellSize, cellY));
            hex.Points.Add(new Point(cellX - cellSize / 2, cellY + cellHeight / 2));
            hex.Points.Add(new Point(cellX + cellSize / 2, cellY + cellHeight / 2));
            hex.Points.Add(new Point(cellX + cellSize, cellY));
            hex.Points.Add(new Point(cellX + cellSize / 2, cellY - cellHeight / 2));
            hex.Points.Add(new Point(cellX - cellSize / 2, cellY - cellHeight / 2));
            return hex;
        }
 
        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            double combHeight, combWidth, cellSize;
 
            // Get sizes that will fit within our window
            GetCombSize(Main.ActualHeight, Main.ActualWidth, ColCount, RowCount, out cellSize, out combHeight,
                        out combWidth);
 
            // Set the canvas size appropriately
            HoneycombCanvas.Width = combWidth;
            HoneycombCanvas.Height = combHeight;
 
            // Add the cells to the canvas
            AddCells(HoneycombCanvas, cellSize, ColCount, RowCount);
 
            // Set the cells to look like we want them
            SetHexProperties(HoneycombCanvas.Children, cellSize);
        }
    }
}",7497,198
46666,"http://rosettacode.org/wiki/Hofstadter-Conway_$10,000_sequence","Hofstadter-Conway $10,000 sequence","The definition of the sequence is colloquially described as:

   Starting with the list [1,1],
   Take the last number in the list so far: 1, I'll call it x.
   Count forward x places from the beginning of the list to find the first number to add (1)
   Count backward x places from the end of the list to find the second number to add (1)
   Add the two indexed numbers from the list and the result becomes the next number in the list (1+1)
   This would then produce [1,1,2] where 2 is the third element of the sequence.

Note that indexing for the description above starts from alternately the left and right ends of the list and starts from an index of one.

A less wordy description of the sequence is:

   a(1)=a(2)=1
   a(n)=a(a(n-1))+a(n-a(n-1))

The sequence begins:

   1, 1, 2, 2, 3, 4, 4, 4, 5, ...

Interesting features of the sequence are that:

   a(n)/n   tends to   0.5   as   n   grows towards infinity.
   a(n)/n   where   n   is a power of   2   is   0.5
   For   n>4   the maximal value of   a(n)/n   between successive powers of 2 decreases.



The sequence is so named because John Conway offered a prize of $10,000 to the first person who could
find the first position,   p   in the sequence where

   │a(n)/n│ < 0.55  for all  n > p

It was later found that Hofstadter had also done prior work on the sequence.

The 'prize' was won quite quickly by Dr. Colin L. Mallows who proved the properties of the sequence and allowed him to find the value of   n   (which is much smaller than the 3,173,375,556 quoted in the NYT article).



Task

   Create a routine to generate members of the Hofstadter-Conway $10,000 sequence.
   Use it to show the maxima of   a(n)/n   between successive powers of two up to   2**20
   As a stretch goal:   compute the value of   n   that would have won the prize and confirm it is true for   n   up to 2**20


Also see

   Conways Challenge Sequence, Mallows' own account.
   Mathworld Article.

",#C.23,C#," 
using System;
using System.Linq;
 
namespace HofstadterConway
{
    class Program
    {
        static int[] GenHofstadterConway(int max)
        {
            int[] result = new int[max];
            result[0]=result[1]=1;
            for (int ix = 2; ix < max; ix++)
                result[ix] = result[result[ix - 1] - 1] + result[ix - result[ix - 1]];
            return result;
        }
 
        static void Main(string[] args)
        {
            double[] adiv = new double[1 << 20];
            {
                int[] a = GenHofstadterConway(1 << 20);
                for (int i = 0; i < 1 << 20; i++)
                    adiv[i] = a[i] / (double)(i + 1);
            }
            for (int p = 2; p <= 20; p++)
            {
                var max = Enumerable.Range(
                     (1 << (p - 1)) - 1,
                     (1 << p) - (1 << (p - 1))
                     )
                     .Select(ix => new { I = ix + 1, A = adiv[ix] })
                     .OrderByDescending(x => x.A)
                     .First();
                Console.WriteLine(""Maximum from 2^{0} to 2^{1} is {2} at {3}"",
                    p - 1, p, max.A, max.I);
            }
            Console.WriteLine(""The winning number is {0}."",
                Enumerable.Range(0, 1 << 20)
                    .Last(i => (adiv[i] > 0.55)) + 1
                );
        }
    }
}
 ",1379,45
46676,http://rosettacode.org/wiki/Holidays_related_to_Easter,Holidays related to Easter,"Task

Calculate the dates of:

   Easter
   Ascension Thursday
   Pentecost
   Trinity Sunday
   Corpus Christi feast (for Catholic)
   All Saints' Sunday (for Orthodox)


As an example, calculate for the first year of each century from;

   years     400   to   2100 CE   and for 
   years   2010   to   2020 CE.
Note

From the year 325 CE on,   Easter Sunday   has been defined as the first Sunday after the first full moon on or after the day of the March equinox. However, the actual astronomical values for the moments of the full moon and equinox are not used. Instead, approximations are used, the first one being that the equinox is assumed to fall on March 21st every year. The tracking of the moon phases is similarly done with relatively straightforward arithmetic (compared to the sort required for astronomical accuracy) which amounts to maintaining a lunisolar calendar in parallel to our standard purely-solar one.

When Pope Gregory reformed the Catholic calendar in 1582 CE, the drifting of Easter with respect to the seasons was the driving motivation, and the rules for determining it (called the computus) were altered to correct that drift. Catholic nations adopted both the new calendar and the new computus right away, while Western Protestant nations adopted them more gradually over the next 350 years or so. Eventually, even nations dominated by the Eastern Orthodox church adopted a similar calendar reform (the Revised Julian calendar), so pretty much the whole world agrees on what day it is for civil purposes. But the Eastern churches never adopted the corresponding Easter rule changes; they still use the original Julian calendar and computus to determine the date of what is known in the West as ""Orthodox Easter"". Therefore, your output should indicate which computus was used to calculate the dates and, at least for historical dates where the calendar can't be assumed or is location-dependent, which calendar those dates are given in.

You may find algorithms on the Computus Wikipedia page. Some of the results:

In the year 400 CE, Easter Sunday was April 1st (in the contemporary Julian calendar), making Ascension Thursday May 10th and Pentecost May 20th. It is ahistorical to give a date so far back for either Trinity Sunday or Corpus Christi, neither of which were observed until centuries later, but they would have been May 27th and 31st. If you extend the modern civil calendar back that far, those days are instead assigned the subsequent dates: Easter on April 2nd, Ascension on May 11th, Pentecost on May 21st.

Skipping forward to the year 2100 CE, assuming the rules don't change between now and then, the Western churches will observe Easter on March 28, Ascension Thursday May 6th, Pentecost May 16th, Trinity Sunday May 23rd and Corpus Christi May 27th. Heading East, the Orthodox rules place Easter on April 18 in the original Julian calendar; the corresponding civil date is May 2nd. That puts the Ascension on June 10th and Pentecost June 20th. Orthodox Trinity Sunday is the same day as Pentecost, but they observe All Saints' Sunday the following week, June 27th. Corpus Christi is a purely Catholic date that has no Orthodox version.

Test values of Easter dates



 Year

 Orthodox

 Catholic

 Calendar


400

01 Apr

 —

Jul.


800

19 Apr

 —

Jul.


1200

09 Apr

 —

Jul.


2000

30 Apr

23 Apr

Gr.


2020

19 Apr

12 Apr

Gr.


",#C.23,C#,"using System;
using System.Collections;
using System.Collections.Specialized;
using System.Linq;
 
internal class Program
{
    private static readonly OrderedDictionary _holidayOffsets = new OrderedDictionary
                                                                    {
                                                                        {""Easter"", 0},
                                                                        {""Ascension"", 39},
                                                                        {""Pentecost"", 49},
                                                                        {""Trinity"", 56},
                                                                        {""Corpus"", 60},
                                                                    };
 
    static void Main(string[] args)
    {
        Console.WriteLine(""Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:"");
        for (int year = 400; year <= 2100; year += 100)
            OutputHolidays(year);
 
        Console.WriteLine();
        Console.WriteLine(""Christian holidays, related to Easter, for years from 2010 to 2020 CE:"");
        for (int year = 2010; year <= 2020; year += 1)
            OutputHolidays(year);
    }
 
    static void OutputHolidays(int year)
    {
        var easter = CalculateEaster(year);
        var holidays = from kp in _holidayOffsets.OfType<DictionaryEntry>()
                       let holiday = easter.AddDays(Convert.ToInt32(kp.Value))
                       select kp.Key + "": "" + string.Format(""{0,2:ddd} {0,2:%d} {0:MMM}"", holiday);
        Console.WriteLine(""{0,4} {1}"", year, string.Join("", "", holidays.ToArray()));
    }
 
    static DateTime CalculateEaster(int year)
    {
        var a = year % 19;
        var b = year / 100;
        var c = year %100;
        var d = b / 4;
        var e = b % 4;
        var f = (b + 8) / 25;
        var g = (b - f + 1) / 3;
        var h = (19 * a + b - d - g + 15) % 30;
        var i = c / 4;
        var k = c % 4;
        var l = (32 + 2 * e + 2 * i - h - k) % 7;
        var m = (a + 11 * h + 22 * l) / 451;
        var numerator = h + l - 7 * m + 114;
        var month = numerator / 31;
        var day = (numerator % 31) + 1;
        return new DateTime(year, month, day);
    }
}
 ",2318,58
46698,http://rosettacode.org/wiki/Hofstadter_Figure-Figure_sequences,Hofstadter Figure-Figure sequences,"These two sequences of positive integers are defined as:

 







R
(
1
)



=
1
 
;
 
S
(
1
)
=
2




R
(
n
)



=
R
(
n
−
1
)
+
S
(
n
−
1
)
,

n
>
1.






{\displaystyle {\begin{aligned}R(1)&=1\ ;\ S(1)=2\\R(n)&=R(n-1)+S(n-1),\quad n>1.\end{aligned}}}




The sequence 



S
(
n
)


{\displaystyle S(n)}

 is further defined as the sequence of positive integers not present in 



R
(
n
)


{\displaystyle R(n)}

.

Sequence 



R


{\displaystyle R}

 starts:

   1, 3, 7, 12, 18, ...

Sequence 



S


{\displaystyle S}

 starts:

   2, 4, 5, 6, 8, ...



Task

 Create two functions named ffr and ffs that when given n return R(n) or S(n) respectively.
(Note that R(1) = 1 and S(1) = 2 to avoid off-by-one errors).
 No maximum value for n should be assumed.
 Calculate and show that the first ten values of R are:
 1, 3, 7, 12, 18, 26, 35, 45, 56, and 69
 Calculate and show that the first 40 values of ffr plus the first 960 values of ffs include all the integers from 1 to 1000 exactly once.


References

 Sloane's A005228 and A030124.
 Wolfram MathWorld
 Wikipedia: Hofstadter Figure-Figure sequences.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace HofstadterFigureFigure
{
	class HofstadterFigureFigure
	{
		readonly List<int> _r = new List<int>() {1};
		readonly List<int> _s = new List<int>();
 
		public IEnumerable<int> R()
		{
			int iR = 0;
			while (true)
			{
				if (iR >= _r.Count)
				{
					Advance();
				}
				yield return _r[iR++];
			}
		}
 
		public IEnumerable<int> S()
		{
			int iS = 0;
			while (true)
			{
				if (iS >= _s.Count)
				{
					Advance();
				}
				yield return _s[iS++];
			}
		}
 
		private void Advance()
		{
			int rCount = _r.Count;
			int oldR = _r[rCount - 1];
			int sVal;
 
			// Take care of first two cases specially since S won't be larger than R at that point
			switch (rCount)
			{
				case 1:
					sVal = 2;
					break;
				case 2:
					sVal = 4;
					break;
				default:
					sVal = _s[rCount - 1];
					break;
			}
			_r.Add(_r[rCount - 1] + sVal);
			int newR = _r[rCount];
			for (int iS = oldR + 1; iS < newR; iS++)
			{
				_s.Add(iS);
			}
		}
	}
 
	class Program
	{
		static void Main()
		{
			var hff = new HofstadterFigureFigure();
			var rs = hff.R();
			var arr = rs.Take(40).ToList();
 
			foreach(var v in arr.Take(10))
			{
				Console.WriteLine(""{0}"", v);
			}
 
			var hs = new HashSet<int>(arr);
			hs.UnionWith(hff.S().Take(960));
			Console.WriteLine(hs.Count == 1000 ? ""Verified"" : ""Oops!  Something's wrong!"");
		}
	}
}
 ",1425,85
46701,http://rosettacode.org/wiki/Hilbert_curve,Hilbert curve,"

Task
Produce a graphical or ASCII-art representation of a Hilbert curve of at least order 3.
",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
 
namespace HilbertCurve {
    class Program {
        static void Swap<T>(ref T a, ref T b) {
            var c = a;
            a = b;
            b = c;
        }
 
        struct Point {
            public int x, y;
 
            public Point(int x, int y) {
                this.x = x;
                this.y = y;
            }
 
            //rotate/flip a quadrant appropriately
            public void Rot(int n, bool rx, bool ry) {
                if (!ry) {
                    if (rx) {
                        x = (n - 1) - x;
                        y = (n - 1) - y;
                    }
                    Swap(ref x, ref y);
                }
            }
 
            public override string ToString() {
                return string.Format(""({0}, {1})"", x, y);
            }
        }
 
        static Point FromD(int n, int d) {
            var p = new Point(0, 0);
            int t = d;
 
            for (int s = 1; s < n; s <<= 1) {
                var rx = (t & 2) != 0;
                var ry = ((t ^ (rx ? 1 : 0)) & 1) != 0;
                p.Rot(s, rx, ry);
                p.x += rx ? s : 0;
                p.y += ry ? s : 0;
                t >>= 2;
            }
 
            return p;
        }
 
        static List<Point> GetPointsForCurve(int n) {
            var points = new List<Point>();
            int d = 0;
            while (d < n * n) {
                points.Add(FromD(n, d));
                d += 1;
            }
            return points;
        }
 
        static List<string> DrawCurve(List<Point> points, int n) {
            var canvas = new char[n, n * 3 - 2];
            for (int i = 0; i < canvas.GetLength(0); i++) {
                for (int j = 0; j < canvas.GetLength(1); j++) {
                    canvas[i, j] = ' ';
                }
            }
 
            for (int i = 1; i < points.Count; i++) {
                var lastPoint = points[i - 1];
                var curPoint = points[i];
                var deltaX = curPoint.x - lastPoint.x;
                var deltaY = curPoint.y - lastPoint.y;
                if (deltaX == 0) {
                    Debug.Assert(deltaY != 0, ""Duplicate point"");
                    //vertical line
                    int row = Math.Max(curPoint.y, lastPoint.y);
                    int col = curPoint.x * 3;
                    canvas[row, col] = '|';
                } else {
                    Debug.Assert(deltaY == 0, ""Duplicate point"");
                    //horizontal line
                    var row = curPoint.y;
                    var col = Math.Min(curPoint.x, lastPoint.x) * 3 + 1;
                    canvas[row, col] = '_';
                    canvas[row, col + 1] = '_';
                }
            }
 
            var lines = new List<string>();
            for (int i = 0; i < canvas.GetLength(0); i++) {
                var sb = new StringBuilder();
                for (int j = 0; j < canvas.GetLength(1); j++) {
                    sb.Append(canvas[i, j]);
                }
                lines.Add(sb.ToString());
            }
            return lines;
        }
 
        static void Main() {
            for (int order = 1; order <= 5; order++) {
                var n = 1 << order;
                var points = GetPointsForCurve(n);
                Console.WriteLine(""Hilbert curve, order={0}"", order);
                var lines = DrawCurve(points, n);
                foreach (var line in lines) {
                    Console.WriteLine(line);
                }
                Console.WriteLine();
            }
        }
    }
}",3664,117
46826,http://rosettacode.org/wiki/Hofstadter_Q_sequence,Hofstadter Q sequence,"Hofstadter Q sequence


 







Q
(
1
)



=
Q
(
2
)
=
1
,




Q
(
n
)



=
Q


(


n
−
Q
(
n
−
1
)


)


+
Q


(


n
−
Q
(
n
−
2
)


)


,

n
>
2.






{\displaystyle {\begin{aligned}Q(1)&=Q(2)=1,\\Q(n)&=Q{\big (}n-Q(n-1){\big )}+Q{\big (}n-Q(n-2){\big )},\quad n>2.\end{aligned}}}




It is defined like the Fibonacci sequence, but whereas the next term in the Fibonacci sequence is the sum of the previous two terms, in the Q sequence the previous two terms tell you how far to go back in the Q sequence to find the two numbers to sum to make the next term of the sequence.



Task

 Confirm and display that the first ten terms of the sequence are: 1, 1, 2, 3, 3, 4, 5, 5, 6, and 6 
 Confirm and display that the 1000th term is:   502


Optional extra credit
 Count and display how many times a member of the sequence is less than its preceding term for terms up to and including the 100,000th term.
 Ensure that the extra credit solution   safely   handles being initially asked for an nth term where   n   is large.

(This point is to ensure that caching and/or recursion limits, if it is a concern, is correctly handled).



",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace HofstadterQSequence
{
    class Program
    {
        // Initialize the dictionary with the first two indices filled.
        private static readonly Dictionary<int, int> QList = new Dictionary<int, int>
                                                                 {
                                                                     {1, 1},
                                                                     {2, 1}
                                                                 };
 
        private static void Main()
        {
            int lessThanLast = 0;
                /* Initialize our variable that holds the number of times
                                   * a member of the sequence was less than its preceding term. */
 
            for (int n = 1; n <= 100000; n++)
            {
                int q = Q(n); // Get Q(n).
 
                if (n > 1 && QList[n - 1] > q) // If Q(n) is less than Q(n - 1),
                    lessThanLast++;            // then add to the counter.
 
                if (n > 10 && n != 1000) continue; /* If n is greater than 10 and not 1000,
                                                    * the rest of the code in the loop does not apply,
                                                    * and it will be skipped. */
 
                if (!Confirm(n, q)) // Confirm Q(n) is correct.
                    throw new Exception(string.Format(""Invalid result: Q({0}) != {1}"", n, q));
 
                Console.WriteLine(""Q({0}) = {1}"", n, q); // Write Q(n) to the console.
            }
 
            Console.WriteLine(""Number of times a member of the sequence was less than its preceding term: {0}."",
                              lessThanLast);
        }
 
        private static bool Confirm(int n, int value)
        {
            if (n <= 10)
                return new[] {1, 1, 2, 3, 3, 4, 5, 5, 6, 6}[n - 1] == value;
            if (n == 1000)
                return 502 == value;
            throw new ArgumentException(""Invalid index."", ""n"");
        }
 
        private static int Q(int n)
        {
            int q;
 
            if (!QList.TryGetValue(n, out q)) // Try to get Q(n) from the dictionary.
            {
                q = Q(n - Q(n - 1)) + Q(n - Q(n - 2)); // If it's not available, then calculate it.
                QList.Add(n, q); // Add it to the dictionary.
            }
 
            return q;
        }
    }
}",2473,64
46909,http://rosettacode.org/wiki/Here_document,Here document,"A   here document   (or ""heredoc"")   is a way of specifying a text block, preserving the line breaks, indentation and other whitespace within the text.

Depending on the language being used, a   here document   is constructed using a command followed by ""<<"" (or some other symbol) followed by a token string.

The text block will then start on the next line, and will be followed by the chosen token at the beginning of the following line, which is used to mark the end of the text block.



Task

Demonstrate the use of   here documents   within the language.

Related task

   Documentation

",#C.23,C#,"using System;
 
class Program
{
    static void Main(string[] args)
    {
        Console.Write(@""
multiline
strings are easy
to put together
in C#"");
    }
}",158,13
46943,http://rosettacode.org/wiki/Hello_world/Web_server,Hello world/Web server,"The browser is the new GUI !



Task

Serve our standard text   Goodbye, World!   to   http://localhost:8080/   so that it can be viewed with a web browser.

The provided solution must start or implement a server that accepts multiple client connections and serves text as requested.

Note that starting a web browser or opening a new window with this URL
is not part of the task.

Additionally, it is permissible to serve the provided page as a plain text file (there is no requirement to serve properly formatted HTML here).

The browser will generally do the right thing with simple text like this.



",#C.23,C#,"using System.Text;
using System.Net.Sockets;
using System.Net;
 
namespace WebServer
{
    class GoodByeWorld
    {        
        static void Main(string[] args)
        {
            const string msg = ""<html>\n<body>\nGoodbye, world!\n</body>\n</html>\n"";        
            const int port = 8080;
            bool serverRunning = true;
 
            TcpListener tcpListener = new TcpListener(IPAddress.Any, port);
            tcpListener.Start();
 
            while (serverRunning)
            {
                Socket socketConnection = tcpListener.AcceptSocket();
                byte[] bMsg = Encoding.ASCII.GetBytes(msg.ToCharArray(), 0, (int)msg.Length);
                socketConnection.Send(bMsg);
                socketConnection.Disconnect(true);
            }
        }
    }
}",794,27
47015,http://rosettacode.org/wiki/Heronian_triangles,Heronian triangles,"Hero's formula for the area of a triangle given the length of its three sides    a,   b,   and   c   is given by:

 



A
=


s
(
s
−
a
)
(
s
−
b
)
(
s
−
c
)


,


{\displaystyle A={\sqrt {s(s-a)(s-b)(s-c)}},}


where   s   is half the perimeter of the triangle; that is,

 



s
=



a
+
b
+
c

2


.


{\displaystyle s={\frac {a+b+c}{2}}.}



Heronian triangles
are triangles whose sides and area are all integers.

 An example is the triangle with sides   3, 4, 5   whose area is   6   (and whose perimeter is   12). 


Note that any triangle whose sides are all an integer multiple of   3, 4, 5;   such as   6, 8, 10,   will also be a Heronian triangle.

Define a Primitive Heronian triangle as a Heronian triangle where the greatest common divisor
of all three sides is   1   (unity).

This will exclude, for example, triangle   6, 8, 10.



Task

 Create a named function/method/procedure/... that implements Hero's formula.
 Use the function to generate all the primitive Heronian triangles with sides <= 200.
 Show the count of how many triangles are found.
 Order the triangles by first increasing area, then by increasing perimeter, then by increasing maximum side lengths
 Show the first ten ordered triangles in a table of sides, perimeter, and area.
 Show a similar ordered table for those triangles with area = 210


Show all output here.

Note: when generating triangles it may help to restrict 



a
<=
b
<=
c


{\displaystyle a<=b<=c}


",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace heron
{
    class Program{
        static void Main(string[] args){           
            List<int[]> list = new List<int[]>();
            for (int c = 1; c <= 200; c++)
                for (int b = 1; b <= c; b++)
                    for (int a = 1; a <= b; a++)
                        if (gcd(a, gcd(b, c)) == 1 && isHeron(heronArea(a, b, c)))
                            list.Add(new int[] { a, b, c, a + b + c, (int)heronArea(a, b, c)});
            sort(list);
            Console.WriteLine(""Number of primitive Heronian triangles with sides up to 200: "" + list.Count + ""\n\nFirst ten when ordered by increasing area, then perimeter,then maximum sides:\nSides\t\t\tPerimeter\tArea"");
            for(int i = 0; i < 10; i++)
                Console.WriteLine(list[i][0] + ""\t"" + list[i][1] + ""\t"" + list[i][2] + ""\t"" + list[i][3] + ""\t\t"" + list[i][4]);
            Console.WriteLine(""\nPerimeter = 210\nSides\t\t\tPerimeter\tArea"");
            foreach (int[] i in list)
                if (i[4] == 210)
                    Console.WriteLine(i[0] + ""\t"" + i[1] + ""\t"" + i[2] + ""\t"" + i[3] + ""\t\t"" + i[4]);     
        }
        static bool isHeron(double heronArea){
            return heronArea % 1 == 0 && heronArea != 0;
        }
        static double heronArea(int a, int b, int c){
            double s = (a + b + c) / 2d;
            return Math.Sqrt(s * (s - a) * (s - b) * (s - c));
        }
        static int gcd(int a, int b){
            int remainder = 1, dividend, divisor;
            dividend = a > b ? a : b;
            divisor = a > b ? b : a;
            while (remainder != 0){
                remainder = dividend % divisor;
                if (remainder != 0){
                    dividend = divisor;
                    divisor = remainder;
                }
            }
            return divisor;
        }
        static void sort(List<int[]> list){
            int[] temp = new int[5];
            bool changed = true;
            while(changed){
                changed = false;
                for (int i = 1; i < list.Count; i++)
                    if (list[i][4] < list[i - 1][4] || list[i][4] == list[i - 1][4] && list[i][3] < list[i - 1][3]){
                        temp = list[i];
                        list[i] = list[i - 1];
                        list[i - 1] = temp;
                        changed = true;
                    }                
            }
        }
    }
}",2492,58
47044,http://rosettacode.org/wiki/Hello_world/Standard_error,Hello world/Standard error,"Hello world/Standard error is part of Short Circuit's Console Program Basics selection.
A common practice in computing is to send error messages
to a different output stream than normal text console messages.

The normal messages print to what is called ""standard output"" or ""standard out"".

The error messages print to ""standard error"".

This separation can be used to redirect error messages to a different place than normal messages.



Task

Show how to print a message to standard error by printing     Goodbye, World!     on that stream.



",#C.23,C#,"static class StdErr
{
    static void Main(string[] args)
    {
        Console.Error.WriteLine(""Goodbye, World!"");
    }
}",123,7
47379,http://rosettacode.org/wiki/Higher-order_functions,Higher-order functions,"Task

Pass a function     as an argument     to another function.



Related task

   First-class functions

",#C.23,C#,"f=Add, f(6, 2) = 8
f=Mul, f(6, 2) = 12
f=Div, f(6, 2) = 3
",58,4
48047,http://rosettacode.org/wiki/Hello_world/Text,Hello world/Text,"Hello world/Text is part of Short Circuit's Console Program Basics selection.
Task

Display the string Hello world! on a text console.

Related tasks

   Hello world/Graphical
   Hello world/Line Printer
   Hello world/Newbie
   Hello world/Newline omission
   Hello world/Standard error
   Hello world/Web server

",#C.23,C#,"namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            System.Console.WriteLine(""Hello world!"");
        }
    }
}",168,10
48111,http://rosettacode.org/wiki/Hello_world/Line_printer,Hello world/Line printer,"Task

Cause a line printer attached to the computer to print a line containing the message:    Hello World! 



Note

A line printer is not the same as standard output.

A   line printer   was an older-style printer which prints one line at a time to a continuous ream of paper.

With some systems, a line printer can be any device attached to an appropriate port (such as a parallel port).



",#C.23,C#," 
[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
public class DOCINFOA
{
    [MarshalAs(UnmanagedType.LPStr)]
    public string pDocName;
    [MarshalAs(UnmanagedType.LPStr)]
    public string pOutputFile;
    [MarshalAs(UnmanagedType.LPStr)]
    public string pDataType;
}
 
[DllImport(""winspool.Drv"", EntryPoint = ""OpenPrinterA"", CharSet = CharSet.Ansi, ExactSpelling = true)]
public static extern bool OpenPrinter([MarshalAs(UnmanagedType.LPStr)] string szPrinter, out IntPtr hPrinter, IntPtr pd);
 
[DllImport(""winspool.Drv"", EntryPoint = ""StartDocPrinterA"", CharSet = CharSet.Ansi, ExactSpelling = true)]
public static extern bool StartDocPrinter(IntPtr hPrinter, int level, [In, MarshalAs(UnmanagedType.LPStruct)] DOCINFOA di);
 
[DllImport(""winspool.Drv"", EntryPoint = ""StartPagePrinter"", CharSet = CharSet.Ansi, ExactSpelling = true)]
public static extern bool StartPagePrinter(IntPtr hPrinter);
 
[DllImport(""winspool.Drv"", EntryPoint = ""EndPagePrinter"", CharSet = CharSet.Ansi, ExactSpelling = true)]
public static extern bool EndPagePrinter(IntPtr hPrinter);
 
[DllImport(""winspool.Drv"", EntryPoint = ""EndDocPrinter"", CharSet = CharSet.Ansi, ExactSpelling = true)]
public static extern bool EndDocPrinter(IntPtr hPrinter);
 
[DllImport(""winspool.Drv"", EntryPoint = ""ClosePrinter"", CharSet = CharSet.Ansi, ExactSpelling = true)]
public static extern bool ClosePrinter(IntPtr hPrinter);
 
[DllImport(""winspool.Drv"", EntryPoint = ""WritePrinter"", CharSet = CharSet.Ansi, ExactSpelling = true)]
public static extern bool WritePrinter(IntPtr hPrinter, IntPtr pBytes, Int32 dwCount, out Int32 dwWritten);
 
public void HelloWorld()
{
    IntPtr hPrinter;
    bool openSuccessful = OpenPrinter(""My Printer"", out hPrinter, IntPtr.Zero);
    if (openSuccessful)
    {
        DOCINFOA docInfo = new DOCINFOA();
        docInfo.pDocName = ""Hello World Example"";
        docInfo.pOutputFile = null;
        docInfo.pDataType = ""RAW"";
 
        if (StartDocPrinter(hPrinter, 1, docInfo))
        {
            StartPagePrinter(hPrinter);
 
            const string helloWorld = ""Hello World!"";
            IntPtr buf = Marshal.StringToCoTaskMemAnsi(helloWorld);
 
            int bytesWritten;
            WritePrinter(hPrinter, buf, helloWorld.Length, out bytesWritten);
 
            Marshal.FreeCoTaskMem(buf);
        }
        if (EndPagePrinter(hPrinter))
            if (EndDocPrinter(hPrinter))
                ClosePrinter(hPrinter);
    }
}",2463,61
48172,http://rosettacode.org/wiki/Hash_join,Hash join,"An inner join is an operation that combines two data tables into one table, based on matching column values. The simplest way of implementing this operation is the nested loop join algorithm, but a more scalable alternative is the hash join algorithm.

Task[edit]
Implement the ""hash join"" algorithm, and demonstrate that it passes the test-case listed below.

You should represent the tables as data structures that feel natural in your programming language.

Guidance
The ""hash join"" algorithm consists of two steps:

 Hash phase: Create a multimap from one of the two tables, mapping from each join column value to all the rows that contain it.

 The multimap must support hash-based lookup which scales better than a simple linear search, because that's the whole point of this algorithm.
 Ideally we should create the multimap for the smaller table, thus minimizing its creation time and memory size.
 Join phase: Scan the other table, and find matching rows by looking in the multimap created before.


In pseudo-code, the algorithm could be expressed as follows:

let A = the first input table (or ideally, the larger one)
let B = the second input table (or ideally, the smaller one)
let jA = the join column ID of table A
let jB = the join column ID of table B
let MB = a multimap for mapping from single values to multiple rows of table B (starts out empty)
let C = the output table (starts out empty)

for each row b in table B:
   place b in multimap MB under key b(jB)

for each row a in table A:
   for each row b in multimap MB under key a(jA):
      let c = the concatenation of row a and row b
      place row c in table C

Test-case


 Input

 Output





 A =




 Age 
 Name


 27 
 Jonah


 18 
 Alan


 28 
 Glory


 18 
 Popeye


 28 
 Alan




 B =




 Character 
 Nemesis


 Jonah 
 Whales


 Jonah 
 Spiders


 Alan 
 Ghosts


 Alan 
 Zombies


 Glory 
 Buffy



 jA =

 Name (i.e. column 1)

 jB =

 Character (i.e. column 0)





 A.Age 
 A.Name 
 B.Character 
 B.Nemesis


 27 
 Jonah 
 Jonah 
 Whales


 27 
 Jonah 
 Jonah 
 Spiders


 18 
 Alan 
 Alan 
 Ghosts


 18 
 Alan 
 Alan 
 Zombies


 28 
 Glory 
 Glory 
 Buffy


 28 
 Alan 
 Alan 
 Ghosts


 28 
 Alan 
 Alan 
 Zombies


The order of the rows in the output table is not significant.

If you're using numerically indexed arrays to represent table rows (rather than referring to columns by name), you could represent the output rows in the form [[27, ""Jonah""], [""Jonah"", ""Whales""]].



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace HashJoin
{
    public class AgeName
    {
        public AgeName(byte age, string name)
        {
            Age = age;
            Name = name;
        }
        public byte Age { get; private set; }
        public string Name { get; private set; }
    }
 
    public class NameNemesis
    {
        public NameNemesis(string name, string nemesis)
        {
            Name = name;
            Nemesis = nemesis;
        }
        public string Name { get; private set; }
        public string Nemesis { get; private set; }
    }
 
    public class DataContext
    {
        public DataContext()
        {
            AgeName = new List<AgeName>();
            NameNemesis = new List<NameNemesis>();
        }
        public List<AgeName> AgeName { get; set; }
        public List<NameNemesis> NameNemesis { get; set; }
    }
 
    public class AgeNameNemesis
    {
        public AgeNameNemesis(byte age, string name, string nemesis)
        {
            Age = age;
            Name = name;
            Nemesis = nemesis;
        }
        public byte Age { get; private set; }
        public string Name { get; private set; }
        public string Nemesis { get; private set; }
    }
 
    class Program
    {
        public static void Main()
        {
            var data = GetData();
            var result = ExecuteHashJoin(data);
            WriteResultToConsole(result);
        }
 
        private static void WriteResultToConsole(List<AgeNameNemesis> result)
        {
            result.ForEach(ageNameNemesis => Console.WriteLine(""Age: {0}, Name: {1}, Nemesis: {2}"",
                ageNameNemesis.Age, ageNameNemesis.Name, ageNameNemesis.Nemesis));
        }
 
        private static List<AgeNameNemesis> ExecuteHashJoin(DataContext data)
        {
            return (data.AgeName.Join(data.NameNemesis, 
                ageName => ageName.Name, nameNemesis => nameNemesis.Name,
                (ageName, nameNemesis) => new AgeNameNemesis(ageName.Age, ageName.Name, nameNemesis.Nemesis)))
                .ToList();
        }
 
        private static DataContext GetData()
        {
            var context = new DataContext();
 
            context.AgeName.AddRange(new [] {
                    new AgeName(27, ""Jonah""), 
                    new AgeName(18, ""Alan""), 
                    new AgeName(28, ""Glory""), 
                    new AgeName(18, ""Popeye""), 
                    new AgeName(28, ""Alan"")
                });
 
            context.NameNemesis.AddRange(new[]
            {
                new NameNemesis(""Jonah"", ""Whales""),
                new NameNemesis(""Jonah"", ""Spiders""),
                new NameNemesis(""Alan"", ""Ghosts""),
                new NameNemesis(""Alan"", ""Zombies""),
                new NameNemesis(""Glory"", ""Buffy"")
            });
 
            return context;
        }
    }
}",2911,100
48226,http://rosettacode.org/wiki/Hello_world/Newbie,Hello world/Newbie,"Task

Guide a new user of a language through the steps necessary
to install the programming language and selection of a text editor if needed,
to run the languages' example in the Hello world/Text task.

 Assume the language-newbie is a programmer in another language.
 Assume the language-newbie is competent in installing software for the platform.
 Assume the language-newbie can use one simple text editor for the OS/platform, (but that may not necessarily be a particular one if the installation needs a particular editor).
 Refer to, (and link to), already existing documentation as much as possible (but provide a summary here).
 Remember to state where to view the output.
 If particular IDE's or editors are required that are not standard, then point to/explain their installation too.


Note:
 If it is more natural for a language to give output via a GUI or to a file etc, then use that method of output rather than as text to a terminal/command-line, but remember to give instructions on how to view the output generated.
 You may use sub-headings if giving instructions for multiple platforms.

",#C.23,C#,"#include <iostream>
int main() {
    using namespace std;
    cout << ""Hello, World!"" << endl;
    return 0;
}",110,6
48315,http://rosettacode.org/wiki/Hash_from_two_arrays,Hash from two arrays,"Task

Using two Arrays of equal length, create a Hash object
where the elements from one array (the keys) are linked
to the elements of the other (the values)



Related task

   Associative arrays/Creation

",#C.23,C#,"static class Program
{
    static void Main()
    {
        System.Collections.Hashtable h = new System.Collections.Hashtable();
 
        string[] keys = { ""foo"", ""bar"", ""val"" };
        string[] values = { ""little"", ""miss"", ""muffet"" };
 
        System.Diagnostics.Trace.Assert(keys.Length == values.Length, ""Arrays are not same length."");
 
        for (int i = 0; i < keys.Length; i++)
        {
            h.Add(keys[i], values[i]);
        }
    }
}",456,17
48386,http://rosettacode.org/wiki/Hello_world/Newline_omission,Hello world/Newline omission,"Some languages automatically insert a newline after outputting a string, unless measures are taken to prevent its output.



Task

Display the string   Goodbye, World!   without a trailing newline.



Related tasks

   Hello world/Graphical
   Hello world/Line Printer
   Hello world/Standard error
   Hello world/Text

",#C.23,C#,"using System;
 
class Program
{
    static void Main(string[] args)
    {
        //Using Console.WriteLine() will append a newline
        Console.WriteLine(""Goodbye, World!"");
 
        //Using Console.Write() will not append a newline
        Console.Write(""Goodbye, World!"");
    }
}",287,13
48450,http://rosettacode.org/wiki/Harshad_or_Niven_series,Harshad or Niven series,"The Harshad or Niven numbers are positive integers ≥ 1 that are divisible by the sum of their digits.

For example,   42   is a Harshad number as   42   is divisible by   (4 + 2)   without remainder.

Assume that the series is defined as the numbers in increasing order.



Task

The task is to create a function/method/procedure to generate successive members of the Harshad sequence.

Use it to:

   list the first 20 members of the sequence,   and
   list the first Harshad number greater than 1000.


Show your output here.



Related task
   Increasing gaps between consecutive Niven numbers


See also
    OEIS: A005349

",#C.23,C#," 
using System;
using System.Collections.Generic;
 
namespace Harshad
{
    class Program
    {
        public static bool IsHarshad(int n)
        {
            char[] inputChars = n.ToString().ToCharArray();
            IList<byte> digits = new List<byte>();
 
            foreach (char digit in inputChars)
            {
                digits.Add((byte)Char.GetNumericValue(digit));
            }
 
            if (n < 1)
            {
                return false;
            }
 
            int sum = 0;
 
            foreach (byte digit in digits)
            {
                sum += digit;
            }
 
            return n % sum == 0;
        }
 
        static void Main(string[] args)
        {
            int i = 1;
            int count = 0;
 
            while (true)
            {
                if (IsHarshad(i))
                {
                    count++;
 
                    if (count <= 20)
                    {
                        Console.Write(string.Format(""{0} "", i));
                    }
                    else if (i > 1000)
                    {
                        Console.Write(string.Format(""{0} "", i));
                        break;
                    }
                }
 
                i++;
            }
 
            Console.ReadKey();
        }
    }
}
 ",1317,63
48460,http://rosettacode.org/wiki/Handle_a_signal,Handle a signal,"Most operating systems provide interrupt facilities, sometimes called signals either generated by the user or as a result of program failure or reaching a limit like file space.
Unhandled signals generally terminate a program in a disorderly manner.
Signal handlers are created so that the program behaves in a well-defined manner upon receipt of a signal.

Task

Provide a program that displays an integer on each line of output at the rate of about one per half second.
Upon receipt of the SIGINT signal (often generated by the user typing ctrl-C ( or better yet, SIGQUIT ctrl-\ )) the program will cease outputting integers, output the number of seconds the program has run, and then the program will quit.



",#C.23,C#,"using System; //DateTime, Console, Environment classes
class Program
{
    static DateTime start;
    static void Main(string[] args)
    {
        start = DateTime.Now;
        //Add event handler for Ctrl+C command
        Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);
        int counter = 0;
        while (true)
        {
            Console.WriteLine(++counter);
            System.Threading.Thread.Sleep(500);
        }
    }
    static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
    {
        var end = DateTime.Now;
        Console.WriteLine(""This program ran for {0:000.000} seconds."", (end - start).TotalMilliseconds / 1000);
        Environment.Exit(0);
    }
}",734,23
48500,http://rosettacode.org/wiki/Halt_and_catch_fire,Halt and catch fire,"Task
Create a program that crashes as soon as possible, with as few lines of code as possible. Be smart and don't damage your computer, ok?

The code should be syntactically valid. It should be possible to insert [a subset of] your submission into another program, presumably to help debug it, or perhaps for use when an internal corruption has been detected and it would be dangerous and irresponsible to continue.

References
 Wikipedia: Halt and Catch Fire


Related Tasks
 Program termination

",#C.23,C#,"int a=0,b=1/a;",14,1
48638,http://rosettacode.org/wiki/GUI/Maximum_window_dimensions,GUI/Maximum window dimensions,"The task is to determine the maximum height and width of a window that can fit within the physical display area of the screen without scrolling.

This is effectively the screen size (not the total desktop area, which could be bigger than the screen display area) in pixels minus any adjustments for window decorations and menubars.

The idea is to determine the physical display parameters for the maximum height and width of the usable display area in pixels (without scrolling).

The values calculated should represent the usable desktop area of a window maximized to fit the the screen.



Considerations

--- Multiple Monitors

For multiple monitors, the values calculated should represent the size of the usable display area on the monitor which is related to the task (i.e.:   the monitor which would display a window if such instructions were given).

--- Tiling Window Managers
For a tiling window manager, the values calculated should represent the maximum height and width of the display area of the maximum size a window can be created (without scrolling). This would typically be a full screen window (minus any areas occupied by desktop bars), unless the window manager has restrictions that prevents the creation of a full screen window, in which case the values represent the usable area of the desktop that occupies the maximum permissible window size (without scrolling).



",#C.23,C#,"using System;
using System.Drawing;
using System.Windows.Forms;
 
static class Program
{
    static void Main()
    {
        Rectangle bounds = Screen.PrimaryScreen.Bounds;
        Console.WriteLine($""Primary screen bounds:  {bounds.Width}x{bounds.Height}"");
 
        Rectangle workingArea = Screen.PrimaryScreen.WorkingArea;
        Console.WriteLine($""Primary screen working area:  {workingArea.Width}x{workingArea.Height}"");
    }
}",437,15
48683,http://rosettacode.org/wiki/Haversine_formula,Haversine formula,"

 This page uses content from Wikipedia. The original article was at Haversine formula. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The haversine formula is an equation important in navigation, giving great-circle distances between two points on a sphere from their longitudes and latitudes.

It is a special case of a more general formula in spherical trigonometry, the law of haversines, relating the sides and angles of spherical ""triangles"".



Task

Implement a great-circle distance function, or use a library function,
to show the great-circle distance between:

 Nashville International Airport (BNA)   in Nashville, TN, USA,   which is: 
   N 36°7.2',   W 86°40.2'     (36.12,   -86.67)           -and-

 Los Angeles International Airport (LAX)  in Los Angeles, CA, USA,   which is:
   N 33°56.4',  W 118°24.0'    (33.94,  -118.40)   



User Kaimbridge clarified on the Talk page:

 -- 6371.0 km is the authalic radius based on/extracted from surface area;
 -- 6372.8 km is an approximation of the radius of the average circumference
    (i.e., the average great-elliptic or great-circle radius), where the
     boundaries are the meridian (6367.45 km) and the equator (6378.14 km).

Using either of these values results, of course, in differing distances:

 6371.0 km -> 2886.44444283798329974715782394574671655 km;
 6372.8 km -> 2887.25995060711033944886005029688505340 km;
 (results extended for accuracy check:  Given that the radii are only
  approximations anyways, .01' ≈ 1.0621333 km and .001"" ≈ .00177 km,
  practical precision required is certainly no greater than about
  .0000001——i.e., .1 mm!)

As distances are segments of great circles/circumferences, it is
recommended that the latter value (r = 6372.8 km) be used (which
most of the given solutions have already adopted, anyways). 

Most of the examples below adopted Kaimbridge's recommended value of
6372.8 km for the earth radius. However, the derivation of this
ellipsoidal quadratic mean radius
is wrong (the averaging over azimuth is biased). When applying these
examples in real applications, it is better to use the
mean earth radius,
6371 km. This value is recommended by the International Union of
Geodesy and Geophysics and it minimizes the RMS relative error between the
great circle and geodesic distance.





",#C.23,C#,"public static class Haversine {
  public static double calculate(double lat1, double lon1, double lat2, double lon2) {
    var R = 6372.8; // In kilometers
    var dLat = toRadians(lat2 - lat1);
    var dLon = toRadians(lon2 - lon1);
    lat1 = toRadians(lat1);
    lat2 = toRadians(lat2);
 
    var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Sin(dLon / 2) * Math.Sin(dLon / 2) * Math.Cos(lat1) * Math.Cos(lat2);
    var c = 2 * Math.Asin(Math.Sqrt(a));
    return R * 2 * Math.Asin(Math.Sqrt(a));
  }
 
  public static double toRadians(double angle) {
    return Math.PI * angle / 180.0;
  }
}
 
void Main() {
  Console.WriteLine(String.Format(""The distance between coordinates {0},{1} and {2},{3} is: {4}"", 36.12, -86.67, 33.94, -118.40, Haversine.calculate(36.12, -86.67, 33.94, -118.40)));
}
 
// Returns: The distance between coordinates 36.12,-86.67 and 33.94,-118.4 is: 2887.25995060711
 ",903,24
48778,http://rosettacode.org/wiki/Hello_world/Graphical,Hello world/Graphical,"

Task

Display the string       Goodbye, World!       on a GUI object   (alert box, plain window, text area, etc.).



Related task

   Hello world/Text

",#C.23,C#,"using System;
using System.Windows.Forms;
 
class Program {
    static void Main(string[] args) {
        Application.EnableVisualStyles(); //Optional.
        MessageBox.Show(""Goodbye, World!"");
    }
}",203,9
48852,http://rosettacode.org/wiki/GUI_enabling/disabling_of_controls,GUI enabling/disabling of controls,"In addition to fundamental GUI component interaction, an application should
dynamically enable and disable GUI components, to give some guidance to the
user, and prohibit (inter)actions which are inappropriate in the current state
of the application.



Task

Similar to the task GUI component interaction, write a program
that presents a form with three components to the user:

   a numeric input field (""Value"") 
   a button   (""increment"")
   a button   (""decrement"")


The field is initialized to zero.
The user may manually enter a new value into the field,
increment its value with the ""increment"" button,
or decrement the value with the ""decrement"" button.

The input field should be enabled only when its value is zero.
The ""increment"" button only as long as the field's value is less then 10:
When the value 10 is reached, the button should go into a disabled state.
Analogously, the ""decrement"" button should be enabled only as long as
the value is greater than zero.

Effectively, the user can now either increment up to 10, or down to zero.
Manually entering values outside that range is still legal,
but the buttons should reflect that and enable/disable accordingly.



",#C.23,C#,"using System; 
using System.ComponentModel; 
using System.Windows.Forms; 
 
class RosettaInteractionForm : Form
{    
 
    // Model used for DataBinding.
    // Notifies bound controls about Value changes.
    class NumberModel: INotifyPropertyChanged
    {
        // initialize event with empty delegate to avoid checks on null
        public event PropertyChangedEventHandler PropertyChanged = delegate {};
 
        int _value;
        public int Value
        {
            get { return _value; }
            set 
            { 
                _value = value;
                // Notify bound control about value change
                PropertyChanged(this, new PropertyChangedEventArgs(""Value""));
            }
        }
    }
 
    NumberModel model = new NumberModel{ Value = 0};
 
    RosettaInteractionForm()    
    {
        //MaskedTextBox is a TextBox variety with built-in input validation
        var tbNumber = new MaskedTextBox
                        { 
                            Mask=""0000"",            // allow 4 decimal digits only
                            ResetOnSpace = false,   // don't enter spaces
                            Dock = DockStyle.Top    // place at the top of form
                        };
        // bound TextBox.Text to NumberModel.Value;
        tbNumber.DataBindings.Add(""Text"", model, ""Value"");
        var enabledIfZero = new Binding(""Enabled"", model, ""Value"");
        EnableControlWhen(tbNumber, value => value == 0);
 
        var btIncrement = new Button{Text = ""Increment"", Dock = DockStyle.Bottom};
        btIncrement.Click += delegate
                        {
                            model.Value++;
                        };
        EnableControlWhen(btIncrement, value => value < 10);
        var btDecrement = new Button{Text = ""Decrement"", Dock = DockStyle.Bottom};
        btDecrement.Click += delegate
                        {
                            model.Value--;
                        };
        EnableControlWhen(btDecrement, value => value > 0);
        Controls.Add(tbNumber);
        Controls.Add(btIncrement);
        Controls.Add(btDecrement);
    }
 
    // common part of creating bindings for Enabled property
    void EnableControlWhen(Control ctrl, Func<int, bool> predicate)
    {
        // bind Control.Enabled to NumberModel.Value
        var enabledBinding = new Binding(""Enabled"", model, ""Value"");
        // Format event is called when model value should be converted to Control value.
        enabledBinding.Format += (sender, args) =>
            {
                // Enabled property is of bool type.
                if (args.DesiredType != typeof(bool)) return;
                // set resulting value by applying condition
                args.Value = predicate((int)args.Value);
            };
        // as a result, control will be enabled if predicate returns true
        ctrl.DataBindings.Add(enabledBinding);
    }
 
    static void Main()
    {
        Application.Run(new RosettaInteractionForm());
    }
}",3021,82
49003,http://rosettacode.org/wiki/Guess_the_number/With_feedback_(player),Guess the number/With feedback (player),"Task

Write a player for the game that follows the following rules:

The scorer will choose a number between set limits. The computer player will print a guess of the target number. The computer asks for a score of whether its guess is higher than, lower than, or equal to the target. The computer guesses, and the scorer scores, in turn, until the computer correctly guesses the target number.
The computer should guess intelligently based on the accumulated scores given. One way is to use a Binary search based algorithm.



Related tasks

   Guess the number/With Feedback
   Bulls and cows/Player

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading; //Remember to add this if you want the game to pause in RealisticGuess.Start()
 
namespace ConsoleApplication1
{
    class RealisticGuess //Simulates a guessing game between two people. Guessing efficiency is not a goal.
    {
        private int max;
        private int min;
        private int guess;
 
        public void Start()
        {
            Console.Clear();
            string input;
 
            try
            {
                Console.WriteLine(""Please enter the lower boundary"");
                input = Console.ReadLine();
                min = Convert.ToInt32(input);
                Console.WriteLine(""Please enter the upper boundary"");
                input = Console.ReadLine();
                max = Convert.ToInt32(input);
            }
            catch (FormatException)
            {
                Console.WriteLine(""The entry you have made is invalid. Please make sure your entry is an integer and try again."");
                Console.ReadKey(true);
                Start();
            }
            Console.WriteLine(""Think of a number between {0} and {1}."", min, max);
            Thread.Sleep(2500);
            Console.WriteLine(""Ready?"");
            Console.WriteLine(""Press any key to begin."");
            Console.ReadKey(true);
            Guess(min, max);
        }
        public void Guess(int min, int max)
        {
            int counter = 1;
            string userAnswer;
            bool correct = false;
            Random rand = new Random();
 
            while (correct == false)
            {
                guess = rand.Next(min, max);
                Console.Clear();
                Console.WriteLine(""{0}"", guess);
                Console.WriteLine(""Is this number correct? {Y/N}"");
                userAnswer = Console.ReadLine();
                if (userAnswer != ""y"" && userAnswer != ""Y"" && userAnswer != ""n"" && userAnswer != ""N"")
                {
                    Console.WriteLine(""Your entry is invalid. Please enter either 'Y' or 'N'"");
                    Console.WriteLine(""Is the number correct? {Y/N}"");
                    userAnswer = Console.ReadLine();
                }
                if (userAnswer == ""y"" || userAnswer == ""Y"")
                {
                    correct = true;
                }
                if (userAnswer == ""n"" || userAnswer == ""N"")
                {
                    counter++;
                    if (max == min)
                    {
                        Console.WriteLine(""Error: Range Intersect. Press enter to restart the game."");  //This message should never pop up if the user enters good data.
                        Console.ReadKey(true);                                                          //It handles the game-breaking exception that occurs
                        Guess(1, 101);                                                                  //when the max guess number is the same as the min number.
                    }
                    Console.WriteLine(""Is the number you're thinking of lower or higher? {L/H}"");
                    userAnswer = Console.ReadLine();
                    if (userAnswer != ""l"" && userAnswer != ""L"" && userAnswer != ""h"" && userAnswer != ""H"")
                    {
                        Console.WriteLine(""Your entry is invalid. Please enter either 'L' or 'H'"");
                        Console.WriteLine(""Is the number you're thinking of lower or higher? {L/H}"");
                        userAnswer = Console.ReadLine();
                    }
                    if (userAnswer == ""l"" || userAnswer == ""L"")
                    {
                        max = guess;
                    }
                    if (userAnswer == ""h"" || userAnswer == ""H"")
                    {
                        min = guess;
                    }
                }
            }
            if (correct == true)
            {
                EndAndLoop(counter);
            }
        }
 
        public void EndAndLoop(int iterations)
        {
            string userChoice;
            bool loop = false;
            Console.WriteLine(""Game over. It took {0} guesses to find the number."", iterations);
            while (loop == false)
            {
                Console.WriteLine(""Would you like to play again? {Y/N}"");
                userChoice = Console.ReadLine();
                if (userChoice != ""Y"" && userChoice != ""y"" && userChoice != ""N"" && userChoice != ""n"")
                {
                    Console.WriteLine(""Sorry, your input is invalid. Please answer 'Y' to play again, or 'N' to quit."");
                }
                if (userChoice == ""Y"" || userChoice == ""y"")
                {
                    Start();
                }
                if (userChoice == ""N"" || userChoice == ""n"")
                {
                    Environment.Exit(1);
                }
            }
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Console.Title = ""Random Number"";
            RealisticGuess game = new RealisticGuess();
            game.Start();
        }
    }
}
 ",5225,133
49140,http://rosettacode.org/wiki/Happy_numbers,Happy numbers,"From Wikipedia, the free encyclopedia:

 A happy number is defined by the following process:
 Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals   1   (where it will stay),   or it loops endlessly in a cycle which does not include   1.   


 Those numbers for which this process end in   1   are       happy   numbers,   
 while   those numbers   that   do   not   end in   1   are   unhappy   numbers. 


Task

Find and print the first   8   happy numbers.

Display an example of your output here on this page.



See also

   The OEIS entry:   The     happy numbers:   A007770
   The OEIS entry:   The unhappy numbers;   A031177

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace HappyNums
{
    class Program
    {
        public static bool ishappy(int n)
        {
            List<int> cache = new List<int>();
            int sum = 0;
            while (n != 1)
            {
                if (cache.Contains(n))
                {
                    return false;
                }
                cache.Add(n);
                while (n != 0)
                {
                    int digit = n % 10;
                    sum += digit * digit;
                    n /= 10;
                }
                n = sum;
                sum = 0;
            }
           return true;            
        }
 
        static void Main(string[] args)
        {
            int num = 1;
            List<int> happynums = new List<int>();
 
            while (happynums.Count < 8)
            {
                if (ishappy(num))
                {
                    happynums.Add(num);
                }
                num++;
            }
            Console.WriteLine(""First 8 happy numbers : "" + string.Join("","", happynums));
        }
    }
}",1163,49
49160,http://rosettacode.org/wiki/Greyscale_bars/Display,Greyscale bars/Display,"The task is to display a series of vertical greyscale bars (contrast bars) with a sufficient number of bars to span the entire width of the display.

For the top quarter of the display, the left hand bar should be black, and we then incrementally step through six shades of grey until we have a white bar on the right hand side of the display. (This gives a total of 8 bars)

For the second quarter down, we start with white and step down through 14 shades of gray, getting darker until we have black on the right hand side of the display. (This gives a total of 16 bars).

Halfway down the display, we start with black, and produce 32 bars, ending in white, and for the last quarter, we start with white and step through 62 shades of grey, before finally arriving at black in the bottom right hand corner, producing a total of 64 bars for the bottom quarter.
",#C.23,C#,"using System;
using System.Drawing;
using System.Windows.Forms;
static class Program { static void Main() { Application.Run(new FullScreen()); } }
public sealed class FullScreen : Form
{
    const int ColorCount = 256;
    public FullScreen()
    {
        FormBorderStyle = FormBorderStyle.None;
        WindowState = FormWindowState.Maximized;
        KeyPress += (s, e) => Application.Exit();
        BackgroundImage = ColorBars(Screen.FromControl(this).Bounds);
    }
    private static Bitmap ColorBars(Rectangle size)
    {
        var colorBars = new Bitmap(size.Width, size.Height);
        Func<int, int, int> forwardColor = (x, divs) => (int)(x * ((float)divs / size.Width)) * ColorCount / divs;
        Func<int, int, int> reverseColor = (x, divs) => ColorCount - 1 - forwardColor(x, divs);
        Action<int, int, int> setGray = (x, y, gray) => colorBars.SetPixel(x, y, Color.FromArgb(gray, gray, gray));
        Action<int, int, int> setForward = (x, y, divs) => setGray(x, y, forwardColor(x, divs));
        Action<int, int, int> setReverse = (x, y, divs) => setGray(x, y, reverseColor(x, divs));
        int verticalStripe = size.Height / 4;
        for (int x = 0; x < size.Width; x++)
        {
            for (int y = 0; y < verticalStripe; y++) setForward(x, y, 8);
            for (int y = verticalStripe; y < verticalStripe * 2; y++) setReverse(x, y, 16);
            for (int y = verticalStripe * 2; y < verticalStripe * 3; y++) setForward(x, y, 32);
            for (int y = verticalStripe * 3; y < verticalStripe * 4; y++) setReverse(x, y, 64);
        }
        return colorBars;
    }
}",1614,33
49340,http://rosettacode.org/wiki/Guess_the_number,Guess the number,"Task

Write a program where the program chooses a number between   1   and   10.

A player is then prompted to enter a guess.   If the player guesses wrong,   then the prompt appears again until the guess is correct.

When the player has made a successful guess the computer will issue a   ""Well guessed!""   message,   and the program exits.

A   conditional loop   may be used to repeat the guessing until the user is correct.



Related tasks

   Bulls and cows
   Bulls and cows/Player
   Guess the number/With Feedback
   Mastermind

",#C.23,C#,"using System;
 
class GuessTheNumberGame
{
    static void Main()
    {
        int randomNumber = new Random().Next(1, 11);
 
        Console.WriteLine(""I'm thinking of a number between 1 and 10. Can you guess it?"");
        while(true)
        {
            Console.Write(""Guess: "");
            if (int.Parse(Console.ReadLine()) == randomNumber)
                break;
            Console.WriteLine(""That's not it. Guess again."");
        }
        Console.WriteLine(""Congrats!! You guessed right!"");
    }
};",512,19
49342,http://rosettacode.org/wiki/Greatest_subsequential_sum,Greatest subsequential sum,"Task

Given a sequence of integers, find a continuous subsequence which maximizes the sum of its elements, that is, the elements of no other single subsequence add up to a value larger than this one.



An empty subsequence is considered to have the sum of   0;   thus if all elements are negative, the result must be the empty sequence.



",#C.23,C#,"using System;
 
namespace Tests_With_Framework_4
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] integers = { -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 }; int length = integers.Length;
            int maxsum, beginmax, endmax, sum; maxsum = beginmax = sum = 0; endmax = -1;
 
            for (int i = 0; i < length; i++)
            {
                sum = 0;
                for (int k = i; k < length; k++)
                {
                    sum += integers[k];
                    if (sum > maxsum)
                    {
                        maxsum = sum;
                        beginmax = i;
                        endmax = k;
                    }
                }
            }
 
            for (int i = beginmax; i <= endmax; i++)
                Console.WriteLine(integers[i]);
 
            Console.ReadKey();
        }
    }
}",888,33
49362,http://rosettacode.org/wiki/Grayscale_image,Grayscale image,"Many image processing algorithms are defined for grayscale (or else monochromatic) images.



Task

Extend the data storage type defined on this page to support grayscale images.

Define two operations, one to convert a color image to a grayscale image and one for the backward conversion.

To get luminance of a color use the formula recommended by CIE:

 L  =  0.2126 × R   +   0.7152 × G   +   0.0722 × B 

When using floating-point arithmetic make sure that rounding errors would not cause run-time problems or else distorted results when calculated luminance is stored as an unsigned integer.



",#C.23,C#," 
Bitmap tImage = new Bitmap(""spectrum.bmp"");
 
for (int x = 0; x < tImage.Width; x++)
{
	for (int y = 0; y < tImage.Height; y++)
	{
		Color tCol = tImage.GetPixel(x, y);
 
		// L = 0.2126·R + 0.7152·G + 0.0722·B 
		double L = 0.2126 * tCol.R + 0.7152 * tCol.G + 0.0722 * tCol.B;
		tImage.SetPixel(x, y, Color.FromArgb(Convert.ToInt32(L), Convert.ToInt32(L), Convert.ToInt32(L)));
	}
}
 
// Save
tImage.Save(""spectrum2.bmp"");
 ",427,18
49370,http://rosettacode.org/wiki/Guess_the_number/With_feedback,Guess the number/With feedback,"Task

Write a game (computer program) that follows the following rules:

 The computer chooses a number between given set limits.
 The player is asked for repeated guesses until the the target number is guessed correctly
 At each guess, the computer responds with whether the guess is:
 higher than the target,
 equal to the target, 
 less than the target,   or
 the input was inappropriate. 


Related task

   Guess the number/With Feedback (Player)

",#C.23,C#,"using System;
 
class Program
{
    static void Main(string[] args)
    {
        const int from = 1;
        const int to = 10;
 
        int randomNumber = new Random().Next(from, to);
        int guessedNumber;
 
        Console.Write(""The number is between {0} and {1}. "", from, to);
        while (true)
        {
            Console.Write(""Make a guess: "");
            if (int.TryParse(Console.ReadLine(), out guessedNumber))
            {
                if (guessedNumber == randomNumber)
                {
                    Console.WriteLine(""You guessed the right number!"");
                    break;
                }
                else
                {
                    Console.WriteLine(""Your guess was too {0}."", (guessedNumber > randomNumber) ? ""high"" : ""low"");
                }
            }
            else
            {
                Console.WriteLine(""Input was not an integer."");
            }
        }
 
        Console.WriteLine();
        Console.WriteLine(""Press any key to exit."");
        Console.ReadKey();
    }
}
 ",1058,40
49450,http://rosettacode.org/wiki/Hamming_numbers,Hamming numbers,"Hamming numbers are numbers of the form  

    H = 2i × 3j × 5k
           where 
     i,  j,  k  ≥  0 

Hamming numbers   are also known as   ugly numbers   and also   5-smooth numbers   (numbers whose prime divisors are less or equal to 5).



Task

Generate the sequence of Hamming numbers, in increasing order.   In particular:

 Show the   first twenty   Hamming numbers.
 Show the   1691st   Hamming number (the last one below   231).
 Show the   one millionth   Hamming number (if the language – or a convenient library – supports arbitrary-precision integers).


Related tasks

 Humble numbers
 N-smooth numbers


References

 Wikipedia entry:   Hamming numbers     (this link is re-directed to   Regular number).
 Wikipedia entry:   Smooth number
 OEIS entry:   A051037   5-smooth   or   Hamming numbers
 Hamming problem from Dr. Dobb's CodeTalk (dead link as of Sep 2011; parts of the thread here and here).

",#C.23,C#,"using System;
using System.Numerics;
using System.Linq;
 
namespace Hamming {
 
    class MainClass {
 
        public static BigInteger Hamming(int n) {
            BigInteger two = 2, three = 3, five = 5;
            var h = new BigInteger[n];
            h[0] = 1;
            BigInteger x2 = 2, x3 = 3, x5 = 5;
            int i = 0, j = 0, k = 0;
 
            for (int index = 1; index < n; index++) {
                h[index] = BigInteger.Min(x2, BigInteger.Min(x3, x5));
                if (h[index] == x2) x2 = two * h[++i];
                if (h[index] == x3) x3 = three * h[++j];
                if (h[index] == x5) x5 = five * h[++k];
            }
            return h[n - 1];
        }
 
        public static void Main(string[] args) {
            Console.WriteLine(string.Join("" "", Enumerable.Range(1, 20).ToList().Select(x => Hamming(x))));
            Console.WriteLine(Hamming(1691));
            Console.WriteLine(Hamming(1000000));
        }
    }
}",970,31
49644,http://rosettacode.org/wiki/Globally_replace_text_in_several_files,Globally replace text in several files,"Task

Replace every occurring instance of a piece of text in a group of text files with another one.



For this task we want to replace the text   ""Goodbye London!""   with   ""Hello New York!""   for a list of files.



",#C.23,C#," 
using System.Collections.Generic;
using System.IO;
 
class Program {
    static void Main() {
        var files = new List<string> {
            ""test1.txt"",
            ""test2.txt""
        };
        foreach (string file in files) {
            File.WriteAllText(file, File.ReadAllText(file).Replace(""Goodbye London!"", ""Hello New York!""));
        }
    }
}
 ",362,16
49667,http://rosettacode.org/wiki/Gray_code,Gray code,"Gray code
Karnaugh maps
Create functions to encode a number to and decode a number from Gray code.

Display the normal binary representations, Gray code representations, and decoded Gray code values for all 5-bit binary numbers (0-31 inclusive, leading 0's not necessary).

There are many possible Gray codes. The following encodes what is called ""binary reflected Gray code.""

Encoding (MSB is bit 0, b is binary, g is Gray code):

if b[i-1] = 1
   g[i] = not b[i]
else
   g[i] = b[i]
Or:

g = b xor (b logically right shifted 1 time)
Decoding (MSB is bit 0, b is binary, g is Gray code):

b[0] = g[0]

for other bits:
b[i] = g[i] xor b[i-1]
Reference
 Converting Between Gray and Binary Codes. It includes step-by-step animations.",#C.23,C#,"using System;
 
public class Gray {
    public static ulong grayEncode(ulong n) {
        return n^(n>>1);
    }
 
    public static ulong grayDecode(ulong n) {
        ulong i=1<<8*64-2; //long is 64-bit
        ulong p, b=p=n&i;
 
        while((i>>=1)>0)
            b|=p=n&i^p>>1;
        return b;
    }
 
    public static void Main(string[] args) {
        Console.WriteLine(""Number\tBinary\tGray\tDecoded"");
        for(ulong i=0;i<32;i++) {
            Console.WriteLine(string.Format(""{0}\t{1}\t{2}\t{3}"", i, Convert.ToString((long)i, 2), Convert.ToString((long)grayEncode(i), 2), grayDecode(grayEncode(i))));
        }
    }
}",637,23
49668,http://rosettacode.org/wiki/Get_system_command_output,Get system command output,"Task
Execute a system command and get its output into the program. The output may be stored in any kind of collection (array, list, etc.).




Related task
  Execute a system command

",#C.23,C#,"using System;
 
namespace GetSystemCommandOutput {
    class Program {
        static void Main(string[] args) {
            System.Diagnostics.Process process = new System.Diagnostics.Process();
            System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo();
            startInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;
            startInfo.FileName = ""cmd.exe"";
            startInfo.Arguments = ""/c echo Hello World"";
            startInfo.RedirectStandardOutput = true;
            startInfo.UseShellExecute = false;
            process.StartInfo = startInfo;
            process.Start();
 
            string output = process.StandardOutput.ReadToEnd();
            Console.WriteLine(""Output is {0}"", output);
        }
    }
}",793,20
50167,http://rosettacode.org/wiki/Greatest_element_of_a_list,Greatest element of a list,"Task

Create a function that returns the maximum value in a provided set of values,

where the number of values may not be known until run-time.



",#C.23,C#,"int[] values = new int[] {1,2,3,4,5,6,7,8,9,10};
 
int max = values.Max();",74,3
50172,http://rosettacode.org/wiki/Hailstone_sequence,Hailstone sequence,"The Hailstone sequence of numbers can be generated from a starting positive integer,   n   by:

   If   n   is     1     then the sequence ends.
   If   n   is   even then the next   n   of the sequence    = n/2 
   If   n   is   odd   then the next   n   of the sequence    = (3 * n) + 1 


The (unproven) Collatz conjecture is that the hailstone sequence for any starting number always terminates.



This sequence was named by Lothar Collatz in 1937   (or possibly in 1939),   and is also known as (the):

   hailstone sequence,   hailstone numbers
   3x + 2 mapping,   3n + 1 problem
   Collatz sequence
   Hasse's algorithm
   Kakutani's problem
   Syracuse algorithm,   Syracuse problem
   Thwaites conjecture 
   Ulam's problem


The hailstone sequence is also known as   hailstone numbers   (because the values are usually subject to multiple descents and ascents like hailstones in a cloud).



Task

 Create a routine to generate the hailstone sequence for a number.
 Use the routine to show that the hailstone sequence for the number 27 has 112 elements starting with 27, 82, 41, 124 and ending with 8, 4, 2, 1
 Show the number less than 100,000 which has the longest hailstone sequence together with that sequence's length.
   (But don't show the actual sequence!)


See also

   xkcd (humourous).
   The Notorious Collatz conjecture Terence Tao, UCLA (Presentation, pdf).
   The Simplest Math Problem No One Can Solve Veritasium (video, sponsored).

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace Hailstone
{
    class Program
    {
        public static List<int> hs(int n,List<int> seq)
        {
            List<int> sequence = seq;
            sequence.Add(n);
            if (n == 1)
            {
                return sequence;
            }else{
                int newn = (n % 2 == 0) ? n / 2 : (3 * n) + 1;
                return hs(newn, sequence);
            }                        
        }
 
        static void Main(string[] args)
        {
            int n = 27;
            List<int> sequence = hs(n,new List<int>());
            Console.WriteLine(sequence.Count + "" Elements"");
            List<int> start = sequence.GetRange(0, 4);
            List<int> end = sequence.GetRange(sequence.Count - 4, 4);
            Console.WriteLine(""Starting with : "" + string.Join("","", start) + "" and ending with : "" + string.Join("","", end));            
            int number = 0, longest = 0;            
            for (int i = 1; i < 100000; i++)
            {
                int count = (hs(i, new List<int>())).Count;
                if (count > longest)
                {
                    longest = count;
                    number = i;
                }
            }
            Console.WriteLine(""Number < 100000 with longest Hailstone seq.: "" + number + "" with length of "" + longest);
       }
    }
}",1430,44
50333,http://rosettacode.org/wiki/Generic_swap,Generic swap,"Task

Write a generic swap function or operator which exchanges the values of two variables (or, more generally, any two storage places that can be assigned), regardless of their types.

If your solution language is statically typed please describe the way your language provides genericity.

If variables are typed in the given language, it is permissible that the two variables be constrained to having a mutually compatible type, such that each is permitted to hold the value previously stored in the other without a type violation.
That is to say, solutions do not have to be capable of exchanging, say, a string and integer value, if the underlying storage locations are not attributed with types that permit such an exchange.

Generic swap is a task which brings together a few separate issues in programming language semantics.

Dynamically typed languages deal with values in a generic way quite readily, but do not necessarily make it easy to write a function to destructively swap two variables, because this requires indirection upon storage places or upon the syntax designating storage places.

Functional languages, whether static or dynamic, do not necessarily allow a destructive operation such as swapping two variables regardless of their generic capabilities.

Some static languages have difficulties with generic programming due to a lack of support for (Parametric Polymorphism).

Do your best!



",#C.23,C#,"static void Swap<T>(ref T a, ref T b)
{
    T temp = a;
    a = b;
    b = temp;
}",82,6
50371,http://rosettacode.org/wiki/Greatest_common_divisor,Greatest common divisor,"Greatest common divisor

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Find the greatest common divisor   (GCD)   of two integers.


Greatest common divisor   is also known as   greatest common factor (gcf)   and   greatest common measure.



Related task

   least common multiple.


See also

   MathWorld entry:   greatest common divisor.
   Wikipedia entry:     greatest common divisor.

",#C.23,C#," 
static void Main()
{
	Console.WriteLine(""GCD of {0} and {1} is {2}"", 1, 1, gcd(1, 1));
	Console.WriteLine(""GCD of {0} and {1} is {2}"", 1, 10, gcd(1, 10));
	Console.WriteLine(""GCD of {0} and {1} is {2}"", 10, 100, gcd(10, 100));
	Console.WriteLine(""GCD of {0} and {1} is {2}"", 5, 50, gcd(5, 50));
	Console.WriteLine(""GCD of {0} and {1} is {2}"", 8, 24, gcd(8, 24));
	Console.WriteLine(""GCD of {0} and {1} is {2}"", 36, 17, gcd(36, 17));
	Console.WriteLine(""GCD of {0} and {1} is {2}"", 36, 18, gcd(36, 18));
	Console.WriteLine(""GCD of {0} and {1} is {2}"", 36, 19, gcd(36, 19));
	for (int x = 1; x < 36; x++)
	{
		Console.WriteLine(""GCD of {0} and {1} is {2}"", 36, x, gcd(36, x));
	}
	Console.Read();
}
 
/// <summary>
/// Greatest Common Denominator using Euclidian Algorithm
/// </summary>
static int gcd(int a, int b)
{
    while (b != 0) b = a % (a = b);
    return a;
}
 ",872,27
51292,http://rosettacode.org/wiki/Generator/Exponential,Generator/Exponential,"A generator is an executable entity (like a function or procedure) that contains code that yields a sequence of values, one at a time, so that each time you call the generator, the next value in the sequence is provided.

Generators are often built on top of coroutines or objects so that the internal state of the object is handled “naturally”.

Generators are often used in situations where a sequence is potentially infinite, and where it is possible to construct the next value of the sequence with only minimal state.



Task

 Create a function that returns a generation of the m'th powers of the positive integers starting from zero, in order, and without obvious or simple upper limit. (Any upper limit to the generator should not be stated in the source but should be down to factors such as the languages natural integer size limit or computational time/size).
 Use it to create a generator of:
   Squares.
   Cubes. 
 Create a new generator that filters all cubes from the generator of squares.
 Drop the first 20 values from this last generator of filtered results, and then show the next 10 values.


Note that this task requires the use of generators in the calculation of the result.



Also see

 Generator

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
static class Program {
    static void Main() {
        Func<int, IEnumerable<int>> ms = m => Infinite().Select(i => (int)Math.Pow(i, m));
        var squares = ms(2);
        var cubes = ms(3);
        var filtered = squares.Where(square => cubes.First(cube => cube >= square) != square);
        var final = filtered.Skip(20).Take(10);
        foreach (var i in final) Console.WriteLine(i);
    }
 
    static IEnumerable<int> Infinite() {
        var i = 0;
        while (true) yield return i++;
    }
}",576,19
51438,http://rosettacode.org/wiki/General_FizzBuzz,General FizzBuzz,"Task

Write a generalized version of FizzBuzz that works for any list of factors, along with their words.

This is basically a ""fizzbuzz"" implementation where the user supplies the parameters.

The user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.

For simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.



For example, given:

>20      #This is the maximum number, supplied by the user
>3 Fizz  #The user now enters the starting factor (3) and the word they want associated with it (Fizz)
>5 Buzz  #The user now enters the next factor (5) and the word they want associated with it (Buzz)
>7 Baxx  #The user now enters the next factor (7) and the word they want associated with it (Baxx)

In other words: For this example, print the numbers 1 through 20, replacing every multiple of 3 with ""Fizz"", every multiple of 5 with ""Buzz"", and every multiple of 7 with ""Baxx"".

In the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor.

For instance, the number 15 is a multiple of both 3 and 5; print ""FizzBuzz"".

If the max number was 105 instead of 20, you would print ""FizzBuzzBaxx"" because it's a multiple of 3, 5, and 7.


Output:
1
2
Fizz
4
Buzz
Fizz
Baxx
8
Fizz
Buzz
11
Fizz
13
Baxx
FizzBuzz
16
17
Fizz
19
Buzz


",#C.23,C#," 
using System;
 
public class GeneralFizzBuzz
{
    public static void Main() 
    {
        int i;
        int j;
        int k;
 
        int limit;
 
        string iString;
        string jString;
        string kString;
 
        Console.WriteLine(""First integer:"");
        i = Convert.ToInt32(Console.ReadLine());
        Console.WriteLine(""First string:"");
        iString = Console.ReadLine();
 
        Console.WriteLine(""Second integer:"");
        j = Convert.ToInt32(Console.ReadLine());
        Console.WriteLine(""Second string:"");
        jString = Console.ReadLine();
 
        Console.WriteLine(""Third integer:"");
        k = Convert.ToInt32(Console.ReadLine());
        Console.WriteLine(""Third string:"");
        kString = Console.ReadLine();
 
        Console.WriteLine(""Limit (inclusive):"");
        limit = Convert.ToInt32(Console.ReadLine());
 
        for(int n = 1; n<= limit; n++)
        {
            bool flag = true;
            if(n%i == 0)
            {
                Console.Write(iString);
                flag = false;
            }
 
            if(n%j == 0)
            {
                Console.Write(jString);
                flag = false;
            }
 
            if(n%k == 0)
            {
                Console.Write(kString);
                flag = false;
            }
            if(flag)
                Console.Write(n);
            Console.WriteLine();
        }
    }
}
 ",1427,62
51453,http://rosettacode.org/wiki/Gauss-Jordan_matrix_inversion,Gauss-Jordan matrix inversion,"Task

Invert matrix   A   using Gauss-Jordan method.

A   being an   n × n   matrix.



",#C.23,C#," 
using System;
 
namespace Rosetta
{
    internal class Vector
    {
        private double[] b;
        internal readonly int rows;
 
        internal Vector(int rows)
        {
            this.rows = rows;
            b = new double[rows];
        }
 
        internal Vector(double[] initArray)
        {
            b = (double[])initArray.Clone();
            rows = b.Length;
        }
 
        internal Vector Clone()
        {
            Vector v = new Vector(b);
            return v;
        }
 
        internal double this[int row]
        {
            get { return b[row]; }
            set { b[row] = value; }
        }
 
        internal void SwapRows(int r1, int r2)
        {
            if (r1 == r2) return;
            double tmp = b[r1];
            b[r1] = b[r2];
            b[r2] = tmp;
        }
 
        internal double norm(double[] weights)
        {
            double sum = 0;
            for (int i = 0; i < rows; i++)
            {
                double d = b[i] * weights[i];
                sum +=  d*d;
            }
            return Math.Sqrt(sum);
        }
 
        internal void print()
        {
            for (int i = 0; i < rows; i++)
                Console.WriteLine(b[i]);
            Console.WriteLine();
        }
 
        public static Vector operator-(Vector lhs, Vector rhs)
        {
            Vector v = new Vector(lhs.rows);
            for (int i = 0; i < lhs.rows; i++)
                v[i] = lhs[i] - rhs[i];
            return v;
        }
    }
 
    class Matrix
    {
        private double[] b;
        internal readonly int rows, cols;
 
        internal Matrix(int rows, int cols)
        {
            this.rows = rows;
            this.cols = cols;
            b = new double[rows * cols];            
        }
 
        internal Matrix(int size)
        {
            this.rows = size;
            this.cols = size;
            b = new double[rows * cols];
            for (int i = 0; i < size; i++)
                this[i, i] = 1;
        }
 
        internal Matrix(int rows, int cols, double[] initArray)
        {
            this.rows = rows;
            this.cols = cols;
            b = (double[])initArray.Clone();
            if (b.Length != rows * cols) throw new Exception(""bad init array"");
        }
 
        internal double this[int row, int col]
        {
            get { return b[row * cols + col]; }
            set { b[row * cols + col] = value; }
        }        
 
        public static Vector operator*(Matrix lhs, Vector rhs)
        {
            if (lhs.cols != rhs.rows) throw new Exception(""I can't multiply matrix by vector"");
            Vector v = new Vector(lhs.rows);
            for (int i = 0; i < lhs.rows; i++)
            {
                double sum = 0;
                for (int j = 0; j < rhs.rows; j++)
                    sum += lhs[i,j]*rhs[j];
                v[i] = sum;
            }
            return v;
        }
 
        internal void SwapRows(int r1, int r2)
        {
            if (r1 == r2) return;
            int firstR1 = r1 * cols;
            int firstR2 = r2 * cols;
            for (int i = 0; i < cols; i++)
            {
                double tmp = b[firstR1 + i];
                b[firstR1 + i] = b[firstR2 + i];
                b[firstR2 + i] = tmp;
            }
        }
 
        //with partial pivot
        internal bool InvPartial()
        {
            const double Eps = 1e-12;
            if (rows != cols) throw new Exception(""rows != cols for Inv"");
            Matrix M = new Matrix(rows); //unitary
            for (int diag = 0; diag < rows; diag++)
            {
                int max_row = diag;
                double max_val = Math.Abs(this[diag, diag]);
                double d;
                for (int row = diag + 1; row < rows; row++)
                    if ((d = Math.Abs(this[row, diag])) > max_val)
                    {
                        max_row = row;
                        max_val = d;
                    }
                if (max_val <= Eps) return false;
                SwapRows(diag, max_row);
                M.SwapRows(diag, max_row);
                double invd = 1 / this[diag, diag];
                for (int col = diag; col < cols; col++)
                {
                    this[diag, col] *= invd;
                }
                for (int col = 0; col < cols; col++)
                {
                    M[diag, col] *= invd;
                }
                for (int row = 0; row < rows; row++)
                {
                    d = this[row, diag];
                    if (row != diag)
                    {
                        for (int col = diag; col < this.cols; col++)
                        {
                            this[row, col] -= d * this[diag, col];
                        }
                        for (int col = 0; col < this.cols; col++)
                        {
                            M[row, col] -= d * M[diag, col];
                        }
                    }
                }
            }
            b = M.b;
            return true;
        }
 
        internal void print()
        {
            for (int i = 0; i < rows; i++)
            {
                for (int j = 0; j < cols; j++)
                    Console.Write(this[i,j].ToString()+""  "");
                Console.WriteLine();
            }
        }
    }
}
 ",5383,192
51497,http://rosettacode.org/wiki/Gapful_numbers,Gapful numbers,"Numbers   (positive integers expressed in base ten)   that are (evenly) divisible by the number formed by the
first and last digit are known as   gapful numbers.


Evenly divisible   means divisible with   no   remainder.



All   one─   and two─digit   numbers have this property and are trivially excluded.   Only
numbers    ≥  100   will be considered for this Rosetta Code task.



Example

187   is a   gapful   number because it is evenly divisible by the
number   17   which is formed by the first and last decimal digits
of    187. 



About   7.46%   of positive integers are   gapful.



Task

   Generate and show all sets of numbers (below) on one line (horizontally) with a title,   here on this page
   Show the first   30   gapful numbers
   Show the first   15   gapful numbers    ≥           1,000,000
   Show the first   10   gapful numbers    ≥    1,000,000,000


Related tasks

   Harshad or Niven series.
   palindromic gapful numbers.
   largest number divisible by its digits.


Also see

   The OEIS entry:   A108343 gapful numbers.
   numbersaplenty gapful numbers

",#C.23,C#," 
using System;
 
namespace GapfulNumbers
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(""The first 30 gapful numbers are: "");
            /* Starting at 100, find 30 gapful numbers */
            FindGap(100, 30);
 
            Console.WriteLine(""The first 15 gapful numbers > 1,000,000 are: "");
            FindGap(1000000, 15);
 
            Console.WriteLine(""The first 10 gapful numbers > 1,000,000,000 are: "");
            FindGap(1000000000, 10);
 
            Console.Read();
        }
 
        public static int firstNum(int n)
        {
            /*Divide by ten until the leading digit remains.*/
            while (n >= 10)
            {
                n /= 10;
            }
            return (n);
        }
 
        public static int lastNum(int n)
        {
            /*Modulo gives you the last digit. */
            return (n % 10);
        }
 
        static void FindGap(int n, int gaps)
        {
            int count = 0;
            while (count < gaps)
            {
 
                /* We have to convert our first and last digits to strings to concatenate.*/
                string concat = firstNum(n).ToString() + lastNum(n).ToString();
                /* And then convert our concatenated string back to an integer. */
                int i = Convert.ToInt32(concat);
 
                /* Modulo with our new integer and output the result. */
                if (n % i == 0)
                {
                    Console.Write(n + "" "");
                    count++;
                    n++;
                }
                else
                {
                    n++;
                    continue;
                }
            }
        }
    }
}
 
 
 ",1755,68
51530,http://rosettacode.org/wiki/Function_prototype,Function prototype,"Some languages provide the facility to declare functions and subroutines through the use of function prototyping.



Task

Demonstrate the methods available for declaring prototypes within the language. The provided solutions should include:

 An explanation of any placement restrictions for prototype declarations
 A prototype declaration for a function that does not require arguments
 A prototype declaration for a function that requires two arguments
 A prototype declaration for a function that utilizes varargs
 A prototype declaration for a function that utilizes optional arguments
 A prototype declaration for a function that utilizes named parameters
 Example of prototype declarations for subroutines or procedures (if these differ from functions)
 An explanation and example of any special forms of prototyping not covered by the above


Languages that do not provide function prototyping facilities should be omitted from this task.



",#C.23,C#,"using System;
abstract class Printer
{
    public abstract void Print();
}
 
class PrinterImpl : Printer
{
    public override void Print() {
        Console.WriteLine(""Hello world!"");
    }
}",192,12
51533,http://rosettacode.org/wiki/Gaussian_elimination,Gaussian elimination,"Task

Solve   Ax=b   using Gaussian elimination then backwards substitution.

A   being an   n by n   matrix.

Also,   x and b   are   n by 1   vectors.

To improve accuracy, please use partial pivoting and scaling.



See also

   the Wikipedia entry:   Gaussian elimination

",#C.23,C#," 
using System;
 
namespace Rosetta
{
    internal class Vector
    {
        private double[] b;
        internal readonly int rows;
 
        internal Vector(int rows)
        {
            this.rows = rows;
            b = new double[rows];
        }
 
        internal Vector(double[] initArray)
        {
            b = (double[])initArray.Clone();
            rows = b.Length;
        }
 
        internal Vector Clone()
        {
            Vector v = new Vector(b);
            return v;
        }
 
        internal double this[int row]
        {
            get { return b[row]; }
            set { b[row] = value; }
        }
 
        internal void SwapRows(int r1, int r2)
        {
            if (r1 == r2) return;
            double tmp = b[r1];
            b[r1] = b[r2];
            b[r2] = tmp;
        }
 
        internal double norm(double[] weights)
        {
            double sum = 0;
            for (int i = 0; i < rows; i++)
            {
                double d = b[i] * weights[i];
                sum +=  d*d;
            }
            return Math.Sqrt(sum);
        }
 
        internal void print()
        {
            for (int i = 0; i < rows; i++)
                Console.WriteLine(b[i]);
            Console.WriteLine();
        }
 
        public static Vector operator-(Vector lhs, Vector rhs)
        {
            Vector v = new Vector(lhs.rows);
            for (int i = 0; i < lhs.rows; i++)
                v[i] = lhs[i] - rhs[i];
            return v;
        }
    }
 
    class Matrix
    {
        private double[] b;
        internal readonly int rows, cols;
 
        internal Matrix(int rows, int cols)
        {
            this.rows = rows;
            this.cols = cols;
            b = new double[rows * cols];            
        }
 
        internal Matrix(int size)
        {
            this.rows = size;
            this.cols = size;
            b = new double[rows * cols];
            for (int i = 0; i < size; i++)
                this[i, i] = 1;
        }
 
        internal Matrix(int rows, int cols, double[] initArray)
        {
            this.rows = rows;
            this.cols = cols;
            b = (double[])initArray.Clone();
            if (b.Length != rows * cols) throw new Exception(""bad init array"");
        }
 
        internal double this[int row, int col]
        {
            get { return b[row * cols + col]; }
            set { b[row * cols + col] = value; }
        }        
 
        public static Vector operator*(Matrix lhs, Vector rhs)
        {
            if (lhs.cols != rhs.rows) throw new Exception(""I can't multiply matrix by vector"");
            Vector v = new Vector(lhs.rows);
            for (int i = 0; i < lhs.rows; i++)
            {
                double sum = 0;
                for (int j = 0; j < rhs.rows; j++)
                    sum += lhs[i,j]*rhs[j];
                v[i] = sum;
            }
            return v;
        }
 
        internal void SwapRows(int r1, int r2)
        {
            if (r1 == r2) return;
            int firstR1 = r1 * cols;
            int firstR2 = r2 * cols;
            for (int i = 0; i < cols; i++)
            {
                double tmp = b[firstR1 + i];
                b[firstR1 + i] = b[firstR2 + i];
                b[firstR2 + i] = tmp;
            }
        }
 
        //with partial pivot
        internal void ElimPartial(Vector B)
        {
            for (int diag = 0; diag < rows; diag++)
            {
                int max_row = diag;
                double max_val = Math.Abs(this[diag, diag]);
                double d;
                for (int row = diag + 1; row < rows; row++)
                    if ((d = Math.Abs(this[row, diag])) > max_val)
                    {
                        max_row = row;
                        max_val = d;
                    }
                SwapRows(diag, max_row);
                B.SwapRows(diag, max_row);
                double invd = 1 / this[diag, diag];
                for (int col = diag; col < cols; col++)
                    this[diag, col] *= invd;
                B[diag] *= invd;
                for (int row = 0; row < rows; row++)
                {
                    d = this[row, diag];
                    if (row != diag)
                    {
                        for (int col = diag; col < cols; col++)
                            this[row, col] -= d * this[diag, col];
                        B[row] -= d * B[diag];
                    }
                }
            }
        }
 
        internal void print()
        {
            for (int i = 0; i < rows; i++)
            {
                for (int j = 0; j < cols; j++)
                    Console.Write(this[i,j].ToString()+""  "");
                Console.WriteLine();
            }
        }
    }
}
 ",4809,176
51558,http://rosettacode.org/wiki/Generate_lower_case_ASCII_alphabet,Generate lower case ASCII alphabet,"Task

Generate an array, list, lazy sequence, or even an indexable string of all the lower case ASCII characters, from  a  to  z. If the standard library contains such a sequence, show how to access it, but don't fail to show how to generate a similar sequence.

For this basic task use a reliable style of coding, a style fit for a very large program, and use strong typing if available. It's bug prone to enumerate all the lowercase characters manually in the code.

During code review it's not immediate obvious to spot the bug in a Tcl line like this contained in a page of code:

set alpha {a b c d e f g h i j k m n o p q r s t u v w x y z}



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.Linq;
 
internal class Program
{
    private static void Main()
    {
        Console.WriteLine(String.Concat(Enumerable.Range('a', 26).Select(c => (char)c)));
    }
}",194,10
51806,http://rosettacode.org/wiki/Gamma_function,Gamma function,"Task

Implement one algorithm (or more) to compute the Gamma (



Γ


{\displaystyle \Gamma }

) function (in the real field only).

If your language has the function as built-in or you know a library which has it, compare your implementation's results with the results of the built-in/library function.

The Gamma function can be defined as:

  



Γ
(
x
)
=


∫

0


∞



t

x
−
1



e

−
t


d
t



{\displaystyle \Gamma (x)=\displaystyle \int _{0}^{\infty }t^{x-1}e^{-t}dt}


This suggests a straightforward (but inefficient) way of computing the 



Γ


{\displaystyle \Gamma }

 through numerical integration.



Better suggested methods:

 Lanczos approximation
 Stirling's approximation

",#C.23,C#,"using System;
using System.Numerics;
 
static int g = 7;
static double[] p = {0.99999999999980993, 676.5203681218851, -1259.1392167224028,
	     771.32342877765313, -176.61502916214059, 12.507343278686905,
	     -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7};
 
Complex Gamma(Complex z)
{
    // Reflection formula
    if (z.Real < 0.5)
	{
        return Math.PI / (Complex.Sin( Math.PI * z) * Gamma(1 - z));
	}
    else
	{
        z -= 1;
        Complex x = p[0];
        for (var i = 1; i < g + 2; i++)
		{
            x += p[i]/(z+i);
		}
        Complex t = z + g + 0.5;
        return Complex.Sqrt(2 * Math.PI) * (Complex.Pow(t, z + 0.5)) * Complex.Exp(-t) * x;
	}
}
 ",695,28
51829,http://rosettacode.org/wiki/Fusc_sequence,Fusc sequence,"

Definitions

The   fusc   integer sequence is defined as:

   fusc(0) = 0
   fusc(1) = 1
   for n>1,   the   nth   term is defined as:
   if   n   is even;     fusc(n) = fusc(n/2)
   if   n   is   odd;     fusc(n) = fusc((n-1)/2)   +   fusc((n+1)/2)


Note that MathWorld's definition starts with unity, not zero.   This task will be using the OEIS' version   (above).



An observation

   fusc(A) = fusc(B)
where   A   is some non-negative integer expressed in binary,   and
where   B   is the binary value of   A   reversed.



Fusc numbers are also known as:

   fusc function   (named by Dijkstra, 1982)
   Stern's Diatomic series   (although it starts with unity, not zero)
   Stern-Brocot sequence   (although it starts with unity, not zero)


Task

   show the first   61   fusc numbers (starting at zero) in a horizontal format.
   show the fusc number (and its index) whose length is greater than any previous fusc number length.
   (the length is the number of decimal digits when the fusc number is expressed in base ten.)
   show all numbers with commas   (if appropriate).
   show all output here.


Related task

   RosettaCode Stern-Brocot sequence


Also see

   the MathWorld entry:   Stern's Diatomic Series.
   the OEIS entry:   A2487.

",#C.23,C#,"using System;
using System.Collections.Generic;
 
static class program
{
    static int n = 61;
    static List<int> l = new List<int>() { 0, 1 };
 
    static int fusc(int n)
    {
        if (n < l.Count) return l[n];
        int f = (n & 1) == 0 ? l[n >> 1] : l[(n - 1) >> 1] + l[(n + 1) >> 1];
        l.Add(f); return f;
    }
 
    static void Main(string[] args)
    {
        bool lst = true; int w = -1, c = 0, t;
        string fs = ""{0,11:n0}  {1,-9:n0}"", res = """";
        Console.WriteLine(""First {0} numbers in the fusc sequence:"", n);
        for (int i = 0; i < int.MaxValue; i++)
        {
            int f = fusc(i); if (lst)
            {
                if (i < 61) Console.Write(""{0} "", f);
                else
                {
                    lst = false;
                    Console.WriteLine();
                    Console.WriteLine(""Points in the sequence where an item has more digits than any previous items:"");
                    Console.WriteLine(fs, ""Index\\"", ""/Value""); Console.WriteLine(res); res = """";
                }
            }
            if ((t = f.ToString().Length) > w)
            {
                w = t; res += (res == """" ? """" : ""\n"") + string.Format(fs, i, f);
                if (!lst) { Console.WriteLine(res); res = """"; } if (++c > 5) break;
            }
        }
        l.Clear();
    }
}",1352,42
51964,http://rosettacode.org/wiki/Function_composition,Function composition,"Task

Create a function, compose,   whose two arguments   f   and   g,   are both functions with one argument.



The result of compose is to be a function of one argument, (lets call the argument   x),   which works like applying function    f    to the result of applying function    g    to    x.



Example

 compose(f, g) (x) = f(g(x))



Reference: Function composition

Hint: In some languages, implementing compose correctly requires creating a closure.



",#C.23,C#,"using System;
class Program
{
    static void Main(string[] args)
    {
        Func<int, int> outfunc = Composer<int, int, int>.Compose(functA, functB);
        Console.WriteLine(outfunc(5)); //Prints 100
    }
    static int functA(int i) { return i * 10; }
    static int functB(int i) { return i + 5; }
    class Composer<A, B, C>
    {
        public static Func<C, A> Compose(Func<B, A> a, Func<C, B> b)
        {
            return delegate(C i) { return a(b(i)); };
        }
    }
}",491,18
51991,http://rosettacode.org/wiki/Fraction_reduction,Fraction reduction,"              There is a fine line between numerator and denominator.       ─── anonymous



A method to   ""reduce""   some reducible fractions is to   cross out   a digit from the
numerator and the denominator.   An example is:

       16                                                  16
      ────     and then (simply) cross─out the sixes:      ────
       64                                                  64

resulting in:

        1
       ───    
        4



Naturally,   this ""method"" of reduction must reduce to the proper value   (shown as a fraction).

This ""method"" is also known as   anomalous cancellation   and also   accidental cancellation.



(Of course,   this ""method"" shouldn't be taught to impressionable or gullible minds.)        😇 



Task

Find and show some fractions that can be reduced by the above ""method"".

   show 2-digit fractions found   (like the example shown above)
   show 3-digit fractions
   show 4-digit fractions
   show 5-digit fractions   (and higher)       (optional)
   show each (above) n-digit fractions separately from other different n-sized fractions, don't mix different ""sizes"" together
   for each ""size"" fraction,   only show a dozen examples   (the 1st twelve found)
   (it's recognized that not every programming solution will have the same generation algorithm)
   for each ""size"" fraction:
   show a count of how many reducible fractions were found.   The example (above) is size 2
   show a count of which digits were crossed out   (one line for each different digit)
   for each ""size"" fraction,   show a count of how many were found.   The example (above) is size 2
   show each n-digit example   (to be shown on one line):
   show each n-digit fraction
   show each reduced n-digit fraction
   show what digit was crossed out for the numerator and the denominator


Task requirements/restrictions

   only proper fractions and their reductions   (the result)   are to be used   (no vulgar fractions)
   only positive fractions are to be used   (no negative signs anywhere)
   only base ten integers are to be used for the numerator and denominator
   no zeros   (decimal digit)   can be used within the numerator or the denominator
   the numerator and denominator should be composed of the same number of digits
   no digit can be repeated in the numerator
   no digit can be repeated in the denominator
   (naturally)   there should be a shared decimal digit in the numerator   and   the denominator
   fractions can be shown as   16/64   (for example)


Show all output here, on this page.



Somewhat related task

   Farey sequence       (It concerns fractions.) 


References

   Wikipedia entry:   proper and improper fractions.
   Wikipedia entry:   anomalous cancellation and/or accidental cancellation.

",#C.23,C#,"using System;
 
namespace FractionReduction {
    class Program {
        static int IndexOf(int n, int[] s) {
            for (int i = 0; i < s.Length; i++) {
                if (s[i] == n) {
                    return i;
                }
            }
            return -1;
        }
 
        static bool GetDigits(int n, int le, int[] digits) {
            while (n > 0) {
                var r = n % 10;
                if (r == 0 || IndexOf(r, digits) >= 0) {
                    return false;
                }
                le--;
                digits[le] = r;
                n /= 10;
            }
            return true;
        }
 
        static int RemoveDigit(int[] digits, int le, int idx) {
            int[] pows = { 1, 10, 100, 1000, 10000 };
 
            var sum = 0;
            var pow = pows[le - 2];
            for (int i = 0; i < le; i++) {
                if (i == idx) continue;
                sum += digits[i] * pow;
                pow /= 10;
 
            }
            return sum;
        }
 
        static void Main() {
            var lims = new int[,] { { 12, 97 }, { 123, 986 }, { 1234, 9875 }, { 12345, 98764 } };
            var count = new int[5];
            var omitted = new int[5, 10];
            var upperBound = lims.GetLength(0);
            for (int i = 0; i < upperBound; i++) {
                var nDigits = new int[i + 2];
                var dDigits = new int[i + 2];
                var blank = new int[i + 2];
                for (int n = lims[i, 0]; n <= lims[i, 1]; n++) {
                    blank.CopyTo(nDigits, 0);
                    var nOk = GetDigits(n, i + 2, nDigits);
                    if (!nOk) {
                        continue;
                    }
                    for (int d = n + 1; d <= lims[i, 1] + 1; d++) {
                        blank.CopyTo(dDigits, 0);
                        var dOk = GetDigits(d, i + 2, dDigits);
                        if (!dOk) {
                            continue;
                        }
                        for (int nix = 0; nix < nDigits.Length; nix++) {
                            var digit = nDigits[nix];
                            var dix = IndexOf(digit, dDigits);
                            if (dix >= 0) {
                                var rn = RemoveDigit(nDigits, i + 2, nix);
                                var rd = RemoveDigit(dDigits, i + 2, dix);
                                if ((double)n / d == (double)rn / rd) {
                                    count[i]++;
                                    omitted[i, digit]++;
                                    if (count[i] <= 12) {
                                        Console.WriteLine(""{0}/{1} = {2}/{3} by omitting {4}'s"", n, d, rn, rd, digit);
                                    }
                                }
                            }
                        }
                    }
                }
                Console.WriteLine();
            }
 
            for (int i = 2; i <= 5; i++) {
                Console.WriteLine(""There are {0} {1}-digit fractions of which:"", count[i - 2], i);
                for (int j = 1; j <= 9; j++) {
                    if (omitted[i - 2, j] == 0) {
                        continue;
                    }
                    Console.WriteLine(""{0,6} have {1}'s omitted"", omitted[i - 2, j], j);
                }
                Console.WriteLine();
            }
        }
    }
}",3443,94
52457,http://rosettacode.org/wiki/Function_definition,Function definition,"A function is a body of code that returns a value.

The value returned may depend on arguments provided to the function.



Task

Write a definition of a function called ""multiply"" that takes two arguments and returns their product.

(Argument types should be chosen so as not to distract from showing how functions are created and values returned).



Related task

   Function prototype

",#C.23,C#,"static double multiply(double a, double b)
{
    return a * b;
}",64,4
52782,http://rosettacode.org/wiki/Fork,Fork,"Task

Spawn a new process which can run simultaneously with, and independently of, the original parent process.



",#C.23,C#,"using System;
using System.Threading;
 
namespace Fork {
    class Program {
        static void Fork() {
            Console.WriteLine(""Spawned Thread"");
        }
 
        static void Main(string[] args) {
            Thread t = new Thread(new ThreadStart(Fork));
            t.Start();
 
            Console.WriteLine(""Main Thread"");
            t.Join();
 
            Console.ReadLine();
        }
    }
}",411,20
52934,http://rosettacode.org/wiki/Formatted_numeric_output,Formatted numeric output,"Task

Express a number in decimal as a fixed-length string with leading zeros.



For example, the number   7.125   could be expressed as   00007.125.



",#C.23,C#," 
class Program
    {
 
 
        static void Main(string[] args)
        {
 
            float myNumbers = 7.125F;
 
            string strnumber = Convert.ToString(myNumbers);
 
            Console.WriteLine(strnumber.PadLeft(9, '0'));
 
            Console.ReadLine();
        }
 
 
 
 
    }
 ",297,22
52973,http://rosettacode.org/wiki/Four_bit_adder,Four bit adder,"Task

""Simulate"" a four-bit adder.

This design can be realized using four 1-bit full adders.
Each of these 1-bit full adders can be built with two half adders and an   or   gate. ;

Finally a half adder can be made using an   xor   gate and an   and   gate.

The   xor   gate can be made using two   nots,   two   ands   and one   or.

Not,   or   and   and,   the only allowed ""gates"" for the task, can be ""imitated"" by using the bitwise operators of your language.

If there is not a bit type in your language, to be sure that the   not   does not ""invert"" all the other bits of the basic type   (e.g. a byte)   we are not interested in,   you can use an extra   nand   (and   then   not)   with the constant   1   on one input.

Instead of optimizing and reducing the number of gates used for the final 4-bit adder,   build it in the most straightforward way,   connecting the other ""constructive blocks"",   in turn made of ""simpler"" and ""smaller"" ones.


Schematics of the ""constructive blocks""


(Xor gate with ANDs, ORs and NOTs)        

   (A half adder)        

          (A full adder)            

                (A 4-bit adder)        












Solutions should try to be as descriptive as possible, making it as easy as possible to identify ""connections"" between higher-order ""blocks"".

It is not mandatory to replicate the syntax of higher-order blocks in the atomic ""gate"" blocks, i.e. basic ""gate"" operations can be performed as usual bitwise operations, or they can be ""wrapped"" in a block in order to expose the same syntax of higher-order blocks, at implementers' choice.

To test the implementation, show the sum of two four-bit numbers (in binary).



",#C.23,C#," 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace RosettaCodeTasks.FourBitAdder
{
	public struct BitAdderOutput
	{
		public bool S { get; set; }
		public bool C { get; set; }
		public override string ToString ( )
		{
			return ""S"" + ( S ? ""1"" : ""0"" ) + ""C"" + ( C ? ""1"" : ""0"" );
		}
	}
	public struct Nibble
	{
		public bool _1 { get; set; }
		public bool _2 { get; set; }
		public bool _3 { get; set; }
		public bool _4 { get; set; }
		public override string ToString ( )
		{
			return ( _4 ? ""1"" : ""0"" )
				+ ( _3 ? ""1"" : ""0"" )
				+ ( _2 ? ""1"" : ""0"" )
				+ ( _1 ? ""1"" : ""0"" );
		}
	}
	public struct FourBitAdderOutput
	{
		public Nibble N { get; set; }
		public bool C { get; set; }
		public override string ToString ( )
		{
			return N.ToString ( ) + ""c"" + ( C ? ""1"" : ""0"" );
		}
	}
 
	public static class LogicGates
	{
		// Basic Gates
		public static bool Not ( bool A ) { return !A; }
		public static bool And ( bool A, bool B ) { return A && B; }
		public static bool Or ( bool A, bool B ) { return A || B; }
 
		// Composite Gates
		public static bool Xor ( bool A, bool B ) {	return Or ( And ( A, Not ( B ) ), ( And ( Not ( A ), B ) ) ); }
	}
 
	public static class ConstructiveBlocks
	{
		public static BitAdderOutput HalfAdder ( bool A, bool B )
		{
			return new BitAdderOutput ( ) { S = LogicGates.Xor ( A, B ), C = LogicGates.And ( A, B ) };
		}
 
		public static BitAdderOutput FullAdder ( bool A, bool B, bool CI )
		{
			BitAdderOutput HA1 = HalfAdder ( CI, A );
			BitAdderOutput HA2 = HalfAdder ( HA1.S, B );
 
			return new BitAdderOutput ( ) { S = HA2.S, C = LogicGates.Or ( HA1.C, HA2.C ) };
		}
 
		public static FourBitAdderOutput FourBitAdder ( Nibble A, Nibble B, bool CI )
		{
 
			BitAdderOutput FA1 = FullAdder ( A._1, B._1, CI );
			BitAdderOutput FA2 = FullAdder ( A._2, B._2, FA1.C );
			BitAdderOutput FA3 = FullAdder ( A._3, B._3, FA2.C );
			BitAdderOutput FA4 = FullAdder ( A._4, B._4, FA3.C );
 
			return new FourBitAdderOutput ( ) { N = new Nibble ( ) { _1 = FA1.S, _2 = FA2.S, _3 = FA3.S, _4 = FA4.S }, C = FA4.C };
		}
 
		public static void Test ( )
		{
			Console.WriteLine ( ""Four Bit Adder"" );
 
			for ( int i = 0; i < 256; i++ )
			{
				Nibble A = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };
				Nibble B = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };
				if ( (i & 1) == 1)
				{
					A._1 = true;
				}
				if ( ( i & 2 ) == 2 )
				{
					A._2 = true;
				}
				if ( ( i & 4 ) == 4 )
				{
					A._3 = true;
				}
				if ( ( i & 8 ) == 8 )
				{
					A._4 = true;
				}
				if ( ( i & 16 ) == 16 )
				{
					B._1 = true;
				}
				if ( ( i & 32 ) == 32)
				{
					B._2 = true;
				}
				if ( ( i & 64 ) == 64 )
				{
					B._3 = true;
				}
				if ( ( i & 128 ) == 128 )
				{
					B._4 = true;
				}
 
				Console.WriteLine ( ""{0} + {1} = {2}"", A.ToString ( ), B.ToString ( ), FourBitAdder( A, B, false ).ToString ( ) );
 
			}
 
			Console.WriteLine ( );
		}
 
	}
}
 
 ",3021,130
53030,http://rosettacode.org/wiki/Forward_difference,Forward difference,"Task

Provide code that produces a list of numbers which is the   nth  order forward difference, given a non-negative integer (specifying the order) and a list of numbers.



The first-order forward difference of a list of numbers   A   is a new list   B,   where   Bn = An+1 - An.

List   B   should have one fewer element as a result.

The second-order forward difference of   A   will be:

tdefmodule Diff do
	def forward(arr,i\\1) do
		forward(arr,[],i)
	end

	def forward([_|[]],diffs,i) do
		if i == 1 do
			IO.inspect diffs
		else 
			forward(diffs,[],i-1)
		end
	end

	def forward([val1|[val2|vals]],diffs,i) do
		forward([val2|vals],diffs++[val2-val1],i) 
	end
end 

The same as the first-order forward difference of   B.

That new list will have two fewer elements than   A   and one less than   B.

The goal of this task is to repeat this process up to the desired order.

For a more formal description, see the related   Mathworld article.



Algorithmic options

 Iterate through all previous forward differences and re-calculate a new array each time.
 Use this formula (from Wikipedia):


 




Δ

n


[
f
]
(
x
)
=

∑

k
=
0


n





(


n
k


)



(
−
1

)

n
−
k


f
(
x
+
k
)


{\displaystyle \Delta ^{n}[f](x)=\sum _{k=0}^{n}{n \choose k}(-1)^{n-k}f(x+k)}




 (Pascal's Triangle   may be useful for this option.)

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
class Program
{
    static IEnumerable<int> ForwardDifference(IEnumerable<int> sequence, uint order = 1u)
    {
        switch (order)
        {
            case 0u:
                return sequence;
            case 1u:
                return sequence.Skip(1).Zip(sequence, (next, current) => next - current);
            default:
                return ForwardDifference(ForwardDifference(sequence), order - 1u);
        }
    }
 
    static void Main()
    {
        IEnumerable<int> sequence = new[] { 90, 47, 58, 29, 22, 32, 55, 5, 55, 73 };
        do
        {
            Console.WriteLine(string.Join("", "", sequence));
        } while ((sequence = ForwardDifference(sequence)).Any());
    }
}",769,28
53172,http://rosettacode.org/wiki/Floyd-Warshall_algorithm,Floyd-Warshall algorithm,"The Floyd–Warshall algorithm is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights.




Task
Find the lengths of the shortest paths between all pairs of vertices of the given directed graph. Your code may assume that the input has already been checked for loops, parallel edges and negative cycles.


Print the pair, the distance and (optionally) the path.




Example
pair     dist    path
1 -> 2    -1     1 -> 3 -> 4 -> 2
1 -> 3    -2     1 -> 3
1 -> 4     0     1 -> 3 -> 4
2 -> 1     4     2 -> 1
2 -> 3     2     2 -> 1 -> 3
2 -> 4     4     2 -> 1 -> 3 -> 4
3 -> 1     5     3 -> 4 -> 2 -> 1
3 -> 2     1     3 -> 4 -> 2
3 -> 4     2     3 -> 4
4 -> 1     3     4 -> 2 -> 1
4 -> 2    -1     4 -> 2
4 -> 3     1     4 -> 2 -> 1 -> 3


See also
 Floyd-Warshall Algorithm - step by step guide (youtube)

",#C.23,C#,"using System;
 
namespace FloydWarshallAlgorithm {
    class Program {
        static void FloydWarshall(int[,] weights, int numVerticies) {
            double[,] dist = new double[numVerticies, numVerticies];
            for (int i = 0; i < numVerticies; i++) {
                for (int j = 0; j < numVerticies; j++) {
                    dist[i, j] = double.PositiveInfinity;
                }
            }
 
            for (int i = 0; i < weights.GetLength(0); i++) {
                dist[weights[i, 0] - 1, weights[i, 1] - 1] = weights[i, 2];
            }
 
            int[,] next = new int[numVerticies, numVerticies];
            for (int i = 0; i < numVerticies; i++) {
                for (int j = 0; j < numVerticies; j++) {
                    if (i != j) {
                        next[i, j] = j + 1;
                    }
                }
            }
 
            for (int k = 0; k < numVerticies; k++) {
                for (int i = 0; i < numVerticies; i++) {
                    for (int j = 0; j < numVerticies; j++) {
                        if (dist[i, k] + dist[k, j] < dist[i, j]) {
                            dist[i, j] = dist[i, k] + dist[k, j];
                            next[i, j] = next[i, k];
                        }
                    }
                }
            }
 
            PrintResult(dist, next);
        }
 
        static void PrintResult(double[,] dist, int[,] next) {
            Console.WriteLine(""pair     dist    path"");
            for (int i = 0; i < next.GetLength(0); i++) {
                for (int j = 0; j < next.GetLength(1); j++) {
                    if (i != j) {
                        int u = i + 1;
                        int v = j + 1;
                        string path = string.Format(""{0} -> {1}    {2,2:G}     {3}"", u, v, dist[i, j], u);
                        do {
                            u = next[u - 1, v - 1];
                            path += "" -> "" + u;
                        } while (u != v);
                        Console.WriteLine(path);
                    }
                }
            }
        }
 
        static void Main(string[] args) {
            int[,] weights = { { 1, 3, -2 }, { 2, 1, 4 }, { 2, 3, 3 }, { 3, 4, 2 }, { 4, 2, -1 } };
            int numVerticies = 4;
 
            FloydWarshall(weights, numVerticies);
        }
    }
}",2350,65
53222,http://rosettacode.org/wiki/Flow-control_structures,Flow-control structures,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops



Task

Document common flow-control structures.



One common example of a flow-control structure is the    goto    construct.

Note that   Conditional Structures   and   Loop Structures   have their own articles/categories.



Related tasks

   Conditional Structures
   Loop Structures 

",#C.23,C#,"int GetNumber() {
    return 5;
}",33,3
53308,http://rosettacode.org/wiki/Forest_fire,Forest fire,"

 This page uses content from Wikipedia. The original article was at Forest-fire model. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Implement the Drossel and Schwabl definition of the forest-fire model.



It is basically a 2D   cellular automaton   where each cell can be in three distinct states (empty, tree and burning) and evolves according to the following rules (as given by Wikipedia)

 A burning cell turns into an empty cell
 A tree will burn if at least one neighbor is burning
 A tree ignites with probability   f    even if no neighbor is burning
 An empty space fills with a tree with probability    p 

Neighborhood is the   Moore neighborhood;   boundary conditions are so that on the boundary the cells are always empty (""fixed"" boundary condition).

At the beginning, populate the lattice with empty and tree cells according to a specific probability (e.g. a cell has the probability 0.5 to be a tree). Then, let the system evolve.

Task's requirements do not include graphical display or the ability to change parameters (probabilities    p    and    f )   through a graphical or command line interface.



Related tasks

   See   Conway's Game of Life 
   See   Wireworld.

",#C.23,C#,"using System;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Threading;
using System.Windows.Forms;
 
namespace ForestFire
{
    class Program : Form
    {
        private static readonly Random rand = new Random();
        private Bitmap img;
 
        public Program(int w, int h, int f, int p)
        {
            Size = new Size(w, h);
            StartPosition = FormStartPosition.CenterScreen;
 
            Thread t = new Thread(() => fire(f, p));
            t.Start();
 
            FormClosing += (object sender, FormClosingEventArgs e) => { t.Abort(); t = null; };
        }
 
        private void fire(int f, int p)
        {
            int clientWidth = ClientRectangle.Width;
            int clientHeight = ClientRectangle.Height;
            int cellSize = 10;
 
            img = new Bitmap(clientWidth, clientHeight);
            Graphics g = Graphics.FromImage(img);
 
            CellState[,] state = InitializeForestFire(clientWidth, clientHeight);
 
            uint generation = 0;
 
            do
            {
                g.FillRectangle(Brushes.White, 0, 0, img.Width, img.Height);
                state = StepForestFire(state, f, p);
 
                for (int y = 0; y < clientHeight - cellSize; y += cellSize)
                {
                    for (int x = 0; x < clientWidth - cellSize; x += cellSize)
                    {
                        switch (state[y, x])
                        {
                            case CellState.Empty:
                                break;
                            case CellState.Tree:
                                g.FillRectangle(Brushes.DarkGreen, x, y, cellSize, cellSize);
                                break;
                            case CellState.Burning:
                                g.FillRectangle(Brushes.DarkRed, x, y, cellSize, cellSize);
                                break;
                        }
                    }
                }
 
                Thread.Sleep(500);
 
                Invoke((MethodInvoker)Refresh);
 
            } while (generation < uint.MaxValue);
 
            g.Dispose();
        }
 
        private CellState[,] InitializeForestFire(int width, int height)
        {
            // Create our state array, initialize all indices as Empty, and return it.
            var state = new CellState[height, width];
            state.Initialize();
            return state;
        }
 
        private enum CellState : byte
        {
            Empty = 0,
            Tree = 1,
            Burning = 2
        }
 
        private CellState[,] StepForestFire(CellState[,] state, int f, int p)
        {
            /* Clone our old state, so we can write to our new state
             * without changing any values in the old state. */
            var newState = (CellState[,])state.Clone();
 
            int numRows = state.GetLength(0);
            int numCols = state.GetLength(1);
 
            for (int r = 1; r < numRows - 1; r++)
            {
                for (int c = 1; c < numCols - 1; c++)
                {
                    /* 
                     * Check the current cell.
                     * 
                     * If it's empty, give it a 1/p chance of becoming a tree.
                     * 
                     * If it's a tree, check to see if any neighbors are burning.
                     * If so, set the cell's state to burning, otherwise give it
                     * a 1/f chance of combusting.
                     * 
                     * If it's burning, set it to empty.
                     */
                    switch (state[r, c])
                    {
                        case CellState.Empty:
                            if (rand.Next(0, p) == 0)
                                newState[r, c] = CellState.Tree;
                            break;
 
                        case CellState.Tree:
                            if (NeighborHasState(state, r, c, CellState.Burning) || rand.Next(0, f) == 0)
                                newState[r, c] = CellState.Burning;
                            break;
 
                        case CellState.Burning:
                            newState[r, c] = CellState.Empty;
                            break;
                    }
                }
            }
 
            return newState;
        }
 
        private bool NeighborHasState(CellState[,] state, int x, int y, CellState value)
        {
            // Check each cell within a 1 cell radius for the specified value.
            for (int r = -1; r <= 1; r++)
            {
                for (int c = -1; c <= 1; c++)
                {
                    if (r == 0 && c == 0)
                        continue;
 
                    if (state[x + r, y + c] == value)
                        return true;
                }
            }
 
            return false;
        }
 
        protected override void OnPaint(PaintEventArgs e)
        {
            base.OnPaint(e);
            e.Graphics.DrawImage(img, 0, 0);
        }
 
        [STAThread]
        static void Main(string[] args)
        {
            Application.Run(new Program(w: 500, h: 500, f: 2, p: 5));
        }
    }
}",5216,161
53337,http://rosettacode.org/wiki/First-class_functions/Use_numbers_analogously,First-class functions/Use numbers analogously,"In First-class functions, a language is showing how its manipulation of functions is similar to its manipulation of other types.

This tasks aim is to compare and contrast a language's implementation of first class functions, with its normal handling of numbers.



Write a program to create an ordered collection of a mixture of literally typed and expressions producing a real number, together with another ordered collection of their multiplicative inverses. Try and use the following pseudo-code to generate the numbers for the ordered collections:

  x  = 2.0
  xi = 0.5
  y  = 4.0
  yi = 0.25
  z  = x + y
  zi = 1.0 / ( x + y )

Create a function multiplier, that given two numbers as arguments returns a function that when called with one argument, returns the result of multiplying the two arguments to the call to multiplier that created it and the argument in the call:

 new_function = multiplier(n1,n2)
 # where new_function(m) returns the result of n1 * n2 * m

Applying the multiplier of a number and its inverse from the two ordered collections of numbers in pairs, show that the result in each case is one.

Compare and contrast the resultant program with the corresponding entry in First-class functions. They should be close.

To paraphrase the task description: Do what was done before, but with numbers rather than functions
",#C.23,C#,"using System;
using System.Linq;
 
class Program
{
    static void Main(string[] args)
    {
        double x, xi, y, yi, z, zi;
        x = 2.0;
        xi = 0.5;
        y = 4.0;
        yi = 0.25;
        z = x + y;
        zi = 1.0 / (x + y);
 
        var numlist = new[] { x, y, z };
        var numlisti = new[] { xi, yi, zi };
        var multiplied = numlist.Zip(numlisti, (n1, n2) =>
                       {
                           Func<double, double> multiplier = m => n1 * n2 * m;
                           return multiplier;
                       });
 
        foreach (var multiplier in multiplied)
            Console.WriteLine(multiplier(0.5));
    }
}
 ",677,28
53374,http://rosettacode.org/wiki/First_power_of_2_that_has_leading_decimal_digits_of_12,First power of 2 that has leading decimal digits of 12,"(This task is taken from a   Project Euler   problem.)

(All numbers herein are expressed in base ten.)


27   =   128   and   7   is
the first power of   2   whose leading decimal digits are   12.

The next power of   2   whose leading decimal digits
are   12   is   80,

280   =   1208925819614629174706176.



Define        p(L,n)      to be the  nth-smallest
value of    j    such that the base ten representation
of    2j    begins with the digits of    L .

    So   p(12, 1) =  7    and
         p(12, 2) = 80



You are also given that:

         p(123, 45)   =   12710



Task

   find: 
     p(12, 1)  
     p(12, 2)  
     p(123, 45)  
     p(123, 12345)  
     p(123, 678910)  
   display the results here, on this page.

",#C.23,C#,"// a mini chrestomathy solution
 
using System;
 
class Program {
 
    // translated from java example
    static long js(int l, int n) {
        long res = 0, f = 1;
        double lf = Math.Log10(2);
        for (int i = l; i > 10; i /= 10) f *= 10;
        while (n > 0)
            if ((int)(f * Math.Pow(10, ++res * lf % 1)) == l) n--;
        return res;
    }
 
    // translated from go integer example (a.k.a. go translation of pascal alternative example)
    static long gi(int ld, int n) {
        string Ls = ld.ToString();
        long res = 0, count = 0, f = 1;
        for (int i = 1; i <= 18 - Ls.Length; i++) f *= 10;
        const long ten18 = (long)1e18; long probe = 1;
        do {
            probe <<= 1; res++; if (probe >= ten18)
                do {
                    if (probe >= ten18) probe /= 10;
                    if (probe / f == ld)
                        if (++count >= n) { count--; break; }
                    probe <<= 1; res++;
                } while (true);
            string ps = probe.ToString();
            if (ps.Substring(0, Math.Min(Ls.Length, ps.Length)) == Ls)
                if (++count >= n) break;
        } while (true);
        return res;
    }
 
    // translated from pascal alternative example
    static long pa(int ld, int n) {
        double L_float64 = Math.Pow(2, 64);
        ulong Log10_2_64 = (ulong)(L_float64 * Math.Log10(2));
        double Log10Num; ulong LmtUpper, LmtLower, Frac64;
        long res = 0, dgts = 1, cnt;
        for (int i = ld; i >= 10; i /= 10) dgts *= 10;
        Log10Num = Math.Log10((ld + 1.0) / dgts);
        // '316' was a limit
        if (Log10Num >= 0.5) {
            LmtUpper = (ld + 1.0) / dgts < 10.0 ? (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2) : 0;
            Log10Num = Math.Log10((double)ld / dgts);
            LmtLower = (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2);
        } else {
            LmtUpper = (ulong)(Log10Num * L_float64);
            LmtLower = (ulong)(Math.Log10((double)ld / dgts) * L_float64);
        }
        cnt = 0; Frac64 = 0; if (LmtUpper != 0)
            do {
                res++; Frac64 += Log10_2_64;
                if ((Frac64 >= LmtLower) & (Frac64 < LmtUpper))
                    if (++cnt >= n) break;
            } while (true);
        else // '999..'
            do {
                res++; Frac64 += Log10_2_64;
                if (Frac64 >= LmtLower) if (++cnt >= n) break;
            } while (true);
        return res;
    }
 
    static int[] values = new int[] { 12, 1, 12, 2, 123, 45, 123, 12345, 123, 678910, 99, 1 };
 
    static void doOne(string name, Func<int, int, long> fun) {
        Console.WriteLine(""{0} version:"", name);
        var start = DateTime.Now;
        for (int i = 0; i < values.Length; i += 2)
            Console.WriteLine(""p({0,3}, {1,6}) = {2,11:n0}"", values[i], values[i + 1], fun(values[i], values[i + 1]));
        Console.WriteLine(""Took {0} seconds\n"", DateTime.Now - start);
    }
 
    static void Main() {
        doOne(""java simple"", js);
        doOne(""go integer"", gi);
        doOne(""pascal alternative"", pa);
    }
}",3168,84
53449,http://rosettacode.org/wiki/Floyd%27s_triangle,Floyd's triangle,"Floyd's triangle   lists the natural numbers in a right triangle aligned to the left where

 the first row is   1     (unity)
 successive rows start towards the left with the next number followed by successive naturals listing one more number than the line above.


The first few lines of a Floyd triangle looks like this:

 1
 2  3
 4  5  6
 7  8  9 10
11 12 13 14 15



Task

 Write a program to generate and display here the first   n   lines of a Floyd triangle. 
(Use   n=5   and   n=14   rows).
 Ensure that when displayed in a mono-space font, the numbers line up in vertical columns as shown and that only one space separates numbers of the last row.

",#C.23,C#,"using System;
using System.Text;
 
public class FloydsTriangle
{
    internal static void Main(string[] args)
    {
        int count;
        if (args.Length >= 1 && int.TryParse(args[0], out count) && count > 0)
        {
            Console.WriteLine(MakeTriangle(count));
        }
        else
        {
            Console.WriteLine(MakeTriangle(5));
            Console.WriteLine();
            Console.WriteLine(MakeTriangle(14));
        }
    }
 
    public static string MakeTriangle(int rows)
    {
        int maxValue = (rows * (rows + 1)) / 2;
        int digit = 0;
        StringBuilder output = new StringBuilder();
 
        for (int row = 1; row <= rows; row++)
        {
            for (int column = 0; column < row; column++)
            {
                int colMaxDigit = (maxValue - rows) + column + 1;
                if (column > 0)
                {
                    output.Append(' ');
                }
 
                digit++;
                output.Append(digit.ToString().PadLeft(colMaxDigit.ToString().Length));
            }
 
            output.AppendLine();
        }
 
        return output.ToString();
    }
}",1154,46
53459,http://rosettacode.org/wiki/Fivenum,Fivenum,"Many big data or scientific programs use boxplots to show distributions of data.   In addition, sometimes saving large arrays for boxplots can be impractical and use extreme amounts of RAM.   It can be useful to save large arrays as arrays with five numbers to save memory.

For example, the   R   programming language implements Tukey's five-number summary as the fivenum function.



Task

Given an array of numbers, compute the five-number summary.



Note
 
While these five numbers can be used to draw a boxplot,   statistical packages will typically need extra data.

Moreover, while there is a consensus about the ""box"" of the boxplot,   there are variations among statistical packages for the whiskers.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace Fivenum {
    public static class Helper {
        public static string AsString<T>(this ICollection<T> c, string format = ""{0}"") {
            StringBuilder sb = new StringBuilder(""["");
            int count = 0;
            foreach (var t in c) {
                if (count++ > 0) {
                    sb.Append("", "");
                }
                sb.AppendFormat(format, t);
            }
            return sb.Append(""]"").ToString();
        }
    }
 
    class Program {
        static double Median(double[] x, int start, int endInclusive) {
            int size = endInclusive - start + 1;
            if (size <= 0) throw new ArgumentException(""Array slice cannot be empty"");
            int m = start + size / 2;
            return (size % 2 == 1) ? x[m] : (x[m - 1] + x[m]) / 2.0;
        }
 
        static double[] Fivenum(double[] x) {
            foreach (var d in x) {
                if (Double.IsNaN(d)) {
                    throw new ArgumentException(""Unable to deal with arrays containing NaN"");
                }
            }
            double[] result = new double[5];
            Array.Sort(x);
            result[0] = x.First();
            result[2] = Median(x, 0, x.Length - 1);
            result[4] = x.Last();
            int m = x.Length / 2;
            int lowerEnd = (x.Length % 2 == 1) ? m : m - 1;
            result[1] = Median(x, 0, lowerEnd);
            result[3] = Median(x, m, x.Length - 1);
            return result;
        }
 
        static void Main(string[] args) {
            double[][] x1 = new double[][]{
                new double[]{ 15.0, 6.0, 42.0, 41.0, 7.0, 36.0, 49.0, 40.0, 39.0, 47.0, 43.0},
                new double[]{ 36.0, 40.0, 7.0, 39.0, 41.0, 15.0},
                new double[]{
                     0.14082834,  0.09748790,  1.73131507,  0.87636009, -1.95059594,  0.73438555,
                    -0.03035726,  1.46675970, -0.74621349, -0.72588772,  0.63905160,  0.61501527,
                    -0.98983780, -1.00447874, -0.62759469,  0.66206163,  1.04312009, -0.10305385,
                     0.75775634,  0.32566578
                },
            };
            foreach(var x in x1) {
                var result = Fivenum(x);
                Console.WriteLine(result.AsString(""{0:F8}""));
            }
        }
    }
}",2397,64
53491,http://rosettacode.org/wiki/Flatten_a_list,Flatten a list,"Task

Write a function to flatten the nesting in an arbitrary list of values.

Your program should work on the equivalent of this list:

  [[1], 2, [[3, 4], 5], [[[]]], [[[6]]], 7, 8, []]

Where the correct result would be the list:

   [1, 2, 3, 4, 5, 6, 7, 8]

Related task

   Tree traversal

",#C.23,C#," 
using System;
using System.Collections;
using System.Linq;
 
namespace RosettaCodeTasks
{
	static class FlattenList
	{
		public static ArrayList Flatten(this ArrayList List)
		{
			ArrayList NewList = new ArrayList ( );
 
			NewList.AddRange ( List );
 
			while ( NewList.OfType<ArrayList> ( ).Count ( ) > 0 )
			{
				int index = NewList.IndexOf ( NewList.OfType<ArrayList> ( ).ElementAt ( 0 ) );
				ArrayList Temp = (ArrayList)NewList[index];
				NewList.RemoveAt ( index );
				NewList.InsertRange ( index, Temp );
			}
 
			return NewList;
		}
	}
}
 ",558,28
53542,http://rosettacode.org/wiki/First_perfect_square_in_base_n_with_n_unique_digits,First perfect square in base n with n unique digits,"Find the first perfect square in a given base N that has at least N digits and
exactly N significant unique digits when expressed in base N.

E.G. In base 10, the first perfect square with at least 10 unique digits is 1026753849 (32043²).

You may use analytical methods to reduce the search space, but the code must do a search. Do not use magic numbers or just feed the code the answer to verify it is correct.

Task
 Find and display here, on this page, the first perfect square in base N, with N significant unique digits when expressed in base N, for each of base 2 through 12. Display each number in the base N for which it was calculated.
 (optional) Do the same for bases 13 through 16.
 (stretch goal) Continue on for bases 17 - ?? (Big Integer math)


See also

 OEIS A260182: smallest square that is pandigital in base n.
Related task
 Casting out nines

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Numerics;
 
static class Program
{
    static byte Base, bmo, blim, ic; static DateTime st0; static BigInteger bllim, threshold;
    static HashSet<byte> hs = new HashSet<byte>(), o = new HashSet<byte>();
    static string chars = ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz|"";
    static List<BigInteger> limits;
    static string ms;
 
    // convert BigInteger to string using current base
    static string toStr(BigInteger b) {
        string res = """"; BigInteger re; while (b > 0) {
            b = BigInteger.DivRem(b, Base, out re); res = chars[(byte)re] + res;
        } return res;
    }
 
    // check for a portion of digits, bailing if uneven
    static bool allInQS(BigInteger b) {
        BigInteger re; int c = ic; hs.Clear(); hs.UnionWith(o); while (b > bllim) {
            b = BigInteger.DivRem(b, Base, out re);
            hs.Add((byte)re); c += 1; if (c > hs.Count) return false;
        } return true;
    }
 
    // check for a portion of digits, all the way to the end
    static bool allInS(BigInteger b) {
        BigInteger re; hs.Clear(); hs.UnionWith(o); while (b > bllim) {
            b = BigInteger.DivRem(b, Base, out re); hs.Add((byte)re);
        } return hs.Count == Base;
    }
 
    // check for all digits, bailing if uneven
    static bool allInQ(BigInteger b) {
        BigInteger re; int c = 0; hs.Clear(); while (b > 0) {
            b = BigInteger.DivRem(b, Base, out re);
            hs.Add((byte)re); c += 1; if (c > hs.Count) return false;
        } return true;
    }
 
    // check for all digits, all the way to the end
    static bool allIn(BigInteger b) {
        BigInteger re; hs.Clear(); while (b > 0) {
            b = BigInteger.DivRem(b, Base, out re); hs.Add((byte)re);
        } return hs.Count == Base;
    }
 
    // parse a string into a BigInteger, using current base
    static BigInteger to10(string s) {
        BigInteger res = 0; foreach (char i in s) res = res * Base + chars.IndexOf(i);
        return res;
    }
 
    // returns the minimum value string, optionally inserting extra digit
    static string fixup(int n) {
        string res = chars.Substring(0, Base); if (n > 0) res = res.Insert(n, n.ToString());
        return ""10"" + res.Substring(2);
    }
 
    // checks the square against the threshold, advances various limits when needed
    static void check(BigInteger sq) {
        if (sq > threshold) {
            o.Remove((byte)chars.IndexOf(ms[blim])); blim -= 1; ic -= 1;
            threshold = limits[bmo - blim - 1]; bllim = to10(ms.Substring(0, blim + 1));
        }
    }
 
    // performs all the caclulations for the current base
    static void doOne() {
        limits = new List<BigInteger>();
        bmo = (byte)(Base - 1); byte dr = 0; if ((Base & 1) == 1) dr = (byte)(Base >> 1);
        o.Clear(); blim = 0;
        byte id = 0; int inc = 1; long i = 0; DateTime st = DateTime.Now; if (Base == 2) st0 = st;
        byte[] sdr = new byte[bmo]; byte rc = 0; for (i = 0; i < bmo; i++) {
            sdr[i] = (byte)((i * i) % bmo); rc += sdr[i] == dr ? (byte)1 : (byte)0;
            sdr[i] += sdr[i] == 0 ? bmo : (byte)0;
        } i = 0; if (dr > 0) {
            id = Base;
            for (i = 1; i <= dr; i++) if (sdr[i] >= dr) if (id > sdr[i]) id = sdr[i]; id -= dr;
            i = 0;
        } ms = fixup(id);
        BigInteger sq = to10(ms); BigInteger rt = new BigInteger(Math.Sqrt((double)sq) + 1);
        sq = rt * rt; if (Base > 9) {
            for (int j = 1; j < Base; j++)
                limits.Add(to10(ms.Substring(0, j) + new string(chars[bmo], Base - j + (rc > 0 ? 0 : 1))));
            limits.Reverse(); while (sq < limits[0]) { rt++; sq = rt * rt; }
        }
        BigInteger dn = (rt << 1) + 1; BigInteger d = 1; if (Base > 3 && rc > 0) {
            while (sq % bmo != dr) { rt += 1; sq += dn; dn += 2; } // alligns sq to dr
            inc = bmo / rc;
            if (inc > 1) { dn += rt * (inc - 2) - 1; d = inc * inc; }
            dn += dn + d;
        }
        d <<= 1; if (Base > 9) {
            blim = 0; while (sq < limits[bmo - blim - 1]) blim++; ic = (byte)(blim + 1);
            threshold = limits[bmo - blim - 1];
            if (blim > 0) for (byte j = 0; j <= blim; j++) o.Add((byte)chars.IndexOf(ms[j]));
            if (blim > 0) bllim = to10(ms.Substring(0, blim + 1)); else bllim = 0;
            if (Base > 5 && rc > 0)
                do { if (allInQS(sq)) break; sq += dn; dn += d; i += 1; check(sq); } while (true);
            else
                do { if (allInS(sq)) break; sq += dn; dn += d; i += 1; check(sq); } while (true);
        } else {
            if (Base > 5 && rc > 0)
                do { if (allInQ(sq)) break; sq += dn; dn += d; i += 1; } while (true);
            else
                do { if (allIn(sq)) break; sq += dn; dn += d; i += 1; } while (true);
        } rt += i * inc;
        Console.WriteLine(""{0,3}  {1,2}  {2,2} {3,20} -> {4,-40} {5,10} {6,9:0.0000}s  {7,9:0.0000}s"",
            Base, inc, (id > 0 ? chars.Substring(id, 1) : "" ""), toStr(rt), toStr(sq), i,
            (DateTime.Now - st).TotalSeconds, (DateTime.Now - st0).TotalSeconds);
    }
 
    static void Main(string[] args) {
        Console.WriteLine(""base inc id                 root    square"" +
            ""                                   test count    time        total"");
        for (Base = 2; Base <= 28; Base++) doOne();
        Console.WriteLine(""Elasped time was {0,8:0.00} minutes"", (DateTime.Now - st0).TotalMinutes);
    }
}",5573,122
53667,http://rosettacode.org/wiki/First-class_functions,First-class functions,"A language has first-class functions if it can do each of the following without recursively invoking a compiler or interpreter or otherwise metaprogramming:

 Create new functions from preexisting functions at run-time
 Store functions in collections
 Use functions as arguments to other functions
 Use functions as return values of other functions


Task

Write a program to create an ordered collection A of functions of a real number. At least one function should be built-in and at least one should be user-defined; try using the sine, cosine, and cubing functions. Fill another collection B with the inverse of each function in A. Implement function composition as in Functional Composition. Finally, demonstrate that the result of applying the composition of each function in A and its inverse in B to a value, is the original value. (Within the limits of computational accuracy).

(A solution need not actually call the collections ""A"" and ""B"". These names are only used in the preceding paragraph for clarity.)



Related task
 
First-class Numbers
",#C.23,C#,"using System;
 
class Program
{
    static void Main(string[] args)
    {
        var cube = new Func<double, double>(x => Math.Pow(x, 3.0));
        var croot = new Func<double, double>(x => Math.Pow(x, 1 / 3.0));
 
        var functionTuples = new[]
        {
            (forward: Math.Sin, backward: Math.Asin),
            (forward: Math.Cos, backward: Math.Acos),
            (forward: cube,     backward: croot)
        };
 
        foreach (var ft in functionTuples)
        {
            Console.WriteLine(ft.backward(ft.forward(0.5)));
        }
    }
}
 ",565,23
53752,http://rosettacode.org/wiki/Five_weekends,Five weekends,"The month of October in 2010 has five Fridays, five Saturdays, and five Sundays.



Task

 Write a program to show all months that have this same characteristic of five full weekends from the year 1900 through 2100 (Gregorian calendar). 
 Show the number of months with this property (there should be 201).
 Show at least the first and last five dates, in order.

Algorithm suggestions

 Count the number of Fridays, Saturdays, and Sundays in every month.
 Find all of the 31-day months that begin on Friday.

Extra credit

Count and/or show all of the years which do not have at least one five-weekend month (there should be 29).



Related tasks
 Day of the week
 Last Friday of each month
 Find last sunday of each month

",#C.23,C#,"using System;
 
namespace _5_Weekends
{
    class Program
    {
        const int FIRST_YEAR = 1900;
        const int LAST_YEAR = 2100;
        static int[] _31_MONTHS = { 1, 3, 5, 7, 8, 10, 12 }; 
 
        static void Main(string[] args)
        {
            int totalNum = 0;
            int totalNo5Weekends = 0;
 
            for (int year = FIRST_YEAR; year <= LAST_YEAR; year++)
            {
                bool has5Weekends = false;
 
                foreach (int month in _31_MONTHS)
                {
                    DateTime firstDay = new DateTime(year, month, 1);
                    if (firstDay.DayOfWeek == DayOfWeek.Friday)
                    {
                        totalNum++;
                        has5Weekends = true;
                        Console.WriteLine(firstDay.ToString(""yyyy - MMMM""));
                    }
                }
 
                if (!has5Weekends) totalNo5Weekends++;
            }
            Console.WriteLine(""Total 5-weekend months between {0} and {1}: {2}"", FIRST_YEAR, LAST_YEAR, totalNum);
            Console.WriteLine(""Total number of years with no 5-weekend months {0}"", totalNo5Weekends);
        }
    }
}",1175,37
53810,http://rosettacode.org/wiki/Find_the_intersection_of_two_lines,Find the intersection of two lines,"[1]


Task

Find the point of intersection of two lines in 2D.



The 1st line passes though    (4,0)    and    (6,10) .

The 2nd line passes though    (0,3)    and    (10,7) .



",#C.23,C#,"using System;
using System.Drawing;
public class Program
{
    static PointF FindIntersection(PointF s1, PointF e1, PointF s2, PointF e2) {
        float a1 = e1.Y - s1.Y;
        float b1 = s1.X - e1.X;
        float c1 = a1 * s1.X + b1 * s1.Y;
 
        float a2 = e2.Y - s2.Y;
        float b2 = s2.X - e2.X;
        float c2 = a2 * s2.X + b2 * s2.Y;
 
        float delta = a1 * b2 - a2 * b1;
        //If lines are parallel, the result will be (NaN, NaN).
        return delta == 0 ? new PointF(float.NaN, float.NaN)
            : new PointF((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);
    }
 
    static void Main() {
        Func<float, float, PointF> p = (x, y) => new PointF(x, y);
        Console.WriteLine(FindIntersection(p(4f, 0f), p(6f, 10f), p(0f, 3f), p(10f, 7f)));
        Console.WriteLine(FindIntersection(p(0f, 0f), p(1f, 1f), p(1f, 2f), p(4f, 5f)));
    }
}",893,25
53811,http://rosettacode.org/wiki/Find_the_intersection_of_a_line_with_a_plane,Find the intersection of a line with a plane,"Finding the intersection of an infinite ray with a plane in 3D is an important topic in collision detection.



Task

Find the point of intersection for the infinite ray with direction   (0, -1, -1)   passing through position   (0, 0, 10)   with the infinite plane with a normal vector of   (0, 0, 1)   and which passes through [0, 0, 5].



",#C.23,C#,"using System;
 
namespace FindIntersection {
    class Vector3D {
        private double x, y, z;
 
        public Vector3D(double x, double y, double z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
 
        public static Vector3D operator +(Vector3D lhs, Vector3D rhs) {
            return new Vector3D(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z);
        }
 
        public static Vector3D operator -(Vector3D lhs, Vector3D rhs) {
            return new Vector3D(lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z);
        }
 
        public static Vector3D operator *(Vector3D lhs, double rhs) {
            return new Vector3D(lhs.x * rhs, lhs.y * rhs, lhs.z * rhs);
        }
 
        public double Dot(Vector3D rhs) {
            return x * rhs.x + y * rhs.y + z * rhs.z;
        }
 
        public override string ToString() {
            return string.Format(""({0:F}, {1:F}, {2:F})"", x, y, z);
        }
    }
 
    class Program {
        static Vector3D IntersectPoint(Vector3D rayVector, Vector3D rayPoint, Vector3D planeNormal, Vector3D planePoint) {
            var diff = rayPoint - planePoint;
            var prod1 = diff.Dot(planeNormal);
            var prod2 = rayVector.Dot(planeNormal);
            var prod3 = prod1 / prod2;
            return rayPoint - rayVector * prod3;
        }
 
        static void Main(string[] args) {
            var rv = new Vector3D(0.0, -1.0, -1.0);
            var rp = new Vector3D(0.0, 0.0, 10.0);
            var pn = new Vector3D(0.0, 0.0, 1.0);
            var pp = new Vector3D(0.0, 0.0, 5.0);
            var ip = IntersectPoint(rv, rp, pn, pp);
            Console.WriteLine(""The ray intersects the plane at {0}"", ip);
        }
    }
}",1733,52
53867,http://rosettacode.org/wiki/Find_the_last_Sunday_of_each_month,Find the last Sunday of each month,"Write a program or a script that returns the last Sundays of each month of a given year. The year may be given through any simple input method in your language (command line, std in, etc).

Example of an expected output:

./last_sundays 2013
2013-01-27
2013-02-24
2013-03-31
2013-04-28
2013-05-26
2013-06-30
2013-07-28
2013-08-25
2013-09-29
2013-10-27
2013-11-24
2013-12-29


Related tasks
 Day of the week
 Five weekends
 Last Friday of each month

",#C.23,C#,"using System;
 
namespace LastSundayOfEachMonth
{
    class Program
    {
        static void Main()
        {
            Console.Write(""Year to calculate: "");
 
            string strYear = Console.ReadLine();
            int year = Convert.ToInt32(strYear);
 
            DateTime date;
            for (int i = 1; i <= 12; i++)
            {
                date = new DateTime(year, i, DateTime.DaysInMonth(year, i), System.Globalization.CultureInfo.CurrentCulture.Calendar);
                /* Modification by Albert Zakhia on 2021-16-02
                   The below code is very slow due to the loop, we will go twice as fast
                while (date.DayOfWeek != DayOfWeek.Sunday)
                {
                    date = date.AddDays(-1);
                }
                */
                // The updated code
                int daysOffset = date.DayOfWeek - dayOfWeek; // take the offset to subtract directly instead of looping
                if (daysOffset < 0) daysOffset += 7; // if the code is negative, we need to normalize them
                date = date.AddDays(-daysOffset ); // now just add the days offset
                Console.WriteLine(date.ToString(""yyyy-MM-dd""));
            }
        }
    }
}
 ",1235,34
54008,http://rosettacode.org/wiki/Find_the_missing_permutation,Find the missing permutation,"                    ABCD
                    CABD
                    ACDB
                    DACB
                    BCDA
                    ACBD
                    ADCB
                    CDAB
                    DABC
                    BCAD
                    CADB
                    CDBA
                    CBAD
                    ABDC
                    ADBC
                    BDCA
                    DCBA
                    BACD
                    BADC
                    BDAC
                    CBDA
                    DBCA
                    DCAB

Listed above are   all-but-one   of the permutations of the symbols   A,   B,   C,   and   D,   except   for one permutation that's   not   listed.



Task

Find that missing permutation.



Methods

 Obvious method: 
        enumerate all permutations of   A,  B,  C,  and  D,  
        and then look for the missing permutation. 

 alternate method:
        Hint:  if all permutations were shown above,  how many 
        times would  A  appear in each position?     
        What is the  parity  of this number?

 another alternate method:
        Hint:  if you add up the letter values of each column, 
        does a missing letter   A,  B,  C,  and  D   from each
        column cause the total value for each column to be unique?



Related task

   Permutations)

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace MissingPermutation
{
    class Program
    {
        static void Main()
        {
            string[] given = new string[] { ""ABCD"", ""CABD"", ""ACDB"", ""DACB"", 
                                            ""BCDA"", ""ACBD"", ""ADCB"", ""CDAB"", 
                                            ""DABC"", ""BCAD"", ""CADB"", ""CDBA"", 
                                            ""CBAD"", ""ABDC"", ""ADBC"", ""BDCA"", 
                                            ""DCBA"", ""BACD"", ""BADC"", ""BDAC"", 
                                            ""CBDA"", ""DBCA"", ""DCAB"" };
 
            List<string> result = new List<string>();
            permuteString(ref result, """", ""ABCD"");
 
            foreach (string a in result)            
                if (Array.IndexOf(given, a) == -1)
                    Console.WriteLine(a + "" is a missing Permutation"");
        }
 
        public static void permuteString(ref List<string> result, string beginningString, string endingString)
        {
            if (endingString.Length <= 1)
            {                 
                result.Add(beginningString + endingString);
            }
            else
            {
                for (int i = 0; i < endingString.Length; i++)
                {                     
                    string newString = endingString.Substring(0, i) + endingString.Substring(i + 1);
                    permuteString(ref result, beginningString + (endingString.ToCharArray())[i], newString);                    
                }
            }
        }
    }
}",1573,41
54491,http://rosettacode.org/wiki/FizzBuzz,FizzBuzz,"Task

Write a program that prints the integers from   1   to   100   (inclusive).



But:

   for multiples of three,   print   Fizz     (instead of the number)
   for multiples of five,   print   Buzz     (instead of the number)
   for multiples of both three and five,   print   FizzBuzz     (instead of the number) 


The   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.



Also see

   (a blog)   dont-overthink-fizzbuzz
   (a blog)   fizzbuzz-the-programmers-stairway-to-heaven

",#C.23,C#,"class Program
{
    public void FizzBuzzGo()
    {
        Boolean Fizz = false;
        Boolean Buzz = false;
        for (int count = 1; count <= 100; count ++)
        {
            Fizz = count % 3 == 0;
            Buzz = count % 5 == 0;
            if (Fizz && Buzz)
            {
                Console.WriteLine(""Fizz Buzz"");
                listBox1.Items.Add(""Fizz Buzz"");
            }
            else if (Fizz)
            {
                Console.WriteLine(""Fizz"");
                listBox1.Items.Add(""Fizz"");
            }
            else if (Buzz)
            {
                Console.WriteLine(""Buzz"");
                listBox1.Items.Add(""Buzz"");
            }
            else
            {
                Console.WriteLine(count);
                listBox1.Items.Add(count);
            }
        }
    }
}",829,33
54635,http://rosettacode.org/wiki/Find_largest_left_truncatable_prime_in_a_given_base,Find largest left truncatable prime in a given base,"A truncatable prime is one where all non-empty substrings that finish at the end of the number (right-substrings) are also primes when understood as numbers in a particular base. The largest such prime in a given (integer) base is therefore computable, provided the base is larger than 2.

Let's consider what happens in base 10. Obviously the right most digit must be prime, so in base 10 candidates are 2,3,5,7. Putting a digit in the range 1 to base-1 in front of each candidate must result in a prime. So 2 and 5, like the whale and the petunias in The Hitchhiker's Guide to the Galaxy, come into existence only to be extinguished before they have time to realize it, because 2 and 5 preceded by any digit in the range 1 to base-1 is not prime. Some numbers formed by preceding 3 or 7 by a digit in the range 1 to base-1 are prime. So 13,17,23,37,43,47,53,67,73,83,97 are candidates. Again, putting a digit in the range 1 to base-1 in front of each candidate must be a prime. Repeating until there are no larger candidates finds the largest left truncatable prime.

Let's work base 3 by hand:

0 and 1 are not prime so the last digit must be 2. 123 = 510 which is prime, 223 = 810 which is not so 123 is the only candidate. 1123 = 1410 which is not prime, 2123 = 2310 which is, so 2123 is the only candidate. 12123 = 5010 which is not prime, 22123 = 7710 which also is not prime. So there are no more candidates, therefore 23 is the largest left truncatable prime in base 3.

The task is to reconstruct as much, and possibly more, of the table in the OEIS as you are able.

Related Tasks:

 Miller-Rabin primality test

",#C.23,C#,"using Mpir.NET;  // 0.4.0
using System;   // 4790@3.6
using System.Collections.Generic;
class MaxLftTrP_B   
{
    static void Main()
    {
        mpz_t p; var sw = System.Diagnostics.Stopwatch.StartNew(); L(3);
        for (uint b = 3; b < 13; b++)
        {
            sw.Restart(); p = L(b);
            Console.WriteLine(""{0} {1,2} {2}"", sw.Elapsed, b, p);
        }
        Console.Read();
    }
 
    static mpz_t L(uint b)
    {
        var p = new List<mpz_t>(); mpz_t np = 0;
        while ((np = nxtP(np)) < b) p.Add(np);
        int i0 = 0, i = 0, i1 = p.Count - 1; mpz_t n0 = b, n, n1 = b * (b - 1);
        for (; i < p.Count; n0 *= b, n1 *= b, i0 = i1 + 1, i1 = p.Count - 1)
            for (n = n0; n <= n1; n += n0)
                for (i = i0; i <= i1; i++)
                    if (mpir.mpz_probab_prime_p(np = n + p[i], 15) > 0) p.Add(np);
        return p[p.Count - 1];
    }
 
    static mpz_t nxtP(mpz_t n) { mpz_t p = 0; mpir.mpz_nextprime(p, n); return p; }
}",984,30
54719,http://rosettacode.org/wiki/Find_limit_of_recursion,Find limit of recursion,"Find limit of recursion is part of Short Circuit's Console Program Basics selection.
Task

Find the limit of recursion.



",#C.23,C#,"using System;
class RecursionLimit
{
  static void Main(string[] args)
  {
    Recur(0);
  }
 
  private static void Recur(int i) 
  {
    Console.WriteLine(i);
    Recur(i + 1);
  }
}",184,14
54720,http://rosettacode.org/wiki/Find_palindromic_numbers_in_both_binary_and_ternary_bases,Find palindromic numbers in both binary and ternary bases,"Find palindromic numbers in both binary and ternary bases

You are encouraged to solve this task according to the task description, using any language you may know.
Task

   Find and show (in decimal) the first six numbers (non-negative integers) that are   palindromes   in   both:
   base 2
   base 3
   Display   0   (zero) as the first number found, even though some other definitions ignore it.
   Optionally, show the decimal number found in its binary and ternary form.
   Show all output here.


It's permissible to assume the first two numbers and simply list them.



See also
   Sequence A60792,   numbers that are palindromic in bases 2 and 3 on The On-Line Encyclopedia of Integer Sequences.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
public class FindPalindromicNumbers
{
    static void Main(string[] args)
    {
        var query =
            PalindromicTernaries()
            .Where(IsPalindromicBinary)
            .Take(6);
        foreach (var x in query) {
            Console.WriteLine(""Decimal: "" + x);
            Console.WriteLine(""Ternary: "" + ToTernary(x));
            Console.WriteLine(""Binary: "" + Convert.ToString(x, 2));
            Console.WriteLine();
        }
    }
 
    public static IEnumerable<long> PalindromicTernaries() {
        yield return 0;
        yield return 1;
        yield return 13;
        yield return 23;
 
        var f = new List<long> {0};
        long fMiddle = 9;
        while (true) {
            for (long edge = 1; edge < 3; edge++) {
                int i;
                do {
                    //construct the result
                    long result = fMiddle;
                    long fLeft = fMiddle * 3;
                    long fRight = fMiddle / 3;
                    for (int j = f.Count - 1; j >= 0; j--) {
                        result += (fLeft + fRight) * f[j];
                        fLeft *= 3;
                        fRight /= 3;
                    }
                    result += (fLeft + fRight) * edge;
                    yield return result;
 
                    //next permutation
                    for (i = f.Count - 1; i >= 0; i--) {
                        if (f[i] == 2) {
                            f[i] = 0;
                        } else {
                            f[i]++;
                            break;
                        }
                    }
                } while (i >= 0);
            }
            f.Add(0);
            fMiddle *= 3;
        }
    }
 
    public static bool IsPalindromicBinary(long number) {
        long n = number;
        long reverse = 0;
        while (n != 0) {
            reverse <<= 1;
            if ((n & 1) == 1) reverse++;
            n >>= 1;
        }
        return reverse == number;
    }
 
    public static string ToTernary(long n)
    {
        if (n == 0) return ""0"";
        string result = """";
        while (n > 0) {        {
            result = (n % 3) + result;
            n /= 3;
        }
        return result;
    }
 
}",2320,83
54821,http://rosettacode.org/wiki/Find_common_directory_path,Find common directory path,"Create a routine that, given a set of strings representing directory paths and a single character directory separator, will return a string representing that part of the directory tree that is common to all the directories.

Test your routine using the forward slash '/' character as the directory separator and the following three strings as input paths:

     '/home/user1/tmp/coverage/test'
     '/home/user1/tmp/covert/operator'
     '/home/user1/tmp/coven/members'

Note: The resultant path should be the valid directory '/home/user1/tmp' and not the longest common string '/home/user1/tmp/cove'.

If your language has a routine that performs this function (even if it does not have a changeable separator character), then mention it as part of the task.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#," 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace RosettaCodeTasks
{
 
	class Program
	{
		static void Main ( string[ ] args )
		{
			FindCommonDirectoryPath.Test ( );
		}
 
	}
 
	class FindCommonDirectoryPath
	{
		public static void Test ( )
		{
			Console.WriteLine ( ""Find Common Directory Path"" );
			Console.WriteLine ( );
			List<string> PathSet1 = new List<string> ( );
			PathSet1.Add ( ""/home/user1/tmp/coverage/test"" );
			PathSet1.Add ( ""/home/user1/tmp/covert/operator"" );
			PathSet1.Add ( ""/home/user1/tmp/coven/members"" );
			Console.WriteLine(""Path Set 1 (All Absolute Paths):"");
			foreach ( string path in PathSet1 )
			{
				Console.WriteLine ( path );
			}
			Console.WriteLine ( ""Path Set 1 Common Path: {0}"", FindCommonPath ( ""/"", PathSet1 ) );
		}
		public static string FindCommonPath ( string Separator, List<string> Paths )
		{
			string CommonPath = String.Empty;
			List<string> SeparatedPath = Paths
				.First ( str => str.Length == Paths.Max ( st2 => st2.Length ) )
				.Split ( new string[ ] { Separator }, StringSplitOptions.RemoveEmptyEntries )
				.ToList ( );
 
			foreach ( string PathSegment in SeparatedPath.AsEnumerable ( ) )
			{
				if ( CommonPath.Length == 0 && Paths.All ( str => str.StartsWith ( PathSegment ) ) )
				{
					CommonPath = PathSegment;
				}
				else if ( Paths.All ( str => str.StartsWith ( CommonPath + Separator + PathSegment ) ) )
				{
					CommonPath += Separator + PathSegment;
				}
				else
				{
					break;
				}
			}
 
			return CommonPath;
		}
	}
}
 
 ",1576,65
54853,http://rosettacode.org/wiki/File_modification_time,File modification time,"Task

Get and set the modification time of a file.



",#C.23,C#,"using System;
using System.IO;
 
Console.WriteLine(File.GetLastWriteTime(""file.txt""));
File.SetLastWriteTime(""file.txt"", DateTime.Now);",135,5
54922,http://rosettacode.org/wiki/File_size,File size,"Verify the size of a file called     input.txt     for a file in the current working directory, and another one in the file system root.



",#C.23,C#,"using System;
using System.IO;
 
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine(new FileInfo(""/input.txt"").Length);
        Console.WriteLine(new FileInfo(""input.txt"").Length);
    }
}
 ",223,12
55049,http://rosettacode.org/wiki/Feigenbaum_constant_calculation,Feigenbaum constant calculation,"Task

Calculate the Feigenbaum constant.



See

   Details in the Wikipedia article:   Feigenbaum constant.

",#C.23,C#,"using System;
 
namespace FeigenbaumConstant {
    class Program {
        static void Main(string[] args) {
            var maxIt = 13;
            var maxItJ = 10;
            var a1 = 1.0;
            var a2 = 0.0;
            var d1 = 3.2;
            Console.WriteLine("" i       d"");
            for (int i = 2; i <= maxIt; i++) {
                var a = a1 + (a1 - a2) / d1;
                for (int j = 1; j <= maxItJ; j++) {
                    var x = 0.0;
                    var y = 0.0;
                    for (int k = 1; k <= 1<<i; k++) {
                        y = 1.0 - 2.0 * y * x;
                        x = a - x * x;
                    }
                    a -= x / y;
                }
                var d = (a1 - a2) / (a - a1);
                Console.WriteLine(""{0,2:d}    {1:f8}"", i, d);
                d1 = d;
                a2 = a1;
                a1 = a;
            }
        }
    }
}",923,31
55110,http://rosettacode.org/wiki/File_input/output,File input/output,"File input/output is part of Short Circuit's Console Program Basics selection.
Task

Create a file called   ""output.txt"",   and place in it the contents of the file   ""input.txt"",   via an intermediate variable.

In other words, your program will demonstrate:

   how to read from a file into a variable
   how to write a variable's contents into a file


Oneliners that skip the intermediate variable are of secondary interest — operating systems have copy commands for that.



",#C.23,C#,"using System.IO;
 
using (var reader = new StreamReader(""input.txt""))
using (var writer = new StreamWriter(""output.txt""))
{
    var text = reader.ReadToEnd();
    writer.Write(text);
}",184,8
55112,http://rosettacode.org/wiki/Fibonacci_word,Fibonacci word,"The   Fibonacci Word   may be created in a manner analogous to the   Fibonacci Sequence   as described here:

    Define   F_Word1   as   1
    Define   F_Word2   as   0
    Form     F_Word3   as   F_Word2     concatenated with   F_Word1    i.e.:   01
    Form     F_Wordn   as   F_Wordn-1   concatenated with   F_wordn-2



Task

Perform the above steps for     n = 37.

You may display the first few but not the larger values of   n.

{Doing so will get the task's author into trouble with them what be (again!).} 

Instead, create a table for   F_Words   1   to   37   which shows:

   The number of characters in the word
   The word's Entropy


Related tasks
 
   Fibonacci word/fractal
   Entropy
   Entropy/Narcissist

",#C.23,C#,"using SYS = System;
using SCG = System.Collections.Generic;
 
//
// Basically a port of the C++ solution as posted
// 2017-11-12.
//
namespace FibonacciWord
{
  class Program
  {
    static void Main( string[] args )
    {
      PrintHeading();
      string firstString = ""1"";
      int n = 1;
      PrintLine( n, firstString );
      string secondString = ""0"";
      ++n;
      PrintLine( n, secondString );
      while ( n < 37 )
      {
        string resultString = firstString + secondString;
        firstString = secondString;
        secondString = resultString;
        ++n;
        PrintLine( n, resultString );
      }
    }
 
    private static void PrintLine( int n, string result )
    {
      SYS.Console.Write( ""{0,-5}"", n );
      SYS.Console.Write( ""{0,12}"", result.Length );
      SYS.Console.WriteLine( ""  {0,-16}"", GetEntropy( result ) );
    }
 
    private static double GetEntropy( string result )
    {
      SCG.Dictionary<char, int> frequencies = new SCG.Dictionary<char, int>();
      foreach ( char c in result )
      {
        if ( frequencies.ContainsKey( c ) )
        {
          ++frequencies[c];
        }
        else
        {
          frequencies[c] = 1;
        }
      }
 
      int length = result.Length;
      double entropy = 0;
      foreach ( var keyValue in frequencies )
      {
        double freq = (double)keyValue.Value / length;
        entropy += freq * SYS.Math.Log( freq, 2 );
      }
 
      return -entropy;
    }
 
    private static void PrintHeading()
    {
      SYS.Console.Write( ""{0,-5}"", ""N"" );
      SYS.Console.Write( ""{0,12}"", ""Length"" );
      SYS.Console.WriteLine( ""  {0,-16}"", ""Entropy"" );
    }
  }
}",1676,71
55212,http://rosettacode.org/wiki/Faulhaber%27s_formula,Faulhaber's formula,"In mathematics,   Faulhaber's formula,   named after Johann Faulhaber,   expresses the sum of the p-th powers of the first n positive integers as a (p + 1)th-degree polynomial function of n,   the coefficients involving Bernoulli numbers.



Task

Generate the first 10 closed-form expressions, starting with p = 0.



Related tasks

   Bernoulli numbers.
   evaluate binomial coefficients.


See also

   The Wikipedia entry:   Faulhaber's formula.
   The Wikipedia entry:   Bernoulli numbers.
   The Wikipedia entry:   binomial coefficients.

",#C.23,C#,"using System;
 
namespace FaulhabersFormula {
    internal class Frac {
        private long num;
        private long denom;
 
        public static readonly Frac ZERO = new Frac(0, 1);
        public static readonly Frac ONE = new Frac(1, 1);
 
        public Frac(long n, long d) {
            if (d == 0) {
                throw new ArgumentException(""d must not be zero"");
            }
            long nn = n;
            long dd = d;
            if (nn == 0) {
                dd = 1;
            }
            else if (dd < 0) {
                nn = -nn;
                dd = -dd;
            }
            long g = Math.Abs(Gcd(nn, dd));
            if (g > 1) {
                nn /= g;
                dd /= g;
            }
            num = nn;
            denom = dd;
        }
 
        private static long Gcd(long a, long b) {
            if (b == 0) {
                return a;
            }
            return Gcd(b, a % b);
        }
 
        public static Frac operator -(Frac self) {
            return new Frac(-self.num, self.denom);
        }
 
        public static Frac operator +(Frac lhs, Frac rhs) {
            return new Frac(lhs.num * rhs.denom + lhs.denom * rhs.num, rhs.denom * lhs.denom);
        }
 
        public static Frac operator -(Frac lhs, Frac rhs) {
            return lhs + -rhs;
        }
 
        public static Frac operator *(Frac lhs, Frac rhs) {
            return new Frac(lhs.num * rhs.num, lhs.denom * rhs.denom);
        }
 
        public static bool operator <(Frac lhs, Frac rhs) {
            double x = (double)lhs.num / lhs.denom;
            double y = (double)rhs.num / rhs.denom;
            return x < y;
        }
 
        public static bool operator >(Frac lhs, Frac rhs) {
            double x = (double)lhs.num / lhs.denom;
            double y = (double)rhs.num / rhs.denom;
            return x > y;
        }
 
        public static bool operator ==(Frac lhs, Frac rhs) {
            return lhs.num == rhs.num && lhs.denom == rhs.denom;
        }
 
        public static bool operator !=(Frac lhs, Frac rhs) {
            return lhs.num != rhs.num || lhs.denom != rhs.denom;
        }
 
        public override string ToString() {
            if (denom == 1) {
                return num.ToString();
            }
            return string.Format(""{0}/{1}"", num, denom);
        }
 
        public override bool Equals(object obj) {
            var frac = obj as Frac;
            return frac != null &&
                   num == frac.num &&
                   denom == frac.denom;
        }
 
        public override int GetHashCode() {
            var hashCode = 1317992671;
            hashCode = hashCode * -1521134295 + num.GetHashCode();
            hashCode = hashCode * -1521134295 + denom.GetHashCode();
            return hashCode;
        }
    }
 
    class Program {
        static Frac Bernoulli(int n) {
            if (n < 0) {
                throw new ArgumentException(""n may not be negative or zero"");
            }
            Frac[] a = new Frac[n + 1];
            for (int m = 0; m <= n; m++) {
                a[m] = new Frac(1, m + 1);
                for (int j = m; j >= 1; j--) {
                    a[j - 1] = (a[j - 1] - a[j]) * new Frac(j, 1);
                }
            }
            // returns 'first' Bernoulli number
            if (n != 1) return a[0];
            return -a[0];
        }
 
        static int Binomial(int n, int k) {
            if (n < 0 || k < 0 || n < k) {
                throw new ArgumentException();
            }
            if (n == 0 || k == 0) return 1;
            int num = 1;
            for (int i = k + 1; i <= n; i++) {
                num = num * i;
            }
            int denom = 1;
            for (int i = 2; i <= n - k; i++) {
                denom = denom * i;
            }
            return num / denom;
        }
 
        static void Faulhaber(int p) {
            Console.Write(""{0} : "", p);
            Frac q = new Frac(1, p + 1);
            int sign = -1;
            for (int j = 0; j <= p; j++) {
                sign *= -1;
                Frac coeff = q * new Frac(sign, 1) * new Frac(Binomial(p + 1, j), 1) * Bernoulli(j);
                if (Frac.ZERO == coeff) continue;
                if (j == 0) {
                    if (Frac.ONE != coeff) {
                        if (-Frac.ONE == coeff) {
                            Console.Write(""-"");
                        }
                        else {
                            Console.Write(coeff);
                        }
                    }
                }
                else {
                    if (Frac.ONE == coeff) {
                        Console.Write("" + "");
                    }
                    else if (-Frac.ONE == coeff) {
                        Console.Write("" - "");
                    }
                    else if (Frac.ZERO < coeff) {
                        Console.Write("" + {0}"", coeff);
                    }
                    else {
                        Console.Write("" - {0}"", -coeff);
                    }
                }
                int pwr = p + 1 - j;
                if (pwr > 1) {
                    Console.Write(""n^{0}"", pwr);
                }
                else {
                    Console.Write(""n"");
                }
            }
            Console.WriteLine();
        }
 
        static void Main(string[] args) {
            for (int i = 0; i < 10; i++) {
                Faulhaber(i);
            }
        }
    }
}",5528,180
55226,http://rosettacode.org/wiki/Filter,Filter,"Task

Select certain elements from an Array into a new Array in a generic way.



To demonstrate, select all even numbers from an Array.

As an option, give a second solution which filters destructively,
by modifying the original Array rather than creating a new Array.



",#C.23,C#,"ArrayList array = new ArrayList( new int[] { 1, 2, 3, 4, 5 } );
ArrayList evens = new ArrayList();
foreach( int i in array )
{
        if( (i%2) == 0 )
                evens.Add( i );
}
foreach( int i in evens )
       System.Console.WriteLine( i.ToString() );",260,9
55236,http://rosettacode.org/wiki/FASTA_format,FASTA format,"In bioinformatics, long character strings are often encoded in a format called FASTA.

A FASTA file can contain several strings, each identified by a name marked by a > (greater than) character at the beginning of the line.



Task

Write a program that reads a FASTA file such as:

>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED


Output:
Rosetta_Example_1: THERECANBENOSPACE
Rosetta_Example_2: THERECANBESEVERALLINESBUTTHEYALLMUSTBECONCATENATED

Note that a high-quality implementation will not hold the entire file in memory at once; real FASTA files can be multiple gigabytes in size.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
 
class Program
{
    public class FastaEntry
    {
        public string Name { get; set; }
        public StringBuilder Sequence { get; set; }
    }
 
    static IEnumerable<FastaEntry> ParseFasta(StreamReader fastaFile)
    {
        FastaEntry f = null;
        string line;
        while ((line = fastaFile.ReadLine()) != null)
        {
            // ignore comment lines
            if (line.StartsWith("";""))
                continue;
 
            if (line.StartsWith("">""))
            {
                if (f != null)
                    yield return f;
                f = new FastaEntry { Name = line.Substring(1), Sequence = new StringBuilder() };
            }
            else if (f != null)
                f.Sequence.Append(line);
        }
        yield return f;
    }
 
    static void Main(string[] args)
    {
        try
        {
            using (var fastaFile = new StreamReader(""fasta.txt""))
            {
                foreach (FastaEntry f in ParseFasta(fastaFile))
                    Console.WriteLine(""{0}: {1}"", f.Name, f.Sequence);
            }
        }
        catch (FileNotFoundException e)
        {
            Console.WriteLine(e);
        }
        Console.ReadLine();
    }
}",1306,52
55260,http://rosettacode.org/wiki/Faulhaber%27s_triangle,Faulhaber's triangle,"Named after Johann Faulhaber, the rows of Faulhaber's triangle are the coefficients of polynomials that represent sums of integer powers, which are extracted from Faulhaber's formula:








∑

k
=
1


n



k

p


=


1

p
+
1




∑

j
=
0


p





(



p
+
1

j


)




B

j



n

p
+
1
−
j




{\displaystyle \sum _{k=1}^{n}k^{p}={1 \over p+1}\sum _{j=0}^{p}{p+1 \choose j}B_{j}n^{p+1-j}}




where 




B

n




{\displaystyle B_{n}}

 is the nth-Bernoulli number.



The first 5 rows of Faulhaber's triangle, are:

    1
  1/2  1/2
  1/6  1/2  1/3
    0  1/4  1/2  1/4
-1/30    0  1/3  1/2  1/5



Using the third row of the triangle, we have:






∑

k
=
1


n



k

2


=


1
6


n
+


1
2



n

2


+


1
3



n

3




{\displaystyle \sum _{k=1}^{n}k^{2}={1 \over 6}n+{1 \over 2}n^{2}+{1 \over 3}n^{3}}





 Task
 show the first 10 rows of Faulhaber's triangle.
 using the 18th row of Faulhaber's triangle, compute the sum: 




∑

k
=
1


1000



k

17




{\displaystyle \sum _{k=1}^{1000}k^{17}}

 (extra credit).
 See also

 Bernoulli numbers
 Evaluate binomial coefficients
 Faulhaber's formula (Wikipedia)
 Faulhaber's triangle (PDF)

",#C.23,C#,"using System;
 
namespace FaulhabersTriangle {
    internal class Frac {
        private long num;
        private long denom;
 
        public static readonly Frac ZERO = new Frac(0, 1);
        public static readonly Frac ONE = new Frac(1, 1);
 
        public Frac(long n, long d) {
            if (d == 0) {
                throw new ArgumentException(""d must not be zero"");
            }
            long nn = n;
            long dd = d;
            if (nn == 0) {
                dd = 1;
            }
            else if (dd < 0) {
                nn = -nn;
                dd = -dd;
            }
            long g = Math.Abs(Gcd(nn, dd));
            if (g > 1) {
                nn /= g;
                dd /= g;
            }
            num = nn;
            denom = dd;
        }
 
        private static long Gcd(long a, long b) {
            if (b == 0) {
                return a;
            }
            return Gcd(b, a % b);
        }
 
        public static Frac operator -(Frac self) {
            return new Frac(-self.num, self.denom);
        }
 
        public static Frac operator +(Frac lhs, Frac rhs) {
            return new Frac(lhs.num * rhs.denom + lhs.denom * rhs.num, rhs.denom * lhs.denom);
        }
 
        public static Frac operator -(Frac lhs, Frac rhs) {
            return lhs + -rhs;
        }
 
        public static Frac operator *(Frac lhs, Frac rhs) {
            return new Frac(lhs.num * rhs.num, lhs.denom * rhs.denom);
        }
 
        public static bool operator <(Frac lhs, Frac rhs) {
            double x = (double)lhs.num / lhs.denom;
            double y = (double)rhs.num / rhs.denom;
            return x < y;
        }
 
        public static bool operator >(Frac lhs, Frac rhs) {
            double x = (double)lhs.num / lhs.denom;
            double y = (double)rhs.num / rhs.denom;
            return x > y;
        }
 
        public static bool operator ==(Frac lhs, Frac rhs) {
            return lhs.num == rhs.num && lhs.denom == rhs.denom;
        }
 
        public static bool operator !=(Frac lhs, Frac rhs) {
            return lhs.num != rhs.num || lhs.denom != rhs.denom;
        }
 
        public override string ToString() {
            if (denom == 1) {
                return num.ToString();
            }
            return string.Format(""{0}/{1}"", num, denom);
        }
 
        public override bool Equals(object obj) {
            var frac = obj as Frac;
            return frac != null &&
                   num == frac.num &&
                   denom == frac.denom;
        }
 
        public override int GetHashCode() {
            var hashCode = 1317992671;
            hashCode = hashCode * -1521134295 + num.GetHashCode();
            hashCode = hashCode * -1521134295 + denom.GetHashCode();
            return hashCode;
        }
    }
 
    class Program {
        static Frac Bernoulli(int n) {
            if (n < 0) {
                throw new ArgumentException(""n may not be negative or zero"");
            }
            Frac[] a = new Frac[n + 1];
            for (int m = 0; m <= n; m++) {
                a[m] = new Frac(1, m + 1);
                for (int j = m; j >= 1; j--) {
                    a[j - 1] = (a[j - 1] - a[j]) * new Frac(j, 1);
                }
            }
            // returns 'first' Bernoulli number
            if (n != 1) return a[0];
            return -a[0];
        }
 
        static int Binomial(int n, int k) {
            if (n < 0 || k < 0 || n < k) {
                throw new ArgumentException();
            }
            if (n == 0 || k == 0) return 1;
            int num = 1;
            for (int i = k + 1; i <= n; i++) {
                num = num * i;
            }
            int denom = 1;
            for (int i = 2; i <= n - k; i++) {
                denom = denom * i;
            }
            return num / denom;
        }
 
        static Frac[] FaulhaberTriangle(int p) {
            Frac[] coeffs = new Frac[p + 1];
            for (int i = 0; i < p + 1; i++) {
                coeffs[i] = Frac.ZERO;
            }
            Frac q = new Frac(1, p + 1);
            int sign = -1;
            for (int j = 0; j <= p; j++) {
                sign *= -1;
                coeffs[p - j] = q * new Frac(sign, 1) * new Frac(Binomial(p + 1, j), 1) * Bernoulli(j);
            }
            return coeffs;
        }
 
        static void Main(string[] args) {
            for (int i = 0; i < 10; i++) {
                Frac[] coeffs = FaulhaberTriangle(i);
                foreach (Frac coeff in coeffs) {
                    Console.Write(""{0,5}  "", coeff);
                }
                Console.WriteLine();
            }
        }
    }
}",4702,155
55410,http://rosettacode.org/wiki/Farey_sequence,Farey sequence,"The   Farey sequence    Fn   of order   n   is the sequence of completely reduced fractions between   0   and   1   which, when in lowest terms, have denominators less than or equal to   n,   arranged in order of increasing size.

The   Farey sequence   is sometimes incorrectly called a   Farey series.



Each Farey sequence:

   starts with the value   0   (zero),   denoted by the fraction     





0
1




{\displaystyle {\frac {0}{1}}}


   ends with the value   1   (unity),   denoted by the fraction   





1
1




{\displaystyle {\frac {1}{1}}}

.


The Farey sequences of orders   1   to   5   are:

 







F




1


=


0
1


,


1
1




{\displaystyle {\bf {\it {F}}}_{1}={\frac {0}{1}},{\frac {1}{1}}}



 







F




2


=


0
1


,


1
2


,


1
1




{\displaystyle {\bf {\it {F}}}_{2}={\frac {0}{1}},{\frac {1}{2}},{\frac {1}{1}}}



 







F




3


=


0
1


,


1
3


,


1
2


,


2
3


,


1
1




{\displaystyle {\bf {\it {F}}}_{3}={\frac {0}{1}},{\frac {1}{3}},{\frac {1}{2}},{\frac {2}{3}},{\frac {1}{1}}}



 







F




4


=


0
1


,


1
4


,


1
3


,


1
2


,


2
3


,


3
4


,


1
1




{\displaystyle {\bf {\it {F}}}_{4}={\frac {0}{1}},{\frac {1}{4}},{\frac {1}{3}},{\frac {1}{2}},{\frac {2}{3}},{\frac {3}{4}},{\frac {1}{1}}}



 







F




5


=


0
1


,


1
5


,


1
4


,


1
3


,


2
5


,


1
2


,


3
5


,


2
3


,


3
4


,


4
5


,


1
1




{\displaystyle {\bf {\it {F}}}_{5}={\frac {0}{1}},{\frac {1}{5}},{\frac {1}{4}},{\frac {1}{3}},{\frac {2}{5}},{\frac {1}{2}},{\frac {3}{5}},{\frac {2}{3}},{\frac {3}{4}},{\frac {4}{5}},{\frac {1}{1}}}


Task
   Compute and show the Farey sequence for orders   1   through   11   (inclusive).
   Compute and display the   number   of fractions in the Farey sequence for order   100   through   1,000   (inclusive)   by hundreds.
   Show the fractions as    n/d    (using the solidus [or slash] to separate the numerator from the denominator). 


The length   (the number of fractions)   of a Farey sequence asymptotically approaches:

  3 × n2   ÷   



π


{\displaystyle \pi }

2 
See also

   OEIS sequence   A006842 numerators of Farey series of order 1, 2, ··· 
   OEIS sequence   A006843 denominators of Farey series of order 1, 2, ··· 
   OEIS sequence   A005728 number of fractions in Farey series of order n 
   MathWorld entry   Farey sequence
   Wikipedia   entry   Farey sequence

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
public static class FareySequence
{
    public static void Main() {
        for (int i = 1; i <= 11; i++) {
            Console.WriteLine($""F{i}: "" + string.Join("", "", Generate(i).Select(f => $""{f.num}/{f.den}"")));
        }
        for (int i = 100; i <= 1000; i+=100) {
            Console.WriteLine($""F{i} has {Generate(i).Count()} terms."");
        }
    }
 
    public static IEnumerable<(int num, int den)> Generate(int i) {
        var comparer = Comparer<(int n, int d)>.Create((a, b) => (a.n * b.d).CompareTo(a.d * b.n));
        var seq = new SortedSet<(int n, int d)>(comparer);
        for (int d = 1; d <= i; d++) {
            for (int n = 0; n <= d; n++) {
                seq.Add((n, d));
            }
        }
        return seq;
    }
}",825,26
55535,http://rosettacode.org/wiki/Fast_Fourier_transform,Fast Fourier transform,"Task

Calculate the   FFT   (Fast Fourier Transform)   of an input sequence.

The most general case allows for complex numbers at the input
and results in a sequence of equal length, again of complex numbers.
If you need to restrict yourself to real numbers, the output should
be the magnitude   (i.e.:   sqrt(re2 + im2))   of the complex result.

The classic version is the recursive Cooley–Tukey FFT. Wikipedia has pseudo-code for that.
Further optimizations are possible but not required.



",#C.23,C#,"using System;
using System.Numerics;
using System.Linq;
using System.Diagnostics;
 
// Fast Fourier Transform in C#
public class Program {
 
    /* Performs a Bit Reversal Algorithm on a postive integer 
     * for given number of bits
     * e.g. 011 with 3 bits is reversed to 110 */
    public static int BitReverse(int n, int bits) {
       int reversedN = n;
       int count = bits - 1;
 
       n >>= 1;
       while (n > 0) {
            reversedN = (reversedN << 1) | (n & 1);
            count--;
            n >>= 1;
        }
 
        return ((reversedN << count) & ((1 << bits) - 1));
    }
 
    /* Uses Cooley-Tukey iterative in-place algorithm with radix-2 DIT case
     * assumes no of points provided are a power of 2 */
    public static void FFT(Complex[] buffer) {
#if false
        int bits = (int)Math.Log(buffer.Length, 2);
        for (int j = 1; j < buffer.Length / 2; j++) {
 
            int swapPos = BitReverse(j, bits);
            var temp = buffer[j];
            buffer[j] = buffer[swapPos];
            buffer[swapPos] = temp;
        }
// Said Zandian
// The above section of the code is incorrect and does not work correctly and has two bugs.
// BUG 1
// The bug is that when you reach and index that was swapped previously it does swap it again
// Ex. binary value n = 0010 and Bits = 4 as input to BitReverse routine and  returns 4. The code section above //     swaps it. Cells 2 and 4 are swapped. just fine.
//     now binary value n = 0010 and Bits = 4 as input to BitReverse routine and returns 2. The code Section
//     swap it. Cells 4 and 2 are swapped.     WROOOOONG
// 
// Bug 2
// The code works on the half section of the cells. In the case of Bits = 4 it means that we are having 16 cells
// The code works on half the cells        for (int j = 1; j < buffer.Length / 2; j++) buffer.Length returns 16
// and divide by 2 makes 8, so j goes from 1 to 7. This covers almost everything but what happened to 1011 value
// which must be swap with 1101. and this is the second bug.
// 
// use the following corrected section of the code. I have seen this bug in other languages that uses bit
// reversal routine. 
 
#else
            for (int j = 1; j < buffer.Length; j++)
            {
                int swapPos = BitReverse(j, bits);
                if (swapPos <= j)
                {
                    continue;
                }
                var temp = buffer[j];
                buffer[j] = buffer[swapPos];
                buffer[swapPos] = temp;
            }
 
// First the full length is used and 1011 value is swapped with 1101. Second if new swapPos is less than j
// then it means that swap was happen when j was the swapPos.
 
#endif
 
        for (int N = 2; N <= buffer.Length; N <<= 1) {
            for (int i = 0; i < buffer.Length; i += N) {
                for (int k = 0; k < N / 2; k++) {
 
                    int evenIndex = i + k;
                    int oddIndex = i + k + (N / 2);
                    var even = buffer[evenIndex];
                    var odd = buffer[oddIndex];
 
                    double term = -2 * Math.PI * k / (double)N;
                    Complex exp = new Complex(Math.Cos(term), Math.Sin(term)) * odd;
 
                    buffer[evenIndex] = even + exp;
                    buffer[oddIndex] = even - exp;
 
                }
            }
        }
    }
 
    public static void Main(string[] args) {
        Complex[] input = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};       
 
        FFT(input);       
 
        Console.WriteLine(""Results:"");
        foreach (Complex c in input) {
            Console.WriteLine(c);   
        }   
    }
}",3656,103
55544,http://rosettacode.org/wiki/Fibonacci_n-step_number_sequences,Fibonacci n-step number sequences,"These number series are an expansion of the ordinary Fibonacci sequence where:

 For 



n
=
2


{\displaystyle n=2}

 we have the Fibonacci sequence; with initial values 



[
1
,
1
]


{\displaystyle [1,1]}

 and 




F

k


2


=

F

k
−
1


2


+

F

k
−
2


2




{\displaystyle F_{k}^{2}=F_{k-1}^{2}+F_{k-2}^{2}}


 For 



n
=
3


{\displaystyle n=3}

 we have the tribonacci sequence; with initial values 



[
1
,
1
,
2
]


{\displaystyle [1,1,2]}

 and 




F

k


3


=

F

k
−
1


3


+

F

k
−
2


3


+

F

k
−
3


3




{\displaystyle F_{k}^{3}=F_{k-1}^{3}+F_{k-2}^{3}+F_{k-3}^{3}}


 For 



n
=
4


{\displaystyle n=4}

 we have the tetranacci sequence; with initial values 



[
1
,
1
,
2
,
4
]


{\displaystyle [1,1,2,4]}

 and 




F

k


4


=

F

k
−
1


4


+

F

k
−
2


4


+

F

k
−
3


4


+

F

k
−
4


4




{\displaystyle F_{k}^{4}=F_{k-1}^{4}+F_{k-2}^{4}+F_{k-3}^{4}+F_{k-4}^{4}}


...
 For general 



n
>
2


{\displaystyle n>2}

 we have the Fibonacci 



n


{\displaystyle n}

-step sequence - 




F

k


n




{\displaystyle F_{k}^{n}}

; with initial values of the first 



n


{\displaystyle n}

 values of the 



(
n
−
1
)


{\displaystyle (n-1)}

'th Fibonacci 



n


{\displaystyle n}

-step sequence 




F

k


n
−
1




{\displaystyle F_{k}^{n-1}}

; and 



k


{\displaystyle k}

'th value of this 



n


{\displaystyle n}

'th sequence being 




F

k


n


=

∑

i
=
1


(
n
)




F

k
−
i


(
n
)





{\displaystyle F_{k}^{n}=\sum _{i=1}^{(n)}{F_{k-i}^{(n)}}}


For small values of 



n


{\displaystyle n}

, Greek numeric prefixes are sometimes used to individually name each series.


 Fibonacci 



n


{\displaystyle n}

-step sequences


 



n


{\displaystyle n}

 
 Series name 
 Values


 2 
 fibonacci 
 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...


 3 
 tribonacci 
 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...


 4 
 tetranacci 
 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...


 5 
 pentanacci 
 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...


 6 
 hexanacci 
 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...


 7 
 heptanacci 
 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...


 8 
 octonacci 
 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...


 9 
 nonanacci 
 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...


 10 
 decanacci 
 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...

Allied sequences can be generated where the initial values are changed:

 The Lucas series sums the two preceding values like the fibonacci series for 



n
=
2


{\displaystyle n=2}

 but uses 



[
2
,
1
]


{\displaystyle [2,1]}

 as its initial values.


Task

 Write a function to generate Fibonacci 



n


{\displaystyle n}

-step number sequences given its initial values and assuming the number of initial values determines how many previous values are summed to make the next number of the series.
 Use this to print and show here at least the first ten members of the Fibo/tribo/tetra-nacci and Lucas sequences.


Related tasks

   Fibonacci sequence
   Wolfram Mathworld
   Hofstadter Q sequence‎
   Leonardo numbers


Also see

   Lucas Numbers - Numberphile (Video)
   Tribonacci Numbers (and the Rauzy Fractal) - Numberphile (Video)
   Wikipedia, Lucas number
   MathWorld, Fibonacci Number
   Some identities for r-Fibonacci numbers
   OEIS Fibonacci numbers
   OEIS Lucas numbers

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace Fibonacci
{
    class Program
    {
        static void Main(string[] args)
        {
            PrintNumberSequence(""Fibonacci"", GetNnacciNumbers(2, 10));
            PrintNumberSequence(""Lucas"", GetLucasNumbers(10));
            PrintNumberSequence(""Tribonacci"", GetNnacciNumbers(3, 10));
            PrintNumberSequence(""Tetranacci"", GetNnacciNumbers(4, 10));
            Console.ReadKey();
        }
 
        private static IList<ulong> GetLucasNumbers(int length)
        {
            IList<ulong> seedSequence = new List<ulong>() { 2, 1 };
            return GetFibLikeSequence(seedSequence, length);
        }
 
        private static IList<ulong> GetNnacciNumbers(int seedLength, int length)
        {
            return GetFibLikeSequence(GetNacciSeed(seedLength), length);
        }
 
        private static IList<ulong> GetNacciSeed(int seedLength)
        {
            IList<ulong> seedSquence = new List<ulong>() { 1 };
 
            for (uint i = 0; i < seedLength - 1; i++)
            {
                seedSquence.Add((ulong)Math.Pow(2, i));
            }
 
            return seedSquence;
        }
 
        private static IList<ulong> GetFibLikeSequence(IList<ulong> seedSequence, int length)
        {
            IList<ulong> sequence = new List<ulong>();
 
            int count = seedSequence.Count();
 
            if (length <= count)
            {
                sequence = seedSequence.Take((int)length).ToList();
            }
            else
            {
                sequence = seedSequence;
 
                for (int i = count; i < length; i++)
                {
                    ulong num = 0;
 
                    for (int j = 0; j < count; j++)
                    {
                        num += sequence[sequence.Count - 1 - j];
                    }
 
                    sequence.Add(num);
                }
            }
 
            return sequence;
        }
 
        private static void PrintNumberSequence(string Title, IList<ulong> numbersequence)
        {
            StringBuilder output = new StringBuilder(Title).Append(""   "");
 
            foreach (long item in numbersequence)
            {
                output.AppendFormat(""{0}, "", item);
            }
 
            Console.WriteLine(output.ToString());
        }
    }
}",2395,84
55594,http://rosettacode.org/wiki/Factors_of_a_Mersenne_number,Factors of a Mersenne number,"A Mersenne number is a number in the form of 2P-1.

If P is prime, the Mersenne number may be a Mersenne prime
(if P is not prime, the Mersenne number is also not prime).

In the search for Mersenne prime numbers it is advantageous to eliminate exponents by finding a small factor before starting a, potentially lengthy, Lucas-Lehmer test.

There are very efficient algorithms for determining if a number divides 2P-1 (or equivalently, if 2P mod (the number) = 1).
Some languages already have built-in implementations of this exponent-and-mod operation (called modPow or similar).

The following is how to implement this modPow yourself:

For example, let's compute 223 mod 47.
Convert the exponent 23 to binary, you get 10111. Starting with square = 1, repeatedly square it.
Remove the top bit of the exponent, and if it's 1 multiply square by the base of the exponentiation (2), then compute square modulo 47.
Use the result of the modulo from the last step as the initial value of square in the next step:

                  remove       optional   
      square      top bit   multiply by 2   mod 47
   ────────────   ───────   ─────────────   ────── 
   1*1 = 1        1  0111   1*2 = 2            2
   2*2 = 4        0   111      no              4
   4*4 = 16       1    11   16*2 = 32         32
   32*32 = 1024   1     1   1024*2 = 2048     27
   27*27 = 729    1         729*2 = 1458       1

Since 223 mod 47 = 1, 47 is a factor of 2P-1.
(To see this, subtract 1 from both sides: 223-1 = 0 mod 47.)
Since we've shown that 47 is a factor, 223-1 is not prime.
Further properties of Mersenne numbers allow us to refine the process even more.
Any factor q of 2P-1 must be of the form 2kP+1, k being a positive integer or zero. Furthermore, q must be 1 or 7 mod 8.
Finally any potential factor q must be prime.
As in other trial division algorithms, the algorithm stops when 2kP+1 > sqrt(N).

These primality tests only work on Mersenne numbers where P is prime. For example, M4=15 yields no factors using these techniques, but factors into 3 and 5, neither of which fit 2kP+1.



Task

Using the above method find a factor of 2929-1 (aka M929)



Related tasks

   count in factors
   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division


See also

   Computers in 1948: 2127 - 1 
       (Note:   This video is no longer available because the YouTube account associated with this video has been terminated.)

",#C.23,C#,"using System;
 
namespace prog
{
	class MainClass
	{
		public static void Main (string[] args)
		{
			int q = 929;
			if ( !isPrime(q) ) return;
			int r = q;
			while( r > 0 ) 
				r <<= 1;
			int d = 2 * q + 1;
			do
			{
				int i = 1;
				for( int p=r; p!=0; p<<=1 )
				{
					i = (i*i) % d;
					if (p < 0) i *= 2;
					if (i > d) i -= d;
				}
				if (i != 1) d += 2 * q; else break;				
			}
			while(true);
 
			Console.WriteLine(""2^""+q+""-1 = 0 (mod ""+d+"")""); 
		}
 
		static bool isPrime(int n)
		{
			if ( n % 2 == 0 ) return n == 2;
			if ( n % 3 == 0 ) return n == 3;
			int d = 5;
			while( d*d <= n )
			{
				if ( n % d == 0 ) return false;
				d += 2;
				if ( n % d == 0 ) return false;
				d += 4;
			}
			return true;
		}
	}
}",746,46
56061,http://rosettacode.org/wiki/Factors_of_an_integer,Factors of an integer,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Compute the   factors   of a positive integer.

These factors are the positive integers by which the number being factored can be divided to yield a positive integer result.

(Though the concepts function correctly for zero and negative integers, the set of factors of zero has countably infinite members, and the factors of negative integers can be obtained from the factors of related positive numbers without difficulty;   this task does not require handling of either of these cases).

Note that every prime number has two factors:   1   and itself.



Related tasks

   count in factors
   prime decomposition
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division
   sequence: smallest number greater than previous term with exactly n divisors

",#C.23,C#,"static void Main (string[] args) {
    do {
        Console.WriteLine (""Number:"");
        Int64 p = 0;
        do {
            try {
                p = Convert.ToInt64 (Console.ReadLine ());
                break;
            } catch (Exception) { }
 
        } while (true);
 
        Console.WriteLine (""For 1 through "" + ((int) Math.Sqrt (p)).ToString () + """");
        for (int x = 1; x <= (int) Math.Sqrt (p); x++) {
            if (p % x == 0)
                Console.WriteLine (""Found: "" + x.ToString () + "". "" + p.ToString () + "" / "" + x.ToString () + "" = "" + (p / x).ToString ());
        }
 
        Console.WriteLine (""Done."");
    } while (true);
}",663,21
56285,http://rosettacode.org/wiki/Fibonacci_sequence,Fibonacci sequence,"The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:

      F0 = 0 
      F1 = 1 
      Fn = Fn-1 + Fn-2, if n>1 



Task

Write a function to generate the    nth    Fibonacci number.

Solutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).

The sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:

      Fn = Fn+2 - Fn+1, if n<0   

support for negative      n      in the solution is optional.



Related tasks

   Fibonacci n-step number sequences‎
   Leonardo numbers


References

   Wikipedia, Fibonacci number
   Wikipedia, Lucas number
   MathWorld, Fibonacci Number
   Some identities for r-Fibonacci numbers
   OEIS Fibonacci numbers
   OEIS Lucas numbers

",#C.23,C#," 
public static ulong Fib(uint n) {
    return (n < 2)? n : Fib(n - 1) + Fib(n - 2);
}
 ",88,5
56643,http://rosettacode.org/wiki/Extend_your_language,Extend your language,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops

Some programming languages allow you to extend the language. While this can be done to a certain degree in most languages (e.g. by using macros), other languages go much further. Most notably in the Forth and Lisp families, programming per se is done by extending the language without any formal distinction between built-in and user-defined elements.

If your language supports it, show how to introduce a new flow control mechanism. A practical and useful example is a four-way branch:

Occasionally, code must be written that depends on two conditions, resulting in up to four branches (depending on whether both, only the first, only the second, or none of the conditions are ""true""). In a C-like language this could look like the following:

  if (condition1isTrue) {
     if (condition2isTrue)
        bothConditionsAreTrue();
     else
        firstConditionIsTrue();
  }
  else if (condition2isTrue)
     secondConditionIsTrue();
  else
     noConditionIsTrue();

Besides being rather cluttered, the statement(s) for 'condition2isTrue' must be written down twice. If 'condition2isTrue' were a lengthy and involved expression, it would be quite unreadable, and the code generated by the compiler might be unnecessarily large.

This can be improved by introducing a new keyword if2. It is similar to if, but takes two conditional statements instead of one, and up to three 'else' statements. One proposal (in pseudo-C syntax) might be:

  if2 (condition1isTrue) (condition2isTrue)
     bothConditionsAreTrue();
  else1
     firstConditionIsTrue();
  else2
     secondConditionIsTrue();
  else
     noConditionIsTrue();

Pick the syntax which suits your language. The keywords 'else1' and 'else2' are just examples. The new conditional expression should look, nest and behave analogously to the language's built-in 'if' statement.
",#C.23,C#," 
 
using System;
using System.Reflection;
 
namespace Extend_your_language
{
 
 
	class Program
	{
 
		public static void Main(string[] args)
		{
			Console.WriteLine();
			Console.WriteLine(""Hello World!"");
			Console.WriteLine();
 
			int x = 0;
			int y = 0;
 
			for(x=0;x<2;x++)
			{
				for(y=0;y<2;y++)
				{
 
					CONDITIONS( (x==0) , (y==0) ).
						IF2  (""METHOD1"").
						ELSE1(""METHOD2"").
						ELSE2(""METHOD3"").
						ELSE (""METHOD4"");
 
				}
			}
 
			Console.WriteLine();
			Console.Write(""Press any key to continue . . . "");
			Console.ReadKey(true);
		}
 
 
 
 
		public static void METHOD1()
		{
			Console.WriteLine(""METHOD 1 executed - both are true"");
		}
 
		public static void METHOD2()
		{
			Console.WriteLine(""METHOD 2 executed - first is true"");
		}
 
		public static void METHOD3()
		{
			Console.WriteLine(""METHOD 3 executed - second is true"");
		}
 
		public static void METHOD4()
		{
			Console.WriteLine(""METHOD 4 executed - both are false"");
		}
 
 
		static int CONDITIONS(bool condition1, bool condition2)
		{
			int c = 0;
			if(condition1 && condition2)
				c = 0;
			else if(condition1)
				c = 1;
			else if(condition2)
				c = 2;
			else
				c = 3;
 
			return c;
		}
	}
 
 
	public static class ExtensionMethods
	{
 
		public static int IF2(this int value, string method)
		{
			if(value == 0)
			{
				MethodInfo m = typeof(Program).GetMethod(method);
				m.Invoke(null,null);
			}
 
			return value;
		}
 
		public static int ELSE1(this int value, string method)
		{
			if(value == 1)
			{
				MethodInfo m = typeof(Program).GetMethod(method);
				m.Invoke(null,null);
			}
 
			return value;
		}
 
		public static int ELSE2(this int value, string method)
		{
			if(value == 2)
			{
				MethodInfo m = typeof(Program).GetMethod(method);
				m.Invoke(null,null);
			}
 
			return value;
		}
 
		public static void ELSE(this int value, string method)
		{
			if(value == 3)
			{
				MethodInfo m = typeof(Program).GetMethod(method);
				m.Invoke(null,null);
			}
		}
 
	}
}
 
 ",2020,130
56691,http://rosettacode.org/wiki/Exponentiation_order,Exponentiation order,"This task will demonstrate the order of exponentiation   (xy)    when there are multiple exponents.

(Many programming languages,   especially those with extended─precision integer arithmetic,   usually support one of  **, ^, ↑  or some such for exponentiation.)



Task requirements
Show the result of a language's evaluation of multiple exponentiation (either as an integer or floating point).

If your language's exponentiation operator is not one of the usual ones, please comment on how to recognize it.



Using whatever operator or syntax your language supports (if any), show the results in three lines (with identification):


   5**3**2 
   (5**3)**2
   5**(3**2)




If there are other methods (or formats) of multiple exponentiations, show them as well.



See also

 MathWorld entry:   exponentiation


Related tasks

   exponentiation operator
   arbitrary-precision integers (included)
   Exponentiation with infix operators in (or operating on) the base

",#C.23,C#,"using System;
 
namespace exponents
{
    class Program
    {
        static void Main(string[] args)
        {
            /* 
             * Like C, C# does not have an exponent operator.
             * Exponentiation is done via Math.Pow, which
             * only takes two arguments 
             */
            Console.WriteLine(Math.Pow(Math.Pow(5, 3), 2));
            Console.WriteLine(Math.Pow(5, Math.Pow(3, 2)));
            Console.Read();
        }
 
    }
}
 ",474,21
56832,http://rosettacode.org/wiki/Execute_HQ9%2B,Execute HQ9+,"Task

Implement a    HQ9+    interpreter or compiler.



",#C.23,C#," 
using System;
using System.Collections.Generic;
using System.Linq;
 
class Program
{
    static void RunCode(string code)
    {
        int accumulator = 0;
        var opcodes = new Dictionary<char, Action>
        {
            {'H', () => Console.WriteLine(""Hello, World!""))},
            {'Q', () => Console.WriteLine(code) },
            {'9', () => Console.WriteLine(Enumerable.Range(1,100).Reverse().Select(n => string.Format(""{0} bottles of beer on the wall\n{0} bottles of beer\nTake one down, pass it around\n{1} bottles of beer on the wall\n"", n, n-1)).Aggregate((a,b) => a + ""\n"" + b))},
            {'+', () => accumulator++ }
        }
 
        foreach(var c in code)
            opcodes[c]();
    }
}
 ",720,23
56873,http://rosettacode.org/wiki/Exponentiation_operator,Exponentiation operator,"Most programming languages have a built-in implementation of exponentiation.



Task

Re-implement integer exponentiation for both   intint   and   floatint   as both a procedure,   and an operator (if your language supports operator definition).

If the language supports operator (or procedure) overloading, then an overloaded form should be provided for both   intint   and   floatint   variants.



Related tasks

   Exponentiation order
   arbitrary-precision integers (included)
   Exponentiation with infix operators in (or operating on) the base

",#C.23,C#," 
static void Main(string[] args)
{
	Console.WriteLine(""5^5 = "" + Expon(5, 5));
	Console.WriteLine(""5.5^5 = "" + Expon(5.5, 5));
	Console.ReadLine();
}
 
static double Expon(int Val, int Pow) 
{
	return Math.Pow(Val, Pow);
}
static double Expon(double Val, int Pow)
{
	return Math.Pow(Val, Pow);
}
 ",298,17
56986,http://rosettacode.org/wiki/Exceptions/Catch_an_exception_thrown_in_a_nested_call,Exceptions/Catch an exception thrown in a nested call,"Show how to create a user-defined exception   and   show how to catch an exception raised from several nested calls away.

   Create two user-defined exceptions,   U0   and   U1. 
   Have function   foo   call function   bar   twice.
   Have function   bar   call function   baz. 
   Arrange for function   baz   to raise, or throw exception   U0   on its first call, then exception   U1   on its second.
   Function   foo   should catch only exception   U0,   not   U1.


Show/describe what happens when the program is run.



",#C.23,C#,"using System; //Used for Exception and Console classes
class Exceptions
{
  class U0 : Exception { }
  class U1 : Exception { }
  static int i;
  static void foo()
  {
    for (i = 0; i < 2; i++)
      try
      {
        bar();
      }
      catch (U0) {
        Console.WriteLine(""U0 Caught"");
      }
  }
  static void bar()
  {
    baz();
  }
  static void baz(){
    if (i == 0)
      throw new U0();
    throw new U1();
  }
 
  public static void Main()
  {
    foo();
  }
}",480,32
57111,http://rosettacode.org/wiki/Exceptions,Exceptions,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops

This task is to give an example of an exception handling routine
and to ""throw"" a new exception.



Related task

   Exceptions Through Nested Calls

",#C.23,C#,"public class MyException : Exception
{
  // data with info about exception
};",77,4
57180,http://rosettacode.org/wiki/Execute_a_system_command,Execute a system command,"Task

Run either the   ls   system command   (dir   on Windows),   or the   pause   system command.




Related task
  Get system command output

",#C.23,C#,"using System.Diagnostics;
 
namespace Execute
{
    class Program
    {
        static void Main(string[] args)
        {
            Process.Start(""cmd.exe"", ""/c dir"");
        }
    }
}",187,12
57327,http://rosettacode.org/wiki/Evolutionary_algorithm,Evolutionary algorithm,"Starting with:

 The target string: ""METHINKS IT IS LIKE A WEASEL"".
 An array of random characters chosen from the set of upper-case letters together with the space, and of the same length as the target string. (Call it the parent).
 A fitness function that computes the ‘closeness’ of its argument to the target string.
 A mutate function that given a string and a mutation rate returns a copy of the string, with some characters probably mutated.
 While the parent is not yet the target:
 copy the parent C times, each time allowing some random probability that another character might be substituted using mutate.
 Assess the fitness of the parent and all the copies to the target and make the most fit string the new parent, discarding the others.
 repeat until the parent converges, (hopefully), to the target.


See also

   Wikipedia entry:   Weasel algorithm.
   Wikipedia entry:   Evolutionary algorithm.

Note: to aid comparison, try and ensure the variables and functions mentioned in the task description appear in solutions



A cursory examination of a few of the solutions reveals that the instructions have not been followed rigorously in some solutions. Specifically,

 While the parent is not yet the target:
 copy the parent C times, each time allowing some random probability that another character might be substituted using mutate.
Note that some of the the solutions given retain characters in the mutated string that are correct in the target string. However, the instruction above does not state to retain any of the characters while performing the mutation. Although some may believe to do so is implied from the use of ""converges""

(:* repeat until the parent converges, (hopefully), to the target.

Strictly speaking, the new parent should be selected from the new pool of mutations, and then the new parent used to generate the next set of mutations with parent characters getting retained only by not being mutated. It then becomes possible that the new set of mutations has no member that is fitter than the parent!

As illustration of this error, the code for 8th has the following remark.

Create a new string based on the TOS, changing randomly any characters which
don't already match the target:

NOTE: this has been changed, the 8th version is completely random now

Clearly, this algo will be applying the mutation function only to the parent characters that don't match to the target characters!

To ensure that the new parent is never less fit than the prior parent, both the parent and all of the latest mutations are subjected to the fitness test to select the next parent.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
static class Program {
    static Random Rng = new Random((int)DateTime.Now.Ticks);
 
    static char NextCharacter(this Random self) {
        const string AllowedChars = "" ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
        return AllowedChars[self.Next() % AllowedChars.Length];
    }
 
    static string NextString(this Random self, int length) {
        return String.Join("""", Enumerable.Repeat(' ', length)
            .Select(c => Rng.NextCharacter()));
    }
 
    static int Fitness(string target, string current) {
        return target.Zip(current, (a, b) => a == b ? 1 : 0).Sum();
    }
 
    static string Mutate(string current, double rate) {
        return String.Join("""", from c in current
               select Rng.NextDouble() <= rate ? Rng.NextCharacter() : c);
    }
 
    static void Main(string[] args) {
        const string target = ""METHINKS IT IS LIKE A WEASEL"";
        const int C = 100;
        const double P = 0.05;
 
        // Start with a random string the same length as the target.
        string parent = Rng.NextString(target.Length);
 
        Console.WriteLine(""START:       {0,20} fitness: {1}"", 
            parent, Fitness(target, parent));
        int i = 0;
 
        while (parent != target) {
            // Create C mutated strings + the current parent.
            var candidates = Enumerable.Range(0, C + 1)
                .Select(n => n > 0 ? Mutate(parent, P) : parent);
 
            // select the fittest
            parent = candidates.OrderByDescending(c => Fitness(target, c)).First();
 
            ++i;
            Console.WriteLine(""     #{0,6} {1,20} fitness: {2}"", 
                i, parent, Fitness(target, parent));
        }
 
        Console.WriteLine(""END: #{0,6} {1,20}"", i, parent);
    }
}",1815,54
57466,http://rosettacode.org/wiki/Execute_Brain****,Execute Brain****,"Execute Brain**** is an implementation of Brainf***.
Other implementations of Brainf***.
RCBF is a set of Brainf*** compilers and interpreters written for Rosetta Code in a variety of languages.

Below are links to each of the versions of RCBF.

An implementation need only properly implement the following instructions:



Command

Description


 > 
 Move the pointer to the right


 < 
 Move the pointer to the left


 + 
 Increment the memory cell under the pointer


 - 
 Decrement the memory cell under the pointer


 . 
 Output the character signified by the cell at the pointer


 , 
 Input a character and store it in the cell at the pointer


 [ 
 Jump past the matching ] if the cell under the pointer is 0


 ] 
 Jump back to the matching [ if the cell under the pointer is nonzero

Any cell size is allowed,   EOF   (End-O-File)   support is optional, as is whether you have bounded or unbounded memory.



",#C.23,C#,"(ns brainfuck)
 
(def ^:dynamic *input*)
 
(def ^:dynamic *output*)
 
(defrecord Data [ptr cells])
 
(defn inc-ptr [next-cmd]
  (fn [data]
    (next-cmd (update-in data [:ptr] inc))))
 
(defn dec-ptr [next-cmd]
  (fn [data]
    (next-cmd (update-in data [:ptr] dec))))
 
(defn inc-cell [next-cmd]
  (fn [data]
    (next-cmd (update-in data [:cells (:ptr data)] (fnil inc 0)))))
 
(defn dec-cell [next-cmd]
  (fn [data]
    (next-cmd (update-in data [:cells (:ptr data)] (fnil dec 0)))))
 
(defn output-cell [next-cmd]
  (fn [data]
    (set! *output* (conj *output* (get (:cells data) (:ptr data) 0)))
    (next-cmd data)))
 
(defn input-cell [next-cmd]
  (fn [data]
    (let [[input & rest-input] *input*]
      (set! *input* rest-input)
      (next-cmd (update-in data [:cells (:ptr data)] input)))))
 
(defn if-loop [next-cmd loop-cmd]
  (fn [data]
    (next-cmd (loop [d data]
                (if (zero? (get (:cells d) (:ptr d) 0))
                  d
                  (recur (loop-cmd d)))))))
 
(defn terminate [data] data)
 
(defn split-cmds [cmds]
  (letfn [(split [[cmd & rest-cmds] loop-cmds]
                 (when (nil? cmd) (throw (Exception. ""invalid commands: missing ]"")))
                 (case cmd
                       \[ (let [[c l] (split-cmds rest-cmds)]
                            (recur c (str loop-cmds ""["" l ""]"")))
                       \] [(apply str rest-cmds) loop-cmds]
                       (recur rest-cmds (str loop-cmds cmd))))]
    (split cmds """")))
 
(defn compile-cmds [[cmd & rest-cmds]]
  (if (nil? cmd)
    terminate
    (case cmd
          \> (inc-ptr (compile-cmds rest-cmds))
          \< (dec-ptr (compile-cmds rest-cmds))
          \+ (inc-cell (compile-cmds rest-cmds))
          \- (dec-cell (compile-cmds rest-cmds))
          \. (output-cell (compile-cmds rest-cmds))
          \, (input-cell (compile-cmds rest-cmds))
          \[ (let [[cmds loop-cmds] (split-cmds rest-cmds)]
               (if-loop (compile-cmds cmds) (compile-cmds loop-cmds)))
          \] (throw (Exception. ""invalid commands: missing [""))
          (compile-cmds rest-cmds))))
 
(defn compile-and-run [cmds input]
  (binding [*input* input *output* []]
    (let [compiled-cmds (compile-cmds cmds)]
     (println (compiled-cmds (Data. 0 {}))))
    (println *output*)
    (println (apply str (map char *output*)))))
 ",2344,76
57752,http://rosettacode.org/wiki/Factorial,Factorial,"Definitions

   The factorial of   0   (zero)   is defined as being   1   (unity).
   The   Factorial Function   of a positive integer,    n,    is defined as the product of the sequence:
                 n,   n-1,   n-2,   ...   1 



Task

Write a function to return the factorial of a number.

Solutions can be iterative or recursive.

Support for trapping negative    n    errors is optional.



Related task

   Primorial numbers

",#C.23,C#,"using System;
 
class Program
{
    static int Factorial(int number)
    {
        if(number < 0) 
            throw new ArgumentOutOfRangeException(nameof(number), number, ""Must be zero or a positive number."");
 
        var accumulator = 1;
        for (var factor = 1; factor <= number; factor++)
        {
            accumulator *= factor;
        }
        return accumulator;
    }
 
    static void Main()
    {
        Console.WriteLine(Factorial(10));
    }
}",469,22
58193,http://rosettacode.org/wiki/Euler%27s_identity,Euler's identity,"

 This page uses content from Wikipedia. The original article was at Euler's_identity. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In mathematics, Euler's identity is the equality:

               ei
  
    
      
        π
      
    
    {\displaystyle \pi }
  
 + 1 = 0

where

   e is Euler's number, the base of natural logarithms,
   i is the imaginary unit, which satisfies i2 = −1, and
   
  
    
      
        π
      
    
    {\displaystyle \pi }
  
 is pi, the ratio of the circumference of a circle to its diameter.

Euler's identity is often cited as an example of deep mathematical beauty. Three of the basic arithmetic operations occur exactly once each: addition, multiplication, and exponentiation. The identity also links five fundamental mathematical constants:

   The number 0.
   The number 1.
   The number 
  
    
      
        π
      
    
    {\displaystyle \pi }
  
 (
  
    
      
        π
      
    
    {\displaystyle \pi }
  
 = 3.14159+),
   The number e (e = 2.71828+), which occurs widely in mathematical analysis.
   The number i, the imaginary unit of the complex numbers.

Task
Show in your language that Euler's identity is true. As much as possible and practical, mimic the Euler's identity equation.

Most languages are limited to IEEE 754 floating point calculations so will have some error in the calculation.

If that is the case, or there is some other limitation, show
that ei



π


{\displaystyle \pi }

 + 1 is approximately equal to zero and
show the amount of error in the calculation.

If your language is capable of symbolic calculations, show
that ei



π


{\displaystyle \pi }

 + 1 is exactly equal to zero for bonus kudos points.



",#C.23,C#,"using System;
using System.Numerics;
 
public class Program
{
    static void Main() {
        Complex e = Math.E;
        Complex i = Complex.ImaginaryOne;
        Complex π = Math.PI;
        Console.WriteLine(Complex.Pow(e, i * π) + 1);
    }
}",247,12
58278,http://rosettacode.org/wiki/Euler_method,Euler method,"Euler's method numerically approximates solutions of first-order ordinary differential equations (ODEs) with a given initial value.   It is an explicit method for solving initial value problems (IVPs), as described in the wikipedia page.

The ODE has to be provided in the following form:

 






d
y
(
t
)


d
t



=
f
(
t
,
y
(
t
)
)


{\displaystyle {\frac {dy(t)}{dt}}=f(t,y(t))}


with an initial value

 



y
(

t

0


)
=

y

0




{\displaystyle y(t_{0})=y_{0}}


To get a numeric solution, we replace the derivative on the   LHS   with a finite difference approximation:

 






d
y
(
t
)


d
t



≈



y
(
t
+
h
)
−
y
(
t
)

h




{\displaystyle {\frac {dy(t)}{dt}}\approx {\frac {y(t+h)-y(t)}{h}}}


then solve for 



y
(
t
+
h
)


{\displaystyle y(t+h)}

:

 



y
(
t
+
h
)
≈
y
(
t
)
+
h




d
y
(
t
)


d
t





{\displaystyle y(t+h)\approx y(t)+h\,{\frac {dy(t)}{dt}}}


which is the same as

 



y
(
t
+
h
)
≈
y
(
t
)
+
h

f
(
t
,
y
(
t
)
)


{\displaystyle y(t+h)\approx y(t)+h\,f(t,y(t))}


The iterative solution rule is then:

 




y

n
+
1


=

y

n


+
h

f
(

t

n


,

y

n


)


{\displaystyle y_{n+1}=y_{n}+h\,f(t_{n},y_{n})}


where   



h


{\displaystyle h}

   is the step size, the most relevant parameter for accuracy of the solution.   A smaller step size increases accuracy but also the computation cost, so it has always has to be hand-picked according to the problem at hand.


Example: Newton's Cooling Law

Newton's cooling law describes how an object of initial temperature   



T
(

t

0


)
=

T

0




{\displaystyle T(t_{0})=T_{0}}

   cools down in an environment of temperature   




T

R




{\displaystyle T_{R}}

:

 






d
T
(
t
)


d
t



=
−
k

Δ
T


{\displaystyle {\frac {dT(t)}{dt}}=-k\,\Delta T}


or

 






d
T
(
t
)


d
t



=
−
k

(
T
(
t
)
−

T

R


)


{\displaystyle {\frac {dT(t)}{dt}}=-k\,(T(t)-T_{R})}




It says that the cooling rate   






d
T
(
t
)


d
t





{\displaystyle {\frac {dT(t)}{dt}}}

   of the object is proportional to the current temperature difference   



Δ
T
=
(
T
(
t
)
−

T

R


)


{\displaystyle \Delta T=(T(t)-T_{R})}

   to the surrounding environment.

The analytical solution, which we will compare to the numerical approximation, is

 



T
(
t
)
=

T

R


+
(

T

0


−

T

R


)


e

−
k
t




{\displaystyle T(t)=T_{R}+(T_{0}-T_{R})\;e^{-kt}}




Task

Implement a routine of Euler's method and then to use it to solve the given example of Newton's cooling law with it for three different step sizes of:

   2 s
   5 s       and 
   10 s 
and to compare with the analytical solution.



Initial values

   initial temperature   




T

0




{\displaystyle T_{0}}

   shall be   100 °C
   room temperature   




T

R




{\displaystyle T_{R}}

   shall be   20 °C
   cooling constant     



k


{\displaystyle k}

     shall be   0.07 
   time interval to calculate shall be from   0 s   ──►   100 s


A reference solution (Common Lisp) can be seen below.   We see that bigger step sizes lead to reduced approximation accuracy.

",#C.23,C#,"using System;
 
namespace prog
{
	class MainClass
	{
		const float T0 = 100f;
		const float TR = 20f;
		const float k = 0.07f;
		readonly static float[] delta_t = {2.0f,5.0f,10.0f};
		const int n = 100;
 
		public delegate float func(float t);
		static float NewtonCooling(float t)
		{
			return -k * (t-TR);			
		}
 
		public static void Main (string[] args)
		{
			func f = new func(NewtonCooling); 
			for(int i=0; i<delta_t.Length; i++)
			{
				Console.WriteLine(""delta_t = "" + delta_t[i]);
				Euler(f,T0,n,delta_t[i]);
			}
		}
 
		public static void Euler(func f, float y, int n, float h)
		{
			for(float x=0; x<=n; x+=h)
			{
				Console.WriteLine(""\t"" + x + ""\t"" + y);
				y += h * f(y);	
			}
		}
	}
}",713,38
58415,http://rosettacode.org/wiki/Evaluate_binomial_coefficients,Evaluate binomial coefficients,"This programming task, is to calculate ANY binomial coefficient.

However, it has to be able to output   






(


5
3


)





{\displaystyle {\binom {5}{3}}}

,   which is   10.

This formula is recommended:


 






(


n
k


)



=



n
!


(
n
−
k
)
!
k
!



=



n
(
n
−
1
)
(
n
−
2
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
(
k
−
2
)
…
1





{\displaystyle {\binom {n}{k}}={\frac {n!}{(n-k)!k!}}={\frac {n(n-1)(n-2)\ldots (n-k+1)}{k(k-1)(k-2)\ldots 1}}}





See Also:

 Combinations and permutations
 Pascal's triangle

 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",#C.23,C#,"using System;
 
namespace BinomialCoefficients
{
    class Program
    {
        static void Main(string[] args)
        {
            ulong n = 1000000, k = 3;
            ulong result = biCoefficient(n, k);
            Console.WriteLine(""The Binomial Coefficient of {0}, and {1}, is equal to: {2}"", n, k, result);
            Console.ReadLine();
        }
 
        static int fact(int n)
        {
            if (n == 0) return 1;
            else return n * fact(n - 1);
        }
 
        static ulong biCoefficient(ulong n, ulong k)
        {
            if (k > n - k)
            {
                k = n - k;
            }
 
            ulong c = 1;
            for (uint i = 0; i < k; i++)
            {
                c = c * (n - i);
                c = c / (i + 1);
            }
            return c;
        }
    }
}",834,37
58473,http://rosettacode.org/wiki/Environment_variables,Environment variables,"Task

Show how to get one of your process's environment variables.

The available variables vary by system;   some of the common ones available on Unix include:

   PATH
   HOME
   USER

",#C.23,C#,"using System;
 
namespace RosettaCode {
    class Program {
        static void Main() {
            string temp = Environment.GetEnvironmentVariable(""TEMP"");
            Console.WriteLine(""TEMP is "" + temp);
        }
    }
}",226,10
58477,http://rosettacode.org/wiki/Euler%27s_sum_of_powers_conjecture,Euler's sum of powers conjecture,"There is a conjecture in mathematics that held for over two hundred years before it was disproved by the finding of a counterexample in 1966 by Lander and Parkin.



Euler's (disproved) sum of powers   conjecture

  At least  k  positive  kth  powers are required to sum to a  kth  power,  
  except for the trivial case of one  kth power:  yk = yk 



In 1966,   Leon J. Lander   and   Thomas R. Parkin   used a brute-force search on a   CDC 6600   computer restricting numbers to those less than 250.



Task

Write a program to search for an integer solution for:


  x05 + x15 + x25 + x35 == y5 

Where all     xi's   and    y    are distinct integers between   0   and   250   (exclusive).

Show an answer here.



Related tasks

   Pythagorean quadruples. 
   Pythagorean triples.

",#C.23,C#,"using System;
 
namespace EulerSumOfPowers {
    class Program {
        const int MAX_NUMBER = 250;
 
        static void Main(string[] args) {
            bool found = false;
            long[] fifth = new long[MAX_NUMBER];
 
            for (int i = 1; i <= MAX_NUMBER; i++) {
                long i2 = i * i;
                fifth[i - 1] = i2 * i2 * i;
            }
 
            for (int a = 0; a < MAX_NUMBER && !found; a++) {
                for (int b = a; b < MAX_NUMBER && !found; b++) {
                    for (int c = b; c < MAX_NUMBER && !found; c++) {
                        for (int d = c; d < MAX_NUMBER && !found; d++) {
                            long sum = fifth[a] + fifth[b] + fifth[c] + fifth[d];
                            int e = Array.BinarySearch(fifth, sum);
                            found = e >= 0;
                            if (found) {
                                Console.WriteLine(""{0}^5 + {1}^5 + {2}^5 + {3}^5 = {4}^5"", a + 1, b + 1, c + 1, d + 1, e + 1);
                            }
                        }
                    }
                }
            }
        }
    }
}",1130,32
58554,http://rosettacode.org/wiki/Enumerations,Enumerations,"Task

Create an enumeration of constants with and without explicit values.



",#C.23,C#,"enum fruits { apple, banana, cherry }
 
enum fruits { apple = 0, banana = 1, cherry = 2 }
 
enum fruits : int { apple = 0, banana = 1, cherry = 2 }
 
[FlagsAttribute]
enum Colors { Red = 1, Green = 2, Blue = 4, Yellow = 8 }",223,8
58561,http://rosettacode.org/wiki/Equilibrium_index,Equilibrium index,"An equilibrium index of a sequence is an index into the sequence such that the sum of elements at lower indices is equal to the sum of elements at higher indices.



For example, in a sequence   



A


{\displaystyle A}

:

   




A

0


=
−
7


{\displaystyle A_{0}=-7}


   




A

1


=
1


{\displaystyle A_{1}=1}


   




A

2


=
5


{\displaystyle A_{2}=5}


   




A

3


=
2


{\displaystyle A_{3}=2}


   




A

4


=
−
4


{\displaystyle A_{4}=-4}


   




A

5


=
3


{\displaystyle A_{5}=3}


   




A

6


=
0


{\displaystyle A_{6}=0}


3   is an equilibrium index, because:

   




A

0


+

A

1


+

A

2


=

A

4


+

A

5


+

A

6




{\displaystyle A_{0}+A_{1}+A_{2}=A_{4}+A_{5}+A_{6}}


6   is also an equilibrium index, because:

   




A

0


+

A

1


+

A

2


+

A

3


+

A

4


+

A

5


=
0


{\displaystyle A_{0}+A_{1}+A_{2}+A_{3}+A_{4}+A_{5}=0}


(sum of zero elements is zero)

7   is not an equilibrium index, because it is not a valid index of sequence 



A


{\displaystyle A}

.



Task;
Write a function that, given a sequence, returns its equilibrium indices (if any).

Assume that the sequence may be very long.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
class Program
{
    static IEnumerable<int> EquilibriumIndices(IEnumerable<int> sequence)
    {
        var left = 0;
        var right = sequence.Sum();
        var index = 0;
        foreach (var element in sequence)
        {
            right -= element;
            if (left == right)
            {
                yield return index;
            }
            left += element;
            index++;
        }
    }
 
    static void Main()
    {
        foreach (var index in EquilibriumIndices(new[] { -7, 1, 5, 2, -4, 3, 0 }))
        {
            Console.WriteLine(index);
        }
    }
}",668,31
58579,http://rosettacode.org/wiki/Enforced_immutability,Enforced immutability,"Task

Demonstrate any means your language has to prevent the modification of values, or to create objects that cannot be modified after they have been created.



",#C.23,C#,readonly DateTime now = DateTime.Now;,37,1
58828,http://rosettacode.org/wiki/Empty_directory,Empty directory,"Starting with a path to some directory, determine whether the directory is empty.

An empty directory contains no files nor subdirectories.
With Unix or Windows systems, every directory contains an entry for “.” and almost every directory contains “..” (except for a root directory); an empty directory contains no other entries.
",#C.23,C#,"using System;
using System.IO;
 
class Program
{
    static void Main( string[] args )
    {
        foreach ( string dir in args )
        {
            Console.WriteLine( ""'{0}' {1} empty"", dir, IsDirectoryEmpty( dir ) ? ""is"" : ""is not"" );
        }
    }
 
    private static bool IsDirectoryEmpty( string dir )
    {
        return ( Directory.GetFiles( dir ).Length == 0 &&
            Directory.GetDirectories( dir ).Length == 0 );
    }
}
 ",447,20
58836,http://rosettacode.org/wiki/Entropy,Entropy,"Task

Calculate the Shannon entropy   H   of a given input string.

Given the discrete random variable 



X


{\displaystyle X}

 that is a string of 



N


{\displaystyle N}

 ""symbols"" (total characters) consisting of 



n


{\displaystyle n}

 different characters (n=2 for binary), the Shannon entropy of X in bits/symbol is :






H

2


(
X
)
=
−

∑

i
=
1


n





c
o
u
n

t

i



N



log

2


⁡

(



c
o
u
n

t

i



N


)



{\displaystyle H_{2}(X)=-\sum _{i=1}^{n}{\frac {count_{i}}{N}}\log _{2}\left({\frac {count_{i}}{N}}\right)}


where 



c
o
u
n

t

i




{\displaystyle count_{i}}

 is the count of character 




n

i




{\displaystyle n_{i}}

.

For this task, use X=""1223334444"" as an example. The result should be 1.84644... bits/symbol. This assumes X was a random variable, which may not be the case, or it may depend on the observer.

This coding problem calculates the ""specific"" or ""intensive"" entropy that finds its parallel in physics with ""specific entropy"" S0 which is entropy per kg or per mole, not like physical entropy S and therefore not the ""information"" content of a file. It comes from Boltzmann's H-theorem where 



S
=

k

B


N
H


{\displaystyle S=k_{B}NH}

 where N=number of molecules. Boltzmann's H is the same equation as Shannon's H, and it gives the specific entropy H on a ""per molecule"" basis.

The ""total"", ""absolute"", or ""extensive"" information entropy is





S
=

H

2


N


{\displaystyle S=H_{2}N}

 bits
This is not the entropy being coded here, but it is the closest to physical entropy and a measure of the information content of a string. But it does not look for any patterns that might be available for compression, so it is a very restricted, basic, and certain measure of ""information"". Every binary file with an equal number of 1's and 0's will have S=N bits. All hex files with equal symbol frequencies will have 



S
=
N

log

2


⁡
(
16
)


{\displaystyle S=N\log _{2}(16)}

 bits of entropy. The total entropy in bits of the example above is S= 10*18.4644 = 18.4644 bits.

The H function does not look for any patterns in data or check if X was a random variable. For example, X=000000111111 gives the same calculated entropy in all senses as Y=010011100101. For most purposes it is usually more relevant to divide the gzip length by the length of the original data to get an informal measure of how much ""order"" was in the data.

Two other ""entropies"" are useful:

Normalized specific entropy:






H

n


=




H

2


∗
log
⁡
(
2
)


log
⁡
(
n
)





{\displaystyle H_{n}={\frac {H_{2}*\log(2)}{\log(n)}}}

 
which varies from 0 to 1 and it has units of ""entropy/symbol"" or just 1/symbol. For this example, Hn<\sub>= 0.923.

Normalized total (extensive) entropy:






S

n


=




H

2


N
∗
log
⁡
(
2
)


log
⁡
(
n
)





{\displaystyle S_{n}={\frac {H_{2}N*\log(2)}{\log(n)}}}


which varies from 0 to N and does not have units. It is simply the ""entropy"", but it needs to be called ""total normalized extensive entropy"" so that it is not confused with Shannon's (specific) entropy or physical entropy. For this example, Sn<\sub>= 9.23.

Shannon himself is the reason his ""entropy/symbol"" H function is very confusingly called ""entropy"". That's like calling a function that returns a speed a ""meter"". See section 1.7 of his classic A Mathematical Theory of Communication and search on ""per symbol"" and ""units"" to see he always stated his entropy H has units of ""bits/symbol"" or ""entropy/symbol"" or ""information/symbol"". So it is legitimate to say entropy NH is ""information"".

In keeping with Landauer's limit, the physics entropy generated from erasing N bits is 



S
=

H

2


N

k

B


ln
⁡
(
2
)


{\displaystyle S=H_{2}Nk_{B}\ln(2)}

 if the bit storage device is perfectly efficient. This can be solved for H2*N to (arguably) get the number of bits of information that a physical entropy represents.

Related tasks

 Fibonacci_word
 Entropy/Narcissist

",#C.23,C#," 
using System;
using System.Collections.Generic;
namespace Entropy
{
	class Program
	{
		public static double logtwo(double num)
		{
			return Math.Log(num)/Math.Log(2);
		}
		public static void Main(string[] args)
		{
		label1:
			string input = Console.ReadLine();
			double infoC=0;
			Dictionary<char,double> table = new Dictionary<char, double>();
 
 
			foreach (char c in input)
			{
				if (table.ContainsKey(c))
					table[c]++;
				    else
				    	table.Add(c,1);
 
			}
			double freq;
			foreach (KeyValuePair<char,double> letter in table)
			{
				freq=letter.Value/input.Length;
				infoC+=freq*logtwo(freq);
			}
			infoC*=-1;
			Console.WriteLine(""The Entropy of {0} is {1}"",input,infoC);
			goto label1;
 
		}
	}
}
 ",736,41
58837,http://rosettacode.org/wiki/Ethiopian_multiplication,Ethiopian multiplication,"Ethiopian multiplication is a method of multiplying integers using only addition, doubling, and halving.


Method:

 Take two numbers to be multiplied and write them down at the top of two columns.
 In the left-hand column repeatedly halve the last number, discarding any remainders, and write the result below the last in the same column, until you write a value of 1.
 In the right-hand column repeatedly double the last number and write the result below. stop when you add a result in the same row as where the left hand column shows 1.
 Examine the table produced and discard any row where the value in the left column is even.
 Sum the values in the right-hand column that remain to produce the result of multiplying the original two numbers together

For example:   17 × 34

       17    34

Halving the first column:

       17    34
        8
        4
        2
        1

Doubling the second column:

       17    34
        8    68
        4   136 
        2   272
        1   544

Strike-out rows whose first cell is even:

       17    34
        8    68 
        4   136 
        2   272 
        1   544

Sum the remaining numbers in the right-hand column:

       17    34
        8    -- 
        4   --- 
        2   --- 
        1   544
           ====
            578

So 17 multiplied by 34, by the Ethiopian method is 578.



Task

The task is to define three named functions/methods/procedures/subroutines:

 one to halve an integer,
 one to double an integer, and
 one to state if an integer is even.


Use these functions to create a function that does Ethiopian multiplication.



References

Ethiopian multiplication explained (BBC Video clip)
A Night Of Numbers - Go Forth And Multiply (Video)
Russian Peasant Multiplication
Programming Praxis: Russian Peasant Multiplication

",#C.23,C#," 
using System;
using System.Linq;
 
namespace RosettaCode.Tasks
{
	public static class EthiopianMultiplication_Task
	{
		public static void Test ( )
		{
			Console.WriteLine ( ""Ethiopian Multiplication"" );
			int A = 17, B = 34;
			Console.WriteLine ( ""Recursion: {0}*{1}={2}"", A, B, EM_Recursion ( A, B ) );
			Console.WriteLine ( ""Linq: {0}*{1}={2}"", A, B, EM_Linq ( A, B ) );
			Console.WriteLine ( ""Loop: {0}*{1}={2}"", A, B, EM_Loop ( A, B ) );
			Console.WriteLine ( );
		}
 
		public static int Halve ( this int p_Number )
		{
			return p_Number >> 1;
		}
		public static int Double ( this int p_Number )
		{
			return p_Number << 1;
		}
		public static bool IsEven ( this int p_Number )
		{
			return ( p_Number % 2 ) == 0;
		}
 
		public static int EM_Recursion ( int p_NumberA, int p_NumberB )
		{
			//     Anchor Point,                Recurse to find the next row                                 Sum it with the second number according to the rules
			return p_NumberA == 1 ? p_NumberB : EM_Recursion ( p_NumberA.Halve ( ), p_NumberB.Double ( ) ) + ( p_NumberA.IsEven ( ) ? 0 : p_NumberB );
		}
		public static int EM_Linq ( int p_NumberA, int p_NumberB )
		{
			// Creating a range from 1 to x where x the number of times p_NumberA can be halved.
			// This will be 2^x where 2^x <= p_NumberA. Basically, ln(p_NumberA)/ln(2).
			return Enumerable.Range ( 1, Convert.ToInt32 ( Math.Log ( p_NumberA, Math.E ) / Math.Log ( 2, Math.E ) ) + 1 )
				// For every item (Y) in that range, create a new list, comprising the pair (p_NumberA,p_NumberB) Y times.
				.Select ( ( item ) => Enumerable.Repeat ( new { Col1 = p_NumberA, Col2 = p_NumberB }, item )
					// The aggregate method iterates over every value in the target list, passing the accumulated value and the current item's value.
					.Aggregate ( ( agg_pair, orig_pair ) => new { Col1 = agg_pair.Col1.Halve ( ), Col2 = agg_pair.Col2.Double ( ) } ) )
				// Remove all even items
				.Where ( pair => !pair.Col1.IsEven ( ) )
				// And sum!
				.Sum ( pair => pair.Col2 );
		}
		public static int EM_Loop ( int p_NumberA, int p_NumberB )
		{
			int RetVal = 0;
			while ( p_NumberA >= 1 )
			{
				RetVal += p_NumberA.IsEven ( ) ? 0 : p_NumberB;
				p_NumberA = p_NumberA.Halve ( );
				p_NumberB = p_NumberB.Double ( );
			}
			return RetVal;
		}
	}
}",2318,63
58845,http://rosettacode.org/wiki/Even_or_odd,Even or odd,"Task

Test whether an integer is even or odd.

There is more than one way to solve this task:

 Use the even and odd predicates, if the language provides them.
 Check the least significant digit. With binary integers, i bitwise-and 1 equals 0 iff i is even, or equals 1 iff i is odd.
 Divide i by 2. The remainder equals 0 iff i is even. The remainder equals +1 or -1 iff i is odd.
 Use modular congruences:
 i ≡ 0 (mod 2) iff i is even.
 i ≡ 1 (mod 2) iff i is odd.

",#C.23,C#,"namespace RosettaCode
{
    using System;
 
    public static class EvenOrOdd
    {
        public static bool IsEvenBitwise(this int number)
        {
            return (number & 1) == 0;
        }
 
        public static bool IsOddBitwise(this int number)
        {
            return (number & 1) != 0;
        }
 
        public static bool IsEvenRemainder(this int number)
        {
            int remainder;
            Math.DivRem(number, 2, out remainder);
            return remainder == 0;
        }
 
        public static bool IsOddRemainder(this int number)
        {
            int remainder;
            Math.DivRem(number, 2, out remainder);
            return remainder != 0;
        }
 
        public static bool IsEvenModulo(this int number)
        {
            return (number % 2) == 0;
        }
 
        public static bool IsOddModulo(this int number)
        {
            return (number % 2) != 0;
        }
    }
    public class Program
    {
        public static void Main()
        {
            int num = 26;               //Set this to any integer.
            if (num.IsEvenBitwise())    //Replace this with any even function.
            {
                Console.Write(""Even"");
            }
            else
            {
                Console.Write(""Odd"");
            }
            //Prints ""Even"".
            if (num.IsOddBitwise())    //Replace this with any odd function.
            {
                Console.Write(""Odd"");
            }
            else
            {
                Console.Write(""Even"");
            }
            //Prints ""Even"".
        }
    }
}",1618,66
58989,http://rosettacode.org/wiki/Emirp_primes,Emirp primes,"An   emirp   (prime spelled backwards)   are primes that when reversed   (in their decimal representation)   are a different prime.

(This rules out palindromic primes.)



Task

   show the first   twenty   emirps
   show all emirps between   7,700   and   8,000
   show the   10,000th   emirp


In each list, the numbers should be in order.

Invoke the (same) program once per task requirement, this will show what limit is used as the upper bound for calculating surplus (regular) primes.

The specific method of how to determine if a range or if specific values are to be shown will be left to the programmer.



See also

   Wikipedia, Emirp.
   The Prime Pages, emirp.
   Wolfram MathWorld™, Emirp.
   The On‑Line Encyclopedia of Integer Sequences, emirps (A6567).

",#C.23,C#,"using static System.Console;
using System;
using System.Linq;
using System.Collections.Generic;
 
public class Program
{
    public static void Main() {
        const int limit = 1_000_000;
        WriteLine(""First 20:"");
        WriteLine(FindEmirpPrimes(limit).Take(20).Delimit());
        WriteLine();
 
        WriteLine(""Between 7700 and 8000:"");
        WriteLine(FindEmirpPrimes(limit).SkipWhile(p => p < 7700).TakeWhile(p => p < 8000).Delimit());
        WriteLine();
 
        WriteLine(""10000th:"");
        WriteLine(FindEmirpPrimes(limit).ElementAt(9999));
    }
 
    private static IEnumerable<int> FindEmirpPrimes(int limit)
    {
        var primes = Primes(limit).ToHashSet();
 
        foreach (int prime in primes) {
            int reverse = prime.Reverse();
            if (reverse != prime && primes.Contains(reverse)) yield return prime;
	}
    }
 
    private static IEnumerable<int> Primes(int bound) {
        if (bound < 2) yield break;
        yield return 2;
 
        BitArray composite = new BitArray((bound - 1) / 2);
        int limit = ((int)(Math.Sqrt(bound)) - 1) / 2;
        for (int i = 0; i < limit; i++) {
            if (composite[i]) continue;
	    int prime = 2 * i + 3;
	    yield return prime;
 
	    for (int j = (prime * prime - 2) / 2; j < composite.Count; j += prime)
	        composite[j] = true;
        }
	for (int i = limit; i < composite.Count; i++)
	    if (!composite[i]) yield return 2 * i + 3;
    }
}
 
public static class Extensions
{
    public static HashSet<T> ToHashSet<T>(this IEnumerable<T> source) => new HashSet<T>(source);
 
    private const string defaultSeparator = "" "";
    public static string Delimit<T>(this IEnumerable<T> source, string separator = defaultSeparator) =>
        string.Join(separator ?? defaultSeparator, source);
 
    public static int Reverse(this int number)
    {
	if (number < 0) return -Reverse(-number);
	if (number < 10) return number;
	int reverse = 0;
	while (number > 0) {
	    reverse = reverse * 10 + number % 10;
	    number /= 10;
	}
	return reverse;
    }
}",2067,70
59153,http://rosettacode.org/wiki/Empty_string,Empty string,"Languages may have features for dealing specifically with empty strings
(those containing no characters).



Task

   Demonstrate how to assign an empty string to a variable.
   Demonstrate how to check that a string is empty.
   Demonstrate how to check that a string is not empty.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
 
class Program {
    static void Main (string[] args) {
        string example = string.Empty;
        if (string.IsNullOrEmpty(example)) { }
        if (!string.IsNullOrEmpty(example)) { }
    }
}",212,9
59269,http://rosettacode.org/wiki/Empty_program,Empty program,"Task

Create the simplest possible program that is still considered ""correct.""



",#C.23,C#,int main(){},12,1
60051,http://rosettacode.org/wiki/Echo_server,Echo server,"Create a network service that sits on TCP port 12321, which accepts connections on that port, and which echoes complete lines (using a carriage-return/line-feed sequence as line separator) back to clients. No error handling is required. For the purposes of testing, it is only necessary to support connections from localhost (127.0.0.1 or perhaps ::1). Logging of connection information to standard output is recommended.

The implementation must be able to handle simultaneous connections from multiple clients. A multi-threaded or multi-process solution may be used. Each connection must be able to echo more than a single line.

The implementation must not stop responding to other clients if one client sends a partial line or stops reading responses.
",#C.23,C#,"using System.Net.Sockets;
using System.Threading;
 
namespace ConsoleApplication1
{
    class Program
    {
        static TcpListener listen;
        static Thread serverthread;
 
        static void Main(string[] args)
        {
            listen = new TcpListener(System.Net.IPAddress.Parse(""127.0.0.1""), 12321);
            serverthread = new Thread(new ThreadStart(DoListen));
            serverthread.Start();
        }
 
        private static void DoListen()
        {
            // Listen
            listen.Start();
            Console.WriteLine(""Server: Started server"");
 
            while (true)
            {
                Console.WriteLine(""Server: Waiting..."");
                TcpClient client = listen.AcceptTcpClient();
                Console.WriteLine(""Server: Waited"");
 
                // New thread with client
                Thread clientThread = new Thread(new ParameterizedThreadStart(DoClient));
                clientThread.Start(client);
            }
        }
 
        private static void DoClient(object client)
        {
            // Read data
            TcpClient tClient = (TcpClient)client;
 
            Console.WriteLine(""Client (Thread: {0}): Connected!"", Thread.CurrentThread.ManagedThreadId);
            do
            {
                if (!tClient.Connected)
                { 
                    tClient.Close();
                    Thread.CurrentThread.Abort();       // Kill thread.
                }
 
                if (tClient.Available > 0)
                {
                    // Resend
                    byte pByte = (byte)tClient.GetStream().ReadByte();
                    Console.WriteLine(""Client (Thread: {0}): Data {1}"", Thread.CurrentThread.ManagedThreadId, pByte);
                    tClient.GetStream().WriteByte(pByte);
                }
 
                // Pause
                Thread.Sleep(100);
            } while (true);
        }
    }
}",1926,63
60061,http://rosettacode.org/wiki/Eertree,Eertree,"An eertree is a data structure designed for efficient processing of certain palindrome tasks, for instance counting the number of sub-palindromes in an input string.

The data structure has commonalities to both tries and suffix trees.
  See links below.



Task

Construct an eertree for the string ""eertree"", then output all sub-palindromes by traversing the tree.



See also

   Wikipedia entry:   trie.
   Wikipedia entry:   suffix tree 
   Cornell University Library, Computer Science, Data Structures and Algorithms ───► EERTREE: An Efficient Data Structure for Processing Palindromes in Strings.

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace Eertree {
    class Node {
        public Node(int length) {
            this.Length = length;
            // empty or
            this.Edges = new Dictionary<char, int>();
        }
 
        public Node(int length, Dictionary<char, int> edges, int suffix) {
            this.Length = length;
            this.Edges = edges;
            this.Suffix = suffix;
        }
 
        public int Length { get; set; }
        public Dictionary<char, int> Edges { get; set; }
        public int Suffix { get; set; }
    }
 
    class Program {
        const int EVEN_ROOT = 0;
        const int ODD_ROOT = 1;
 
        static List<Node> Eertree(string s) {
            List<Node> tree = new List<Node> {
                //new Node(0, null, ODD_ROOT), or
                new Node(0, new Dictionary<char, int>(), ODD_ROOT),
                //new Node(-1, null, ODD_ROOT) or
                new Node(-1, new Dictionary<char, int>(), ODD_ROOT)
            };
            int suffix = ODD_ROOT;
            int n, k;
            for (int i = 0; i < s.Length; i++) {
                char c = s[i];
                for (n = suffix; ; n = tree[n].Suffix) {
                    k = tree[n].Length;
                    int b = i - k - 1;
                    if (b >= 0 && s[b] == c) {
                        break;
                    }
                }
                if (tree[n].Edges.ContainsKey(c)) {
                    suffix = tree[n].Edges[c];
                    continue;
                }
                suffix = tree.Count;
                tree.Add(new Node(k + 2));
                tree[n].Edges[c] = suffix;
                if (tree[suffix].Length == 1) {
                    tree[suffix].Suffix = 0;
                    continue;
                }
                while (true) {
                    n = tree[n].Suffix;
                    int b = i - tree[n].Length - 1;
                    if (b >= 0 && s[b] == c) {
                        break;
                    }
                }
                tree[suffix].Suffix = tree[n].Edges[c];
            }
            return tree;
        }
 
        static List<string> SubPalindromes(List<Node> tree) {
            List<string> s = new List<string>();
            SubPalindromes_children(0, """", tree, s);
            foreach (var c in tree[1].Edges.Keys) {
                int m = tree[1].Edges[c];
                string ct = c.ToString();
                s.Add(ct);
                SubPalindromes_children(m, ct, tree, s);
            }
            return s;
        }
 
        static void SubPalindromes_children(int n, string p, List<Node> tree, List<string> s) {
            foreach (var c in tree[n].Edges.Keys) {
                int m = tree[n].Edges[c];
                string p1 = c + p + c;
                s.Add(p1);
                SubPalindromes_children(m, p1, tree, s);
            }
        }
 
        static void Main(string[] args) {
            List<Node> tree = Eertree(""eertree"");
            List<string> result = SubPalindromes(tree);
            string listStr = string.Join("", "", result);
            Console.WriteLine(""[{0}]"", listStr);
        }
    }
}",3199,96
60130,http://rosettacode.org/wiki/Elementary_cellular_automaton,Elementary cellular automaton,"An elementary cellular automaton is a one-dimensional cellular automaton where there are two possible states (labeled 0 and 1) and the rule to determine the state of a cell in the next generation depends only on the current state of the cell and its two immediate neighbors. Those three values can be encoded with three bits.

The rules of evolution are then encoded with eight bits indicating the outcome of each of the eight possibilities 111, 110, 101, 100, 011, 010, 001 and 000 in this order. Thus for instance the rule 13 means that a state is updated to 1 only in the cases 011, 010 and 000, since 13 in binary is 0b00001101.



Task

Create a subroutine, program or function that allows to create and visualize the evolution of any of the 256 possible elementary cellular automaton of arbitrary space length and for any given initial state. You can demonstrate your solution with any automaton of your choice.

The space state should wrap: this means that the left-most cell should be considered as the right neighbor of the right-most cell, and reciprocally.

This task is basically a generalization of one-dimensional cellular automata.



See also
 Cellular automata (natureofcode.com)

",#C.23,C#," 
using System;
using System.Collections;
namespace ElementaryCellularAutomaton
{
    class Automata
    {
        BitArray cells, ncells;
        const int MAX_CELLS = 19;
 
        public void run()
        {
            cells = new BitArray(MAX_CELLS);
            ncells = new BitArray(MAX_CELLS);
            while (true)
            {
                Console.Clear();
                Console.WriteLine(""What Rule do you want to visualize"");
                doRule(int.Parse(Console.ReadLine()));
                Console.WriteLine(""Press any key to continue..."");
                Console.ReadKey();
            }
        }
 
        private byte getCells(int index)
        {
            byte b;
            int i1 = index - 1,
                i2 = index,
                i3 = index + 1;
 
            if (i1 < 0) i1 = MAX_CELLS - 1;
            if (i3 >= MAX_CELLS) i3 -= MAX_CELLS;
 
            b = Convert.ToByte(
                4 * Convert.ToByte(cells.Get(i1)) +
                2 * Convert.ToByte(cells.Get(i2)) +
                Convert.ToByte(cells.Get(i3)));
            return b;
        }
 
        private string getBase2(int i)
        {
            string s = Convert.ToString(i, 2);
            while (s.Length < 8)
            { s = ""0"" + s; }
            return s;
        }
 
        private void doRule(int rule)
        {
            Console.Clear();
            string rl = getBase2(rule);
            cells.SetAll(false);
            ncells.SetAll(false);
            cells.Set(MAX_CELLS / 2, true);
 
            Console.WriteLine(""Rule: "" + rule + ""\n----------\n"");
 
            for (int gen = 0; gen < 51; gen++)
            {
                Console.Write(""{0, 4}"", gen + "": "");
 
                foreach (bool b in cells)
                    Console.Write(b ? ""#"" : ""."");
 
                Console.WriteLine("""");
 
                int i = 0;
                while (true)
                {
                    byte b = getCells(i);
                    ncells[i] = '1' == rl[7 - b] ? true : false;
                    if (++i == MAX_CELLS) break;
                }
 
                i = 0;
                foreach (bool b in ncells)
                    cells[i++] = b;
            }
            Console.WriteLine("""");
        }
 
    };
    class Program
    {
        static void Main(string[] args)
        {
            Automata t = new Automata();
            t.run();
        }
    }
}
 ",2426,94
60204,http://rosettacode.org/wiki/Element-wise_operations,Element-wise operations,"This task is similar to:

   Matrix multiplication
   Matrix transposition


Task

Implement basic element-wise matrix-matrix and scalar-matrix operations, which can be referred to in other, higher-order tasks.

Implement:

   addition
   subtraction
   multiplication
   division
   exponentiation


Extend the task if necessary to include additional basic operations, which should not require their own specialised task.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
public static class ElementWiseOperations
{
    private static readonly Dictionary<string, Func<double, double, double>> operations =
        new Dictionary<string, Func<double, double, double>> {
            { ""add"", (a, b) => a + b },
            { ""sub"", (a, b) => a - b },
            { ""mul"", (a, b) => a * b },
            { ""div"", (a, b) => a / b },
            { ""pow"", (a, b) => Math.Pow(a, b) }
        };
 
    private static readonly Func<double, double, double> nothing = (a, b) => a;
 
    public static double[,] DoOperation(this double[,] m, string name, double[,] other) =>
        DoOperation(m, operations.TryGetValue(name, out var operation) ? operation : nothing, other);
 
    public static double[,] DoOperation(this double[,] m, Func<double, double, double> operation, double[,] other) {
        if (m == null || other == null) throw new ArgumentNullException();
        int rows = m.GetLength(0), columns = m.GetLength(1);
        if (rows != other.GetLength(0) || columns != other.GetLength(1)) {
            throw new ArgumentException(""Matrices have different dimensions."");
        }
 
        double[,] result = new double[rows, columns];
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < columns; c++) {
                result[r, c] = operation(m[r, c], other[r, c]);
            }
        }
        return result;
    }
 
    public static double[,] DoOperation(this double[,] m, string name, double number) =>
        DoOperation(m, operations.TryGetValue(name, out var operation) ? operation : nothing, number);
 
    public static double[,] DoOperation(this double[,] m, Func<double, double, double> operation, double number) {
        if (m == null) throw new ArgumentNullException();
        int rows = m.GetLength(0), columns = m.GetLength(1);
        double[,] result = new double[rows, columns];
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < columns; c++) {
                result[r, c] = operation(m[r, c], number);
            }
        }
        return result;
    }
 
    public static void Print(this double[,] m) {
        if (m == null) throw new ArgumentNullException();
        int rows = m.GetLength(0), columns = m.GetLength(1);
        for (int r = 0; r < rows; r++) {
            Console.WriteLine(""[ "" + string.Join("", "", Enumerable.Range(0, columns).Select(c => m[r, c])) + "" ]"");
        }
    }
 
}
 
public class Program
{
    public static void Main() {
        double[,] matrix = {
            { 1, 2, 3, 4 },
            { 5, 6, 7, 8 },
            { 9, 10, 11, 12 }
        };
 
        double[,] tens = {
            { 10, 10, 10, 10 },
            { 20, 20, 20, 20 },
            { 30, 30, 30, 30 }
        };
 
        matrix.Print();
        WriteLine();
 
        (matrix = matrix.DoOperation(""add"", tens)).Print();
        WriteLine();
 
        matrix.DoOperation((a, b) => b - a, 100).Print();
    }
}",2990,85
60206,http://rosettacode.org/wiki/Egyptian_fractions,Egyptian fractions,"An   Egyptian fraction   is the sum of distinct unit fractions such as:

  






1
2



+



1
3



+



1
16




(
=



43
48



)


{\displaystyle {\tfrac {1}{2}}+{\tfrac {1}{3}}+{\tfrac {1}{16}}\,(={\tfrac {43}{48}})}

 
Each fraction in the expression has a numerator equal to   1   (unity)   and a denominator that is a positive integer,   and all the denominators are distinct   (i.e., no repetitions).

Fibonacci's   Greedy algorithm for Egyptian fractions   expands the fraction    






x
y





{\displaystyle {\tfrac {x}{y}}}

    to be represented by repeatedly performing the replacement

  





x
y


=


1

⌈
y

/

x
⌉



+



(
−
y
)





mod


x


y
⌈
y

/

x
⌉





{\displaystyle {\frac {x}{y}}={\frac {1}{\lceil y/x\rceil }}+{\frac {(-y)\!\!\!\!\mod x}{y\lceil y/x\rceil }}}

 


(simplifying the 2nd term in this replacement as necessary, and where    



⌈
x
⌉


{\displaystyle \lceil x\rceil }

    is the   ceiling   function).



For this task,   Proper and improper fractions   must be able to be expressed.



Proper  fractions   are of the form    






a
b





{\displaystyle {\tfrac {a}{b}}}

    where    



a


{\displaystyle a}

    and    



b


{\displaystyle b}

    are positive integers, such that    



a
<
b


{\displaystyle a<b}

,     and

improper fractions are of the form    






a
b





{\displaystyle {\tfrac {a}{b}}}

    where    



a


{\displaystyle a}

    and    



b


{\displaystyle b}

    are positive integers, such that    a ≥ b.



(See the REXX programming example to view one method of expressing the whole number part of an improper fraction.)

For improper fractions, the integer part of any improper fraction should be first isolated and shown preceding the Egyptian unit fractions, and be surrounded by square brackets [n].



Task requirements

   show the Egyptian fractions for: 






43
48





{\displaystyle {\tfrac {43}{48}}}

 and 






5
121





{\displaystyle {\tfrac {5}{121}}}

 and 






2014
59





{\displaystyle {\tfrac {2014}{59}}}


   for all proper fractions,    






a
b





{\displaystyle {\tfrac {a}{b}}}

    where    



a


{\displaystyle a}

    and    



b


{\displaystyle b}

    are positive one-or two-digit (decimal) integers, find and show an Egyptian fraction that has:
   the largest number of terms,
   the largest denominator.
   for all one-, two-, and three-digit integers,   find and show (as above).     {extra credit}


Also see

   Wolfram MathWorld™ entry: Egyptian fraction

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
 
namespace EgyptianFractions {
    class Program {
        class Rational : IComparable<Rational>, IComparable<int> {
            public BigInteger Num { get; }
            public BigInteger Den { get; }
 
            public Rational(BigInteger n, BigInteger d) {
                var c = Gcd(n, d);
                Num = n / c;
                Den = d / c;
                if (Den < 0) {
                    Num = -Num;
                    Den = -Den;
                }
            }
 
            public Rational(BigInteger n) {
                Num = n;
                Den = 1;
            }
 
            public override string ToString() {
                if (Den == 1) {
                    return Num.ToString();
                } else {
                    return string.Format(""{0}/{1}"", Num, Den);
                }
            }
 
            public Rational Add(Rational rhs) {
                return new Rational(Num * rhs.Den + rhs.Num * Den, Den * rhs.Den);
            }
 
            public Rational Sub(Rational rhs) {
                return new Rational(Num * rhs.Den - rhs.Num * Den, Den * rhs.Den);
            }
 
            public int CompareTo(Rational rhs) {
                var ad = Num * rhs.Den;
                var bc = Den * rhs.Num;
                return ad.CompareTo(bc);
            }
 
            public int CompareTo(int rhs) {
                var ad = Num * rhs;
                var bc = Den * rhs;
                return ad.CompareTo(bc);
            }
        }
 
        static BigInteger Gcd(BigInteger a, BigInteger b) {
            if (b == 0) {
                if (a < 0) {
                    return -a;
                } else {
                    return a;
                }
            } else {
                return Gcd(b, a % b);
            }
        }
 
        static List<Rational> Egyptian(Rational r) {
            List<Rational> result = new List<Rational>();
 
            if (r.CompareTo(1) >= 0) {
                if (r.Den == 1) {
                    result.Add(r);
                    result.Add(new Rational(0));
                    return result;
                }
                result.Add(new Rational(r.Num / r.Den));
                r = r.Sub(result[0]);
            }
 
            BigInteger modFunc(BigInteger m, BigInteger n) {
                return ((m % n) + n) % n;
            }
 
            while (r.Num != 1) {
                var q = (r.Den + r.Num - 1) / r.Num;
                result.Add(new Rational(1, q));
                r = new Rational(modFunc(-r.Den, r.Num), r.Den * q);
            }
 
            result.Add(r);
            return result;
        }
 
        static string FormatList<T>(IEnumerable<T> col) {
            StringBuilder sb = new StringBuilder();
            var iter = col.GetEnumerator();
 
            sb.Append('[');
            if (iter.MoveNext()) {
                sb.Append(iter.Current);
            }
            while (iter.MoveNext()) {
                sb.AppendFormat("", {0}"", iter.Current);
            }
            sb.Append(']');
 
            return sb.ToString();
        }
 
        static void Main() {
            List<Rational> rs = new List<Rational> {
                new Rational(43, 48),
                new Rational(5, 121),
                new Rational(2014, 59)
            };
            foreach (var r in rs) {
                Console.WriteLine(""{0} => {1}"", r, FormatList(Egyptian(r)));
            }
 
            var lenMax = Tuple.Create(0UL, new Rational(0));
            var denomMax = Tuple.Create(BigInteger.Zero, new Rational(0));
 
            var query = (from i in Enumerable.Range(1, 100)
                         from j in Enumerable.Range(1, 100)
                         select new Rational(i, j))
                         .Distinct()
                         .ToList();
            foreach (var r in query) {
                var e = Egyptian(r);
                ulong eLen = (ulong) e.Count;
                var eDenom = e.Last().Den;
                if (eLen > lenMax.Item1) {
                    lenMax = Tuple.Create(eLen, r);
                }
                if (eDenom > denomMax.Item1) {
                    denomMax = Tuple.Create(eDenom, r);
                }
            }
 
            Console.WriteLine(""Term max is {0} with {1} terms"", lenMax.Item2, lenMax.Item1);
            var dStr = denomMax.Item1.ToString();
            Console.WriteLine(""Denominator max is {0} with {1} digits {2}...{3}"", denomMax.Item2, dStr.Length, dStr.Substring(0, 5), dStr.Substring(dStr.Length - 5, 5));
        }
    }
}",4713,148
60266,http://rosettacode.org/wiki/Egyptian_division,Egyptian division,"Egyptian division is a method of dividing integers using addition and
doubling that is similar to the algorithm of Ethiopian multiplication

Algorithm:

Given two numbers where the dividend is to be divided by the divisor:

 Start the construction of a table of two columns: powers_of_2, and doublings; by a first row of a 1 (i.e. 2^0) in the first column and 1 times the divisor in the first row second column.
 Create the second row with columns of 2 (i.e 2^1), and 2 * divisor in order.
 Continue with successive i’th rows of 2^i and 2^i * divisor.
 Stop adding rows, and keep only those rows, where 2^i * divisor is less than or equal to the dividend.
 We now assemble two separate sums that both start as zero, called here answer and accumulator
 Consider each row of the table, in the reverse order of its construction.
 If the current value of the accumulator added to the doublings cell would be less than or equal to the dividend then add it to the accumulator, as well as adding the powers_of_2 cell value to the answer.
 When the first row has been considered as above, then the integer division of dividend by divisor is given by answer.
 (And the remainder is given by the absolute value of accumulator - dividend).


Example: 580 / 34

 Table creation: 



 powers_of_2

 doublings


 1

 34


 2

 68


 4

 136


 8

 272


 16

 544

 Initialization of sums: 



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272






 16

 544










 0

 0

 Considering table rows, bottom-up: 

When a row is considered it is shown crossed out if it is not accumulated, or bold if the row causes summations.



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272






 16

 544

 16

 544



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272

 16

 544


 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136

 16

 544


 8

 272






 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68

 16

 544


 4

 136






 8

 272






 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34

 17

 578


 2

 68






 4

 136






 8

 272






 16

 544





Answer

So 580 divided by 34 using the Egyptian method is 17 remainder (578 - 580) or 2.



Task

The task is to create a function that does Egyptian division. The function should

closely follow the description above in using a list/array of powers of two, and

another of doublings.

 Functions should be clear interpretations of the algorithm.
 Use the function to divide 580 by 34 and show the answer here, on this page.


Related tasks

   Egyptian fractions


References

   Egyptian Number System

",#C.23,C#," 
using System;
using System.Collections;
 
namespace Egyptian_division
{
	class Program
	{
		public static void Main(string[] args)
		{
			Console.Clear();
			Console.WriteLine();
			Console.WriteLine("" Egyptian division "");
			Console.WriteLine();
			Console.Write("" Enter value of dividend : "");
			int dividend = int.Parse(Console.ReadLine());
 
			Console.Write("" Enter value of divisor : "");
			int divisor = int.Parse(Console.ReadLine());
 
			Divide(dividend, divisor);
 
			Console.WriteLine();
			Console.Write(""Press any key to continue . . . "");
			Console.ReadKey(true);
 
 
 
		}
 
		static void Divide(int dividend, int divisor)
		{
			//
			// Local variable declaration and initialization
			//
			int result   = 0;
			int reminder = 0;
 
			int powers_of_two = 0;
			int doublings 	  = 0;
 
			int answer 	= 0;
			int accumulator = 0;
 
			int two = 2;
			int pow = 0;
			int row = 0;
 
			//
			// Tables declaration
			//
			ArrayList table_powers_of_two = new ArrayList();
			ArrayList table_doublings     = new ArrayList();
 
			//
			// Fill and Show table values
			//
			Console.WriteLine(""                           "");
			Console.WriteLine("" powers_of_2     doublings "");
			Console.WriteLine(""                           "");
 
			// Set initial values
			powers_of_two = 1;
			doublings = divisor;
			while( doublings <= dividend )
			{
				// Set table value
				table_powers_of_two.Add( powers_of_two );
				table_doublings.Add( doublings );
 
				// Show new table row
				Console.WriteLine(""{0,8}{1,16}"",powers_of_two, doublings);
 
 
				pow++;
 
				powers_of_two = (int)Math.Pow( two, pow );
				doublings = powers_of_two * divisor;
			}
			Console.WriteLine(""                           "");
 
			//
			// Calculate division and Show table values
			//
			row = pow - 1;
			Console.WriteLine(""                                                 "");
			Console.WriteLine("" powers_of_2     doublings   answer   accumulator"");
			Console.WriteLine(""                                                 "");
			Console.SetCursorPosition(Console.CursorLeft, Console.CursorTop + row);
 
			pow--;
			while( pow >= 0 && accumulator < dividend )
			{
				// Get values from tables
				doublings = int.Parse(table_doublings[pow].ToString());
				powers_of_two = int.Parse(table_powers_of_two[pow].ToString());
 
				if(accumulator + int.Parse(table_doublings[pow].ToString()) <= dividend )
				{
					// Set new values
					accumulator += doublings;
					answer += powers_of_two;
 
					// Show accumulated row values in different collor
					Console.ForegroundColor = ConsoleColor.Green;
					Console.Write(""{0,8}{1,16}"",powers_of_two, doublings);
					Console.ForegroundColor = ConsoleColor.Green;
					Console.WriteLine(""{0,10}{1,12}"", answer, accumulator);
					Console.SetCursorPosition(Console.CursorLeft, Console.CursorTop - 2);
				}
				else
				{
					// Show not accumulated row walues
					Console.ForegroundColor = ConsoleColor.DarkGray;
					Console.Write(""{0,8}{1,16}"",powers_of_two, doublings);
					Console.ForegroundColor = ConsoleColor.Gray;
					Console.WriteLine(""{0,10}{1,12}"", answer, accumulator);
					Console.SetCursorPosition(Console.CursorLeft, Console.CursorTop - 2);
				}
 
 
				pow--;
			}
 
			Console.WriteLine();
			Console.SetCursorPosition(Console.CursorLeft, Console.CursorTop + row + 2);
			Console.ResetColor();
 
			// Set result and reminder
			result = answer;
			if( accumulator < dividend )
			{
				reminder = dividend - accumulator;
 
				Console.WriteLine("" So "" + dividend +
				                  "" divided by "" + divisor +
				                  "" using the Egyptian method is \n "" + result +
				                  "" remainder ("" + dividend + "" - "" + accumulator +
				                  "") or "" + reminder);
				Console.WriteLine();
			}
			else
			{
				reminder = 0;
 
				Console.WriteLine("" So "" + dividend +
				                  "" divided by "" + divisor +
				                  "" using the Egyptian method is \n "" + result +
				                  "" remainder "" + reminder);
				Console.WriteLine();
			}
		}
	}
}
 ",4086,155
60306,http://rosettacode.org/wiki/Dynamic_variable_names,Dynamic variable names,"Task

Create a variable with a user-defined name.

The variable name should not be written in the program text, but should be taken from the user dynamically.



See also
   Eval in environment is a similar task.

",#C.23,C#,"using System;
using System.Dynamic;
using System.Collections.Generic;
 
public class Program
{
    public static void Main()
    {
        string varname = Console.ReadLine();
        //Let's pretend the user has entered ""foo""
        dynamic expando = new ExpandoObject();
        var map = expando as IDictionary<string, object>;
        map.Add(varname, ""Hello world!"");
 
        Console.WriteLine(expando.foo);
    }
}",423,17
60341,http://rosettacode.org/wiki/Eban_numbers,Eban numbers,"

Definition

An   eban   number is a number that has no letter    e    in it when the number is spelled in English.

Or more literally,   spelled numbers that contain the letter   e   are banned.



The American version of spelling numbers will be used here   (as opposed to the British).

2,000,000,000   is two billion,   not   two milliard.



Only numbers less than   one sextillion   (1021)   will be considered in/for this task.

This will allow optimizations to be used.



Task

   show all eban numbers   ≤   1,000   (in a horizontal format),   and a count
   show all eban numbers between   1,000   and   4,000   (inclusive),   and a count
   show a count of all eban numbers up and including           10,000
   show a count of all eban numbers up and including         100,000
   show a count of all eban numbers up and including      1,000,000
   show a count of all eban numbers up and including    10,000,000
   show all output here.


See also

   The MathWorld entry:   eban numbers.
   The OEIS entry:   A6933, eban numbers.

",#C.23,C#,"using System;
 
namespace EbanNumbers {
    struct Interval {
        public int start, end;
        public bool print;
 
        public Interval(int start, int end, bool print) {
            this.start = start;
            this.end = end;
            this.print = print;
        }
    }
 
    class Program {
        static void Main() {
            Interval[] intervals = {
                new Interval(2, 1_000, true),
                new Interval(1_000, 4_000, true),
                new Interval(2, 10_000, false),
                new Interval(2, 100_000, false),
                new Interval(2, 1_000_000, false),
                new Interval(2, 10_000_000, false),
                new Interval(2, 100_000_000, false),
                new Interval(2, 1_000_000_000, false),
            };
            foreach (var intv in intervals) {
                if (intv.start == 2) {
                    Console.WriteLine(""eban numbers up to and including {0}:"", intv.end);
                } else {
                    Console.WriteLine(""eban numbers between {0} and {1} (inclusive):"", intv.start, intv.end);
                }
 
                int count = 0;
                for (int i = intv.start; i <= intv.end; i += 2) {
                    int b = i / 1_000_000_000;
                    int r = i % 1_000_000_000;
                    int m = r / 1_000_000;
                    r = i % 1_000_000;
                    int t = r / 1_000;
                    r %= 1_000;
                    if (m >= 30 && m <= 66) m %= 10;
                    if (t >= 30 && t <= 66) t %= 10;
                    if (r >= 30 && r <= 66) r %= 10;
                    if (b == 0 || b == 2 || b == 4 || b == 6) {
                        if (m == 0 || m == 2 || m == 4 || m == 6) {
                            if (t == 0 || t == 2 || t == 4 || t == 6) {
                                if (r == 0 || r == 2 || r == 4 || r == 6) {
                                    if (intv.print) Console.Write(""{0} "", i);
                                    count++;
                                }
                            }
                        }
                    }
                }
                if (intv.print) {
                    Console.WriteLine();
                }
                Console.WriteLine(""count = {0}\n"", count);
            }
        }
    }
}",2344,63
60494,http://rosettacode.org/wiki/Draw_a_rotating_cube,Draw a rotating cube,"Task
Draw a rotating cube.

It should be oriented with one vertex pointing straight up, and its opposite vertex on the main diagonal (the one farthest away) straight down. It can be solid or wire-frame, and you can use ASCII art if your language doesn't have graphical capabilities. Perspective is optional.




Related tasks
 Draw a cuboid
 write language name in 3D ASCII

",#C.23,C#,"using System;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Windows.Forms;
using System.Windows.Threading;
 
namespace RotatingCube
{
    public partial class Form1 : Form
    {
        double[][] nodes = {
            new double[] {-1, -1, -1}, new double[] {-1, -1, 1}, new double[] {-1, 1, -1},
            new double[] {-1, 1, 1}, new double[] {1, -1, -1}, new double[] {1, -1, 1},
            new double[] {1, 1, -1}, new double[] {1, 1, 1} };
 
        int[][] edges = {
            new int[] {0, 1}, new int[] {1, 3}, new int[] {3, 2}, new int[] {2, 0}, new int[] {4, 5},
            new int[] {5, 7}, new int[] {7, 6}, new int[] {6, 4}, new int[] {0, 4}, new int[] {1, 5},
            new int[] {2, 6}, new int[] {3, 7}};
 
        public Form1()
        {
            Width = Height = 640;
            StartPosition = FormStartPosition.CenterScreen;
            SetStyle(
                ControlStyles.AllPaintingInWmPaint |
                ControlStyles.UserPaint |
                ControlStyles.DoubleBuffer,
                true);
 
            Scale(100, 100, 100);
            RotateCuboid(Math.PI / 4, Math.Atan(Math.Sqrt(2)));
 
            var timer = new DispatcherTimer();
            timer.Tick += (s, e) => { RotateCuboid(Math.PI / 180, 0); Refresh(); };
            timer.Interval = new TimeSpan(0, 0, 0, 0, 17);
            timer.Start();
        }
 
        private void RotateCuboid(double angleX, double angleY)
        {
            double sinX = Math.Sin(angleX);
            double cosX = Math.Cos(angleX);
 
            double sinY = Math.Sin(angleY);
            double cosY = Math.Cos(angleY);
 
            foreach (var node in nodes)
            {
                double x = node[0];
                double y = node[1];
                double z = node[2];
 
                node[0] = x * cosX - z * sinX;
                node[2] = z * cosX + x * sinX;
 
                z = node[2];
 
                node[1] = y * cosY - z * sinY;
                node[2] = z * cosY + y * sinY;
            }
        }
 
        private void Scale(int v1, int v2, int v3)
        {
            foreach (var item in nodes)
            {
                item[0] *= v1;
                item[1] *= v2;
                item[2] *= v3;
            }
        }
 
        protected override void OnPaint(PaintEventArgs args)
        {
            var g = args.Graphics;
            g.SmoothingMode = SmoothingMode.HighQuality;
            g.Clear(Color.White);
 
            g.TranslateTransform(Width / 2, Height / 2);
 
            foreach (var edge in edges)
            {
                double[] xy1 = nodes[edge[0]];
                double[] xy2 = nodes[edge[1]];
                g.DrawLine(Pens.Black, (int)Math.Round(xy1[0]), (int)Math.Round(xy1[1]),
                        (int)Math.Round(xy2[0]), (int)Math.Round(xy2[1]));
            }
 
            foreach (var node in nodes)
            {
                g.FillEllipse(Brushes.Black, (int)Math.Round(node[0]) - 4,
                    (int)Math.Round(node[1]) - 4, 8, 8);
            }
        }
    }
}",3097,97
60581,http://rosettacode.org/wiki/Doubly-linked_list/Element_insertion,Doubly-linked list/Element insertion,"Doubly-Linked List (element)
This is much like inserting into a Singly-Linked List, but with added assignments so that the backwards-pointing links remain correct.

See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack",#C.23,C#,"static void InsertAfter(Link prev, int i)
{
    if (prev.next != null)
    {
        prev.next.prev = new Link() { item = i, prev = prev, next = prev.next };
        prev.next = prev.next.prev;
    }
    else
        prev.next = new Link() { item = i, prev = prev };
}",268,10
60657,http://rosettacode.org/wiki/Doubly-linked_list/Traversal,Doubly-linked list/Traversal,"Traverse from the beginning of a doubly-linked list to the end, and from the end to the beginning.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace RosettaCode.DoublyLinkedList
{
    internal static class Program
    {
        private static void Main()
        {
            var list = new LinkedList<char>(""hello"");
 
            var current = list.First;
            do
            {
                Console.WriteLine(current.Value);
            } while ((current = current.Next) != null);
 
            Console.WriteLine();
 
            current = list.Last;
            do
            {
                Console.WriteLine(current.Value);
            } while ((current = current.Previous) != null);
        }
    }
}",631,27
60706,http://rosettacode.org/wiki/Doubly-linked_list/Element_definition,Doubly-linked list/Element definition,"Task

Define the data structure for a doubly-linked list element.

The element should include a data member to hold its value and pointers to both the next element in the list and the previous element in the list.

The pointers should be mutable.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#C.23,C#,"class Link
{
    public int Item { get; set; }
    public Link Prev { get; set; }
    public Link Next { get; set; }
 
    //A constructor is not neccessary, but could be useful
    public Link(int item, Link prev = null, Link next = null) {
        Item = item;
        Prev = prev;
        Next = next;
    }
}",312,13
60736,http://rosettacode.org/wiki/Draw_a_cuboid,Draw a cuboid,"Task

Draw a   cuboid   with relative dimensions of    2 × 3 × 4. 



The cuboid can be represented graphically, or in   ASCII art,   depending on the language capabilities.

To fulfill the criteria of being a cuboid, three faces must be visible.

Either static or rotational projection is acceptable for this task.



Related tasks
 draw a sphere
 draw a rotating cube
 write language name in 3D ASCII
 draw a Deathstar

",#C.23,C#,"using System;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Windows.Forms;
 
namespace Cuboid
{
    public partial class Form1 : Form
    {
        double[][] nodes = {
            new double[] {-1, -1, -1}, new double[] {-1, -1, 1}, new double[] {-1, 1, -1},
            new double[] {-1, 1, 1}, new double[] {1, -1, -1}, new double[] {1, -1, 1},
            new double[] {1, 1, -1}, new double[] {1, 1, 1} };
 
        int[][] edges = {
            new int[] {0, 1}, new int[] {1, 3}, new int[] {3, 2}, new int[] {2, 0}, new int[] {4, 5},
            new int[] {5, 7}, new int[] {7, 6}, new int[] {6, 4}, new int[] {0, 4}, new int[] {1, 5},
            new int[] {2, 6}, new int[] {3, 7}};
 
        private int mouseX;
        private int prevMouseX;
        private int prevMouseY;
        private int mouseY;
 
        public Form1()
        {
            Width = Height = 640;
            StartPosition = FormStartPosition.CenterScreen;
            SetStyle(
                ControlStyles.AllPaintingInWmPaint |
                ControlStyles.UserPaint |
                ControlStyles.DoubleBuffer,
                true);
 
            MouseMove += (s, e) =>
            {
                prevMouseX = mouseX;
                prevMouseY = mouseY;
                mouseX = e.X;
                mouseY = e.Y;
 
                double incrX = (mouseX - prevMouseX) * 0.01;
                double incrY = (mouseY - prevMouseY) * 0.01;
 
                RotateCuboid(incrX, incrY);
                Refresh();
            };
 
            MouseDown += (s, e) =>
            {
                mouseX = e.X;
                mouseY = e.Y;
            };
 
            Scale(80, 120, 160);
            RotateCuboid(Math.PI / 5, Math.PI / 9);
        }
 
        private void RotateCuboid(double angleX, double angleY)
        {
            double sinX = Math.Sin(angleX);
            double cosX = Math.Cos(angleX);
 
            double sinY = Math.Sin(angleY);
            double cosY = Math.Cos(angleY);
 
            foreach (var node in nodes)
            {
                double x = node[0];
                double y = node[1];
                double z = node[2];
 
                node[0] = x * cosX - z * sinX;
                node[2] = z * cosX + x * sinX;
 
                z = node[2];
 
                node[1] = y * cosY - z * sinY;
                node[2] = z * cosY + y * sinY;
            }
        }
 
        private void Scale(int v1, int v2, int v3)
        {
            foreach (var item in nodes)
            {
                item[0] *= v1;
                item[1] *= v2;
                item[2] *= v3;
            }
        }
 
        protected override void OnPaint(PaintEventArgs args)
        {
            var g = args.Graphics;
            g.SmoothingMode = SmoothingMode.HighQuality;
            g.Clear(Color.White);
 
            g.TranslateTransform(Width / 2, Height / 2);
 
            foreach (var edge in edges)
            {
                double[] xy1 = nodes[edge[0]];
                double[] xy2 = nodes[edge[1]];
                g.DrawLine(Pens.Black, (int)Math.Round(xy1[0]), (int)Math.Round(xy1[1]),
                        (int)Math.Round(xy2[0]), (int)Math.Round(xy2[1]));
            }
 
            foreach (var node in nodes)
            {
                g.FillEllipse(Brushes.Black, (int)Math.Round(node[0]) - 4,
                    (int)Math.Round(node[1]) - 4, 8, 8);
            }
        }
    }
}",3472,116
60835,http://rosettacode.org/wiki/Draw_a_sphere,Draw a sphere,"Task

Draw a sphere.

The sphere can be represented graphically, or in ASCII art, depending on the language capabilities.

Either static or rotational projection is acceptable for this task.



Related tasks

 draw a cuboid
 draw a rotating cube
 write language name in 3D ASCII
 draw a Deathstar

",#C.23,C#,"using System;
 
namespace Sphere {
    internal class Program {
        private const string Shades = "".:!*oe%&#@"";
        private static readonly double[] Light = {30, 30, -50};
 
        private static void Normalize(double[] v) {
            double len = Math.Sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
            v[0] /= len;
            v[1] /= len;
            v[2] /= len;
        }
 
        private static double Dot(double[] x, double[] y) {
            double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];
            return d < 0 ? -d : 0;
        }
 
        public static void DrawSphere(double r, double k, double ambient) {
            var vec = new double[3];
            for(var i = (int)Math.Floor(-r); i <= (int)Math.Ceiling(r); i++) {
                double x = i + .5;
                for(var j = (int)Math.Floor(-2*r); j <= (int)Math.Ceiling(2*r); j++) {
                    double y = j/2.0 + .5;
                    if(x*x + y*y <= r*r) {
                        vec[0] = x;
                        vec[1] = y;
                        vec[2] = Math.Sqrt(r*r - x*x - y*y);
                        Normalize(vec);
                        double b = Math.Pow(Dot(Light, vec), k) + ambient;
                        int intensity = (b <= 0)
                                            ? Shades.Length - 2
                                            : (int)Math.Max((1 - b)*(Shades.Length - 1), 0);
                        Console.Write(Shades[intensity]);
                    }
                    else
                        Console.Write(' ');
                }
                Console.WriteLine();
            }
        }
 
        private static void Main() {
            Normalize(Light);
            DrawSphere(6, 4, .1);
            DrawSphere(10, 2, .4);
            Console.ReadKey();
        }
    }
}",1825,51
60940,http://rosettacode.org/wiki/Draw_a_clock,Draw a clock,"Task

Draw a clock.



More specific:

 Draw a time keeping device. It can be a stopwatch, hourglass, sundial, a mouth counting ""one thousand and one"", anything. Only showing the seconds is required, e.g.: a watch with just a second hand will suffice. However, it must clearly change every second, and the change must cycle every so often (one minute, 30 seconds, etc.) It must be drawn; printing a string of numbers to your terminal doesn't qualify. Both text-based and graphical drawing are OK.
 The clock is unlikely to be used to control space flights, so it needs not be hyper-accurate, but it should be usable, meaning if one can read the seconds off the clock, it must agree with the system clock.
 A clock is rarely (never?) a major application: don't be a CPU hog and poll the system timer every microsecond, use a proper timer/signal/event from your system or language instead. For a bad example, many OpenGL programs update the frame-buffer in a busy loop even if no redraw is needed, which is very undesirable for this task.
 A clock is rarely (never?) a major application: try to keep your code simple and to the point. Don't write something too elaborate or convoluted, instead do whatever is natural, concise and clear in your language.


Key points
 animate simple object
 timed event 
 polling system resources 
 code clarity

",#C.23,C#,"using System;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Windows.Forms;
 
public class Clock : Form
{
    static readonly float degrees06 = (float)Math.PI / 30;
    static readonly float degrees30 = degrees06 * 5;
    static readonly float degrees90 = degrees30 * 3;
 
    readonly int margin = 20;
 
    private Point p0;
 
    public Clock()
    {
        Size = new Size(500, 500);
        StartPosition = FormStartPosition.CenterScreen;
        Resize += (sender, args) => ResetSize();
        ResetSize();
        var timer = new Timer() { Interval = 1000, Enabled = true };
        timer.Tick += (sender, e) => Refresh();
        DoubleBuffered = true;
    }
 
    private void ResetSize()
    {
        p0 = new Point(ClientRectangle.Width / 2, ClientRectangle.Height / 2);
        Refresh();
    }
 
    protected override void OnPaint(PaintEventArgs e)
    {
        base.OnPaint(e);
        e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;
 
        drawFace(e.Graphics);
 
        var time = DateTime.Now;
        int second = time.Second;
        int minute = time.Minute;
        int hour = time.Hour;
 
        float angle = degrees90 - (degrees06 * second);
        DrawHand(e.Graphics, Pens.Red, angle, 0.95);
 
        float minsecs = (minute + second / 60.0F);
        angle = degrees90 - (degrees06 * minsecs);
        DrawHand(e.Graphics, Pens.Black, angle, 0.9);
 
        float hourmins = (hour + minsecs / 60.0F);
        angle = degrees90 - (degrees30 * hourmins);
        DrawHand(e.Graphics, Pens.Black, angle, 0.6);
    }
 
    private void drawFace(Graphics g)
    {
        int radius = Math.Min(p0.X, p0.Y) - margin;
        g.FillEllipse(Brushes.White, p0.X - radius, p0.Y - radius, radius * 2, radius * 2);
 
        for (int h = 0; h < 12; h++)
            DrawHand(g, Pens.LightGray, h * degrees30, -0.05);
 
        for (int m = 0; m < 60; m++)
            DrawHand(g, Pens.LightGray, m * degrees06, -0.025);
    }
 
    private void DrawHand(Graphics g, Pen pen, float angle, double size)
    {
        int radius = Math.Min(p0.X, p0.Y) - margin;
 
        int x0 = p0.X + (size > 0 ? 0 : Convert.ToInt32(radius * (1 + size) * Math.Cos(angle)));
        int y0 = p0.Y + (size > 0 ? 0 : Convert.ToInt32(radius * (1 + size) * Math.Sin(-angle)));
 
        int x1 = p0.X + Convert.ToInt32(radius * (size > 0 ? size : 1) * Math.Cos(angle));
        int y1 = p0.Y + Convert.ToInt32(radius * (size > 0 ? size : 1) * Math.Sin(-angle));
 
        g.DrawLine(pen, x0, y0, x1, y1);
    }
 
    [STAThread]
    static void Main()
    {
        Application.Run(new Clock());
    }
}",2633,87
61062,http://rosettacode.org/wiki/Dragon_curve,Dragon curve,"

Create and display a dragon curve fractal.

(You may either display the curve directly or write it to an image file.)



Algorithms
Here are some brief notes the algorithms used and how they might suit various languages.

 Recursively a right curling dragon is a right dragon followed by a left dragon, at 90-degree angle. And a left dragon is a left followed by a right.
*---R----*     expands to     *       *
                               \     /
                                R   L
                                 \ /
                                  *

                                  *
                                 / \
                                L   R
                               /     \
*---L---*      expands to     *       *
 The co-routines dcl and dcr in various examples do this recursively to a desired expansion level.
 The curl direction right or left can be a parameter instead of two separate routines.
 Recursively, a curl direction can be eliminated by noting the dragon consists of two copies of itself drawn towards a central point at 45-degrees.
*------->*   becomes    *       *     Recursive copies drawn
                         \     /      from the ends towards
                          \   /       the centre.
                           v v
                            *
 This can be seen in the SVG example. This is best suited to off-line drawing since the reversal in the second half means the drawing jumps backward and forward (in binary reflected Gray code order) which is not very good for a plotter or for drawing progressively on screen.
 Successive approximation repeatedly re-writes each straight line as two new segments at a right angle,
                       *       
*-----*   becomes     / \      bend to left
                     /   \     if N odd
                    *     *

                    *     *   
*-----*   becomes    \   /     bend to right  
                      \ /      if N even 
                       *
 Numbering from the start of the curve built so far, if the segment is at an odd position then the bend introduced is on the right side. If the segment is an even position then on the left. The process is then repeated on the new doubled list of segments. This constructs a full set of line segments before any drawing.
 The effect of the splitting is a kind of bottom-up version of the recursions. See the Asymptote example for code doing this.
 Iteratively the curve always turns 90-degrees left or right at each point. The direction of the turn is given by the bit above the lowest 1-bit of n. Some bit-twiddling can extract that efficiently.
n = 1010110000
        ^
        bit above lowest 1-bit, turn left or right as 0 or 1

LowMask = n BITXOR (n-1)   # eg. giving 0000011111
AboveMask = LowMask + 1    # eg. giving 0000100000
BitAboveLowestOne = n BITAND AboveMask
 The first turn is at n=1, so reckon the curve starting at the origin as n=0 then a straight line segment to position n=1 and turn there.
 If you prefer to reckon the first turn as n=0 then take the bit above the lowest 0-bit instead. This works because ""...10000"" minus 1 is ""...01111"" so the lowest 0 in n-1 is where the lowest 1 in n is.
 Going by turns suits turtle graphics such as Logo or a plotter drawing with a pen and current direction.
 If a language doesn't maintain a ""current direction"" for drawing then you can always keep that separately and apply turns by bit-above-lowest-1.
 Absolute direction to move at point n can be calculated by the number of bit-transitions in n.
n = 11 00 1111 0 1
      ^  ^    ^ ^     4 places where change bit value
                      so direction=4*90degrees=East
 This can be calculated by counting the number of 1 bits in ""n XOR (n RIGHTSHIFT 1)"" since such a shift and xor leaves a single 1 bit at each position where two adjacent bits differ.
 Absolute X,Y coordinates of a point n can be calculated in complex numbers by some powers (i+1)^k and add/subtract/rotate. This is done in the gnuplot code. This might suit things similar to Gnuplot which want to calculate each point independently.
 Predicate test for whether a given X,Y point or segment is on the curve can be done. This might suit line-by-line output rather than building an entire image before printing. See M4 for an example of this.
 A predicate works by dividing out complex number i+1 until reaching the origin, so it takes roughly a bit at a time from X and Y is thus quite efficient. Why it works is slightly subtle but the calculation is not difficult. (Check segment by applying an offset to move X,Y to an ""even"" position before dividing i+1. Check vertex by whether the segment either East or West is on the curve.)
 The number of steps in the predicate corresponds to doublings of the curve, so stopping the check at say 8 steps can limit the curve drawn to 2^8=256 points. The offsets arising in the predicate are bits of n the segment number, so can note those bits to calculate n and limit to an arbitrary desired length or sub-section.
 As a Lindenmayer system of expansions. The simplest is two symbols F and S both straight lines, as used by the PGF code.
Axiom F, angle 90 degrees
F -> F+S
S -> F-S
This always has F at even positions and S at odd. Eg. after 3 levels F_S_F_S_F_S_F_S. The +/- turns in between bend to the left or right the same as the ""successive approximation"" method above. Read more at for instance Joel Castellanos' L-system page.

Variations are possible if you have only a single symbol for line draw, for example the Icon and Unicon and Xfractint code. The angles can also be broken into 45-degree parts to keep the expansion in a single direction rather than the endpoint rotating around.

The string rewrites can be done recursively without building the whole string, just follow its instructions at the target level. See for example C by IFS Drawing code. The effect is the same as ""recursive with parameter"" above but can draw other curves defined by L-systems. 


",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Windows.Forms;
 
public class DragonCurve : Form
{
    private List<int> turns;
    private double startingAngle, side;
 
    public DragonCurve(int iter)
    {
        Size = new Size(800, 600);
        StartPosition = FormStartPosition.CenterScreen;
        DoubleBuffered = true;
        BackColor = Color.White;
 
        startingAngle = -iter * (Math.PI / 4);
        side = 400 / Math.Pow(2, iter / 2.0);
 
        turns = getSequence(iter);
    }
 
    private List<int> getSequence(int iter)
    {
        var turnSequence = new List<int>();
        for (int i = 0; i < iter; i++)
        {
            var copy = new List<int>(turnSequence);
            copy.Reverse();
            turnSequence.Add(1);
            foreach (int turn in copy)
            {
                turnSequence.Add(-turn);
            }
        }
        return turnSequence;
    }
 
    protected override void OnPaint(PaintEventArgs e)
    {
        base.OnPaint(e);
        e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;
 
        double angle = startingAngle;
        int x1 = 230, y1 = 350;
        int x2 = x1 + (int)(Math.Cos(angle) * side);
        int y2 = y1 + (int)(Math.Sin(angle) * side);
        e.Graphics.DrawLine(Pens.Black, x1, y1, x2, y2);
        x1 = x2;
        y1 = y2;
        foreach (int turn in turns)
        {
            angle += turn * (Math.PI / 2);
            x2 = x1 + (int)(Math.Cos(angle) * side);
            y2 = y1 + (int)(Math.Sin(angle) * side);
            e.Graphics.DrawLine(Pens.Black, x1, y1, x2, y2);
            x1 = x2;
            y1 = y2;
        }
    }
 
    [STAThread]
    static void Main()
    {
        Application.Run(new DragonCurve(14));
    }
}",1810,69
61249,http://rosettacode.org/wiki/Documentation,Documentation,"

See also

 Related task: Comments
 Related task: Here_document

",#C.23,C#,"/// <summary>
/// The XMLSystem class is here to help handle XML items in this site.
/// </summary>
public static class XMLSystem
{
    static XMLSystem()
    {
        // Constructor
    }
 
    /// <summary>
    /// A function to get the contents of an XML document.
    /// </summary>
    /// <param name=""name"">A valid name of an XML document in the data folder</param>
    /// <returns>An XmlDocument containing the contents of the XML file</returns>
    public static XmlDocument GetXML(string name) 
    {
        return null;
    }
}",541,20
61257,http://rosettacode.org/wiki/Display_a_linear_combination,Display a linear combination,"Task

Display a finite linear combination in an infinite vector basis 



(

e

1


,

e

2


,
…
)


{\displaystyle (e_{1},e_{2},\ldots )}

.

Write a function that, when given a finite list of scalars 



(

α

1


,

α

2


,
…
)


{\displaystyle (\alpha ^{1},\alpha ^{2},\ldots )}

, 
creates a string representing the linear combination 




∑

i



α

i



e

i




{\displaystyle \sum _{i}\alpha ^{i}e_{i}}

 in an explicit format often used in mathematics, that is:






α


i

1





e


i

1




±

|


α


i

2





|


e


i

2




±

|


α


i

3





|


e


i

3




±
…


{\displaystyle \alpha ^{i_{1}}e_{i_{1}}\pm |\alpha ^{i_{2}}|e_{i_{2}}\pm |\alpha ^{i_{3}}|e_{i_{3}}\pm \ldots }


where 




α


i

k




≠
0


{\displaystyle \alpha ^{i_{k}}\neq 0}







The output must comply to the following rules:

   don't show null terms, unless the whole combination is null. 
 e(1)     is fine,     e(1) + 0*e(3)     or     e(1) + 0     is wrong.
   don't show scalars when they are equal to one or minus one. 
 e(3)     is fine,     1*e(3)     is wrong.
   don't prefix by a minus sign if it follows a preceding term.   Instead you use subtraction. 
 e(4) - e(5)     is fine,     e(4) + -e(5)     is wrong.


Show here output for the following lists of scalars:

 1)    1,  2,  3
 2)    0,  1,  2,  3
 3)    1,  0,  3,  4
 4)    1,  2,  0
 5)    0,  0,  0
 6)    0
 7)    1,  1,  1
 8)   -1, -1, -1
 9)   -1, -2,  0, -3
10)   -1


",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Text;
 
namespace DisplayLinearCombination {
    class Program {
        static string LinearCombo(List<int> c) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < c.Count; i++) {
                int n = c[i];
                if (n < 0) {
                    if (sb.Length == 0) {
                        sb.Append('-');
                    } else {
                        sb.Append("" - "");
                    }
                } else if (n > 0) {
                    if (sb.Length != 0) {
                        sb.Append("" + "");
                    }
                } else {
                    continue;
                }
 
                int av = Math.Abs(n);
                if (av != 1) {
                    sb.AppendFormat(""{0}*"", av);
                }
                sb.AppendFormat(""e({0})"", i + 1);
            }
            if (sb.Length == 0) {
                sb.Append('0');
            }
            return sb.ToString();
        }
 
        static void Main(string[] args) {
            List<List<int>> combos = new List<List<int>>{
                new List<int> { 1, 2, 3},
                new List<int> { 0, 1, 2, 3},
                new List<int> { 1, 0, 3, 4},
                new List<int> { 1, 2, 0},
                new List<int> { 0, 0, 0},
                new List<int> { 0},
                new List<int> { 1, 1, 1},
                new List<int> { -1, -1, -1},
                new List<int> { -1, -2, 0, -3},
                new List<int> { -1},
            };
 
            foreach (List<int> c in combos) {
                var arr = ""["" + string.Join("", "", c) + ""]"";
                Console.WriteLine(""{0,15} -> {1}"", arr, LinearCombo(c));
            }
        }
    }
}",1803,57
61260,http://rosettacode.org/wiki/Diversity_prediction_theorem,Diversity prediction theorem,"The   wisdom of the crowd   is the collective opinion of a group of individuals rather than that of a single expert.

Wisdom-of-the-crowds research routinely attributes the superiority of crowd averages over individual judgments to the elimination of individual noise,   an explanation that assumes independence of the individual judgments from each other.

Thus the crowd tends to make its best decisions if it is made up of diverse opinions and ideologies.



Scott E. Page introduced the diversity prediction theorem:

 The squared error of the collective prediction equals the average squared error minus the predictive diversity. 


Therefore,   when the diversity in a group is large,   the error of the crowd is small.



Definitions

   Average Individual Error:   Average of the individual squared errors
   Collective Error:   Squared error of the collective prediction
   Prediction Diversity:   Average squared distance from the individual predictions to the collective prediction
   Diversity Prediction Theorem:   Given a crowd of predictive models,     then
   Collective Error   =   Average Individual Error   ─   Prediction Diversity
Task

For a given   true   value and a number of number of estimates (from a crowd),   show   (here on this page):

   the true value   and   the crowd estimates
   the average error
   the crowd error
   the prediction diversity


Use   (at least)   these two examples:

   a true value of   49   with crowd estimates of:    48   47   51
   a true value of   49   with crowd estimates of:    48   47   51   42


Also see

   Wikipedia entry:   Wisdom of the crowd
   University of Michigan: PDF paper         (exists on a web archive,   the Wayback Machine).

",#C.23,C#," 
using System;
using System.Linq;
using System.Collections.Generic;
 
public class MainClass {
    static double Square(double x) => x * x;
 
    static double AverageSquareDiff(double a, IEnumerable<double> predictions)
        => predictions.Select(x => Square(x - a)).Average();
 
    static void DiversityTheorem(double truth, IEnumerable<double> predictions)
    {
        var average = predictions.Average();
        Console.WriteLine($@""average-error: {AverageSquareDiff(truth, predictions)}
crowd-error: {Square(truth - average)}
diversity: {AverageSquareDiff(average, predictions)}"");
    }
 
    public static void Main() {
	DiversityTheorem(49, new []{48d,47,51});
    	DiversityTheorem(49, new []{48d,47,51,42});
    }
}",733,24
61264,http://rosettacode.org/wiki/Distributed_programming,Distributed programming,"Write two programs (or one program with two modes) which run on networked computers, and send some messages between them.

The protocol used may be language-specific or not, and should be suitable for general distributed programming; that is, the protocol should be generic (not designed just for the particular example application), readily capable of handling the independent communications of many different components of a single application, and the transferring of arbitrary data structures natural for the language.

This task is intended to demonstrate high-level communication facilities beyond just creating sockets.
",#C.23,C#," 
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Runtime.Serialization.Formatters.Binary;
using System.Threading.Tasks;
 
using static System.Console;
 
class DistributedProgramming
{
    const int Port = 555;
 
    async static Task RunClient()
    {
        WriteLine(""Connecting"");
        var client = new TcpClient();
        await client.ConnectAsync(""localhost"", Port);
 
        using (var stream = client.GetStream())
        {
            WriteLine(""Sending loot"");
            var data = Serialize(new SampleData());
            await stream.WriteAsync(data, 0, data.Length);
 
            WriteLine(""Receiving thanks"");
            var buffer = new byte[80000];
            var bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length);
            var thanks = (string)Deserialize(buffer, bytesRead);
            WriteLine(thanks);
        }
 
        client.Close();
    }
 
    async static Task RunServer()
    {
        WriteLine(""Listening"");
        var listener = new TcpListener(IPAddress.Any, Port);
        listener.Start();
        var client = await listener.AcceptTcpClientAsync();
 
        using (var stream = client.GetStream())
        {
            WriteLine(""Receiving loot"");
            var buffer = new byte[80000];
            var bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length);
            var data = (SampleData)Deserialize(buffer, bytesRead);
            WriteLine($""{data.Loot} at {data.Latitude}, {data.Longitude}"");
 
            WriteLine(""Sending thanks"");
            var thanks = Serialize(""Thanks!"");
            await stream.WriteAsync(thanks, 0, thanks.Length);
        }
 
        client.Close();
        listener.Stop();
        Write(""Press a key"");
        ReadKey();
    }
 
    static byte[] Serialize(object data)
    {
        using (var mem = new MemoryStream())
        {
            new BinaryFormatter().Serialize(mem, data);
            return mem.ToArray();
        }
    }
 
    static object Deserialize(byte[] data, int length)
    {
        using (var mem = new MemoryStream(data, 0, length))
        {
            return new BinaryFormatter().Deserialize(mem);
        }
    }
 
    static void Main(string[] args)
    {
        if (args.Length == 0) return;
 
        switch (args[0])
        {
            case ""client"": RunClient().Wait(); break;
            case ""server"": RunServer().Wait(); break;
        }
    }
}
 
[Serializable]
class SampleData
{
    public decimal Latitude = 44.33190m;
    public decimal Longitude = 114.84129m;
    public string Loot = ""140 tonnes of jade"";
}
 ",2618,99
61278,http://rosettacode.org/wiki/DNS_query,DNS query,"DNS is an internet service that maps domain names, like rosettacode.org, to IP addresses, like 66.220.0.231.

Use DNS to resolve www.kame.net to both IPv4 and IPv6 addresses. Print these addresses.



",#C.23,C#," 
        private string LookupDns(string s)
        {
            try
            {
                System.Net.IPHostEntry ip = System.Net.Dns.GetHostEntry(s);
 
                string result = ip.AddressList[0].ToString();
 
                for (int i = 1; i < ip.AddressList.Length; ++i)
                    result += "", "" + ip.AddressList[i].ToString();
 
                return result;
            }
            catch (System.Net.Sockets.SocketException se)
            {
                return se.Message;
            }
        }
 ",537,20
61432,http://rosettacode.org/wiki/Doubly-linked_list/Definition,Doubly-linked list/Definition,"Define the data structure for a complete Doubly Linked List.

 The structure should support adding elements to the head, tail and middle of the list. 
 The structure should not allow circular loops


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#C.23,C#,"using System.Collections.Generic;
 
class Program
{
    static void Main(string[] args)
    {
        LinkedList<string> list = new LinkedList<string>();
        list.AddFirst("".AddFirst() adds at the head."");
        list.AddLast("".AddLast() adds at the tail."");
        LinkedListNode<string> head = list.Find("".AddFirst() adds at the head."");
        list.AddAfter(head, "".AddAfter() adds after a specified node."");
        LinkedListNode<string> tail = list.Find("".AddLast() adds at the tail."");
        list.AddBefore(tail, ""Betcha can't guess what .AddBefore() does."");
 
        System.Console.WriteLine(""Forward:"");
        foreach (string nodeValue in list) { System.Console.WriteLine(nodeValue); }
 
        System.Console.WriteLine(""\nBackward:"");
        LinkedListNode<string> current = tail;
        while (current != null)
        {
            System.Console.WriteLine(current.Value);
            current = current.Previous;
        }
    }
}",958,26
61626,http://rosettacode.org/wiki/Digital_root/Multiplicative_digital_root,Digital root/Multiplicative digital root,"The multiplicative digital root (MDR) and multiplicative persistence (MP) of a number, 



n


{\displaystyle n}

, is calculated rather like the Digital root except digits are multiplied instead of being added:

 Set 



m


{\displaystyle m}

 to 



n


{\displaystyle n}

 and 



i


{\displaystyle i}

 to 



0


{\displaystyle 0}

.
 While 



m


{\displaystyle m}

 has more than one digit:
 Find a replacement 



m


{\displaystyle m}

 as the multiplication of the digits of the current value of 



m


{\displaystyle m}

.
 Increment 



i


{\displaystyle i}

.
 Return 



i


{\displaystyle i}

 (= MP) and 



m


{\displaystyle m}

 (= MDR)


Task

 Tabulate the MP and MDR of the numbers 123321, 7739, 893, 899998
 Tabulate MDR versus the first five numbers having that MDR, something like:
MDR: [n0..n4]
===  ========
  0: [0, 10, 20, 25, 30]
  1: [1, 11, 111, 1111, 11111]
  2: [2, 12, 21, 26, 34]
  3: [3, 13, 31, 113, 131]
  4: [4, 14, 22, 27, 39]
  5: [5, 15, 35, 51, 53]
  6: [6, 16, 23, 28, 32]
  7: [7, 17, 71, 117, 171]
  8: [8, 18, 24, 29, 36]
  9: [9, 19, 33, 91, 119]

Show all output on this page.

Similar

The Product of decimal digits of n page was redirected here, and had the following description


Find the product of the decimal digits of a positive integer   n,   where n <= 100

The three existing entries for Phix, REXX, and Ring have been moved here, under ===Similar=== headings, feel free to match or ignore them.



References

 Multiplicative Digital Root on Wolfram Mathworld.
 Multiplicative digital root on The On-Line Encyclopedia of Integer Sequences.
 What's special about 277777788888899? - Numberphile video

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
class Program
{
    static Tuple<int, int> DigitalRoot(long num)
    {
        int mp = 0;
        while (num > 9)
        {
            num = num.ToString().ToCharArray().Select(x => x - '0').Aggregate((a, b) => a * b);
            mp++;
        }
        return new Tuple<int, int>(mp, (int)num);
    }
    static void Main(string[] args)
    {
        foreach (long num in new long[] { 123321, 7739, 893, 899998 })
        {
            var t = DigitalRoot(num);
            Console.WriteLine(""{0} has multiplicative persistence {1} and multiplicative digital root {2}"", num, t.Item1, t.Item2);
        }
 
        const int twidth = 5;
        List<long>[] table = new List<long>[10];
        for (int i = 0; i < 10; i++)
            table[i] = new List<long>();
        long number = -1;
        while (table.Any(x => x.Count < twidth)) 
        {
            var t = DigitalRoot(++number);
            if (table[t.Item2].Count < twidth)
                table[t.Item2].Add(number);
        }
        for (int i = 0; i < 10; i++)
            Console.WriteLine("" {0} : [{1}]"", i, string.Join("", "", table[i]));
    }
}",1189,39
61666,http://rosettacode.org/wiki/Dot_product,Dot product,"Task

Create a function/use an in-built function, to compute the   dot product,   also known as the   scalar product   of two vectors.

If possible, make the vectors of arbitrary length.



As an example, compute the dot product of the vectors:

     [1,  3, -5]       and 
     [4, -2, -1]   


If implementing the dot product of two vectors directly:

   each vector must be the same length
   multiply corresponding terms from each vector
   sum the products   (to produce the answer)


Related task

   Vector products

",#C.23,C#,"static void Main(string[] args)
{
	Console.WriteLine(DotProduct(new decimal[] { 1, 3, -5 }, new decimal[] { 4, -2, -1 }));
	Console.Read();
}
 
private static decimal DotProduct(decimal[] vec1, decimal[] vec2) 
{
	if (vec1 == null)
		return 0;
 
	if (vec2 == null)
		return 0;
 
	if (vec1.Length != vec2.Length)
		return 0;
 
	decimal tVal = 0;
	for (int x = 0; x < vec1.Length; x++)
	{
		tVal += vec1[x] * vec2[x];
	}
 
	return tVal;
}",436,25
61700,http://rosettacode.org/wiki/Dinesman%27s_multiple-dwelling_problem,Dinesman's multiple-dwelling problem,"Task
Solve Dinesman's multiple dwelling problem but in a way that most naturally follows the problem statement given below.

Solutions are allowed (but not required) to parse and interpret the problem text, but should remain flexible and should state what changes to the problem text are allowed. Flexibility and ease of expression are valued.

Examples may be be split into ""setup"", ""problem statement"", and ""output"" sections where the ease and naturalness of stating the problem and getting an answer, as well as the ease and flexibility of modifying the problem are the primary concerns.

Example output should be shown here, as well as any comments on the examples flexibility.



The problem
Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an apartment house that contains only five floors.


   Baker does not live on the top floor.
   Cooper does not live on the bottom floor. 
   Fletcher does not live on either the top or the bottom floor.
   Miller lives on a higher floor than does Cooper.
   Smith does not live on a floor adjacent to Fletcher's. 
   Fletcher does not live on a floor adjacent to Cooper's.

Where does everyone live?
",#C.23,C#,"public class Program
{
    public static void Main()
    {
        const int count = 5;
        const int Baker = 0, Cooper = 1, Fletcher = 2, Miller = 3, Smith = 4;
        string[] names = { nameof(Baker), nameof(Cooper), nameof(Fletcher), nameof(Miller), nameof(Smith) };
 
        Func<int[], bool>[] constraints = {
            floorOf => floorOf[Baker] != count-1,
            floorOf => floorOf[Cooper] != 0,
            floorOf => floorOf[Fletcher] != count-1 && floorOf[Fletcher] != 0,
            floorOf => floorOf[Miller] > floorOf[Cooper],
            floorOf => Math.Abs(floorOf[Smith] - floorOf[Fletcher]) > 1,
            floorOf => Math.Abs(floorOf[Fletcher] - floorOf[Cooper]) > 1,
        };
 
        var solver = new DinesmanSolver();
        foreach (var tenants in solver.Solve(count, constraints)) {
            Console.WriteLine(string.Join("" "", tenants.Select(t => names[t])));
        }
    }
}
 
public class DinesmanSolver
{
    public IEnumerable<int[]> Solve(int count, params Func<int[], bool>[] constraints) {
        foreach (int[] floorOf in Permutations(count)) {
            if (constraints.All(c => c(floorOf))) {
                yield return Enumerable.Range(0, count).OrderBy(i => floorOf[i]).ToArray();
            }
        }
    }
 
    static IEnumerable<int[]> Permutations(int length) {
        if (length == 0) {
            yield return new int[0];
            yield break;
        }
        bool forwards = false;
        foreach (var permutation in Permutations(length - 1)) {
            for (int i = 0; i < length; i++) {
                yield return permutation.InsertAt(forwards ? i : length - i - 1, length - 1).ToArray();
            }
            forwards = !forwards;
        }
    }
}
 
static class Extensions
{
    public static IEnumerable<T> InsertAt<T>(this IEnumerable<T> source, int position, T newElement) {
        if (source == null) throw new ArgumentNullException(nameof(source));
        if (position < 0) throw new ArgumentOutOfRangeException(nameof(position));
        return InsertAtIterator(source, position, newElement);
    }
 
    private static IEnumerable<T> InsertAtIterator<T>(IEnumerable<T> source, int position, T newElement) {
        int index = 0;
        foreach (T element in source) {
            if (index == position) yield return newElement;
            yield return element;
            index++;
        }
        if (index < position) throw new ArgumentOutOfRangeException(nameof(position));
        if (index == position) yield return newElement;
    }
}",2551,68
61716,http://rosettacode.org/wiki/Dining_philosophers,Dining philosophers,"The dining philosophers problem illustrates non-composability of low-level synchronization primitives like semaphores. It is a modification of a problem posed by Edsger Dijkstra.

Five philosophers, Aristotle, Kant, Spinoza, Marx, and Russell (the tasks) spend their time thinking and eating spaghetti. They eat at a round table with five individual seats. For eating each philosopher needs two forks (the resources). There are five forks on the table, one left and one right of each seat. When a philosopher cannot grab both forks it sits and waits. Eating takes random time, then the philosopher puts the forks down and leaves the dining room. After spending some random time thinking about the nature of the universe, he again becomes hungry, and the circle repeats itself.

It can be observed that a straightforward solution, when forks are implemented by semaphores, is exposed to deadlock. There exist two deadlock states when all five philosophers are sitting at the table holding one fork each. One deadlock state is when each philosopher has grabbed the fork left of him, and another is when each has the fork on his right.

There are many solutions of the problem, program at least one, and explain how the deadlock is prevented.
",#C.23,C#," 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
 
namespace Dining_Philosophers
{
    class Program
    {
        private const int DinerCount = 5;
        private static List<Diner> Diners = new List<Diner>();
        private static List<Fork> Forks = new List<Fork>();
        private static DateTime TimeToStop;
 
        static void Main(string[] args)
        {
            Initialize();
            WriteHeaderLine();
 
            do
            {
                WriteStatusLine();
                Thread.Sleep(1000);
            }
            while (DateTime.Now < TimeToStop);
 
            TearDown();
        }
 
        private static void Initialize()
        {
            for (int i = 0; i < DinerCount; i++)
                Forks.Add(new Fork());
            for (int i = 0; i < DinerCount; i++)
                Diners.Add(new Diner(i, Forks[i], Forks[(i + 1) % DinerCount]));
 
            TimeToStop = DateTime.Now.AddSeconds(60);
        }
 
        private static void TearDown()
        {
            foreach (var diner in Diners)
                diner.Dispose();
        }
 
        private static void WriteHeaderLine()
        {
            Console.Write(""|"");
 
            foreach (Diner d in Diners)
                Console.Write(""D "" + d.ID + ""|"");
 
            Console.Write(""    |"");
 
            for (int i = 0; i < DinerCount; i++)
                Console.Write(""F"" + i + ""|"");
 
            Console.WriteLine();
        }
 
        private static void WriteStatusLine()
        {
            Console.Write(""|"");
 
            foreach (Diner d in Diners)
                Console.Write(FormatDinerState(d) + ""|"");
 
            Console.Write(""    |"");
 
            foreach (Fork f in Forks)
                Console.Write(FormatForkState(f) + ""|"");
 
            Console.WriteLine();
        }
 
        private static string FormatDinerState(Diner diner)
        {
            switch (diner.State)
            {
                case Diner.DinerState.Eating:
                    return ""Eat"";
                case Diner.DinerState.Pondering:
                    return ""Pon"";
                case Diner.DinerState.TryingToGetForks:
                    return ""Get"";
                default:
                    throw new Exception(""Unknown diner state."");
            }
        }
 
        private static string FormatForkState(Fork fork)
        {
            return (!ForkIsBeingUsed(fork) ? ""  "" : ""D"" + GetForkHolder(fork));
        }
 
        private static bool ForkIsBeingUsed(Fork fork)
        {
            return Diners.Count(d => d.CurrentlyHeldForks.Contains(fork)) > 0;
        }
 
        private static int GetForkHolder(Fork fork)
        {
            return Diners.Single(d => d.CurrentlyHeldForks.Contains(fork)).ID;
        }
    }
 
    class Diner : IDisposable
    {
        private bool IsCurrentlyHoldingLeftFork = false;
        private bool IsCurrentlyHoldingRightFork = false;
        private const int MaximumWaitTime = 100;
        private static Random Randomizer = new Random();
        private bool ShouldStopEating = false;
 
        public int ID { get; private set; }
        public Fork LeftFork { get; private set; }
        public Fork RightFork { get; private set; }
        public DinerState State { get; private set; }
 
        public IEnumerable<Fork> CurrentlyHeldForks
        {
            get
            {
                var forks = new List<Fork>();
                if (IsCurrentlyHoldingLeftFork)
                    forks.Add(LeftFork);
                if (IsCurrentlyHoldingRightFork)
                    forks.Add(RightFork);
                return forks;
            }
        }
 
        public Diner(int id, Fork leftFork, Fork rightFork)
        {
            InitializeDinerState(id, leftFork, rightFork);
            BeginDinerActivity();
        }
 
        private void KeepTryingToEat()
        {
            do
                if (State == DinerState.TryingToGetForks)
                {
                    TryToGetLeftFork();
                    if (IsCurrentlyHoldingLeftFork)
                    {
                        TryToGetRightFork();
                        if (IsCurrentlyHoldingRightFork)
                        {
                            Eat();
                            DropForks();
                            Ponder();
                        }
                        else
                        {
                            DropForks();
                            WaitForAMoment();
                        }
                    }
                    else
                        WaitForAMoment();
                }
                else
                    State = DinerState.TryingToGetForks;
            while (!ShouldStopEating);
        }
 
        private void InitializeDinerState(int id, Fork leftFork, Fork rightFork)
        {
            ID = id;
            LeftFork = leftFork;
            RightFork = rightFork;
            State = DinerState.TryingToGetForks;
        }
 
        private async void BeginDinerActivity()
        {
            await Task.Run(() => KeepTryingToEat());
        }
 
        private void TryToGetLeftFork()
        {
            Monitor.TryEnter(LeftFork, ref IsCurrentlyHoldingLeftFork);
        }
 
        private void TryToGetRightFork()
        {
            Monitor.TryEnter(RightFork, ref IsCurrentlyHoldingRightFork);
        }
 
        private void DropForks()
        {
            DropLeftFork();
            DropRightFork();
        }
 
        private void DropLeftFork()
        {
            if (IsCurrentlyHoldingLeftFork)
            {
                IsCurrentlyHoldingLeftFork = false;
                Monitor.Exit(LeftFork);
            }
        }
 
        private void DropRightFork()
        {
            if (IsCurrentlyHoldingRightFork)
            {
                IsCurrentlyHoldingRightFork = false;
                Monitor.Exit(RightFork);
            }
        }
 
        private void Eat()
        {
            State = DinerState.Eating;
            WaitForAMoment();
        }
 
        private void Ponder()
        {
            State = DinerState.Pondering;
            WaitForAMoment();
        }
 
        private static void WaitForAMoment()
        {
            Thread.Sleep(Randomizer.Next(MaximumWaitTime));
        }
 
        public void Dispose()
        {
            ShouldStopEating = true;
        }
 
        public enum DinerState
        {
            Eating,
            TryingToGetForks,
            Pondering
        }
    }
 
    class Fork { }
}
 ",6674,250
61732,http://rosettacode.org/wiki/Dijkstra%27s_algorithm,Dijkstra's algorithm,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.

Dijkstra's algorithm, conceived by Dutch computer scientist Edsger Dijkstra in 1956 and published in 1959, is a graph search algorithm that solves the single-source shortest path problem for a graph with non-negative edge path costs, producing a shortest path tree.

This algorithm is often used in routing and as a subroutine in other graph algorithms.



For a given source vertex (node) in the graph, the algorithm finds the path with lowest cost (i.e. the shortest path) between that vertex and every other vertex.



For instance

If the vertices of the graph represent cities and edge path costs represent driving distances between pairs of cities connected by a direct road,   Dijkstra's algorithm can be used to find the shortest route between one city and all other cities.

As a result, the shortest path first is widely used in network routing protocols, most notably:

   IS-IS   (Intermediate System to Intermediate System)   and 
   OSPF   (Open Shortest Path First).


Important note
 
The inputs to Dijkstra's algorithm are a directed and weighted graph consisting of 2 or more nodes, generally represented by:

   an adjacency matrix or list,   and
   a start node. 


A destination node is not specified.

The output is a set of edges depicting the shortest path to each destination node.



An example, starting with

                                         a──►b,  cost=7,   lastNode=a  
                                         a──►c,  cost=9,   lastNode=a 
                                         a──►d,  cost=NA,  lastNode=a
                                         a──►e,  cost=NA,  lastNode=a 
                                         a──►f,  cost=14,  lastNode=a
 
    The lowest cost is    a──►b    so    a──►b    is added to the output. 
 
    There is a connection from   b──►d   so the input is updated to: 
                                         a──►c,  cost=9,   lastNode=a 
                                         a──►d,  cost=22,  lastNode=b 
                                         a──►e,  cost=NA,  lastNode=a 
                                         a──►f,  cost=14,  lastNode=a
 
    The lowest cost is    a──►c    so    a──►c    is added to the output. 
 
    Paths to    d    and    f    are cheaper via    c    so the input is updated to:
                                         a──►d,  cost=20,  lastNode=c 
                                         a──►e,  cost=NA,  lastNode=a 
                                         a──►f,  cost=11,  lastNode=c
 
    The lowest cost is    a──►f    so    c──►f    is added to the output. 
 
    The input is updated to:
                                         a──►d,  cost=20,  lastNode=c 
                                         a──►e,  cost=NA,  lastNode=a
 
    The lowest cost is    a──►d    so    c──►d    is added to the output. 
 
    There is a connection from    d──►e    so the input is updated to:
                                         a──►e,  cost=26,  lastNode=d
 
    Which just leaves adding    d──►e    to the output.
 
    The output should now be:
                                       [ d──►e
                                         c──►d
                                         c──►f
                                         a──►c
                                         a──►b ]   


Task

 Implement a version of Dijkstra's algorithm that outputs a set of edges depicting the shortest path to each reachable node from an origin.
 Run your program with the following directed graph starting at node    a.
 Write a program which interprets the output from the above and use it to output the shortest path from node    a    to nodes    e    and  f. 

 Vertices


 Number 
 Name


 1 
 a


 2 
 b


 3 
 c


 4 
 d


 5 
 e


 6 
 f


 Edges


 Start 
 End 
 Cost


 a 
 b 
 7


 a 
 c 
 9


 a 
 f 
 14


 b 
 c 
 10


 b 
 d 
 15


 c 
 d 
 11


 c 
 f 
 2


 d 
 e 
 6


 e 
 f 
 9



You can use numbers or names to identify vertices in your program.



See also
 Dijkstra's Algorithm vs. A* Search vs. Concurrent Dijkstra's Algorithm (youtube)

",#C.23,C#,"using static System.Linq.Enumerable;
using static System.String;
using static System.Console;
using System.Collections.Generic;
using System;
using EdgeList = System.Collections.Generic.List<(int node, double weight)>;
 
public static class Dijkstra
{
    public static void Main() {
        Graph graph = new Graph(6);
        Func<char, int> id = c => c - 'a';
        Func<int , char> name = i => (char)(i + 'a');
        foreach (var (start, end, cost) in new [] {
            ('a', 'b', 7),
            ('a', 'c', 9),
            ('a', 'f', 14),
            ('b', 'c', 10),
            ('b', 'd', 15),
            ('c', 'd', 11),
            ('c', 'f', 2),
            ('d', 'e', 6),
            ('e', 'f', 9),
        }) {
            graph.AddEdge(id(start), id(end), cost);
        }
 
        var path = graph.FindPath(id('a'));
        for (int d = id('b'); d <= id('f'); d++) {
            WriteLine(Join("" -> "", Path(id('a'), d).Select(p => $""{name(p.node)}({p.distance})"").Reverse()));
        }
 
        IEnumerable<(double distance, int node)> Path(int start, int destination) {
            yield return (path[destination].distance, destination);
            for (int i = destination; i != start; i = path[i].prev) {
                yield return (path[path[i].prev].distance, path[i].prev);
            }
        }
    }
 
}
 
sealed class Graph
{
    private readonly List<EdgeList> adjacency;
 
    public Graph(int vertexCount) => adjacency = Range(0, vertexCount).Select(v => new EdgeList()).ToList();
 
    public int Count => adjacency.Count;
    public bool HasEdge(int s, int e) => adjacency[s].Any(p => p.node == e);
    public bool RemoveEdge(int s, int e) => adjacency[s].RemoveAll(p => p.node == e) > 0;
 
    public bool AddEdge(int s, int e, double weight) {
        if (HasEdge(s, e)) return false;
        adjacency[s].Add((e, weight));
        return true;
    }
 
    public (double distance, int prev)[] FindPath(int start) {
        var info = Range(0, adjacency.Count).Select(i => (distance: double.PositiveInfinity, prev: i)).ToArray();
        info[start].distance = 0;
        var visited = new System.Collections.BitArray(adjacency.Count);
 
        var heap = new Heap<(int node, double distance)>((a, b) => a.distance.CompareTo(b.distance));
        heap.Push((start, 0));
        while (heap.Count > 0) {
            var current = heap.Pop();
            if (visited[current.node]) continue;
            var edges = adjacency[current.node];
            for (int n = 0; n < edges.Count; n++) {
                int v = edges[n].node;
                if (visited[v]) continue;
                double alt = info[current.node].distance + edges[n].weight;
                if (alt < info[v].distance) {
                    info[v] = (alt, current.node);
                    heap.Push((v, alt));
                }
            }
            visited[current.node] = true;
        }
        return info;
    }
 
}
 
sealed class Heap<T>
{
    private readonly IComparer<T> comparer;
    private readonly List<T> list = new List<T> { default };
 
    public Heap() : this(default(IComparer<T>)) { }
 
    public Heap(IComparer<T> comparer) {
        this.comparer = comparer ?? Comparer<T>.Default;
    }
 
    public Heap(Comparison<T> comparison) : this(Comparer<T>.Create(comparison)) { }
 
    public int Count => list.Count - 1;
 
    public void Push(T element) {
        list.Add(element);
        SiftUp(list.Count - 1);
    }
 
    public T Pop() {
        T result = list[1];
        list[1] = list[list.Count - 1];
        list.RemoveAt(list.Count - 1);
        SiftDown(1);
        return result;
    }
 
    private static int Parent(int i) => i / 2;
    private static int Left(int i) => i * 2;
    private static int Right(int i) => i * 2 + 1;
 
    private void SiftUp(int i) {
        while (i > 1) {
            int parent = Parent(i);
            if (comparer.Compare(list[i], list[parent]) > 0) return;
            (list[parent], list[i]) = (list[i], list[parent]);
            i = parent;
        }
    }
 
    private void SiftDown(int i) {
        for (int left = Left(i); left < list.Count; left = Left(i)) {
            int smallest = comparer.Compare(list[left], list[i]) <= 0 ? left : i;
            int right = Right(i);
            if (right < list.Count && comparer.Compare(list[right], list[smallest]) <= 0) smallest = right;
            if (smallest == i) return;
            (list[i], list[smallest]) = (list[smallest], list[i]);
            i = smallest;
        }
    }
 
}",4540,138
61752,http://rosettacode.org/wiki/Determine_if_only_one_instance_is_running,Determine if only one instance is running,"This task is to determine if there is only one instance of an application running. If the program discovers that an instance of it is already running, then it should display a message indicating that it is already running and exit.
",#C.23,C#,"using System;
using System.Net;
using System.Net.Sockets;
 
class Program {        
    static void Main(string[] args) {        
        try {
            TcpListener server = new TcpListener(IPAddress.Any, 12345);
            server.Start();
        } 
 
        catch (SocketException e) {
            if (e.SocketErrorCode == SocketError.AddressAlreadyInUse) {
                Console.Error.WriteLine(""Already running."");
            }
        }
    }
}",457,18
61785,http://rosettacode.org/wiki/Discordian_date,Discordian date,"

Task

Convert a given date from the   Gregorian calendar   to the   Discordian calendar.



",#C.23,C#,"using System;
 
public static class DiscordianDate
{
    static readonly string[] seasons = { ""Chaos"", ""Discord"", ""Confusion"", ""Bureaucracy"", ""The Aftermath"" };
    static readonly string[] weekdays = { ""Sweetmorn"", ""Boomtime"", ""Pungenday"", ""Prickle-Prickle"", ""Setting Orange"" };
    static readonly string[] apostles = { ""Mungday"", ""Mojoday"", ""Syaday"", ""Zaraday"", ""Maladay"" };
    static readonly string[] holidays = { ""Chaoflux"", ""Discoflux"", ""Confuflux"", ""Bureflux"", ""Afflux"" };
 
    public static string Discordian(this DateTime date) {
        string yold = $"" in the YOLD {date.Year + 1166}."";
        int dayOfYear = date.DayOfYear;
 
        if (DateTime.IsLeapYear(date.Year)) {
            if (dayOfYear == 60) return ""St. Tib's day"" + yold;
            else if (dayOfYear > 60) dayOfYear--;
        }
        dayOfYear--;
 
        int seasonDay = dayOfYear % 73 + 1;
        int seasonNr = dayOfYear / 73;
        int weekdayNr = dayOfYear % 5;
        string holyday = """";
 
        if (seasonDay == 5)       holyday = $"" Celebrate {apostles[seasonNr]}!"";
        else if (seasonDay == 50) holyday = $"" Celebrate {holidays[seasonNr]}!"";
        return $""{weekdays[weekdayNr]}, day {seasonDay} of {seasons[seasonNr]}{yold}{holyday}"";
    }
 
    public static void Main() {
        foreach (var (day, month, year) in new [] {
            (1, 1, 2010),
            (5, 1, 2010),
            (19, 2, 2011),
            (28, 2, 2012),
            (29, 2, 2012),
            (1, 3, 2012),
            (19, 3, 2013),
            (3, 5, 2014),
            (31, 5, 2015),
            (22, 6, 2016),
            (15, 7, 2016),
            (12, 8, 2017),
            (19, 9, 2018),
            (26, 9, 2018),
            (24, 10, 2019),
            (8, 12, 2020),
            (31, 12, 2020)
        })
        {
            Console.WriteLine($""{day:00}-{month:00}-{year:00} = {new DateTime(year, month, day).Discordian()}"");
        }
    }
 
}",1948,55
61800,http://rosettacode.org/wiki/Digital_root,Digital root,"The digital root, 



X


{\displaystyle X}

, of a number, 



n


{\displaystyle n}

, is calculated:

 find 



X


{\displaystyle X}

 as the sum of the digits of 



n


{\displaystyle n}


 find a new 



X


{\displaystyle X}

 by summing the digits of 



X


{\displaystyle X}

, repeating until 



X


{\displaystyle X}

 has only one digit.
The additive persistence is the number of summations required to obtain the single digit.

The task is to calculate the additive persistence and the digital root of a number, e.g.:





627615


{\displaystyle 627615}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



9


{\displaystyle 9}

;




39390


{\displaystyle 39390}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



6


{\displaystyle 6}

;




588225


{\displaystyle 588225}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



3


{\displaystyle 3}

;




393900588225


{\displaystyle 393900588225}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



9


{\displaystyle 9}

;
The digital root may be calculated in bases other than 10.



See

 Casting out nines for this wiki's use of this procedure.
 Digital root/Multiplicative digital root
 Sum digits of an integer
 Digital root sequence on OEIS
 Additive persistence sequence on OEIS
 Iterated digits squaring

",#C.23,C#,"using System;
using System.Linq;
 
class Program
{
    static Tuple<int, int> DigitalRoot(long num)
    {
        int additivepersistence = 0;
        while (num > 9)
        {
            num = num.ToString().ToCharArray().Sum(x => x - '0');
            additivepersistence++;
        }
        return new Tuple<int, int>(additivepersistence, (int)num);
    }
    static void Main(string[] args)
    {
        foreach (long num in new long[] { 627615, 39390, 588225, 393900588225 })
        {
            var t = DigitalRoot(num);
            Console.WriteLine(""{0} has additive persistence {1} and digital root {2}"", num, t.Item1, t.Item2);
        }
    }
}",660,24
61953,http://rosettacode.org/wiki/Determine_if_a_string_is_squeezable,Determine if a string is squeezable,"Determine if a character string is   squeezable.

And if so,   squeeze the string   (by removing any number of
a   specified   immediately repeated   character).



This task is very similar to the task     Determine if a character string is collapsible     except
that only a specified character is   squeezed   instead of any character that is immediately repeated.



If a character string has a specified   immediately repeated   character(s),   the repeated characters are to be
deleted (removed),   but not the primary (1st) character(s).



A specified   immediately repeated   character is any specified character that is   immediately  
followed by an identical character (or characters).   Another word choice could've been   duplicated
character,   but that might have ruled out   (to some readers)   triplicated characters   ···   or more.



{This Rosetta Code task was inspired by a newly introduced   (as of around
November 2019)   PL/I   BIF:   squeeze.}



Examples

In the following character string with a specified   immediately repeated   character of   e:



 The better the 4-wheel drive, the further you'll be from help when ya get stuck! 



Only the 2nd   e   is an specified repeated character,   indicated by an underscore
(above),   even though they (the characters) appear elsewhere in the character string.



So, after squeezing the string, the result would be:

 The better the 4-whel drive, the further you'll be from help when ya get stuck! 





Another example:
In the following character string,   using a specified immediately repeated character   s:

 headmistressship 



The ""squeezed"" string would be:

 headmistreship 



Task

Write a subroutine/function/procedure/routine···   to locate a   specified immediately repeated   character
and   squeeze   (delete)   them from the character string.   The
character string can be processed from either direction.



Show all output here, on this page:

   the   specified repeated character   (to be searched for and possibly squeezed):
   the   original string and its length
   the resultant string and its length
   the above strings should be ""bracketed"" with   <<<   and   >>>   (to delineate blanks)
   «««Guillemets may be used instead for ""bracketing"" for the more artistic programmers,   shown used here»»»


Use (at least) the following five strings,   all strings are length seventy-two (characters, including blanks),   except
the 1st string:

                                                                                  immediately
 string                                                                            repeated
 number                                                                            character
                                                                                     ( ↓   a blank,  a minus,  a seven,  a period)
        ╔╗
   1    ║╚═══════════════════════════════════════════════════════════════════════╗    ' '    ◄■■■■■■  a null string  (length zero)
   2    ║""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln ║    '-'
   3    ║..1111111111111111111111111111111111111111111111111111111111111117777888║    '7'
   4    ║I never give 'em hell, I just tell the truth, and they think it's hell. ║    '.'
   5    ║                                                    --- Harry S Truman  ║  (below)  ◄■■■■■■  has many repeated blanks
        ╚════════════════════════════════════════════════════════════════════════╝     ↑
                                                                                       │
                                                                                       │
        For the 5th string  (Truman's signature line),  use each of these  specified immediately  repeated characters:
                                  •  a blank
                                  •  a minus
                                  •  a lowercase  r



Note:   there should be seven results shown,   one each for the 1st four strings,   and three results for
the 5th string.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using static System.Linq.Enumerable;
 
public class Program
{
    static void Main()
    {
        SqueezeAndPrint("""", ' ');
        SqueezeAndPrint(""\""If I were two-faced, would I be wearing this one?\"" --- Abraham Lincoln "", '-');
        SqueezeAndPrint(""..1111111111111111111111111111111111111111111111111111111111111117777888"", '7');
        SqueezeAndPrint(""I never give 'em hell, I just tell the truth, and they think it's hell. "", '.');
        string s = ""                                                    --- Harry S Truman  "";
        SqueezeAndPrint(s, ' ');
        SqueezeAndPrint(s, '-');
        SqueezeAndPrint(s, 'r');
    }
 
    static void SqueezeAndPrint(string s, char c) {
        Console.WriteLine($""squeeze: '{c}'"");
        Console.WriteLine($""old: {s.Length} «««{s}»»»"");
        s = Squeeze(s, c);
        Console.WriteLine($""new: {s.Length} «««{s}»»»"");
    }
 
    static string Squeeze(string s, char c) => string.IsNullOrEmpty(s) ? """" :
        s[0] + new string(Range(1, s.Length - 1).Where(i => s[i] != c || s[i] != s[i - 1]).Select(i => s[i]).ToArray());
}",1108,27
62011,http://rosettacode.org/wiki/Determine_if_a_string_is_collapsible,Determine if a string is collapsible,"Determine if a character string is   collapsible.

And if so,   collapse the string   (by removing   immediately repeated   characters).



If a character string has   immediately repeated   character(s),   the repeated characters are to be
deleted (removed),   but not the primary (1st) character(s).



An   immediately repeated   character is any character that is   immediately   followed by an
identical character (or characters).   Another word choice could've been   duplicated character,   but that
might have ruled out   (to some readers)   triplicated characters   ···   or more.



{This Rosetta Code task was inspired by a newly introduced   (as of around November 2019)   PL/I   BIF:   collapse.}



Examples

In the following character string:



 The better the 4-wheel drive, the further you'll be from help when ya get stuck! 



Only the 2nd   t,   e, and   l   are repeated characters,   indicated
by underscores (above),   even though they (those characters) appear elsewhere in the character string.



So, after collapsing the string, the result would be:

 The beter the 4-whel drive, the further you'l be from help when ya get stuck! 





Another example:
In the following character string:

 headmistressship 



The ""collapsed"" string would be:

 headmistreship 



Task

Write a subroutine/function/procedure/routine···   to
locate   repeated   characters and   collapse   (delete)   them from the character
string.   The character string can be processed from either direction.



Show all output here, on this page:

   the   original string and its length
   the resultant string and its length
   the above strings should be ""bracketed"" with   <<<   and   >>>   (to delineate blanks)
   «««Guillemets may be used instead for ""bracketing"" for the more artistic programmers,   shown used here»»»


Use (at least) the following five strings,   all strings are length seventy-two (characters, including blanks),   except
the 1st string:

 string
 number
        ╔╗
   1    ║╚═══════════════════════════════════════════════════════════════════════╗   ◄■■■■■■  a null string  (length zero)
   2    ║""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln ║
   3    ║..1111111111111111111111111111111111111111111111111111111111111117777888║
   4    ║I never give 'em hell, I just tell the truth, and they think it's hell. ║
   5    ║                                                    --- Harry S Truman  ║   ◄■■■■■■  has many repeated blanks
        ╚════════════════════════════════════════════════════════════════════════╝


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using static System.Linq.Enumerable;
 
public class Program
{
    static void Main()
    {
        string[] input = {
            """",
            ""The better the 4-wheel drive, the further you'll be from help when ya get stuck!"",
            ""headmistressship"",
            ""\""If I were two-faced, would I be wearing this one?\"" --- Abraham Lincoln "",
            ""..1111111111111111111111111111111111111111111111111111111111111117777888"",
            ""I never give 'em hell, I just tell the truth, and they think it's hell. "",
            ""                                                    --- Harry S Truman  ""
        };
        foreach (string s in input) {
            Console.WriteLine($""old: {s.Length} «««{s}»»»"");
            string c = Collapse(s);
            Console.WriteLine($""new: {c.Length} «««{c}»»»"");
        }
    }
 
    static string Collapse(string s) => string.IsNullOrEmpty(s) ? """" :
        s[0] + new string(Range(1, s.Length - 1).Where(i => s[i] != s[i - 1]).Select(i => s[i]).ToArray());
}",1034,26
62014,http://rosettacode.org/wiki/Determine_if_a_string_has_all_the_same_characters,Determine if a string has all the same characters,"Task

Given a character string   (which may be empty, or have a length of zero characters):

   create a function/procedure/routine to:
   determine if all the characters in the string are the same
   indicate if or which character is different from the previous character
   display each string and its length   (as the strings are being examined)
   a zero─length (empty) string shall be considered as all the same character(s)
   process the strings from left─to─right
   if       all the same character,   display a message saying such
   if not all the same character,   then:
   display a message saying such
   display what character is different
   only the 1st different character need be displayed
   display where the different character is in the string
   the above messages can be part of a single message
   display the hexadecimal value of the different character


Use (at least) these seven test values   (strings):

   a string of length   0   (an empty string)
   a string of length   3   which contains three blanks
   a string of length   1   which contains:   2
   a string of length   3   which contains:   333
   a string of length   3   which contains:   .55
   a string of length   6   which contains:   tttTTT
   a string of length   9   with a blank in the middle:   4444   444k


Show all output here on this page.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
 
namespace AllSame {
    class Program {
        static void Analyze(string s) {
            Console.WriteLine(""Examining [{0}] which has a length of {1}:"", s, s.Length);
            if (s.Length > 1) {
                var b = s[0];
                for (int i = 1; i < s.Length; i++) {
                    var c = s[i];
                    if (c != b) {
                        Console.WriteLine(""    Not all characters in the string are the same."");
                        Console.WriteLine(""    '{0}' (0x{1:X02}) is different at position {2}"", c, (int)c, i);
                        return;
                    }
                }
 
            }
            Console.WriteLine(""    All characters in the string are the same."");
        }
 
        static void Main() {
            var strs = new string[] { """", ""   "", ""2"", ""333"", "".55"", ""tttTTT"", ""4444 444k"" };
            foreach (var str in strs) {
                Analyze(str);
            }
        }
    }
}",981,29
62056,http://rosettacode.org/wiki/Determine_if_two_triangles_overlap,Determine if two triangles overlap,"Determining if two triangles in the same plane overlap is an important topic in collision detection.



Task

Determine which of these pairs of triangles overlap in 2D:

   (0,0),(5,0),(0,5)     and   (0,0),(5,0),(0,6)
   (0,0),(0,5),(5,0)     and   (0,0),(0,5),(5,0)
   (0,0),(5,0),(0,5)     and   (-10,0),(-5,0),(-1,6)
   (0,0),(5,0),(2.5,5)   and   (0,4),(2.5,-1),(5,4)
   (0,0),(1,1),(0,2)     and   (2,1),(3,0),(3,2)
   (0,0),(1,1),(0,2)     and   (2,1),(3,-2),(3,4)


Optionally, see what the result is when only a single corner is in contact (there is no definitive correct answer):

   (0,0),(1,0),(0,1)   and   (1,0),(2,0),(1,1)

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace TriangleOverlap {
    class Triangle {
        public Tuple<double, double> P1 { get; set; }
        public Tuple<double, double> P2 { get; set; }
        public Tuple<double, double> P3 { get; set; }
 
        public Triangle(Tuple<double, double> p1, Tuple<double, double> p2, Tuple<double, double> p3) {
            P1 = p1;
            P2 = p2;
            P3 = p3;
        }
 
        public double Det2D() {
            return P1.Item1 * (P2.Item2 - P3.Item2)
                 + P2.Item1 * (P3.Item2 - P1.Item2)
                 + P3.Item1 * (P3.Item1 - P2.Item2);
        }
 
        public void CheckTriWinding(bool allowReversed) {
            var detTri = Det2D();
            if (detTri < 0.0) {
                if (allowReversed) {
                    var a = P3;
                    P3 = P2;
                    P2 = a;
                } else {
                    throw new Exception(""Triangle has wrong winding direction"");
                }
            }
        }
 
        public bool BoundaryCollideChk(double eps) {
            return Det2D() < eps;
        }
 
        public bool BoundaryDoesntCollideChk(double eps) {
            return Det2D() <= eps;
        }
 
        public override string ToString() {
            return string.Format(""Triangle: {0}, {1}, {2}"", P1, P2, P3);
        }
    }
 
    class Program {
        static bool BoundaryCollideChk(Triangle t, double eps) {
            return t.BoundaryCollideChk(eps);
        }
 
        static bool BoundaryDoesntCollideChk(Triangle t, double eps) {
            return t.BoundaryDoesntCollideChk(eps);
        }
 
        static bool TriTri2D(Triangle t1, Triangle t2, double eps = 0.0, bool allowReversed = false, bool onBoundary = true) {
            // Triangles must be expressed anti-clockwise
            t1.CheckTriWinding(allowReversed);
            t2.CheckTriWinding(allowReversed);
            // 'onBoundary' determines whether points on boundary are considered as colliding or not
            var chkEdge = onBoundary
                ? (Func<Triangle, double, bool>)BoundaryCollideChk
                : BoundaryDoesntCollideChk;
            List<Tuple<double, double>> lp1 = new List<Tuple<double, double>>() { t1.P1, t1.P2, t1.P3 };
            List<Tuple<double, double>> lp2 = new List<Tuple<double, double>>() { t2.P1, t2.P2, t2.P3 };
 
            // for each edge E of t1
            for (int i = 0; i < 3; i++) {
                var j = (i + 1) % 3;
                // Check all points of t2 lay on the external side of edge E.
                // If they do, the triangles do not overlap.
                if (chkEdge(new Triangle(lp1[i], lp1[j], lp2[0]), eps) &&
                    chkEdge(new Triangle(lp1[i], lp1[j], lp2[1]), eps) &&
                    chkEdge(new Triangle(lp1[i], lp1[j], lp2[2]), eps)) {
                    return false;
                }
            }
 
            // for each edge E of t2
            for (int i = 0; i < 3; i++) {
                var j = (i + 1) % 3;
                // Check all points of t1 lay on the external side of edge E.
                // If they do, the triangles do not overlap.
                if (chkEdge(new Triangle(lp2[i], lp2[j], lp1[0]), eps) &&
                    chkEdge(new Triangle(lp2[i], lp2[j], lp1[1]), eps) &&
                    chkEdge(new Triangle(lp2[i], lp2[j], lp1[2]), eps)) {
                    return false;
                }
            }
 
            // The triangles overlap
            return true;
        }
 
        static void Overlap(Triangle t1, Triangle t2, double eps = 0.0, bool allowReversed = false, bool onBoundary = true) {
            if (TriTri2D(t1, t2, eps, allowReversed, onBoundary)) {
                Console.WriteLine(""overlap"");
            } else {
                Console.WriteLine(""do not overlap"");
            }
        }
 
        static void Main(string[] args) {
            var t1 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(5.0, 0.0), new Tuple<double, double>(0.0, 5.0));
            var t2 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(5.0, 0.0), new Tuple<double, double>(0.0, 6.0));
            Console.WriteLine(""{0} and\n{1}"", t1, t2);
            Overlap(t1, t2);
            Console.WriteLine();
 
            // need to allow reversed for this pair to avoid exception
            t1 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(0.0, 5.0), new Tuple<double, double>(5.0, 0.0));
            t2 = t1;
            Console.WriteLine(""{0} and\n{1}"", t1, t2);
            Overlap(t1, t2, 0.0, true);
            Console.WriteLine();
 
            t1 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(5.0, 0.0), new Tuple<double, double>(0.0, 5.0));
            t2 = new Triangle(new Tuple<double, double>(-10.0, 0.0), new Tuple<double, double>(-5.0, 0.0), new Tuple<double, double>(-1.0, 6.0));
            Console.WriteLine(""{0} and\n{1}"", t1, t2);
            Overlap(t1, t2);
            Console.WriteLine();
 
            t1.P3 = new Tuple<double, double>(2.5, 5.0);
            t2 = new Triangle(new Tuple<double, double>(0.0, 4.0), new Tuple<double, double>(2.5, -1.0), new Tuple<double, double>(5.0, 4.0));
            Console.WriteLine(""{0} and\n{1}"", t1, t2);
            Overlap(t1, t2);
            Console.WriteLine();
 
            t1 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(1.0, 1.0), new Tuple<double, double>(0.0, 2.0));
            t2 = new Triangle(new Tuple<double, double>(2.0, 1.0), new Tuple<double, double>(3.0, 0.0), new Tuple<double, double>(3.0, 2.0));
            Console.WriteLine(""{0} and\n{1}"", t1, t2);
            Overlap(t1, t2);
            Console.WriteLine();
 
            t2 = new Triangle(new Tuple<double, double>(2.0, 1.0), new Tuple<double, double>(3.0, -2.0), new Tuple<double, double>(3.0, 4.0));
            Console.WriteLine(""{0} and\n{1}"", t1, t2);
            Overlap(t1, t2);
            Console.WriteLine();
 
            t1 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(1.0, 0.0), new Tuple<double, double>(0.0, 1.0));
            t2 = new Triangle(new Tuple<double, double>(1.0, 0.0), new Tuple<double, double>(2.0, 0.0), new Tuple<double, double>(1.0, 1.1));
            Console.WriteLine(""{0} and\n{1}"", t1, t2);
            Console.WriteLine(""which have only a single corner in contact, if boundary points collide"");
            Overlap(t1, t2);
            Console.WriteLine();
 
            Console.WriteLine(""{0} and\n{1}"", t1, t2);
            Console.WriteLine(""which have only a single corner in contact, if boundary points do not collide"");
            Overlap(t1, t2, 0.0, false, false);
        }
    }
}",6853,153
62092,http://rosettacode.org/wiki/Determine_if_a_string_has_all_unique_characters,Determine if a string has all unique characters,"Task

Given a character string   (which may be empty, or have a length of zero characters):

   create a function/procedure/routine to:
   determine if all the characters in the string are unique
   indicate if or which character is duplicated and where
   display each string and its length   (as the strings are being examined)
   a zero─length (empty) string shall be considered as unique
   process the strings from left─to─right
   if       unique,   display a message saying such
   if not unique,   then:
   display a message saying such
   display what character is duplicated
   only the 1st non─unique character need be displayed
   display where ""both"" duplicated characters are in the string
   the above messages can be part of a single message
   display the hexadecimal value of the duplicated character


Use (at least) these five test values   (strings):

   a string of length     0   (an empty string)
   a string of length     1   which is a single period   (.)
   a string of length     6   which contains:   abcABC
   a string of length     7   which contains a blank in the middle:   XYZ  ZYX
   a string of length   36   which   doesn't   contain the letter ""oh"":
 1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ


Show all output here on this page.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.Linq;
 
public class Program
{
    static void Main
    {
        string[] input = {"""", ""."", ""abcABC"", ""XYZ ZYX"", ""1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ""};
        foreach (string s in input) {
            Console.WriteLine($""\""{s}\"" (Length {s.Length}) "" +
                string.Join("", "",
                    s.Select((c, i) => (c, i))
                    .GroupBy(t => t.c).Where(g => g.Count() > 1)
                    .Select(g => $""'{g.Key}' (0X{(int)g.Key:X})[{string.Join("", "", g.Select(t => t.i))}]"")
                    .DefaultIfEmpty(""All characters are unique."")
                )
            );
        }
    }
}",653,20
62149,http://rosettacode.org/wiki/Detect_division_by_zero,Detect division by zero,"Task

Write a function to detect a   divide by zero error   without checking if the denominator is zero.



",#C.23,C#,"using System;
 
namespace RosettaCode {
    class Program {
        static void Main(string[] args) {
            int x = 1;
            int y = 0;
            try {
               int z = x / y;
            } catch (DivideByZeroException e) {
                Console.WriteLine(e);
            }
 
        }
    }
}",315,16
62196,http://rosettacode.org/wiki/Delegates,Delegates,"A delegate is a helper object used by another object. The delegator may send the delegate certain messages, and provide a default implementation when there is no delegate or the delegate does not respond to a message. This pattern is heavily used in Cocoa framework on Mac OS X. See also wp:Delegation pattern.

Objects responsibilities:

Delegator:

 Keep an optional delegate instance.
 Implement ""operation"" method, returning the delegate ""thing"" if the delegate respond to ""thing"", or the string ""default implementation"".
Delegate:

 Implement ""thing"" and return the string ""delegate implementation""
Show how objects are created and used. First, without a delegate, then with a delegate that does not implement ""thing"", and last with a delegate that implements ""thing"".
",#C.23,C#,"using System;
 
interface IOperable
{
    string Operate();
}
 
class Inoperable
{
}
 
class Operable : IOperable
{
    public string Operate()
    {
        return ""Delegate implementation."";
    }
}
 
class Delegator : IOperable
{
    object Delegate;
 
    public string Operate()
    {
        var operable = Delegate as IOperable;
        return operable != null ? operable.Operate() : ""Default implementation."";
    }
 
    static void Main()
    {
        var delegator = new Delegator();
        foreach (var @delegate in new object[] { null, new Inoperable(), new Operable() })
        {
            delegator.Delegate = @delegate;
            Console.WriteLine(delegator.Operate());
        }
    }
}",710,39
62256,http://rosettacode.org/wiki/Determine_if_a_string_is_numeric,Determine if a string is numeric,"Task

Create a boolean function which takes in a string and tells whether it is a numeric string (floating point and negative numbers included) in the syntax the language uses for numeric literals or numbers converted from strings.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"public static bool IsNumeric(string s)
{
    double Result;
    return double.TryParse(s, out Result);  // TryParse routines were added in Framework version 2.0.
}        
 
string value = ""123"";
if (IsNumeric(value)) 
{
  // do something
}",240,11
62280,http://rosettacode.org/wiki/Delete_a_file,Delete a file,"Task

Delete a file called ""input.txt"" and delete a directory called ""docs"".

This should be done twice: once ""here"", i.e. in the current working directory and once in the filesystem root.



",#C.23,C#,"using System;
using System.IO;
 
namespace RosettaCode {
    class Program {
        static void Main() {
            try {
                File.Delete(""input.txt"");
                Directory.Delete(""docs"");
                File.Delete(@""\input.txt"");
                Directory.Delete(@""\docs"");
            } catch (Exception exception) {
                Console.WriteLine(exception.Message);
            }
        }
    }
}",425,17
62466,http://rosettacode.org/wiki/Department_numbers,Department numbers,"There is a highly organized city that has decided to assign a number to each of their departments:

   police department
   sanitation department
   fire department 


Each department can have a number between   1   and   7   (inclusive).

The three department numbers are to be unique (different from each other) and must add up to   12.

The Chief of the Police doesn't like odd numbers and wants to have an even number for his department.



Task

Write a computer program which outputs all valid combinations.



Possible output   (for the 1st and 14th solutions):

 --police--  --sanitation--  --fire-- 
     2             3            7 
     6             5            1


",#C.23,C#,"using System;
public class Program
{
    public static void Main() {
        for (int p = 2; p <= 7; p+=2) {
            for (int s = 1; s <= 7; s++) {
                int f = 12 - p - s;
                if (s >= f) break;
                if (f > 7) continue;
                if (s == p || f == p) continue; //not even necessary
                Console.WriteLine($""Police:{p}, Sanitation:{s}, Fire:{f}"");
                Console.WriteLine($""Police:{p}, Sanitation:{f}, Fire:{s}"");
            }
        }
    }
}",512,16
63215,http://rosettacode.org/wiki/Deepcopy,Deepcopy,"Task

Demonstrate how to copy data structures containing complex heterogeneous and cyclic semantics.

This is often referred to as deep copying, and is normally required where structures are mutable and to ensure that independent copies can be manipulated without side-effects.

If this facility is not built into the language, it is permissible to use functions from a common library, or a coded procedure.



The task should show:

 Relevant semantics of structures, such as their homogeneous or heterogeneous properties, or containment of (self- or mutual-reference) cycles.
 Any limitations of the method.
 That the structure and its copy are different.
 Suitable links to external documentation for common libraries.

",#C.23,C#,"using System;
 
namespace prog
{
	class MainClass
	{
		class MyClass : ICloneable
		{
			public MyClass() { f = new int[3]{2,3,5}; c = '1'; }
 
			public object Clone()
			{				
				MyClass cpy = (MyClass) this.MemberwiseClone();
				cpy.f = (int[]) this.f.Clone();			
				return cpy;
			}
 
			public char c;
			public int[] f;
		}
 
		public static void Main( string[] args )
		{
			MyClass c1 = new MyClass();
			MyClass c2 = (MyClass) c1.Clone();
		}
	}
}",459,28
63253,http://rosettacode.org/wiki/Define_a_primitive_data_type,Define a primitive data type,"Demonstrate how to define a type that behaves like an integer but has a lowest valid value of 1 and a highest valid value of 10. Include all bounds checking you need to write, or explain how the compiler or interpreter creates those bounds checks for you.
",#C.23,C#,"using System;
using System.Globalization;
 
struct LimitedInt : IComparable, IComparable<LimitedInt>, IConvertible, IEquatable<LimitedInt>, IFormattable
{
    const int MIN_VALUE = 1;
    const int MAX_VALUE = 10;
 
    public static readonly LimitedInt MinValue = new LimitedInt(MIN_VALUE);
    public static readonly LimitedInt MaxValue = new LimitedInt(MAX_VALUE);
 
    static bool IsValidValue(int value) => value >= MIN_VALUE && value <= MAX_VALUE;
 
    readonly int _value;
    public int Value => this._value == 0 ? MIN_VALUE : this._value; // Treat the default, 0, as being the minimum value.
 
    public LimitedInt(int value)
    {
        if (!IsValidValue(value))
            throw new ArgumentOutOfRangeException(nameof(value), value, $""Value must be between {MIN_VALUE} and {MAX_VALUE}."");
        this._value = value;
    }
 
    #region IComparable
    public int CompareTo(object obj)
    {
        if (obj is LimitedInt l) return this.Value.CompareTo(l);
        throw new ArgumentException(""Object must be of type "" + nameof(LimitedInt), nameof(obj));
    }
    #endregion
 
    #region IComparable<LimitedInt>
    public int CompareTo(LimitedInt other) => this.Value.CompareTo(other.Value);
    #endregion
 
    #region IConvertible
    public TypeCode GetTypeCode() => this.Value.GetTypeCode();
    bool IConvertible.ToBoolean(IFormatProvider provider) => ((IConvertible)this.Value).ToBoolean(provider);
    byte IConvertible.ToByte(IFormatProvider provider) => ((IConvertible)this.Value).ToByte(provider);
    char IConvertible.ToChar(IFormatProvider provider) => ((IConvertible)this.Value).ToChar(provider);
    DateTime IConvertible.ToDateTime(IFormatProvider provider) => ((IConvertible)this.Value).ToDateTime(provider);
    decimal IConvertible.ToDecimal(IFormatProvider provider) => ((IConvertible)this.Value).ToDecimal(provider);
    double IConvertible.ToDouble(IFormatProvider provider) => ((IConvertible)this.Value).ToDouble(provider);
    short IConvertible.ToInt16(IFormatProvider provider) => ((IConvertible)this.Value).ToInt16(provider);
    int IConvertible.ToInt32(IFormatProvider provider) => ((IConvertible)this.Value).ToInt32(provider);
    long IConvertible.ToInt64(IFormatProvider provider) => ((IConvertible)this.Value).ToInt64(provider);
    sbyte IConvertible.ToSByte(IFormatProvider provider) => ((IConvertible)this.Value).ToSByte(provider);
    float IConvertible.ToSingle(IFormatProvider provider) => ((IConvertible)this.Value).ToSingle(provider);
    string IConvertible.ToString(IFormatProvider provider) => this.Value.ToString(provider);
    object IConvertible.ToType(Type conversionType, IFormatProvider provider) => ((IConvertible)this.Value).ToType(conversionType, provider);
    ushort IConvertible.ToUInt16(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt16(provider);
    uint IConvertible.ToUInt32(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt32(provider);
    ulong IConvertible.ToUInt64(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt64(provider);
    #endregion
 
    #region IEquatable<LimitedInt>
    public bool Equals(LimitedInt other) => this == other;
    #endregion
 
    #region IFormattable
    public string ToString(string format, IFormatProvider formatProvider) => this.Value.ToString(format, formatProvider);
    #endregion
 
    #region operators
    public static bool operator ==(LimitedInt left, LimitedInt right) => left.Value == right.Value;
    public static bool operator !=(LimitedInt left, LimitedInt right) => left.Value != right.Value;
    public static bool operator <(LimitedInt left, LimitedInt right) => left.Value < right.Value;
    public static bool operator >(LimitedInt left, LimitedInt right) => left.Value > right.Value;
    public static bool operator <=(LimitedInt left, LimitedInt right) => left.Value <= right.Value;
    public static bool operator >=(LimitedInt left, LimitedInt right) => left.Value >= right.Value;
 
    public static LimitedInt operator ++(LimitedInt left) => (LimitedInt)(left.Value + 1);
    public static LimitedInt operator --(LimitedInt left) => (LimitedInt)(left.Value - 1);
 
    public static LimitedInt operator +(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value + right.Value);
    public static LimitedInt operator -(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value - right.Value);
    public static LimitedInt operator *(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value * right.Value);
    public static LimitedInt operator /(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value / right.Value);
    public static LimitedInt operator %(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value % right.Value);
 
    public static LimitedInt operator &(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value & right.Value);
    public static LimitedInt operator |(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value | right.Value);
    public static LimitedInt operator ^(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value ^ right.Value);
    public static LimitedInt operator ~(LimitedInt left) => (LimitedInt)~left.Value;
 
    public static LimitedInt operator >>(LimitedInt left, int right) => (LimitedInt)(left.Value >> right);
    public static LimitedInt operator <<(LimitedInt left, int right) => (LimitedInt)(left.Value << right);
 
    public static implicit operator int(LimitedInt value) => value.Value;
    public static explicit operator LimitedInt(int value)
    {
        if (!IsValidValue(value)) throw new OverflowException();
        return new LimitedInt(value);
    }
    #endregion
 
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default, IFormatProvider provider = null)
        => this.Value.TryFormat(destination, out charsWritten, format, provider);
 
    public override int GetHashCode() => this.Value.GetHashCode();
    public override bool Equals(object obj) => obj is LimitedInt l && this.Equals(l);
    public override string ToString() => this.Value.ToString();
 
    #region static methods
    public static bool TryParse(ReadOnlySpan<char> s, out int result) => int.TryParse(s, out result);
    public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out int result) => int.TryParse(s, style, provider, out result);
    public static int Parse(string s, IFormatProvider provider) => int.Parse(s, provider);
    public static int Parse(string s, NumberStyles style, IFormatProvider provider) => int.Parse(s, style, provider);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, ref int result) => int.TryParse(s, style, provider, out result);
    public static int Parse(string s) => int.Parse(s);
    public static int Parse(string s, NumberStyles style) => int.Parse(s, style);
    public static int Parse(ReadOnlySpan<char> s, NumberStyles style = NumberStyles.Integer, IFormatProvider provider = null) => int.Parse(s, style, provider);
    public static bool TryParse(string s, ref int result) => int.TryParse(s, out result);
    #endregion
}",7170,115
63303,http://rosettacode.org/wiki/De_Bruijn_sequences,de Bruijn sequences,"The sequences are named after the Dutch mathematician   Nicolaas Govert de Bruijn.



A note on Dutch capitalization:   Nicolaas' last name is   de Bruijn,   the   de   isn't normally capitalized
unless it's the first word in a sentence.   Rosetta Code (more or less by default or by fiat) requires the first word in the task name to be
capitalized.



In combinatorial mathematics,   a   de Bruijn sequence   of order    n    on
a    size-k    alphabet (computer science)    A    is a cyclic sequence in which every
possible    length-n    string (computer science, formal theory)   on    A    occurs
exactly once as a contiguous substring.

Such a sequence is denoted by    B(k, n)    and has
length   kn,   which is also the number of distinct substrings of
length   n   on   A;    

de Bruijn sequences are therefore optimally short.

There are:

                         (k!)k(n-1)   ÷   kn

distinct de Bruijn sequences    B(k, n). 



Task

For this Rosetta Code task,   a   de Bruijn   sequence is to be generated that can be used to shorten a brute-force attack on
a   PIN-like   code lock that does not have an ""enter""
key and accepts the last    n    digits entered.



Note:   automated teller machines (ATMs)   used to work like
this,   but their software has been updated to not allow a brute-force attack.



Example

A   digital door lock   with a 4-digit code would
have B (10, 4) solutions,   with a length of   10,000   (digits).

Therefore, only at most     10,000 + 3     (as the solutions are cyclic or wrap-around)   presses are needed to
open the lock.

Trying all 4-digit codes separately would require   4 × 10,000   or   40,000   presses.



Task requirements

   Generate a de Bruijn sequence for a 4-digit (decimal) PIN code.
   Show the length of the generated de Bruijn sequence.
   (There are many possible de Bruijn sequences that solve this task,   one solution is shown on the discussion page).
   Show the first and last   130   digits of the de Bruijn sequence.
   Verify that all four-digit (decimal)   1,000   PIN codes are contained within the de Bruijn sequence.
   0000, 0001, 0002, 0003,   ...   9996, 9997, 9998, 9999   (note the leading zeros).
   Reverse the de Bruijn sequence.
   Again, perform the (above) verification test.
   Replace the 4,444th digit with a period (.) in the original de Bruijn sequence.
   Perform the verification test (again).   There should be four PIN codes missing.


(The last requirement is to ensure that the verification tests performs correctly.   The verification processes should list
any and all missing PIN codes.)

Show all output here, on this page.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




References

   Wikipedia entry:   de Bruijn sequence.
   MathWorld entry:   de Bruijn sequence.
   An  OEIS  entry:   A166315 lexicographically earliest binary de Bruijn sequences, B(2,n)     --- Not B(10,4),   but possibly relevant.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Text;
 
namespace DeBruijn {
    class Program {
        const string digits = ""0123456789"";
 
        static string DeBruijn(int k, int n) {
            var alphabet = digits.Substring(0, k);
            var a = new byte[k * n];
            var seq = new List<byte>();
            void db(int t, int p) {
                if (t > n) {
                    if (n % p == 0) {
                        seq.AddRange(new ArraySegment<byte>(a, 1, p));
                    }
                } else {
                    a[t] = a[t - p];
                    db(t + 1, p);
                    var j = a[t - p] + 1;
                    while (j < k) {
                        a[t] = (byte)j;
                        db(t + 1, t);
                        j++;
                    }
                }
            }
            db(1, 1);
            var buf = new StringBuilder();
            foreach (var i in seq) {
                buf.Append(alphabet[i]);
            }
            var b = buf.ToString();
            return b + b.Substring(0, n - 1);
        }
 
        static bool AllDigits(string s) {
            foreach (var c in s) {
                if (c < '0' || '9' < c) {
                    return false;
                }
            }
            return true;
        }
 
        static void Validate(string db) {
            var le = db.Length;
            var found = new int[10_000];
            var errs = new List<string>();
            // Check all strings of 4 consecutive digits within 'db'
            // to see if all 10,000 combinations occur without duplication.
            for (int i = 0; i < le - 3; i++) {
                var s = db.Substring(i, 4);
                if (AllDigits(s)) {
                    int.TryParse(s, out int n);
                    found[n]++;
                }
            }
            for (int i = 0; i < 10_000; i++) {
                if (found[i] == 0) {
                    errs.Add(string.Format(""    PIN number {0,4} missing"", i));
                } else if (found[i] > 1) {
                    errs.Add(string.Format(""    PIN number {0,4} occurs {1} times"", i, found[i]));
                }
            }
            var lerr = errs.Count;
            if (lerr == 0) {
                Console.WriteLine(""  No errors found"");
            } else {
                var pl = lerr == 1 ? """" : ""s"";
                Console.WriteLine(""  {0} error{1} found:"", lerr, pl);
                errs.ForEach(Console.WriteLine);
            }
        }
 
        static string Reverse(string s) {
            char[] arr = s.ToCharArray();
            Array.Reverse(arr);
            return new string(arr);
        }
 
        static void Main() {
            var db = DeBruijn(10, 4);
            var le = db.Length;
 
            Console.WriteLine(""The length of the de Bruijn sequence is {0}"", le);
            Console.WriteLine(""\nThe first 130 digits of the de Bruijn sequence are: {0}"", db.Substring(0, 130));
            Console.WriteLine(""\nThe last 130 digits of the de Bruijn sequence are: {0}"", db.Substring(le - 130, 130));
 
            Console.WriteLine(""\nValidating the deBruijn sequence:"");
            Validate(db);
 
            Console.WriteLine(""\nValidating the reversed deBruijn sequence:"");
            Validate(Reverse(db));
 
            var bytes = db.ToCharArray();
            bytes[4443] = '.';
            db = new string(bytes);
            Console.WriteLine(""\nValidating the overlaid deBruijn sequence:"");
            Validate(db);
        }
    }
}",3576,104
63318,http://rosettacode.org/wiki/Deal_cards_for_FreeCell,Deal cards for FreeCell,"Free Cell is the solitaire card game that Paul Alfille introduced to the PLATO system in 1978. Jim Horne, at Microsoft, changed the name to FreeCell and reimplemented the game for DOS, then Windows. 

This version introduced 32000 numbered deals. (The FreeCell FAQ tells this history.)

As the game became popular, Jim Horne disclosed the algorithm, and other implementations of FreeCell began to reproduce the Microsoft deals. 

These deals are numbered from 1 to 32000.
Newer versions from Microsoft have 1 million deals, numbered from 1 to 1000000; some implementations allow numbers outside that range.

The algorithm uses this linear congruential generator from Microsoft C:

 



s
t
a
t

e

n
+
1


≡
214013
×
s
t
a
t

e

n


+
2531011


(
mod


2

31


)



{\displaystyle state_{n+1}\equiv 214013\times state_{n}+2531011{\pmod {2^{31}}}}


 



r
a
n

d

n


=
s
t
a
t

e

n


÷

2

16




{\displaystyle rand_{n}=state_{n}\div 2^{16}}


 



r
a
n

d

n




{\displaystyle rand_{n}}

 is in range 0 to 32767.
 Rosetta Code has another task, linear congruential generator, with code for this RNG in several languages.


The algorithm follows:

 Seed the RNG with the number of the deal.
 Create an array of 52 cards: Ace of Clubs, Ace of Diamonds, Ace of Hearts, Ace of Spades, 2 of Clubs, 2 of Diamonds, and so on through the ranks: Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King. The array indexes are 0 to 51, with Ace of Clubs at 0, and King of Spades at 51.
 Until the array is empty:
 Choose a random card at index ≡ next random number (mod array length).
 Swap this random card with the last card of the array.
 Remove this random card from the array. (Array length goes down by 1.)
 Deal this random card.
 Deal all 52 cards, face up, across 8 columns. The first 8 cards go in 8 columns, the next 8 cards go on the first 8 cards, and so on.


 Order to deal cards

 Game #1

 Game #617


  1  2  3  4  5  6  7  8
 9 10 11 12 13 14 15 16
17 18 19 20 21 22 23 24
25 26 27 28 29 30 31 32
33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48
49 50 51 52

 JD 2D 9H JC 5D 7H 7C 5H
KD KC 9S 5S AD QC KH 3H
2S KS 9D QD JS AS AH 3C
4C 5C TS QH 4H AC 4D 7S
3S TD 4S TH 8H 2C JH 7D
6D 8S 8D QS 6C 3D 8C TC
6S 9C 2H 6H

 7D AD 5C 3S 5S 8C 2D AH
TD 7S QD AC 6D 8H AS KH
TH QC 3H 9D 6S 8D 3D TC
KD 5H 9S 3C 8S 7H 4D JS
4C QS 9C 9H 7C 6H 2C 2S
4S TS 2H 5D JC 6C JH QH
JD KS KC 4H

Deals can also be checked against FreeCell solutions to 1000000 games.
(Summon a video solution, and it displays the initial deal.)

Write a program to take a deal number and deal cards in the same order as this algorithm.
The program may display the cards with ASCII, with Unicode, by drawing graphics, or any other way.

Related tasks:

 Playing cards
 Card shuffles
 War Card_Game
 Poker hand_analyser
 Go Fish

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Text;
 
namespace FreeCellDeals
{
    public class RNG
    {
        private int _state;
 
        public RNG()
        {
            _state = (int)DateTime.Now.Ticks;
        }
 
        public RNG(int n)
        {
            _state = n;
        }
        public int Next()
        {
            return ((_state = 214013 * _state + 2531011) & int.MaxValue) >> 16;
        }
    }
 
    public enum Rank
    {
        Ace,
        One,
        Two,
        Three,
        Four,
        Five,
        Six,
        Seven,
        Eight,
        Nine,
        Ten,
        Jack,
        Queen,
        King
    }
 
    public enum Suit
    {
        Clubs,
        Diamonds,
        Hearts,
        Spades
    }
 
    public class Card
    {
        private const string Ranks = ""A23456789TJQK"";
        private const string Suits = ""CDHS"";
 
        private Rank _rank;
        public Rank Rank
        {
            get
            {
                return _rank;
            }
            set
            {
                if ((int)value < 0 || (int)value > 12)
                {
                    throw new InvalidOperationException(""Setting card rank out of range"");
                }
                _rank = value;
            }
        }
 
        private Suit _suit;
        public Suit Suit
        {
            get
            {
                return _suit;
            }
            set
            {
                if ((int)value < 0 || (int)value > 3)
                {
                    throw new InvalidOperationException(""Setting card rank out of range"");
                }
                _suit = value;
            }
        }
 
        public Card(Rank rank, Suit suit)
        {
            Rank = rank;
            Suit = suit;
        }
 
        public int NRank()
        {
            return (int) Rank;
        }
 
        public int NSuit()
        {
            return (int) Suit;
        }
 
        public override string ToString()
        {
            return new string(new[] {Ranks[NRank()], Suits[NSuit()]});
        }
    }
 
    public class FreeCellDeal
    {
        public List<Card> Deck { get; private set; }
 
        public FreeCellDeal(int iDeal)
        {
            RNG rng = new RNG(iDeal);
 
            List<Card> rDeck = new List<Card>();
            Deck = new List<Card>();
 
            for (int rank = 0; rank < 13; rank++)
            {
                for (int suit = 0; suit < 4; suit++)
                {
                    rDeck.Add(new Card((Rank)rank, (Suit)suit));
                }
            }
 
            // Normally we deal from the front of a deck.  The algorithm ""deals"" from the back so we reverse the
            // deck here to more conventionally deal from the front/start of the array.
            for (int iCard = 51; iCard >= 0; iCard--)
            {
                int iSwap = rng.Next() % (iCard + 1);
                Deck.Add(rDeck[iSwap]);
                rDeck[iSwap] = rDeck[iCard];
            }
        }
 
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            for (int iRow = 0; iRow < 6; iRow++ )
            {
                for (int iCol = 0; iCol < 8; iCol++)
                {
                    sb.AppendFormat(""{0} "", Deck[iRow * 8 + iCol]);
                }
                sb.Append(""\n"");
            }
            for (int iCard = 48; iCard < 52; iCard++)
            {
                sb.AppendFormat(""{0} "", Deck[iCard]);
            }
            return sb.ToString();
        }
    }
 
    class Program
    {
        static void Main()
        {
            Console.WriteLine(new FreeCellDeal(1));
            Console.WriteLine();
            Console.WriteLine(new FreeCellDeal(617));
        }
    }
}",3841,170
63529,http://rosettacode.org/wiki/Date_manipulation,Date manipulation,"Task

Given the date string ""March 7 2009 7:30pm EST"", 

output the time 12 hours later in any human-readable format.

As extra credit, display the resulting time in a time zone different from your own.



",#C.23,C#,"class Program
{
    static void Main(string[] args)
    {
        CultureInfo ci=CultureInfo.CreateSpecificCulture(""en-US"");
        string dateString = ""March 7 2009 7:30pm EST"";
        string format = ""MMMM d yyyy h:mmtt z"";
        DateTime myDateTime = DateTime.ParseExact(dateString.Replace(""EST"",""+6""),format,ci) ;
        DateTime newDateTime = myDateTime.AddHours(12).AddDays(1) ;
        Console.WriteLine(newDateTime.ToString(format).Replace(""-5"",""EST"")); //probably not the best way to do this
 
        Console.ReadLine();
    }
}",543,14
63547,http://rosettacode.org/wiki/Day_of_the_week,Day of the week,"A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).



Task

In what years between 2008 and 2121 will the 25th of December be a Sunday?

Using any standard date handling libraries of your programming language;
compare the dates calculated with the output of other languages to discover any anomalies in the handling of dates which may be due to, for example, overflow in types used to represent dates/times similar to   y2k   type problems.



",#C.23,C#,"using System;
 
class Program
{
    static void Main(string[] args)
    {
        for (int i = 2008; i <= 2121; i++)
        {
            DateTime date = new DateTime(i, 12, 25);
            if (date.DayOfWeek == DayOfWeek.Sunday)
            {
                Console.WriteLine(date.ToString(""dd MMM yyyy""));
            }
        }
    }
}",342,16
63556,http://rosettacode.org/wiki/Cyclotomic_polynomial,Cyclotomic polynomial,"The nth Cyclotomic polynomial, for any positive integer n, is the unique irreducible polynomial of largest degree with integer coefficients that is a divisor of x^n − 1, and is not a divisor of x^k − 1 for any k < n.



Task

 Find and print the first 30 cyclotomic polynomials.
 Find and print the order of the first 10 cyclotomic polynomials that have n or -n as a coefficient.


See also
 Wikipedia article, Cyclotomic polynomial, showing ways to calculate them.
 The sequence A013594 with the smallest order of cyclotomic polynomial containing n or -n as a coefficient.",#C.23,C#,"using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using IntMap = System.Collections.Generic.Dictionary<int, int>;
 
public static class CyclotomicPolynomial
{
    public static void Main2() {
        Console.WriteLine(""Task 1: Cyclotomic polynomials for n <= 30:"");
        for (int i = 1; i <= 30; i++) {
            var p = GetCyclotomicPolynomial(i);
            Console.WriteLine($""CP[{i}] = {p.ToString()}"");
        }
        Console.WriteLine();
 
        Console.WriteLine(""Task 2: Smallest cyclotomic polynomial with n or -n as a coefficient:"");
        for (int i = 1, n = 0; i <= 10; i++) {
            while (true) {
                n++;
                var p = GetCyclotomicPolynomial(n);
                if (p.Any(t => Math.Abs(t.Coefficient) == i)) {
                    Console.WriteLine($""CP[{n}] has coefficient with magnitude = {i}"");
                    n--;
                    break;
                }
            }
        }
    }
 
    private const int MaxFactors = 100_000;
    private const int Algorithm = 2;
    private static readonly Term x = new Term(1, 1);
    private static readonly Dictionary<int, Polynomial> polyCache =
        new Dictionary<int, Polynomial> { [1] = x - 1 };
    private static readonly Dictionary<int, IntMap> factorCache =
        new Dictionary<int, IntMap> { [2] = new IntMap { [2] = 1 } };
 
    private static Polynomial GetCyclotomicPolynomial(in int n) {
        if (polyCache.TryGetValue(n, out var result)) return result;
 
        var factors = GetFactors(n);
        if (factors.ContainsKey(n)) { //n is prime
            result = new Polynomial(from exp in ..n select x[exp]);
        } else if (factors.Count == 2 && factors.Contains(2, 1) && factors.Contains(n/2, 1)) { //n = 2p
            result = new Polynomial(from i in ..(n/2) select (IsOdd(i) ? -x : x)[i]);
        } else if (factors.Count == 1 && factors.TryGetValue(2, out int h)) { //n = 2^h
            result = x[1<<(h-1)] + 1;
        } else if (factors.Count == 1 && !factors.ContainsKey(n)) { // n = p^k
            (int p, int k) = factors.First();
            result = new Polynomial(from i in ..p select x[i * (int)Math.Pow(p, k-1)]);
        } else if (factors.Count == 2 && factors.ContainsKey(2)) { //n = 2^h * p^k
            (int p, int k) = factors.First(entry => entry.Key != 2);
            int twoExp = 1 << (factors[2] - 1);
            result = new Polynomial(from i in ..p select (IsOdd(i) ? -x : x)[i * twoExp * (int)Math.Pow(p, k-1)]);
        } else if (factors.ContainsKey(2) && IsOdd(n/2) && n/2 > 1) { // CP(2m)[x] = CP[-m][x], n is odd > 1
            Polynomial cycloDiv2 = GetCyclotomicPolynomial(n/2);
            result = new Polynomial(from term in cycloDiv2 select IsOdd(term.Exponent) ? -term : term);
            #pragma warning disable CS0162
        } else if (Algorithm == 0) {
            var divisors = GetDivisors(n);
            result = x[n] - 1;
            foreach (int d in divisors) result /= GetCyclotomicPolynomial(d);
        } else if (Algorithm == 1) {
            var divisors = GetDivisors(n).ToList();
            int maxDivisor = divisors.Max();
            result = (x[n] - 1) / (x[maxDivisor] - 1);
            foreach (int d in divisors.Where(div => maxDivisor % div == 0)) {
                result /= GetCyclotomicPolynomial(d);
            }
        } else if (Algorithm == 2) {
            int m = 1;
            result = GetCyclotomicPolynomial(m);
            var primes = factors.Keys.ToList();
            primes.Sort();
            foreach (int prime in primes) {
                var cycloM = result;
                result = new Polynomial(from term in cycloM select term.Coefficient * x[term.Exponent * prime]);
                result /= cycloM;
                m *= prime;
            }
            int s = n / m;
            result = new Polynomial(from term in result select term.Coefficient * x[term.Exponent * s]);
            #pragma warning restore CS0162
        } else {
            throw new InvalidOperationException(""Invalid algorithm"");
        }
        polyCache[n] = result;
        return result;
    }
 
    private static bool IsOdd(int i) => (i & 1) != 0;
    private static bool Contains(this IntMap map, int key, int value) => map.TryGetValue(key, out int v) && v == value;
    private static int GetOrZero(this IntMap map, int key) => map.TryGetValue(key, out int v) ? v : 0;
    private static IEnumerable<T> Select<T>(this Range r, Func<int, T> f) => Enumerable.Range(r.Start.Value, r.End.Value - r.Start.Value).Select(f);
 
    private static IntMap GetFactors(in int n) {
        if (factorCache.TryGetValue(n, out var factors)) return factors;
 
        factors = new IntMap();
        if (!IsOdd(n)) {
            foreach (var entry in GetFactors(n/2)) factors.Add(entry.Key, entry.Value);
            factors[2] = factors.GetOrZero(2) + 1;
            return Cache(n, factors);
        }
        for (int i = 3; i * i <= n; i+=2) {
            if (n % i == 0) {
                foreach (var entry in GetFactors(n/i)) factors.Add(entry.Key, entry.Value);
                factors[i] = factors.GetOrZero(i) + 1;
                return Cache(n, factors);
            }
        }
        factors[n] = 1;
        return Cache(n, factors);
    }
 
    private static IntMap Cache(int n, IntMap factors) {
        if (n < MaxFactors) factorCache[n] = factors;
        return factors;
    }
 
    private static IEnumerable<int> GetDivisors(int n) {
        for (int i = 1; i * i <= n; i++) {
            if (n % i == 0) {
                yield return i;
                int div = n / i;
                if (div != i && div != n) yield return div;
            }
        }
    }
 
    public sealed class Polynomial : IEnumerable<Term>
    {
        public Polynomial() { }
        public Polynomial(params Term[] terms) : this(terms.AsEnumerable()) { }
 
        public Polynomial(IEnumerable<Term> terms) {
            Terms.AddRange(terms);
            Simplify();
        }
 
        private List<Term>? terms;
        private List<Term> Terms => terms ??= new List<Term>();
 
        public int Count => terms?.Count ?? 0;
        public int Degree => Count == 0 ? -1 : Terms[0].Exponent;
        public int LeadingCoefficient => Count == 0 ? 0 : Terms[0].Coefficient;
 
        public IEnumerator<Term> GetEnumerator() => Terms.GetEnumerator();
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
 
        public override string ToString() => Count == 0 ? ""0"" : string.Join("" + "", Terms).Replace(""+ -"", ""- "");
 
        public static Polynomial operator *(Polynomial p, Term t) => new Polynomial(from s in p select s * t);
        public static Polynomial operator +(Polynomial p, Polynomial q) => new Polynomial(p.Terms.Concat(q.Terms));
        public static Polynomial operator -(Polynomial p, Polynomial q) => new Polynomial(p.Terms.Concat(q.Terms.Select(t => -t)));
        public static Polynomial operator *(Polynomial p, Polynomial q) => new Polynomial(from s in p from t in q select s * t);
        public static Polynomial operator /(Polynomial p, Polynomial q) => p.Divide(q).quotient;
 
        public (Polynomial quotient, Polynomial remainder) Divide(Polynomial divisor) {
            if (Degree < 0) return (new Polynomial(), this);
            Polynomial quotient = new Polynomial();
            Polynomial remainder = this;
            int lcv = divisor.LeadingCoefficient;
            int dv = divisor.Degree;
            while (remainder.Degree >= divisor.Degree) {
                int lcr = remainder.LeadingCoefficient;
                Term div = new Term(lcr / lcv, remainder.Degree - dv);
                quotient.Terms.Add(div);
                remainder += divisor * -div;
            }
            quotient.Simplify();
            remainder.Simplify();
            return (quotient, remainder);
        }
 
        private void Simplify() {
            if (Count < 2) return;
            Terms.Sort((a, b) => -a.CompareTo(b));
            for (int i = Terms.Count - 1; i > 0; i--) {
                Term s = Terms[i-1];
                Term t = Terms[i];
                if (t.Exponent == s.Exponent) {
                    Terms[i-1] = new Term(s.Coefficient + t.Coefficient, s.Exponent);
                    Terms.RemoveAt(i);
                }
            }
            Terms.RemoveAll(t => t.IsZero);
        }
 
    }
 
    public readonly struct Term : IEquatable<Term>, IComparable<Term>
    {
        public Term(int coefficient, int exponent = 0) => (Coefficient, Exponent) = (coefficient, exponent);
 
        public Term this[int exponent] => new Term(Coefficient, exponent); //Using x[exp] because x^exp has low precedence
        public int Coefficient { get; }
        public int Exponent { get; }
        public bool IsZero => Coefficient == 0;
 
        public static Polynomial operator +(Term left, Term right) => new Polynomial(left, right);
        public static Polynomial operator -(Term left, Term right) => new Polynomial(left, -right);
        public static implicit operator Term(int coefficient) => new Term(coefficient);
        public static Term operator -(Term t) => new Term(-t.Coefficient, t.Exponent);
        public static Term operator *(Term left, Term right) => new Term(left.Coefficient * right.Coefficient, left.Exponent + right.Exponent);
 
        public static bool operator ==(Term left, Term right) => left.Equals(right);
        public static bool operator !=(Term left, Term right) => !left.Equals(right);
        public static bool operator  <(Term left, Term right) => left.CompareTo(right)  < 0;
        public static bool operator  >(Term left, Term right) => left.CompareTo(right)  > 0;
        public static bool operator <=(Term left, Term right) => left.CompareTo(right) <= 0;
        public static bool operator >=(Term left, Term right) => left.CompareTo(right) >= 0;
 
        public bool Equals(Term other) => Exponent == other.Exponent && Coefficient == other.Coefficient;
        public override bool Equals(object? obj) => obj is Term t && Equals(t);
        public override int GetHashCode() => Coefficient.GetHashCode() * 31 + Exponent.GetHashCode();
 
        public int CompareTo(Term other) {
            int c = Exponent.CompareTo(other.Exponent);
            if (c != 0) return c;
            return Coefficient.CompareTo(other.Coefficient);
        }
 
        public override string ToString() => (Coefficient, Exponent) switch {
            (0,  _) => ""0"",
            (_,  0) => $""{Coefficient}"",
            (1,  1) => ""x"",
            (-1, 1) => ""-x"",
            (_,  1) => $""{Coefficient}x"",
            (1,  _) => $""x^{Exponent}"",
            (-1, _) => $""-x^{Exponent}"",
                    _ => $""{Coefficient}x^{Exponent}""
        };
    }
}",10834,236
63623,http://rosettacode.org/wiki/CUSIP,CUSIP,"

 This page uses content from Wikipedia. The original article was at CUSIP. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



A   CUSIP   is a nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades. The CUSIP was adopted as an American National Standard under Accredited Standards X9.6.



Task

Ensure the last digit   (i.e., the   check digit)   of the CUSIP code (the 1st column) is correct, against the following:

   037833100       Apple Incorporated 
   17275R102       Cisco Systems 
   38259P508       Google Incorporated 
   594918104       Microsoft Corporation 
   68389X106       Oracle Corporation   (incorrect)
   68389X105       Oracle Corporation 


Example pseudo-code below.
algorithm Cusip-Check-Digit(cusip) is
   Input: an 8-character CUSIP
 
   sum := 0
   for 1 ≤ i ≤ 8 do
      c := the ith character of cusip
      if c is a digit then
         v := numeric value of the digit c
      else if c is a letter then
         p := ordinal position of c in the alphabet (A=1, B=2...)
         v := p + 9
      else if c = ""*"" then
         v := 36
      else if c = ""@"" then
         v := 37
      else if' c = ""#"" then
         v := 38
      end if
      if i is even then
         v := v × 2
      end if
 
      sum := sum + int ( v div 10 ) + v mod 10
   repeat
 
   return (10 - (sum mod 10)) mod 10
end function
See related tasks
 
 SEDOL
 ISIN

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace CUSIP {
    class Program {
        static bool IsCusip(string s) {
            if (s.Length != 9) return false;
            int sum = 0;
            for (int i = 0; i <= 7; i++) {
                char c = s[i];
 
                int v;
                if (c >= '0' && c <= '9') {
                    v = c - 48;
                }
                else if (c >= 'A' && c <= 'Z') {
                    v = c - 55;  // lower case letters apparently invalid
                }
                else if (c == '*') {
                    v = 36;
                }
                else if (c == '#') {
                    v = 38;
                }
                else {
                    return false;
                }
                if (i % 2 == 1) v *= 2;  // check if odd as using 0-based indexing
                sum += v / 10 + v % 10;
            }
            return s[8] - 48 == (10 - (sum % 10)) % 10;
        }
 
        static void Main(string[] args) {
            List<string> candidates = new List<string>() {
                ""037833100"",
                ""17275R102"",
                ""38259P508"",
                ""594918104"",
                ""68389X106"",
                ""68389X105""
            };
            foreach (var candidate in candidates) {
                Console.WriteLine(""{0} -> {1}"", candidate, IsCusip(candidate) ? ""correct"" : ""incorrect"");
            }
        }
    }
}",1456,48
63629,http://rosettacode.org/wiki/Damm_algorithm,Damm algorithm,"The Damm algorithm is a checksum algorithm which detects all single digit errors and adjacent transposition errors.



The algorithm is named after H. Michael Damm.



Task

Verify the checksum, stored as last digit of an input.


",#C.23,C#,"using System;
 
namespace DammAlgorithm {
    class Program {
        static int[,] table = {
            {0, 3, 1, 7, 5, 9, 8, 6, 4, 2},
            {7, 0, 9, 2, 1, 5, 4, 8, 6, 3},
            {4, 2, 0, 6, 8, 7, 1, 3, 5, 9},
            {1, 7, 5, 0, 9, 8, 3, 4, 2, 6},
            {6, 1, 2, 3, 0, 4, 5, 9, 7, 8},
            {3, 6, 7, 4, 2, 0, 9, 5, 8, 1},
            {5, 8, 6, 9, 7, 2, 0, 1, 3, 4},
            {8, 9, 4, 5, 3, 6, 2, 0, 1, 7},
            {9, 4, 3, 8, 6, 1, 7, 2, 0, 5},
            {2, 5, 8, 1, 4, 3, 6, 7, 9, 0},
        };
 
        static bool Damm(string s) {
            int interim = 0;
            foreach (char c in s) {
                interim = table[interim, c - '0'];
            }
            return interim == 0;
        }
 
        static void Main(string[] args) {
            int[] numbers = { 5724, 5727, 112946, 112949 };
            foreach (int number in numbers) {
                bool isValid = Damm(number.ToString());
                if (isValid) {
                    Console.WriteLine(""{0,6} is valid"", number);
                }
                else {
                    Console.WriteLine(""{0,6} is invalid"", number);
                }
            }
        }
    }
}",1216,39
63647,http://rosettacode.org/wiki/Currying,Currying,"

 This page uses content from Wikipedia. The original article was at Currying. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Create a simple demonstrative example of Currying in a specific language.

Add any historic details as to how the feature made its way into the language.



",#C.23,C#,"public delegate int Plus(int y); 
public delegate Plus CurriedPlus(int x);
public static CurriedPlus plus = 
      delegate(int x) {return delegate(int y) {return x + y;};};
static void Main()
{
    int sum = plus(3)(4); // sum = 7
    int sum2= plus(2)(plus(3)(4)) // sum2 = 9
}",279,9
63697,http://rosettacode.org/wiki/Date_format,Date format,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.


Task

Display the   current date   in the formats of:

   2007-11-23     and 
   Friday, November 23, 2007

",#C.23,C#,"using System;
 
namespace RosettaCode.DateFormat
{
    class Program
    {
        static void Main(string[] args)
        {
            DateTime today = DateTime.Now.Date;
            Console.WriteLine(today.ToString(""yyyy-MM-dd""));
            Console.WriteLine(today.ToString(""dddd, MMMMM d, yyyy""));
        }
    }
}",321,14
63747,http://rosettacode.org/wiki/Currency,Currency,"Task

Show how to represent currency in a simple example, using a data type that represent exact values of dollars and cents.



Note

The IEEE 754 binary floating point representations of numbers like   2.86   and   .0765   are not exact.

For this example, data will be two items with prices in dollars and cents, a quantity for each, and a tax rate.

Use the values:

 4000000000000000 hamburgers at $5.50 each       (four quadrillion burgers)
 2 milkshakes at $2.86 each, and 
 a tax rate of 7.65%. 


(That number of hamburgers is a 4 with 15 zeros after it.   The number is contrived to exclude naïve task solutions using 64 bit floating point types.)

Compute and output (show results on this page):

 the total price before tax
 the tax
 the total with tax 


The tax value must be computed by rounding to the nearest whole cent and this exact value must be added to the total price before tax.

The output must show dollars and cents with a decimal point.

The three results displayed should be:

 22000000000000005.72
 1683000000000000.44 
 23683000000000006.16 


Dollar signs and thousands separators are optional.



",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace Currency
{
    class Program
    {
        static void Main(string[] args)
        {
            MenuItem hamburger = new MenuItem() { Name = ""Hamburger"", Price = 5.5M };
            MenuItem milkshake = new MenuItem() { Name = ""Milkshake"", Price = 2.86M };
 
            IList<CartItem> cart = new List<CartItem>();
            cart.Add(new CartItem() { item = hamburger, quantity = 4000000000000000 });
            cart.Add(new CartItem() { item = milkshake, quantity = 2 });
 
            decimal total = CalculateTotal(cart);
 
            Console.WriteLine(string.Format(""Total before tax: {0:C}"", total));
 
            // Add Tax
            decimal tax = total * 0.0765M;
 
            Console.WriteLine(string.Format(""Tax: {0:C}"", tax));
 
            total += tax;
 
            Console.WriteLine(string.Format(""Total with tax: {0:C}"", total));
        }
 
        private static decimal CalculateTotal(IList<CartItem> cart)
        {
            decimal total = 0M;
 
            foreach (CartItem item in cart)
            {
                total += item.quantity * item.item.Price;
            }
 
            return total;
        }
 
        private struct MenuItem
        {
            public string Name { get; set; }
            public decimal Price { get; set; }
        }
 
        private struct CartItem
        {
            public MenuItem item { get; set; }
            public decimal quantity { get; set; }
        }
    }
}",1511,55
63901,http://rosettacode.org/wiki/Cuban_primes,Cuban primes,"The name   cuban   has nothing to do with   Cuba  (the country),   but has to do with the
fact that cubes   (3rd powers)   play a role in its definition.



Some definitions of cuban primes

   primes which are the difference of two consecutive cubes.
   primes of the form:   (n+1)3 - n3.
   primes of the form:   n3 - (n-1)3.
   primes   p   such that   n2(p+n)   is a cube for some   n>0.
   primes   p   such that   4p = 1 + 3n2.


Cuban primes were named in 1923 by Allan Joseph Champneys Cunningham.



Task requirements

   show the first   200   cuban primes   (in a multi─line horizontal format).
   show the   100,000th   cuban prime.
   show all cuban primes with commas   (if appropriate).
   show all output here.


Note that   cuban prime   isn't capitalized   (as it doesn't refer to the nation of Cuba).



Also see

   Wikipedia entry:     cuban prime.
   MathWorld entry:   cuban prime.
   The OEIS entry:     A002407.     The   100,000th   cuban prime can be verified in the   2nd   example   on this OEIS web page.

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
static class Program
{
    static List<long> primes = new List<long>() { 3, 5 };
 
     static void Main(string[] args)
    {
        const int cutOff = 200;
        const int bigUn = 100000;
        const int chunks = 50;
        const int little = bigUn / chunks;
        const string tn = "" cuban prime"";
        Console.WriteLine(""The first {0:n0}{1}s:"", cutOff, tn);
        int c = 0;
        bool showEach = true;
        long u = 0, v = 1;
        DateTime st = DateTime.Now;
        for (long i = 1; i <= long.MaxValue; i++)
        {
            bool found = false;
            int mx = System.Convert.ToInt32(Math.Ceiling(Math.Sqrt(v += (u += 6))));
            foreach (long item in primes)
            {
                if (item > mx) break;
                if (v % item == 0) { found = true; break; }
            }
            if (!found)
            {
                c += 1; if (showEach)
                {
                    for (var z = primes.Last() + 2; z <= v - 2; z += 2)
                    {
                        bool fnd = false;
                        foreach (long item in primes)
                        {
                            if (item > mx) break;
                            if (z % item == 0) { fnd = true; break; }
                        }
                        if (!fnd) primes.Add(z);
                    }
                    primes.Add(v); Console.Write(""{0,11:n0}"", v);
                    if (c % 10 == 0) Console.WriteLine();
                    if (c == cutOff)
                    {
                        showEach = false;
                        Console.Write(""\nProgress to the {0:n0}th{1}: "", bigUn, tn);
                    }
                }
                if (c % little == 0) { Console.Write("".""); if (c == bigUn) break; }
            }
        }
        Console.WriteLine(""\nThe {1:n0}th{2} is {0,17:n0}"", v, c, tn);
        Console.WriteLine(""Computation time was {0} seconds"", (DateTime.Now - st).TotalSeconds);
        if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();
    }
}",2129,59
63918,http://rosettacode.org/wiki/Cumulative_standard_deviation,Cumulative standard deviation,"Task[edit]
Write a stateful function, class, generator or co-routine that takes a series of floating point numbers, one at a time, and returns the running standard deviation of the series.

The task implementation should use the most natural programming style of those listed for the function in the implementation language; the task must state which is being used.

Do not apply Bessel's correction; the returned standard deviation should always be computed as if the sample seen so far is the entire population.



Test case

Use this to compute the standard deviation of this demonstration set, 



{
2
,
4
,
4
,
4
,
5
,
5
,
7
,
9
}


{\displaystyle \{2,4,4,4,5,5,7,9\}}

, which is 



2


{\displaystyle 2}

.



Related tasks

 Random numbers


Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace standardDeviation
{
    class Program
    {
        static void Main(string[] args)
        {
            List<double> nums = new List<double> { 2, 4, 4, 4, 5, 5, 7, 9 };
            for (int i = 1; i <= nums.Count; i++)            
                Console.WriteLine(sdev(nums.GetRange(0, i)));
        }
 
        static double sdev(List<double> nums)
        {
            List<double> store = new List<double>();
            foreach (double n in nums)
                store.Add((n - nums.Average()) * (n - nums.Average()));           
 
            return Math.Sqrt(store.Sum() / store.Count);
        }
    }
}",693,25
63921,http://rosettacode.org/wiki/CSV_data_manipulation,CSV data manipulation,"CSV spreadsheet files are suitable for storing tabular data in a relatively portable way.

The CSV format is flexible but somewhat ill-defined.

For present purposes, authors may assume that the data fields contain no commas, backslashes, or quotation marks.



Task

Read a CSV file, change some values and save the changes back to a file.

For this task we will use the following CSV file:

C1,C2,C3,C4,C5
1,5,9,13,17
2,6,10,14,18
3,7,11,15,19
4,8,12,16,20

Suggestions


 Show how to add a column, headed 'SUM', of the sums of the rows.
 If possible, illustrate the use of built-in or standard functions, methods, or libraries, that handle generic CSV files.


",#C.23,C#,"using System.IO;
using System.Linq;
 
namespace CSV_data_manipulation
{
    class Program
    {
        static void Main()
        {
            var input = File.ReadAllLines(""test_in.csv"");
            var output = input.Select((line, i) =>
            {
                if (i == 0)
                    return line + "",SUM"";
                var sum = line.Split(',').Select(int.Parse).Sum();
                return line + "","" + sum;
            }).ToArray();
            File.WriteAllLines(""test_out.csv"", output);
        }
    }
}
 ",535,22
64059,http://rosettacode.org/wiki/CRC-32,CRC-32,"

Task

Demonstrate a method of deriving the Cyclic Redundancy Check from within the language.



The result should be in accordance with ISO 3309, ITU-T V.42, Gzip and PNG.

Algorithms are described on Computation of CRC in Wikipedia.
This variant of CRC-32 uses LSB-first order, sets the initial CRC to FFFFFFFF16, and complements the final CRC.

For the purpose of this task, generate a CRC-32 checksum for the ASCII encoded string:

 The quick brown fox jumps over the lazy dog

",#C.23,C#," 
    /// <summary>
    /// Performs 32-bit reversed cyclic redundancy checks.
    /// </summary>
    public class Crc32
    {
        #region Constants
        /// <summary>
        /// Generator polynomial (modulo 2) for the reversed CRC32 algorithm. 
        /// </summary>
        private const UInt32 s_generator = 0xEDB88320;
        #endregion
 
        #region Constructors
        /// <summary>
        /// Creates a new instance of the Crc32 class.
        /// </summary>
        public Crc32()
        {
            // Constructs the checksum lookup table. Used to optimize the checksum.
            m_checksumTable = Enumerable.Range(0, 256).Select(i =>
            {
                var tableEntry = (uint)i;
                for (var j = 0; j < 8; ++j)
                {
                    tableEntry = ((tableEntry & 1) != 0)
                        ? (s_generator ^ (tableEntry >> 1)) 
                        : (tableEntry >> 1);
                }
                return tableEntry;
            }).ToArray();
        }
        #endregion
 
        #region Methods
        /// <summary>
        /// Calculates the checksum of the byte stream.
        /// </summary>
        /// <param name=""byteStream"">The byte stream to calculate the checksum for.</param>
        /// <returns>A 32-bit reversed checksum.</returns>
        public UInt32 Get<T>(IEnumerable<T> byteStream)
        {
            try
            {
                // Initialize checksumRegister to 0xFFFFFFFF and calculate the checksum.
                return ~byteStream.Aggregate(0xFFFFFFFF, (checksumRegister, currentByte) => 
                          (m_checksumTable[(checksumRegister & 0xFF) ^ Convert.ToByte(currentByte)] ^ (checksumRegister >> 8)));
            }
            catch (FormatException e)
            {
                throw new CrcException(""Could not read the stream out as bytes."", e);
            }
            catch (InvalidCastException e)
            {
                throw new CrcException(""Could not read the stream out as bytes."", e);
            }
            catch (OverflowException e)
            {
                throw new CrcException(""Could not read the stream out as bytes."", e);
            }
        }
        #endregion
 
        #region Fields
        /// <summary>
        /// Contains a cache of calculated checksum chunks.
        /// </summary>
        private readonly UInt32[] m_checksumTable;
 
        #endregion
    }
 ",2455,72
64230,http://rosettacode.org/wiki/Cramer%27s_rule,Cramer's rule,"linear algebra
Cramer's rule
system of linear equations


Given


 




{





a

1


x
+

b

1


y
+

c

1


z


=



d

1









a

2


x
+

b

2


y
+

c

2


z


=



d

2









a

3


x
+

b

3


y
+

c

3


z


=



d

3












{\displaystyle \left\{{\begin{matrix}a_{1}x+b_{1}y+c_{1}z&={\color {red}d_{1}}\\a_{2}x+b_{2}y+c_{2}z&={\color {red}d_{2}}\\a_{3}x+b_{3}y+c_{3}z&={\color {red}d_{3}}\end{matrix}}\right.}




which in matrix format is



 





[




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





]




[



x




y




z



]


=


[






d

1











d

2











d

3







]


.


{\displaystyle {\begin{bmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{bmatrix}}{\begin{bmatrix}x\\y\\z\end{bmatrix}}={\begin{bmatrix}{\color {red}d_{1}}\\{\color {red}d_{2}}\\{\color {red}d_{3}}\end{bmatrix}}.}




Then the values of 



x
,
y


{\displaystyle x,y}

 and 



z


{\displaystyle z}

 can be found as follows:







x
=



|






d

1







b

1





c

1









d

2







b

2





c

2









d

3







b

3





c

3





|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



,

y
=



|




a

1







d

1







c

1







a

2







d

2







c

2







a

3







d

3







c

3





|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



,

 and 

z
=



|




a

1





b

1







d

1









a

2





b

2







d

2









a

3





b

3







d

3







|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



.


{\displaystyle x={\frac {\begin{vmatrix}{\color {red}d_{1}}&b_{1}&c_{1}\\{\color {red}d_{2}}&b_{2}&c_{2}\\{\color {red}d_{3}}&b_{3}&c_{3}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}},\quad y={\frac {\begin{vmatrix}a_{1}&{\color {red}d_{1}}&c_{1}\\a_{2}&{\color {red}d_{2}}&c_{2}\\a_{3}&{\color {red}d_{3}}&c_{3}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}},{\text{ and }}z={\frac {\begin{vmatrix}a_{1}&b_{1}&{\color {red}d_{1}}\\a_{2}&b_{2}&{\color {red}d_{2}}\\a_{3}&b_{3}&{\color {red}d_{3}}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}}.}






Task
Given the following system of equations:









{



2
w
−
x
+
5
y
+
z
=
−
3




3
w
+
2
x
+
2
y
−
6
z
=
−
32




w
+
3
x
+
3
y
−
z
=
−
47




5
w
−
2
x
−
3
y
+
3
z
=
49








{\displaystyle {\begin{cases}2w-x+5y+z=-3\\3w+2x+2y-6z=-32\\w+3x+3y-z=-47\\5w-2x-3y+3z=49\\\end{cases}}}




solve for 



w


{\displaystyle w}

, 



x


{\displaystyle x}

, 



y


{\displaystyle y}

 and 



z


{\displaystyle z}

, using Cramer's rule.



",#C.23,C#,"using System;
using System.Collections.Generic;
using static System.Linq.Enumerable;
 
public static class CramersRule
{
    public static void Main() {
        var equations = new [] {
            new [] { 2, -1,  5,  1,  -3 },
            new [] { 3,  2,  2, -6, -32 },
            new [] { 1,  3,  3, -1, -47 },
            new [] { 5, -2, -3,  3,  49 }
        };
        var solution = SolveCramer(equations);
        Console.WriteLine(solution.DelimitWith("", ""));
    }
 
    public static int[] SolveCramer(int[][] equations) {
        int size = equations.Length;
        if (equations.Any(eq => eq.Length != size + 1)) throw new ArgumentException($""Each equation must have {size+1} terms."");
        int[,] matrix = new int[size, size];
        int[] column = new int[size];
        for (int r = 0; r < size; r++) {
            column[r] = equations[r][size];
            for (int c = 0; c < size; c++) {
                matrix[r, c] = equations[r][c];
            }
        }
        return Solve(new SubMatrix(matrix, column));
    }
 
    private static int[] Solve(SubMatrix matrix) {
        int det = matrix.Det();
        if (det == 0) throw new ArgumentException(""The determinant is zero."");
 
        int[] answer = new int[matrix.Size];
        for (int i = 0; i < matrix.Size; i++) {
            matrix.ColumnIndex = i;
            answer[i] = matrix.Det() / det;
        }
        return answer;
    }
 
    //Extension method from library.
    static string DelimitWith<T>(this IEnumerable<T> source, string separator = "" "") =>
        string.Join(separator ?? "" "", source ?? Empty<T>());
 
    private class SubMatrix
    {
        private int[,] source;
        private SubMatrix prev;
        private int[] replaceColumn;
 
        public SubMatrix(int[,] source, int[] replaceColumn) {
            this.source = source;
            this.replaceColumn = replaceColumn;
            this.prev = null;
            this.ColumnIndex = -1;
            Size = replaceColumn.Length;
        }
 
        private SubMatrix(SubMatrix prev, int deletedColumnIndex = -1) {
            this.source = null;
            this.prev = prev;
            this.ColumnIndex = deletedColumnIndex;
            Size = prev.Size - 1;
        }
 
        public int ColumnIndex { get; set; }
        public int Size { get; }
 
        public int this[int row, int column] {
            get {
                if (source != null) return column == ColumnIndex ? replaceColumn[row] : source[row, column];
                return prev[row + 1, column < ColumnIndex ? column : column + 1];
            }
        }
 
        public int Det() {
            if (Size == 1) return this[0, 0];
            if (Size == 2) return this[0, 0] * this[1, 1] - this[0, 1] * this[1, 0];
            SubMatrix m = new SubMatrix(this);
            int det = 0;
            int sign = 1;
            for (int c = 0; c < Size; c++) {
                m.ColumnIndex = c;
                int d = m.Det();
                det += this[0, c] * d * sign;
                sign = -sign;
            }
            return det;
        }
 
        public void Print() {
            for (int r = 0; r < Size; r++) {
                Console.WriteLine(Range(0, Size).Select(c => this[r, c]).DelimitWith("", ""));
            }
            Console.WriteLine();
        }
    }
 
}",3335,102
64245,http://rosettacode.org/wiki/Create_a_two-dimensional_array_at_runtime,Create a two-dimensional array at runtime,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
Get two integers from the user, then create a two-dimensional array where the two dimensions have the sizes given by those numbers, and which can be accessed in the most natural way possible. Write some element of that array, and then output that element. Finally destroy the array if not done by the language itself.
",#C.23,C#," 
class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(""Enter two integers. Space delimited please: "");
            string s = Console.ReadLine();
 
            int[,] myArray=new int[(int)s[0],(int)s[2]];
            myArray[0, 0] = 2;
            Console.WriteLine(myArray[0, 0]);
 
            Console.ReadLine();
        }
    }",379,15
64316,http://rosettacode.org/wiki/CSV_to_HTML_translation,CSV to HTML translation,"Consider a simplified CSV format where all rows are separated by a newline
and all columns are separated by commas.

No commas are allowed as field data, but the data may contain
other characters and character sequences that would
normally be   escaped   when converted to HTML



Task

Create a function that takes a string representation of the CSV data
and returns a text string of an HTML table representing the CSV data.

Use the following data as the CSV text to convert, and show your output.

 Character,Speech
 The multitude,The messiah! Show us the messiah!
 Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>
 The multitude,Who are you?
 Brians mother,I'm his mother; that's who!
 The multitude,Behold his mother! Behold his mother!


Extra credit

Optionally allow special formatting for the first row of the table as if it is the tables header row
(via <thead> preferably; CSS if you must).



",#C.23,C#," 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
 
    class Program
    {
        private static string ConvertCsvToHtmlTable(string csvText)
        {
            //split the CSV, assume no commas or line breaks in text
            List<List<string>> splitString = new List<List<string>>();
            List<string> lineSplit = csvText.Split('\n').ToList();
            foreach (string line in lineSplit)
            {
                splitString.Add(line.Split(',').ToList());
            }
 
            //encode text safely, and create table
            string tableResult = ""<table>"";
            foreach(List<string> splitLine in splitString)
            {
                tableResult += ""<tr>"";
                foreach(string splitText in splitLine)
                {
                    tableResult += ""<td>"" + WebUtility.HtmlEncode(splitText) + ""</td>"";
                }
                tableResult += ""</tr>"";
            }
            tableResult += ""</table>"";
            return tableResult;
        }
    }
 ",1062,34
64373,http://rosettacode.org/wiki/Create_a_file,Create a file,"In this task, the job is to create a new empty file called ""output.txt"" of size 0 bytes
and an empty directory called ""docs"". This should be done twice: once ""here"", i.e. in the current working directory and once in the filesystem root.
",#C.23,C#,"using System;
using System.IO;
 
class Program {
    static void Main(string[] args) {
        File.Create(""output.txt"");
        File.Create(@""\output.txt"");
 
        Directory.CreateDirectory(""docs"");
        Directory.CreateDirectory(@""\docs"");
    }
}",256,12
64391,http://rosettacode.org/wiki/Count_the_coins,Count the coins,"There are four types of common coins in   US   currency:

   quarters   (25 cents)
   dimes   (10 cents)
   nickels   (5 cents),   and 
   pennies   (1 cent) 


There are six ways to make change for 15 cents:

   A dime and a nickel 
   A dime and 5 pennies
   3 nickels
   2 nickels and 5 pennies
   A nickel and 10 pennies
   15 pennies


Task

How many ways are there to make change for a dollar using these common coins?     (1 dollar = 100 cents).



Optional

Less common are dollar coins (100 cents);   and very rare are half dollars (50 cents).   With the addition of these two coins, how many ways are there to make change for $1000?

(Note:   the answer is larger than   232).



References

 an algorithm from the book Structure and Interpretation of Computer Programs.
 an article in the algorithmist.
 Change-making problem on Wikipedia.

",#C.23,C#," 
    // Adapted from http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/
    class Program
    {
        static long Count(int[] C, int m, int n)
        {
            var table = new long[n + 1];
            table[0] = 1;
            for (int i = 0; i < m; i++)
                for (int j = C[i]; j <= n; j++)
                    table[j] += table[j - C[i]];
            return table[n];
        }
        static void Main(string[] args)
        {
            var C = new int[] { 1, 5, 10, 25 };
            int m = C.Length;
            int n = 100;
            Console.WriteLine(Count(C, m, n));  //242
            Console.ReadLine();
        }
    }
 ",672,23
64495,http://rosettacode.org/wiki/Create_an_HTML_table,Create an HTML table,"Create an HTML table.

 The table body should have at least three rows of three columns.
 Each of these three columns should be labelled ""X"", ""Y"", and ""Z"". 
 An extra column should be added at either the extreme left or the extreme right of the table that has no heading, but is filled with sequential row numbers. 
 The rows of the ""X"", ""Y"", and ""Z"" columns should be filled with random or sequential integers having 4 digits or less. 
 The numbers should be aligned in the same fashion for all columns.

",#C.23,C#,"using System;
using System.Text;
 
namespace prog
{
	class MainClass
	{		
		public static void Main (string[] args)
		{
			StringBuilder s = new StringBuilder();
			Random rnd = new Random();
 
			s.AppendLine(""<table>"");
			s.AppendLine(""<thead align = \""right\"">"");
			s.Append(""<tr><th></th>"");
			for(int i=0; i<3; i++)
				s.Append(""<td>"" + ""XYZ""[i] + ""</td>"");
			s.AppendLine(""</tr>"");
			s.AppendLine(""</thead>"");
			s.AppendLine(""<tbody align = \""right\"">"");
			for( int i=0; i<3; i++ )
			{
				s.Append(""<tr><td>""+i+""</td>"");
				for( int j=0; j<3; j++ )
					s.Append(""<td>""+rnd.Next(10000)+""</td>"");				
				s.AppendLine(""</tr>"");
			}
			s.AppendLine(""</tbody>"");
			s.AppendLine(""</table>"");
 
			Console.WriteLine( s );
		}
	}
}",744,34
64542,http://rosettacode.org/wiki/Count_in_factors,Count in factors,"Task

Write a program which counts up from   1,   displaying each number as the multiplication of its prime factors.

For the purpose of this task,   1   (unity)   may be shown as itself.



Example

      2   is prime,   so it would be shown as itself.

      6   is not prime;   it would be shown as   



2
×
3


{\displaystyle 2\times 3}

.
2144   is not prime;   it would be shown as   



2
×
2
×
2
×
2
×
2
×
67


{\displaystyle 2\times 2\times 2\times 2\times 2\times 67}

.



Related tasks

   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace prog
{
	class MainClass
	{
		public static void Main (string[] args)
		{
			for( int i=1; i<=22; i++ )
			{				
				List<int> f = Factorize(i);
				Console.Write( i + "":  "" + f[0] );
				for( int j=1; j<f.Count; j++ )
				{
					Console.Write( "" * "" + f[j] );
				}
				Console.WriteLine();
			}
		}
 
		public static List<int> Factorize( int n )
		{
			List<int> l = new List<int>();
 
			if ( n == 1 )
			{
				l.Add(1);
			}
			else
			{
				int k = 2;
				while( n > 1 ) 
				{
					while( n % k == 0 )
					{
						l.Add( k );
						n /= k;
					}
					k++;
				}
			}			
			return l;
		}	
	}
}",659,46
64563,http://rosettacode.org/wiki/Count_occurrences_of_a_substring,Count occurrences of a substring,"Task

Create a function,   or show a built-in function,   to count the number of non-overlapping occurrences of a substring inside a string.

The function should take two arguments:

   the first argument being the string to search,   and 
   the second a substring to be searched for. 


It should return an integer count.

print countSubstring(""the three truths"",""th"")
3
 
// do not count substrings that overlap with previously-counted substrings:
print countSubstring(""ababababab"",""abab"")
2
The matching should yield the highest number of non-overlapping matches.

In general, this essentially means matching from left-to-right or right-to-left   (see proof on talk page).




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
 
class SubStringTestClass
{
   public static int CountSubStrings(this string testString, string testSubstring)
   {
        int count = 0;
 
        if (testString.Contains(testSubstring))
        {
            for (int i = 0; i < testString.Length; i++)
            {
                if (testString.Substring(i).Length >= testSubstring.Length)
                {
                    bool equals = testString.Substring(i, testSubstring.Length).Equals(testSubstring);
                    if (equals)
                    {
                        count++;
                        i += testSubstring.Length - 1;  // Fix: Don't count overlapping matches
                    }
                }
            }
        }
        return count;
   }
}",756,26
64566,http://rosettacode.org/wiki/Count_in_octal,Count in octal,"Task

Produce a sequential count in octal,   starting at zero,   and using an increment of a one for each consecutive number.

Each number should appear on a single line,   and the program should count until terminated,   or until the maximum value of the numeric type in use is reached.



Related task

   Integer sequence   is a similar task without the use of octal numbers.

",#C.23,C#,"using System;
 
class Program
{
    static void Main()
    {
        var number = 0;
        do
        {
            Console.WriteLine(Convert.ToString(number, 8));
        } while (++number > 0);
    }
}",205,13
65478,http://rosettacode.org/wiki/Copy_stdin_to_stdout,Copy stdin to stdout,"Create an executable file that copies stdin to stdout, or else a script that does so through the invocation of an interpreter at the command line.
",#C.23,C#," 
using System;
 
class Program
{
    static void Main(string[] args)
    {
        Console.OpenStandardInput().CopyTo(Console.OpenStandardOutput());
    }
}
 ",159,11
65564,http://rosettacode.org/wiki/Continued_fraction/Arithmetic/Construct_from_rational_number,Continued fraction/Arithmetic/Construct from rational number,"Continued fraction arithmetic
The purpose of this task is to write a function 





r
2
c
f


(

i
n
t



{\displaystyle {\mathit {r2cf}}(\mathrm {int} }

 




N

1


,

i
n
t



{\displaystyle N_{1},\mathrm {int} }

 




N

2


)


{\displaystyle N_{2})}

, or 





r
2
c
f


(

F
r
a
c
t
i
o
n



{\displaystyle {\mathit {r2cf}}(\mathrm {Fraction} }

 



N
)


{\displaystyle N)}

, which will output a continued fraction assuming:






N

1




{\displaystyle N_{1}}

 is the numerator





N

2




{\displaystyle N_{2}}

 is the denominator
The function should output its results one digit at a time each time it is called, in a manner sometimes described as lazy evaluation.

To achieve this it must determine: the integer part; and remainder part, of 




N

1




{\displaystyle N_{1}}

 divided by 




N

2




{\displaystyle N_{2}}

. It then sets 




N

1




{\displaystyle N_{1}}

 to 




N

2




{\displaystyle N_{2}}

 and 




N

2




{\displaystyle N_{2}}

 to the determined remainder part. It then outputs the determined integer part. It does this until 




a
b
s

(

N

2


)


{\displaystyle \mathrm {abs} (N_{2})}

 is zero.

Demonstrate the function by outputing the continued fraction for:

 1/2
 3
 23/8
 13/11
 22/7
 -151/77






2




{\displaystyle {\sqrt {2}}}

 should approach 



[
1
;
2
,
2
,
2
,
2
,
…
]


{\displaystyle [1;2,2,2,2,\ldots ]}

 try ever closer rational approximations until boredom gets the better of you:

 14142,10000
 141421,100000
 1414214,1000000
 14142136,10000000
Try :

 31,10
 314,100
 3142,1000
 31428,10000
 314285,100000
 3142857,1000000
 31428571,10000000
 314285714,100000000
Observe how this rational number behaves differently to 





2




{\displaystyle {\sqrt {2}}}

 and convince yourself that, in the same way as 



3.7


{\displaystyle 3.7}

 may be represented as 



3.70


{\displaystyle 3.70}

 when an extra decimal place is required, 



[
3
;
7
]


{\displaystyle [3;7]}

 may be represented as 



[
3
;
7
,
∞
]


{\displaystyle [3;7,\infty ]}

 when an extra term is required.
",#C.23,C#,"using System;
using System.Collections.Generic;
 
class Program
{
    static IEnumerable<int> r2cf(int n1, int n2)
    {
        while (Math.Abs(n2) > 0)
        {
            int t1 = n1 / n2;
            int t2 = n2;
            n2 = n1 - t1 * n2;
            n1 = t2;
            yield return t1;
        }
    }
 
    static void spit(IEnumerable<int> f)
    {
        foreach (int n in f) Console.Write("" {0}"", n);
        Console.WriteLine();
    }
 
    static void Main(string[] args)
    {
        spit(r2cf(1, 2));
        spit(r2cf(3, 1));
        spit(r2cf(23, 8));
        spit(r2cf(13, 11));
        spit(r2cf(22, 7));
        spit(r2cf(-151, 77));
        for (int scale = 10; scale <= 10000000; scale *= 10)
        {
            spit(r2cf((int)(Math.Sqrt(2) * scale), scale));
        }
        spit(r2cf(31, 10));
        spit(r2cf(314, 100)); 
        spit(r2cf(3142, 1000));
        spit(r2cf(31428, 10000));
        spit(r2cf(314285, 100000));
        spit(r2cf(3142857, 1000000));
        spit(r2cf(31428571, 10000000));
        spit(r2cf(314285714, 100000000));
    }
}
 ",1094,46
65570,http://rosettacode.org/wiki/Convert_decimal_number_to_rational,Convert decimal number to rational,"This task has been flagged for clarification. Code on this page in its current state may be flagged incorrect once this task has been clarified. See this page's Talk page for discussion.


The task is to write a program to transform a decimal number into a fraction in lowest terms.

It is not always possible to do this exactly. For instance, while rational numbers can be converted to decimal representation, some of them need an infinite number of digits to be represented exactly in decimal form. Namely, repeating decimals such as 1/3 = 0.333...

Because of this, the following fractions cannot be obtained (reliably) unless the language has some way of representing repeating decimals:

 67 / 74 = 0.9(054) = 0.9054054...
 14 / 27 = 0.(518) = 0.518518...

Acceptable output:

 0.9054054 → 4527027 / 5000000
 0.518518 → 259259 / 500000

Finite decimals are of course no problem:

 0.75 → 3 / 4 

",#C.23,C#,"using System;
using System.Text;
 
namespace RosettaDecimalToFraction
{
    public class Fraction
    {
        public Int64 Numerator;
        public Int64 Denominator;
        public Fraction(double f, Int64 MaximumDenominator = 4096)
        {
            /* Translated from the C version. */
            /*  a: continued fraction coefficients. */
            Int64 a;
            var h = new Int64[3] { 0, 1, 0 };
            var k = new Int64[3] { 1, 0, 0 };
            Int64 x, d, n = 1;
            int i, neg = 0;
 
            if (MaximumDenominator <= 1)
            {
                Denominator = 1;
                Numerator = (Int64)f;
                return;
            }
 
            if (f < 0) { neg = 1; f = -f; }
 
            while (f != Math.Floor(f)) { n <<= 1; f *= 2; }
            d = (Int64)f;
 
            /* continued fraction and check denominator each step */
            for (i = 0; i < 64; i++)
            {
                a = (n != 0) ? d / n : 0;
                if ((i != 0) && (a == 0)) break;
 
                x = d; d = n; n = x % n;
 
                x = a;
                if (k[1] * a + k[0] >= MaximumDenominator)
                {
                    x = (MaximumDenominator - k[0]) / k[1];
                    if (x * 2 >= a || k[1] >= MaximumDenominator)
                        i = 65;
                    else
                        break;
                }
 
                h[2] = x * h[1] + h[0]; h[0] = h[1]; h[1] = h[2];
                k[2] = x * k[1] + k[0]; k[0] = k[1]; k[1] = k[2];
            }
            Denominator = k[1];
            Numerator = neg != 0 ? -h[1] : h[1];
        }
        public override string ToString()
        {
            return string.Format(""{0} / {1}"", Numerator, Denominator);
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Console.OutputEncoding = UTF8Encoding.UTF8;
            foreach (double d in new double[] { 0.9054054, 0.518518, 0.75, 0.4285714, 0.833333,
                0.90909, 3.14159265358979, 2.7182818284590451 })
            {
                var f = new Fraction(d, d >= 2 ? 65536 : 4096);
                Console.WriteLine(""{0,20} → {1}"", d, f);
 
            }
        }
    }
}
 ",2252,76
65665,http://rosettacode.org/wiki/Copy_a_string,Copy a string,"This task is about copying a string.



Task

Where it is relevant, distinguish between copying the contents of a string
versus making an additional reference to an existing string.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"string src = ""Hello"";
string dst = src;",39,2
65705,http://rosettacode.org/wiki/Constrained_genericity,Constrained genericity,"Constrained genericity or bounded quantification means
that a parametrized type or function (see parametric polymorphism)
can only be instantiated on types fulfilling some conditions,
even if those conditions are not used in that function.

Say a type is called ""eatable"" if you can call the function eat on it.
Write a generic type FoodBox which contains a collection of objects of
a type given as parameter, but can only be instantiated on eatable types.
The FoodBox shall not use the function eat in any way (i.e. without the explicit restriction, it could be instantiated on any type).
The specification of a type being eatable should be as generic as possible
in your language (i.e. the restrictions on the implementation of eatable types
should be as minimal as possible).
Also explain the restrictions, if any, on the implementation of eatable types,
and show at least one example of an eatable type.
",#C.23,C#,"interface IEatable
{
    void Eat();
}",38,4
65717,http://rosettacode.org/wiki/Consecutive_primes_with_ascending_or_descending_differences,Consecutive primes with ascending or descending differences,"Task




Find and display here on this page, the longest sequence of consecutive prime numbers where the differences between the primes are strictly ascending.


Do the same for sequences of primes where the differences are strictly descending.



In both cases, show the sequence for primes   <   1,000,000.



If there are multiple sequences of the same length, only the first need be shown.


",#C.23,C#,"using System.Linq;
using System.Collections.Generic;
using TG = System.Tuple<int, int>;
using static System.Console;
 
class Program
{
    static void Main(string[] args)
    {
        const int mil = (int)1e6;
        foreach (var amt in new int[] { 1, 2, 6, 12, 18 })
        {
            int lmt = mil * amt, lg = 0, ng, d, ld = 0;
            var desc = new string[] { ""A"", """", ""De"" };
            int[] mx = new int[] { 0, 0, 0 },
                  bi = new int[] { 0, 0, 0 },
                   c = new int[] { 2, 2, 2 };
            WriteLine(""For primes up to {0:n0}:"", lmt);
            var pr = PG.Primes(lmt).ToArray();
            for (int i = 0; i < pr.Length; i++)
            {
                ng = pr[i].Item2; d = ng.CompareTo(lg) + 1;
                if (ld == d)
                    c[2 - d]++;
                else
                {
                    if (c[d] > mx[d]) { mx[d] = c[d]; bi[d] = i - mx[d] - 1; }
                    c[d] = 2;
                }
                ld = d; lg = ng;
            }
            for (int r = 0; r <= 2; r += 2)
            {
                Write(""{0}scending, found run of {1} consecutive primes:\n  {2} "",
                    desc[r], mx[r] + 1, pr[bi[r]++].Item1);
                foreach (var itm in pr.Skip(bi[r]).Take(mx[r]))
                    Write(""({0}) {1} "", itm.Item2, itm.Item1); WriteLine(r == 0 ? """" : ""\n"");
            }
        }
    }
}
 
class PG
{
    public static IEnumerable<TG> Primes(int lim)
    {
        bool[] flags = new bool[lim + 1];
        int j = 3, lj = 2;
        for (int d = 8, sq = 9; sq <= lim; j += 2, sq += d += 8)
            if (!flags[j])
            {
                yield return new TG(j, j - lj);
                lj = j;
                for (int k = sq, i = j << 1; k <= lim; k += i) flags[k] = true;
            }
        for (; j <= lim; j += 2)
            if (!flags[j])
            {
                yield return new TG(j, j - lj);
                lj = j;
            }
    }
}",1996,63
65733,http://rosettacode.org/wiki/Convert_seconds_to_compound_duration,Convert seconds to compound duration,"Task

Write a function or program which:

   takes a positive integer representing a duration in seconds as input (e.g., 100), and
   returns a string which shows the same duration decomposed into:
   weeks,
   days, 
   hours, 
   minutes,   and 
   seconds.
This is detailed below (e.g., ""2 hr, 59 sec"").



Demonstrate that it passes the following three test-cases:

Test Cases


 input number

 output string


 7259

 2 hr, 59 sec


 86400

 1 d


 6000000

 9 wk, 6 d, 10 hr, 40 min

Details
The following five units should be used:



 unit

 suffix used in output

 conversion


 week

 wk

 1 week = 7 days


 day

 d

 1 day = 24 hours


 hour

 hr

 1 hour = 60 minutes


 minute

 min

 1 minute = 60 seconds


 second

 sec



However, only include quantities with non-zero values in the output (e.g., return ""1 d"" and not ""0 wk, 1 d, 0 hr, 0 min, 0 sec"").

Give larger units precedence over smaller ones as much as possible (e.g., return 2 min, 10 sec and not 1 min, 70 sec or 130 sec)

Mimic the formatting shown in the test-cases (quantities sorted from largest unit to smallest and separated by comma+space; value and unit of each quantity separated by space).



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace ConvertSecondsToCompoundDuration
{
  class Program
  {
    static void Main( string[] args )
    {
      foreach ( string arg in args )
      {
        int duration ;
        bool isValid = int.TryParse( arg , out duration ) ;
 
        if ( !isValid     ) { Console.Error.WriteLine( ""ERROR: Not an integer: {0}""           , arg ) ; }
        if ( duration < 0 ) { Console.Error.WriteLine( ""ERROR: duration must be non-negative"" , arg ) ; }
 
        Console.WriteLine();
        Console.WriteLine( ""{0:#,##0} seconds ==> {1}"" , duration , FormatAsDuration(duration) ) ;
 
      }
    }
 
    private static string FormatAsDuration( int duration )
    {
      if ( duration < 0 ) throw new ArgumentOutOfRangeException(""duration"") ;
      return string.Join( "", "" , GetDurationParts(duration)  ) ;
    }
 
    private static IEnumerable<string> GetDurationParts( int duration )
    {
      var parts = new[]
      {
        new { Name=""wk"" , Length = 7*24*60*60*1 , } ,
        new { Name=""d""  , Length =   24*60*60*1 , } ,
        new { Name=""h""  , Length =      60*60*1 , } ,
        new { Name=""m""  , Length =         60*1 , } ,
        new { Name=""s""  , Length =            1 , } ,
      } ;
 
      foreach ( var part in parts )
      {
        int n = Math.DivRem( duration , part.Length , out duration ) ;
        if ( n > 0 ) yield return string.Format( ""{0} {1}"" , n , part.Name ) ;
      }
 
    }
 
  }
 
}",1495,52
65761,http://rosettacode.org/wiki/Continued_fraction,Continued fraction,"continued fraction
Mathworld





a

0


+









b

1












a

1


+









b

2












a

2


+









b

3












a

3


+
⋱

















{\displaystyle a_{0}+{\cfrac {b_{1}}{a_{1}+{\cfrac {b_{2}}{a_{2}+{\cfrac {b_{3}}{a_{3}+\ddots }}}}}}}


The task is to write a program which generates such a number and prints a real representation of it. The code should be tested by calculating and printing the square root of 2, Napier's Constant, and Pi, using the following coefficients:

For the square root of 2, use 




a

0


=
1


{\displaystyle a_{0}=1}

 then 




a

N


=
2


{\displaystyle a_{N}=2}

. 




b

N




{\displaystyle b_{N}}

 is always 



1


{\displaystyle 1}

.







2


=
1
+








1









2
+








1









2
+








1









2
+
⋱

















{\displaystyle {\sqrt {2}}=1+{\cfrac {1}{2+{\cfrac {1}{2+{\cfrac {1}{2+\ddots }}}}}}}


For Napier's Constant, use 




a

0


=
2


{\displaystyle a_{0}=2}

, then 




a

N


=
N


{\displaystyle a_{N}=N}

. 




b

1


=
1


{\displaystyle b_{1}=1}

 then 




b

N


=
N
−
1


{\displaystyle b_{N}=N-1}

.





e
=
2
+








1









1
+








1









2
+








2









3
+








3









4
+
⋱






















{\displaystyle e=2+{\cfrac {1}{1+{\cfrac {1}{2+{\cfrac {2}{3+{\cfrac {3}{4+\ddots }}}}}}}}}


For Pi, use 




a

0


=
3


{\displaystyle a_{0}=3}

 then 




a

N


=
6


{\displaystyle a_{N}=6}

. 




b

N


=
(
2
N
−
1

)

2




{\displaystyle b_{N}=(2N-1)^{2}}

.





π
=
3
+








1









6
+








9









6
+








25









6
+
⋱

















{\displaystyle \pi =3+{\cfrac {1}{6+{\cfrac {9}{6+{\cfrac {25}{6+\ddots }}}}}}}




See also

   Continued fraction/Arithmetic for tasks that do arithmetic over continued fractions.

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace ContinuedFraction {
    class Program {
        static double Calc(Func<int, int[]> f, int n) {
            double temp = 0.0;
            for (int ni = n; ni >= 1; ni--) {
                int[] p = f(ni);
                temp = p[1] / (p[0] + temp);
            }
            return f(0)[0] + temp;
        }
 
        static void Main(string[] args) {
            List<Func<int, int[]>> fList = new List<Func<int, int[]>>();
            fList.Add(n => new int[] { n > 0 ? 2 : 1, 1 });
            fList.Add(n => new int[] { n > 0 ? n : 2, n > 1 ? (n - 1) : 1 });
            fList.Add(n => new int[] { n > 0 ? 6 : 3, (int) Math.Pow(2 * n - 1, 2) });
 
            foreach (var f in fList) {
                Console.WriteLine(Calc(f, 200));
            }
        }
    }
}",833,26
65825,http://rosettacode.org/wiki/Convex_hull,Convex hull,"Find the points which form a convex hull from a set of arbitrary two dimensional points.

For example, given the points (16,3), (12,17), (0,6), (-4,-6), (16,6), (16,-7), (16,-3), (17,-4), (5,19), (19,-8), (3,16), (12,13), (3,-4), (17,5), (-3,15), (-3,-9), (0,11), (-9,-3), (-4,-2) and (12,10) the convex hull would be (-9,-3), (-3,-9), (19,-8), (17,5), (12,17), (5,19) and (-3,15).




See also
 Convex Hull (youtube)
 http://www.geeksforgeeks.org/convex-hull-set-2-graham-scan/

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace ConvexHull {
    class Point : IComparable<Point> {
        private int x, y;
 
        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
 
        public int X { get => x; set => x = value; }
        public int Y { get => y; set => y = value; }
 
        public int CompareTo(Point other) {
            return x.CompareTo(other.x);
        }
 
        public override string ToString() {
            return string.Format(""({0}, {1})"", x, y);
        }
    }
 
    class Program {
        private static List<Point> ConvexHull(List<Point> p) {
            if (p.Count == 0) return new List<Point>();
            p.Sort();
            List<Point> h = new List<Point>();
 
            // lower hull
            foreach (var pt in p) {
                while (h.Count >= 2 && !Ccw(h[h.Count - 2], h[h.Count - 1], pt)) {
                    h.RemoveAt(h.Count - 1);
                }
                h.Add(pt);
            }
 
            // upper hull
            int t = h.Count + 1;
            for (int i = p.Count - 1; i >= 0; i--) {
                Point pt = p[i];
                while (h.Count >= t && !Ccw(h[h.Count - 2], h[h.Count - 1], pt)) {
                    h.RemoveAt(h.Count - 1);
                }
                h.Add(pt);
            }
 
            h.RemoveAt(h.Count - 1);
            return h;
        }
 
        private static bool Ccw(Point a, Point b, Point c) {
            return ((b.X - a.X) * (c.Y - a.Y)) > ((b.Y - a.Y) * (c.X - a.X));
        }
 
        static void Main(string[] args) {
            List<Point> points = new List<Point>() {
                new Point(16, 3),
                new Point(12, 17),
                new Point(0, 6),
                new Point(-4, -6),
                new Point(16, 6),
 
                new Point(16, -7),
                new Point(16, -3),
                new Point(17, -4),
                new Point(5, 19),
                new Point(19, -8),
 
                new Point(3, 16),
                new Point(12, 13),
                new Point(3, -4),
                new Point(17, 5),
                new Point(-3, 15),
 
                new Point(-3, -9),
                new Point(0, 11),
                new Point(-9, -3),
                new Point(-4, -2),
                new Point(12, 10)
            };
 
            List<Point> hull = ConvexHull(points);
            Console.Write(""Convex Hull: ["");
            for (int i = 0; i < hull.Count; i++) {
                if (i > 0) {
                    Console.Write("", "");
                }
                Point pt = hull[i];
                Console.Write(pt);
            }
            Console.WriteLine(""]"");
        }
    }
}",2756,96
65848,http://rosettacode.org/wiki/Constrained_random_points_on_a_circle,Constrained random points on a circle,"Task

Generate 100 <x,y> coordinate pairs such that x and y are integers sampled from the uniform distribution with the condition that 




10
≤



x

2


+

y

2




≤
15


{\displaystyle 10\leq {\sqrt {x^{2}+y^{2}}}\leq 15}

. 
Then display/plot them. The outcome should be a ""fuzzy"" circle. The actual number of points plotted may be less than 100, given that some pairs may be generated more than once.

There are several possible approaches to accomplish this. Here are two possible algorithms.

1) Generate random pairs of integers and filter out those that don't satisfy this condition:





10
≤



x

2


+

y

2




≤
15


{\displaystyle 10\leq {\sqrt {x^{2}+y^{2}}}\leq 15}

.
2) Precalculate the set of all possible points (there are 404 of them) and select randomly from this set.



",#C.23,C#,"using System;
using System.Diagnostics;
using System.Drawing;
 
namespace RosettaConstrainedRandomCircle
{
    class Program
    {
        static void Main(string[] args)
        {
            var points = new Point[404];
            int i = 0;
            for (int y = -15; y <= 15; y++)
                for (int x = -15; x <= 15 && i < 404; x++)
                {
                    var c = Math.Sqrt(x * x + y * y);
                    if (10 <= c && c <= 15)
                    {
                        points[i++] = new Point(x, y);
                    }
                }
 
            var bm = new Bitmap(600, 600);
            var g = Graphics.FromImage(bm);
            var brush = new SolidBrush(Color.Magenta);
 
            var r = new System.Random();
            for (int count = 0; count < 100; count++)
            {
                var p = points[r.Next(404)];
                g.FillEllipse(brush, new Rectangle(290 + 19 * p.X, 290 + 19 * p.Y, 10, 10));
            }
            const string filename = ""Constrained Random Circle.png"";
            bm.Save(filename);
            Process.Start(filename);
        }
    }
}",1142,38
65990,http://rosettacode.org/wiki/Concurrent_computing,Concurrent computing,"Task

Using either native language concurrency syntax or freely available libraries, write a program to display the strings ""Enjoy"" ""Rosetta"" ""Code"", one string per line, in random order.

Concurrency syntax must use threads, tasks, co-routines, or whatever concurrency is called in your language.



",#C.23,C#," 
static Random tRand = new Random();
 
static void Main(string[] args)
{
	Thread t = new Thread(new ParameterizedThreadStart(WriteText));
	t.Start(""Enjoy"");
 
	t = new Thread(new ParameterizedThreadStart(WriteText));
	t.Start(""Rosetta"");
 
	t = new Thread(new ParameterizedThreadStart(WriteText));
	t.Start(""Code"");
 
	Console.ReadLine();
}
 
private static void WriteText(object p)
{
	Thread.Sleep(tRand.Next(1000, 4000));
	Console.WriteLine(p);
}
 ",451,23
66054,http://rosettacode.org/wiki/Compound_data_type,Compound data type,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.


Task

Create a compound data type:

  Point(x,y) 



A compound data type is one that holds multiple independent values.



Related task

   Enumeration


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#C.23,C#,"struct Point
{
  public int x, y;
  public Point(int x, int y) {
    this.x = x;
    this.y = y;
  }
}",102,8
66188,http://rosettacode.org/wiki/Compile-time_calculation,Compile-time calculation,"Some programming languages allow calculation of values at compile time.



Task

Calculate    10!    (ten factorial)   at compile time.

Print the result when the program is run.

Discuss what limitations apply to compile-time calculations in your language.



",#C.23,C#,"using System;
 
public static class Program
{
    public const int FACTORIAL_10 = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1;
    static void Main()
    {
        Console.WriteLine(FACTORIAL_10);
    }
}",199,10
66520,http://rosettacode.org/wiki/Commatizing_numbers,Commatizing numbers,"Commatizing   numbers (as used here, is a handy expedient made-up word) is the act of adding commas to a number (or string), or to the numeric part of a larger string.



Task

Write a function that takes a string as an argument with optional arguments or parameters (the format of parameters/options is left to the programmer) that in general, adds commas (or some
other characters, including blanks or tabs) to the first numeric part of a string (if it's suitable for commatizing as per the rules below), and returns that newly commatized string.

Some of the commatizing rules (specified below) are arbitrary, but they'll be a part of this task requirements, if only to make the results consistent amongst national preferences and other disciplines.

The number may be part of a larger (non-numeric) string such as:

   «US$1744 millions»       ──or──
   ±25000 motes.


The string may possibly not have a number suitable for commatizing, so it should be untouched and no error generated.

If any argument (option) is invalid, nothing is changed and no error need be generated (quiet execution, no fail execution).   Error message generation is optional.

The exponent part of a number is never commatized.   The following string isn't suitable for commatizing:   9.7e+12000

Leading zeroes are never commatized.   The string   0000000005714.882   after commatization is:   0000000005,714.882

Any   period   (.)   in a number is assumed to be a   decimal point.

The original string is never changed   except   by the addition of commas   [or whatever character(s) is/are used for insertion], if at all.

To wit, the following should be preserved:

   leading signs (+, -)       ── even superfluous signs
   leading/trailing/embedded blanks, tabs, and other whitespace 
   the case (upper/lower) of the exponent indicator, e.g.:   4.8903d-002


Any exponent character(s) should be supported:

   1247e12
   57256.1D-4
   4444^60
   7500∙10**35
   8500x10**35
   9500↑35
   +55000↑3
   1000**100
   2048²
   409632
   10000pow(pi)

Numbers may be terminated with any non-digit character, including subscripts and/or superscript:   41421356243   or   7320509076(base 24).

The character(s) to be used for the comma can be specified, and may contain blanks, tabs, and other whitespace characters, as well as multiple characters.   The default is the comma (,) character.

The   period length   can be specified   (sometimes referred to as ""thousands"" or ""thousands separators"").   The   period length   can be defined as the length (or number) of the decimal digits between commas.   The default period length is   3.

 E.G.:   in this example, the   period length   is five:   56789,12340,14148
The location of where to start the scanning for the target field (the numeric part) should be able to be specified.   The default is   1.

The character strings below may be placed in a file (and read) or stored as simple strings within the program.



Strings to be used as a minimum

The value of   pi   (expressed in base 10)   should be separated with blanks every   5   places past the decimal point,

the Zimbabwe dollar amount should use a decimal point for the ""comma"" separator:

   pi=3.14159265358979323846264338327950288419716939937510582097494459231
   The author has two Z$100000000000000 Zimbabwe notes (100 trillion).
   ""-in Aus$+1411.8millions""
   ===US$0017440 millions=== (in 2000 dollars)
   123.e8000 is pretty big.
   The land area of the earth is 57268900(29% of the surface) square miles.
   Ain't no numbers in this here words, nohow, no way, Jose.
   James was never known as 0000000007
   Arthur Eddington wrote: I believe there are 15747724136275002577605653961181555468044717914527116709366231425076185631031296 protons in the universe.
   ␢␢␢$-140000±100 millions.
   6/9/1946 was a good year for some.

where the penultimate string has three leading blanks   (real blanks are to be used).



Also see

 The Wiki entry:   (sir) Arthur Eddington's number of protons in the universe. 

",#C.23,C#," 
static string[] inputs = {
	""pi=3.14159265358979323846264338327950288419716939937510582097494459231"",
	""The author has two Z$100000000000000 Zimbabwe notes (100 trillion)."",
	""\""-in Aus$+1411.8millions\"""",
	""===US$0017440 millions=== (in 2000 dollars)""
};
 
void Main()
{
	inputs.Select(s => Commatize(s, 0, 3, "",""))
              .ToList()
              .ForEach(Console.WriteLine);
}
 
string Commatize(string text, int startPosition, int interval, string separator)
{
	var matches = Regex.Matches(text.Substring(startPosition), ""[0-9]*"");
	var x = matches.Cast<Match>().Select(match => Commatize(match, interval, separator, text)).ToList();
	return string.Join("""", x);
}
 
 
string Commatize(Match match, int interval, string separator, string original)
{
	if (match.Length <= interval)
		return original.Substring(match.Index, 
                match.Index == original.Length ? 0 : Math.Max(match.Length, 1));
 
	return string.Join(separator, match.Value.Split(interval));
}
 
public static class Extension
{
	public static string[] Split(this string source, int interval)
	{
		return SplitImpl(source, interval).ToArray();
	}
 
	static IEnumerable<string>SplitImpl(string source, int interval)
	{
		for	(int i = 1; i < source.Length; i++)
		{
			if (i % interval != 0) continue;
 
			yield return source.Substring(i - interval, interval);
		}
	}
}
 ",1355,50
66527,http://rosettacode.org/wiki/Compare_length_of_two_strings,Compare length of two strings,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Given two strings of different length, determine which string is longer or shorter. Print both strings and their length, one on each line. Print the longer one first.

Measure the length of your string in terms of bytes or characters, as appropriate for your language. If your language doesn't have an operator for measuring the length of a string, note it.

Extra credit

Given more than two strings:

list = [""abcd"",""123456789"",""abcdef"",""1234567""]

Show the strings in descending length order.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace example
{
    class Program
    {
        static void Main(string[] args)
        {
            var strings = new string[] { ""abcd"", ""123456789"", ""abcdef"", ""1234567"" };
            compareAndReportStringsLength(strings);
        }
 
        private static void compareAndReportStringsLength(string[] strings)
        {
            if (strings.Length > 0)
            {
                char Q = '""';
                string hasLength = "" has length "";
                string predicateMax = "" and is the longest string"";
                string predicateMin = "" and is the shortest string"";
                string predicateAve = "" and is neither the longest nor the shortest string"";
                string predicate;
 
                (int, int)[] li = new (int, int)[strings.Length];
                for (int i = 0; i < strings.Length; i++)
                    li[i] = (strings[i].Length, i);
                Array.Sort(li, ((int, int) a, (int, int) b) => b.Item1 - a.Item1);
                int maxLength = li[0].Item1;
                int minLength = li[strings.Length - 1].Item1;
 
                for (int i = 0; i < strings.Length; i++)
                {
                    int length = li[i].Item1;
                    string str = strings[li[i].Item2];
                    if (length == maxLength)
                        predicate = predicateMax;
                    else if (length == minLength)
                        predicate = predicateMin;
                    else
                        predicate = predicateAve;
                    Console.WriteLine(Q + str + Q + hasLength + length + predicate);
                }
            }
        }
 
    }
}
 ",1727,49
66529,http://rosettacode.org/wiki/Conway%27s_Game_of_Life,Conway's Game of Life,"The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.

Conway's game of life is described   here:

A cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.

We calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:

   C   N                 new C
   1   0,1             ->  0  # Lonely
   1   4,5,6,7,8       ->  0  # Overcrowded
   1   2,3             ->  1  # Lives
   0   3               ->  1  # It takes three to give birth!
   0   0,1,2,4,5,6,7,8 ->  0  # Barren

Assume cells beyond the boundary are always dead.

The ""game"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.



Task

Although you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.



References

   Its creator John Conway, explains   the game of life.   Video from numberphile on youtube.
   John Conway   Inventing Game of Life   - Numberphile video.


Related task

   Langton's ant   - another well known cellular automaton.

",#C.23,C#," 
using System;
using System.Text;
using System.Threading;
 
namespace ConwaysGameOfLife
{
    // Plays Conway's Game of Life on the console with a random initial state.
    class Program
    {
        // The delay in milliseconds between board updates.
        private const int DELAY = 50;
 
        // The cell colors.
        private const ConsoleColor DEAD_COLOR = ConsoleColor.White;
        private const ConsoleColor LIVE_COLOR = ConsoleColor.Black;
 
        // The color of the cells that are off of the board.
        private const ConsoleColor EXTRA_COLOR = ConsoleColor.Gray;
 
        private const char EMPTY_BLOCK_CHAR = ' ';
        private const char FULL_BLOCK_CHAR = '\u2588';
 
        // Holds the current state of the board.
        private static bool[,] board;
 
        // The dimensions of the board in cells.
        private static int width = 32;
        private static int height = 32;
 
        // True if cell rules can loop around edges.
        private static bool loopEdges = true;
 
 
        static void Main(string[] args)
        {
            // Use initializeRandomBoard for a larger, random board.
            initializeDemoBoard();
 
            initializeConsole();
 
            // Run the game until the Escape key is pressed.
            while (!Console.KeyAvailable || Console.ReadKey(true).Key != ConsoleKey.Escape) {
                Program.drawBoard();
                Program.updateBoard();
 
                // Wait for a bit between updates.
                Thread.Sleep(DELAY);
            }
        }
 
        // Sets up the Console.
        private static void initializeConsole()
        {
            Console.BackgroundColor = EXTRA_COLOR;
            Console.Clear();
 
            Console.CursorVisible = false;
 
            // Each cell is two characters wide.
            // Using an extra row on the bottom to prevent scrolling when drawing the board.
            int width = Math.Max(Program.width, 8) * 2 + 1;
            int height = Math.Max(Program.height, 8) + 1;
            Console.SetWindowSize(width, height);
            Console.SetBufferSize(width, height);
 
            Console.BackgroundColor = DEAD_COLOR;
            Console.ForegroundColor = LIVE_COLOR;
        }
 
        // Creates the initial board with a random state.
        private static void initializeRandomBoard()
        {
            var random = new Random();
 
            Program.board = new bool[Program.width, Program.height];
            for (var y = 0; y < Program.height; y++) {
                for (var x = 0; x < Program.width; x++) {
                    // Equal probability of being true or false.
                    Program.board[x, y] = random.Next(2) == 0;
                }
            }
        }
 
        // Creates a 3x3 board with a blinker.
        private static void initializeDemoBoard()
        {
            Program.width = 3;
            Program.height = 3;
 
            Program.loopEdges = false;
 
            Program.board = new bool[3, 3];
            Program.board[1, 0] = true;
            Program.board[1, 1] = true;
            Program.board[1, 2] = true;
        }
 
        // Draws the board to the console.
        private static void drawBoard()
        {
            // One Console.Write call is much faster than writing each cell individually.
            var builder = new StringBuilder();
 
            for (var y = 0; y < Program.height; y++) {
                for (var x = 0; x < Program.width; x++) {
                    char c = Program.board[x, y] ? FULL_BLOCK_CHAR : EMPTY_BLOCK_CHAR;
 
                    // Each cell is two characters wide.
                    builder.Append(c);
                    builder.Append(c);
                }
                builder.Append('\n');
            }
 
            // Write the string to the console.
            Console.SetCursorPosition(0, 0);
            Console.Write (builder.ToString());
        }
 
        // Moves the board to the next state based on Conway's rules.
        private static void updateBoard()
        {
            // A temp variable to hold the next state while it's being calculated.
            bool[,] newBoard = new bool[Program.width, Program.height];
 
            for (var y = 0; y < Program.height; y++) {
                for (var x = 0; x < Program.width; x++) {
                    var n = countLiveNeighbors(x, y);
                    var c = Program.board[x, y];
 
                    // A live cell dies unless it has exactly 2 or 3 live neighbors.
                    // A dead cell remains dead unless it has exactly 3 live neighbors.
                    newBoard[x, y] = c && (n == 2 || n == 3) || !c && n == 3;
                }
            }
 
            // Set the board to its new state.
            Program.board = newBoard;
        }
 
        // Returns the number of live neighbors around the cell at position (x,y).
        private static int countLiveNeighbors(int x, int y)
        {
            // The number of live neighbors.
            int value = 0;
 
            // This nested loop enumerates the 9 cells in the specified cells neighborhood.
            for (var j = -1; j <= 1; j++) {
                // If loopEdges is set to false and y+j is off the board, continue.
                if (!Program.loopEdges && y + j < 0 || y + j >= Program.height) {
                    continue;
                }
 
                // Loop around the edges if y+j is off the board.
                int k = (y + j + Program.height) % Program.height;
 
                for (var i = -1; i <= 1; i++) {
                    // If loopEdges is set to false and x+i is off the board, continue.
                    if (!Program.loopEdges && x + i < 0 || x + i >= Program.width) {
                        continue;
                    }
 
                    // Loop around the edges if x+i is off the board.
                    int h = (x + i + Program.width) % Program.width;
 
                    // Count the neighbor cell at (h,k) if it is alive.
                    value += Program.board[h, k] ? 1 : 0;
                }
            }
 
            // Subtract 1 if (x,y) is alive since we counted it as a neighbor.
            return value - (Program.board[x, y] ? 1 : 0);
        }
    }
}
 
 ",6283,178
66652,http://rosettacode.org/wiki/Compare_a_list_of_strings,Compare a list of strings,"Task

Given a   list   of arbitrarily many strings, show how to:

   test if they are all lexically equal
   test if every string is lexically less than the one after it (i.e. whether the list is in strict ascending order)


Each of those two tests should result in a single true or false value, which could be used as the condition of an    if    statement or similar.

If the input list has less than two elements, the tests should always return true.

There is no need to provide a complete program and output.

Assume that the strings are already stored in an array/list/sequence/tuple variable (whatever is most idiomatic) with the name   strings,   and just show the expressions for performing those two tests on it (plus of course any includes and custom functions etc. that it needs),   with as little distractions as possible.

Try to write your solution in a way that does not modify the original list,   but if it does then please add a note to make that clear to readers.

If you need further guidance/clarification,   see #Perl and #Python for solutions that use implicit short-circuiting loops,   and #Raku for a solution that gets away with simply using a built-in language feature. 




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"public static (bool lexicallyEqual, bool strictlyAscending) CompareAListOfStrings(List<string> strings) =>
    strings.Count < 2 ? (true, true) :
    (
        strings.Distinct().Count() < 2,
        Enumerable.Range(1, strings.Count - 1).All(i => string.Compare(strings[i-1], strings[i]) < 0)
    );",300,6
66707,http://rosettacode.org/wiki/Compiler/lexical_analyzer,Compiler/lexical analyzer,"Definition from Wikipedia:

 Lexical analysis is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of tokens (strings with an identified ""meaning""). A program that performs lexical analysis may be called a lexer, tokenizer, or scanner (though ""scanner"" is also used to refer to the first stage of a lexer).
Task[edit]
Create a lexical analyzer for the simple programming language specified below. The
program should read input from a file and/or stdin, and write output to a file and/or
stdout. If the language being used has a lexer module/library/class, it would be great
if two versions of the solution are provided: One without the lexer module, and one with.

Input Specification
The simple programming language to be analyzed is more or less a subset of C. It supports the following tokens:

Operators


 Name 
 Common name 
 Character sequence


 Op_multiply 
 multiply 
 *


 Op_divide 
 divide 
 /


 Op_mod 
 mod 
 %


 Op_add 
 plus 
 +


 Op_subtract 
 minus 
 -


 Op_negate 
 unary minus 
 -


 Op_less 
 less than 
 <


 Op_lessequal 
 less than or equal 
 <=


 Op_greater 
 greater than 
 >


 Op_greaterequal 
 greater than or equal 
 >=


 Op_equal 
 equal 
 ==


 Op_notequal 
 not equal 
 !=


 Op_not 
 unary not 
 !


 Op_assign 
 assignment 
 =


 Op_and 
 logical and 
 &&


 Op_or 
 logical or 
 ¦¦

 The - token should always be interpreted as Op_subtract by the lexer. Turning some Op_subtract into Op_negate will be the job of the syntax analyzer, which is not part of this task.
Symbols


 Name 
 Common name 
 Character


 LeftParen 
 left parenthesis 
 (


 RightParen 
 right parenthesis 
 )


 LeftBrace 
 left brace 
 {


 RightBrace 
 right brace 
 }


 Semicolon 
 semi-colon 
 ;


 Comma 
 comma 
 ,

Keywords


 Name 
 Character sequence


 Keyword_if 
 if


 Keyword_else 
 else


 Keyword_while 
 while


 Keyword_print 
 print


 Keyword_putc 
 putc

Identifiers and literals
These differ from the the previous tokens, in that each occurrence of them has a value associated with it.



 Name

 Common name

 Format description

 Format regex

 Value


 Identifier

 identifier

 one or more letter/number/underscore characters, but not starting with a number

 [_a-zA-Z][_a-zA-Z0-9]*

 as is


 Integer

 integer literal

 one or more digits

 [0-9]+

 as is, interpreted as a number


 Integer

 char literal

 exactly one character (anything except newline or single quote) or one of the allowed escape sequences, enclosed by single quotes

 '([^'\n]|\\n|\\\\)'

 the ASCII code point number of the character, e.g. 65 for 'A' and 10 for '\n'


 String

 string literal

 zero or more characters (anything except newline or double quote), enclosed by double quotes

 ""[^""\n]*""

 the characters without the double quotes and with escape sequences converted

 For char and string literals, the \n escape sequence is supported to represent a new-line character.
 For char and string literals, to represent a backslash, use \\.
 No other special sequences are supported. This means that:
 Char literals cannot represent a single quote character (value 39).
 String literals cannot represent strings containing double quote characters.
Zero-width tokens


 Name 
 Location


 End_of_input 
 when the end of the input stream is reached

White space
 Zero or more whitespace characters, or comments enclosed in /* ... */, are allowed between any two tokens, with the exceptions noted below.
 ""Longest token matching"" is used to resolve conflicts (e.g., in order to match <= as a single token rather than the two tokens < and =).
 Whitespace is required between two tokens that have an alphanumeric character or underscore at the edge.
 This means: keywords, identifiers, and integer literals.
 e.g. ifprint is recognized as an identifier, instead of the keywords if and print.
 e.g. 42fred is invalid, and neither recognized as a number nor an identifier.
 Whitespace is not allowed inside of tokens (except for chars and strings where they are part of the value).
 e.g. & & is invalid, and not interpreted as the && operator.
For example, the following two program fragments are equivalent, and should produce the same token stream except for the line and column positions:

 if ( p /* meaning n is prime */ ) {
    print ( n , "" "" ) ;
    count = count + 1 ; /* number of primes found so far */
}
 if(p){print(n,"" "");count=count+1;}
Complete list of token names
End_of_input  Op_multiply   Op_divide     Op_mod       Op_add     Op_subtract
Op_negate     Op_not        Op_less       Op_lessequal Op_greater Op_greaterequal
Op_equal      Op_notequal   Op_assign     Op_and       Op_or      Keyword_if
Keyword_else  Keyword_while Keyword_print Keyword_putc LeftParen  RightParen
LeftBrace     RightBrace    Semicolon     Comma        Identifier Integer
String

Output Format
The program output should be a sequence of lines, each consisting of the following whitespace-separated fields:

 the line number where the token starts
 the column number where the token starts
 the token name
 the token value (only for Identifier, Integer, and String tokens)
 the number of spaces between fields is up to you. Neatly aligned is nice, but not a requirement.


This task is intended to be used as part of a pipeline, with the other compiler tasks - for example:

lex < hello.t | parse | gen | vm

Or possibly:

lex hello.t lex.out
parse lex.out parse.out
gen parse.out gen.out
vm gen.out



This implies that the output of this task (the lexical analyzer) should be suitable as input to any of the Syntax Analyzer task programs.

Diagnostics
The following error conditions should be caught:



 Error

 Example


 Empty character constant

 ''


 Unknown escape sequence.

 \r


 Multi-character constant.

 'xx'


 End-of-file in comment. Closing comment characters not found.


 End-of-file while scanning string literal. Closing string character not found.


 End-of-line while scanning string literal. Closing string character not found before end-of-line.


 Unrecognized character.

 |


 Invalid number. Starts like a number, but ends in non-numeric characters.

 123abc

Test Cases


 Input

 Output



Test Case 1:

/*
  Hello world
 */
print(""Hello, World!\n"");


    4      1 Keyword_print
    4      6 LeftParen
    4      7 String         ""Hello, World!\n""
    4     24 RightParen
    4     25 Semicolon
    5      1 End_of_input




Test Case 2:

/*
  Show Ident and Integers
 */
phoenix_number = 142857;
print(phoenix_number, ""\n"");


    4      1 Identifier     phoenix_number
    4     16 Op_assign
    4     18 Integer         142857
    4     24 Semicolon
    5      1 Keyword_print
    5      6 LeftParen
    5      7 Identifier     phoenix_number
    5     21 Comma
    5     23 String         ""\n""
    5     27 RightParen
    5     28 Semicolon
    6      1 End_of_input




Test Case 3:

/*
  All lexical tokens - not syntactically correct, but that will
  have to wait until syntax analysis
 */
/* Print   */  print    /* Sub     */  -
/* Putc    */  putc     /* Lss     */  <
/* If      */  if       /* Gtr     */  >
/* Else    */  else     /* Leq     */  <=
/* While   */  while    /* Geq     */  >=
/* Lbrace  */  {        /* Eq      */  ==
/* Rbrace  */  }        /* Neq     */  !=
/* Lparen  */  (        /* And     */  &&
/* Rparen  */  )        /* Or      */  ||
/* Uminus  */  -        /* Semi    */  ;
/* Not     */  !        /* Comma   */  ,
/* Mul     */  *        /* Assign  */  =
/* Div     */  /        /* Integer */  42
/* Mod     */  %        /* String  */  ""String literal""
/* Add     */  +        /* Ident   */  variable_name
/* character literal */  '\n'
/* character literal */  '\\'
/* character literal */  ' '


    5     16   Keyword_print
    5     40   Op_subtract
    6     16   Keyword_putc
    6     40   Op_less
    7     16   Keyword_if
    7     40   Op_greater
    8     16   Keyword_else
    8     40   Op_lessequal
    9     16   Keyword_while
    9     40   Op_greaterequal
   10     16   LeftBrace
   10     40   Op_equal
   11     16   RightBrace
   11     40   Op_notequal
   12     16   LeftParen
   12     40   Op_and
   13     16   RightParen
   13     40   Op_or
   14     16   Op_subtract
   14     40   Semicolon
   15     16   Op_not
   15     40   Comma
   16     16   Op_multiply
   16     40   Op_assign
   17     16   Op_divide
   17     40   Integer             42
   18     16   Op_mod
   18     40   String          ""String literal""
   19     16   Op_add
   19     40   Identifier      variable_name
   20     26   Integer             10
   21     26   Integer             92
   22     26   Integer             32
   23      1   End_of_input




Test Case 4:

/*** test printing, embedded \n and comments with lots of '*' ***/
print(42);
print(""\nHello World\nGood Bye\nok\n"");
print(""Print a slash n - \\n.\n"");


    2      1 Keyword_print
    2      6 LeftParen
    2      7 Integer            42
    2      9 RightParen
    2     10 Semicolon
    3      1 Keyword_print
    3      6 LeftParen
    3      7 String          ""\nHello World\nGood Bye\nok\n""
    3     38 RightParen
    3     39 Semicolon
    4      1 Keyword_print
    4      6 LeftParen
    4      7 String          ""Print a slash n - \\n.\n""
    4     33 RightParen
    4     34 Semicolon
    5      1 End_of_input


Additional examples
Your solution should pass all the test cases above and the additional tests found Here.



Reference
The C and Python versions can be considered reference implementations.



Related Tasks
 Syntax Analyzer task
 Code Generator task
 Virtual Machine Interpreter task
 AST Interpreter task


",#C.23,C#," 
using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
 
 
namespace Rosetta {
 
    public enum TokenType {
        End_of_input, Op_multiply, Op_divide, Op_mod, Op_add, Op_subtract,
        Op_negate, Op_not, Op_less, Op_lessequal, Op_greater, Op_greaterequal,
        Op_equal, Op_notequal, Op_assign, Op_and, Op_or, Keyword_if,
        Keyword_else, Keyword_while, Keyword_print, Keyword_putc, LeftParen, RightParen,
        LeftBrace, RightBrace, Semicolon, Comma, Identifier, Integer, String, None
    }
 
    /// <summary>
    /// Storage class for tokens
    /// </summary>
    public class Token {
        public TokenType Type { get; set; }
        public int Line { get; set; }
        public int Position { get; set; }
        public string Value { get; set; }
        public override string ToString() {
            if (Type == TokenType.Integer || Type == TokenType.Identifier) {
                return String.Format(""{0,-5}  {1,-5}   {2,-14}     {3}"", Line, Position, Type.ToString(), Value);
            } else if (Type == TokenType.String) {
                return String.Format(""{0,-5}  {1,-5}   {2,-14}     \""{3}\"""", Line, Position, Type.ToString(), Value.Replace(""\n"", ""\\n""));
            }
            return String.Format(""{0,-5}  {1,-5}   {2,-14}"", Line, Position, Type.ToString());
        }
    }
 
    /// <summary>
    /// C# Example of Lexical scanner for Rosetta Compiler
    /// </summary>
    public class LexicalScanner {
 
        // character classes 
        private const string _letters = ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"";        
        private const string _numbers = ""0123456789"";
        private const string _identifier = _letters + _numbers + ""_"";
        private const string _whitespace = "" \t\n\r"";
 
        // mappings from string keywords to token type 
        private Dictionary<string, TokenType> _keywordTokenTypeMap = new Dictionary<string, TokenType>() {
            { ""if"", TokenType.Keyword_if },
            { ""else"", TokenType.Keyword_else },
            { ""while"", TokenType.Keyword_while },
            { ""print"", TokenType.Keyword_print },
            { ""putc"", TokenType.Keyword_putc }
        };
 
        // mappings from simple operators to token type
        private Dictionary<string, TokenType> _operatorTokenTypeMap = new Dictionary<string, TokenType>() {
            { ""+"", TokenType.Op_add },
            { ""-"", TokenType.Op_subtract },
            { ""*"", TokenType.Op_multiply },
            { ""/"", TokenType.Op_divide },
            { ""%"", TokenType.Op_mod },
            { ""="", TokenType.Op_assign },
            { ""<"", TokenType.Op_less },
            { "">"", TokenType.Op_greater },
            { ""!"", TokenType.Op_not },
        };
 
        private List<string> _keywords;
        private string _operators = ""+-*/%=<>!%"";
 
        private string _code;
        private List<Token> tokens = new List<Token>();
 
        private int _line = 1;
        private int _position = 1;
 
        public string CurrentCharacter {
            get {
                try {
                    return _code.Substring(0, 1);
                } catch (ArgumentOutOfRangeException) {
                    return """";
                }
            }
        }
 
        /// <summary>
        /// Lexical scanner initialiser
        /// </summary>
        /// <param name=""code"">Code to be tokenised</param>
        public LexicalScanner (string code) {
            _code = code;
            _keywords = _keywordTokenTypeMap.Keys.ToList();
        }
 
        /// <summary>
        /// Advance the cursor forward given number of characters
        /// </summary>
        /// <param name=""characters"">Number of characters to advance</param>
        private void advance(int characters=1) {
            try {
                // reset position when there is a newline
                if (CurrentCharacter == ""\n"") {
                    _position = 0;
                    _line++;
                }
 
                _code = _code.Substring(characters, _code.Length - characters);
                _position += characters;
            } catch (ArgumentOutOfRangeException) {
                _code = """";
            }
        }
 
        /// <summary>
        /// Outputs error message to the console and exits 
        /// </summary>
        /// <param name=""message"">Error message to display to user</param>
        /// <param name=""line"">Line error occurred on</param>
        /// <param name=""position"">Line column that the error occurred at</param>
        public void error(string message, int line, int position) {
            // output error to the console and exit
            Console.WriteLine(String.Format(""{0} @ {1}:{2}"", message, line, position));
            Environment.Exit(1);
        }
 
        /// <summary>
        /// Pattern matching using first & follow matching
        /// </summary>
        /// <param name=""recogniseClass"">String of characters that identifies the token type
        /// or the exact match the be made if exact:true</param>
        /// <param name=""matchClass"">String of characters to match against remaining target characters</param>
        /// <param name=""tokenType"">Type of token the match represents.</param>
        /// <param name=""notNextClass"">Optional class of characters that cannot follow the match</param>
        /// <param name=""maxLen"">Optional maximum length of token value</param>
        /// <param name=""exact"">Denotes whether recogniseClass represents an exact match or class match. 
        /// Default: false</param>
        /// <param name=""discard"">Denotes whether the token is kept or discarded. Default: false</param>
        /// <param name=""offset"">Optiona line position offset to account for discarded tokens</param>
        /// <returns>Boolean indicating if a match was made </returns>
        public bool match(string recogniseClass, string matchClass, TokenType tokenType, 
                          string notNextClass=null, int maxLen=Int32.MaxValue, bool exact=false, 
                          bool discard=false, int offset=0) {
 
            // if we've hit the end of the file, there's no more matching to be done
            if (CurrentCharacter == """")
                return false;
 
            // store _current_ line and position so that our vectors point at the start
            // of each token
            int line = _line;
            int position = _position;
 
            // special case exact tokens to avoid needing to worry about backtracking
            if (exact) {
                if (_code.StartsWith(recogniseClass)) {
                    if (!discard) 
                        tokens.Add(new Token() { Type = tokenType, Value = recogniseClass, Line = line, Position = position - offset});   
                    advance(recogniseClass.Length);
                    return true;
                }
                return false;
            }
 
            // first match - denotes the token type usually
            if (!recogniseClass.Contains(CurrentCharacter))
                return false;
 
            string tokenValue = CurrentCharacter;
            advance();
 
            // follow match while we haven't exceeded maxLen and there are still characters
            // in the code stream
            while ((matchClass ?? """").Contains(CurrentCharacter) && tokenValue.Length <= maxLen && CurrentCharacter != """") {
                tokenValue += CurrentCharacter;
                advance();
            }
 
            // ensure that any incompatible characters are not next to the token
            // eg 42fred is invalid, and neither recognized as a number nor an identifier.
            // _letters would be the notNextClass
            if (notNextClass != null && notNextClass.Contains(CurrentCharacter))
                error(""Unrecognised character: "" + CurrentCharacter, _line, _position);
 
            // only add tokens to the stack that aren't marked as discard - dont want
            // things like open and close quotes/comments
            if (!discard) {
                Token token = new Token() { Type = tokenType, Value = tokenValue, Line = line, Position = position - offset };
                tokens.Add(token);
            }
 
            return true;
        }
 
        /// <summary>
        /// Tokenise the input code 
        /// </summary>
        /// <returns>List of Tokens</returns>
        public List<Token> scan() {
 
            while (CurrentCharacter != """") {
                // match whitespace
                match(_whitespace, _whitespace, TokenType.None, discard: true);
 
                // match integers
                match(_numbers, _numbers, TokenType.Integer, notNextClass:_letters);
 
                // match identifiers and keywords
                if (match(_letters, _identifier, TokenType.Identifier)) {
                    Token match = tokens.Last();
                    if (_keywords.Contains(match.Value))
                        match.Type = _keywordTokenTypeMap[match.Value];
                }
 
                // match string similarly to comments without allowing newlines
                // this token doesn't get discarded though
                if (match(""\"""", null, TokenType.String, discard:true)) {
                    string value = """";
                    int position = _position;
                    while (!match(""\"""", null, TokenType.String, discard:true)) {
                        // not allowed newlines in strings
                        if (CurrentCharacter == ""\n"")
                            error(""End-of-line while scanning string literal. Closing string character not found before end-of-line"", _line, _position);
                        // end of file reached before finding end of string
                        if (CurrentCharacter == """")
                            error(""End-of-file while scanning string literal. Closing string character not found"", _line, _position);
 
                        value += CurrentCharacter;
 
                        // deal with escape sequences - we only accept newline (\n)
                        if (value.Length >= 2) {
                            string lastCharacters = value.Substring(value.Length - 2, 2);
                            if (lastCharacters[0] == '\\') {
                                if (lastCharacters[1] != 'n') {
                                    error(""Unknown escape sequence. "", _line, position);
                                }
                                value = value.Substring(0, value.Length - 2).ToString() + ""\n"";
                            }
                        }
 
                        advance();
                    }
                    tokens.Add(new Token() { Type = TokenType.String, Value = value, Line = _line, Position = position - 1});
                }
 
                // match string literals
                if (match(""'"", null, TokenType.Integer, discard:true)) {
                    int value;
                    int position = _position;
                    value = CurrentCharacter.ToCharArray()[0];
                    advance();
 
                    // deal with empty literals ''
                    if (value == '\'')
                        error(""Empty character literal"", _line, _position);
 
                    // deal with escaped characters, only need to worry about \n and \\
                    // throw werror on any other
                    if (value == '\\') {
                        if (CurrentCharacter == ""n"") {
                            value = '\n';
                        } else if (CurrentCharacter == ""\\"") {
                            value = '\\';
                        } else {
                            error(""Unknown escape sequence. "", _line, _position - 1);
                        }
                        advance();
                    }
 
                    // if we haven't hit a closing ' here, there are two many characters
                    // in the literal
                    if (!match(""'"", null, TokenType.Integer, discard: true))
                        error(""Multi-character constant"", _line, _position);
 
                    tokens.Add(new Rosetta.Token() { Type = TokenType.Integer, Value = value.ToString(), Line = _line, Position = position - 1 });
                }
 
                // match comments by checking for starting token, then advancing 
                // until closing token is matched
                if (match(""/*"", null, TokenType.None, exact: true, discard: true)) {
                    while (!match(""*/"", null, TokenType.None, exact: true, discard: true)) {
                        // reached the end of the file without closing comment!
                        if (CurrentCharacter == """")
                            error(""End-of-file in comment. Closing comment characters not found."", _line, _position);
                        advance();
                    }
                    continue;
                }
 
                // match complex operators
                match(""<="", null, TokenType.Op_lessequal, exact: true);
                match("">="", null, TokenType.Op_greaterequal, exact: true);
                match(""=="", null, TokenType.Op_equal, exact: true);
                match(""!="", null, TokenType.Op_notequal, exact: true);
                match(""&&"", null, TokenType.Op_and, exact: true);
                match(""||"", null, TokenType.Op_or, exact: true);
 
                // match simple operators
                if (match(_operators, null, TokenType.None, maxLen:1)) {
                    Token match = tokens.Last();
                    match.Type = _operatorTokenTypeMap[match.Value];
                }
 
                // brackets, braces and separators
                match(""("", null, TokenType.LeftParen, exact: true);
                match("")"", null, TokenType.RightParen, exact: true);
                match(""{"", null, TokenType.LeftBrace, exact: true);
                match(""}"", null, TokenType.RightBrace, exact: true);
                match("";"", null, TokenType.Semicolon, exact: true);
                match("","", null, TokenType.Comma, exact: true);
 
            }
 
            // end of file token
            tokens.Add(new Rosetta.Token() { Type = TokenType.End_of_input, Line = _line, Position = _position });
 
            return tokens;
        }
 
        static void Main (string[] args) {
            StreamReader inputFile;
 
            // if we passed in a filename, read code from that, else
            // read code from stdin
            if (args.Length > 0) {
                string path = args[0];
                try {
                    inputFile = new StreamReader(path);
                } catch (IOException) {
                    inputFile = new StreamReader(Console.OpenStandardInput(8192));
                }
            } else {
                inputFile = new StreamReader(Console.OpenStandardInput(8192));
            }
 
            string code = inputFile.ReadToEnd();
 
            // strip windows line endings out
            code = code.Replace(""\r"", """");
 
            LexicalScanner scanner = new LexicalScanner(code);
            List<Token> tokens = scanner.scan();
 
            foreach(Token token in tokens) {
                Console.WriteLine(token.ToString());
            }       
        }
    }
}
 ",15392,351
66777,http://rosettacode.org/wiki/Command-line_arguments,Command-line arguments,"Command-line arguments is part of Short Circuit's Console Program Basics selection.
Scripted main
See also Program name.

For parsing command line arguments intelligently, see Parsing command-line arguments.

Example command line:

myprogram -c ""alpha beta"" -h ""gamma""
",#C.23,C#,"using System;
 
namespace RosettaCode {
    class Program {
        static void Main(string[] args) {
            for (int i = 0; i < args.Length; i++)
                Console.WriteLine(String.Format(""Argument {0} is '{1}'"", i, args[i]));
        }
    }
}",256,10
66796,http://rosettacode.org/wiki/Combinations_with_repetitions,Combinations with repetitions,"The set of combinations with repetitions is computed from a set, 



S


{\displaystyle S}

 (of cardinality 



n


{\displaystyle n}

), and a size of resulting selection, 



k


{\displaystyle k}

, by reporting the sets of cardinality 



k


{\displaystyle k}

 where each member of those sets is chosen from 



S


{\displaystyle S}

.
In the real world, it is about choosing sets where there is a “large” supply of each type of element and where the order of choice does not matter.
For example:

Q: How many ways can a person choose two doughnuts from a store selling three types of doughnut: iced, jam, and plain? (i.e., 



S


{\displaystyle S}

 is 



{

i
c
e
d

,

j
a
m

,

p
l
a
i
n

}


{\displaystyle \{\mathrm {iced} ,\mathrm {jam} ,\mathrm {plain} \}}

, 




|

S

|

=
3


{\displaystyle |S|=3}

, and 



k
=
2


{\displaystyle k=2}

.)
A: 6: {iced, iced}; {iced, jam}; {iced, plain}; {jam, jam}; {jam, plain}; {plain, plain}.
Note that both the order of items within a pair, and the order of the pairs given in the answer is not significant; the pairs represent multisets.
Also note that doughnut can also be spelled donut.



Task

 Write a function/program/routine/.. to generate all the combinations with repetitions of 



n


{\displaystyle n}

 types of things taken 



k


{\displaystyle k}

 at a time and use it to show an answer to the doughnut example above.
 For extra credit, use the function to compute and show just the number of ways of choosing three doughnuts from a choice of ten types of doughnut. Do not show the individual choices for this part.


References

 k-combination with repetitions


See also


 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",#C.23,C#," 
using System;
using System.Collections.Generic;
using System.Linq;
 
public static class MultiCombinations
{
    private static void Main()
    {
        var set = new List<string> { ""iced"", ""jam"", ""plain"" };
        var combinations = GenerateCombinations(set, 2);
 
        foreach (var combination in combinations)
        {
            string combinationStr = string.Join("" "", combination);
            Console.WriteLine(combinationStr);
        }
 
        var donuts = Enumerable.Range(1, 10).ToList();
 
        int donutsCombinationsNumber = GenerateCombinations(donuts, 3).Count;
 
        Console.WriteLine(""{0} ways to order 3 donuts given 10 types"", donutsCombinationsNumber);
    }
 
    private static List<List<T>> GenerateCombinations<T>(List<T> combinationList, int k)
    {
        var combinations = new List<List<T>>();
 
        if (k == 0)
        {
            var emptyCombination = new List<T>();
            combinations.Add(emptyCombination);
 
            return combinations;
        }
 
        if (combinationList.Count == 0)
        {
            return combinations;
        }
 
        T head = combinationList[0];
        var copiedCombinationList = new List<T>(combinationList);
 
        List<List<T>> subcombinations = GenerateCombinations(copiedCombinationList, k - 1);
 
        foreach (var subcombination in subcombinations)
        {
            subcombination.Insert(0, head);
            combinations.Add(subcombination);
        }
 
        combinationList.RemoveAt(0);
        combinations.AddRange(GenerateCombinations(combinationList, k));
 
        return combinations;
    }
}
 ",1631,60
66857,http://rosettacode.org/wiki/Comma_quibbling,Comma quibbling,"Comma quibbling is a task originally set by Eric Lippert in his blog.



Task

Write a function to generate a string output which is the concatenation of input words from a list/sequence where:

 An input of no words produces the output string of just the two brace characters ""{}"".
 An input of just one word, e.g. [""ABC""], produces the output string of the word inside the two braces, e.g. ""{ABC}"".
 An input of two words, e.g. [""ABC"", ""DEF""], produces the output string of the two words inside the two braces with the words separated by the string "" and "", e.g. ""{ABC and DEF}"".
 An input of three or more words, e.g. [""ABC"", ""DEF"", ""G"", ""H""], produces the output string of all but the last word separated by "", "" with the last word separated by "" and "" and all within braces; e.g. ""{ABC, DEF, G and H}"".


Test your function with the following series of inputs showing your output here on this page:

 [] # (No input words).
 [""ABC""]
 [""ABC"", ""DEF""]
 [""ABC"", ""DEF"", ""G"", ""H""]


Note: Assume words are non-empty strings of uppercase characters for this task.



",#C.23,C#,"using System;
using System.Linq;
 
namespace CommaQuibbling
{
    internal static class Program
    {
        #region Static Members
	private static string Quibble(string[] input)
	{
            return
                String.Format(""{{{0}}}"",
                    String.Join("""",
                        input.Reverse().Zip(
                            new [] { """", "" and "" }.Concat(Enumerable.Repeat("", "", int.MaxValue)),
                            (x, y) => x + y).Reverse()));
	}
 
 
        private static void Main()
        {
            Console.WriteLine( Quibble( new string[] {} ) );
            Console.WriteLine( Quibble( new[] {""ABC""} ) );
            Console.WriteLine( Quibble( new[] {""ABC"", ""DEF""} ) );
            Console.WriteLine( Quibble( new[] {""ABC"", ""DEF"", ""G"", ""H""} ) );
 
            Console.WriteLine( ""< Press Any Key >"" );
            Console.ReadKey();
        }
 
        #endregion
    }
}",919,33
66967,http://rosettacode.org/wiki/Conditional_structures,Conditional structures,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops

Task

List the conditional structures offered by a programming language. See Wikipedia: conditionals for descriptions.

Common conditional structures include if-then-else and switch.

Less common are arithmetic if, ternary operator and Hash-based conditionals.

Arithmetic if allows tight control over computed gotos, which optimizers have a hard time to figure out.


",#C.23,C#,"if (condition)
{
   // Some Task
}
 
if (condition)
{
  // Some Task
}
else if (condition2)
{
  // Some Task
}
else
{
  // Some Task
}",134,17
66993,http://rosettacode.org/wiki/Comments,Comments,"Task

Show all ways to include text in a language source file
that's completely ignored by the compiler or interpreter.



Related tasks

   Documentation
   Here_document


See also

   Wikipedia
   xkcd (Humor: hand gesture denoting // for ""commenting out"" people.)

",#C.23,C#,"//This is a comment.
//This is other comment.
 
/* This is a comment too. */
 
/* This is a 
multi-line
comment */",114,8
67602,http://rosettacode.org/wiki/Color_of_a_screen_pixel,Color of a screen pixel,"Task

Get color information from an arbitrary pixel on the screen, such as the current location of the mouse cursor.

The mouse cursor may or may not have to be active in a GUI created by your program. These functions are OS related.



",#C.23,C#,"using System;
using System.Drawing;
using System.Windows.Forms;
 
class Program
{
    static Color GetPixel(Point position)
    {
        using (var bitmap = new Bitmap(1, 1))
        {
            using (var graphics = Graphics.FromImage(bitmap))
            {
                graphics.CopyFromScreen(position, new Point(0, 0), new Size(1, 1));
            }
            return bitmap.GetPixel(0, 0);
        }
    }
 
    static void Main()
    {
        Console.WriteLine(GetPixel(Cursor.Position));
    }
}",510,23
67760,http://rosettacode.org/wiki/Combinations,Combinations,"Task

Given non-negative integers    m    and    n,   generate all size    m    combinations   of the integers from    0   (zero)   to    n-1    in sorted order   (each combination is sorted and the entire table is sorted).



Example

3   comb    5      is:

0 1 2
0 1 3
0 1 4
0 2 3
0 2 4
0 3 4
1 2 3
1 2 4
1 3 4
2 3 4

If it is more ""natural"" in your language to start counting from    1   (unity) instead of    0   (zero),

the combinations can be of the integers from    1   to    n. 



See also


 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",#C.23,C#,"using System;
using System.Collections.Generic;
 
public class Program
{
    public static IEnumerable<int[]> Combinations(int m, int n)
    {
            int[] result = new int[m];
            Stack<int> stack = new Stack<int>();
            stack.Push(0);
 
            while (stack.Count > 0)
           {
                int index = stack.Count - 1;
                int value = stack.Pop();
 
                while (value < n) 
               {
                    result[index++] = ++value;
                    stack.Push(value);
 
                    if (index == m) 
                    {
                        yield return result;
                        break;
                    }
                }
            }
    }
 
    static void Main()
    {
        foreach (int[] c in Combinations(3, 5))
        {
            Console.WriteLine(string.Join("","", c));
            Console.WriteLine();
        }
    }
}",923,39
67890,http://rosettacode.org/wiki/Closures/Value_capture,Closures/Value capture,"Task

Create a list of ten functions, in the simplest manner possible   (anonymous functions are encouraged),   such that the function at index    i     (you may choose to start     i     from either    0    or    1),    when run, should return the square of the index,   that is,     i  2.

Display the result of running any but the last function, to demonstrate that the function indeed remembers its value.



Goal

Demonstrate how to create a series of independent closures based on the same template but maintain separate copies of the variable closed over.

In imperative languages, one would generally use a loop with a mutable counter variable.

For each function to maintain the correct number, it has to capture the value of the variable at the time it was created, rather than just a reference to the variable, which would have a different value by the time the function was run.

See also: Multiple distinct objects
",#C.23,C#,"using System;
using System.Linq;
 
class Program
{
    static void Main()
    {
        var captor = (Func<int, Func<int>>)(number => () => number * number);
        var functions = Enumerable.Range(0, 10).Select(captor);
        foreach (var function in functions.Take(9))
        {
            Console.WriteLine(function());
        }
    }
}",344,15
68035,http://rosettacode.org/wiki/Closest-pair_problem,Closest-pair problem,"

 This page uses content from Wikipedia. The original article was at Closest pair of points problem. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Provide a function to find the closest two points among a set of given points in two dimensions,   i.e. to solve the   Closest pair of points problem   in the   planar   case.

The straightforward solution is a   O(n2)   algorithm   (which we can call brute-force algorithm);   the pseudo-code (using indexes) could be simply:

bruteForceClosestPair of P(1), P(2), ... P(N)
if N < 2 then
  return ∞
else
  minDistance ← |P(1) - P(2)|
  minPoints ← { P(1), P(2) }
  foreach i ∈ [1, N-1]
    foreach j ∈ [i+1, N]
      if |P(i) - P(j)| < minDistance then
        minDistance ← |P(i) - P(j)|
        minPoints ← { P(i), P(j) } 
      endif
    endfor
  endfor
  return minDistance, minPoints
 endif

A better algorithm is based on the recursive divide&conquer approach,   as explained also at   Wikipedia's Closest pair of points problem,   which is   O(n log n);   a pseudo-code could be:

closestPair of (xP, yP)
               where xP is P(1) .. P(N) sorted by x coordinate, and
                     yP is P(1) .. P(N) sorted by y coordinate (ascending order)
if N ≤ 3 then
  return closest points of xP using brute-force algorithm
else
  xL ← points of xP from 1 to ⌈N/2⌉
  xR ← points of xP from ⌈N/2⌉+1 to N
  xm ← xP(⌈N/2⌉)x
  yL ← { p ∈ yP : px ≤ xm }
  yR ← { p ∈ yP : px > xm }
  (dL, pairL) ← closestPair of (xL, yL)
  (dR, pairR) ← closestPair of (xR, yR)
  (dmin, pairMin) ← (dR, pairR)
  if dL < dR then
    (dmin, pairMin) ← (dL, pairL)
  endif
  yS ← { p ∈ yP : |xm - px| < dmin }
  nS ← number of points in yS
  (closest, closestPair) ← (dmin, pairMin)
  for i from 1 to nS - 1
    k ← i + 1
    while k ≤ nS and yS(k)y - yS(i)y < dmin
      if |yS(k) - yS(i)| < closest then
        (closest, closestPair) ← (|yS(k) - yS(i)|, {yS(k), yS(i)})
      endif
      k ← k + 1
    endwhile
  endfor
  return closest, closestPair
endif



References and further readings

   Closest pair of points problem
   Closest Pair (McGill)
   Closest Pair (UCSB)
   Closest pair (WUStL)
   Closest pair (IUPUI) 

",#C.23,C#,"class Segment
{
    public Segment(PointF p1, PointF p2)
    {
        P1 = p1;
        P2 = p2;
    }
 
    public readonly PointF P1;
    public readonly PointF P2;
 
    public float Length()
    {
        return (float)Math.Sqrt(LengthSquared());
    }
 
    public float LengthSquared()
    {
        return (P1.X - P2.X) * (P1.X - P2.X)
            + (P1.Y - P2.Y) * (P1.Y - P2.Y);
    }
}",395,22
68043,http://rosettacode.org/wiki/Church_numerals,Church numerals,"Task

In the Church encoding of natural numbers, the number N is encoded by a function that applies its first argument N times to its second argument.

 Church zero always returns the identity function, regardless of its first argument. In other words, the first argument is not applied to the second argument at all.
 Church one applies its first argument f just once to its second argument x, yielding f(x)
 Church two applies its first argument f twice to its second argument x, yielding f(f(x))
 and each successive Church numeral applies its first argument one additional time to its second argument, f(f(f(x))), f(f(f(f(x)))) ... The Church numeral 4, for example, returns a quadruple composition of the function supplied as its first argument.


Arithmetic operations on natural numbers can be similarly represented as functions on Church numerals.

In your language define:

 Church Zero,
 a Church successor function (a function on a Church numeral which returns the next Church numeral in the series),
 functions for Addition, Multiplication and Exponentiation over Church numerals,
 a function to convert integers to corresponding Church numerals,
 and a function to convert Church numerals to corresponding integers.


You should:

 Derive Church numerals three and four in terms of Church zero and a Church successor function.
 use Church numeral arithmetic to obtain the the sum and the product of Church 3 and Church 4,
 similarly obtain 4^3 and 3^4 in terms of Church numerals, using a Church numeral exponentiation function,
 convert each result back to an integer, and return it or print it to the console.

",#C.23,C#,"using System;
 
public delegate Church Church(Church f);
 
public static class ChurchNumeral
{
    public static readonly Church ChurchZero = _ => x => x;
    public static readonly Church ChurchOne = f => f;
 
    public static Church Successor(this Church n) => f => x => f(n(f)(x));
    public static Church Add(this Church m, Church n) => f => x => m(f)(n(f)(x));
    public static Church Multiply(this Church m, Church n) => f => m(n(f));
    public static Church Exponent(this Church m, Church n) => n(m);
    public static Church IsZero(this Church n) => n(_ => ChurchZero)(ChurchOne);
    public static Church Predecessor(this Church n) =>
      f => x => n(g => h => h(g(f)))(_ => x)(a => a);
    public static Church Subtract(this Church m, Church n) => n(Predecessor)(m);
    static Church looper(this Church v, Church d) =>
        v(_ => v.divr(d).Successor())(ChurchZero);
    static Church divr(this Church n, Church d) =>
        n.Subtract(d).looper(d);
    public static Church Divide(this Church dvdnd, Church dvsr) =>
        (dvdnd.Successor()).divr(dvsr);
 
    public static Church FromInt(int i) =>
      i <= 0 ? ChurchZero : Successor(FromInt(i - 1));
 
    public static int ToInt(this Church ch) {
        int count = 0;
        ch(x => { count++; return x; })(null);
        return count;
    }
 
    public static void Main() {
        Church c3 = FromInt(3);
        Church c4 = c3.Successor();
        Church c11 = FromInt(11);
        Church c12 = c11.Successor();
        int sum = c3.Add(c4).ToInt();
        int product = c3.Multiply(c4).ToInt();
        int exp43 = c4.Exponent(c3).ToInt();
        int exp34 = c3.Exponent(c4).ToInt();
        int tst0 = ChurchZero.IsZero().ToInt();
        int pred4 = c4.Predecessor().ToInt();
        int sub43 = c4.Subtract(c3).ToInt();
        int div11by3 = c11.Divide(c3).ToInt();
        int div12by3 = c12.Divide(c3).ToInt();
        Console.Write($""{sum} {product} {exp43} {exp34} {tst0} "");
        Console.WriteLine($""{pred4} {sub43} {div11by3} {div12by3}"");
    } 
}",2050,51
68066,http://rosettacode.org/wiki/Collections,Collections,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.


Collections are abstractions to represent sets of values. 

In statically-typed languages, the values are typically of a common data type.



Task

Create a collection, and add a few values to it.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#C.23,C#," 
// Creates and initializes a new integer Array
int[] intArray = new int[5] { 1, 2, 3, 4, 5 };
//same as
int[] intArray = new int[]{ 1, 2, 3, 4, 5 };
//same as
int[] intArray = { 1, 2, 3, 4, 5 };
 
//Arrays are zero-based
string[] stringArr = new string[5];
stringArr[0] = ""string"";
 ",285,12
68072,http://rosettacode.org/wiki/Classes,Classes,"In object-oriented programming class is a set (a transitive closure) of types bound by the relation of inheritance. It is said that all types derived from some base type T and the type T itself form a class T.

The first type T from the class T sometimes is called the root type of the class.

A class of types itself, as a type, has the values and operations of its own.
The operations of are usually called methods of the root type.
Both operations and values are called  polymorphic.

A polymorphic operation (method) selects an implementation depending on the actual specific type of the polymorphic argument.

The action of choice the type-specific implementation of a polymorphic operation is called dispatch. Correspondingly, polymorphic operations are often called dispatching or virtual.
Operations with multiple arguments and/or the results of the class are called multi-methods.
A further generalization of is the operation with arguments and/or results from different classes.

 single-dispatch languages are those that allow only one argument or result to control the dispatch. Usually it is the first parameter, often hidden, so that a prefix notation x.f() is used instead of mathematical f(x).
 multiple-dispatch languages allow many arguments and/or results to control the dispatch.


A polymorphic value has a type tag indicating its specific type from the class and the corresponding specific value of that type.
This type is sometimes called the most specific type of a [polymorphic] value.
The type tag of the value is used in order to resolve the dispatch.
The set of polymorphic values of a class is a transitive closure of the sets of values of all types from that class.

In many  OO languages
the type of the class of T and T itself are considered equivalent.
In some languages they are distinct (like in Ada).
When class T and T are equivalent, there is no way to distinguish
polymorphic and specific values.



Task

Create a basic class with a method, a constructor, an instance variable and how to instantiate it.



",#C.23,C#,"public class MyClass
{
    public MyClass()
    {
    }
    public void SomeMethod()
    {
    }
    private int _variable;
    public int Variable
    {
        get { return _variable; }
        set { _variable = value; }
    }
    public static void Main()
    {
        // instantiate it
        MyClass instance = new MyClass();
        // invoke the method
        instance.SomeMethod();
        // set the variable
        instance.Variable = 99;
        // get the variable
        System.Console.WriteLine( ""Variable="" + instance.Variable.ToString() );
    }
}",568,26
68189,http://rosettacode.org/wiki/Chowla_numbers,Chowla numbers,"Chowla numbers are also known as:

   Chowla's function
   chowla numbers 
   the chowla function
   the chowla number
   the chowla sequence




The chowla number of   n   is   (as defined by Chowla's function):

   the sum of the divisors of   n     excluding unity and   n
   where   n   is a positive integer


The sequence is named after   Sarvadaman D. S. Chowla,   (22 October 1907 ──► 10 December 1995),

a London born Indian American mathematician specializing in number theory.



German mathematician Carl Friedrich Gauss (1777─1855) said:

   ""Mathematics is the queen of the sciences ─ and number theory is the queen of mathematics"".



Definitions

Chowla numbers can also be expressed as:

   
   chowla(n) = sum of divisors of  n  excluding unity and  n
   chowla(n) = sum(       divisors(n))   - 1  -  n 
   chowla(n) = sum( properDivisors(n))   - 1       
   chowla(n) = sum(aliquotDivisors(n))   - 1        
   chowla(n) = aliquot(n)                - 1       
   chowla(n) = sigma(n)                  - 1  -  n 
   chowla(n) = sigmaProperDivisiors(n)   - 1       
 
   chowla(a*b) =  a + b,    if  a  and  b  are distinct primes
   if  chowla(n) =  0,       and n > 1,  then   n   is prime
   if  chowla(n) =  n - 1,  and n > 1,  then   n   is a perfect number
    

Task

   create a   chowla   function that returns the   chowla number   for a positive integer   n
   Find and display   (1 per line)   for the 1st   37   integers:
   the integer   (the index)
   the chowla number for that integer
   For finding primes, use the   chowla   function to find values of zero
   Find and display the   count   of the primes up to              100
   Find and display the   count   of the primes up to           1,000
   Find and display the   count   of the primes up to         10,000
   Find and display the   count   of the primes up to       100,000
   Find and display the   count   of the primes up to    1,000,000
   Find and display the   count   of the primes up to  10,000,000
   For finding perfect numbers, use the   chowla   function to find values of   n - 1
   Find and display all   perfect numbers   up to   35,000,000
   use commas within appropriate numbers
   show all output here




Related tasks

    totient function
    perfect numbers
   Proper divisors
   Sieve of Eratosthenes


See also

   the OEIS entry for   A48050 Chowla's function.

",#C.23,C#,"using System;
 
namespace chowla_cs
{
    class Program
    {
        static int chowla(int n)
        {
            int sum = 0;
            for (int i = 2, j; i * i <= n; i++)
                if (n % i == 0) sum += i + (i == (j = n / i) ? 0 : j);
            return sum;
        }
 
        static bool[] sieve(int limit)
        {
            // True denotes composite, false denotes prime.
            // Only interested in odd numbers >= 3
            bool[] c = new bool[limit];
            for (int i = 3; i * 3 < limit; i += 2)
                if (!c[i] && (chowla(i) == 0))
                    for (int j = 3 * i; j < limit; j += 2 * i)
                        c[j] = true;
            return c;
        }
 
        static void Main(string[] args)
        {
            for (int i = 1; i <= 37; i++)
                Console.WriteLine(""chowla({0}) = {1}"", i, chowla(i));
            int count = 1, limit = (int)(1e7), power = 100;
            bool[] c = sieve(limit);
            for (int i = 3; i < limit; i += 2)
            {
                if (!c[i]) count++;
                if (i == power - 1)
                {
                    Console.WriteLine(""Count of primes up to {0,10:n0} = {1:n0}"", power, count);
                    power *= 10;
                }
            }
 
            count = 0; limit = 35000000;
            int k = 2, kk = 3, p;
            for (int i = 2; ; i++)
            {
                if ((p = k * kk) > limit) break;
                if (chowla(p) == p - 1)
                {
                    Console.WriteLine(""{0,10:n0} is a number that is perfect"", p);
                    count++;
                }
                k = kk + 1; kk += k;
            }
            Console.WriteLine(""There are {0} perfect numbers <= 35,000,000"", count);
            if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();
        }
    }
}",1880,59
68253,http://rosettacode.org/wiki/Check_output_device_is_a_terminal,Check output device is a terminal,"Task

Demonstrate how to check whether the output device is a terminal or not.



Related task

   Check input device is a terminal

",#C.23,C#,"using System;
 
namespace CheckTerminal {
    class Program {
        static void Main(string[] args) {
            Console.WriteLine(""Stdout is tty: {0}"", Console.IsOutputRedirected);
        }
    }
}",202,9
68255,http://rosettacode.org/wiki/Cholesky_decomposition,Cholesky decomposition,"Every symmetric, positive definite matrix A can be decomposed into a product of a unique lower triangular matrix L and its transpose:





A
=
L

L

T




{\displaystyle A=LL^{T}}






L


{\displaystyle L}

 is called the Cholesky factor of 



A


{\displaystyle A}

, and can be interpreted as a generalized square root of 



A


{\displaystyle A}

, as described in Cholesky decomposition.

In a 3x3 example, we have to solve the following system of equations:









A



=


(




a

11





a

21





a

31







a

21





a

22





a

32







a

31





a

32





a

33





)








=


(




l

11




0


0





l

21





l

22




0





l

31





l

32





l

33





)




(




l

11





l

21





l

31






0



l

22





l

32






0


0



l

33





)


≡
L

L

T








=


(




l

11


2





l

21



l

11





l

31



l

11







l

21



l

11





l

21


2


+

l

22


2





l

31



l

21


+

l

32



l

22







l

31



l

11





l

31



l

21


+

l

32



l

22





l

31


2


+

l

32


2


+

l

33


2





)








{\displaystyle {\begin{aligned}A&={\begin{pmatrix}a_{11}&a_{21}&a_{31}\\a_{21}&a_{22}&a_{32}\\a_{31}&a_{32}&a_{33}\\\end{pmatrix}}\\&={\begin{pmatrix}l_{11}&0&0\\l_{21}&l_{22}&0\\l_{31}&l_{32}&l_{33}\\\end{pmatrix}}{\begin{pmatrix}l_{11}&l_{21}&l_{31}\\0&l_{22}&l_{32}\\0&0&l_{33}\end{pmatrix}}\equiv LL^{T}\\&={\begin{pmatrix}l_{11}^{2}&l_{21}l_{11}&l_{31}l_{11}\\l_{21}l_{11}&l_{21}^{2}+l_{22}^{2}&l_{31}l_{21}+l_{32}l_{22}\\l_{31}l_{11}&l_{31}l_{21}+l_{32}l_{22}&l_{31}^{2}+l_{32}^{2}+l_{33}^{2}\end{pmatrix}}\end{aligned}}}


We can see that for the diagonal elements (




l

k
k




{\displaystyle l_{kk}}

) of 



L


{\displaystyle L}

 there is a calculation pattern:






l

11


=



a

11






{\displaystyle l_{11}={\sqrt {a_{11}}}}







l

22


=



a

22


−

l

21


2






{\displaystyle l_{22}={\sqrt {a_{22}-l_{21}^{2}}}}







l

33


=



a

33


−
(

l

31


2


+

l

32


2


)




{\displaystyle l_{33}={\sqrt {a_{33}-(l_{31}^{2}+l_{32}^{2})}}}


or in general:






l

k
k


=



a

k
k


−

∑

j
=
1


k
−
1



l

k
j


2






{\displaystyle l_{kk}={\sqrt {a_{kk}-\sum _{j=1}^{k-1}l_{kj}^{2}}}}


For the elements below the diagonal (




l

i
k




{\displaystyle l_{ik}}

, where 



i
>
k


{\displaystyle i>k}

) there is also a calculation pattern:






l

21


=


1

l

11





a

21




{\displaystyle l_{21}={\frac {1}{l_{11}}}a_{21}}







l

31


=


1

l

11





a

31




{\displaystyle l_{31}={\frac {1}{l_{11}}}a_{31}}







l

32


=


1

l

22




(

a

32


−

l

31



l

21


)


{\displaystyle l_{32}={\frac {1}{l_{22}}}(a_{32}-l_{31}l_{21})}


which can also be expressed in a general formula:






l

i
k


=


1

l

k
k





(

a

i
k


−

∑

j
=
1


k
−
1



l

i
j



l

k
j


)



{\displaystyle l_{ik}={\frac {1}{l_{kk}}}\left(a_{ik}-\sum _{j=1}^{k-1}l_{ij}l_{kj}\right)}


Task description

The task is to implement a routine which will return a lower Cholesky factor 



L


{\displaystyle L}

 for every given symmetric, positive definite nxn matrix 



A


{\displaystyle A}

. You should then test it on the following two examples and include your output.

Example 1:

25  15  -5                 5   0   0
15  18   0         -->     3   3   0
-5   0  11                -1   1   3

Example 2:

18  22   54   42           4.24264    0.00000    0.00000    0.00000
22  70   86   62   -->     5.18545    6.56591    0.00000    0.00000
54  86  174  134          12.72792    3.04604    1.64974    0.00000
42  62  134  106           9.89949    1.62455    1.84971    1.39262



Note

 The Cholesky decomposition of a Pascal upper-triangle matrix is the Identity matrix of the same size. 
 The Cholesky decomposition of a Pascal symmetric matrix is the Pascal lower-triangle matrix of the same size.",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace Cholesky
{
    class Program
    {
        /// <summary>
        /// This is example is written in C#, and compiles with .NET Framework 4.0
        /// </summary>
        /// <param name=""args""></param>
        static void Main(string[] args)
        {
            double[,] test1 = new double[,]
            {
                {25, 15, -5},
                {15, 18, 0},
                {-5, 0, 11},
            };
 
            double[,] test2 = new double[,]
            {
                {18, 22, 54, 42},
                {22, 70, 86, 62},
                {54, 86, 174, 134},
                {42, 62, 134, 106},
            };
 
            double[,] chol1 = Cholesky(test1);
            double[,] chol2 = Cholesky(test2);
 
            Console.WriteLine(""Test 1: "");
            Print(test1);
            Console.WriteLine("""");
            Console.WriteLine(""Lower Cholesky 1: "");
            Print(chol1);
            Console.WriteLine("""");
            Console.WriteLine(""Test 2: "");
            Print(test2);
            Console.WriteLine("""");
            Console.WriteLine(""Lower Cholesky 2: "");
            Print(chol2);
 
        }
 
        public static void Print(double[,] a)
        {
            int n = (int)Math.Sqrt(a.Length);
 
            StringBuilder sb = new StringBuilder();
            for (int r = 0; r < n; r++)
            {
                string s = """";
                for (int c = 0; c < n; c++)
                {
                    s += a[r, c].ToString(""f5"").PadLeft(9) + "","";
                }
                sb.AppendLine(s);
            }
 
            Console.WriteLine(sb.ToString());
        }
 
        /// <summary>
        /// Returns the lower Cholesky Factor, L, of input matrix A. 
        /// Satisfies the equation: L*L^T = A.
        /// </summary>
        /// <param name=""a"">Input matrix must be square, symmetric, 
        /// and positive definite. This method does not check for these properties,
        /// and may produce unexpected results of those properties are not met.</param>
        /// <returns></returns>
        public static double[,] Cholesky(double[,] a)
        {
            int n = (int)Math.Sqrt(a.Length);
 
            double[,] ret = new double[n, n];
            for (int r = 0; r < n; r++)
                for (int c = 0; c <= r; c++)
                {
                    if (c == r)
                    {
                        double sum = 0;
                        for (int j = 0; j < c; j++)
                        {
                            sum += ret[c, j] * ret[c, j];
                        }
                        ret[c, c] = Math.Sqrt(a[c, c] - sum);
                    }
                    else
                    {
                        double sum = 0;
                        for (int j = 0; j < c; j++)
                            sum += ret[r, j] * ret[c, j];
                        ret[r, c] = 1.0 / ret[c, c] * (a[r, c] - sum);
                    }
                }
 
            return ret;
        }
    }
}",3122,103
68307,http://rosettacode.org/wiki/Circles_of_given_radius_through_two_points,Circles of given radius through two points,"
Given two points on a plane and a radius, usually two circles of given radius can be drawn through the points.

Exceptions

 r==0.0 should be treated as never describing circles (except in the case where the points are coincident).
 If the points are coincident then an infinite number of circles with the point on their circumference can be drawn, unless r==0.0 as well which then collapses the circles to a point.
 If the points form a diameter then return two identical circles or return a single circle, according to which is the most natural mechanism for the implementation language.
 If the points are too far apart then no circles can be drawn.


Task detail

 Write a function/subroutine/method/... that takes two points and a radius and returns the two circles through those points, or some indication of special cases where two, possibly equal, circles cannot be returned.
 Show here the output for the following inputs:
      p1                p2           r
0.1234, 0.9876    0.8765, 0.2345    2.0
0.0000, 2.0000    0.0000, 0.0000    1.0
0.1234, 0.9876    0.1234, 0.9876    2.0
0.1234, 0.9876    0.8765, 0.2345    0.5
0.1234, 0.9876    0.1234, 0.9876    0.0



Related task

   Total circles area.


See also

   Finding the Center of a Circle from 2 Points and Radius from Math forum @ Drexel

",#C.23,C#,"using System;
public class CirclesOfGivenRadiusThroughTwoPoints
{
    public static void Main()
    {
        double[][] values = new double[][] {
            new [] { 0.1234, 0.9876, 0.8765, 0.2345,   2 },
            new [] { 0.0,       2.0,    0.0,    0.0,   1 },
            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   2 },
            new [] { 0.1234, 0.9876, 0.8765, 0.2345, 0.5 },
            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   0 }
        };
 
        foreach (var a in values) {
            var p = new Point(a[0], a[1]);
            var q = new Point(a[2], a[3]);
            Console.WriteLine($""Points {p} and {q} with radius {a[4]}:"");
            try {
                var centers = FindCircles(p, q, a[4]);
                Console.WriteLine(""\t"" + string.Join("" and "", centers));
            } catch (Exception ex) {
                Console.WriteLine(""\t"" + ex.Message);
            }
        }
    }
 
    static Point[] FindCircles(Point p, Point q, double radius) {
        if(radius < 0) throw new ArgumentException(""Negative radius."");
        if(radius == 0) {
            if(p == q) return new [] { p };
            else throw new InvalidOperationException(""No circles."");
        }
        if (p == q) throw new InvalidOperationException(""Infinite number of circles."");
 
        double sqDistance = Point.SquaredDistance(p, q);
        double sqDiameter = 4 * radius * radius;
        if (sqDistance > sqDiameter) throw new InvalidOperationException(""Points are too far apart."");
 
        Point midPoint = new Point((p.X + q.X) / 2, (p.Y + q.Y) / 2);
        if (sqDistance == sqDiameter) return new [] { midPoint };
 
        double d = Math.Sqrt(radius * radius - sqDistance / 4);
        double distance = Math.Sqrt(sqDistance);
        double ox = d * (q.X - p.X) / distance, oy = d * (q.Y - p.Y) / distance;
        return new [] {
            new Point(midPoint.X - oy, midPoint.Y + ox),
            new Point(midPoint.X + oy, midPoint.Y - ox)
        };
    }
 
    public struct Point
    {
        public Point(double x, double y) : this() {
            X = x;
            Y = y;
        }
 
        public double X { get; }
        public double Y { get; }
 
        public static bool operator ==(Point p, Point q) => p.X == q.X && p.Y == q.Y;
        public static bool operator !=(Point p, Point q) => p.X != q.X || p.Y != q.Y;
 
        public static double SquaredDistance(Point p, Point q) {
            double dx = q.X - p.X, dy = q.Y - p.Y;
            return dx * dx + dy * dy;
        }
 
        public override string ToString() => $""({X}, {Y})"";
 
    }	
}",2610,72
68328,http://rosettacode.org/wiki/Chinese_remainder_theorem,Chinese remainder theorem,"Suppose   




n

1




{\displaystyle n_{1}}

,   




n

2




{\displaystyle n_{2}}

,   



…


{\displaystyle \ldots }

,   




n

k




{\displaystyle n_{k}}

   are positive integers that are pairwise co-prime.  

Then, for any given sequence of integers   




a

1




{\displaystyle a_{1}}

,   




a

2




{\displaystyle a_{2}}

,   



…


{\displaystyle \dots }

,   




a

k




{\displaystyle a_{k}}

,   there exists an integer   



x


{\displaystyle x}

   solving the following system of simultaneous congruences:

 







x



≡

a

1




(
mod


n

1


)





x



≡

a

2




(
mod


n

2


)








 
 
⋮




x



≡

a

k




(
mod


n

k


)







{\displaystyle {\begin{aligned}x&\equiv a_{1}{\pmod {n_{1}}}\\x&\equiv a_{2}{\pmod {n_{2}}}\\&{}\ \ \vdots \\x&\equiv a_{k}{\pmod {n_{k}}}\end{aligned}}}


Furthermore, all solutions   



x


{\displaystyle x}

   of this system are congruent modulo the product,   



N
=

n

1



n

2


…

n

k




{\displaystyle N=n_{1}n_{2}\ldots n_{k}}

.



Task

Write a program to solve a system of linear congruences by applying the   Chinese Remainder Theorem.

If the system of equations cannot be solved, your program must somehow indicate this.

(It may throw an exception or return a special false value.)

Since there are infinitely many solutions, the program should return the unique solution   



s


{\displaystyle s}

   where   



0
≤
s
≤

n

1



n

2


…

n

k




{\displaystyle 0\leq s\leq n_{1}n_{2}\ldots n_{k}}

.


Show the functionality of this program by printing the result such that the   



n


{\displaystyle n}

's   are   



[
3
,
5
,
7
]


{\displaystyle [3,5,7]}

   and the   



a


{\displaystyle a}

's   are   



[
2
,
3
,
2
]


{\displaystyle [2,3,2]}

.


Algorithm:   The following algorithm only applies if the   




n

i




{\displaystyle n_{i}}

's   are pairwise co-prime.

Suppose, as above, that a solution is required for the system of congruences:

 



x
≡

a

i




(
mod


n

i


)



f
o
r


i
=
1
,
…
,
k


{\displaystyle x\equiv a_{i}{\pmod {n_{i}}}\quad \mathrm {for} \;i=1,\ldots ,k}


Again, to begin, the product   



N
=

n

1



n

2


…

n

k




{\displaystyle N=n_{1}n_{2}\ldots n_{k}}

   is defined.

Then a solution   



x


{\displaystyle x}

   can be found as follows:

For each   



i


{\displaystyle i}

,   the integers   




n

i




{\displaystyle n_{i}}

   and   



N

/


n

i




{\displaystyle N/n_{i}}

   are co-prime.

Using the   Extended Euclidean algorithm,   we can find integers   




r

i




{\displaystyle r_{i}}

   and   




s

i




{\displaystyle s_{i}}

   such that   




r

i



n

i


+

s

i


N

/


n

i


=
1


{\displaystyle r_{i}n_{i}+s_{i}N/n_{i}=1}

.

Then, one solution to the system of simultaneous congruences is:

 



x
=

∑

i
=
1


k



a

i



s

i


N

/


n

i




{\displaystyle x=\sum _{i=1}^{k}a_{i}s_{i}N/n_{i}}


and the minimal solution,

 



x


(
mod

N
)



{\displaystyle x{\pmod {N}}}

.

",#C.23,C#,"using System;
using System.Linq;
 
namespace ChineseRemainderTheorem
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] n = { 3, 5, 7 };
            int[] a = { 2, 3, 2 };
 
            int result = ChineseRemainderTheorem.Solve(n, a);
 
            int counter = 0;
            int maxCount = n.Length - 1;
            while (counter <= maxCount)
            {
                Console.WriteLine($""{result} ≡ {a[counter]} (mod {n[counter]})"");
                counter++;
            }
        }
    }
 
    public static class ChineseRemainderTheorem
    {
        public static int Solve(int[] n, int[] a)
        {
            int prod = n.Aggregate(1, (i, j) => i * j);
            int p;
            int sm = 0;
            for (int i = 0; i < n.Length; i++)
            {
                p = prod / n[i];
                sm += a[i] * ModularMultiplicativeInverse(p, n[i]) * p;
            }
            return sm % prod;
        }
 
        private static int ModularMultiplicativeInverse(int a, int mod)
        {
            int b = a % mod;
            for (int x = 1; x < mod; x++)
            {
                if ((b * x) % mod == 1)
                {
                    return x;
                }
            }
            return 1;
        }
    }
}",1307,53
68374,http://rosettacode.org/wiki/Chinese_zodiac,Chinese zodiac,"Traditionally, the Chinese have counted years using two simultaneous cycles, one of length 10 (the ""celestial stems"") and one of length 12 (the ""terrestrial branches""); the combination results in a repeating 60-year pattern. Mapping the branches to twelve traditional animal deities results in the well-known ""Chinese zodiac"", assigning each year to a given animal. For example, Tuesday, February 1, 2022 CE (in the common Gregorian calendar) will begin the lunisolar Year of the Tiger.

The celestial stems have no one-to-one mapping like that of the branches to animals; however, the five pairs of consecutive stems each belong to one of the five traditional Chinese elements (Wood, Fire, Earth, Metal, and Water). Further, one of the two years within each element's governance is associated with yin, the other with yang.

Thus, 2022 is also the yang year of Water. Note that since 12 is an even number, the association between animals and yin/yang doesn't change. Consecutive Years of the Rooster will cycle through the five elements, but will always be yin, despite the apparent conceptual mismatch between the specifically-male English animal name and the female aspect denoted by yin.

Task
 Create a subroutine or program that will return or output the animal, yin/yang association, and element for the lunisolar year that begins in a given CE year.
You may optionally provide more information in the form of the year's numerical position within the 60-year cycle and/or its actual Chinese stem-branch name (in Han characters or Pinyin transliteration).

Requisite information

 The animal cycle runs in this order: Rat, Ox, Tiger, Rabbit, Dragon, Snake, Horse, Goat, Monkey, Rooster, Dog, Pig.
 The element cycle runs in this order: Wood, Fire, Earth, Metal, Water.
 The yang year precedes the yin year within each element.
 The current 60-year cycle began in 1984 CE; the first cycle of the Common Era began in 4 CE.
Thus, 1984 was the year of the Wood Rat (yang), 1985 was the year of the Wood Ox (yin), and 1986 the year of the Fire Tiger (yang); 2022 - which, as already noted, is the year of the Water Tiger (yang) - is the 39th year of the current cycle.

Information for optional task

 The ten celestial stems are 甲 jiă, 乙 yĭ, 丙 bĭng, 丁 dīng, 戊 wù, 己 jĭ, 庚 gēng, 辛 xīn, 壬 rén, and 癸 gŭi. With the ASCII version of Pinyin tones, the names are written ""jia3"", ""yi3"", ""bing3"", ""ding1"", ""wu4"", ""ji3"", ""geng1"", ""xin1"", ""ren2"", and ""gui3"".
 The twelve terrestrial branches are 子 zĭ, 丑 chŏu, 寅 yín, 卯 măo, 辰 chén, 巳 sì, 午 wŭ, 未 wèi, 申 shēn, 酉 yŏu, 戌 xū, 亥 hài. In ASCII Pinyin, those are ""zi3"", ""chou3"", ""yin2"", ""mao3"", ""chen2"", ""si4"", ""wu3"", ""wei4"", ""shen1"", ""you3"", ""xu1"", and ""hai4"".
Therefore 1984 was 甲子 (jiă-zĭ, or jia3-zi3). 2022 is 壬寅 (rén-yín or ren2-yin2).
",#C.23,C#,"using System;
 
namespace ChineseZodiac {
    class Program {
        static string[] animals = { ""Rat"", ""Ox"", ""Tiger"", ""Rabbit"", ""Dragon"", ""Snake"", ""Horse"", ""Goat"", ""Monkey"", ""Rooster"", ""Dog"", ""Pig"" };
        static string[] elements = { ""Wood"", ""Fire"", ""Earth"", ""Metal"", ""Water"" };
        static string[] animalChars = { ""子"", ""丑"", ""寅"", ""卯"", ""辰"", ""巳"", ""午"", ""未"", ""申"", ""酉"", ""戌"", ""亥"" };
        static string[,] elementChars = { { ""甲"", ""丙"", ""戊"", ""庚"", ""壬"" }, { ""乙"", ""丁"", ""己"", ""辛"", ""癸"" } };
 
        static string getYY(int year) {
            if (year % 2 == 0) {
                return ""yang"";
            }
            return ""yin"";
        }
 
        static void Main(string[] args) {
            Console.OutputEncoding = System.Text.Encoding.UTF8;
            int[] years = { 1935, 1938, 1968, 1972, 1976, 1984, 1985, 2017 };
            for (int i = 0; i < years.Length; i++) {
                int ei = (int)Math.Floor((years[i] - 4.0) % 10 / 2);
                int ai = (years[i] - 4) % 12;
                Console.WriteLine(""{0} is the year of the {1} {2} ({3}). {4}{5}"", years[i], elements[ei], animals[ai], getYY(years[i]), elementChars[years[i] % 2, ei], animalChars[(years[i] - 4) % 12]);
            }
        }
    }
}",1233,27
68422,http://rosettacode.org/wiki/Cheryl%27s_birthday,Cheryl's birthday,"Albert and Bernard just became friends with Cheryl, and they want to know when her birthday is.

Cheryl gave them a list of ten possible dates:

     May 15,     May 16,     May 19
     June 17,    June 18
     July 14,    July 16
     August 14,  August 15,  August 17

Cheryl then tells Albert the   month   of birth,   and Bernard the   day   (of the month)   of birth.

 1)  Albert:   I don't know when Cheryl's birthday is, but I know that Bernard does not know too.
 2)  Bernard:  At first I don't know when Cheryl's birthday is, but I know now.
 3)  Albert:   Then I also know when Cheryl's birthday is.



Task
Write a computer program to deduce, by successive elimination, Cheryl's birthday.



Related task

 Sum and Product Puzzle


References
 Wikipedia article of the same name.
 Tuple Relational Calculus

",#C.23,C#,"public static class CherylsBirthday
{
    public static void Main() {
        var dates = new HashSet<(string month, int day)> {
            (""May"", 15),
            (""May"", 16),
            (""May"", 19),
            (""June"", 17),
            (""June"", 18),
            (""July"", 14),
            (""July"", 16),
            (""August"", 14),
            (""August"", 15),
            (""August"", 17)
        };
 
        Console.WriteLine(dates.Count + "" remaining."");
        //The month cannot have a unique day.
        var monthsWithUniqueDays = dates.GroupBy(d => d.day).Where(g => g.Count() == 1).Select(g => g.First().month).ToHashSet();
        dates.RemoveWhere(d => monthsWithUniqueDays.Contains(d.month));
        Console.WriteLine(dates.Count + "" remaining."");
        //The day must now be unique.
        dates.IntersectWith(dates.GroupBy(d => d.day).Where(g => g.Count() == 1).Select(g => g.First()));
        Console.WriteLine(dates.Count + "" remaining."");
        //The month must now be unique.
        dates.IntersectWith(dates.GroupBy(d => d.month).Where(g => g.Count() == 1).Select(g => g.First()));
        Console.WriteLine(dates.Single());
    }
 
}",1164,30
68528,http://rosettacode.org/wiki/Chat_server,Chat server,"Task

Write a server for a minimal text based chat.

People should be able to connect via ‘telnet’, sign on with a nickname, and type messages which will then be seen by all other connected users. Arrivals and departures of chat members should generate appropriate notification messages.



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Net.Sockets;
using System.Text;
using System.Threading;
 
namespace ChatServer {
    class State {
        private TcpClient client;
        private StringBuilder sb = new StringBuilder();
 
        public string Name { get; }
 
        public State(string name, TcpClient client) {
            Name = name;
            this.client = client;
        }
 
        public void Add(byte b) {
            sb.Append((char)b);
        }
 
        public void Send(string text) {
            var bytes = Encoding.ASCII.GetBytes(string.Format(""{0}\r\n"", text));
            client.GetStream().Write(bytes, 0, bytes.Length);
        }
    }
 
    class Program {
        static TcpListener listen;
        static Thread serverthread;
        static Dictionary<int, State> connections = new Dictionary<int, State>();
 
        static void Main(string[] args) {
            listen = new TcpListener(System.Net.IPAddress.Parse(""127.0.0.1""), 4004);
            serverthread = new Thread(new ThreadStart(DoListen));
            serverthread.Start();
        }
 
        private static void DoListen() {
            // Listen
            listen.Start();
            Console.WriteLine(""Server: Started server"");
 
            while (true) {
                Console.WriteLine(""Server: Waiting..."");
                TcpClient client = listen.AcceptTcpClient();
                Console.WriteLine(""Server: Waited"");
 
                // New thread with client
                Thread clientThread = new Thread(new ParameterizedThreadStart(DoClient));
                clientThread.Start(client);
            }
        }
 
        private static void DoClient(object client) {
            // Read data
            TcpClient tClient = (TcpClient)client;
 
            Console.WriteLine(""Client (Thread: {0}): Connected!"", Thread.CurrentThread.ManagedThreadId);
            byte[] bytes = Encoding.ASCII.GetBytes(""Enter name: "");
            tClient.GetStream().Write(bytes, 0, bytes.Length);
 
            string name = string.Empty;
            bool done = false;
            do {
                if (!tClient.Connected) {
                    Console.WriteLine(""Client (Thread: {0}): Terminated!"", Thread.CurrentThread.ManagedThreadId);
                    tClient.Close();
                    Thread.CurrentThread.Abort();       // Kill thread.
                }
 
                name = Receive(tClient);
                done = true;
 
                if (done) {
                    foreach (var cl in connections) {
                        var state = cl.Value;
                        if (state.Name == name) {
                            bytes = Encoding.ASCII.GetBytes(""Name already registered. Please enter your name: "");
                            tClient.GetStream().Write(bytes, 0, bytes.Length);
                            done = false;
                        }
                    }
                }
            } while (!done);
 
            connections.Add(Thread.CurrentThread.ManagedThreadId, new State(name, tClient));
            Console.WriteLine(""\tTotal connections: {0}"", connections.Count);
            Broadcast(string.Format(""+++ {0} arrived +++"", name));
 
            do {
                string text = Receive(tClient);
                if (text == ""/quit"") {
                    Broadcast(string.Format(""Connection from {0} closed."", name));
                    connections.Remove(Thread.CurrentThread.ManagedThreadId);
                    Console.WriteLine(""\tTotal connections: {0}"", connections.Count);
                    break;
                }
 
                if (!tClient.Connected) {
                    break;
                }
                Broadcast(string.Format(""{0}> {1}"", name, text));
            } while (true);
 
            Console.WriteLine(""Client (Thread: {0}): Terminated!"", Thread.CurrentThread.ManagedThreadId);
            tClient.Close();
            Thread.CurrentThread.Abort();
        }
 
        private static string Receive(TcpClient client) {
            StringBuilder sb = new StringBuilder();
            do {
                if (client.Available > 0) {
                    while (client.Available > 0) {
                        char ch = (char)client.GetStream().ReadByte();
                        if (ch == '\r') {
                            //ignore
                            continue;
                        }
                        if (ch == '\n') {
                            return sb.ToString();
                        }
                        sb.Append(ch);
                    }
                }
 
                // Pause
                Thread.Sleep(100);
            } while (true);
        }
 
        private static void Broadcast(string text) {
            Console.WriteLine(text);
            foreach (var oClient in connections) {
                if (oClient.Key != Thread.CurrentThread.ManagedThreadId) {
                    State state = oClient.Value;
                    state.Send(text);
                }
            }
        }
    }
}",5082,144
68575,http://rosettacode.org/wiki/Chaos_game,Chaos game,"The Chaos Game is a method of generating the attractor of an iterated function system (IFS).

One of the best-known and simplest examples creates a fractal, using a polygon and an initial point selected at random.



Task
Play the Chaos Game using the corners of an equilateral triangle as the reference points.   Add a starting point at random (preferably inside the triangle).   Then add the next point halfway between the starting point and one of the reference points.   This reference point is chosen at random.

After a sufficient number of iterations, the image of a Sierpinski Triangle should emerge.



See also
 The Game of Chaos

",#C.23,C#,"using System.Diagnostics;
using System.Drawing;
 
namespace RosettaChaosGame
{
    class Program
    {
        static void Main(string[] args)
        {
            var bm = new Bitmap(600, 600);
 
            var referencePoints = new Point[] {
                new Point(0, 600),
                new Point(600, 600),
                new Point(300, 81)
            };
            var r = new System.Random();
            var p = new Point(r.Next(600), r.Next(600));
            for (int count = 0; count < 10000; count++)
            {
                bm.SetPixel(p.X, p.Y, Color.Magenta);
                int i = r.Next(3);
                p.X = (p.X + referencePoints[i].X) / 2;
                p.Y = (p.Y + referencePoints[i].Y) / 2;
            }
            const string filename = ""Chaos Game.png"";
            bm.Save(filename);
            Process.Start(filename);
        }
    }
}",890,31
68674,http://rosettacode.org/wiki/Check_that_file_exists,Check that file exists,"Task

Verify that a file called     input.txt     and   a directory called     docs     exist.



This should be done twice:  

   once for the current working directory,   and
   once for a file and a directory in the filesystem root.


Optional criteria (May 2015):   verify it works with:

   zero-length files
   an unusual filename:     `Abdu'l-Bahá.txt  

",#C.23,C#,"using System.IO;
 
Console.WriteLine(File.Exists(""input.txt""));
Console.WriteLine(File.Exists(""/input.txt""));
Console.WriteLine(Directory.Exists(""docs""));
Console.WriteLine(Directory.Exists(""/docs""));",200,6
68777,http://rosettacode.org/wiki/Character_codes,Character codes,"

Task

Given a character value in your language, print its code   (could be ASCII code, Unicode code, or whatever your language uses).



Example

The character   'a'   (lowercase letter A)   has a code of 97 in ASCII   (as well as Unicode, as ASCII forms the beginning of Unicode).

Conversely, given a code, print out the corresponding character.



",#C.23,C#,"using System;
 
namespace RosettaCode.CharacterCode
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine((int) 'a');   //Prints ""97""
            Console.WriteLine((char) 97);   //Prints ""a""
        }
    }
}",260,13
69546,http://rosettacode.org/wiki/Chaocipher,Chaocipher,"Description

The Chaocipher was invented by J.F.Byrne in 1918 and, although simple by modern cryptographic standards, does not appear to have been broken until the algorithm was finally disclosed by his family in 2010.

The algorithm is described in this paper by M.Rubin in 2010 and there is a C# implementation here.



Task

Code the algorithm in your language and to test that it works with the plaintext 'WELLDONEISBETTERTHANWELLSAID' used in the paper itself.



",#C.23,C#,"using System;
 
namespace Chaocipher {
    enum Mode {
        ENCRYPT,
        DECRYPT,
    }
 
    class Program {
        const string L_ALPHABET = ""HXUCZVAMDSLKPEFJRIGTWOBNYQ"";
        const string R_ALPHABET = ""PTLNBQDEOYSFAVZKGJRIHWXUMC"";
 
        static string Exec(string text, Mode mode, bool showSteps = false) {
            char[] left = L_ALPHABET.ToCharArray();
            char[] right = R_ALPHABET.ToCharArray();
            char[] eText = new char[text.Length];
            char[] temp = new char[26];
 
            for (int i = 0; i < text.Length; ++i) {
                if (showSteps) Console.WriteLine(""{0} {1}"", string.Join("""", left), string.Join("""", right));
                int index = 0;
                if (mode == Mode.ENCRYPT) {
                    index = Array.IndexOf(right, text[i]);
                    eText[i] = left[index];
                } else {
                    index = Array.IndexOf(left, text[i]);
                    eText[i] = right[index];
                }
                if (i == text.Length - 1) break;
 
                // permute left
 
                for (int j = index; j < 26; ++j) temp[j - index] = left[j];
                for (int j = 0; j < index; ++j) temp[26 - index + j] = left[j];
                var store = temp[1];
                for (int j = 2; j < 14; ++j) temp[j - 1] = temp[j];
                temp[13] = store;
                temp.CopyTo(left, 0);
 
                // permute right
 
                for (int j = index; j < 26; ++j) temp[j - index] = right[j];
                for (int j = 0; j < index; ++j) temp[26 - index + j] = right[j];
                store = temp[0];
                for (int j = 1; j < 26; ++j) temp[j - 1] = temp[j];
                temp[25] = store;
                store = temp[2];
                for (int j = 3; j < 14; ++j) temp[j - 1] = temp[j];
                temp[13] = store;
                temp.CopyTo(right, 0);
            }
 
            return new string(eText);
        }
 
        static void Main(string[] args) {
            var plainText = ""WELLDONEISBETTERTHANWELLSAID"";
            Console.WriteLine(""The original plaintext is : {0}"", plainText);
            Console.WriteLine(""\nThe left and right alphabets after each permutation during encryption are :\n"");
            var cipherText = Exec(plainText, Mode.ENCRYPT, true);
            Console.WriteLine(""\nThe ciphertext is : {0}"", cipherText);
            var plainText2 = Exec(cipherText, Mode.DECRYPT);
            Console.WriteLine(""\nThe recovered plaintext is : {0}"", plainText2);
        }
    }
}",2583,66
69560,http://rosettacode.org/wiki/Catalan_numbers/Pascal%27s_triangle,Catalan numbers/Pascal's triangle,"Task

Print out the first   15   Catalan numbers by extracting them from Pascal's triangle.



See

   Catalan Numbers and the Pascal Triangle.     This method enables calculation of Catalan Numbers using only addition and subtraction.
   Catalan's Triangle for a Number Triangle that generates Catalan Numbers using only addition.
   Sequence A000108 on OEIS has a lot of information on Catalan Numbers.
Related Tasks

Pascal's triangle
",#C.23,C#," 
int n = 15;
List<int> t = new List<int>() { 0, 1 };
for (int i = 1; i <= n; i++)
{
    for (var j = i; j > 1; j--) t[j] += t[j - 1];
    t.Add(t[i]);
    for (var j = i + 1; j > 1; j--) t[j] += t[j - 1];
    Console.Write(((i == 1) ? """" : "", "") + (t[i + 1] - t[i]));
}
 ",272,11
69581,http://rosettacode.org/wiki/Case-sensitivity_of_identifiers,Case-sensitivity of identifiers,"Three dogs (Are there three dogs or one dog?) is a code snippet used to illustrate the lettercase sensitivity of the programming language. For a case-sensitive language, the identifiers dog, Dog and DOG are all different and we should get the output:

The three dogs are named Benjamin, Samba and Bernie.

For a language that is lettercase insensitive, we get the following output:

There is just one dog named Bernie.



Related task

 Unicode variable names

",#C.23,C#," 
using System;
 
class Program
{
    static void Main(string[] args)
    {
        string dog = ""Benjamin"";
        string Dog = ""Samba"";
        string DOG = ""Bernie"";
        Console.WriteLine(string.Format(""The three dogs are named {0}, {1}, and {2}."", dog, Dog, DOG));
    }
}",281,13
69649,http://rosettacode.org/wiki/Cartesian_product_of_two_or_more_lists,Cartesian product of two or more lists,"Task

Show one or more idiomatic ways of generating the Cartesian product of two arbitrary lists in your language.

Demonstrate that your function/method correctly returns:

{1, 2} × {3, 4} = {(1, 3), (1, 4), (2, 3), (2, 4)}
and, in contrast:

{3, 4} × {1, 2} = {(3, 1), (3, 2), (4, 1), (4, 2)}
Also demonstrate, using your function/method, that the product of an empty list with any other list is empty.

 {1, 2} × {} = {}
 {} × {1, 2} = {}
For extra credit, show or write a function returning the n-ary product of an arbitrary number of lists, each of arbitrary length. Your function might, for example, accept a single argument which is itself a list of lists, and return the n-ary product of those lists.

Use your n-ary Cartesian product function to show the following products:

 {1776, 1789} × {7, 12} × {4, 14, 23} × {0, 1}
 {1, 2, 3} × {30} × {500, 100}
 {1, 2, 3} × {} × {500, 100}

",#C.23,C#,"using System;
public class Program
{
    public static void Main()
    {
        int[] empty = new int[0];
        int[] list1 = { 1, 2 };
        int[] list2 = { 3, 4 };
        int[] list3 = { 1776, 1789 };
        int[] list4 = { 7, 12 };
        int[] list5 = { 4, 14, 23 };
        int[] list6 = { 0, 1 };
        int[] list7 = { 1, 2, 3 };
        int[] list8 = { 30 };
        int[] list9 = { 500, 100 };
 
        foreach (var sequenceList in new [] {
            new [] { list1, list2 },
            new [] { list2, list1 },
            new [] { list1, empty },
            new [] { empty, list1 },
            new [] { list3, list4, list5, list6 },
            new [] { list7, list8, list9 },
            new [] { list7, empty, list9 }
        }) {
            var cart = sequenceList.CartesianProduct()
                .Select(tuple => $""({string.Join("", "", tuple)})"");
            Console.WriteLine($""{{{string.Join("", "", cart)}}}"");
        }
    }
}
 
public static class Extensions
{
    public static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> sequences) {
        IEnumerable<IEnumerable<T>> emptyProduct = new[] { Enumerable.Empty<T>() };
        return sequences.Aggregate(
            emptyProduct,
            (accumulator, sequence) =>
            from acc in accumulator
            from item in sequence
            select acc.Concat(new [] { item }));
    }
}",1422,44
69665,http://rosettacode.org/wiki/Catamorphism,Catamorphism,"Reduce is a function or method that is used to take the values in an array or a list and apply a function to successive members of the list to produce (or reduce them to), a single value.



Task

Show how reduce (or foldl or foldr etc), work (or would be implemented) in your language.



See also

 Wikipedia article:   Fold
 Wikipedia article:   Catamorphism

",#C.23,C#,"var nums = Enumerable.Range(1, 10);
 
int summation = nums.Aggregate((a, b) => a + b);
 
int product = nums.Aggregate((a, b) => a * b);
 
string concatenation = nums.Aggregate(String.Empty, (a, b) => a.ToString() + b.ToString());
 
Console.WriteLine(""{0} {1} {2}"", summation, product, concatenation);",300,9
69673,http://rosettacode.org/wiki/Casting_out_nines,Casting out nines,"Task   (in three parts)



Part 1
Write a procedure (say 





c
o
9


(
x
)


{\displaystyle {\mathit {co9}}(x)}

) which implements Casting Out Nines as described by returning the checksum for 



x


{\displaystyle x}

. Demonstrate the procedure using the examples given there, or others you may consider lucky.

Part 2
Notwithstanding past Intel microcode errors, checking computer calculations like this would not be sensible. To find a computer use for your procedure:

 Consider the statement ""318682 is 101558 + 217124 and squared is 101558217124"" (see: Kaprekar numbers#Casting Out Nines (fast)).
 note that 



318682


{\displaystyle 318682}

 has the same checksum as (



101558
+
217124


{\displaystyle 101558+217124}

);
 note that 



101558217124


{\displaystyle 101558217124}

 has the same checksum as (



101558
+
217124


{\displaystyle 101558+217124}

) because for a Kaprekar they are made up of the same digits (sometimes with extra zeroes);
 note that this implies that for Kaprekar numbers the checksum of 



k


{\displaystyle k}

 equals the checksum of 




k

2




{\displaystyle k^{2}}

.
Demonstrate that your procedure can be used to generate or filter a range of numbers with the property 





c
o
9


(
k
)
=


c
o
9


(

k

2


)


{\displaystyle {\mathit {co9}}(k)={\mathit {co9}}(k^{2})}

 and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.

Part 3
Considering this MathWorld page, produce a efficient algorithm based on the more mathematical treatment of Casting Out Nines, and realizing:

 





c
o
9


(
x
)


{\displaystyle {\mathit {co9}}(x)}

 is the residual of 



x


{\displaystyle x}

 mod 



9


{\displaystyle 9}

;
 the procedure can be extended to bases other than 9.
Demonstrate your algorithm by generating or filtering a range of numbers with the property 



k
%
(


B
a
s
e


−
1
)
==
(

k

2


)
%
(


B
a
s
e


−
1
)


{\displaystyle k\%({\mathit {Base}}-1)==(k^{2})\%({\mathit {Base}}-1)}

 and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.



related tasks
 First perfect square in base N with N unique digits
 Kaprekar numbers

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace CastingOutNines {
    public static class Helper {
        public static string AsString<T>(this IEnumerable<T> e) {
            var it = e.GetEnumerator();
 
            StringBuilder builder = new StringBuilder();
            builder.Append(""["");
 
            if (it.MoveNext()) {
                builder.Append(it.Current);
            }
            while (it.MoveNext()) {
                builder.Append("", "");
                builder.Append(it.Current);
            }
 
            builder.Append(""]"");
            return builder.ToString();
        }
    }
 
    class Program {
        static List<int> CastOut(int @base, int start, int end) {
            int[] ran = Enumerable
                .Range(0, @base - 1)
                .Where(a => a % (@base - 1) == (a * a) % (@base - 1))
                .ToArray();
            int x = start / (@base - 1);
 
            List<int> result = new List<int>();
            while (true) {
                foreach (int n in ran) {
                    int k = (@base - 1) * x + n;
                    if (k < start) {
                        continue;
                    }
                    if (k > end) {
                        return result;
                    }
                    result.Add(k);
                }
                x++;
            }
        }
 
        static void Main() {
            Console.WriteLine(CastOut(16, 1, 255).AsString());
            Console.WriteLine(CastOut(10, 1, 99).AsString());
            Console.WriteLine(CastOut(17, 1, 288).AsString());
        }
    }
}",1651,57
69717,http://rosettacode.org/wiki/Canonicalize_CIDR,Canonicalize CIDR,"Task

Implement a function or program that, given a range of IPv4 addresses in CIDR notation (dotted-decimal/network-bits), will return/output the same range in canonical form.

That is, the IP address portion of the output CIDR block must not contain any set (1) bits in the host part of the address.



Example

Given   87.70.141.1/22,   your code should output   87.70.140.0/22



Explanation

An Internet Protocol version 4 address is a 32-bit value, conventionally represented as a number in base 256 using dotted-decimal notation, where each base-256 ""digit"" is represented by the digit value in decimal and the digits are separated by periods. Logically, this 32-bit value represents two components: the leftmost (most-significant) bits determine the ""network"" portion of the address, while the rightmost (least-significant) bits determine the ""host"" portion. Classless Internet Domain Routing block notation indicates where the boundary between these two components is for a given address by adding a slash followed by the number of bits in the network portion.

In general, CIDR blocks stand in for the entire set of IP addresses sharing the same ""network"" component; it's common to see access control lists specify a single IP address using CIDR with /32 to indicate that only the one address is included. Often, the tools using this notation expect the address to be entered in canonical form, in which the ""host"" bits are all zeroes in the binary representation. But careless network admins may provide CIDR blocks without canonicalizing them first. This task handles the canonicalization.

The example address, 87.70.141.1, translates into 01010111010001101000110100000001 in binary notation zero-padded to 32 bits. The /22 means that the first 22 of those bits determine the match; the final 10 bits should be 0. But they instead include two 1 bits: 0100000001. So to canonicalize the address, change those 1's to 0's to yield 01010111010001101000110000000000, which in dotted-decimal is 87.70.140.0.



More examples for testing
        36.18.154.103/12    →  36.16.0.0/12
        62.62.197.11/29     →  62.62.197.8/29
        67.137.119.181/4    →  64.0.0.0/4
        161.214.74.21/24    →  161.214.74.0/24
        184.232.176.184/18  →  184.232.128.0/18


",#C.23,C#,"using System;
using System.Net;
using System.Linq;
 
public class Program
{
    public static void Main()
    {
        string[] tests = {
            ""87.70.141.1/22"",
            ""36.18.154.103/12"",
            ""62.62.197.11/29"",
            ""67.137.119.181/4"",
            ""161.214.74.21/24"",
            ""184.232.176.184/18""
        };
 
        foreach (string t in tests) Console.WriteLine($""{t}   =>   {Canonicalize(t)}"");
    }
 
    static string Canonicalize(string cidr) => CIDR.Parse(cidr).Canonicalize().ToString();
}
 
readonly struct CIDR
{
    public readonly IPAddress ip;
    public readonly int length;
 
    public static CIDR Parse(string cidr)
    {
        string[] parts = cidr.Split('/');
        return new CIDR(IPAddress.Parse(parts[0]), int.Parse(parts[1]));
    }
 
    public CIDR(IPAddress ip, int length) => (this.ip, this.length) = (ip, length);
 
    public CIDR Canonicalize() =>
        new CIDR(
            new IPAddress(
                ToBytes(
                    ToInt(
                        ip.GetAddressBytes()
                    )
                    & ~((1 << (32 - length)) - 1)
                )
            ),
            length
        );
 
    private int ToInt(byte[] bytes) => bytes.Aggregate(0, (n, b) => (n << 8) | b);
 
    private byte[] ToBytes(int n)
    {
        byte[] bytes = new byte[4];
        for (int i = 3; i >= 0; i--) {
            bytes[i] = (byte)(n & 0xFF);
            n >>= 8;
        }
        return bytes;
    }
 
    public override string ToString() => $""{ip}/{length}"";
}",1556,63
69833,http://rosettacode.org/wiki/Call_a_function_in_a_shared_library,Call a function in a shared library,"Show how to call a function in a shared library (without dynamically linking to it at compile-time). In particular, show how to call the shared library function if the library is available, otherwise use an internal equivalent function.

This is a special case of calling a foreign language function where the focus is close to the ABI level and not at the normal API level.



Related task

 OpenGL -- OpenGL is usually maintained as a shared library.

",#C.23,C#,"using System.Runtime.InteropServices;
 
class Program {
    [DllImport(""fakelib.dll"")]
    public static extern int fakefunction(int args);
 
    static void Main(string[] args) {
        int r = fakefunction(10);
    }
}",221,10
69858,http://rosettacode.org/wiki/Cantor_set,Cantor set,"Task

Draw a Cantor set.



See details at this Wikipedia webpage:   Cantor set
",#C.23,C#,"using System;
 
namespace CantorSet {
    class Program {
        const int WIDTH = 81;
        const int HEIGHT = 5;
        private static char[,] lines = new char[HEIGHT, WIDTH];
 
        static Program() {
            for (int i = 0; i < HEIGHT; i++) {
                for (int j = 0; j < WIDTH; j++) {
                    lines[i, j] = '*';
                }
            }
        }
 
        private static void Cantor(int start, int len, int index) {
            int seg = len / 3;
            if (seg == 0) return;
            for (int i = index; i < HEIGHT; i++) {
                for (int j = start + seg; j < start + seg * 2; j++) {
                    lines[i, j] = ' ';
                }
            }
            Cantor(start, seg, index + 1);
            Cantor(start + seg * 2, seg, index + 1);
        }
 
        static void Main(string[] args) {
            Cantor(0, WIDTH, 1);
            for (int i = 0; i < HEIGHT; i++) {
                for (int j = 0; j < WIDTH; j++) {
                    Console.Write(lines[i,j]);
                }
                Console.WriteLine();
            }
        }
    }
}",1129,39
69922,http://rosettacode.org/wiki/Catalan_numbers,Catalan numbers,"Catalan numbers

You are encouraged to solve this task according to the task description, using any language you may know.


Catalan numbers are a sequence of numbers which can be defined directly:






C

n


=


1

n
+
1






(



2
n

n


)



=



(
2
n
)
!


(
n
+
1
)
!

n
!





 for 

n
≥
0.


{\displaystyle C_{n}={\frac {1}{n+1}}{2n \choose n}={\frac {(2n)!}{(n+1)!\,n!}}\qquad {\mbox{ for }}n\geq 0.}


Or recursively:






C

0


=
1


and



C

n
+
1


=

∑

i
=
0


n



C

i




C

n
−
i




for 

n
≥
0
;


{\displaystyle C_{0}=1\quad {\mbox{and}}\quad C_{n+1}=\sum _{i=0}^{n}C_{i}\,C_{n-i}\quad {\text{for }}n\geq 0;}


Or alternatively (also recursive):






C

0


=
1


and



C

n


=



2
(
2
n
−
1
)


n
+
1




C

n
−
1


,


{\displaystyle C_{0}=1\quad {\mbox{and}}\quad C_{n}={\frac {2(2n-1)}{n+1}}C_{n-1},}




Task

Implement at least one of these algorithms and print out the first 15 Catalan numbers with each.

Memoization   is not required, but may be worth the effort when using the second method above.



Related tasks

Catalan numbers/Pascal's triangle
Evaluate binomial coefficients

",#C.23,C#,"namespace CatalanNumbers
{
    /// <summary>
    /// Class that holds all options.
    /// </summary>
    public class CatalanNumberGenerator
    {
        private static double Factorial(double n)
        {
            if (n == 0)
                return 1;
 
            return n * Factorial(n - 1);
        }
 
        public double FirstOption(double n)
        {
            const double topMultiplier = 2;
            return Factorial(topMultiplier * n) / (Factorial(n + 1) * Factorial(n));
        }
 
        public double SecondOption(double n)
        {
            if (n == 0)
            {
                return 1;
            }
            double sum = 0;
            double i = 0;
            for (; i <= (n - 1); i++)
            {
                sum += SecondOption(i) * SecondOption((n - 1) - i);
            }
            return sum;
        }
 
        public double ThirdOption(double n)
        {
            if (n == 0)
            {
                return 1;
            }
            return ((2 * (2 * n - 1)) / (n + 1)) * ThirdOption(n - 1);
        }
    }
}
 
 
// Program.cs
using System;
using System.Configuration;
 
// Main program
// Be sure to add the following to the App.config file and add a reference to System.Configuration:
// <?xml version=""1.0"" encoding=""utf-8"" ?>
// <configuration>
//  <appSettings>
//    <clear/>
//    <add key=""MaxCatalanNumber"" value=""50""/>
//  </appSettings>
// </configuration>
namespace CatalanNumbers
{
    class Program
    {
        static void Main(string[] args)
        {
            CatalanNumberGenerator generator = new CatalanNumberGenerator();
            int i = 0;
            DateTime initial;
            DateTime final;
            TimeSpan ts;
 
            try
            {
                initial = DateTime.Now;
                for (; i <= Convert.ToInt32(ConfigurationManager.AppSettings[""MaxCatalanNumber""]); i++)
                {
                    Console.WriteLine(""CatalanNumber({0}):{1}"", i, generator.FirstOption(i));
                }
                final = DateTime.Now;
                ts = final - initial;
                Console.WriteLine(""It took {0}.{1} to execute\n"", ts.Seconds, ts.Milliseconds);
 
                i = 0;
                initial = DateTime.Now;
                for (; i <= Convert.ToInt32(ConfigurationManager.AppSettings[""MaxCatalanNumber""]); i++)
                {
                    Console.WriteLine(""CatalanNumber({0}):{1}"", i, generator.SecondOption(i));
                }
                final = DateTime.Now;
                ts = final - initial;
                Console.WriteLine(""It took {0}.{1} to execute\n"", ts.Seconds, ts.Milliseconds);   
 
                i = 0;
                initial = DateTime.Now;
                for (; i <= Convert.ToInt32(ConfigurationManager.AppSettings[""MaxCatalanNumber""]); i++)
                {
                    Console.WriteLine(""CatalanNumber({0}):{1}"", i, generator.ThirdOption(i));
                }
                final = DateTime.Now;
                ts = final - initial;
                Console.WriteLine(""It took {0}.{1} to execute"", ts.Seconds, ts.Milliseconds, ts.TotalMilliseconds);
                Console.ReadLine();
            }
            catch (Exception ex)
            {
                Console.WriteLine(""Stopped at index {0}:"", i);
                Console.WriteLine(ex.Message);
                Console.ReadLine();
            }
        }
    }
}",3447,114
70151,http://rosettacode.org/wiki/Burrows%E2%80%93Wheeler_transform,Burrows–Wheeler transform,"

 This page uses content from Wikipedia. The original article was at Burrows–Wheeler_transform. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The Burrows–Wheeler transform (BWT, also called block-sorting compression) rearranges a character string into runs of similar characters.

This is useful for compression, since it tends to be easy to compress a string that has runs of repeated characters by techniques such as move-to-front transform and run-length encoding.

More importantly, the transformation is reversible, without needing to store any additional data.

The BWT is thus a ""free"" method of improving the efficiency of text compression algorithms, costing only some extra computation.



Source: Burrows–Wheeler transform
",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace BurrowsWheeler {
    class Program {
        const char STX = (char)0x02;
        const char ETX = (char)0x03;
 
        private static void Rotate(ref char[] a) {
            char t = a.Last();
            for (int i = a.Length - 1; i > 0; --i) {
                a[i] = a[i - 1];
            }
            a[0] = t;
        }
 
        // For some reason, strings do not compare how whould be expected
        private static int Compare(string s1, string s2) {
            for (int i = 0; i < s1.Length && i < s2.Length; ++i) {
                if (s1[i] < s2[i]) {
                    return -1;
                }
                if (s2[i] < s1[i]) {
                    return 1;
                }
            }
            if (s1.Length < s2.Length) {
                return -1;
            }
            if (s2.Length < s1.Length) {
                return 1;
            }
            return 0;
        }
 
        static string Bwt(string s) {
            if (s.Any(a => a == STX || a == ETX)) {
                throw new ArgumentException(""Input can't contain STX or ETX"");
            }
            char[] ss = (STX + s + ETX).ToCharArray();
            List<string> table = new List<string>();
            for (int i = 0; i < ss.Length; ++i) {
                table.Add(new string(ss));
                Rotate(ref ss);
            }
            table.Sort(Compare);
            return new string(table.Select(a => a.Last()).ToArray());
        }
 
        static string Ibwt(string r) {
            int len = r.Length;
            List<string> table = new List<string>(new string[len]);
            for (int i = 0; i < len; ++i) {
                for (int j = 0; j < len; ++j) {
                    table[j] = r[j] + table[j];
                }
                table.Sort(Compare);
            }
            foreach (string row in table) {
                if (row.Last() == ETX) {
                    return row.Substring(1, len - 2);
                }
            }
            return """";
        }
 
        static string MakePrintable(string s) {
            return s.Replace(STX, '^').Replace(ETX, '|');
        }
 
        static void Main() {
            string[] tests = new string[] {
                ""banana"",
                ""appellee"",
                ""dogwood"",
                ""TO BE OR NOT TO BE OR WANT TO BE OR NOT?"",
                ""SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES"",
                ""\u0002ABC\u0003""
            };
 
            foreach (string test in tests) {
                Console.WriteLine(MakePrintable(test));
                Console.Write("" --> "");
 
                string t = """";
                try {
                    t = Bwt(test);
                    Console.WriteLine(MakePrintable(t));
                } catch (Exception e) {
                    Console.WriteLine(""ERROR: {0}"", e.Message);
                }
 
                string r = Ibwt(t);
                Console.WriteLine("" --> {0}"", r);
                Console.WriteLine();
            }
        }
    }
}",3102,100
70179,http://rosettacode.org/wiki/Calculating_the_value_of_e,Calculating the value of e,"Task

Calculate the value of   e.



(e   is also known as   Euler's number   and   Napier's constant.)



See details: Calculating the value of e
",#C.23,C#,"using System;
 
namespace CalculateE {
    class Program {
        public const double EPSILON = 1.0e-15;
 
        static void Main(string[] args) {
            ulong fact = 1;
            double e = 2.0;
            double e0;
            uint n = 2;
            do {
                e0 = e;
                fact *= n++;
                e += 1.0 / fact;
            } while (Math.Abs(e - e0) >= EPSILON);
            Console.WriteLine(""e = {0:F15}"", e);
        }
    }
}",473,20
70209,http://rosettacode.org/wiki/Bulls_and_cows/Player,Bulls and cows/Player,"Task

Write a player of the Bulls and Cows game, rather than a scorer. The player should give intermediate answers that respect the scores to previous attempts.

One method is to generate a list of all possible numbers that could be the answer, then to prune the list by keeping only those numbers that would give an equivalent score to how your last guess was scored. Your next guess can be any number from the pruned list.

Either you guess correctly or run out of numbers to guess, which indicates a problem with the scoring.



Related tasks

   Bulls and cows
   Guess the number
   Guess the number/With Feedback (Player)

",#C.23,C#," 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace BullsAndCows
{
    class Program
    {
        const int ANSWER_SIZE = 4;
 
        static IEnumerable<string> Permutations(int size)
        {
            if (size > 0)
            {
                foreach (string s in Permutations(size - 1))
                    foreach (char n in ""123456789"")
                        if (!s.Contains(n))
                            yield return s + n;
            }
            else
                yield return """";
        }
 
        static IEnumerable<T> Shuffle<T>(IEnumerable<T> source)
        {
            Random random = new Random();
            List<T> list = source.ToList();
            while (list.Count > 0)
            {
                int ix = random.Next(list.Count);
                yield return list[ix];
                list.RemoveAt(ix);
            }
        }
 
        static bool ReadBullsCows(out int bulls, out int cows)
        {
            string[] input = Console.ReadLine().Split(',').ToArray();
            bulls = cows = 0;
            if (input.Length < 2)
                return false;
            else
                return int.TryParse(input[0], out bulls)
                    && int.TryParse(input[1], out cows);
        }
 
        static void Main(string[] args)
        {
            Console.WriteLine(""Bulls and Cows"");
            Console.WriteLine(""=============="");
            Console.WriteLine();
            List<string> answers = Shuffle(Permutations(ANSWER_SIZE)).ToList();
            while (answers.Count > 1)
            {
                string guess = answers[0];
                Console.Write(""My guess is {0}. How many bulls, cows? "", guess);
                int bulls, cows;
                if (!ReadBullsCows(out bulls, out cows))
                    Console.WriteLine(""Sorry, I didn't understand that. Please try again."");
                else
                    for (int ans = answers.Count - 1; ans >= 0; ans--)
                    {
                        int tb = 0, tc = 0;
                        for (int ix = 0; ix < ANSWER_SIZE; ix++)
                            if (answers[ans][ix] == guess[ix])
                                tb++;
                            else if (answers[ans].Contains(guess[ix]))
                                tc++;
                        if ((tb != bulls) || (tc != cows))
                            answers.RemoveAt(ans);
                    }
            }
            if (answers.Count == 1)
                Console.WriteLine(""Hooray! The answer is {0}!"", answers[0]);
            else
                Console.WriteLine(""No possible answer fits the scores you gave."");
        }
    }
}
 ",2735,82
70321,http://rosettacode.org/wiki/Break_OO_privacy,Break OO privacy,"Show how to access private or protected members of a class in an object-oriented language from outside an instance of the class, without calling non-private or non-protected members of the class as a proxy.
The intent is to show how a debugger, serializer, or other meta-programming tool might access information that is barred by normal access methods to the object but can nevertheless be accessed from within the language by some provided escape hatch or reflection mechanism.
The intent is specifically not to demonstrate heroic measures such as peeking and poking raw memory.

Note that cheating on your type system is almost universally regarded
as unidiomatic at best, and poor programming practice at worst.
Nonetheless, if your language intentionally maintains a double-standard for OO privacy, here's where you can show it off.
",#C.23,C#,"using System;
using System.Reflection;
 
public class MyClass
{
    private int answer = 42;
}
 
public class Program
{
    public static void Main()
    {
        var myInstance = new MyClass();
        var fieldInfo = typeof(MyClass).GetField(""answer"", BindingFlags.NonPublic | BindingFlags.Instance);
        var answer = fieldInfo.GetValue(myInstance);
        Console.WriteLine(answer);
    }
}",399,18
70393,http://rosettacode.org/wiki/Call_a_function,Call a function,"Task

Demonstrate the different syntax and semantics provided for calling a function.



This may include:

   Calling a function that requires no arguments
   Calling a function with a fixed number of arguments
   Calling a function with optional arguments
   Calling a function with a variable number of arguments
   Calling a function with named arguments
   Using a function in statement context
   Using a function in first-class context within an expression
   Obtaining the return value of a function
   Distinguishing built-in functions and user-defined functions
   Distinguishing subroutines and functions
   Stating whether arguments are passed by value or by reference
   Is partial application possible and how


This task is not about defining functions.



",#C.23,C#," 
/* a function that has no argument */
	public int MyFunction();
 
	/* a function with a fixed number of arguments */
	FunctionWithArguments(4, 3, 2);
 
	/* a function with optional arguments */
	public void OptArg();
 
	public static void Main()
	{
		OptArg(1);
		OptArg(1, 2);
		OptArg(1, 2, 3);
	}
	public void ExampleMethod(int required, 
        string optionalstr = ""default string"",
		int optionalint = 10)
	/* If you know the first and the last parameter */
	ExampleMethod(3, optionalint: 4);
 
	/* If you know all the parameter */
	ExampleMethod(3, ""Hello World"", 4);
 
	/* Variable number of arguments use array */
	public static void UseVariableParameters(params int[] list) 
 
	/* Obtain return value from function */
	public internal MyFunction();
	int returnValue = MyFunction();
 ",796,32
70493,http://rosettacode.org/wiki/Brownian_tree,Brownian tree,"Brownian tree

You are encouraged to solve this task according to the task description, using any language you may know.



Task

Generate and draw a   Brownian Tree.



A Brownian Tree is generated as a result of an initial seed, followed by the interaction of two processes.

 The initial ""seed"" is placed somewhere within the field. Where is not particularly important; it could be randomized, or it could be a fixed point.
 Particles are injected into the field, and are individually given a (typically random) motion pattern.
 When a particle collides with the seed or tree, its position is fixed, and it's considered to be part of the tree.

Because of the lax rules governing the random nature of the particle's placement and motion, no two resulting trees are really expected to be the same, or even necessarily have the same general shape. 


",#C.23,C#,"using System;
using System.Drawing;
 
namespace BrownianTree
{
    class Program
    {
        static Bitmap BrownianTree(int size, int numparticles)
        {
            Bitmap bmp = new Bitmap(size, size);
            Rectangle bounds = new Rectangle { X = 0, Y = 0, Size = bmp.Size };
            using (Graphics g = Graphics.FromImage(bmp))
            {
                g.Clear(Color.Black);
            }
            Random rnd = new Random();
            bmp.SetPixel(rnd.Next(size), rnd.Next(size), Color.White);
            Point pt = new Point(), newpt = new Point();
            for (int i = 0; i < numparticles; i++)
            {
                pt.X = rnd.Next(size);
                pt.Y = rnd.Next(size);
                do
                {
                    newpt.X = pt.X + rnd.Next(-1, 2);
                    newpt.Y = pt.Y + rnd.Next(-1, 2);
                    if (!bounds.Contains(newpt))
                    {
                        pt.X = rnd.Next(size);
                        pt.Y = rnd.Next(size);
                    }
                    else if (bmp.GetPixel(newpt.X, newpt.Y).R > 0)
                    {
                        bmp.SetPixel(pt.X, pt.Y, Color.White);
                        break;
                    }
                    else
                    {
                        pt = newpt;
                    }
                } while (true);
            }
            return bmp;
        }
 
        static void Main(string[] args)
        {
            BrownianTree(300, 3000).Save(""browniantree.png"");
        }
    }
}",1575,51
70509,http://rosettacode.org/wiki/Brace_expansion,Brace expansion,"Brace expansion is a type of parameter expansion made popular by Unix shells, where it allows users to specify multiple similar string parameters without having to type them all out. E.g. the parameter enable_{audio,video} would be interpreted as if both enable_audio and enable_video had been specified.



Task[edit]
Write a function that can perform brace expansion on any input string, according to the following specification.

Demonstrate how it would be used, and that it passes the four test cases given below.

Specification
In the input string, balanced pairs of braces containing comma-separated substrings (details below) represent alternations that specify multiple alternatives which are to appear at that position in the output. In general, one can imagine the information conveyed by the input string as a tree of nested alternations interspersed with literal substrings, as shown in the middle part of the following diagram:


It{{em,alic}iz,erat}e{d,}

parse 
―――――▶
‌



It




⎧
⎨
⎩





⎧
⎨
⎩

em

⎫
⎬
⎭


alic



iz


⎫
⎬
⎭


erat


e




⎧
⎨
⎩

d

⎫
⎬
⎭


‌





expand 
―――――▶
‌
Itemized
Itemize
Italicized
Italicize
Iterated
Iterate


input string

alternation tree

output (list of strings)

This tree can in turn be transformed into the intended list of output strings by, colloquially speaking, determining all the possible ways to walk through it from left to right while only descending into one branch of each alternation one comes across (see the right part of the diagram). When implementing it, one can of course combine the parsing and expansion into a single algorithm, but this specification discusses them separately for the sake of clarity.

Expansion of alternations can be more rigorously described by these rules:





a




⎧
⎨
⎩

2

⎫
⎬
⎭


1


b




⎧
⎨
⎩

X

⎫
⎬
⎭


Y
X


c



⟶

a2bXc
a2bYc
a2bXc
a1bXc
a1bYc
a1bXc




An alternation causes the list of alternatives that will be produced by its parent branch to be increased 𝑛-fold, each copy featuring one of the 𝑛 alternatives produced by the alternation's child branches, in turn, at that position.


This means that multiple alternations inside the same branch are cumulative  (i.e. the complete list of alternatives produced by a branch is the string-concatenating ""Cartesian product"" of its parts).


All alternatives (even duplicate and empty ones) are preserved, and they are ordered like the examples demonstrate  (i.e. ""lexicographically"" with regard to the alternations).


The alternatives produced by the root branch constitute the final output.


Parsing the input string involves some additional complexity to deal with escaped characters and ""incomplete"" brace pairs:


a\\{\\\{b,c\,d}
⟶


a\\




⎧
⎨
⎩

\\\{b

⎫
⎬
⎭


c\,d





{a,b{c{,{d}}e}f
⟶


{a,b{c




⎧
⎨
⎩

‌

⎫
⎬
⎭


{d}


e}f





An unescaped backslash which precedes another character, escapes that character (to force it to be treated as literal). The backslashes are passed along to the output unchanged.


Balanced brace pairs are identified by, conceptually, going through the string from left to right and associating each unescaped closing brace that is encountered with the nearest still unassociated unescaped opening brace to its left (if any). Furthermore, each unescaped comma is associated with the innermost brace pair that contains it (if any). With that in mind:


Each brace pair that has at least one comma associated with it, forms an alternation (whose branches are the brace pair's contents split at its commas). The associated brace and comma characters themselves do not become part of the output.


Brace characters from pairs without any associated comma, as well as unassociated brace and comma characters, as well as all characters that are not covered by the preceding rules, are instead treated as literals.




For every possible input string, your implementation should produce exactly the output which this specification mandates. Please comply with this even when it's inconvenient, to ensure that all implementations are comparable. However, none of the above should be interpreted as instructions (or even recommendations) for how to implement it. Try to come up with a solution that is idiomatic in your programming language. (See #Perl for a reference implementation.)

Test Cases


 Input
(single string)

 Ouput
(list/array of strings)



~/{Downloads,Pictures}/*.{jpg,gif,png}



~/Downloads/*.jpg
~/Downloads/*.gif
~/Downloads/*.png
~/Pictures/*.jpg
~/Pictures/*.gif
~/Pictures/*.png




It{{em,alic}iz,erat}e{d,}, please.



Itemized, please.
Itemize, please.
Italicized, please.
Italicize, please.
Iterated, please.
Iterate, please.




{,{,gotta have{ ,\, again\, }}more }cowbell!



cowbell!
more cowbell!
gotta have more cowbell!
gotta have\, again\, more cowbell!




{}} some }{,{\\{ edge, edge} \,}{ cases, {here} \\\\\}



{}} some }{,{\\ edge \,}{ cases, {here} \\\\\}
{}} some }{,{\\ edge \,}{ cases, {here} \\\\\}




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




   Brace_expansion_using_ranges

",#C.23,C#,"using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using static System.Linq.Enumerable;
 
public static class BraceExpansion
{
    enum TokenType { OpenBrace, CloseBrace, Separator, Text, Alternate, Concat }
    const char L = '{', R = '}', S = ',';
 
    public static void Main() {
        string[] input = {
            ""It{{em,alic}iz,erat}e{d,}, please."",
            ""~/{Downloads,Pictures}/*.{jpg,gif,png}"",
            @""{,{,gotta have{ ,\, again\, }}more }cowbell!"",
            @""{}} some }{,{\\{ edge, edge} \,}{ cases, {here} \\\\\}""
        };
        foreach (string text in input) Expand(text);
    }
 
    static void Expand(string input) {
        Token token = Tokenize(input);
        foreach (string value in token) Console.WriteLine(value);
        Console.WriteLine();
    }
 
    static Token Tokenize(string input) {
        var tokens = new List<Token>();
        var buffer = new StringBuilder();
        bool escaping = false;
        int level = 0;
 
        foreach (char c in input) {
            (escaping, level, tokens, buffer) = c switch {
                _ when escaping => (false, level, tokens, buffer.Append(c)),
                '\\' => (true, level, tokens, buffer.Append(c)),
                L => (escaping, level + 1,
                    tokens.With(buffer.Flush()).With(new Token(c.ToString(), TokenType.OpenBrace)), buffer),
                S when level > 0 => (escaping, level,
                    tokens.With(buffer.Flush()).With(new Token(c.ToString(), TokenType.Separator)), buffer),
                R when level > 0 => (escaping, level - 1,
                    tokens.With(buffer.Flush()).With(new Token(c.ToString(), TokenType.CloseBrace)).Merge(), buffer),
                _ => (escaping, level, tokens, buffer.Append(c))
            };
        }
        if (buffer.Length > 0) tokens.Add(buffer.Flush());
        for (int i = 0; i < tokens.Count; i++) {
            if (tokens[i].Type == TokenType.OpenBrace || tokens[i].Type == TokenType.Separator) {
                tokens[i] = tokens[i].Value; //Change to text
            }
        }
        return new Token(tokens, TokenType.Concat);
    }
 
    static List<Token> Merge(this List<Token> list) {
        int separators = 0;
        int last = list.Count - 1;
        for (int i = list.Count - 3; i >= 0; i--) {
            if (list[i].Type == TokenType.Separator) {
                separators++;
                Concat(list, i + 1, last);
                list.RemoveAt(i);
                last = i;
            } else if (list[i].Type == TokenType.OpenBrace) {
                Concat(list, i + 1, last);
                if (separators > 0) {
                    list[i] = new Token(list.Range((i+1)..^1), TokenType.Alternate);
                    list.RemoveRange(i+1, list.Count - i - 1);
                } else {
                    list[i] = L.ToString();
                    list[^1] = R.ToString();
                    Concat(list, i, list.Count);
                }
                break;
            }
        }
        return list;
    }
 
    static void Concat(List<Token> list, int s, int e) {
        for (int i = e - 2; i >= s; i--) {
            (Token a, Token b) = (list[i], list[i+1]);
            switch (a.Type, b.Type) {
                case (TokenType.Text, TokenType.Text):
                    list[i] = a.Value + b.Value;
                    list.RemoveAt(i+1);
                    break;
                case (TokenType.Concat, TokenType.Concat):
                    a.SubTokens.AddRange(b.SubTokens);
                    list.RemoveAt(i+1);
                    break;
                case (TokenType.Concat, TokenType.Text) when b.Value == """":
                    list.RemoveAt(i+1);
                    break;
                case (TokenType.Text, TokenType.Concat) when a.Value == """":
                    list.RemoveAt(i);
                    break;
                default:
                    list[i] = new Token(new [] { a, b }, TokenType.Concat);
                    list.RemoveAt(i+1);
                    break;
            }
        }
    }
 
    private struct Token : IEnumerable<string>
    {
        private List<Token>? _subTokens;
 
        public string Value { get; }
        public TokenType Type { get; }
        public List<Token> SubTokens => _subTokens ??= new List<Token>();
 
        public Token(string value, TokenType type) => (Value, Type, _subTokens) = (value, type, null);
        public Token(IEnumerable<Token> subTokens, TokenType type) => (Value, Type, _subTokens) = ("""", type, subTokens.ToList());
 
        public static implicit operator Token(string value) => new Token(value, TokenType.Text);
 
        public IEnumerator<string> GetEnumerator() => (Type switch
        {
            TokenType.Concat => SubTokens.Select(t => t.AsEnumerable()).CartesianProduct().Select(p => string.Join("""", p)),
            TokenType.Alternate => from t in SubTokens from s in t select s,
            _ => Repeat(Value, 1)
        }).GetEnumerator();
 
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();        
    }
 
    //===Extension methods===
    static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> sequences) {
        IEnumerable<IEnumerable<T>> emptyProduct = new[] { Empty<T>() };
        return sequences.Aggregate(
            emptyProduct,
            (accumulator, sequence) =>
                from acc in accumulator
                from item in sequence
                select acc.Concat(new [] { item }));
    }
 
    static List<Token> With(this List<Token> list, Token token) {
        list.Add(token);
        return list;
    }
 
    static IEnumerable<Token> Range(this List<Token> list, Range range) {
        int start = range.Start.GetOffset(list.Count);
        int end = range.End.GetOffset(list.Count);
        for (int i = start; i < end; i++) yield return list[i];
    }
 
    static string Flush(this StringBuilder builder) {
        string result = builder.ToString();
        builder.Clear();
        return result;
    }
}",6106,157
70576,http://rosettacode.org/wiki/Brazilian_numbers,Brazilian numbers,"Brazilian numbers are so called as they were first formally presented at the 1994 math Olympiad Olimpiada Iberoamericana de Matematica in Fortaleza, Brazil.

Brazilian numbers are defined as:

The set of positive integer numbers where each number N has at least one natural number B where 1 < B < N-1 where the representation of N in base B has all equal digits.



E.G.

 1, 2 & 3 can not be Brazilian; there is no base B that satisfies the condition 1 < B < N-1.
 4 is not Brazilian; 4 in base 2 is 100. The digits are not all the same.
 5 is not Brazilian; 5 in base 2 is 101, in base 3 is 12. There is no representation where the digits are the same.
 6 is not Brazilian; 6 in base 2 is 110, in base 3 is 20, in base 4 is 12. There is no representation where the digits are the same.
 7 is Brazilian; 7 in base 2 is 111. There is at least one representation where the digits are all the same.
 8 is Brazilian; 8 in base 3 is 22. There is at least one representation where the digits are all the same.
 and so on...


All even integers 2P >= 8 are Brazilian because 2P = 2(P-1) + 2, which is 22 in base P-1 when P-1 > 2. That becomes true when P >= 4.

More common: for all all integers R and S, where R > 1 and also S-1 > R, then R*S is Brazilian because R*S = R(S-1) + R, which is RR in base S-1

The only problematic numbers are squares of primes, where R = S. Only 11^2 is brazilian to base 3.

All prime integers, that are brazilian, can only have the digit 1. Otherwise one could factor out the digit, therefore it cannot be a prime number. Mostly in form of 111 to base Integer(sqrt(prime number)). Must be an odd count of 1 to stay odd like primes > 2


Task

Write a routine (function, whatever) to determine if a number is Brazilian and use the routine to show here, on this page;

 the first 20 Brazilian numbers;
 the first 20 odd Brazilian numbers;
 the first 20 prime Brazilian numbers;


See also

 OEIS:A125134 - Brazilian numbers
 OEIS:A257521 - Odd Brazilian numbers
 OEIS:A085104 - Prime Brazilian numbers

",#C.23,C#,"using System;
class Program {
 
  static bool sameDigits(int n, int b) {
    int f = n % b;
    while ((n /= b) > 0) if (n % b != f) return false;
    return true;
  }
 
  static bool isBrazilian(int n) {
    if (n < 7) return false;
    if (n % 2 == 0) return true;
    for (int b = 2; b < n - 1; b++) if (sameDigits(n, b)) return true;
    return false;
  }
 
  static bool isPrime(int n) {
    if (n < 2) return false;
    if (n % 2 == 0) return n == 2;
    if (n % 3 == 0) return n == 3;
    int d = 5;
    while (d * d <= n) {
      if (n % d == 0) return false; d += 2;
      if (n % d == 0) return false; d += 4;
    }
    return true;
  }
 
  static void Main(string[] args) {
    foreach (string kind in "",odd ,prime "".Split(',')) {
      bool quiet = false; int BigLim = 99999, limit = 20;
      Console.WriteLine(""First {0} {1}Brazilian numbers:"", limit, kind);
      int c = 0, n = 7;
      while (c < BigLim) {
        if (isBrazilian(n)) {
          if (!quiet) Console.Write(""{0:n0} "", n);
          if (++c == limit) { Console.Write(""\n\n""); quiet = true; }
        }
        if (quiet && kind != """") continue;
        switch (kind) {
          case """": n++; break;
          case ""odd "": n += 2; break;
          case ""prime "":
            while (true) {
              n += 2;
              if (isPrime(n)) break;
            } break;
        }
      }
      if (kind == """") Console.WriteLine(""The {0:n0}th Brazilian number is: {1:n0}\n"", BigLim + 1, n);
    }
  }
}",1483,53
70597,http://rosettacode.org/wiki/Calendar,Calendar,"Create a routine that will generate a text calendar for any year.
Test the calendar by generating a calendar for the year 1969, on a device of the time.
Choose one of the following devices:

 A line printer with a width of 132 characters.
 An IBM 3278 model 4 terminal (80×43 display with accented characters). Target formatting the months of the year to fit nicely across the 80 character width screen. Restrict number of lines in test output to 43.


(Ideally, the program will generate well-formatted calendars for any page width from 20 characters up.)

Kudos (κῦδος) for routines that also transition from Julian to Gregorian calendar.

This task is inspired by Real Programmers Don't Use PASCAL by Ed Post, Datamation, volume 29 number 7, July 1983.

THE REAL PROGRAMMER'S NATURAL HABITAT
""Taped to the wall is a line-printer Snoopy calender for the year 1969.""

For further Kudos see task CALENDAR, where all code is to be in UPPERCASE.

For economy of size, do not actually include Snoopy generation in either the code or the output, instead just output a place-holder.



Related task

   Five weekends

",#C.23,C#," 
 
using System;
using System.Collections.Generic; 
using System.Linq;
using System.Text;
 
namespace CalendarStuff
{
 
    class Program
    {
        static void Main(string[] args)
        {
            Console.WindowHeight = 46;
            Console.Write(buildMonths(new DateTime(1969, 1, 1)));
            Console.Read(); 
        }
        private static string buildMonths(DateTime date)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine(center(""[Snoop]"", 24 * 3));
            sb.AppendLine();
            sb.AppendLine(center(date.Year.ToString(), 24 * 3));
 
            List<DateTime> dts = new List<DateTime>();
            while (true)
            {
                dts.Add(date);
                if (date.Year != ((date = date.AddMonths(1)).Year))
                {
                    break;
                }
            }
            var jd = dts.Select(a => buildMonth(a).GetEnumerator()).ToArray();
 
            int sCur=0;
            while (sCur<dts.Count)
            {
                sb.AppendLine();
                int curMonth=0; 
                var j = jd.Where(a => curMonth++ >= sCur && curMonth - 1 < sCur + 3).ToArray(); //grab the next 3
                sCur += j.Length; 
                bool breakOut = false;
                while (!breakOut)
                {
                    int inj = 1;
                    foreach (var cd in j)
                    {
                        if (cd.MoveNext())
                        {
                            sb.Append((cd.Current.Length == 21 ? cd.Current : cd.Current.PadRight(21, ' ')) + ""     "");
                        }
                        else
                        {
                            sb.Append("""".PadRight(21, ' ') + ""     "");
                            breakOut = true;
                        }
                        if (inj++ % 3 == 0) sb.AppendLine();
                    }
                }
 
            }
            return sb.ToString();
        }
 
 
        private static IEnumerable<string> buildMonth(DateTime date)
        {
            yield return center(date.ToString(""MMMM""),7*3);
            var j = DateTime.DaysInMonth(date.Year, date.Month);
            yield return Enum.GetNames(typeof(DayOfWeek)).Aggregate("""", (current, result) => current + (result.Substring(0, 2).ToUpper() + "" ""));
            string cur = """";
            int total = 0;
 
            foreach (var day in Enumerable.Range(-((int)date.DayOfWeek),j + (int)date.DayOfWeek))
            {
                cur += (day < 0 ? ""  "" : ((day < 9 ? "" "" : """") + (day + 1))) +"" "";
                if (total++ > 0 && (total ) % 7 == 0)
                {
                    yield return cur;
                    cur = """";
                }
            }
            yield return cur;
        }
        private static string center(string s, int len)
        {
            return (s.PadLeft((len - s.Length) / 2 + s.Length, ' ').PadRight((len), ' '));
        } 
    }
}
 
 ",3006,94
70623,http://rosettacode.org/wiki/Bulls_and_cows,Bulls and cows,"Bulls and Cows


Task

Create a four digit random number from the digits   1   to   9,   without duplication.

The program should:

   ask for guesses to this number
   reject guesses that are malformed
   print the score for the guess


The score is computed as:

 The player wins if the guess is the same as the randomly chosen number, and the program ends.
 A score of one bull is accumulated for each digit in the guess that equals the corresponding digit in the randomly chosen initial number.
 A score of one cow is accumulated for each digit in the guess that also appears in the randomly chosen number, but in the wrong position.


Related tasks

   Bulls and cows/Player
   Guess the number
   Guess the number/With Feedback
   Mastermind

",#C.23,C#,"using System;
 
namespace BullsnCows
{
    class Program
    {
 
        static void Main(string[] args)
        {
            int[] nums = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
            KnuthShuffle<int>(ref nums);
            int[] chosenNum = new int[4];
            Array.Copy(nums, chosenNum, 4);
 
            Console.WriteLine(""Your Guess ?"");
            while (!game(Console.ReadLine(), chosenNum))
            {
                Console.WriteLine(""Your next Guess ?"");
            }
 
            Console.ReadKey();
        }
 
        public static void KnuthShuffle<T>(ref T[] array)
        {
            System.Random random = new System.Random();
            for (int i = 0; i < array.Length; i++)
            {
                int j = random.Next(array.Length);
                T temp = array[i]; array[i] = array[j]; array[j] = temp;
            }
        }
 
        public static bool game(string guess, int[] num)
        {
            char[] guessed = guess.ToCharArray();
            int bullsCount = 0, cowsCount = 0;
 
            if (guessed.Length != 4)
            {
                Console.WriteLine(""Not a valid guess."");
                return false;
            }
 
            for (int i = 0; i < 4; i++)
            {
                int curguess = (int) char.GetNumericValue(guessed[i]);
                if (curguess < 1 || curguess > 9)
                {
                    Console.WriteLine(""Digit must be ge greater 0 and lower 10."");
                    return false;
                }
                if (curguess == num[i])
                {
                    bullsCount++;
                }
                else
                {
                    for (int j = 0; j < 4; j++)
                    {
                        if (curguess == num[j])
                            cowsCount++;
                    }
                }
            }
 
            if (bullsCount == 4)
            {
                Console.WriteLine(""Congratulations! You have won!"");
                return true;
            }
            else
            {
                Console.WriteLine(""Your Score is {0} bulls and {1} cows"", bullsCount, cowsCount);
                return false;
            }
        }
    }
}
 ",2245,80
70759,http://rosettacode.org/wiki/Caesar_cipher,Caesar cipher,"

Task

Implement a Caesar cipher, both encoding and decoding. 

The key is an integer from 1 to 25.

This cipher rotates (either towards left or right) the letters of the alphabet (A to Z).

The encoding replaces each letter with the 1st to 25th next letter in the alphabet (wrapping Z to A).

So key 2 encrypts ""HI"" to ""JK"", but key 20 encrypts ""HI"" to ""BC"".

This simple ""mono-alphabetic substitution cipher"" provides almost no security, because an attacker who has the encoded message can either use frequency analysis to guess the key, or just try all 25 keys.

Caesar cipher is identical to Vigenère cipher with a key of length 1. 

Also, Rot-13 is identical to Caesar cipher with key 13.



Related tasks

 Rot-13
 Substitution Cipher
 Vigenère Cipher/Cryptanalysis

",#C.23,C#,"using System;
using System.Linq;
 
namespace CaesarCypher
{
    class Program
    {
        static char Encrypt(char ch, int code)
        {
            if (!char.IsLetter(ch)) return ch;
 
            char offset = char.IsUpper(ch) ? 'A' : 'a';
            return (char)((ch + code - offset) % 26 + offset);
        }
 
        static string Encrypt(string input, int code)
        {
            return new string(input.Select(ch => Encrypt(ch, code)).ToArray());
        }
 
        static string Decrypt(string input, int code)
        {
            return Encrypt(input, 26 - code);
        }
 
        const string TestCase = ""Pack my box with five dozen liquor jugs."";
 
        static void Main()
        {
            string str = TestCase;
 
            Console.WriteLine(str);
            str = Encrypt(str, 5);
            Console.WriteLine(""Encrypted: "" + str);
            str = Decrypt(str, 5);
            Console.WriteLine(""Decrypted: "" + str);
            Console.ReadKey();
        }
    }
}",1009,40
71343,http://rosettacode.org/wiki/Bitmap/Read_a_PPM_file,Bitmap/Read a PPM file,"Using the data storage type defined on this page for raster images, read an image from a PPM file (binary P6 prefered).
(Read the definition of PPM file on Wikipedia.)

Task: Use write ppm file solution and grayscale image solution with this one in order to convert a color image to grayscale one.
",#C.23,C#,"using System.IO;
class PPMReader
{
    public static Bitmap ReadBitmapFromPPM(string file)
    {
        var reader = new BinaryReader(new FileStream(file, FileMode.Open));
        if (reader.ReadChar() != 'P' || reader.ReadChar() != '6')
            return null;
        reader.ReadChar(); //Eat newline
        string widths = """", heights = """";
        char temp;
        while ((temp = reader.ReadChar()) != ' ')
            widths += temp;
        while ((temp = reader.ReadChar()) >= '0' && temp <= '9')
            heights += temp;
        if (reader.ReadChar() != '2' || reader.ReadChar() != '5' || reader.ReadChar() != '5')
            return null;
        reader.ReadChar(); //Eat the last newline
        int width = int.Parse(widths),
            height = int.Parse(heights);
        Bitmap bitmap = new Bitmap(width, height);
        //Read in the pixels
        for (int y = 0; y < height; y++)
            for (int x = 0; x < width; x++)
                bitmap.SetPixel(x, y, new Bitmap.Color()
                {
                    Red = reader.ReadByte(),
                    Green = reader.ReadByte(),
                    Blue = reader.ReadByte()
                });
        return bitmap;
    }
}",1214,33
71367,http://rosettacode.org/wiki/Bitmap/Write_a_PPM_file,Bitmap/Write a PPM file,"Using the data storage type defined on this page for raster images, write the image to a PPM file (binary P6 prefered).

(Read the definition of PPM file on Wikipedia.)



",#C.23,C#,"using System;
using System.IO;
class PPMWriter
{
    public static void WriteBitmapToPPM(string file, Bitmap bitmap)
        {
            //Use a streamwriter to write the text part of the encoding
            var writer = new StreamWriter(file);
            writer.WriteLine(""P6"");
            writer.WriteLine($""{bitmap.Width}  {bitmap.Height}"");
            writer.WriteLine(""255"");
            writer.Close();
            //Switch to a binary writer to write the data
            var writerB = new BinaryWriter(new FileStream(file, FileMode.Append));
            for (int x = 0; x < bitmap.Height; x++)
                for (int y = 0; y < bitmap.Width; y++)
                {
                    Color color = bitmap.GetPixel(y, x);
                    writerB.Write(color.R);
                    writerB.Write(color.G);
                    writerB.Write(color.B);
                }
            writerB.Close();
        }
}",928,25
71387,http://rosettacode.org/wiki/Bitwise_IO,Bitwise IO,"The aim of this task is to write functions (or create a class if your
language is Object Oriented and you prefer) for reading and writing sequences of
bits, most significant bit first. While the output of a asciiprint ""STRING"" is the ASCII byte sequence
""S"", ""T"", ""R"", ""I"", ""N"", ""G"", the output of a ""print"" of the bits sequence
0101011101010 (13 bits) must be 0101011101010; real I/O is performed always
quantized by byte (avoiding endianness issues and relying on underlying
buffering for performance), therefore you must obtain as output the bytes
0101 0111 0101 0000 (bold bits are padding bits), i.e. in hexadecimal 57 50.

As test, you can implement a rough (e.g. don't care about error handling or
other issues) compression/decompression program for ASCII sequences
of bytes, i.e. bytes for which the most significant bit is always unused, so that you can write
seven bits instead of eight (each 8 bytes of input, we write 7 bytes of output).

These bit oriented I/O functions can be used to implement compressors and
decompressors; e.g. Dynamic and Static Huffman encodings use variable length
bits sequences, while LZW (see LZW compression) use fixed or variable words
nine (or more) bits long.

 Limits in the maximum number of bits that can be written/read in a single read/write operation are allowed.
 Errors handling is not mandatory

",#C.23,C#,"using System;
using System.IO;
 
public class BitReader
{
    uint readData = 0;
    int startPosition = 0;
    int endPosition = 0;
 
    public int InBuffer
    {
        get { return endPosition - startPosition; }
    }
 
    private Stream stream;
 
    public Stream BaseStream
    {
        get { return stream; }
    }
 
    public BitReader(Stream stream)
    {
        this.stream = stream;
    }
 
    void EnsureData(int bitCount)
    {
        int readBits = bitCount - InBuffer;
        while (readBits > 0)
        {
            int b = BaseStream.ReadByte();
 
            if (b < 0) throw new InvalidOperationException(""Unexpected end of stream"");
 
            readData |= checked((uint)b << endPosition);
            endPosition += 8;
            readBits -= 8;
        }
    }
 
    public bool ReadBit()
    {
        return Read(1) > 0;
    }
 
    public int Read(int bitCount)
    {
        EnsureData(bitCount);
 
        int result = (int)(readData >> startPosition) & ((1 << bitCount) - 1);
        startPosition += bitCount;
        if (endPosition == startPosition)
        {
            endPosition = startPosition = 0;
            readData = 0;
        }
        else if (startPosition >= 8)
        {
            readData >>= startPosition;
            endPosition -= startPosition;
            startPosition = 0;
        }
 
        return result;
    }
 
    public void Align()
    {
        endPosition = startPosition = 0;
        readData = 0;
    }
}
 
public class BitWriter
{
    uint data = 0;
    int dataLength = 0;
    Stream stream;
 
    public Stream BaseStream
    {
        get { return stream; }
    }
 
    public int BitsToAligment
    {
        get { return (32 - dataLength) % 8; }
    }
 
    public BitWriter(Stream stream)
    {
        this.stream = stream;
    }
 
    public void WriteBit(bool value)
    {
        Write(value ? 1 : 0, 1);
    }
 
    public void Write(int value, int length)
    {
        uint currentData = data | checked((uint)value << dataLength);
        int currentLength = dataLength + length;
        while (currentLength >= 8)
        {
            BaseStream.WriteByte((byte)currentData);
            currentData >>= 8;
            currentLength -= 8;
        }
        data = currentData;
        dataLength = currentLength;
    }
 
    public void Align()
    {
        if (dataLength > 0)
        {
            BaseStream.WriteByte((byte)data);
 
            data = 0;
            dataLength = 0;
        }
    }
}
 
class Program
{
    static void Main(string[] args)
    {
        MemoryStream ms = new MemoryStream();
        BitWriter writer = new BitWriter(ms);
        writer.WriteBit(true);
        writer.Write(5, 3);
        writer.Write(0x0155, 11);
        writer.Align();
 
        ms.Position = 0;
        BitReader reader = new BitReader(ms);
        Console.WriteLine(reader.ReadBit());
        Console.WriteLine(reader.Read(3));
        Console.WriteLine(reader.Read(11).ToString(""x4""));
        reader.Align();
    }
}",3025,145
71532,http://rosettacode.org/wiki/Boolean_values,Boolean values,"Task

Show how to represent the boolean states ""true"" and ""false"" in a language.

If other objects represent ""true"" or ""false"" in conditionals, note it.



Related tasks

   Logical operations

",#C.23,C#,bool? value = null,18,1
71571,http://rosettacode.org/wiki/Bitmap/Midpoint_circle_algorithm,Bitmap/Midpoint circle algorithm,"Task

Using the data storage type defined on this page for raster images,
write an implementation of the midpoint circle algorithm   (also known as Bresenham's circle algorithm).

(definition on Wikipedia).



",#C.23,C#," 
        /// <summary>
        /// Draws a circle.
        /// </summary>
        /// <param name=""image"">
        /// The destination image.
        /// </param>
        /// <param name=""centerX"">
        /// The x center position of the circle.
        /// </param>
        /// <param name=""centerY"">
        /// The y center position of the circle.
        /// </param>
        /// <param name=""radius"">
        /// The radius of the circle.
        /// </param>  
        /// <param name=""color"">
        /// The color to use.
        /// </param>    
        public static void DrawCircle(this GenericImage image, int centerX, int centerY, int radius, Color color)
        {
            int d = (5 - radius * 4) / 4;
            int x = 0;
            int y = radius;
 
            do
            {
                // ensure index is in range before setting (depends on your image implementation)
                // in this case we check if the pixel location is within the bounds of the image before setting the pixel
                if (centerX + x >= 0 && centerX + x <= image.Width - 1 && centerY + y >= 0 && centerY + y <= image.Height - 1) image[centerX + x, centerY + y] = color;
                if (centerX + x >= 0 && centerX + x <= image.Width - 1 && centerY - y >= 0 && centerY - y <= image.Height - 1) image[centerX + x, centerY - y] = color;
                if (centerX - x >= 0 && centerX - x <= image.Width - 1 && centerY + y >= 0 && centerY + y <= image.Height - 1) image[centerX - x, centerY + y] = color;
                if (centerX - x >= 0 && centerX - x <= image.Width - 1 && centerY - y >= 0 && centerY - y <= image.Height - 1) image[centerX - x, centerY - y] = color;
                if (centerX + y >= 0 && centerX + y <= image.Width - 1 && centerY + x >= 0 && centerY + x <= image.Height - 1) image[centerX + y, centerY + x] = color;
                if (centerX + y >= 0 && centerX + y <= image.Width - 1 && centerY - x >= 0 && centerY - x <= image.Height - 1) image[centerX + y, centerY - x] = color;
                if (centerX - y >= 0 && centerX - y <= image.Width - 1 && centerY + x >= 0 && centerY + x <= image.Height - 1) image[centerX - y, centerY + x] = color;
                if (centerX - y >= 0 && centerX - y <= image.Width - 1 && centerY - x >= 0 && centerY - x <= image.Height - 1) image[centerX - y, centerY - x] = color;
                if (d < 0)
                {
                    d += 2 * x + 1;
                }
                else
                {
                    d += 2 * (x - y) + 1;
                    y--;
                }
                x++;
            } while (x <= y);
        }
 ",2654,50
71658,http://rosettacode.org/wiki/Bitmap/Flood_fill,Bitmap/Flood fill,"Implement a flood fill.

A flood fill is a way of filling an area using color banks to define the contained area or a target color which ""determines"" the area (the valley that can be flooded; Wikipedia uses the term target color). It works almost like a water flooding from a point towards the banks (or: inside the valley): if there's a hole in the banks, the flood is not contained and all the image (or all the ""connected valleys"") get filled.

To accomplish the task, you need to implement just one of the possible algorithms (examples are on Wikipedia). Variations on the theme are allowed (e.g. adding a tolerance parameter or argument for color-matching of the banks or target color).

 
Testing: the basic algorithm is not suitable for truecolor images; a possible test image is the one shown on the right box; you can try to fill the white area, or the black inner circle.
",#C.23,C#," 
using System;
using System.Collections.Generic;
using System.Drawing;
 
namespace FloodFill
{
    class Program
    {
        private static bool ColorMatch(Color a, Color b)
        {
            return (a.ToArgb() & 0xffffff) == (b.ToArgb() & 0xffffff);
        }
 
        static void FloodFill(Bitmap bmp, Point pt, Color targetColor, Color replacementColor)
        {
            Queue<Point> q = new Queue<Point>();
            q.Enqueue(pt);
            while (q.Count > 0)
            {
                Point n = q.Dequeue();
                if (!ColorMatch(bmp.GetPixel(n.X, n.Y),targetColor))
                    continue;
                Point w = n, e = new Point(n.X + 1, n.Y);
                while ((w.X >= 0) && ColorMatch(bmp.GetPixel(w.X, w.Y),targetColor))
                {
                    bmp.SetPixel(w.X, w.Y, replacementColor);
                    if ((w.Y > 0) && ColorMatch(bmp.GetPixel(w.X, w.Y - 1),targetColor))
                        q.Enqueue(new Point(w.X, w.Y - 1));
                    if ((w.Y < bmp.Height - 1) && ColorMatch(bmp.GetPixel(w.X, w.Y + 1),targetColor))
                        q.Enqueue(new Point(w.X, w.Y + 1));
                    w.X--;
                }
                while ((e.X <= bmp.Width - 1) && ColorMatch(bmp.GetPixel(e.X, e.Y),targetColor))
                {
                    bmp.SetPixel(e.X, e.Y, replacementColor);
                    if ((e.Y > 0) && ColorMatch(bmp.GetPixel(e.X, e.Y - 1), targetColor))
                        q.Enqueue(new Point(e.X, e.Y - 1));
                    if ((e.Y < bmp.Height - 1) && ColorMatch(bmp.GetPixel(e.X, e.Y + 1), targetColor))
                        q.Enqueue(new Point(e.X, e.Y + 1));
                    e.X++;
                }
            }
        }
 
        static void Main(string[] args)
        {
            Bitmap bmp = new Bitmap(""Unfilledcirc.bmp"");
            FloodFill(bmp, new Point(200, 200), Color.White, Color.Red);
            FloodFill(bmp, new Point(100, 100), Color.Black, Color.Blue);
            bmp.Save(""Filledcirc.bmp"");
        }
    }
}
 ",2088,55
71683,http://rosettacode.org/wiki/Box_the_compass,Box the compass,"There be many a land lubber that knows naught of the pirate ways and gives direction by degree!
They know not how to box the compass!



Task description

 Create a function that takes a heading in degrees and returns the correct 32-point compass heading.
 Use the function to print and display a table of Index, Compass point, and Degree; rather like the corresponding columns from, the first table of the wikipedia article, but use only the following 33 headings as input:
[0.0, 16.87, 16.88, 33.75, 50.62, 50.63, 67.5, 84.37, 84.38, 101.25, 118.12, 118.13, 135.0, 151.87, 151.88, 168.75, 185.62, 185.63, 202.5, 219.37, 219.38, 236.25, 253.12, 253.13, 270.0, 286.87, 286.88, 303.75, 320.62, 320.63, 337.5, 354.37, 354.38]. (They should give the same order of points but are spread throughout the ranges of acceptance).


Notes;
 The headings and indices can be calculated from this pseudocode:
for i in 0..32 inclusive:
    heading = i * 11.25
    case i %3:
      if 1: heading += 5.62; break
      if 2: heading -= 5.62; break
    end
    index = ( i mod 32) + 1
 The column of indices can be thought of as an enumeration of the thirty two cardinal points (see talk page)..

",#C.23,C#," 
using System;
using System.Collections.Generic;
 
namespace BoxTheCompass
{
    class Compass
    {
        string[] cp = new string[] {""North"", ""North by east"", ""North-northeast"", ""Northeast by north"", ""Northeast"",""Northeast by east"", 
	    ""East-northeast"", ""East by north"", ""East"", ""East by south"", ""East-southeast"", ""Southeast by east"", ""Southeast"", 
            ""Southeast by south"", ""South-southeast"", ""South by east"", ""South"", ""South by west"", ""South-southwest"", ""Southwest by south"", 
            ""Southwest"", ""Southwest by west"", ""West-southwest"", ""West by south"", ""West"", ""West by north"", ""West-northwest"", 
            ""Northwest by west"", ""Northwest"", ""Northwest by north"", ""North-northwest"", ""North by west"", ""North""};
 
        public void compassHeading(float a)
        {
            int h = Convert.ToInt32(Math.Floor(a / 11.25f + .5f)) % 32;
            Console.WriteLine( ""{0,2}: {1,-22} : {2,6:N}"",h + 1, cp[h], a );
        }
    };
    class Program
    {
        static void Main(string[] args)
       {
            Compass c = new Compass();
            float[] degs = new float[] {0.0f, 16.87f, 16.88f, 33.75f, 50.62f, 50.63f, 67.5f, 84.37f, 84.38f, 101.25f, 
                118.12f, 118.13f, 135.0f, 151.87f, 151.88f, 168.75f, 185.62f, 185.63f, 202.5f, 219.37f, 219.38f, 236.25f, 
                253.12f, 253.13f, 270.0f, 286.87f, 286.88f, 303.75f, 320.62f, 320.63f, 337.5f, 354.37f, 354.38f};
 
            foreach (float d in degs)
                c.compassHeading(d);
 
            Console.WriteLine(""\nPress any key to continue..."");
            Console.ReadKey();
        }
    }
}
 ",1618,38
71716,http://rosettacode.org/wiki/Bitcoin/address_validation,Bitcoin/address validation,"Bitcoin/address validation

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Write a program that takes a bitcoin address as argument,
and checks whether or not this address is valid.

A bitcoin address uses a base58 encoding, which uses an alphabet of the characters 0 .. 9, A ..Z, a .. z, but without the four characters:

   0   zero
   O   uppercase oh
   I   uppercase eye
   l   lowercase ell


With this encoding, a bitcoin address encodes 25 bytes:

 the first byte is the version number, which will be zero for this task ;
 the next twenty bytes are a RIPEMD-160 digest, but you don't have to know that for this task: you can consider them a pure arbitrary data ;
 the last four bytes are a checksum check. They are the first four bytes of a double SHA-256 digest of the previous 21 bytes.


To check the bitcoin address, you must read the first twenty-one bytes, compute the checksum, and check that it corresponds to the last four bytes.

The program can either return a boolean value or throw an exception when not valid.

You can use a digest library for SHA-256.



Example of a bitcoin address



1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i



It doesn't belong to anyone and is part of the test suite of the bitcoin software.

You can change a few characters in this string and check that it'll fail the test.



",#C.23,C#," 
using System;
using System.Linq;
using System.Security.Cryptography;
using NUnit.Framework;
 
namespace BitcoinValidator
{
    public class ValidateTest
    {
        [TestCase]
        public void ValidateBitcoinAddressTest()
        {
            Assert.IsTrue(ValidateBitcoinAddress(""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i"")); // VALID
            Assert.IsTrue(ValidateBitcoinAddress(""1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nK9"")); // VALID
            Assert.Throws<Exception>(() => ValidateBitcoinAddress(""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62X"")); // checksum changed, original data
            Assert.Throws<Exception>(() => ValidateBitcoinAddress(""1ANNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i"")); // data changed, original checksum
            Assert.Throws<Exception>(() => ValidateBitcoinAddress(""1A Na15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i"")); // invalid chars
            Assert.Throws<Exception>(() => ValidateBitcoinAddress(""BZbvjr"")); // checksum is fine, address too short
        }
 
        public static bool ValidateBitcoinAddress(string address)
        {
            if (address.Length < 26 || address.Length > 35) throw new Exception(""wrong length"");
            var decoded = DecodeBase58(address);
            var d1 = Hash(decoded.SubArray(0, 21));
            var d2 = Hash(d1);
            if (!decoded.SubArray(21, 4).SequenceEqual(d2.SubArray(0, 4))) throw new Exception(""bad digest"");
            return true;
        }
 
        const string Alphabet = ""123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"";
        const int Size = 25;
 
        private static byte[] DecodeBase58(string input)
        {
            var output = new byte[Size];
            foreach (var t in input)
            {
                var p = Alphabet.IndexOf(t);
                if (p == -1) throw new Exception(""invalid character found"");
                var j = Size;
                while (--j > 0)
                {
                    p += 58 * output[j];
                    output[j] = (byte)(p % 256);
                    p /= 256;
                }
                if (p != 0) throw new Exception(""address too long"");
            }
            return output;
        }
 
        private static byte[] Hash(byte[] bytes)
        {
            var hasher = new SHA256Managed();
            return hasher.ComputeHash(bytes);
        }
    }
 
    public static class ArrayExtensions
    {
        public static T[] SubArray<T>(this T[] data, int index, int length)
        {
            var result = new T[length];
            Array.Copy(data, index, result, 0, length);
            return result;
        }
    }
}
 ",2610,71
71913,http://rosettacode.org/wiki/Bitmap/Bresenham%27s_line_algorithm,Bitmap/Bresenham's line algorithm,"Task

Using the data storage type defined on the Bitmap page for raster graphics images,

draw a line given two points with Bresenham's line algorithm.



",#C.23,C#,"using System;
using System.Drawing;
using System.Drawing.Imaging;
static class Program
{
    static void Main()
    {
        new Bitmap(200, 200)
            .DrawLine(0, 0, 199, 199, Color.Black).DrawLine(199,0,0,199,Color.Black)
            .DrawLine(50, 75, 150, 125, Color.Blue).DrawLine(150, 75, 50, 125, Color.Blue)
            .Save(""line.png"", ImageFormat.Png);
    }
    static Bitmap DrawLine(this Bitmap bitmap, int x0, int y0, int x1, int y1, Color color)
    {
        int dx = Math.Abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
        int dy = Math.Abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
        int err = (dx > dy ? dx : -dy) / 2, e2;
        for(;;) {
            bitmap.SetPixel(x0, y0, color);
            if (x0 == x1 && y0 == y1) break;
            e2 = err;
            if (e2 > -dx) { err -= dy; x0 += sx; }
            if (e2 < dy) { err += dx; y0 += sy; }
        }
        return bitmap;
    }
}",911,27
71983,http://rosettacode.org/wiki/Bitmap,Bitmap,"Show a basic storage type to handle a simple RGB raster graphics image,
and some primitive associated functions.

If possible provide a function to allocate an uninitialised image,
given its width and height, and provide 3 additional functions:

   one to fill an image with a plain RGB color,
   one to set a given pixel with a color,
   one to get the color of a pixel.


(If there are specificities about the storage or the allocation, explain those.)

These functions are used as a base for the articles in the category raster graphics operations, 
and a basic output function to check the results
is available in the article write ppm file.



",#C.23,C#,"public class Bitmap
{
    public struct Color
    {
        public byte Red { get; set; }
        public byte Blue { get; set; }
        public byte Green { get; set; }
    }
    Color[,] _imagemap;
    public int Width { get { return _imagemap.GetLength(0); } }
    public int Height { get { return _imagemap.GetLength(1); } }
    public Bitmap(int width, int height)
    {
        _imagemap = new Color[width, height];
    }
    public void Fill(Color color)
    {
        for (int y = 0; y < Height; y++)
            for (int x = 0; x < Width; x++)
            {
                _imagemap[x, y] = color;
            }
    }
    public Color GetPixel(int x, int y)
    {
        return _imagemap[x, y];
    }
    public void SetPixel(int x, int y, Color color)
    {
        _imagemap[x, y] = color;
    }
}",809,32
72004,http://rosettacode.org/wiki/Bitwise_operations,Bitwise operations,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses




Task

Write a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.

All shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.

If any operation is not available in your language, note it.



",#C.23,C#,"static void bitwise(int a, int b)
        {
            Console.WriteLine(""a and b is {0}"", a & b);
            Console.WriteLine(""a or b is {0}"", a | b);
            Console.WriteLine(""a xor b is {0}"", a ^ b);
            Console.WriteLine(""not a is {0}"", ~a);
            Console.WriteLine(""a lshift b is {0}"", a << b);
            Console.WriteLine(""a arshift b is {0}"", a >> b); // When the left operand of the >> operator is of a signed integral type, 
                                                             // the operator performs an arithmetic shift right
            uint c = (uint)a;
            Console.WriteLine(""c rshift b is {0}"", c >> b); // When the left operand of the >> operator is of an unsigned integral type, 
                                                            // the operator performs a logical shift right
            // there are no rotation operators in C#
        }",907,14
72052,http://rosettacode.org/wiki/Bin_given_limits,Bin given limits,"You are given a list of n ascending, unique numbers which are to form limits
for n+1 bins which count how many of a large set of input numbers fall in the
range of each bin.

(Assuming zero-based indexing)

   bin[0] counts how many inputs are < limit[0]
   bin[1] counts how many inputs are >= limit[0] and < limit[1]
   ..
   bin[n-1] counts how many inputs are >= limit[n-2] and < limit[n-1]
   bin[n] counts how many inputs are >= limit[n-1]

Task

The task is to create a function that given the ascending limits and a stream/
list of numbers, will return the bins; together with another function that
given the same list of limits and the binning will print the limit of each bin
together with the count of items that fell in the range.

Assume the numbers to bin are too large to practically sort.

Task examples

Part 1: Bin using the following limits the given input data

   limits  = [23, 37, 43, 53, 67, 83]
   data = [95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,
           16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55]

Part 2: Bin using the following limits the given input data

   limits = [14, 18, 249, 312, 389, 392, 513, 591, 634, 720]
   data = [445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,
           416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,
           655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,
           346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,
           345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,
           854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,
           787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,
           698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,
           605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,
           466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749]

Show output here, on this page.
",#C.23,C#,"using System;
 
public class Program
{
    static void Main()
    {
        PrintBins(new [] { 23, 37, 43, 53, 67, 83 },
            95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,
            16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55
        );
        Console.WriteLine();
 
        PrintBins(new [] { 14, 18, 249, 312, 389, 392, 513, 591, 634, 720 },
            445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,416,589,930,373,202,
            253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,655,267,248,477,549,238, 62,678, 98,534,
            622,907,406,714,184,391,913, 42,560,247,346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,
            945,733,507,916,123,345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,
            854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,787,942,456,242,759,
            898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,698,765,331,487,251,600,879,342,982,527,
            736,795,585, 40, 54,901,408,359,577,237,605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,
            892,443,198,988,791,466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749);
    }
 
    static void PrintBins(int[] limits, params int[] data)
    {
        int[] bins = Bins(limits, data);
        Console.WriteLine($""-∞ .. {limits[0]} => {bins[0]}"");
        for (int i = 0; i < limits.Length-1; i++) {
            Console.WriteLine($""{limits[i]} .. {limits[i+1]} => {bins[i+1]}"");
        }
        Console.WriteLine($""{limits[^1]} .. ∞ => {bins[^1]}"");
    }
 
    static int[] Bins(int[] limits, params int[] data)
    {
        Array.Sort(limits);
        int[] bins = new int[limits.Length + 1];
        foreach (int n in data) {
            int i = Array.BinarySearch(limits, n);
            i = i < 0 ? ~i : i+1;
            bins[i]++;
        }
        return bins;
    }
}",2022,45
72094,http://rosettacode.org/wiki/Binary_strings,Binary strings,"Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.

This task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them.

If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.

In particular the functions you need to create are:

 String creation and destruction (when needed and if there's no garbage collection or similar mechanism)
 String assignment
 String comparison
 String cloning and copying
 Check if a string is empty
 Append a byte to a string
 Extract a substring from a string
 Replace every occurrence of a byte (or a string) in a string with another string
 Join strings


Possible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.



",#C.23,C#,"using System;
 
class Program
{
    static void Main()
    {
        //string creation
        var x = ""hello world"";
 
        //# mark string for garbage collection
        x = null;
 
        //# string assignment with a null byte
        x = ""ab\0"";
        Console.WriteLine(x);
        Console.WriteLine(x.Length); // 3
 
        //# string comparison
        if (x == ""hello"")
            Console.WriteLine(""equal"");
        else
            Console.WriteLine(""not equal"");
 
        if (x.CompareTo(""bc"") == -1)
            Console.WriteLine(""x is lexicographically less than 'bc'"");
 
        //# string cloning 
        var c = new char[3];
        x.CopyTo(0, c, 0, 3);
        object objecty = new string(c);
        var y = new string(c);
 
        Console.WriteLine(x == y);      //same as string.equals
        Console.WriteLine(x.Equals(y)); //it overrides object.Equals
 
        Console.WriteLine(x == objecty); //uses object.Equals, return false
 
        //# check if empty
        var empty = """";
        string nullString = null;
        var whitespace = ""   "";
        if (nullString == null && empty == string.Empty && 
            string.IsNullOrEmpty(nullString) && string.IsNullOrEmpty(empty) &&
            string.IsNullOrWhiteSpace(nullString) && string.IsNullOrWhiteSpace(empty) &&
            string.IsNullOrWhiteSpace(whitespace))
            Console.WriteLine(""Strings are null, empty or whitespace"");
 
        //# append a byte
        x = ""helloworld"";
        x += (char)83;
        Console.WriteLine(x);
 
        //# substring
        var slice = x.Substring(5, 5);
        Console.WriteLine(slice);
 
        //# replace bytes
        var greeting = x.Replace(""worldS"", """");
        Console.WriteLine(greeting);
 
        //# join strings
        var join = greeting + "" "" + slice;
        Console.WriteLine(join);
    }
}",1862,65
72133,http://rosettacode.org/wiki/Bell_numbers,Bell numbers,"Bell or exponential numbers are enumerations of the number of different ways to partition a set that has exactly n elements. Each element of the sequence Bn is the number of partitions of a set of size n where order of the elements and order of the partitions are non-significant. E.G.: {a b} is the same as {b a} and {a} {b} is the same as {b} {a}.



So

B0 = 1 trivially. There is only one way to partition a set with zero elements. { }
B1 = 1 There is only one way to partition a set with one element. {a}
B2 = 2 Two elements may be partitioned in two ways. {a} {b}, {a b}
B3 = 5 Three elements may be partitioned in five ways {a} {b} {c}, {a b} {c}, {a} {b c}, {a c} {b}, {a b c}
 and so on.


A simple way to find the Bell numbers is construct a Bell triangle, also known as an Aitken's array or Peirce triangle, and read off the numbers in the first column of each row. There are other generating algorithms though, and you are free to choose the best / most appropriate for your case.



Task

Write a routine (function, generator, whatever) to generate the Bell number sequence and call the routine to show here, on this page at least the first 15 and (if your language supports big Integers) 50th elements of the sequence.

If you do use the Bell triangle method to generate the numbers, also show the first ten rows of the Bell triangle.



See also

 OEIS:A000110 Bell or exponential numbers
 OEIS:A011971 Aitken's array",#C.23,C#,"using System;
using System.Numerics;
 
namespace BellNumbers {
    public static class Utility {
        public static void Init<T>(this T[] array, T value) {
            if (null == array) return;
            for (int i = 0; i < array.Length; ++i) {
                array[i] = value;
            }
        }
    }
 
    class Program {
        static BigInteger[][] BellTriangle(int n) {
            BigInteger[][] tri = new BigInteger[n][];
            for (int i = 0; i < n; ++i) {
                tri[i] = new BigInteger[i];
                tri[i].Init(BigInteger.Zero);
            }
            tri[1][0] = 1;
            for (int i = 2; i < n; ++i) {
                tri[i][0] = tri[i - 1][i - 2];
                for (int j = 1; j < i; ++j) {
                    tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1];
                }
            }
            return tri;
        }
 
        static void Main(string[] args) {
            var bt = BellTriangle(51);
            Console.WriteLine(""First fifteen and fiftieth Bell numbers:"");
            for (int i = 1; i < 16; ++i) {
                Console.WriteLine(""{0,2}: {1}"", i, bt[i][0]);
            }
            Console.WriteLine(""50: {0}"", bt[50][0]);
            Console.WriteLine();
            Console.WriteLine(""The first ten rows of Bell's triangle:"");
            for (int i = 1; i < 11; ++i) {
                //Console.WriteLine(bt[i]);
                var it = bt[i].GetEnumerator();
                Console.Write(""["");
                if (it.MoveNext()) {
                    Console.Write(it.Current);
                }
                while (it.MoveNext()) {
                    Console.Write("", "");
                    Console.Write(it.Current);
                }
                Console.WriteLine(""]"");
            }
        }
    }
}",1810,55
72178,http://rosettacode.org/wiki/Bernoulli_numbers,Bernoulli numbers,"Bernoulli numbers are used in some series expansions of several functions   (trigonometric, hyperbolic, gamma, etc.),   and are extremely important in number theory and analysis.

Note that there are two definitions of Bernoulli numbers;   this task will be using the modern usage   (as per   The National Institute of Standards and Technology convention).

The   nth   Bernoulli number is expressed as   Bn.



Task
   show the Bernoulli numbers   B0   through   B60.
   suppress the output of values which are equal to zero.   (Other than   B1 , all   odd   Bernoulli numbers have a value of zero.)
   express the Bernoulli numbers as fractions  (most are improper fractions).
   the fractions should be reduced.
   index each number in some way so that it can be discerned which Bernoulli number is being displayed.
   align the solidi   (/)   if used  (extra credit).


An algorithm
The Akiyama–Tanigawa algorithm for the ""second Bernoulli numbers"" as taken from wikipedia is as follows:

 for m from 0 by 1 to n do
    A[m] ← 1/(m+1)
    for j from m by -1 to 1 do
      A[j-1] ← j×(A[j-1] - A[j])
  return A[0] (which is Bn)

See also
 Sequence A027641 Numerator of Bernoulli number B_n on The On-Line Encyclopedia of Integer Sequences.
 Sequence A027642 Denominator of Bernoulli number B_n on The On-Line Encyclopedia of Integer Sequences.
 Entry Bernoulli number on The Eric Weisstein's World of Mathematics (TM).
 Luschny's The Bernoulli Manifesto for a discussion on    B1   =   -½   versus   +½. 

",#C.23,C#," 
using Mpir.NET;
using System;
 
namespace Bernoulli
{
    class Program
    {
        private static void bernoulli(mpq_t rop, uint n)
        {
            mpq_t[] a = new mpq_t[n + 1];
 
            for (uint i = 0; i < n + 1; i++)
            {
                a[i] = new mpq_t();
            }
 
            for (uint m = 0; m <= n; ++m)
            {
                mpir.mpq_set_ui(a[m], 1, m + 1);
 
                for (uint j = m; j > 0; --j)
                {
                    mpir.mpq_sub(a[j - 1], a[j], a[j - 1]);
                    mpir.mpq_set_ui(rop, j, 1);
                    mpir.mpq_mul(a[j - 1], a[j - 1], rop);
                }
 
                mpir.mpq_set(rop, a[0]);
            }
        }
 
        static void Main(string[] args)
        {
            mpq_t rop = new mpq_t();
            mpz_t n = new mpz_t();
            mpz_t d = new mpz_t();
 
            for (uint  i = 0; i <= 60; ++i) 
            {
                bernoulli(rop, i);
 
                if (mpir.mpq_cmp_ui(rop, 0, 1) != 0) 
                {
                    mpir.mpq_get_num(n, rop);
                    mpir.mpq_get_den(d, rop);
                    Console.WriteLine(string.Format(""B({0, 2}) = {1, 44} / {2}"", i, n, d));
                }
            }
 
            Console.ReadKey();
        }
    }
}
 ",1321,55
72244,http://rosettacode.org/wiki/Best_shuffle,Best shuffle,"Task

Shuffle the characters of a string in such a way that as many of the character values are in a different position as possible.

A shuffle that produces a randomized result among the best choices is to be preferred. A deterministic approach that produces the same sequence every time is acceptable as an alternative.

Display the result as follows:

original string, shuffled string, (score) 

The score gives the number of positions whose character value did not change.



Example

tree, eetr, (0)



Test cases

abracadabra
seesaw
elk
grrrrrr
up
a



Related tasks
   Anagrams/Deranged anagrams
   Permutations/Derangements



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"ShuffledString[] array = {""cat"", ""dog"", ""mouse""};",49,1
72470,http://rosettacode.org/wiki/Binary_search,Binary search,"A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a ""divide and conquer"" algorithm.

As an analogy, consider the children's game ""guess a number."" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.

As the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.



Task

Given the starting point of a range, the ending point of a range, and the ""secret value"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.

There are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.

All of the following code examples use an ""inclusive"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using ""exclusive"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):

 change high = N-1 to high = N
 change high = mid-1 to high = mid
 (for recursive algorithm) change if (high < low) to if (high <= low)
 (for iterative algorithm) change while (low <= high) to while (low < high)
Traditional algorithm
The algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the ""insertion point"" for it (the index that the value would have if it were inserted into the array).

Recursive Pseudocode:

  // initially called with low = 0, high = N-1
  BinarySearch(A[0..N-1], value, low, high) {
      // invariants: value > A[i] for all i < low
                     value < A[i] for all i > high
      if (high < low)
          return not_found // value would be inserted at index ""low""
      mid = (low + high) / 2
      if (A[mid] > value)
          return BinarySearch(A, value, low, mid-1)
      else if (A[mid] < value)
          return BinarySearch(A, value, mid+1, high)
      else
          return mid
  }

Iterative Pseudocode:

  BinarySearch(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value > A[i] for all i < low
                         value < A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] > value)
              high = mid - 1
          else if (A[mid] < value)
              low = mid + 1
          else
              return mid
      }
      return not_found // value would be inserted at index ""low""
  }

Leftmost insertion point
The following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.

Recursive Pseudocode:

  // initially called with low = 0, high = N - 1
  BinarySearch_Left(A[0..N-1], value, low, high) {
      // invariants: value > A[i] for all i < low
                     value <= A[i] for all i > high
      if (high < low)
          return low
      mid = (low + high) / 2
      if (A[mid] >= value)
          return BinarySearch_Left(A, value, low, mid-1)
      else
          return BinarySearch_Left(A, value, mid+1, high)
  }

Iterative Pseudocode:

  BinarySearch_Left(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value > A[i] for all i < low
                         value <= A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] >= value)
              high = mid - 1
          else
              low = mid + 1
      }
      return low
  }

Rightmost insertion point
The following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.

Recursive Pseudocode:

  // initially called with low = 0, high = N - 1
  BinarySearch_Right(A[0..N-1], value, low, high) {
      // invariants: value >= A[i] for all i < low
                     value < A[i] for all i > high
      if (high < low)
          return low
      mid = (low + high) / 2
      if (A[mid] > value)
          return BinarySearch_Right(A, value, low, mid-1)
      else
          return BinarySearch_Right(A, value, mid+1, high)
  }

Iterative Pseudocode:

  BinarySearch_Right(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value >= A[i] for all i < low
                         value < A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] > value)
              high = mid - 1
          else
              low = mid + 1
      }
      return low
  }

Extra credit
Make sure it does not have overflow bugs.

The line in the pseudo-code above to calculate the mean of two integers:

mid = (low + high) / 2
could produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.

One way to fix it is to manually add half the range to the low number:

mid = low + (high - low) / 2
Even though this is mathematically equivalent to the above, it is not susceptible to overflow.

Another way for signed integers, possibly faster, is the following:

mid = (low + high) >>> 1
where  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.



Related task

 Guess the number/With Feedback (Player)


See also

 wp:Binary search algorithm
 Extra, Extra - Read All About It: Nearly All Binary Searches and Mergesorts are Broken.

",#C.23,C#,"namespace Search {
  using System;
 
  public static partial class Extensions {
    /// <summary>Use Binary Search to find index of GLB for value</summary>
    /// <typeparam name=""T"">type of entries and value</typeparam>
    /// <param name=""entries"">array of entries</param>
    /// <param name=""value"">search value</param>
    /// <remarks>entries must be in ascending order</remarks>
    /// <returns>index into entries of GLB for value</returns>
    public static int RecursiveBinarySearchForGLB<T>(this T[] entries, T value)
      where T : IComparable {
      return entries.RecursiveBinarySearchForGLB(value, 0, entries.Length - 1);
    }
 
    /// <summary>Use Binary Search to find index of GLB for value</summary>
    /// <typeparam name=""T"">type of entries and value</typeparam>
    /// <param name=""entries"">array of entries</param>
    /// <param name=""value"">search value</param>
    /// <param name=""left"">leftmost index to search</param>
    /// <param name=""right"">rightmost index to search</param>
    /// <remarks>entries must be in ascending order</remarks>
    /// <returns>index into entries of GLB for value</returns>
    public static int RecursiveBinarySearchForGLB<T>(this T[] entries, T value, int left, int right)
      where T : IComparable {
      if (left <= right) {
        var middle = left + (right - left) / 2;
        return entries[middle].CompareTo(value) < 0 ?
          entries.RecursiveBinarySearchForGLB(value, middle + 1, right) :
          entries.RecursiveBinarySearchForGLB(value, left, middle - 1);
      }
 
      //[Assert]left == right + 1
      // GLB: entries[right] < value && value <= entries[right + 1]
      return right;
    }
 
    /// <summary>Use Binary Search to find index of LUB for value</summary>
    /// <typeparam name=""T"">type of entries and value</typeparam>
    /// <param name=""entries"">array of entries</param>
    /// <param name=""value"">search value</param>
    /// <remarks>entries must be in ascending order</remarks>
    /// <returns>index into entries of LUB for value</returns>
    public static int RecursiveBinarySearchForLUB<T>(this T[] entries, T value)
      where T : IComparable {
      return entries.RecursiveBinarySearchForLUB(value, 0, entries.Length - 1);
    }
 
    /// <summary>Use Binary Search to find index of LUB for value</summary>
    /// <typeparam name=""T"">type of entries and value</typeparam>
    /// <param name=""entries"">array of entries</param>
    /// <param name=""value"">search value</param>
    /// <param name=""left"">leftmost index to search</param>
    /// <param name=""right"">rightmost index to search</param>
    /// <remarks>entries must be in ascending order</remarks>
    /// <returns>index into entries of LUB for value</returns>
    public static int RecursiveBinarySearchForLUB<T>(this T[] entries, T value, int left, int right)
      where T : IComparable {
      if (left <= right) {
        var middle = left + (right - left) / 2;
        return entries[middle].CompareTo(value) <= 0 ?
          entries.RecursiveBinarySearchForLUB(value, middle + 1, right) :
          entries.RecursiveBinarySearchForLUB(value, left, middle - 1);
      }
 
      //[Assert]left == right + 1
      // LUB: entries[left] > value && value >= entries[left - 1]
      return left;
    }
  }
}",3297,71
72647,http://rosettacode.org/wiki/Binary_digits,Binary digits,"Task

Create and display the sequence of binary digits for a given   non-negative integer.

   The decimal value      5   should produce an output of               101
   The decimal value     50   should produce an output of            110010
   The decimal value   9000   should produce an output of    10001100101000

The results can be achieved using built-in radix functions within the language   (if these are available),   or alternatively a user defined function can be used.

The output produced should consist just of the binary digits of each number followed by a   newline.

There should be no other whitespace, radix or sign markers in the produced output, and leading zeros should not appear in the results.



",#C.23,C#,"using System;
 
class Program
{
    static void Main()
    {
        foreach (var number in new[] { 5, 50, 9000 })
        {
            Console.WriteLine(Convert.ToString(number, 2));
        }
    }
}",202,12
73125,http://rosettacode.org/wiki/Base64_decode_data,Base64 decode data,"See Base64 encode data.

Now write a program that takes the output of the Base64 encode data task as input and regenerate the original file.

When working on the VBA implementation I found several 'solutions' on the net, including one from the software maker himself, that showed output with incorrect padding. Obviously with incorrect padding in the output you can not decode correctly to the original file again.
",#C.23,C#,"using System;
using System.Text;
 
namespace Base64DecodeData {
    class Program {
        static void Main(string[] args) {
            var data = ""VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g="";
            Console.WriteLine(data);
            Console.WriteLine();
 
            var decoded = Encoding.ASCII.GetString(Convert.FromBase64String(data));
            Console.WriteLine(decoded);
        }
    }
}",486,15
73190,http://rosettacode.org/wiki/Averages/Root_mean_square,Averages/Root mean square,"Task[edit]
Compute the   Root mean square   of the numbers 1..10.



The   root mean square   is also known by its initials RMS (or rms), and as the quadratic mean.

The RMS is calculated as the mean of the squares of the numbers, square-rooted:



 




x


r
m
s



=







x

1




2


+



x

2




2


+
⋯
+



x

n




2



n



.


{\displaystyle x_{\mathrm {rms} }={\sqrt {{{x_{1}}^{2}+{x_{2}}^{2}+\cdots +{x_{n}}^{2}} \over n}}.}




See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",#C.23,C#,"using System;
 
namespace rms
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] x = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
            Console.WriteLine(rootMeanSquare(x));
        }
 
        private static double rootMeanSquare(int[] x)
        {            
            double sum = 0;
            for (int i = 0; i < x.Length; i++)
            {
                sum += (x[i]*x[i]);
            }
            return Math.Sqrt(sum / x.Length);
        }
    }
}",513,23
73234,http://rosettacode.org/wiki/Barnsley_fern,Barnsley fern,"
A Barnsley fern is a fractal named after British mathematician Michael Barnsley and can be created using an iterated function system (IFS).



Task

Create this fractal fern, using the following transformations:

 ƒ1   (chosen 1% of the time)
        xn + 1 = 0
        yn + 1 = 0.16 yn

 ƒ2   (chosen 85% of the time)
        xn + 1 = 0.85 xn + 0.04 yn
        yn + 1 = −0.04 xn + 0.85 yn + 1.6

 ƒ3   (chosen 7% of the time)
        xn + 1 = 0.2 xn − 0.26 yn
        yn + 1 = 0.23 xn + 0.22 yn + 1.6

 ƒ4   (chosen 7% of the time)
        xn + 1 = −0.15 xn + 0.28 yn
        yn + 1 = 0.26 xn + 0.24 yn + 0.44.

Starting position: x = 0, y = 0



",#C.23,C#,"using System;
using System.Diagnostics;
using System.Drawing;
 
namespace RosettaBarnsleyFern
{
    class Program
    {
        static void Main(string[] args)
        {
            const int w = 600;
            const int h = 600;
            var bm = new Bitmap(w, h);
            var r = new Random();
            double x = 0;
            double y = 0;
            for (int count = 0; count < 100000; count++)
            {
                bm.SetPixel((int)(300 + 58 * x), (int)(58 * y), Color.ForestGreen);
                int roll = r.Next(100);
                double xp = x;
                if (roll < 1)
                {
                    x = 0;
                    y = 0.16 * y;
                } else if (roll < 86)
                {
                    x = 0.85 * x + 0.04 * y;
                    y = -0.04 * xp + 0.85 * y + 1.6;
                } else if (roll < 93)
                {
                    x = 0.2 * x - 0.26 * y;
                    y = 0.23 * xp + 0.22 * y + 1.6;
                } else
                {
                    x = -0.15 * x + 0.28 * y;
                    y = 0.26 * xp + 0.24 * y + 0.44;
                }
            }
            const string filename = ""Fern.png"";
            bm.Save(filename);
            Process.Start(filename);
        }
    }
}",1303,45
73303,http://rosettacode.org/wiki/Averages/Simple_moving_average,Averages/Simple moving average,"Computing the simple moving average of a series of numbers.

Task[edit]
Create a stateful function/class/instance that takes a period and returns a routine that takes a number as argument and returns a simple moving average of its arguments so far.

Description
A simple moving average is a method for computing an average of a stream of numbers by only averaging the last   P   numbers from the stream,   where   P   is known as the period.

It can be implemented by calling an initialing routine with   P   as its argument,   I(P),   which should then return a routine that when called with individual, successive members of a stream of numbers, computes the mean of (up to), the last   P   of them, lets call this   SMA().

The word   stateful   in the task description refers to the need for   SMA()   to remember certain information between calls to it:

   The period,   P
   An ordered container of at least the last   P   numbers from each of its individual calls.

Stateful   also means that successive calls to   I(),   the initializer,   should return separate routines that do   not   share saved state so they could be used on two independent streams of data.

Pseudo-code for an implementation of   SMA   is:

function SMA(number: N):
    stateful integer: P
    stateful list:    stream
    number:           average

    stream.append_last(N)
    if stream.length() > P:
        # Only average the last P elements of the stream
        stream.delete_first()
    if stream.length() == 0:
        average = 0
    else:    
        average = sum( stream.values() ) / stream.length()
    return average

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace SMA {
    class Program {
        static void Main(string[] args) {
            var nums = Enumerable.Range(1, 5).Select(n => (double)n);
            nums = nums.Concat(nums.Reverse());
 
            var sma3 = SMA(3);
            var sma5 = SMA(5);
 
            foreach (var n in nums) {
                Console.WriteLine(""{0}    (sma3) {1,-16} (sma5) {2,-16}"", n, sma3(n), sma5(n));
            }
        }
 
        static Func<double, double> SMA(int p) {
            Queue<double> s = new Queue<double>(p);
            return (x) => {
                if (s.Count >= p) {
                    s.Dequeue();
                }
                s.Enqueue(x);
                return s.Average();
            };
        }
    }
}",805,30
73366,http://rosettacode.org/wiki/Babbage_problem,Babbage problem,"

Charles Babbage, looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:

 What is the smallest positive integer whose square ends in the digits 269,696?

— Babbage, letter to Lord Bowden, 1837; see Hollingdale and Tootill, Electronic Computers, second edition, 1970, p. 125.

He thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.



Task[edit]
The task is to find out if Babbage had the right answer — and to do so, as far as your language allows it, in code that Babbage himself would have been able to read and understand.
As Babbage evidently solved the task with pencil and paper, a similar efficient solution is preferred.

For these purposes, Charles Babbage may be taken to be an intelligent person, familiar with mathematics and with the idea of a computer; he has written the first drafts of simple computer programmes in tabular form. [Babbage Archive Series L].



Motivation
The aim of the task is to write a program that is sufficiently clear and well-documented for such a person to be able to read it and be confident that it does indeed solve the specified problem.



",#C.23,C#,"namespace Babbage_Problem
{
    class iterateNumbers
    {
        public iterateNumbers()
        {
            long baseNumberSquared = 0; //the base number multiplied by itself
            long baseNumber = 0;  //the number to be squared, this one will be iterated
 
            do  //this sets up the loop
            {
                baseNumber += 1; //add one to the base number
                baseNumberSquared = baseNumber * baseNumber; //multiply the base number by itself and store the value as baseNumberSquared
            }
            while (Right6Digits(baseNumberSquared) != 269696); //this will continue the loop until the right 6 digits of the base number squared are 269,696
 
            Console.WriteLine(""The smallest integer whose square ends in 269,696 is "" + baseNumber);
            Console.WriteLine(""The square is "" + baseNumberSquared);
 
        }
 
        private long Right6Digits(long baseNumberSquared)
        {
 
            string numberAsString = baseNumberSquared.ToString(); //this is converts the number to a different type so it can be cut up
 
            if (numberAsString.Length < 6) { return baseNumberSquared; }; //if the number doesn't have 6 digits in it, just return it to try again.
 
            numberAsString = numberAsString.Substring(numberAsString.Length - 6);  //this extracts the last 6 digits from the number
 
            return long.Parse(numberAsString); //return the last 6 digits of the number
 
        }
    }
}}",1483,35
73514,http://rosettacode.org/wiki/Averages/Pythagorean_means,Averages/Pythagorean means,"Task[edit]
Compute all three of the Pythagorean means of the set of integers 1 through 10 (inclusive).

Show that 



A
(

x

1


,
…
,

x

n


)
≥
G
(

x

1


,
…
,

x

n


)
≥
H
(

x

1


,
…
,

x

n


)


{\displaystyle A(x_{1},\ldots ,x_{n})\geq G(x_{1},\ldots ,x_{n})\geq H(x_{1},\ldots ,x_{n})}

 for this set of positive integers.

 The most common of the three means, the arithmetic mean, is the sum of the list divided by its length:
 



A
(

x

1


,
…
,

x

n


)
=




x

1


+
⋯
+

x

n



n




{\displaystyle A(x_{1},\ldots ,x_{n})={\frac {x_{1}+\cdots +x_{n}}{n}}}


 The geometric mean is the 



n


{\displaystyle n}

th root of the product of the list:
 



G
(

x

1


,
…
,

x

n


)
=




x

1


⋯

x

n




n





{\displaystyle G(x_{1},\ldots ,x_{n})={\sqrt[{n}]{x_{1}\cdots x_{n}}}}


 The harmonic mean is 



n


{\displaystyle n}

 divided by the sum of the reciprocal of each item in the list:
 



H
(

x

1


,
…
,

x

n


)
=


n



1

x

1




+
⋯
+


1

x

n









{\displaystyle H(x_{1},\ldots ,x_{n})={\frac {n}{{\frac {1}{x_{1}}}+\cdots +{\frac {1}{x_{n}}}}}}




See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
 
namespace PythMean
{
    static class Program
    {
        static void Main(string[] args) {
            var nums = from n in Enumerable.Range(1, 10) select (double)n;
 
            var a = nums.Average();
            var g = nums.Gmean();
            var h = nums.Hmean();
 
            Console.WriteLine(""Arithmetic mean {0}"", a);
            Console.WriteLine(""Geometric mean  {0}"", g);
            Console.WriteLine(""Harmonic mean   {0}"", h);
 
            Debug.Assert(a >= g && g >= h);
        }
 
        // Geometric mean extension method.
        static double Gmean(this IEnumerable<double> n) {
            return Math.Pow(n.Aggregate((s, i) => s * i), 1.0 / n.Count());
        }
 
        // Harmonic mean extension method.
        static double Hmean(this IEnumerable<double> n) {
            return n.Count() / n.Sum(i => 1.0 / i);
        }
    }
}",961,34
73524,http://rosettacode.org/wiki/Averages/Mode,Averages/Mode,"Task[edit]
Write a program to find the mode value of a collection.

The case where the collection is empty may be ignored. Care must be taken to handle the case where the mode is non-unique.

If it is not appropriate or possible to support a general collection, use a vector (array), if possible. If it is not appropriate or possible to support an unspecified value type, use integers.

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",#C.23,C#,"using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
 
namespace Test
{
    class Program
    {
 
        static void Main(string[] args)
        {
            /*
             * We Use Linq To Determine The Mode
             */
            List<int> myList = new List<int>() { 1, 1, 2, 4, 4 }; 
 
            var query =     from numbers in myList //select the numbers
                            group numbers by numbers //group them together so we can get the count
                            into groupedNumbers
                            select new { Number = groupedNumbers.Key, Count = groupedNumbers.Count() }; //so we got a query
            //find the max of the occurence of the mode 
            int max = query.Max(g => g.Count);
            IEnumerable<int> modes = query.Where(x => x.Count == max).Select(x => x.Number);//match the frequence and select the number
            foreach (var item in modes)
            {
                Console.WriteLine(item);
            }
 
            Console.ReadLine();
        }
 
 
 
    }
 
 
}
 ",1092,39
73560,http://rosettacode.org/wiki/Balanced_ternary,Balanced ternary,"Balanced ternary is a way of representing numbers. Unlike the prevailing binary representation, a balanced ternary integer is in base 3, and each digit can have the values 1, 0, or −1.



Examples

Decimal 11 = 32 + 31 − 30, thus it can be written as ""++−""

Decimal 6 = 32 − 31 + 0 × 30, thus it can be written as ""+−0""



Task

Implement balanced ternary representation of integers with the following:

 Support arbitrarily large integers, both positive and negative;
 Provide ways to convert to and from text strings, using digits '+', '-' and '0' (unless you are already using strings to represent balanced ternary; but see requirement 5).
 Provide ways to convert to and from native integer type (unless, improbably, your platform's native integer type is balanced ternary). If your native integers can't support arbitrary length, overflows during conversion must be indicated.
 Provide ways to perform addition, negation and multiplication directly on balanced ternary integers; do not convert to native integers first.
 Make your implementation efficient, with a reasonable definition of ""efficient"" (and with a reasonable definition of ""reasonable"").

Test case With balanced ternaries a from string ""+-0++0+"", b from native integer -436, c ""+-++-"":

 write out a, b and c in decimal notation;
 calculate a × (b − c), write out the result in both ternary and decimal notations.

Note: The pages generalised floating point addition and generalised floating point multiplication have code implementing arbitrary precision floating point balanced ternary.



",#C.23,C#,"using System;
using System.Text;
using System.Collections.Generic;
 
public class BalancedTernary
{
	public static void Main()
	{
		BalancedTernary a = new BalancedTernary(""+-0++0+"");
		System.Console.WriteLine(""a: "" + a + "" = "" + a.ToLong());
		BalancedTernary b = new BalancedTernary(-436);
		System.Console.WriteLine(""b: "" + b + "" = "" + b.ToLong());
		BalancedTernary c = new BalancedTernary(""+-++-"");
		System.Console.WriteLine(""c: "" + c + "" = "" + c.ToLong());
		BalancedTernary d = a * (b - c);
		System.Console.WriteLine(""a * (b - c): "" + d + "" = "" + d.ToLong());
	}
 
	private enum BalancedTernaryDigit
	{
		MINUS = -1,
		ZERO = 0,
		PLUS = 1
	}
 
	private BalancedTernaryDigit[] value;
 
	// empty = 0
	public BalancedTernary()
	{
		this.value = new BalancedTernaryDigit[0];
	}
 
	// create from String
	public BalancedTernary(String str)
	{
		this.value = new BalancedTernaryDigit[str.Length];
		for (int i = 0; i < str.Length; ++i)
		{
			switch (str[i])
			{
				case '-':
					this.value[i] = BalancedTernaryDigit.MINUS;
					break;
				case '0':
					this.value[i] = BalancedTernaryDigit.ZERO;
					break;
				case '+':
					this.value[i] = BalancedTernaryDigit.PLUS;
					break;
				default:
					throw new ArgumentException(""Unknown Digit: "" + str[i]);
			}
		}
		Array.Reverse(this.value);
	}
 
	// convert long integer
	public BalancedTernary(long l)
	{
		List<BalancedTernaryDigit> value = new List<BalancedTernaryDigit>();
		int sign = Math.Sign(l);
		l = Math.Abs(l);
 
		while (l != 0)
		{
			byte rem = (byte)(l % 3);
			switch (rem)
			{
				case 0:
				case 1:
					value.Add((BalancedTernaryDigit)rem);
					l /= 3;
					break;
				case 2:
					value.Add(BalancedTernaryDigit.MINUS);
					l = (l + 1) / 3;
					break;
			}
		}
 
		this.value = value.ToArray();
		if (sign < 0)
		{
			this.Invert();
		}
	}
 
	// copy constructor
	public BalancedTernary(BalancedTernary origin)
	{
		this.value = new BalancedTernaryDigit[origin.value.Length];
		Array.Copy(origin.value, this.value, origin.value.Length);
	}
 
	// only for internal use
	private BalancedTernary(BalancedTernaryDigit[] value)
	{
		int end = value.Length - 1;
		while (value[end] == BalancedTernaryDigit.ZERO)
			--end;
		this.value = new BalancedTernaryDigit[end + 1];
		Array.Copy(value, this.value, end + 1);
	}
 
	// invert the values
	private void Invert()
	{
		for (int i=0; i < this.value.Length; ++i)
		{
			this.value[i] = (BalancedTernaryDigit)(-(int)this.value[i]);
		}
	}
 
	// convert to string
	override public String ToString()
	{
		StringBuilder result = new StringBuilder();
		for (int i = this.value.Length - 1; i >= 0; --i)
		{
			switch (this.value[i])
			{
				case BalancedTernaryDigit.MINUS:
					result.Append('-');
					break;
				case BalancedTernaryDigit.ZERO:
					result.Append('0');
					break;
				case BalancedTernaryDigit.PLUS:
					result.Append('+');
					break;
			}
		}
		return result.ToString();
	}
 
	// convert to long
	public long ToLong()
	{
		long result = 0;
		int digit;
		for (int i = 0; i < this.value.Length; ++i)
		{
			result += (long)this.value[i] * (long)Math.Pow(3.0, (double)i);
		}
		return result;
	}
 
	// unary minus
	public static BalancedTernary operator -(BalancedTernary origin)
	{
		BalancedTernary result = new BalancedTernary(origin);
		result.Invert();
		return result;
	}
 
	// addition of digits
	private static BalancedTernaryDigit carry = BalancedTernaryDigit.ZERO;
	private static BalancedTernaryDigit Add(BalancedTernaryDigit a, BalancedTernaryDigit b)
	{
		if (a != b)
		{
			carry = BalancedTernaryDigit.ZERO;
			return (BalancedTernaryDigit)((int)a + (int)b);
		}
		else
		{
			carry = a;
			return (BalancedTernaryDigit)(-(int)b);
		}
	}
 
	// addition of balanced ternary numbers
	public static BalancedTernary operator +(BalancedTernary a, BalancedTernary b)
	{
		int maxLength = Math.Max(a.value.Length, b.value.Length);
		BalancedTernaryDigit[] resultValue = new BalancedTernaryDigit[maxLength + 1];
		for (int i=0; i < maxLength; ++i)
		{
			if (i < a.value.Length)
			{
				resultValue[i] = Add(resultValue[i], a.value[i]);
				resultValue[i+1] = carry;
			}
			else
			{
				carry = BalancedTernaryDigit.ZERO;
			}
 
			if (i < b.value.Length)
			{
				resultValue[i] = Add(resultValue[i], b.value[i]);
				resultValue[i+1] = Add(resultValue[i+1], carry);
			}
		}
		return new BalancedTernary(resultValue);
	}
 
	// subtraction of balanced ternary numbers
	public static BalancedTernary operator -(BalancedTernary a, BalancedTernary b)
	{
		return a + (-b);
	}
 
	// multiplication of balanced ternary numbers
	public static BalancedTernary operator *(BalancedTernary a, BalancedTernary b)
	{
		BalancedTernaryDigit[] longValue = a.value;
		BalancedTernaryDigit[] shortValue = b.value;
		BalancedTernary result = new BalancedTernary();
		if (a.value.Length < b.value.Length)
		{
			longValue = b.value;
			shortValue = a.value;
		}
 
		for (int i = 0; i < shortValue.Length; ++i)
		{
			if (shortValue[i] != BalancedTernaryDigit.ZERO)
			{
				BalancedTernaryDigit[] temp = new BalancedTernaryDigit[i + longValue.Length];
				for (int j = 0; j < longValue.Length; ++j)
				{
					temp[i+j] = (BalancedTernaryDigit)((int)shortValue[i] * (int)longValue[j]);
				}
				result = result + new BalancedTernary(temp);
			}
		}
		return result;
	}
}",5313,231
73576,http://rosettacode.org/wiki/Averages/Mean_time_of_day,Averages/Mean time of day,"Task[edit]
A particular activity of bats occurs at these times of the day:

23:00:17, 23:40:20, 00:12:45, 00:17:19
Using the idea that there are twenty-four hours in a day,
which is analogous to there being 360 degrees in a circle,
map times of day to and from angles;
and using the ideas of Averages/Mean angle
compute and show the average time of the nocturnal activity
to an accuracy of one second of time.

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
 
namespace RosettaCode
{
    class Program
    {
        static void Main(string[] args)
        {
            Func<TimeSpan, double> TimeToDegrees = (time) => 
                360 * time.Hours / 24.0 +
                360 * time.Minutes / (24 * 60.0) +
                360 * time.Seconds / (24 * 3600.0);
            Func<List<double>, double> MeanAngle = (angles) =>
                {
                    double y_part = 0.0d, x_part = 0.0d;
                    int numItems = angles.Count;
 
                    for (int i = 0; i < numItems; i++)
                    {
                        x_part += Math.Cos(angles[i] * Math.PI / 180);
                        y_part += Math.Sin(angles[i] * Math.PI / 180);
                    }
 
                    return Math.Atan2(y_part / numItems, x_part / numItems) * 180 / Math.PI;
                };
            Func<double, TimeSpan> TimeFromDegrees = (angle) =>
                    new TimeSpan(
                        (int)(24 * 60 * 60 * angle / 360) / 3600, 
                        ((int)(24 * 60 * 60 * angle / 360) % 3600 - (int)(24 * 60 * 60 * angle / 360) % 60) / 60, 
                        (int)(24 * 60 * 60 * angle / 360) % 60);
            List<double> digitimes = new List<double>();
            TimeSpan digitime;
            string input;
 
            Console.WriteLine(""Enter times, end with no input: "");
            do
            {
                input = Console.ReadLine();
                if (!(string.IsNullOrWhiteSpace(input)))
                {
                    if (TimeSpan.TryParse(input, out digitime))
                        digitimes.Add(TimeToDegrees(digitime));
                    else
                        Console.WriteLine(""Seems this is wrong input: ignoring time"");
                }
            } while (!string.IsNullOrWhiteSpace(input));
 
            if(digitimes.Count() > 0)
                Console.WriteLine(""The mean time is : {0}"", TimeFromDegrees(360 + MeanAngle(digitimes)));
        }
    }
}
 ",2093,56
73628,http://rosettacode.org/wiki/AVL_tree,AVL tree,"

 This page uses content from Wikipedia. The original article was at AVL tree. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In computer science, an AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; at no time do they differ by more than one because rebalancing is done ensure this is the case. Lookup, insertion, and deletion all take O(log n) time in both the average and worst cases, where n is the number of nodes in the tree prior to the operation. Insertions and deletions may require the tree to be rebalanced by one or more tree rotations. Note the tree of nodes comprise a set, so duplicate node keys are not allowed.

AVL trees are often compared with red-black trees because they support the same set of operations and because red-black trees also take O(log n) time for the basic operations. Because AVL trees are more rigidly balanced, they are faster than red-black trees for lookup-intensive applications. Similar to red-black trees, AVL trees are height-balanced, but in general not weight-balanced nor μ-balanced; that is, sibling nodes can have hugely differing numbers of descendants.



Task

Implement an AVL tree in the language of choice, and provide at least basic operations.



",#C.23,C#," 
#include <algorithm>
#include <iostream>
 
/* AVL node */
template <class T>
class AVLnode {
public:
    T key;
    int balance;
    AVLnode *left, *right, *parent;
 
    AVLnode(T k, AVLnode *p) : key(k), balance(0), parent(p),
                        left(NULL), right(NULL) {}
 
    ~AVLnode() {
        delete left;
        delete right;
    }
};
 
/* AVL tree */
template <class T>
class AVLtree {
public:
    AVLtree(void);
    ~AVLtree(void);
    bool insert(T key);
    void deleteKey(const T key);
    void printBalance();
 
private:
    AVLnode<T> *root;
 
    AVLnode<T>* rotateLeft          ( AVLnode<T> *a );
    AVLnode<T>* rotateRight         ( AVLnode<T> *a );
    AVLnode<T>* rotateLeftThenRight ( AVLnode<T> *n );
    AVLnode<T>* rotateRightThenLeft ( AVLnode<T> *n );
    void rebalance                  ( AVLnode<T> *n );
    int height                      ( AVLnode<T> *n );
    void setBalance                 ( AVLnode<T> *n );
    void printBalance               ( AVLnode<T> *n );
};
 
/* AVL class definition */
template <class T>
void AVLtree<T>::rebalance(AVLnode<T> *n) {
    setBalance(n);
 
    if (n->balance == -2) {
        if (height(n->left->left) >= height(n->left->right))
            n = rotateRight(n);
        else
            n = rotateLeftThenRight(n);
    }
    else if (n->balance == 2) {
        if (height(n->right->right) >= height(n->right->left))
            n = rotateLeft(n);
        else
            n = rotateRightThenLeft(n);
    }
 
    if (n->parent != NULL) {
        rebalance(n->parent);
    }
    else {
        root = n;
    }
}
 
template <class T>
AVLnode<T>* AVLtree<T>::rotateLeft(AVLnode<T> *a) {
    AVLnode<T> *b = a->right;
    b->parent = a->parent;
    a->right = b->left;
 
    if (a->right != NULL)
        a->right->parent = a;
 
    b->left = a;
    a->parent = b;
 
    if (b->parent != NULL) {
        if (b->parent->right == a) {
            b->parent->right = b;
        }
        else {
            b->parent->left = b;
        }
    }
 
    setBalance(a);
    setBalance(b);
    return b;
}
 
template <class T>
AVLnode<T>* AVLtree<T>::rotateRight(AVLnode<T> *a) {
    AVLnode<T> *b = a->left;
    b->parent = a->parent;
    a->left = b->right;
 
    if (a->left != NULL)
        a->left->parent = a;
 
    b->right = a;
    a->parent = b;
 
    if (b->parent != NULL) {
        if (b->parent->right == a) {
            b->parent->right = b;
        }
        else {
            b->parent->left = b;
        }
    }
 
    setBalance(a);
    setBalance(b);
    return b;
}
 
template <class T>
AVLnode<T>* AVLtree<T>::rotateLeftThenRight(AVLnode<T> *n) {
    n->left = rotateLeft(n->left);
    return rotateRight(n);
}
 
template <class T>
AVLnode<T>* AVLtree<T>::rotateRightThenLeft(AVLnode<T> *n) {
    n->right = rotateRight(n->right);
    return rotateLeft(n);
}
 
template <class T>
int AVLtree<T>::height(AVLnode<T> *n) {
    if (n == NULL)
        return -1;
    return 1 + std::max(height(n->left), height(n->right));
}
 
template <class T>
void AVLtree<T>::setBalance(AVLnode<T> *n) {
    n->balance = height(n->right) - height(n->left);
}
 
template <class T>
void AVLtree<T>::printBalance(AVLnode<T> *n) {
    if (n != NULL) {
        printBalance(n->left);
        std::cout << n->balance << "" "";
        printBalance(n->right);
    }
}
 
template <class T>
AVLtree<T>::AVLtree(void) : root(NULL) {}
 
template <class T>
AVLtree<T>::~AVLtree(void) {
    delete root;
}
 
template <class T>
bool AVLtree<T>::insert(T key) {
    if (root == NULL) {
        root = new AVLnode<T>(key, NULL);
    }
    else {
        AVLnode<T>
            *n = root,
            *parent;
 
        while (true) {
            if (n->key == key)
                return false;
 
            parent = n;
 
            bool goLeft = n->key > key;
            n = goLeft ? n->left : n->right;
 
            if (n == NULL) {
                if (goLeft) {
                    parent->left = new AVLnode<T>(key, parent);
                }
                else {
                    parent->right = new AVLnode<T>(key, parent);
                }
 
                rebalance(parent);
                break;
            }
        }
    }
 
    return true;
}
 
template <class T>
void AVLtree<T>::deleteKey(const T delKey) {
    if (root == NULL)
        return;
 
    AVLnode<T>
        *n       = root,
        *parent  = root,
        *delNode = NULL,
        *child   = root;
 
    while (child != NULL) {
        parent = n;
        n = child;
        child = delKey >= n->key ? n->right : n->left;
        if (delKey == n->key)
            delNode = n;
    }
 
    if (delNode != NULL) {
        delNode->key = n->key;
 
        child = n->left != NULL ? n->left : n->right;
 
        if (root->key == delKey) {
            root = child;
        }
        else {
            if (parent->left == n) {
                parent->left = child;
            }
            else {
                parent->right = child;
            }
 
            rebalance(parent);
        }
    }
}
 
template <class T>
void AVLtree<T>::printBalance() {
    printBalance(root);
    std::cout << std::endl;
}
 
int main(void)
{
    AVLtree<int> t;
 
    std::cout << ""Inserting integer values 1 to 10"" << std::endl;
    for (int i = 1; i <= 10; ++i)
        t.insert(i);
 
    std::cout << ""Printing balance: "";
    t.printBalance();
}
 ",5383,257
73629,http://rosettacode.org/wiki/Averages/Mean_angle,Averages/Mean angle,"When calculating the average or mean of an angle one has to take into account how angles wrap around so that any angle in degrees plus any integer multiple of 360 degrees is a measure of the same angle.

If one wanted an average direction of the wind over two readings where the first reading was of 350 degrees and the second was of 10 degrees then the average of the numbers is 180 degrees, whereas if you can note that 350 degrees is equivalent to -10 degrees and so you have two readings at 10 degrees either side of zero degrees leading to a more fitting mean angle of zero degrees.

To calculate the mean angle of several angles:

 Assume all angles are on the unit circle and convert them to complex numbers expressed in real and imaginary form.
 Compute the mean of the complex numbers.
 Convert the complex mean to polar coordinates whereupon the phase of the complex mean is the required angular mean.


(Note that, since the mean is the sum divided by the number of numbers, and division by a positive real number does not affect the angle, you can also simply compute the sum for step 2.)

You can alternatively use this formula:

 Given the angles 




α

1


,
…
,

α

n




{\displaystyle \alpha _{1},\dots ,\alpha _{n}}

 the mean is computed by







α
¯



=
atan2
⁡

(


1
n


⋅

∑

j
=
1


n


sin
⁡

α

j


,


1
n


⋅

∑

j
=
1


n


cos
⁡

α

j


)



{\displaystyle {\bar {\alpha }}=\operatorname {atan2} \left({\frac {1}{n}}\cdot \sum _{j=1}^{n}\sin \alpha _{j},{\frac {1}{n}}\cdot \sum _{j=1}^{n}\cos \alpha _{j}\right)}


Task[edit]
 write a function/method/subroutine/... that given a list of angles in degrees returns their mean angle. 
 (You should use a built-in function if you have one that does this for degrees or radians). 
 Use the function to compute the means of these lists of angles (in degrees):
   [350, 10] 
   [90, 180, 270, 360] 
   [10, 20, 30]
 Show your output here.
See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",#C.23,C#,"using System;
using System.Linq;
using static System.Math;
class Program
{
    static double MeanAngle(double[] angles)
    {
        var x = angles.Sum(a => Cos(a * PI / 180)) / angles.Length;
        var y = angles.Sum(a => Sin(a * PI / 180)) / angles.Length;
        return Atan2(y, x) * 180 / PI;
    }
    static void Main()
    {
        Action<double[]> printMean = x => Console.WriteLine(""{0:0.###}"", MeanAngle(x));
        printMean(new double[] { 350, 10 });
        printMean(new double[] { 90, 180, 270, 360 });
        printMean(new double[] { 10, 20, 30 });
    }
}",579,19
73673,http://rosettacode.org/wiki/Average_loop_length,Average loop length,"Let f be a uniformly-randomly chosen mapping from the numbers 1..N to the numbers 1..N (note: not necessarily a permutation of 1..N; the mapping could produce a number in more than one way or not at all). At some point, the sequence 1, f(1), f(f(1))... will contain a repetition, a number that occurring for the second time in the sequence.



Task

Write a program or a script that estimates, for each N, the average length until the first such repetition.

Also calculate this expected length using an analytical formula, and optionally compare the simulated result with the theoretical one.



This problem comes from the end of Donald Knuth's Christmas tree lecture 2011.

Example of expected output:

 N    average    analytical    (error)
===  =========  ============  =========
  1     1.0000        1.0000  (  0.00%)
  2     1.4992        1.5000  (  0.05%)
  3     1.8784        1.8889  (  0.56%)
  4     2.2316        2.2188  (  0.58%)
  5     2.4982        2.5104  (  0.49%)
  6     2.7897        2.7747  (  0.54%)
  7     3.0153        3.0181  (  0.09%)
  8     3.2429        3.2450  (  0.07%)
  9     3.4536        3.4583  (  0.14%)
 10     3.6649        3.6602  (  0.13%)
 11     3.8091        3.8524  (  1.12%)
 12     3.9986        4.0361  (  0.93%)
 13     4.2074        4.2123  (  0.12%)
 14     4.3711        4.3820  (  0.25%)
 15     4.5275        4.5458  (  0.40%)
 16     4.6755        4.7043  (  0.61%)
 17     4.8877        4.8579  (  0.61%)
 18     4.9951        5.0071  (  0.24%)
 19     5.1312        5.1522  (  0.41%)
 20     5.2699        5.2936  (  0.45%)

",#C.23,C#,"public class AverageLoopLength {
	private static int N = 100000;
 
	private static double analytical(int n) {
		double[] factorial = new double[n + 1];
		double[] powers = new double[n + 1];
		powers[0] = 1.0;
		factorial[0] = 1.0;
		for (int i = 1; i <= n; i++) {
			factorial[i] = factorial[i - 1] * i;
			powers[i] = powers[i - 1] * n;
		}
		double sum = 0;
 
		for (int i = 1; i <= n; i++) {
			sum += factorial[n] / factorial[n - i] / powers[i];
		}
		return sum;
	}
 
	private static double average(int n) {
		Random rnd = new Random();
		double sum = 0.0;
		for (int a = 0; a < N; a++) {
			int[] random = new int[n];
			for (int i = 0; i < n; i++) {
				random[i] = rnd.Next(n);
			}
			var seen = new HashSet<double>(n);
			int current = 0;
			int length = 0;
			while (seen.Add(current)) {
				length++;
				current = random[current];
			}
			sum += length;
		}
		return sum / N;
	}
 
	public static void Main(string[] args) {
	Console.WriteLine("" N    average    analytical    (error)"");
	Console.WriteLine(""===  =========  ============  ========="");
		for (int i = 1; i <= 20; i++) {
			var average = AverageLoopLength.average(i);
			var analytical = AverageLoopLength.analytical(i);
			Console.WriteLine(""{0,3} {1,10:N4} {2,13:N4}  {3,8:N2}%"", i, average, analytical, (analytical - average) / analytical * 100);
		}
	}
}
 ",1335,51
73754,http://rosettacode.org/wiki/Attractive_numbers,Attractive numbers,"A number is an   attractive number   if the number of its prime factors (whether distinct or not) is also prime.



Example

The number   20,   whose prime decomposition is   2 × 2 × 5,   is an   attractive number   because the number of its prime factors   (3)   is also prime.



Task

Show sequence items up to   120.



Reference

   The OEIS entry:   A063989: Numbers with a prime number of prime divisors.

",#C.23,C#,"using System;
 
namespace AttractiveNumbers {
    class Program {
        const int MAX = 120;
 
        static bool IsPrime(int n) {
            if (n < 2) return false;
            if (n % 2 == 0) return n == 2;
            if (n % 3 == 0) return n == 3;
            int d = 5;
            while (d * d <= n) {
                if (n % d == 0) return false;
                d += 2;
                if (n % d == 0) return false;
                d += 4;
            }
            return true;
        }
 
        static int PrimeFactorCount(int n) {
            if (n == 1) return 0;
            if (IsPrime(n)) return 1;
            int count = 0;
            int f = 2;
            while (true) {
                if (n % f == 0) {
                    count++;
                    n /= f;
                    if (n == 1) return count;
                    if (IsPrime(n)) f = n;
                } else if (f >= 3) {
                    f += 2;
                } else {
                    f = 3;
                }
            }
        }
 
        static void Main(string[] args) {
            Console.WriteLine(""The attractive numbers up to and including {0} are:"", MAX);
            int i = 1;
            int count = 0;
            while (i <= MAX) {
                int n = PrimeFactorCount(i);
                if (IsPrime(n)) {
                    Console.Write(""{0,4}"", i);
                    if (++count % 20 == 0) Console.WriteLine();
                }
                ++i;
            }
            Console.WriteLine();
        }
    }
}",1546,55
73772,http://rosettacode.org/wiki/Associative_array/Merging,Associative array/Merging,"Task

Define two associative arrays, where one represents the following ""base"" data:





 Key 
 Value


 ""name"" 
 ""Rocket Skates""


 ""price"" 
 12.75


 ""color"" 
 ""yellow""

And the other represents ""update"" data:





 Key 
 Value


 ""price"" 
 15.25


 ""color"" 
 ""red""


 ""year"" 
 1974

Merge these into a new associative array that contains every key found in either of the source ones. Each key should map to the value in the second (update) table if that exists, or else to the value in the first (base) table. If possible, do this in a way that does not mutate the original two associative arrays. Obviously this should be done in a way that would work for any data, not just the specific data given here, but in this example the result should be:





 Key 
 Value


 ""name"" 
 ""Rocket Skates""


 ""price"" 
 15.25


 ""color"" 
 ""red""


 ""year"" 
 1974


",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
public class Program
{
    public static void Main() {
        var baseData = new Dictionary<string, object> {
            [""name""] = ""Rocket Skates"",
            [""price""] = 12.75,
            [""color""] = ""yellow""
        };
        var updateData = new Dictionary<string, object> {
            [""price""] = 15.25,
            [""color""] = ""red"",
            [""year""] = 1974
        };
        var mergedData = new Dictionary<string, object>();
        foreach (var entry in baseData.Concat(updateData)) {
            mergedData[entry.Key] = entry.Value;
        }
        foreach (var entry in mergedData) {
            Console.WriteLine(entry);
        }
   }
}",731,26
73779,http://rosettacode.org/wiki/Averages/Median,Averages/Median,"Task[edit]
Write a program to find the   median   value of a vector of floating-point numbers.

The program need not handle the case where the vector is empty, but must handle the case where there are an even number of elements.   In that case, return the average of the two middle values.

There are several approaches to this.   One is to sort the elements, and then pick the element(s) in the middle.

Sorting would take at least   O(n logn).   Another approach would be to build a priority queue from the elements, and then extract half of the elements to get to the middle element(s).   This would also take   O(n logn).   The best solution is to use the   selection algorithm   to find the median in   O(n)   time.

See also
Quickselect_algorithm

Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",#C.23,C#,"using System;
using System.Linq;
 
namespace Test
{
    class Program
    {
        static void Main()
        {
            double[] myArr = new double[] { 1, 5, 3, 6, 4, 2 };
 
            myArr = myArr.OrderBy(i => i).ToArray();
            // or Array.Sort(myArr) for in-place sort
 
            int mid = myArr.Length / 2;
            double median;
 
            if (myArr.Length % 2 == 0)
            {
                //we know its even
                median = (myArr[mid] + myArr[mid - 1]) / 2.0;
            }
            else
            {
                //we know its odd
                median = myArr[mid];
            }
 
            Console.WriteLine(median);
            Console.ReadLine();
        }
    }
}
 ",729,34
73812,http://rosettacode.org/wiki/Approximate_equality,Approximate equality,"Sometimes, when testing whether the solution to a task (for example, here on Rosetta Code) is correct, the
difference in floating point calculations between different language implementations becomes significant.

For example, a difference between 32 bit and 64 bit floating point calculations may appear by
about the 8th significant digit in base 10 arithmetic.



Task

Create a function which returns true if two floating point numbers are approximately equal.



The function should allow for differences in the magnitude of numbers, so that, for example,

100000000000000.01   may be approximately equal to   100000000000000.011,

even though   100.01   is not approximately equal to   100.011.

If the language has such a feature in its standard library, this may be used instead of a custom function.

Show the function results with comparisons on the following pairs of values:

     100000000000000.01,   100000000000000.011     (note: should return true)
     100.01,   100.011                                                     (note: should return false)
     10000000000000.001 / 10000.0,   1000000000.0000001000
     0.001,   0.0010000001
     0.000000000000000000000101,   0.0
      sqrt(2) * sqrt(2),    2.0
     -sqrt(2) * sqrt(2),   -2.0
     3.14159265358979323846,   3.14159265358979324


Answers should be true for the first example and false in the second, so that just rounding the numbers to a fixed number of decimals should not be enough. Otherwise answers may vary and still be correct. See the Python code for one type of solution.



",#C.23,C#,"using System;
 
public static class Program
{
    public static void Main() {
        Test(100000000000000.01, 100000000000000.011);
        Test(100.01, 100.011);
        Test(10000000000000.001 / 10000.0, 1000000000.0000001000);
        Test(0.001, 0.0010000001);
        Test(0.000000000000000000000101, 0.0);
        Test(Math.Sqrt(2) * Math.Sqrt(2), 2.0);
        Test(-Math.Sqrt(2) * Math.Sqrt(2), -2.0);
        Test(3.14159265358979323846, 3.14159265358979324);
 
        void Test(double a, double b) {
            const double epsilon = 1e-18;
            WriteLine($""{a}, {b} => {a.ApproxEquals(b, epsilon)}"");
        }
    }
 
    public static bool ApproxEquals(this double value, double other, double epsilon) => Math.Abs(value - other) < epsilon;
}",764,22
73814,http://rosettacode.org/wiki/Atomic_updates,Atomic updates,"

Task

Define a data type consisting of a fixed number of 'buckets', each containing a nonnegative integer value, which supports operations to:

 get the current value of any bucket
 remove a specified amount from one specified bucket and add it to another, preserving the total of all bucket values, and clamping the transferred amount to ensure the values remain non-negative

In order to exercise this data type, create one set of buckets, and start three concurrent tasks:

 As often as possible, pick two buckets and make their values closer to equal.
 As often as possible, pick two buckets and arbitrarily redistribute their values.
 At whatever rate is convenient, display (by any means) the total value and, optionally, the individual values of each bucket.


The display task need not be explicit; use of e.g. a debugger or trace tool is acceptable provided it is simple to set up to provide the display.


This task is intended as an exercise in atomic operations.   The sum of the bucket values must be preserved even if the two tasks attempt to perform transfers simultaneously, and a straightforward solution is to ensure that at any time, only one transfer is actually occurring — that the transfer operation is atomic.



",#C.23,C#,"- Changed to using object locks and Montor.Enter rather than Mutexes.  This allows use of the cleaner ""lock"" statement, and also has lower runtime overhead for in process locks
- The previous implementation tracked a ""swapped"" state - which seems a harder way to tackle the problem.   You need to acquire the locks in the correct order, not swap i and j
",354,3
73875,http://rosettacode.org/wiki/Balanced_brackets,Balanced brackets,"Task:

 Generate a string with   N   opening brackets   [   and with   N   closing brackets   ],   in some arbitrary order. 
 Determine whether the generated string is balanced; that is, whether it consists entirely of pairs of opening/closing brackets (in that order), none of which mis-nest.


Examples

   (empty)      OK
   []           OK   
   [][]         OK   
   [[][]]       OK 
   ][         NOT OK
   ][][       NOT OK
   []][[]     NOT OK


",#C.23,C#,"using System;
using System.Linq;
 
class Program
{
    static bool IsBalanced(string text, char open = '[', char close = ']')
    {
        var level = 0;
        foreach (var character in text)
        {
            if (character == close)
            {
                if (level == 0)
                {
                    return false;
                }
                level--;
            }
            if (character == open)
            {
                level++;
            }
        }
        return level == 0;
    }
 
    static string RandomBrackets(int count, char open = '[', char close = ']')
    {
        var random = new Random();
        return string.Join(string.Empty,
                (new string(open, count) + new string(close, count)).OrderBy(c => random.Next()));
    }
 
    static void Main()
    {
        for (var count = 0; count < 9; count++)
        {
            var text = RandomBrackets(count);
            Console.WriteLine(""\""{0}\"" is {1}balanced."", text, IsBalanced(text) ? string.Empty : ""not "");
        }
    }
}",1053,42
73953,http://rosettacode.org/wiki/Apply_a_digital_filter_(direct_form_II_transposed),Apply a digital filter (direct form II transposed),"Digital filters are used to apply a mathematical operation to a sampled signal. One of the common formulations is the ""direct form II transposed"" which can represent both infinite impulse response (IIR) and finite impulse response (FIR) filters, as well as being more numerically stable than other forms. [1]

Task

Filter a signal using an order 3 low-pass Butterworth filter. The coefficients for the filter are a=[1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17] and b = [0.16666667, 0.5, 0.5, 0.16666667]

The signal that needs filtering is the following vector: [-0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412, -0.662370894973, -1.00700480494, -0.404707073677 ,0.800482325044, 0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195, 0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293, 0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589]
",#C.23,C#,"using System;
 
namespace ApplyDigitalFilter {
    class Program {
        private static double[] Filter(double[] a, double[] b, double[] signal) {
            double[] result = new double[signal.Length];
            for (int i = 0; i < signal.Length; ++i) {
                double tmp = 0.0;
                for (int j = 0; j < b.Length; ++j) {
                    if (i - j < 0) continue;
                    tmp += b[j] * signal[i - j];
                }
                for (int j = 1; j < a.Length; ++j) {
                    if (i - j < 0) continue;
                    tmp -= a[j] * result[i - j];
                }
                tmp /= a[0];
                result[i] = tmp;
            }
            return result;
        }
 
        static void Main(string[] args) {
            double[] a = new double[] { 1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17 };
            double[] b = new double[] { 0.16666667, 0.5, 0.5, 0.16666667 };
 
            double[] signal = new double[] {
                -0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412,
                -0.662370894973, -1.00700480494, -0.404707073677, 0.800482325044,
                0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195,
                0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293,
                0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589
            };
 
            double[] result = Filter(a, b, signal);
            for (int i = 0; i < result.Length; ++i) {
                Console.Write(""{0,11:F8}"", result[i]);
                Console.Write((i + 1) % 5 != 0 ? "", "" : ""\n"");
            }
        }
    }
}",1680,42
74042,http://rosettacode.org/wiki/Append_a_record_to_the_end_of_a_text_file,Append a record to the end of a text file,"Many systems offer the ability to open a file for writing, such that any data written will be appended to the end of the file. Further, the file operations will always adjust the position pointer to guarantee the end of the file, even in a multitasking environment.

This feature is most useful in the case of log files, where many jobs may be appending to the log file at the same time, or where care must be taken to avoid concurrently overwriting the same record from another job.



Task

Given a two record sample for a mythical ""passwd"" file:

 Write these records out in the typical system format.
 Ideally these records will have named fields of various types.
 Close the file, then reopen the file for append.
 Append a new record to the file and close the file again.
 Take appropriate care to avoid concurrently overwrites from another job.
 Open the file and demonstrate the new record has indeed written to the end.

 Source record field types and contents.


account
password
UID
GID
fullname,office,extension,homephone,email
directory
shell


string
string
int
int
struct(string,string,string,string,string)
string
string


jsmith
x
1001
1000
Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org
/home/jsmith
/bin/bash


jdoe
x
1002
1000
Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org
/home/jdoe
/bin/bash


 Record to be appended.


account
password
UID
GID
fullname,office,extension,homephone,email
directory
shell


string
string
int
int
struct(string,string,string,string,string)
string
string


xyz
x
1003
1000
X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org
/home/xyz
/bin/bash

Resulting file format: should mimic Linux's /etc/passwd file format with particular attention to the "","" separator used in the GECOS field. But if the specific language has a particular or unique format of storing records in text file, then this format should be named and demonstrated with an additional example.

Expected output:

Appended record: xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash

Finally: Provide a summary of the language's ""append record"" capabilities in a table. eg.


 Append Capabilities.


 Data Representation

 IO
Library

 Append
Possible

 Automatic
Append

 Multi-tasking
Safe


 In core 
 On disk


 C struct 
 CSV text file 
 glibc/stdio 
 ☑ 
 ☑ 
 ☑ (Not all, eg NFS)

Alternatively: If the language's appends can not guarantee its writes will always append, then note this restriction in the table. If possible, provide an actual code example (possibly using file/record locking) to guarantee correct concurrent appends.



",#C.23,C#,"using System;
using System.IO;
 
namespace AppendPwdRosetta
{
    class PasswordRecord
    {
        public string account, password, fullname, office, extension, homephone, email, directory, shell;
        public int UID, GID;
        public PasswordRecord(string account, string password, int UID, int GID, string fullname, string office, string extension, string homephone, 
            string email, string directory, string shell)
        {
            this.account = account; this.password = password; this.UID = UID; this.GID = GID; this.fullname = fullname; this.office = office;
            this.extension = extension; this.homephone = homephone; this.email = email; this.directory = directory; this.shell = shell;
        }
        public override string ToString()
        {
            var gecos = string.Join("","", new string[] { fullname, office, extension, homephone, email });
            return string.Join("":"", new string[] { account, password, UID.ToString(), GID.ToString(), gecos, directory, shell });
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            var jsmith = new PasswordRecord(""jsmith"", ""x"", 1001, 1000, ""Joe Smith"", ""Room 1007"", ""(234)555-8917"", ""(234)555-0077"", ""jsmith@rosettacode.org"", 
                ""/home/jsmith"", ""/bin/bash"");
            var jdoe = new PasswordRecord(""jdoe"", ""x"", 1002, 1000, ""Jane Doe"", ""Room 1004"", ""(234)555-8914"", ""(234)555-0044"", ""jdoe@rosettacode.org"", ""/home/jdoe"", 
                ""/bin/bash"");
            var xyz = new PasswordRecord(""xyz"", ""x"", 1003, 1000, ""X Yz"", ""Room 1003"", ""(234)555-8913"", ""(234)555-0033"", ""xyz@rosettacode.org"", ""/home/xyz"", ""/bin/bash"");
 
            // Write these records out in the typical system format. 
            File.WriteAllLines(""passwd.txt"", new string[] { jsmith.ToString(), jdoe.ToString() });
 
            // Append a new record to the file and close the file again.
            File.AppendAllText(""passwd.txt"", xyz.ToString());
 
            // Open the file and demonstrate the new record has indeed written to the end.
            string[] lines = File.ReadAllLines(""passwd.txt"");
            Console.WriteLine(""Appended record: "" + lines[2]);
        }
    }
}
 ",2226,44
74057,http://rosettacode.org/wiki/Averages/Arithmetic_mean,Averages/Arithmetic mean,"Task[edit]
Write a program to find the mean (arithmetic average) of a numeric vector.

In case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",#C.23,C#,"using System;
using System.Linq;
 
class Program
{
    static void Main()
    {
        Console.WriteLine(new[] { 1, 2, 3 }.Average());
    }
}",143,10
74122,http://rosettacode.org/wiki/Associative_array/Iteration,Associative array/Iteration,"Show how to iterate over the key-value pairs of an associative array, and print each pair out.

Also show how to iterate just over the keys, or the values, if there is a separate way to do that in your language.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace AssocArrays
{
    class Program
    {
        static void Main(string[] args)
        {
 
            Dictionary<string,int> assocArray = new Dictionary<string,int>();
 
            assocArray[""Hello""] = 1;
            assocArray.Add(""World"", 2);
            assocArray[""!""] = 3;
 
            foreach (KeyValuePair<string, int> kvp in assocArray)
            {
                Console.WriteLine(kvp.Key + "" : "" + kvp.Value);
            }
 
            foreach (string key in assocArray.Keys)
            {
                Console.WriteLine(key);
            }
 
            foreach (int val in assocArray.Values)
            {
                Console.WriteLine(val.ToString());
            }
        }
    }
}
 ",773,34
74259,http://rosettacode.org/wiki/Anti-primes,Anti-primes,"The anti-primes
(or highly composite numbers, sequence A002182 in the OEIS)
are the natural numbers with more factors than any smaller than itself.



Task

Generate and show here, the first twenty anti-primes.



Related tasks

   Factors of an integer
   Sieve of Eratosthenes

",#C.23,C#,"using System;
using System.Linq;
using System.Collections.Generic;
 
public static class Program
{
    public static void Main() =>
        Console.WriteLine(string.Join("" "", FindAntiPrimes().Take(20)));
 
    static IEnumerable<int> FindAntiPrimes() {
        int max = 0;
        for (int i = 1; ; i++) {
            int divisors = CountDivisors(i);
            if (divisors > max) {
                max = divisors;
                yield return i;
            }
        }
 
        int CountDivisors(int n) => Enumerable.Range(1, n / 2).Count(i => n % i == 0) + 1;
    }
}",574,22
74266,http://rosettacode.org/wiki/Apply_a_callback_to_an_array,Apply a callback to an array,"Task

Take a combined set of elements and apply a function to each element.



",#C.23,C#,"int[] intArray = { 1, 2, 3, 4, 5 };
// Simplest method:  LINQ, functional
int[] squares1 = intArray.Select(x => x * x).ToArray();
 
// Slightly fancier: LINQ, query expression
int[] squares2 = (from x in intArray
                  select x * x).ToArray();
 
// Or, if you only want to call a function on each element, just use foreach
foreach (var i in intArray)
    Console.WriteLine(i * i);",392,11
74664,http://rosettacode.org/wiki/Associative_array/Creation,Associative array/Creation,"Task

The goal is to create an associative array (also known as a dictionary, map, or hash).



Related tasks:

 Associative arrays/Iteration
 Hash from two arrays


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#C.23,C#,"System.Collections.HashTable map = new System.Collections.HashTable();
map[""key1""] = ""foo"";",91,2
75551,http://rosettacode.org/wiki/Anonymous_recursion,Anonymous recursion,"While implementing a recursive function, it often happens that we must resort to a separate   helper function   to handle the actual recursion.

This is usually the case when directly calling the current function would waste too many resources (stack space, execution time), causing unwanted side-effects,   and/or the function doesn't have the right arguments and/or return values.

So we end up inventing some silly name like   foo2   or   foo_helper.   I have always found it painful to come up with a proper name, and see some disadvantages:

   You have to think up a name, which then pollutes the namespace
   Function is created which is called from nowhere else
   The program flow in the source code is interrupted
Some languages allow you to embed recursion directly in-place.   This might work via a label, a local gosub instruction, or some special keyword.

Anonymous recursion can also be accomplished using the   Y combinator.



Task

If possible, demonstrate this by writing the recursive version of the fibonacci function   (see Fibonacci sequence)   which checks for a negative argument before doing the actual recursion.



",#C.23,C#," 
static int Fib(int n)
{
    if (n < 0) throw new ArgumentException(""Must be non negativ"", ""n"");
 
    Func<int, int> fib = null; // Must be known, before we can assign recursively to it.
    fib = p => p > 1 ? fib(p - 2) + fib(p - 1) : p;
    return fib(n);
}
 ",263,10
75563,http://rosettacode.org/wiki/Anagrams/Deranged_anagrams,Anagrams/Deranged anagrams,"Two or more words are said to be anagrams if they have the same characters, but in a different order.

By analogy with derangements we define a deranged anagram as two words with the same characters, but in which the same character does not appear in the same position in both words.

Task[edit]
Use the word list at unixdict to find and display the longest deranged anagram.



Related tasks
 Permutations/Derangements
 Best shuffle
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"public static void Main()
{
    var lookupTable = File.ReadLines(""unixdict.txt"").ToLookup(line => AnagramKey(line));
    var query = from a in lookupTable
        orderby a.Key.Length descending
        let deranged = FindDeranged(a)
        where deranged != null
        select deranged[0] + "" "" + deranged[1];
    Console.WriteLine(query.FirstOrDefault());
}
 
static string AnagramKey(string word) => new string(word.OrderBy(c => c).ToArray());
 
static string[] FindDeranged(IEnumerable<string> anagrams) => (
    from first in anagrams
    from second in anagrams
    where !second.Equals(first)
        && Enumerable.Range(0, first.Length).All(i => first[i] != second[i])
    select new [] { first, second })
    .FirstOrDefault();",738,20
75567,http://rosettacode.org/wiki/Animation,Animation,"
Animation is integral to many parts of GUIs, including both the fancy effects when things change used in window managers, and of course games.   The core of any animation system is a scheme for periodically changing the display while still remaining responsive to the user.   This task demonstrates this.



Task

Create a window containing the string ""Hello World! "" (the trailing space is significant).

Make the text appear to be rotating right by periodically removing one letter from the end of the string and attaching it to the front.

When the user clicks on the (windowed) text, it should reverse its direction.



",#C.23,C#,"using System;
using System.Drawing;
using System.Windows.Forms;
 
namespace BasicAnimation
{
  class BasicAnimationForm : Form
  {
    bool isReverseDirection;
    Label textLabel;
    Timer timer;
 
    internal BasicAnimationForm()
    {
      this.Size = new Size(150, 75);
      this.Text = ""Basic Animation"";
 
      textLabel = new Label();
      textLabel.Text = ""Hello World! "";
      textLabel.Location = new Point(3,3);
      textLabel.AutoSize = true;
      textLabel.Click += new EventHandler(textLabel_OnClick);
      this.Controls.Add(textLabel);
 
      timer = new Timer();
      timer.Interval = 500;
      timer.Tick += new EventHandler(timer_OnTick);
      timer.Enabled = true;
 
      isReverseDirection = false;
    }
 
    private void timer_OnTick(object sender, EventArgs e)
    {
      string oldText = textLabel.Text, newText;
      if(isReverseDirection)
        newText = oldText.Substring(1, oldText.Length - 1) + oldText.Substring(0, 1);
      else
        newText = oldText.Substring(oldText.Length - 1, 1) + oldText.Substring(0, oldText.Length - 1);
      textLabel.Text = newText;
    }
 
    private void textLabel_OnClick(object sender, EventArgs e)
    {
      isReverseDirection = !isReverseDirection;
    }
  }
 
   class Program
   {
      static void Main()
      {
	Application.Run(new BasicAnimationForm());
      }
   }
}",1365,56
75577,"http://rosettacode.org/wiki/Angles_(geometric),_normalization_and_conversion","Angles (geometric), normalization and conversion","This task is about the normalization and/or conversion of (geometric) angles using
some common scales.



The angular scales that will be used in this task are:

   degree
   gradian
   mil
   radian


Definitions

The angular scales used or referenced here:

   turn   is a full turn or 360 degrees, also shown as 360º
   degree   is   1/360   of a turn
   gradian   is   1/400   of a turn
   mil   is   1/6400   of a turn
   radian   is   1/2



π


{\displaystyle \pi }

   of a turn   (or   0.5/



π


{\displaystyle \pi }

   of a turn)


Or, to put it another way,   for a full circle:

   there are   360   degrees
   there are   400   gradians
   there are   6,400   mils
   there are   2



π


{\displaystyle \pi }

   radians   (roughly equal to 6.283+)


A   mil   is approximately equal to a   milliradian   (which is   1/1000   of a radian).

There is another definition of a   mil   which
is   1/1000   of a radian   ─── this
definition won't be used in this Rosetta Code task.


Turns   are sometimes known or shown as:

   turn(s)
   360 degrees
   unit circle
   a (full) circle

Degrees   are sometimes known or shown as:

   degree(s)
   deg
   º       (a symbol)
   °       (another symbol)

Gradians   are sometimes known or shown as:

   gradian(s)
   grad(s)
   grade(s)
   gon(s)
   metric degree(s)
   (Note that   centigrade   was used for 1/100th of a grade, see the note below.)

Mils   are sometimes known or shown as:

   mil(s)
   NATO mil(s)

Radians   are sometimes known or shown as:

   radian(s)
   rad(s)


Notes

In continental Europe, the French term   centigrade   was used
for   1/100   of a grad (grade);   this was
one reason for the adoption of the term   Celsius   to
replace   centigrade   as the name of a temperature scale.

Gradians were commonly used in civil engineering.

Mils were normally used for artillery   (elevations of the gun barrel for ranging).



Positive and negative angles

Although the definition of the measurement of an angle doesn't support the
concept of a negative angle,   it's frequently useful to impose a convention that
allows positive and negative angular values to represent orientations and/or rotations
in opposite directions relative to some reference.   It is this reason that
negative angles will keep their sign and not be normalized to positive angles.



Normalization

Normalization   (for this Rosetta Code task)   will keep the same
sign,   but it will reduce the magnitude to less than a full circle;   in
other words, less than 360º.

Normalization   shouldn't   change   -45º   to   315º,

An angle of   0º,   +0º,   0.000000,   or   -0º   should be
shown as   0º.



Task

   write a function (or equivalent) to do the normalization for each scale
 Suggested names:
 d2d,   g2g,   m2m,   and  r2r
   write a function (or equivalent) to convert one scale to another
 Suggested names for comparison of different computer language function names:
 d2g,   d2m,   and   d2r   for degrees
 g2d,   g2m,   and   g2r   for gradians
 m2d,   m2g,   and   m2r   for mils
 r2d,   r2g,   and   r2m   for radians
   normalize all angles used   (except for the ""original"" or ""base"" angle)
   show the angles in every scale and convert them to all other scales
   show all output here on this page


For the (above) conversions,   use these dozen numbers   (in the order shown):

   -2   -1   0   1   2   6.2831853   16   57.2957795   359   399   6399   1000000

",#C.23,C#,"using System;
 
public static class Angles
{
    public static void Main() => Print(-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 6399, 1_000_000);
 
    public static void Print(params double[] angles) {
        string[] names = { ""Degrees"", ""Gradians"", ""Mils"", ""Radians"" };
        Func<double, double> rnd = a => Math.Round(a, 4);
        Func<double, double>[] normal = { NormalizeDeg, NormalizeGrad, NormalizeMil, NormalizeRad };
 
        Func<double, double>[,] convert = {
            { a => a, DegToGrad, DegToMil, DegToRad },
            { GradToDeg, a => a, GradToMil, GradToRad },
            { MilToDeg, MilToGrad, a => a, MilToRad },
            { RadToDeg, RadToGrad, RadToMil, a => a }
        };
 
        Console.WriteLine($@""{""Angle"",-12}{""Normalized"",-12}{""Unit"",-12}{
            ""Degrees"",-12}{""Gradians"",-12}{""Mils"",-12}{""Radians"",-12}"");
 
        foreach (double angle in angles) {
            for (int i = 0; i < 4; i++) {
                double nAngle = normal[i](angle);
 
                Console.WriteLine($@""{
                    rnd(angle),-12}{
                    rnd(nAngle),-12}{
                    names[i],-12}{
                    rnd(convert[i, 0](nAngle)),-12}{
                    rnd(convert[i, 1](nAngle)),-12}{
                    rnd(convert[i, 2](nAngle)),-12}{
                    rnd(convert[i, 3](nAngle)),-12}"");
            }
        }
    }
 
    public static double NormalizeDeg(double angle) => Normalize(angle, 360);
    public static double NormalizeGrad(double angle) => Normalize(angle, 400);
    public static double NormalizeMil(double angle) => Normalize(angle, 6400);
    public static double NormalizeRad(double angle) => Normalize(angle, 2 * Math.PI);
 
    private static double Normalize(double angle, double N) {
        while (angle <= -N) angle += N;
        while (angle >= N) angle -= N;
        return angle;
    }
 
    public static double DegToGrad(double angle) => angle * 10 / 9;
    public static double DegToMil(double angle) => angle * 160 / 9;
    public static double DegToRad(double angle) => angle * Math.PI / 180;
 
    public static double GradToDeg(double angle) => angle * 9 / 10;
    public static double GradToMil(double angle) => angle * 16;
    public static double GradToRad(double angle) => angle * Math.PI / 200;
 
    public static double MilToDeg(double angle) => angle * 9 / 160;
    public static double MilToGrad(double angle) => angle / 16;
    public static double MilToRad(double angle) => angle * Math.PI / 3200;
 
    public static double RadToDeg(double angle) => angle * 180 / Math.PI;
    public static double RadToGrad(double angle) => angle * 200 / Math.PI;
    public static double RadToMil(double angle) => angle * 3200 / Math.PI;
}",2749,64
75625,http://rosettacode.org/wiki/Angle_difference_between_two_bearings,Angle difference between two bearings,"Finding the angle between two bearings is often confusing.[1]



Task

Find the angle which is the result of the subtraction b2 - b1, where b1 and b2 are the bearings.


Input bearings are expressed in the range   -180   to   +180   degrees.

The  result  is also expressed in the range   -180   to   +180   degrees.



Compute the angle for the following pairs:

 20 degrees (b1) and 45 degrees (b2)
 -45 and 45
 -85 and 90
 -95 and 90
 -45 and 125
 -45 and 145
 29.4803 and -88.6381
 -78.3251 and -159.036


Optional extra
 
Allow the input bearings to be any (finite) value.



Test cases

 -70099.74233810938 and 29840.67437876723
 -165313.6666297357 and 33693.9894517456
 1174.8380510598456 and -154146.66490124757
 60175.77306795546 and 42213.07192354373

",#C.23,C#,"using System;
 
namespace Angle_difference_between_two_bearings
{
	class Program
	{
		public static void Main(string[] args)
		{
			Console.WriteLine();
			Console.WriteLine(""Hello World!"");
			Console.WriteLine();
 
			// Calculate standard test cases
			Console.WriteLine(Delta_Bearing( 20M,45));
			Console.WriteLine(Delta_Bearing(-45M,45M));
			Console.WriteLine(Delta_Bearing(-85M,90M));
			Console.WriteLine(Delta_Bearing(-95M,90M));
			Console.WriteLine(Delta_Bearing(-45M,125M));
			Console.WriteLine(Delta_Bearing(-45M,145M));
			Console.WriteLine(Delta_Bearing( 29.4803M,-88.6381M));
			Console.WriteLine(Delta_Bearing(-78.3251M, -159.036M));
 
			// Calculate optional test cases
			Console.WriteLine(Delta_Bearing(-70099.74233810938M,   29840.67437876723M));
			Console.WriteLine(Delta_Bearing(-165313.6666297357M,   33693.9894517456M));
			Console.WriteLine(Delta_Bearing( 1174.8380510598456M, -154146.66490124757M));
			Console.WriteLine(Delta_Bearing( 60175.77306795546M,   42213.07192354373M));
 
			Console.WriteLine();
			Console.Write(""Press any key to continue . . . "");
			Console.ReadKey(true);
		}
 
		static decimal Delta_Bearing(decimal b1, decimal b2)
		{
			/*
			 * Optimal solution
			 *
			decimal d = 0;
 
			d = (b2-b1)%360;
 
			if(d>180)
				d -= 360;
			else if(d<-180)
				d += 360;
 
			return d;
			 *
			 * 
			 */
 
 
			//
			//
			//
			decimal d = 0;
 
			// Convert bearing to W.C.B
			if(b1<0)
				b1 += 360;
			if(b2<0)
				b2 += 360;
 
			///Calculate delta bearing
			//and
			//Convert result value to Q.B.
			d = (b2 - b1)%360;
 
			if(d>180)
				d -= 360;
			else if(d<-180)
				d += 360;
 
			return d;
 
			//
			//
			//
		}
	}
}",1683,82
75632,http://rosettacode.org/wiki/Animate_a_pendulum,Animate a pendulum,"
One good way of making an animation is by simulating a physical system and illustrating the variables in that system using a dynamically changing graphical display.

The classic such physical system is a simple gravity pendulum.



Task

Create a simple physical model of a pendulum and animate it.



",#C.23,C#," 
using System;
using System.Drawing;
using System.Windows.Forms;
 
class CSharpPendulum
{
    Form _form;
    Timer _timer;
 
    double _angle = Math.PI / 2, 
           _angleAccel, 
           _angleVelocity = 0, 
           _dt = 0.1;
 
    int _length = 50;
 
    [STAThread]
    static void Main()
    {
        var p = new CSharpPendulum();
    }
 
    public CSharpPendulum()
    {
        _form = new Form() { Text = ""Pendulum"", Width = 200, Height = 200 };
        _timer = new Timer() { Interval = 30 };
 
        _timer.Tick += delegate(object sender, EventArgs e)
        {
            int anchorX = (_form.Width / 2) - 12,
                anchorY = _form.Height / 4,
                ballX = anchorX + (int)(Math.Sin(_angle) * _length),
                ballY = anchorY + (int)(Math.Cos(_angle) * _length);
 
            _angleAccel = -9.81 / _length * Math.Sin(_angle);
            _angleVelocity += _angleAccel * _dt;
            _angle += _angleVelocity * _dt;
 
            Bitmap dblBuffer = new Bitmap(_form.Width, _form.Height);
            Graphics g = Graphics.FromImage(dblBuffer);
            Graphics f = Graphics.FromHwnd(_form.Handle);
 
            g.DrawLine(Pens.Black, new Point(anchorX, anchorY), new Point(ballX, ballY));
            g.FillEllipse(Brushes.Black, anchorX - 3, anchorY - 4, 7, 7);
            g.FillEllipse(Brushes.DarkGoldenrod, ballX - 7, ballY - 7, 14, 14);
 
            f.Clear(Color.White);
            f.DrawImage(dblBuffer, new Point(0, 0));    
        };
 
        _timer.Start();
        Application.Run(_form);
    }     
}
 ",1585,56
75645,http://rosettacode.org/wiki/Amicable_pairs,Amicable pairs,"Two integers 



N


{\displaystyle N}

 and 



M


{\displaystyle M}

 are said to be amicable pairs if 



N
≠
M


{\displaystyle N\neq M}

 and the sum of the proper divisors of 



N


{\displaystyle N}

 (




s
u
m

(

p
r
o
p
D
i
v
s

(
N
)
)


{\displaystyle \mathrm {sum} (\mathrm {propDivs} (N))}

) 



=
M


{\displaystyle =M}

 as well as 




s
u
m

(

p
r
o
p
D
i
v
s

(
M
)
)
=
N


{\displaystyle \mathrm {sum} (\mathrm {propDivs} (M))=N}

.



Example

1184 and 1210 are an amicable pair, with proper divisors:

   1, 2, 4, 8, 16, 32, 37, 74, 148, 296, 592   and 
   1, 2, 5, 10, 11, 22, 55, 110, 121, 242, 605   respectively.


Task

Calculate and show here the Amicable pairs below 20,000; (there are eight).



Related tasks
 Proper divisors
 Abundant, deficient and perfect number classifications
 Aliquot sequence classifications and its amicable classification. 

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace RosettaCode.AmicablePairs
{
    internal static class Program {
        private const int Limit = 20000;        
 
        private static void Main()
        {
            foreach (var pair in GetPairs(Limit))
            {
                Console.WriteLine(""{0} {1}"", pair.Item1, pair.Item2);
            }
        }
 
        private static IEnumerable<Tuple<int, int>> GetPairs(int max)
        {
            List<int> divsums =
                Enumerable.Range(0, max + 1).Select(i => ProperDivisors(i).Sum()).ToList();
            for(int i=1; i<divsums.Count; i++) {
                int sum = divsums[i];
                if(i < sum && sum <= divsums.Count && divsums[sum] == i) {
                    yield return new Tuple<int, int>(i, sum);
                }
            }
        }
 
        private static IEnumerable<int> ProperDivisors(int number)
        {
            return
                Enumerable.Range(1, number / 2)
                    .Where(divisor => number % divisor == 0);
        }
    }
}",1094,37
75680,http://rosettacode.org/wiki/Almkvist-Giullera_formula_for_pi,Almkvist-Giullera formula for pi,"The Almkvist-Giullera formula for calculating   1/π2   is based on the Calabi-Yau
differential equations of order 4 and 5,   which were originally used to describe certain manifolds
in string theory.



The formula is:

 1/π2 = (25/3) ∑0∞ ((6n)! / (n!6))(532n2 + 126n + 9) / 10002n+1


This formula can be used to calculate the constant   π-2,   and thus to calculate   π.

Note that, because the product of all terms but the power of 1000 can be calculated as an integer,
the terms in the series can be separated into a large integer term:

  (25) (6n)! (532n2 + 126n + 9) / (3(n!)6)      (***)
multiplied by a negative integer power of 10:

  10-(6n + 3) 


Task

 Print the integer portions (the starred formula, which is without the power of 1000 divisor) of the first 10 terms of the series.
 Use the complete formula to calculate and print π to 70 decimal digits of precision.


Reference

  Gert Almkvist and Jesús Guillera, Ramanujan-like series for 1/π2 and string theory, Experimental Mathematics, 21 (2012), page 2, formula 1.

",#C.23,C#,"using System;
using BI = System.Numerics.BigInteger;
using static System.Console;
 
class Program {
 
  static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {
    q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }
 
  static string dump(int digs, bool show = false) {
    int gb = 1, dg = ++digs + gb, z;
    BI t1 = 1, t2 = 9, t3 = 1, te, su = 0,
       t = BI.Pow(10, dg <= 60 ? 0 : dg - 60), d = -1, fn = 1;
    for (BI n = 0; n < dg; n++) {
      if (n > 0) t3 *= BI.Pow(n, 6);
      te = t1 * t2 / t3;
      if ((z = dg - 1 - (int)n * 6) > 0) te *= BI.Pow (10, z);
      else te /= BI.Pow (10, -z);
      if (show && n < 10)
        WriteLine(""{0,2} {1,62}"", n, te * 32 / 3 / t);
      su += te; if (te < 10) {
        if (show) WriteLine(""\n{0} iterations required for {1} digits "" +
        ""after the decimal point.\n"", n, --digs); break; }
      for (BI j = n * 6 + 1; j <= n * 6 + 6; j++) t1 *= j;
      t2 += 126 + 532 * (d += 2);
    }
    string s = string.Format(""{0}"", isqrt(BI.Pow(10, dg * 2 + 3) /
      su / 32 * 3 * BI.Pow((BI)10, dg + 5)));
    return s[0] + ""."" + s.Substring(1, digs); }
 
  static void Main(string[] args) {
    WriteLine(dump(70, true)); }
}",1237,33
75824,http://rosettacode.org/wiki/Algebraic_data_types,Algebraic data types,"Some languages offer direct support for algebraic data types and pattern matching on them. While this of course can always be simulated with manual tagging and conditionals, it allows for terse code which is easy to read, and can represent the algorithm directly.



Task

As an example, implement insertion in a red-black-tree.

A red-black-tree is a binary tree where each internal node has a color attribute red or black. Moreover, no red node can have a red child, and every path from the root to an empty node must contain the same number of black nodes. As a consequence, the tree is balanced, and must be re-balanced after an insertion.




Reference

Red-Black Trees in a Functional Setting
",#C.23,C#,"using System;
 
class Tree
{
    public static void Main() {
        Tree tree = Tree.E;
        for (int i = 1; i <= 16; i++) {
            tree = tree.Insert(i);
        }
        tree.Print();
    }
 
    private const bool B = false, R = true;
    public static readonly Tree E = new Tree(B, null, 0, null);
 
    private Tree(bool c, Tree? l, int v, Tree? r) => (IsRed, Left, Value, Right) = (c, l ?? this, v, r ?? this);
 
    public bool IsRed { get; private set; }
    public int Value { get; }
    public Tree Left { get; }
    public Tree Right { get; }
 
    public static implicit operator Tree((bool c, Tree l, int v, Tree r) t) => new Tree(t.c, t.l, t.v, t.r);
    public void Deconstruct(out bool c, out Tree l, out int v, out Tree r) => (c, l, v, r) = (IsRed, Left, Value, Right);
    public override string ToString() => this == E ? ""[]"" : $""[{(IsRed ? 'R' : 'B')}{Value}]"";
    public Tree Insert(int x) => Ins(x).MakeBlack();
    private Tree MakeBlack() { IsRed = false; return this; }
 
    public void Print(int indent = 0) {
        if (this != E) Right.Print(indent + 1);
        Console.WriteLine(new string(' ', indent * 4) + ToString());
        if (this != E) Left.Print(indent + 1);
    }
 
    private Tree Ins(int x) => Math.Sign(x.CompareTo(Value)) switch {
         _ when this == E => (R, E, x, E),
        -1 => new Tree(IsRed, Left.Ins(x) , Value, Right).Balance(),
         1 => new Tree(IsRed, Left , Value, Right.Ins(x)).Balance(),
         _ => this
    };
 
    private Tree Balance() => this switch {
        (B, (R, (R, var a, var x, var b), var y, var c), var z, var d) => (R, (B, a, x, b), y, (B, c, z, d)),
        (B, (R, var a, var x, (R, var b, var y, var c)), var z, var d) => (R, (B, a, x, b), y, (B, c, z, d)),
        (B, var a, var x, (R, (R, var b, var y, var c), var z, var d)) => (R, (B, a, x, b), y, (B, c, z, d)),
        (B, var a, var x, (R, var b, var y, (R, var c, var z, var d))) => (R, (B, a, x, b), y, (B, c, z, d)),
        _ => this
    };
}",2009,49
75853,http://rosettacode.org/wiki/Almost_prime,Almost prime,"A   k-Almost-prime   is a natural number   



n


{\displaystyle n}

   that is the product of   



k


{\displaystyle k}

   (possibly identical) primes.



Example

1-almost-primes,   where   



k
=
1


{\displaystyle k=1}

,   are the prime numbers themselves.

2-almost-primes,   where   



k
=
2


{\displaystyle k=2}

,   are the   semiprimes.



Task

Write a function/method/subroutine/... that generates k-almost primes and use it to create a table here of the first ten members of k-Almost primes for   



1
<=
K
<=
5


{\displaystyle 1<=K<=5}

.



Related tasks

   Semiprime
   Category:Prime Numbers

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
 
namespace AlmostPrime
{
    class Program
    {
        static void Main(string[] args)
        {
            foreach (int k in Enumerable.Range(1, 5))
            {
                KPrime kprime = new KPrime() { K = k };
                Console.WriteLine(""k = {0}: {1}"",
                    k, string.Join<int>("" "", kprime.GetFirstN(10)));
            }
        }
    }
 
    class KPrime
    {
        public int K { get; set; }
 
        public bool IsKPrime(int number)
        {
            int primes = 0;
            for (int p = 2; p * p <= number && primes < K; ++p)
            {
                while (number % p == 0 && primes < K)
                {
                    number /= p;
                    ++primes;
                }
            }
            if (number > 1)
            {
                ++primes;
            }
            return primes == K;
        }
 
        public List<int> GetFirstN(int n)
        {
            List<int> result = new List<int>();
            for (int number = 2; result.Count < n; ++number)
            {
                if (IsKPrime(number))
                {
                    result.Add(number);
                }
            }
            return result;
        }
    }
}",1299,55
75910,http://rosettacode.org/wiki/Amb,Amb,"Define and give an example of the Amb operator.

The Amb operator (short for ""ambiguous"") expresses nondeterminism. This doesn't refer to randomness (as in ""nondeterministic universe"") but is closely related to the term as it is used in automata theory (""non-deterministic finite automaton"").

The Amb operator takes a variable number of expressions (or values if that's simpler in the language) and yields a correct one which will satisfy a constraint in some future computation, thereby avoiding failure.

Problems whose solution the Amb operator naturally expresses can be approached with other tools, such as explicit nested iterations over data sets, or with pattern matching. By contrast, the Amb operator appears integrated into the language. Invocations of Amb are not wrapped in any visible loops or other search patterns; they appear to be independent.

Essentially Amb(x, y, z) splits the computation into three possible futures: a future in which the value x is yielded, a future in which the value y is yielded and a future in which the value z is yielded. The future which leads to a successful subsequent computation is chosen. The other ""parallel universes"" somehow go away. Amb called with no arguments fails.

For simplicity, one of the domain values usable with Amb may denote failure, if that is convenient. For instance, it is convenient if a Boolean false denotes failure, so that Amb(false) fails, and thus constraints can be expressed using Boolean expressions like Amb(x * y == 8) which unless x and y add to four.

A pseudo-code program which satisfies this constraint might look like:

let x = Amb(1, 2, 3)
let y = Amb(7, 6, 4, 5)
Amb(x * y = 8)
print x, y
The output is 2 4 because Amb(1, 2, 3) correctly chooses the future in which x has value 2, Amb(7, 6, 4, 5) chooses 4 and consequently Amb(x * y = 8) produces a success.

Alternatively, failure could be represented using strictly Amb():

unless x * y = 8 do Amb()
Or else Amb could take the form of two operators or functions: one for producing values and one for enforcing constraints:

let x = Ambsel(1, 2, 3)
let y = Ambsel(4, 5, 6)
Ambassert(x * y = 8)
print x, y
where Ambassert behaves like Amb() if the Boolean expression is false, otherwise it allows the future computation to take place, without yielding any value.

The task is to somehow implement Amb, and demonstrate it with a program which chooses one word from each of the following four sets of character strings to generate a four-word sentence:

""the"" ""that"" ""a""
""frog"" ""elephant"" ""thing""
""walked"" ""treaded"" ""grows""
""slowly"" ""quickly""
The constraint to be satisfied is that the last character of each word (other than the last) is the same as the first character of its successor.

The only successful sentence is ""that thing grows slowly""; other combinations do not satisfy the constraint and thus fail.

The goal of this task isn't to simply process the four lists of words with explicit, deterministic program flow such as nested iteration, to trivially demonstrate the correct output. The goal is to implement the Amb operator, or a facsimile thereof that is possible within the language limitations.
",#C.23,C#,"using System;
using System.Collections.Generic;
 
public class Amb : IDisposable
{
    List<IValueSet> streams = new List<IValueSet>();
    List<IAssertOrAction> assertsOrActions = new List<IAssertOrAction>();
    volatile bool stopped = false;
 
    public IAmbValue<T> DefineValues<T>(params T[] values)
    {
        return DefineValueSet(values);
    }
 
    public IAmbValue<T> DefineValueSet<T>(IEnumerable<T> values)
    {
        ValueSet<T> stream = new ValueSet<T>();
        stream.Enumerable = values;
        streams.Add(stream);
        return stream;
    }
 
    public Amb Assert(Func<bool> function)
    {
        assertsOrActions.Add(new AmbAssert()
        {
            Level = streams.Count,
            IsValidFunction = function
        });
        return this;
    }
 
    public Amb Perform(Action action)
    {
        assertsOrActions.Add(new AmbAction()
        {
            Level = streams.Count,
            Action = action
        });
        return this;
    }
 
    public void Stop()
    {
        stopped = true;
    }
 
    public void Dispose()
    {
        RunLevel(0, 0);
        if (!stopped)
        {
            throw new AmbException();
        }
    }
 
    void RunLevel(int level, int actionIndex)
    {
        while (actionIndex < assertsOrActions.Count && assertsOrActions[actionIndex].Level <= level)
        {
            if (!assertsOrActions[actionIndex].Invoke() || stopped)
                return;
            actionIndex++;
        }
        if (level < streams.Count)
        {
            using (IValueSetIterator iterator = streams[level].CreateIterator())
            {
                while (iterator.MoveNext())
                {
                    RunLevel(level + 1, actionIndex);
                }
            }
        }
    }
 
    interface IValueSet
    {
        IValueSetIterator CreateIterator();
    }
 
    interface IValueSetIterator : IDisposable
    {
        bool MoveNext();
    }
 
    interface IAssertOrAction
    {
        int Level { get; }
        bool Invoke();
    }
 
    class AmbAssert : IAssertOrAction
    {
        internal int Level;
        internal Func<bool> IsValidFunction;
 
        int IAssertOrAction.Level { get { return Level; } }
 
        bool IAssertOrAction.Invoke()
        {
            return IsValidFunction();
        }
    }
 
    class AmbAction : IAssertOrAction
    {
        internal int Level;
        internal Action Action;
 
        int IAssertOrAction.Level { get { return Level; } }
 
        bool IAssertOrAction.Invoke()
        {
            Action(); return true;
        }
    }
 
    class ValueSet<T> : IValueSet, IAmbValue<T>, IValueSetIterator
    {
        internal IEnumerable<T> Enumerable;
        private IEnumerator<T> enumerator;
 
        public T Value { get { return enumerator.Current; } }
 
        public IValueSetIterator CreateIterator()
        {
            enumerator = Enumerable.GetEnumerator();
            return this;
        }
 
        public bool MoveNext()
        {
            return enumerator.MoveNext();
        }
 
        public void Dispose()
        {
            enumerator.Dispose();
        }
    }
}
 
public interface IAmbValue<T>
{
    T Value { get; }
}
 
public class AmbException : Exception
{
    public AmbException() : base(""AMB is angry"") { }
}",3330,152
75956,http://rosettacode.org/wiki/Address_of_a_variable,Address of a variable,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses




Task

Demonstrate how to get the address of a variable and how to set the address of a variable.



",#C.23,C#,"unsafe
{
  int i = 5;
  void* address_of_i = &i;
}",50,5
75994,http://rosettacode.org/wiki/Active_Directory/Connect,Active Directory/Connect,"The task is to establish a connection to an Active Directory or Lightweight Directory Access Protocol server.
",#C.23,C#," 
// Requires adding a reference to System.DirectoryServices 
var objDE = new System.DirectoryServices.DirectoryEntry(""LDAP://DC=onecity,DC=corp,DC=fabrikam,DC=com"");
 ",168,4
76002,http://rosettacode.org/wiki/Add_a_variable_to_a_class_instance_at_runtime,Add a variable to a class instance at runtime,"Demonstrate how to dynamically add variables to an object (a class instance) at runtime.

This is useful when the methods/variables of an instance are based on a data file that isn't available until runtime. Hal Fulton gives an example of creating an OO CSV parser at An Exercise in Metaprogramming with Ruby. This is referred to as ""monkeypatching"" by Pythonistas and some others.
",#C.23,C#,"// ----------------------------------------------------------------------------------------------
//  
//  Program.cs - DynamicClassVariable
//  
//     Mikko Puonti, 2013
// 
// ----------------------------------------------------------------------------------------------
 
using System;
using System.Dynamic;
 
namespace DynamicClassVariable
{
    internal static class Program
    {
        #region Static Members
 
        private static void Main()
        {
            // To enable late binding, we must use dynamic keyword
            // ExpandoObject readily implements IDynamicMetaObjectProvider which allows us to do some dynamic magic 
            dynamic sampleObj = new ExpandoObject();
            // Adding a new property
            sampleObj.bar = 1;
            Console.WriteLine( ""sampleObj.bar = {0}"", sampleObj.bar );
 
            // We can also add dynamically methods and events to expando object 
            // More information: http://msdn.microsoft.com/en-us/library/system.dynamic.expandoobject.aspx
            // This sample only show very small part of dynamic language features - there is lot's more
 
            Console.WriteLine( ""< Press any key >"" );
            Console.ReadKey();
        }
 
        #endregion
    }
}",1260,37
76067,http://rosettacode.org/wiki/Anagrams,Anagrams,"When two or more words are composed of the same characters, but in a different order, they are called anagrams.

Task[edit]
Using the word list at   http://wiki.puzzlers.org/pub/wordlists/unixdict.txt,

find the sets of words that share the same characters that contain the most words in them.

Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.IO;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
 
namespace Anagram
{
    class Program
    {
        const string DICO_URL = ""http://wiki.puzzlers.org/pub/wordlists/unixdict.txt"";
 
        static void Main( string[] args )
        {
            WebRequest request = WebRequest.Create(DICO_URL);
            string[] words;
            using (StreamReader sr = new StreamReader(request.GetResponse().GetResponseStream(), true)) {
                words = Regex.Split(sr.ReadToEnd(), @""\r?\n"");
            }
            var groups = from string w in words
                         group w by string.Concat(w.OrderBy(x => x)) into c
                         group c by c.Count() into d
                         orderby d.Key descending
                         select d;
            foreach (var c in groups.First()) {
                Console.WriteLine(string.Join("" "", c));
            }
        }
    }
}",963,30
76091,http://rosettacode.org/wiki/AKS_test_for_primes,AKS test for primes,"The AKS algorithm for testing whether a number is prime is a polynomial-time algorithm based on an elementary theorem about Pascal triangles.

The theorem on which the test is based can be stated as follows:

   a number   



p


{\displaystyle p}

   is prime   if and only if   all the coefficients of the polynomial expansion of
 



(
x
−
1

)

p


−
(

x

p


−
1
)


{\displaystyle (x-1)^{p}-(x^{p}-1)}


are divisible by   



p


{\displaystyle p}

.



Example

Using   



p
=
3


{\displaystyle p=3}

:

         (x-1)^3 - (x^3 - 1)
            = (x^3 - 3x^2 + 3x - 1) - (x^3 - 1)
            = -3x^2 + 3x



And all the coefficients are divisible by 3,   so 3 is prime.





 Note:
This task is not the AKS primality test.   It is an inefficient exponential time algorithm discovered in the late 1600s and used as an introductory lemma in the AKS derivation.



Task



 Create a function/subroutine/method that given   



p


{\displaystyle p}

   generates the coefficients of the expanded polynomial representation of   



(
x
−
1

)

p




{\displaystyle (x-1)^{p}}

.
 Use the function to show here the polynomial expansions of   



(
x
−
1

)

p




{\displaystyle (x-1)^{p}}

   for   



p


{\displaystyle p}

   in the range   0   to at least   7,   inclusive.
 Use the previous function in creating another function that when given   



p


{\displaystyle p}

   returns whether   



p


{\displaystyle p}

   is prime using the theorem.
 Use your test to generate a list of all primes under   35.
 As a stretch goal,   generate all primes under   50   (needs integers larger than 31-bit).


References

 Agrawal-Kayal-Saxena (AKS) primality test (Wikipedia) 
 Fool-Proof Test for Primes - Numberphile (Video). The accuracy of this video is disputed -- at best it is an oversimplification.

",#C.23,C#," 
using System;
    public class AksTest
    {
        static long[] c = new long[100];
 
        static void Main(string[] args)
        {
        for (int n = 0; n < 10; n++) {
		coef(n);
		Console.Write(""(x-1)^"" + n + "" = "");
		show(n);
		Console.WriteLine("""");
	}	 
	   Console.Write(""Primes:"");
	  for (int n = 1; n <= 63; n++)
	     if (is_prime(n))
	       Console.Write(n + "" "");
 
	    Console.WriteLine('\n');
            Console.ReadLine();
        }
 
        static void coef(int n)
        {
            int i, j;
 
            if (n < 0 || n > 63) System.Environment.Exit(0);// gracefully deal with range issue
 
            for (c[i = 0] = 1L; i < n; c[0] = -c[0], i++)
                for (c[1 + (j = i)] = 1L; j > 0; j--)
                    c[j] = c[j - 1] - c[j];
        }
 
        static bool is_prime(int n)
        {
            int i;
 
            coef(n);
            c[0] += 1;
            c[i = n] -= 1;
 
            while (i-- != 0 && (c[i] % n) == 0) ;
 
            return i < 0;
        }
 
        static void show(int n)
	    {
		    do {
                Console.Write(""+"" + c[n] + ""x^"" + n);
		    }while (n-- != 0);
	    }
    }
 ",1169,55
76142,http://rosettacode.org/wiki/Active_object,Active object,"In object-oriented programming an object is active when its state depends on clock. Usually an active object encapsulates a task that updates the object's state. To the outer world the object looks like a normal object with methods that can be called from outside. Implementation of such methods must have a certain synchronization mechanism with the encapsulated task in order to prevent object's state corruption.

A typical instance of an active object is an animation widget. The widget state changes with the time, while as an object it has all properties of a normal widget.

The task

Implement an active integrator object. The object has an input and output. The input can be set using the method Input. The input is a function of time. The output can be queried using the method Output. The object integrates its input over the time and the result becomes the object's output. So if the input is K(t) and the output is S, the object state S is changed to S + (K(t1) + K(t0)) * (t1 - t0) / 2, i.e. it integrates K using the trapeze method. Initially K is constant 0 and S is 0.

In order to test the object:

 set its input to sin (2π f t), where the frequency f=0.5Hz. The phase is irrelevant.
 wait 2s
 set the input to constant 0
 wait 0.5s
Verify that now the object's output is approximately 0 (the sine has the period of 2s). The accuracy of the result will depend on the OS scheduler time slicing and the accuracy of the clock.
",#C.23,C#,"using System;
using System.Threading.Tasks;
 
using static System.Diagnostics.Stopwatch;
using static System.Math;
using static System.Threading.Thread;
 
class ActiveObject
{
    static double timeScale = 1.0 / Frequency;
 
    Func<double, double> func;
    Task updateTask;
    double integral;
    double value;
    long timestamp0, timestamp;
 
    public ActiveObject(Func<double, double> input)
    {
        timestamp0 = timestamp = GetTimestamp();
        func = input;
        value = func(0);
        updateTask = Integrate();
    }
 
    public void ChangeInput(Func<double, double> input)
    {
        lock (updateTask)
        {
            func = input;
        }
    }
 
    public double Value
    {
        get
        {
            lock (updateTask)
            {
                return integral;
            }
        }
    }
 
    async Task Integrate()
    {
        while (true)
        {
            await Task.Yield();
            var newTime = GetTimestamp();
            double newValue;
 
            lock (updateTask)
            {
                newValue = func((newTime - timestamp0) * timeScale);
                integral += (newValue + value) * (newTime - timestamp) * timeScale / 2;
            }
 
            timestamp = newTime;
            value = newValue;
        }
    }
}
 
class Program
{
    static Func<double, double> Sine(double frequency) =>
        t => Sin(2 * PI * frequency * t);
 
    static void Main(string[] args)
    {
        var ao = new ActiveObject(Sine(0.5));
        Sleep(TimeSpan.FromSeconds(2));
        ao.ChangeInput(t => 0);
        Sleep(TimeSpan.FromSeconds(0.5));
        Console.WriteLine(ao.Value);
    }
}",1682,78
76394,http://rosettacode.org/wiki/Accumulator_factory,Accumulator factory,"A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).



Rules

The detailed rules are at http://paulgraham.com/accgensub.html and are reproduced here for simplicity (with additions in small italic text).

Before you submit an example, make sure the function
 Takes a number n and returns a function (lets call it g), that takes a number i, and returns n incremented by the accumulation of i from every call of function g(i).
Although these exact function and parameter names need not be used
 Works for any numeric type-- i.e. can take both ints and floats and returns functions that can take both ints and floats. (It is not enough simply to convert all input to floats. An accumulator that has only seen integers must return integers.) (i.e., if the language doesn't allow for numeric polymorphism, you have to use overloading or something like that)
 Generates functions that return the sum of every number ever passed to them, not just the most recent. (This requires a piece of state to hold the accumulated value, which in turn means that pure functional languages can't be used for this task.)
 Returns a real function, meaning something that you can use wherever you could use a function you had defined in the ordinary way in the text of your program. (Follow your language's conventions here.)
 Doesn't store the accumulated value or the returned functions in a way that could cause them to be inadvertently modified by other code. (No global variables or other such things.)
 E.g. if after the example, you added the following code (in a made-up language) where the factory function is called foo:
 x = foo(1); 
x(5); 
foo(3);
print x(2.3);
 It should print 8.3. (There is no need to print the form of the accumulator function returned by foo(3); it's not part of the task at all.)


Task

Create a function that implements the described rules.



It need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a closure, providing the language supports them.

Where it is not possible to hold exactly to the constraints above, describe the deviations.



",#C.23,C#,"using System;
 
class Program
{
    static Func<dynamic, dynamic> Foo(dynamic n)
    {
        return i => n += i;
    }
 
    static void Main(string[] args)
    {
        var x = Foo(1);
        x(5);
        Foo(3);
        Console.WriteLine(x(2.3));
    }
}",261,17
76645,http://rosettacode.org/wiki/Align_columns,Align columns,"Given a text file of many lines, where fields within a line
are delineated by a single 'dollar' character, write a program
that aligns each column of fields by ensuring that words in each
column are separated by at least one space.
Further, allow for each word in a column to be either left
justified, right justified, or center justified within its column.

Use the following text to test your programs:

Given$a$text$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.


Note that:

   The example input texts lines may, or may not, have trailing dollar characters.
   All columns should share the same alignment.
   Consecutive space characters produced adjacent to the end of lines are insignificant for the purposes of the task.
   Output text will be viewed in a mono-spaced font on a plain text editor or basic terminal.
   The minimum space between columns should be computed from the text and not hard-coded.
   It is not a requirement to add separating characters between or around columns.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
class ColumnAlignerProgram
{
    delegate string Justification(string s, int width);
 
    static string[] AlignColumns(string[] lines, Justification justification)
    {
        const char Separator = '$';
        // build input table and calculate columns count
        string[][] table = new string[lines.Length][];
        int columns = 0;
        for (int i = 0; i < lines.Length; i++)
        {
            string[] row = lines[i].TrimEnd(Separator).Split(Separator);
            if (columns < row.Length) columns = row.Length;
            table[i] = row;
        }
        // create formatted table
        string[][] formattedTable = new string[table.Length][];
        for (int i = 0; i < formattedTable.Length; i++)
        {
            formattedTable[i] = new string[columns];
        }
        for (int j = 0; j < columns; j++)
        {
            // get max column width
            int columnWidth = 0;
            for (int i = 0; i < table.Length; i++)
            {
                if (j < table[i].Length && columnWidth < table[i][j].Length)
                    columnWidth = table[i][j].Length;
            }
            // justify column cells
            for (int i = 0; i < formattedTable.Length; i++)
            {
                if (j < table[i].Length)
                    formattedTable[i][j] = justification(table[i][j], columnWidth);
                else 
                    formattedTable[i][j] = new String(' ', columnWidth);
            }
        }
        // create result
        string[] result = new string[formattedTable.Length];
        for (int i = 0; i < result.Length; i++)
        {
            result[i] = String.Join("" "", formattedTable[i]);
        }
        return result;
    }
 
    static string JustifyLeft(string s, int width) { return s.PadRight(width); }
    static string JustifyRight(string s, int width) { return s.PadLeft(width); }
    static string JustifyCenter(string s, int width) 
    { 
        return s.PadLeft((width + s.Length) / 2).PadRight(width); 
    }
 
    static void Main()
    {
        string[] input = {    
            ""Given$a$text$file$of$many$lines,$where$fields$within$a$line$"",
            ""are$delineated$by$a$single$'dollar'$character,$write$a$program"",
            ""that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$"",
            ""column$are$separated$by$at$least$one$space."",
            ""Further,$allow$for$each$word$in$a$column$to$be$either$left$"",
            ""justified,$right$justified,$or$center$justified$within$its$column."",
        };
 
        foreach (string line in AlignColumns(input, JustifyCenter))
        {
            Console.WriteLine(line);
        }
    }
}",2698,74
76701,"http://rosettacode.org/wiki/Abundant,_deficient_and_perfect_number_classifications","Abundant, deficient and perfect number classifications","These define three classifications of positive integers based on their   proper divisors.

Let   P(n)   be the sum of the proper divisors of   n   where the proper divisors are all positive divisors of   n   other than   n   itself.

   if    P(n) <  n    then  n  is classed as  deficient  (OEIS A005100).
   if    P(n) == n    then  n  is classed as  perfect    (OEIS A000396).
   if    P(n) >  n    then  n  is classed as  abundant   (OEIS A005101).



Example

6   has proper divisors of   1,   2,   and   3.

1 + 2 + 3 = 6,   so   6   is classed as a perfect number.



Task

Calculate how many of the integers   1   to   20,000   (inclusive) are in each of the three classes.

Show the results here.



Related tasks

   Aliquot sequence classifications.   (The whole series from which this task is a subset.)
   Proper divisors
   Amicable pairs

",#C.23,C#,"using System;
using System.Linq;
 
public class Program
{
    public static void Main()
    {
        int abundant, deficient, perfect;
        var sw = System.Diagnostics.Stopwatch.StartNew();
        ClassifyNumbers.UsingSieve(20000, out abundant, out deficient, out perfect); sw.Stop();
        Console.WriteLine($""Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms"");
        sw.Restart();
        ClassifyNumbers.UsingOptiDivision(20000, out abundant, out deficient, out perfect);
        Console.WriteLine($""Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms"");
        sw.Restart();
        ClassifyNumbers.UsingDivision(20000, out abundant, out deficient, out perfect);
        Console.WriteLine($""Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms"");
    }
}
 
public static class ClassifyNumbers
{
    //Fastest way, but uses memory
    public static void UsingSieve(int bound, out int abundant, out int deficient, out int perfect) {
        abundant = perfect = 0;
        //For very large bounds, this array can get big.
        int[] sum = new int[bound + 1];
        for (int divisor = 1; divisor <= bound >> 1; divisor++)
            for (int i = divisor << 1; i <= bound; i += divisor)
                sum[i] += divisor;
        for (int i = 1; i <= bound; i++) {
            if (sum[i] > i) abundant++;
            else if (sum[i] == i) perfect++;
        }
        deficient = bound - abundant - perfect;
    }
 
    //Slower, optimized, but doesn't use storage
    public static void UsingOptiDivision(int bound, out int abundant, out int deficient, out int perfect) {
        abundant = perfect = 0; int sum = 0;
        for (int i = 2, d, r = 1; i <= bound; i++) {
            if ((d = r * r - i) < 0) r++;
            for (int x = 2; x < r; x++) if (i % x == 0) sum += x + i / x;
            if (d == 0) sum += r;
            switch (sum.CompareTo(i)) { case 0: perfect++; break; case 1: abundant++; break; }
            sum = 1;
        }
        deficient = bound - abundant - perfect;
    }
 
    //Much slower, doesn't use storage and is un-optimized 
    public static void UsingDivision(int bound, out int abundant, out int deficient, out int perfect) {
        abundant = perfect = 0;
        for (int i = 2; i <= bound; i++) {
            int sum = Enumerable.Range(1, (i + 1) / 2)
                .Where(div => i % div == 0).Sum();
            switch (sum.CompareTo(i)) {
                case 0: perfect++; break;
                case 1: abundant++; break;
            }
        }
        deficient = bound - abundant - perfect;
    }
}",2714,64
76975,http://rosettacode.org/wiki/Ackermann_function,Ackermann function,"The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.



The Ackermann function is usually defined as follows:







A
(
m
,
n
)
=


{



n
+
1



if 

m
=
0




A
(
m
−
1
,
1
)



if 

m
>
0

 and 

n
=
0




A
(
m
−
1
,
A
(
m
,
n
−
1
)
)



if 

m
>
0

 and 

n
>
0.








{\displaystyle A(m,n)={\begin{cases}n+1&{\mbox{if }}m=0\\A(m-1,1)&{\mbox{if }}m>0{\mbox{ and }}n=0\\A(m-1,A(m,n-1))&{\mbox{if }}m>0{\mbox{ and }}n>0.\end{cases}}}






Its arguments are never negative and it always terminates.



Task

Write a function which returns the value of 



A
(
m
,
n
)


{\displaystyle A(m,n)}

. Arbitrary precision is preferred (since the function grows so quickly), but not required.



See also

 Conway chained arrow notation for the Ackermann function.

",#C.23,C#,"using System;
class Program
{
    public static long Ackermann(long m, long n)
    {
        if(m > 0)
        {
            if (n > 0)
                return Ackermann(m - 1, Ackermann(m, n - 1));
            else if (n == 0)
                return Ackermann(m - 1, 1);
        }
        else if(m == 0)
        {
            if(n >= 0) 
                return n + 1;
        }
 
        throw new System.ArgumentOutOfRangeException();
    }
 
    static void Main()
    {
        for (long m = 0; m <= 3; ++m)
        {
            for (long n = 0; n <= 4; ++n)
            {
                Console.WriteLine(""Ackermann({0}, {1}) = {2}"", m, n, Ackermann(m, n));
            }
        }
    }
}",696,32
77449,http://rosettacode.org/wiki/Abstract_type,Abstract type,"Abstract type is a type without instances or without definition.

For example in object-oriented programming using some languages, abstract types can be partial implementations of other types, which are to be derived there-from. An abstract type may provide implementation of some operations and/or components. Abstract types without any implementation are called interfaces. In the languages that do not support multiple inheritance (Ada, Java), classes can, nonetheless, inherit from multiple interfaces. The languages with multiple inheritance (like C++) usually make no distinction between partially implementable abstract types and interfaces. Because the abstract type's implementation is incomplete,  OO languages normally prevent instantiation from them (instantiation must derived from one of their descendant classes).

The term abstract datatype also may denote a type, with an implementation provided by the programmer rather than directly by the language (a built-in or an inferred type). Here the word abstract means that the implementation is abstracted away, irrelevant for the user of the type. Such implementation can and should be hidden if the language supports separation of implementation and specification. This hides complexity while allowing the implementation to change without repercussions on the usage. The corresponding software design practice is said to follow the information hiding principle.

It is important not to confuse this abstractness (of implementation) with one of the abstract type. The latter is abstract in the sense that the set of its values is empty. In the sense of implementation abstracted away, all user-defined types are abstract.

In some languages, like for example in Objective Caml which is strongly statically typed, it is also possible to have abstract types that are not OO related and are not an abstractness too. These are pure abstract types without any definition even in the implementation and can be used for example for the type algebra, or for some consistence of the type inference. For example in this area, an abstract type can be used as a phantom type to augment another type as its parameter.

Task: show how an abstract type can be declared in the language. If the language makes a distinction between interfaces and partially implemented types illustrate both.
",#C.23,C#,"abstract class Class1
{
   public abstract void method1();
 
   public int method2()
   {
      return 0;
   }
}",112,9
77552,"http://rosettacode.org/wiki/Abbreviations,_automatic","Abbreviations, automatic","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an

easy way to add flexibility when specifying or using commands, sub─commands, options, etc.



It would make a list of words easier to maintain   (as words are added, changed, and/or deleted)   if
the minimum abbreviation length of that list could be automatically (programmatically) determined.



For this task, use the list (below) of the days-of-the-week names that are expressed in about a hundred languages   (note that there is a blank line in the list).

Sunday Monday Tuesday Wednesday Thursday Friday Saturday
Sondag Maandag Dinsdag Woensdag Donderdag Vrydag Saterdag
E_djelë E_hënë E_martë E_mërkurë E_enjte E_premte E_shtunë
Ehud Segno Maksegno Erob Hamus Arbe Kedame
Al_Ahad Al_Ithinin Al_Tholatha'a Al_Arbia'a Al_Kamis Al_Gomia'a Al_Sabit
Guiragui Yergou_shapti Yerek_shapti Tchorek_shapti Hink_shapti Ourpat Shapat
domingu llunes martes miércoles xueves vienres sábadu
Bazar_gÜnÜ Birinci_gÜn Çkinci_gÜn ÜçÜncÜ_gÜn DÖrdÜncÜ_gÜn Bes,inci_gÜn Altòncò_gÜn
Igande Astelehen Astearte Asteazken Ostegun Ostiral Larunbat
Robi_bar Shom_bar Mongal_bar Budhh_bar BRihashpati_bar Shukro_bar Shoni_bar
Nedjelja Ponedeljak Utorak Srijeda Cxetvrtak Petak Subota
Disul Dilun Dimeurzh Dimerc'her Diriaou Digwener Disadorn
nedelia ponedelnik vtornik sriada chetvartak petak sabota
sing_kei_yaht sing_kei_yat sing_kei_yee sing_kei_saam sing_kei_sie sing_kei_ng sing_kei_luk
Diumenge Dilluns Dimarts Dimecres Dijous Divendres Dissabte
Dzeenkk-eh Dzeehn_kk-ehreh Dzeehn_kk-ehreh_nah_kay_dzeeneh Tah_neesee_dzeehn_neh Deehn_ghee_dzee-neh Tl-oowey_tts-el_dehlee Dzeentt-ahzee
dy_Sul dy_Lun dy_Meurth dy_Mergher dy_You dy_Gwener dy_Sadorn
Dimanch Lendi Madi Mèkredi Jedi Vandredi Samdi
nedjelja ponedjeljak utorak srijeda cxetvrtak petak subota
nede^le ponde^lí úterÿ str^eda c^tvrtek pátek sobota
Sondee Mondee Tiisiday Walansedee TOOsedee Feraadee Satadee
s0ndag mandag tirsdag onsdag torsdag fredag l0rdag
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
Diman^co Lundo Mardo Merkredo ^Jaùdo Vendredo Sabato
pÜhapäev esmaspäev teisipäev kolmapäev neljapäev reede laupäev

Diu_prima Diu_sequima Diu_tritima Diu_quartima Diu_quintima Diu_sextima Diu_sabbata
sunnudagur mánadagur tÿsdaguy mikudagur hósdagur friggjadagur leygardagur
Yek_Sham'beh Do_Sham'beh Seh_Sham'beh Cha'har_Sham'beh Panj_Sham'beh Jom'eh Sham'beh
sunnuntai maanantai tiistai keskiviiko torsktai perjantai lauantai
dimanche lundi mardi mercredi jeudi vendredi samedi
Snein Moandei Tiisdei Woansdei Tonersdei Freed Sneon
Domingo Segunda_feira Martes Mércores Joves Venres Sábado
k'vira orshabati samshabati otkhshabati khutshabati p'arask'evi shabati
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag
Kiriaki' Defte'ra Tri'ti Teta'rti Pe'mpti Paraskebi' Sa'bato
ravivaar somvaar mangalvaar budhvaar guruvaar shukravaar shanivaar
pópule pó`akahi pó`alua pó`akolu pó`ahá pó`alima pó`aono
Yom_rishon Yom_sheni Yom_shlishi Yom_revi'i Yom_chamishi Yom_shishi Shabat
ravivara somavar mangalavar budhavara brahaspativar shukravara shanivar
vasárnap hétfö kedd szerda csütörtök péntek szombat
Sunnudagur Mánudagur ╞riδjudagur Miδvikudagar Fimmtudagur FÖstudagur Laugardagur
sundio lundio mardio merkurdio jovdio venerdio saturdio
Minggu Senin Selasa Rabu Kamis Jumat Sabtu
Dominica Lunedi Martedi Mercuridi Jovedi Venerdi Sabbato
Dé_Domhnaigh Dé_Luain Dé_Máirt Dé_Ceadaoin Dé_ardaoin Dé_hAoine Dé_Sathairn
domenica lunedí martedí mercoledí giovedí venerdí sabato
Nichiyou_bi Getzuyou_bi Kayou_bi Suiyou_bi Mokuyou_bi Kin'you_bi Doyou_bi
Il-yo-il Wol-yo-il Hwa-yo-il Su-yo-il Mok-yo-il Kum-yo-il To-yo-il
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
sve-tdien pirmdien otrdien tresvdien ceturtdien piektdien sestdien
Sekmadienis Pirmadienis Antradienis Trec^iadienis Ketvirtadienis Penktadienis S^es^tadienis
Wangu Kazooba Walumbe Mukasa Kiwanuka Nnagawonye Wamunyi
xing-_qi-_rì xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
Jedoonee Jelune Jemayrt Jecrean Jardaim Jeheiney Jesam
Jabot Manre Juje Wonje Taije Balaire Jarere
geminrongo minòmishi mártes mièrkoles misheushi bèrnashi mishábaro
Ahad Isnin Selasa Rabu Khamis Jumaat Sabtu
sφndag mandag tirsdag onsdag torsdag fredag lφrdag
lo_dimenge lo_diluns lo_dimarç lo_dimèrcres lo_dijòus lo_divendres lo_dissabte
djadomingo djaluna djamars djarason djaweps djabièrna djasabra
Niedziela Poniedzial/ek Wtorek S,roda Czwartek Pia,tek Sobota
Domingo segunda-feire terça-feire quarta-feire quinta-feire sexta-feira såbado
Domingo Lunes martes Miercoles Jueves Viernes Sabado
Duminicª Luni Mart'i Miercuri Joi Vineri Sâmbªtª
voskresenie ponedelnik vtornik sreda chetverg pyatnitsa subbota
Sunday Di-luain Di-màirt Di-ciadain Di-ardaoin Di-haoine Di-sathurne
nedjelja ponedjeljak utorak sreda cxetvrtak petak subota
Sontaha Mmantaha Labobedi Laboraro Labone Labohlano Moqebelo
Iridha- Sandhudha- Anga.haruwa-dha- Badha-dha- Brahaspa.thindha- Sikura-dha- Sena.sura-dha-
nedel^a pondelok utorok streda s^tvrtok piatok sobota
Nedelja Ponedeljek Torek Sreda Cxetrtek Petek Sobota
domingo lunes martes miércoles jueves viernes sábado
sonde mundey tude-wroko dride-wroko fode-wroko freyda Saturday
Jumapili Jumatatu Jumanne Jumatano Alhamisi Ijumaa Jumamosi
söndag måndag tisdag onsdag torsdag fredag lordag
Linggo Lunes Martes Miyerkoles Huwebes Biyernes Sabado
Lé-pài-jít Pài-it Pài-jï Pài-sañ Pài-sì Pài-gÖ. Pài-lák
wan-ar-tit wan-tjan wan-ang-kaan wan-phoet wan-pha-ru-hat-sa-boh-die wan-sook wan-sao
Tshipi Mosupologo Labobedi Laboraro Labone Labotlhano Matlhatso
Pazar Pazartesi Sali Çar,samba Per,sembe Cuma Cumartesi
nedilya ponedilok vivtorok sereda chetver pyatnytsya subota
Chu?_Nhâ.t Thú*_Hai Thú*_Ba Thú*_Tu* Thú*_Na'm Thú*_Sáu Thú*_Ba?y
dydd_Sul dyds_Llun dydd_Mawrth dyds_Mercher dydd_Iau dydd_Gwener dyds_Sadwrn
Dibeer Altine Talaata Allarba Al_xebes Aljuma Gaaw
iCawa uMvulo uLwesibini uLwesithathu uLuwesine uLwesihlanu uMgqibelo
zuntik montik dinstik mitvokh donershtik fraytik shabes
iSonto uMsombuluko uLwesibili uLwesithathu uLwesine uLwesihlanu uMgqibelo
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
Bazar_gÜnÜ Bazar_ærtæsi Çærs,ænbæ_axs,amò Çærs,ænbæ_gÜnÜ CÜmæ_axs,amò CÜmæ_gÜnÜ CÜmæ_Senbæ
Sun Moon Mars Mercury Jove Venus Saturn
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
KoseEraa GyoOraa BenEraa Kuoraa YOwaaraa FeEraa Memenaa
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Sonnabend
Domingo Luns Terza_feira Corta_feira Xoves Venres Sábado
Dies_Solis Dies_Lunae Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Sabbatum
xing-_qi-_tiàn xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
djadomingu djaluna djamars djarason djaweps djabièrnè djasabra
Killachau Atichau Quoyllurchau Illapachau Chaskachau Kuychichau Intichau

Caveat:   The list (above) most surely contains errors (or, at the least, differences) of what the actual (or true) names for the days-of-the-week.



To make this Rosetta Code task page as small as possible, if processing the complete list, read the days-of-the-week from a file (that is created from the above list).



Notes concerning the above list of words

   each line has a list of days-of-the-week for a language, separated by at least one blank
   the words on each line happen to be in order, from Sunday ──► Saturday
   most lines have words in mixed case and some have all manner of accented words and other characters
   some words were translated to the nearest character that was available to code page   437
   the characters in the words are not restricted except that they may not have imbedded blanks
   for this example, the use of an underscore (_) was used to indicate a blank in a word


Task

   The list of words   (days of the week)   needn't be verified/validated.
   Write a function to find the (numeric) minimum length abbreviation for each line that would make abbreviations unique.
   A blank line   (or a null line)   should return a null string.
   Process and show the output for at least the first five lines of the file.
   Show all output here.

Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.Collections.Generic;
 
namespace Abbreviations {
    class Program {
        static void Main(string[] args) {
            string[] lines = System.IO.File.ReadAllLines(""days_of_week.txt"");
            int i = 0;
 
            foreach (string line in lines) {
                i++;
                if (line.Length > 0) {
                    var days = line.Split();
                    if (days.Length != 7) {
                        throw new Exception(""There aren't 7 days in line "" + i);
                    }
 
                    Dictionary<string, int> temp = new Dictionary<string, int>();
                    foreach (string day in days) {
                        if (temp.ContainsKey(day)) {
                            Console.WriteLine("" ∞  {0}"", line);
                            continue;
                        }
                        temp.Add(day, 1);
                    }
 
                    int len = 1;
                    while (true) {
                        temp.Clear();
                        foreach(string day in days) {
                            string key;
                            if (len < day.Length) {
                                key = day.Substring(0, len);
                            } else {
                                key = day;
                            }
                            if (temp.ContainsKey(key)) {
                                break;
                            }
                            temp.Add(key, 1);
                        }
                        if (temp.Count == 7) {
                            Console.WriteLine(""{0,2:D}  {1}"", len, line);
                            break;
                        }
                        len++;
                    }
                }
            }
        }
    }
}",1825,52
77592,http://rosettacode.org/wiki/Abundant_odd_numbers,Abundant odd numbers,"An Abundant number is a number n for which the   sum of divisors   σ(n) > 2n,

or,   equivalently,   the   sum of proper divisors   (or aliquot sum)       s(n) > n.



E.G.

12   is abundant, it has the proper divisors     1,2,3,4 & 6     which sum to   16   ( > 12 or n);

       or alternately,   has the sigma sum of   1,2,3,4,6 & 12   which sum to   28   ( > 24 or 2n).



Abundant numbers are common, though even abundant numbers seem to be much more common than odd abundant numbers.

To make things more interesting, this task is specifically about finding   odd abundant numbers.



Task
Find and display here: at least the first 25 abundant odd numbers and either their proper divisor sum or sigma sum.
Find and display here: the one thousandth abundant odd number and either its proper divisor sum or sigma sum.
Find and display here: the first abundant odd number greater than one billion (109) and either its proper divisor sum or sigma sum.


References

   OEIS:A005231: Odd abundant numbers (odd numbers n whose sum of divisors exceeds 2n)
   American Journal of Mathematics, Vol. 35, No. 4 (Oct., 1913), pp. 413-422 - Finiteness of the Odd Perfect and Primitive Abundant Numbers with n Distinct Prime Factors (LE Dickson)

",#C.23,C#,"using static System.Console;
using System.Collections.Generic;
using System.Linq;
 
public static class AbundantOddNumbers
{
    public static void Main() {
        WriteLine(""First 25 abundant odd numbers:"");
        foreach (var x in AbundantNumbers().Take(25)) WriteLine(x.Format());
        WriteLine();
        WriteLine($""The 1000th abundant odd number: {AbundantNumbers().ElementAt(999).Format()}"");
        WriteLine();
        WriteLine($""First abundant odd number > 1b: {AbundantNumbers(1_000_000_001).First().Format()}"");
    }
 
    static IEnumerable<(int n, int sum)> AbundantNumbers(int start = 3) =>
        start.UpBy(2).Select(n => (n, sum: n.DivisorSum())).Where(x => x.sum > x.n);
 
    static int DivisorSum(this int n) => 3.UpBy(2).TakeWhile(i => i * i <= n).Where(i => n % i == 0)
        .Select(i => (a:i, b:n/i)).Sum(p => p.a == p.b ? p.a : p.a + p.b) + 1;
 
    static IEnumerable<int> UpBy(this int n, int step) {
        for (int i = n; ; i+=step) yield return i;
    }
 
    static string Format(this (int n, int sum) pair) => $""{pair.n:N0} with sum {pair.sum:N0}"";
}",1097,27
77651,http://rosettacode.org/wiki/9_billion_names_of_God_the_integer,9 billion names of God the integer,"This task is a variation of the short story by Arthur C. Clarke.

(Solvers should be aware of the consequences of completing this task.)

In detail, to specify what is meant by a   “name”:

The integer 1 has 1 name     “1”.
The integer 2 has 2 names   “1+1”,   and   “2”.
The integer 3 has 3 names   “1+1+1”,   “2+1”,   and   “3”.
The integer 4 has 5 names   “1+1+1+1”,   “2+1+1”,   “2+2”,   “3+1”,   “4”.
The integer 5 has 7 names   “1+1+1+1+1”,   “2+1+1+1”,   “2+2+1”,   “3+1+1”,   “3+2”,   “4+1”,   “5”.


Task
Display the first 25 rows of a number triangle which begins:

                                      1
                                    1   1
                                  1   1   1 
                                1   2   1   1
                              1   2   2   1   1
                            1   3   3   2   1   1

Where row   



n


{\displaystyle n}

   corresponds to integer   



n


{\displaystyle n}

,   and each column   



C


{\displaystyle C}

   in row   



m


{\displaystyle m}

   from left to right corresponds to the number of names beginning with   



C


{\displaystyle C}

.

A function   



G
(
n
)


{\displaystyle G(n)}

   should return the sum of the   



n


{\displaystyle n}

-th   row.

Demonstrate this function by displaying:   



G
(
23
)


{\displaystyle G(23)}

,   



G
(
123
)


{\displaystyle G(123)}

,   



G
(
1234
)


{\displaystyle G(1234)}

,   and   



G
(
12345
)


{\displaystyle G(12345)}

.

Optionally note that the sum of the   



n


{\displaystyle n}

-th   row   



P
(
n
)


{\displaystyle P(n)}

   is the     integer partition function.

Demonstrate this is equivalent to   



G
(
n
)


{\displaystyle G(n)}

   by displaying:   



P
(
23
)


{\displaystyle P(23)}

,   



P
(
123
)


{\displaystyle P(123)}

,   



P
(
1234
)


{\displaystyle P(1234)}

,   and   



P
(
12345
)


{\displaystyle P(12345)}

.



Extra credit
If your environment is able, plot   



P
(
n
)


{\displaystyle P(n)}

   against   



n


{\displaystyle n}

   for   



n
=
1
…
999


{\displaystyle n=1\ldots 999}

.

Related tasks
 Partition function P

",#C.23,C#,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
 
namespace NamesOfGod
{
    public class RowSummer
    {
        const int N = 100000;
        public BigInteger[] p;
 
        private void calc(int n)
            /* Translated from C */
        {
            p[n] = 0;
 
            for (int k = 1; k <= n; k++)
            {
                int d = n - k * (3 * k - 1) / 2;
                if (d < 0) break;
 
                if ((k & 1) != 0) p[n] += p[d];
                else p[n] -= p[d];
 
                d -= k;
                if (d < 0) break;
 
                if ((k & 1) != 0) p[n] += p[d];
                else p[n] -= p[d];
            }
 
        }
        public void PrintSums()
            /* translated from C */
        {
            p = new BigInteger[N + 1];
            var idx = new int[] { 23, 123, 1234, 12345, 20000, 30000, 40000, 50000, N, 0 };
            int at = 0;
 
            p[0] = 1;
 
            for (int i = 1; idx[at] > 0; i++)
            {
                calc(i);
                if (i != idx[at]) continue;
                Console.WriteLine(i + "":\t"" + p[i]);
                at++;
            }
        }
    }
 
    public class RowPrinter
        /* translated from Python */
    {
        List<List<int>> cache;
        public RowPrinter()
        {
            cache = new List<List<int>> { new List<int> { 1 } };
        }
        public List<int> cumu(int n)
        {
            for (int l = cache.Count; l < n + 1; l++)
            {
                var r = new List<int> { 0 };
                for (int x = 1; x < l + 1; x++)
                    r.Add(r.Last() + cache[l - x][Math.Min(x, l - x)]);
                cache.Add(r);
            }
            return cache[n];
        }
        public List<int> row(int n)
        {
            var r = cumu(n);
            return (from i in Enumerable.Range(0, n) select r[i + 1] - r[i]).ToList();
        }
        public void PrintRows()
        {
            var rows = Enumerable.Range(1, 25).Select(x => string.Join("" "", row(x))).ToList();
            var widest = rows.Last().Length;
            foreach (var r in rows)
                Console.WriteLine(new String(' ', (widest - r.Length) / 2) + r);
        }
    }
 
    class Program
    {
        static void Main(string[] args) 
        {
            var rpr = new RowPrinter();
            rpr.PrintRows();
            var ros = new RowSummer();
            ros.PrintSums();
            Console.ReadLine();
        }
    }
}
 ",2533,98
77764,http://rosettacode.org/wiki/4-rings_or_4-squares_puzzle,4-rings or 4-squares puzzle,"4-rings or 4-squares puzzle

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Replace       a, b, c, d, e, f,   and
  g        with the decimal
digits   LOW   ───►   HIGH

such that the sum of the letters inside of each of the four large squares add up to
the same sum.

            ╔══════════════╗      ╔══════════════╗
            ║              ║      ║              ║
            ║      a       ║      ║      e       ║
            ║              ║      ║              ║
            ║          ┌───╫──────╫───┐      ┌───╫─────────┐
            ║          │   ║      ║   │      │   ║         │
            ║          │ b ║      ║ d │      │ f ║         │
            ║          │   ║      ║   │      │   ║         │
            ║          │   ║      ║   │      │   ║         │
            ╚══════════╪═══╝      ╚═══╪══════╪═══╝         │
                       │       c      │      │      g      │
                       │              │      │             │
                       │              │      │             │
                       └──────────────┘      └─────────────┘

Show all output here.



   Show all solutions for each letter being unique with
        LOW=1     HIGH=7

   Show all solutions for each letter being unique with
        LOW=3     HIGH=9

   Show only the   number   of solutions when each letter can be non-unique
        LOW=0     HIGH=9



Related task

 Solve the no connection puzzle

",#C.23,C#,"using System;
using System.Linq;
 
namespace Four_Squares_Puzzle {
    class Program {
        static void Main(string[] args) {
            fourSquare(1, 7, true, true);
            fourSquare(3, 9, true, true);
            fourSquare(0, 9, false, false);
        }
 
        private static void fourSquare(int low, int high, bool unique, bool print) {
            int count = 0;
 
            if (print) {
                Console.WriteLine(""a b c d e f g"");
            }
            for (int a = low; a <= high; ++a) {
                for (int b = low; b <= high; ++b) {
                    if (notValid(unique, b, a)) continue;
 
                    int fp = a + b;
                    for (int c = low; c <= high; ++c) {
                        if (notValid(unique, c, b, a)) continue;
                        for (int d = low; d <= high; ++d) {
                            if (notValid(unique, d, c, b, a)) continue;
                            if (fp != b + c + d) continue;
 
                            for (int e = low; e <= high; ++e) {
                                if (notValid(unique, e, d, c, b, a)) continue;
                                for (int f = low; f <= high; ++f) {
                                    if (notValid(unique, f, e, d, c, b, a)) continue;
                                    if (fp != d + e + f) continue;
 
                                    for (int g = low; g <= high; ++g) {
                                        if (notValid(unique, g, f, e, d, c, b, a)) continue;
                                        if (fp != f + g) continue;
 
                                        ++count;
                                        if (print) {
                                            Console.WriteLine(""{0} {1} {2} {3} {4} {5} {6}"", a, b, c, d, e, f, g);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (unique) {
                Console.WriteLine(""There are {0} unique solutions in [{1}, {2}]"", count, low, high);
            }
            else {
                Console.WriteLine(""There are {0} non-unique solutions in [{1}, {2}]"", count, low, high);
            }
        }
 
        private static bool notValid(bool unique, int needle, params int[] haystack) {
            return unique && haystack.Any(p => p == needle);
        }
    }
}",2481,62
77840,http://rosettacode.org/wiki/21_game,21 game,"21 game

You are encouraged to solve this task according to the task description, using any language you may know.
21 is a two player game, the game is played by choosing
a number (1, 2, or 3) to be added to the running total.

The game is won by the player whose chosen number causes the running total
to reach exactly 21.

The running total starts at zero.
One player will be the computer.

Players alternate supplying a number to be added to the running total.



Task

Write a computer program that will:

 do the prompting (or provide a button menu), 
 check for errors and display appropriate error messages, 
 do the additions (add a chosen number to the running total), 
 display the running total, 
 provide a mechanism for the player to quit/exit/halt/stop/close the program,
 issue a notification when there is a winner, and
 determine who goes first (maybe a random or user choice, or can be specified when the game begins). 

",#C.23,C#,"// 21 Game 
 
using System;
 
namespace _21Game
{
    public class Program
    {
        private const string computerPlayer = ""Computer"";
        private const string humanPlayer = ""Player 1"";
 
        public static string SwapPlayer(string currentPlayer)
        {
            if (currentPlayer == computerPlayer)
            {
                currentPlayer = humanPlayer;
            }
            else
            {
                currentPlayer = computerPlayer;
            }
 
            return currentPlayer;
        }
 
        public static void PlayGame()
        {
            bool playAnother = true;
            int total = 0;
            int final = 21;
            int roundChoice = 0;
            string currentPlayer = RandomPLayerSelect();
            int compWins = 0;
            int humanWins = 0;
 
            while (playAnother)
            {
                Console.WriteLine($""Now playing: {currentPlayer}"");
                try
                {
                    if (currentPlayer == computerPlayer)
                    {
                       roundChoice =  CompMove(total);
                    }
                    else
                    {
                        roundChoice = int.Parse(Console.ReadLine());
                    }
 
 
                    if (roundChoice != 1 && roundChoice != 2 && roundChoice != 3)
                    {
                        throw new Exception();
                    }
 
                    total += roundChoice;
                }
                catch (Exception)
                {
                    Console.WriteLine(""Invalid choice! Choose from numbers: 1, 2, 3."");
                    continue;
                }
 
                Console.WriteLine(total);
 
                if (total == final)
                {
                    if (currentPlayer == computerPlayer)
                    {
                        compWins++;
                    }
                    if (currentPlayer == humanPlayer)
                    {
                        humanWins++;
                    }
                    Console.WriteLine($""Winner: {currentPlayer}"");
                    Console.WriteLine($""Comp wins: {compWins}. Human wins: {humanWins}"");
                    Console.WriteLine($""do you wan to play another round? y/n"");
                    var choice = Console.ReadLine();
                    if (choice == ""y"")
                    {
                        total = 0;
                    }
                    else if (choice == ""n"")
                    {
                        break;
                    }
                    else
                    {
                        Console.WriteLine(""Invalid choice! Choose from y or n"");
                        continue;
                    }
                }
 
                else if (total > 21)
                {
                    Console.WriteLine(""Not the right time to play this game :)"");
                    break;
                }
 
                currentPlayer = SwapPlayer(currentPlayer);
            }
        }
 
        public static bool CheckIfCanWin(int total)
        {
            bool result = false;
            if (total == 18)
            {
                result = true;
            }
            return result;
        }
 
        public static int CompMove(int total)
        {
            int choice = 0;
 
            if (CheckIfCanWin(total))
            {
                choice = 21 - total;
            }
            else
            {
                choice = new Random().Next(1,4);
            }
 
            return choice;
        }
 
        public static string RandomPLayerSelect()
        {
            string[] players = new string[] { computerPlayer, humanPlayer };
            var random = new Random().Next(0,2);
            return players[random];
        }
 
        public static void Main(string[] args)
        {
            // welcome message and rules
            Console.WriteLine(""Welcome to 21 game \n"");
            Console.WriteLine(@""21 is a two player game. 
The game is played by choosing a number.
1, 2, or 3 to be added a total sum. \n
The game is won by the player reaches exactly 21. \n"" );            
            Console.WriteLine(""Choose your number: (1, 2 or 3)"");
 
            PlayGame();
        }
    }
}
 
 
 ",4326,154
77850,http://rosettacode.org/wiki/ABC_problem,ABC problem,"ABC problem

You are encouraged to solve this task according to the task description, using any language you may know.
You are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).

There are twenty blocks with two letters on each block.

A complete alphabet is guaranteed amongst all sides of the blocks.

The sample collection of blocks:

 (B O)
 (X K)
 (D Q)
 (C P)
 (N A)
 (G T)
 (R E)
 (T G)
 (Q D)
 (F S)
 (J W)
 (H U)
 (V I)
 (A N)
 (O B)
 (E R)
 (F S)
 (L Y)
 (P C)
 (Z M)



Task

Write a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.



The rules are simple:

   Once a letter on a block is used that block cannot be used again
   The function should be case-insensitive
   Show the output on this page for the following 7 words in the following example


Example

    >>> can_make_word(""A"")
    True
    >>> can_make_word(""BARK"")
    True
    >>> can_make_word(""BOOK"")
    False
    >>> can_make_word(""TREAT"")
    True
    >>> can_make_word(""COMMON"")
    False
    >>> can_make_word(""SQUAD"")
    True
    >>> can_make_word(""CONFUSE"")
    True

Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#C.23,C#,"using System;
using System.IO;
// Needed for the method.
using System.Text.RegularExpressions;
using System.Collections.Generic;
 
void Main()
{
   string blocks = ""BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM"";
   List<string> words = new List<string>() {
      ""A"", ""BARK"", ""BOOK"", ""TREAT"", ""COMMON"", ""SQUAD"", ""CONFUSE""
   };
 
   foreach(var word in words)
   {
      Console.WriteLine(""{0}: {1}"", word, CheckWord(blocks, word));
   }
}
 
bool CheckWord(string blocks, string word)
{
   for(int i = 0; i < word.Length; ++i)
   {
      int length = blocks.Length;
      Regex rgx = new Regex(""([a-z]""+word[i]+""|""+word[i]+""[a-z])"", RegexOptions.IgnoreCase);
      blocks = rgx.Replace(blocks, """", 1);
      if(blocks.Length == length) return false;
   }
   return true;
}
 ",789,31
77962,http://rosettacode.org/wiki/24_game/Solve,24 game/Solve,"task

Write a program that takes four digits, either from user input or by random generation, and computes arithmetic expressions following the rules of the 24 game.

Show examples of solutions generated by the program.



Related task

   Arithmetic Evaluator

",#C.23,C#,"using System;
using System.Collections.Generic;
using static System.Linq.Enumerable;
 
public static class Solve24Game
{
    public static void Main2() {
        var testCases = new [] {
            new [] { 1,1,2,7 },
            new [] { 1,2,3,4 },
            new [] { 1,2,4,5 },
            new [] { 1,2,7,7 },
            new [] { 1,4,5,6 },
            new [] { 3,3,8,8 },
            new [] { 4,4,5,9 },
            new [] { 5,5,5,5 },
            new [] { 5,6,7,8 },
            new [] { 6,6,6,6 },
            new [] { 6,7,8,9 },
        };
        foreach (var t in testCases) Test(24, t);
        Test(100, 9,9,9,9,9,9);
 
        static void Test(int target, params int[] numbers) {
            foreach (var eq in GenerateEquations(target, numbers)) Console.WriteLine(eq);
            Console.WriteLine();
        }
    }
 
    static readonly char[] ops = { '*', '/', '+', '-' };
    public static IEnumerable<string> GenerateEquations(int target, params int[] numbers) {
        var operators = Repeat(ops, numbers.Length - 1).CartesianProduct().Select(e => e.ToArray()).ToList();
        return (
            from pattern in Patterns(numbers.Length)
            let expression = CreateExpression(pattern)
            from ops in operators
            where expression.WithOperators(ops).HasPreferredTree()
            from permutation in Permutations(numbers)
            let expr = expression.WithValues(permutation)
            where expr.Value == target && expr.HasPreferredValues()
            select $""{expr.ToString()} = {target}"")
            .Distinct()
            .DefaultIfEmpty($""Cannot make {target} with {string.Join("", "", numbers)}"");
    }
 
    ///<summary>Generates postfix expression trees where 1's represent operators and 0's represent numbers.</summary>
    static IEnumerable<int> Patterns(int length) {
        if (length == 1) yield return 0; //0
        if (length == 2) yield return 1; //001
        if (length < 3) yield break;
        //Of each tree, the first 2 bits must always be 0 and the last bit must be 1. Generate the bits in between.
        length -= 2;
        int len = length * 2 + 3;
        foreach (int permutation in BinaryPatterns(length, length * 2)) {
            (int p, int l) = ((permutation << 1) + 1, len);
            if (IsValidPattern(ref p, ref l)) yield return (permutation << 1) + 1;
        }
    }
 
    ///<summary>Generates all numbers with the given number of 1's and total length.</summary>
    static IEnumerable<int> BinaryPatterns(int ones, int length) {
        int initial = (1 << ones) - 1;
        int blockMask = (1 << length) - 1;
        for (int v = initial; v >= initial; ) {
            yield return v;
            int w = (v | (v - 1)) + 1;
            w |= (((w & -w) / (v & -v)) >> 1) - 1;
            v = w & blockMask;
        }
    }
 
    static bool IsValidPattern(ref int pattern, ref int len) {
        bool isNumber = (pattern & 1) == 0;
        pattern >>= 1;
        len--;
        if (isNumber) return true;
        IsValidPattern(ref pattern, ref len);
        IsValidPattern(ref pattern, ref len);
        return len == 0;
    }
 
    static Expr CreateExpression(int pattern) {
        return Create();
 
        Expr Create() {
            bool isNumber = (pattern & 1) == 0;
            pattern >>= 1;
            if (isNumber) return new Const(0);
            Expr right = Create();
            Expr left = Create();
            return new Binary('*', left, right);
        }
    }
 
    static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> sequences) {
        IEnumerable<IEnumerable<T>> emptyProduct = new[] { Empty<T>() };
        return sequences.Aggregate(
            emptyProduct,
            (accumulator, sequence) =>
                from acc in accumulator
                from item in sequence
                select acc.Concat(new [] { item }));
    }
 
    private static List<int> helper = new List<int>();
    public static IEnumerable<T[]> Permutations<T>(params T[] input) {
        if (input == null || input.Length == 0) yield break;
        helper.Clear();
        for (int i = 0; i < input.Length; i++) helper.Add(i);
        while (true) {
            yield return input;
            int cursor = helper.Count - 2;
            while (cursor >= 0 && helper[cursor] > helper[cursor + 1]) cursor--;
            if (cursor < 0) break;
            int i = helper.Count - 1;
            while (i > cursor && helper[i] < helper[cursor]) i--;
            (helper[cursor], helper[i]) = (helper[i], helper[cursor]);
            (input[cursor], input[i]) = (input[i], input[cursor]);
            int firstIndex = cursor + 1;
            for (int lastIndex = helper.Count - 1; lastIndex > firstIndex; ++firstIndex, --lastIndex) {
                (helper[firstIndex], helper[lastIndex]) = (helper[lastIndex], helper[firstIndex]);
                (input[firstIndex], input[lastIndex]) = (input[lastIndex], input[firstIndex]);
            }
        }
    }
 
    static Expr WithOperators(this Expr expr, char[] operators) {
        int i = 0;
        SetOperators(expr, operators, ref i);
        return expr;
 
        static void SetOperators(Expr expr, char[] operators, ref int i) {
            if (expr is Binary b) {
                b.Symbol = operators[i++];
                SetOperators(b.Right, operators, ref i);
                SetOperators(b.Left, operators, ref i);
            }
        }
    }
 
    static Expr WithValues(this Expr expr, int[] values) {
        int i = 0;
        SetValues(expr, values, ref i);
        return expr;
 
        static void SetValues(Expr expr, int[] values, ref int i) {
            if (expr is Binary b) {
                SetValues(b.Left, values, ref i);
                SetValues(b.Right, values, ref i);
            } else {
                expr.Value = values[i++];
            }
        }
    }
 
    static bool HasPreferredTree(this Expr expr) => expr switch {
        Const _ => true,
 
        // a / b * c => a * c / b
        ((_, '/' ,_), '*', _) => false,
        // c + a * b => a * b + c
        (var l, '+', (_, '*' ,_) r) when l.Depth < r.Depth => false,
        // c + a / b => a / b + c
        (var l, '+', (_, '/' ,_) r) when l.Depth < r.Depth => false,
        // a * (b + c) => (b + c) * a
        (var l, '*', (_, '+' ,_) r) when l.Depth < r.Depth => false,
        // a * (b - c) => (b - c) * a
        (var l, '*', (_, '-' ,_) r) when l.Depth < r.Depth => false,
        // (a +- b) + (c */ d) => ((c */ d) + a) +- b
        ((_, var p, _), '+', (_, var q, _)) when ""+-"".Contains(p) && ""*/"".Contains(q) => false,
        // a + (b + c) => (a + b) + c
        (var l, '+', (_, '+' ,_) r) => false,
        // a + (b - c) => (a + b) - c
        (var l, '+', (_, '-' ,_) r) => false,
        // a - (b + c) => (a - b) + c
        (_, '-', (_, '+', _)) => false,
        // a * (b * c) => (a * b) * c
        (var l, '*', (_, '*' ,_) r) => false,
        // a * (b / c) => (a * b) / c
        (var l, '*', (_, '/' ,_) r) => false,
        // a / (b / c) => (a * c) / b
        (var l, '/', (_, '/' ,_) r) => false,
        // a - (b - c) * d => (c - b) * d + a
        (_, '-', ((_, '-' ,_), '*', _)) => false,
        // a - (b - c) / d => (c - b) / d + a
        (_, '-', ((_, '-' ,_), '/', _)) => false,
        // a - (b - c) => a + c - b
        (_, '-', (_, '-', _)) => false,
        // (a - b) + c => (a + c) - b
        ((_, '-', var b), '+', var c) => false,
 
        (var l, _, var r) => l.HasPreferredTree() && r.HasPreferredTree()
    };
 
    static bool HasPreferredValues(this Expr expr) => expr switch {
        Const _ => true,
 
        // -a + b => b - a
        (var l, '+', var r) when l.Value < 0 && r.Value >= 0 => false,
        // b * a => a * b
        (var l, '*', var r) when l.Depth == r.Depth && l.Value > r.Value => false,
        // b + a => a + b
        (var l, '+', var r) when l.Depth == r.Depth && l.Value > r.Value => false,
        // (b o c) * (a o d) => (a o d) * (b o c)
        ((var a, _, _) l, '*', (var c, _, _) r) when l.Value == r.Value && l.Depth == r.Depth && a.Value < c.Value => false,
        // (b o c) + (a o d) => (a o d) + (b o c)
        ((var a, var p, _) l, '+', (var c, var q, _) r) when l.Value == r.Value && l.Depth == r.Depth && a.Value < c.Value => false,
        // (a * c) * b => (a * b) * c
        ((_, '*', var c), '*', var b) when b.Value < c.Value => false,
        // (a + c) + b => (a + b) + c
        ((_, '+', var c), '+', var b) when b.Value < c.Value => false,
        // (a - b) - c => (a - c) - b
        ((_, '-', var b), '-', var c) when b.Value < c.Value => false,
        // a / 1 => a * 1
        (_, '/', var b) when b.Value == 1 => false,
        // a * b / b => a + b - b
        ((_, '*', var b), '/', var c) when b.Value == c.Value => false,
        // a * 1 * 1 => a + 1 - 1
        ((_, '*', var b), '*', var c) when b.Value == 1 && c.Value == 1 => false,
 
        (var l, _, var r) => l.HasPreferredValues() && r.HasPreferredValues()
    };
 
    private struct Fraction : IEquatable<Fraction>, IComparable<Fraction>
    {
        public readonly int Numerator, Denominator;
 
        public Fraction(int numerator, int denominator)
            => (Numerator, Denominator) = (numerator, denominator) switch
        {
            (_, 0) => (Math.Sign(numerator), 0),
            (0, _) => (0, 1),
            (_, var d) when d < 0 => (-numerator, -denominator),
            _ => (numerator, denominator)
        };
 
        public static implicit operator Fraction(int i) => new Fraction(i, 1);
        public static Fraction operator +(Fraction a, Fraction b) =>
            new Fraction(a.Numerator * b.Denominator + a.Denominator * b.Numerator, a.Denominator * b.Denominator);
        public static Fraction operator -(Fraction a, Fraction b) =>
            new Fraction(a.Numerator * b.Denominator + a.Denominator * -b.Numerator, a.Denominator * b.Denominator);
        public static Fraction operator *(Fraction a, Fraction b) =>
            new Fraction(a.Numerator * b.Numerator, a.Denominator * b.Denominator);
        public static Fraction operator /(Fraction a, Fraction b) =>
            new Fraction(a.Numerator * b.Denominator, a.Denominator * b.Numerator);
 
        public static bool operator ==(Fraction a, Fraction b) => a.CompareTo(b) == 0;
        public static bool operator !=(Fraction a, Fraction b) => a.CompareTo(b) != 0;
        public static bool operator  <(Fraction a, Fraction b) => a.CompareTo(b)  < 0;
        public static bool operator  >(Fraction a, Fraction b) => a.CompareTo(b)  > 0;
        public static bool operator <=(Fraction a, Fraction b) => a.CompareTo(b) <= 0;
        public static bool operator >=(Fraction a, Fraction b) => a.CompareTo(b) >= 0;
 
        public bool Equals(Fraction other) => Numerator == other.Numerator && Denominator == other.Denominator;
        public override string ToString() => Denominator == 1 ? Numerator.ToString() : $""[{Numerator}/{Denominator}]"";
 
        public int CompareTo(Fraction other) => (Numerator, Denominator, other.Numerator, other.Denominator) switch {
            var (    n1, d1,     n2, d2) when n1 == n2 && d1 == d2 => 0,
                (     0,  0,      _,  _) => (-1),
                (     _,  _,      0,  0) => 1,
            var (    n1, d1,     n2, d2) when d1 == d2 => n1.CompareTo(n2),
                (var n1,  0,      _,  _) => Math.Sign(n1),
                (     _,  _, var n2,  0) => Math.Sign(n2),
            var (    n1, d1,     n2, d2) => (n1 * d2).CompareTo(n2 * d1)
        };
    }
 
    private abstract class Expr
    {
        protected Expr(char symbol) => Symbol = symbol;
        public char Symbol { get; set; }
        public abstract Fraction Value { get; set; }
        public abstract int Depth { get; }
        public abstract void Deconstruct(out Expr left, out char symbol, out Expr right);
    }
 
    private sealed class Const : Expr
    {
        public Const(Fraction value) : base('c') => Value = value;
        public override Fraction Value { get; set; }
        public override int Depth => 0;
        public override void Deconstruct(out Expr left, out char symbol, out Expr right) => (left, symbol, right) = (this, Symbol, this);
        public override string ToString() => Value.ToString();
    }
 
    private sealed class Binary : Expr
    {
        public Binary(char symbol, Expr left, Expr right) : base(symbol) => (Left, Right) = (left, right);
        public Expr Left { get; }
        public Expr Right { get; }
        public override int Depth => Math.Max(Left.Depth, Right.Depth) + 1;
        public override void Deconstruct(out Expr left, out char symbol, out Expr right) => (left, symbol, right) = (Left, Symbol, Right);
 
        public override Fraction Value {
            get => Symbol switch {
                '*' => Left.Value * Right.Value,
                '/' => Left.Value / Right.Value,
                '+' => Left.Value + Right.Value,
                '-' => Left.Value - Right.Value,
                _ => throw new InvalidOperationException() };
            set {}
        }
 
        public override string ToString() => Symbol switch {
            '*' => ToString(""+-"".Contains(Left.Symbol), ""+-"".Contains(Right.Symbol)),
            '/' => ToString(""+-"".Contains(Left.Symbol), ""*/+-"".Contains(Right.Symbol)),
            '+' => ToString(false, false),
            '-' => ToString(false, ""+-"".Contains(Right.Symbol)),
            _ => $""[{Value}]""
        };
 
        private string ToString(bool wrapLeft, bool wrapRight) =>
            $""{(wrapLeft ? $""({Left})"" : $""{Left}"")} {Symbol} {(wrapRight ? $""({Right})"" : $""{Right}"")}"";
    }
}",13741,315
78010,http://rosettacode.org/wiki/24_game,24 game,"The 24 Game tests one's mental arithmetic.



Task
Write a program that randomly chooses and displays four digits, each from 1 ──► 9 (inclusive) with repetitions allowed.

The program should prompt for the player to enter an arithmetic expression using just those, and all of those four digits, used exactly once each. The program should check then evaluate the expression.

The goal is for the player to enter an expression that (numerically) evaluates to 24.

 Only the following operators/functions are allowed: multiplication, division, addition, subtraction
 Division should use floating point or rational arithmetic, etc, to preserve remainders.
 Brackets are allowed, if using an infix expression evaluator.
 Forming multiple digit numbers from the supplied digits is disallowed. (So an answer of 12+12 when given 1, 2, 2, and 1 is wrong).
 The order of the digits when given does not have to be preserved.


Notes
 The type of expression evaluator used is not mandated. An RPN evaluator is equally acceptable for example.
 The task is not for the program to generate the expression, or test whether an expression is even possible.


Related tasks
 24 game/Solve


Reference
 The 24 Game on h2g2.

",#C.23,C#,"#include <random>
#include <iostream>
#include <stack>
#include <set>
#include <string>
#include <functional>
using namespace std;
 
class RPNParse
{
public:
  stack<double> stk;
  multiset<int> digits;
 
  void op(function<double(double,double)> f)
  {
    if(stk.size() < 2)
      throw ""Improperly written expression"";
    int b = stk.top(); stk.pop();
    int a = stk.top(); stk.pop();
    stk.push(f(a, b));
  }
 
  void parse(char c)
  {
    if(c >= '0' && c <= '9')
    {
      stk.push(c - '0');
      digits.insert(c - '0');
    }
    else if(c == '+')
      op([](double a, double b) {return a+b;});
    else if(c == '-')
      op([](double a, double b) {return a-b;});
    else if(c == '*')
      op([](double a, double b) {return a*b;});
    else if(c == '/')
      op([](double a, double b) {return a/b;});
  }
 
  void parse(string s)
  {
    for(int i = 0; i < s.size(); ++i)
      parse(s[i]);
  }
 
  double getResult()
  {
    if(stk.size() != 1)
      throw ""Improperly written expression"";
    return stk.top();
  }
};
 
int main()
{
  random_device seed;
  mt19937 engine(seed());
  uniform_int_distribution<> distribution(1, 9);
  auto rnd = bind(distribution, engine);
 
  multiset<int> digits;
  cout << ""Make 24 with the digits: "";
  for(int i = 0; i < 4; ++i)
  {
    int n = rnd();
    cout << "" "" << n;
    digits.insert(n);
  }
  cout << endl;
 
  RPNParse parser;
 
  try
  {
    string input;
    getline(cin, input);
    parser.parse(input);
 
    if(digits != parser.digits)
      cout << ""Error: Not using the given digits"" << endl;
    else
    {
      double r = parser.getResult();
      cout << ""Result: "" << r << endl;
 
      if(r > 23.999 && r < 24.001)
        cout << ""Good job!"" << endl;
      else
        cout << ""Try again."" << endl;
    }
  }
  catch(char* e)
  {
    cout << ""Error: "" << e << endl;
  }
  return 0;
}",1865,98
78039,http://rosettacode.org/wiki/100_prisoners,100 prisoners,"

The Problem

 100 prisoners are individually numbered 1 to 100
 A room having a cupboard of 100 opaque drawers numbered 1 to 100, that cannot be seen from outside.
 Cards numbered 1 to 100 are placed randomly, one to a drawer, and the drawers all closed; at the start.
 Prisoners start outside the room
 They can decide some strategy before any enter the room.
 Prisoners enter the room one by one, can open a drawer, inspect the card number in the drawer, then close the drawer.
 A prisoner can open no more than 50 drawers.
 A prisoner tries to find his own number.
 A prisoner finding his own number is then held apart from the others.
 If all 100 prisoners find their own numbers then they will all be pardoned. If any don't then all sentences stand. 


The task

 Simulate several thousand instances of the game where the prisoners randomly open drawers
 Simulate several thousand instances of the game where the prisoners use the optimal strategy mentioned in the Wikipedia article, of:
 First opening the drawer whose outside number is his prisoner number.
 If the card within has his number then he succeeds otherwise he opens the drawer with the same number as that of the revealed card. (until he opens his maximum).


Show and compare the computed probabilities of success for the two strategies, here, on this page.




References

 The unbelievable solution to the 100 prisoner puzzle standupmaths (Video).
 wp:100 prisoners problem
 100 Prisoners Escape Puzzle DataGenetics.
 Random permutation statistics#One hundred prisoners on Wikipedia.

",#C.23,C#,"using System;
using System.Linq;
 
namespace Prisoners {
    class Program {
        static bool PlayOptimal() {
            var secrets = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();
 
            for (int p = 0; p < 100; p++) {
                bool success = false;
 
                var choice = p;
                for (int i = 0; i < 50; i++) {
                    if (secrets[choice] == p) {
                        success = true;
                        break;
                    }
                    choice = secrets[choice];
                }
 
                if (!success) {
                    return false;
                }
            }
 
            return true;
        }
 
        static bool PlayRandom() {
            var secrets = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();
 
            for (int p = 0; p < 100; p++) {
                var choices = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();
 
                bool success = false;
                for (int i = 0; i < 50; i++) {
                    if (choices[i] == p) {
                        success = true;
                        break;
                    }
                }
 
                if (!success) {
                    return false;
                }
            }
 
            return true;
        }
 
        static double Exec(uint n, Func<bool> play) {
            uint success = 0;
            for (uint i = 0; i < n; i++) {
                if (play()) {
                    success++;
                }
            }
            return 100.0 * success / n;
        }
 
        static void Main() {
            const uint N = 1_000_000;
            Console.WriteLine(""# of executions: {0}"", N);
            Console.WriteLine(""Optimal play success rate: {0:0.00000000000}%"", Exec(N, PlayOptimal));
            Console.WriteLine("" Random play success rate: {0:0.00000000000}%"", Exec(N, PlayRandom));
        }
    }
}",1974,68
78105,http://rosettacode.org/wiki/A%2BB,A+B,"A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.



Task

Given two integers,   A and B.

Their sum needs to be calculated.



Input data

Two integers are written in the input stream, separated by space(s):

 



(
−
1000
≤
A
,
B
≤
+
1000
)


{\displaystyle (-1000\leq A,B\leq +1000)}




Output data

The required output is one integer:   the sum of A and B.



Example



 input  

 output  


 2 2 

 4 


 3 2 

 5 


",#C.23,C#,"using System;
using System.Linq;
 
class Program
{
    static void Main()
    {
        Console.WriteLine(Console.ReadLine().Split().Select(int.Parse).Sum());
    }
}",166,10
78194,http://rosettacode.org/wiki/2048,2048,"Task

Implement a 2D sliding block puzzle game where blocks with numbers are combined to add their values.



Rules of the game

   The rules are that on each turn the player must choose a direction   (up, down, left or right).
   All tiles move as far as possible in that direction, some move more than others. 
   Two adjacent tiles (in that direction only) with matching numbers combine into one bearing the sum of those numbers. 
   A move is valid when at least one tile can be moved,   if only by combination. 
   A new tile with the value of   2   is spawned at the end of each turn at a randomly chosen empty square   (if there is one). 
   Adding a new tile on a blank space.   Most of the time,   a new   2   is to be added,   and occasionally   (10% of the time),   a   4.
   To win,   the player must create a tile with the number   2048. 
   The player loses if no valid moves are possible.


The name comes from the popular open-source implementation of this game mechanic, 2048.



Requirements

   ""Non-greedy"" movement.   
  The tiles that were created by combining other tiles should not be combined again during the same turn (move).   
  That is to say,   that moving the tile row of:
               [2][2][2][2] 

 to the right should result in: 
               ......[4][4] 

 and not:
               .........[8] 

   ""Move direction priority"".   
  If more than one variant of combining is possible,   move direction shall indicate which combination will take effect. 
  For example, moving the tile row of:
               ...[2][2][2] 

 to the right should result in:
               ......[2][4] 

 and not:
               ......[4][2] 



   Check for valid moves.   The player shouldn't be able to skip their turn by trying a move that doesn't change the board.
   Check for a  win condition.
   Check for a lose condition.

",#C.23,C#,"using System;
 
namespace g2048_csharp
{
    internal class Tile
    {
        public Tile()
        {
            Value = 0;
            IsBlocked = false;
        }
 
        public int Value { get; set; }
        public bool IsBlocked { get; set; }
    }
 
    internal enum MoveDirection
    {
        Up,
        Down,
        Left,
        Right
    }
 
    internal class G2048
    {
        public G2048()
        {
            _isDone = false;
            _isWon = false;
            _isMoved = true;
            _score = 0;
            InitializeBoard();
        }
 
        private void InitializeBoard()
        {
            for (int y = 0; y < 4; y++)
            {
                for (int x = 0; x < 4; x++)
                {
                    _board[x, y] = new Tile();
                }
            }
        }
 
        private bool _isDone;
        private bool _isWon;
        private bool _isMoved;
        private int _score;
        private readonly Tile[,] _board = new Tile[4, 4];
        private readonly Random _rand = new Random();
 
        public void Loop()
        {
            AddTile();
            while (true)
            {
                if (_isMoved)
                {
                    AddTile();
                }
 
                DrawBoard();
                if (_isDone)
                {
                    break;
                }
 
                WaitKey();
            }
 
            string endMessage = _isWon ? ""You've made it!"" : ""Game Over!"";
            Console.WriteLine(endMessage);
        }
 
        private void DrawBoard()
        {
            Console.Clear();
            Console.WriteLine(""Score: "" + _score + ""\n"");
            for (int y = 0; y < 4; y++)
            {
                Console.WriteLine(""+------+------+------+------+"");
                Console.Write(""| "");
                for (int x = 0; x < 4; x++)
                {
                    if (_board[x, y].Value == 0)
                    {
                        const string empty = "" "";
                        Console.Write(empty.PadRight(4));
                    }
                    else
                    {
                        Console.Write(_board[x, y].Value.ToString().PadRight(4));
                    }
 
                    Console.Write("" | "");
                }
 
                Console.WriteLine();
            }
 
            Console.WriteLine(""+------+------+------+------+\n\n"");
        }
 
        private void WaitKey()
        {
            _isMoved = false;
            Console.WriteLine(""(W) Up (S) Down (A) Left (D) Right"");
            char input;
            char.TryParse(Console.ReadKey().Key.ToString(), out input);
 
            switch (input)
            {
                case 'W':
                    Move(MoveDirection.Up);
                    break;
                case 'A':
                    Move(MoveDirection.Left);
                    break;
                case 'S':
                    Move(MoveDirection.Down);
                    break;
                case 'D':
                    Move(MoveDirection.Right);
                    break;
            }
 
            for (int y = 0; y < 4; y++)
            {
                for (int x = 0; x < 4; x++)
                {
                    _board[x, y].IsBlocked = false;
                }
            }
        }
 
        private void AddTile()
        {
            for (int y = 0; y < 4; y++)
            {
                for (int x = 0; x < 4; x++)
                {
                    if (_board[x, y].Value != 0) continue;
                    int a, b;
                    do
                    {
                        a = _rand.Next(0, 4);
                        b = _rand.Next(0, 4);
                    } while (_board[a, b].Value != 0);
 
                    double r = _rand.NextDouble();
                    _board[a, b].Value = r > 0.89f ? 4 : 2;
 
                    if (CanMove())
                    {
                        return;
                    }
                }
            }
 
            _isDone = true;
        }
 
        private bool CanMove()
        {
            for (int y = 0; y < 4; y++)
            {
                for (int x = 0; x < 4; x++)
                {
                    if (_board[x, y].Value == 0)
                    {
                        return true;
                    }
                }
            }
 
            for (int y = 0; y < 4; y++)
            {
                for (int x = 0; x < 4; x++)
                {
                    if (TestAdd(x + 1, y, _board[x, y].Value)
                        || TestAdd(x - 1, y, _board[x, y].Value)
                        || TestAdd(x, y + 1, _board[x, y].Value)
                        || TestAdd(x, y - 1, _board[x, y].Value))
                    {
                        return true;
                    }
                }
            }
 
            return false;
        }
 
        private bool TestAdd(int x, int y, int value)
        {
            if (x < 0 || x > 3 || y < 0 || y > 3)
            {
                return false;
            }
 
            return _board[x, y].Value == value;
        }
 
        private void MoveVertically(int x, int y, int d)
        {
            if (_board[x, y + d].Value != 0
                && _board[x, y + d].Value == _board[x, y].Value
                && !_board[x, y].IsBlocked
                && !_board[x, y + d].IsBlocked)
            {
                _board[x, y].Value = 0;
                _board[x, y + d].Value *= 2;
                _score += _board[x, y + d].Value;
                _board[x, y + d].IsBlocked = true;
                _isMoved = true;
            }
            else if (_board[x, y + d].Value == 0
                     && _board[x, y].Value != 0)
            {
                _board[x, y + d].Value = _board[x, y].Value;
                _board[x, y].Value = 0;
                _isMoved = true;
            }
 
            if (d > 0)
            {
                if (y + d < 3)
                {
                    MoveVertically(x, y + d, 1);
                }
            }
            else
            {
                if (y + d > 0)
                {
                    MoveVertically(x, y + d, -1);
                }
            }
        }
 
        private void MoveHorizontally(int x, int y, int d)
        {
            if (_board[x + d, y].Value != 0
                && _board[x + d, y].Value == _board[x, y].Value
                && !_board[x + d, y].IsBlocked
                && !_board[x, y].IsBlocked)
            {
                _board[x, y].Value = 0;
                _board[x + d, y].Value *= 2;
                _score += _board[x + d, y].Value;
                _board[x + d, y].IsBlocked = true;
                _isMoved = true;
            }
            else if (_board[x + d, y].Value == 0
                     && _board[x, y].Value != 0)
            {
                _board[x + d, y].Value = _board[x, y].Value;
                _board[x, y].Value = 0;
                _isMoved = true;
            }
 
            if (d > 0)
            {
                if (x + d < 3)
                {
                    MoveHorizontally(x + d, y, 1);
                }
            }
            else
            {
                if (x + d > 0)
                {
                    MoveHorizontally(x + d, y, -1);
                }
            }
        }
 
        private void Move(MoveDirection direction)
        {
            switch (direction)
            {
                case MoveDirection.Up:
                    for (int x = 0; x < 4; x++)
                    {
                        int y = 1;
                        while (y < 4)
                        {
                            if (_board[x, y].Value != 0)
                            {
                                MoveVertically(x, y, -1);
                            }
 
                            y++;
                        }
                    }
 
                    break;
                case MoveDirection.Down:
                    for (int x = 0; x < 4; x++)
                    {
                        int y = 2;
                        while (y >= 0)
                        {
                            if (_board[x, y].Value != 0)
                            {
                                MoveVertically(x, y, 1);
                            }
 
                            y--;
                        }
                    }
 
                    break;
                case MoveDirection.Left:
                    for (int y = 0; y < 4; y++)
                    {
                        int x = 1;
                        while (x < 4)
                        {
                            if (_board[x, y].Value != 0)
                            {
                                MoveHorizontally(x, y, -1);
                            }
 
                            x++;
                        }
                    }
 
                    break;
                case MoveDirection.Right:
                    for (int y = 0; y < 4; y++)
                    {
                        int x = 2;
                        while (x >= 0)
                        {
                            if (_board[x, y].Value != 0)
                            {
                                MoveHorizontally(x, y, 1);
                            }
 
                            x--;
                        }
                    }
 
                    break;
            }
        }
    }
 
    internal static class Program
    {
        public static void Main(string[] args)
        {
            RunGame();
        }
 
        private static void RunGame()
        {
            G2048 game = new G2048();
            game.Loop();
 
            CheckRestart();
        }
 
        private static void CheckRestart()
        {
            Console.WriteLine(""(N) New game (P) Exit"");
            while (true)
            {
                char input;
                char.TryParse(Console.ReadKey().Key.ToString(), out input);
                switch (input)
                {
                    case 'N':
                        RunGame();
                        break;
                    case 'P':
                        return;
                    default:
                        ClearLastLine();
                        break;
                }
            }
        }
 
        private static void ClearLastLine()
        {
            Console.SetCursorPosition(0, Console.CursorTop);
            Console.Write(new string(' ', Console.BufferWidth));
            Console.SetCursorPosition(0, Console.CursorTop - 1);
        }
    }
}
 ",10701,395
78277,http://rosettacode.org/wiki/15_puzzle_game,15 puzzle game," 


Task

Implement the Fifteen Puzzle Game.



The   15-puzzle   is also known as:

   Fifteen Puzzle
   Gem Puzzle
   Boss Puzzle
   Game of Fifteen
   Mystic Square
   14-15 Puzzle
   and some others.


Related Tasks

   15 Puzzle Solver
   16 Puzzle Game

",#C.23,C#,"using System;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
 
public class FifteenPuzzle
{
    const int gridSize = 4; //Standard 15 puzzle is 4x4
    const bool evenSized = gridSize % 2 == 0;
    const int blockCount = gridSize * gridSize;
    const int last = blockCount - 1;
    const int buttonSize = 50;
    const int buttonMargin = 3; //default = 3
    const int formEdge = 9;
    static readonly Random rnd = new Random();
    static readonly Font buttonFont = new Font(""Arial"", 15.75F, FontStyle.Regular, GraphicsUnit.Point, ((byte)(0)));
    readonly Button[] buttons = new Button[blockCount];
    readonly int[] grid = new int[blockCount];
    readonly int[] positionOf = new int[blockCount];
    int moves = 0;
    DateTime start;
 
    public static void Main(string[] args)
    {
        FifteenPuzzle p = new FifteenPuzzle();
        Form f = p.BuildForm();
        Application.Run(f);
    }
 
    public FifteenPuzzle()
    {
        for (int i = 0; i < blockCount; i++) {
            grid[i] = i;
            positionOf[i] = i;
        }
    }
 
    Form BuildForm()
    {
        Button startButton = new Button {
            Font = new Font(""Arial"", 9.75F, FontStyle.Regular, GraphicsUnit.Point, ((byte)(0))),
            Size = new Size(86, 23),
            Location = new Point(formEdge,
                (buttonSize + buttonMargin * 2) * gridSize + buttonMargin + formEdge),
            Text = ""New Game"",
            UseVisualStyleBackColor = true
        };
        startButton.Click += (sender, e) => Shuffle();
 
        int size = buttonSize * gridSize + buttonMargin * gridSize * 2 + formEdge * 2;
        Form form = new Form {
            Text = ""Fifteen"",
            ClientSize = new Size(width: size, height: size + buttonMargin * 2 + startButton.Height)
        };
        form.SuspendLayout();
        for (int index = 0; index < blockCount; index++) {
            Button button = new Button {
                Font = buttonFont,
                Size = new Size(buttonSize, buttonSize),
                //Margin = new Padding(buttonMargin),
                Text = (index + 1).ToString(),
                UseVisualStyleBackColor = true
            };
            SetLocation(button, index);
            form.Controls.Add(button);
            buttons[index] = button;
            int i = index;
            button.Click += (sender, e) => ButtonClick(i);
        }
        form.Controls.Add(startButton);
        form.ResumeLayout();
        return form;
    }
 
    void ButtonClick(int i)
    {
        if (buttons[last].Visible) return;
        int target = positionOf[i];
        if (positionOf[i] / gridSize == positionOf[last] / gridSize) {
            while (positionOf[last] < target) {
                Swap(last, grid[positionOf[last] + 1]);
                moves++;
            }
            while (positionOf[last] > target) {
                Swap(last, grid[positionOf[last] - 1]);
                moves++;
            }
        } else if (positionOf[i] % gridSize == positionOf[last] % gridSize) {
            while (positionOf[last] < target) {
                Swap(last, grid[positionOf[last] + gridSize]);
                moves++;
            }
            while (positionOf[last] > target) {
                Swap(last, grid[positionOf[last] - gridSize]);
                moves++;
            }
        }
        if (Solved()) {
            TimeSpan elapsed = DateTime.Now - start;
            elapsed = TimeSpan.FromSeconds(Math.Round(elapsed.TotalSeconds, 0));
            buttons[last].Visible = true;
            MessageBox.Show($""Solved in {moves} moves. Time: {elapsed}"");
        }
    }
 
    bool Solved() => Enumerable.Range(0, blockCount - 1).All(i => positionOf[i] == i);
 
    static void SetLocation(Button button, int index)
    {
        int row = index / gridSize, column = index % gridSize;
        button.Location = new Point(
            (buttonSize + buttonMargin * 2) * column + buttonMargin + formEdge,
            (buttonSize + buttonMargin * 2) * row + buttonMargin + formEdge);
    }
 
    void Shuffle()
    {
        for (int i = 0; i < blockCount; i++) {
            int r = rnd.Next(i, blockCount);
            int g = grid[r];
            grid[r] = grid[i];
            grid[i] = g;
        }
        for (int i = 0; i < blockCount; i++) {
            positionOf[grid[i]] = i;
            SetLocation(buttons[grid[i]], i);
        }
        if (!Solvable()) Swap(0, 1); //Swap any 2 blocks
 
        buttons[last].Visible = false;
        moves = 0;
        start = DateTime.Now;
    }
 
    bool Solvable()
    {
        bool parity = true;
        for (int i = 0; i < blockCount - 2; i++) {
            for (int j = i + 1; j < blockCount - 1; j++) {
                if (positionOf[j] < positionOf[i]) parity = !parity;
            }
        }
        if (evenSized && positionOf[last] / gridSize % 2 == 0) parity = !parity;
        return parity;
    }
 
    void Swap(int a, int b)
    {
        Point location = buttons[a].Location;
        buttons[a].Location = buttons[b].Location;
        buttons[b].Location = location;
 
        int p = positionOf[a];
        positionOf[a] = positionOf[b];
        positionOf[b] = p;
 
        grid[positionOf[a]] = a;
        grid[positionOf[b]] = b;
    }
}",5301,160
78468,http://rosettacode.org/wiki/99_bottles_of_beer,99 bottles of beer,"Task

Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.



The beer song

The lyrics follow this form:


 99 bottles of beer on the wall

 99 bottles of beer

 Take one down, pass it around

 98 bottles of beer on the wall


 98 bottles of beer on the wall

 98 bottles of beer

 Take one down, pass it around

 97 bottles of beer on the wall

... and so on, until reaching   0     (zero).

Grammatical support for   1 bottle of beer   is optional.

As with any puzzle, try to do it in as creative/concise/comical a way
as possible (simple, obvious solutions allowed, too).




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




See also
 
   http://99-bottles-of-beer.net/
   Category:99_Bottles_of_Beer
   Category:Programming language families
   Wikipedia 99 bottles of beer

",#C.23,C#,"using System;
 
class Program
{
    static void Main(string[] args)
    {
        for (int i = 99; i > -1; i--)
        {
            if (i == 0)
            {
                Console.WriteLine(""No more bottles of beer on the wall, no more bottles of beer."");
                Console.WriteLine(""Go to the store and buy some more, 99 bottles of beer on the wall."");
                break;
            }
            if (i == 1)
            {
                Console.WriteLine(""1 bottle of beer on the wall, 1 bottle of beer."");
                Console.WriteLine(""Take one down and pass it around, no more bottles of beer on the wall."");
                Console.WriteLine();
            }
            else
            {
                Console.WriteLine(""{0} bottles of beer on the wall, {0} bottles of beer."", i);
                Console.WriteLine(""Take one down and pass it around, {0} bottles of beer on the wall."", i - 1);
                Console.WriteLine();
            }
        }
    }
}",992,29
