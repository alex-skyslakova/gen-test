,task_url,task_name,task_description,language_url,language_name,code,code_length,line_count
5,http://rosettacode.org/wiki/Ascending_primes,Ascending primes,"Generate and show all primes with strictly ascending decimal digits.

Aside: Try solving without peeking at existing solutions. I had a weird idea for generating
a prime sieve faster, which needless to say didn't pan out. The solution may be p(r)etty trivial
but generating them quickly is at least mildly interesting.
Tip: filtering all 7,027,260 primes below 123,456,789 probably won't kill you, but there is
at least one significantly better and much faster way, needing a mere 511 odd/prime tests.



See also
 OEIS:A052015 - Primes with distinct digits in ascending order


Related

Primes with digits in nondecreasing order (infinite series allowing duplicate digits, whereas this isn't and doesn't)
Pandigital prime (whereas this is the smallest, with gaps in the used digits being permitted)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""rcu""
    ""sort""
)
 
var ascPrimesSet = make(map[int]bool) // avoids duplicates
 
func generate(first, cand, digits int) {
    if digits == 0 {
        if rcu.IsPrime(cand) {
            ascPrimesSet[cand] = true
        }
        return
    }
    for i := first; i < 10; i++ {
        next := cand*10 + i
        generate(i+1, next, digits-1)
    }
}
 
func main() {
    for digits := 1; digits < 10; digits++ {
        generate(1, 0, digits)
    }
    le := len(ascPrimesSet)
    ascPrimes := make([]int, le)
    i := 0
    for k := range ascPrimesSet {
        ascPrimes[i] = k
        i++
    }
    sort.Ints(ascPrimes)
    fmt.Println(""There are"", le, ""ascending primes, namely:"")
    for i := 0; i < le; i++ {
        fmt.Printf(""%8d "", ascPrimes[i])
        if (i+1)%10 == 0 {
            fmt.Println()
        }
    }
}",865,43
96,http://rosettacode.org/wiki/Array_concatenation,Array concatenation,"Task

Show how to concatenate two arrays in your language.



If this is as simple as array1 + array2, so be it.



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    // Example 1:  Idiomatic in Go is use of the append function.
    // Elements must be of identical type.
    a := []int{1, 2, 3}
    b := []int{7, 12, 60} // these are technically slices, not arrays
    c := append(a, b...)
    fmt.Println(c)
 
    // Example 2:  Polymorphism.
    // interface{} is a type too, one that can reference values of any type.
    // This allows a sort of polymorphic list.
    i := []interface{}{1, 2, 3}
    j := []interface{}{""Crosby"", ""Stills"", ""Nash"", ""Young""}
    k := append(i, j...) // append will allocate as needed
    fmt.Println(k)
 
    // Example 3:  Arrays, not slices.
    // A word like ""array"" on RC often means ""whatever array means in your
    // language.""  In Go, the common role of ""array"" is usually filled by
    // Go slices, as in examples 1 and 2.  If by ""array"" you really mean
    // ""Go array,"" then you have to do a little extra work.  The best
    // technique is almost always to create slices on the arrays and then
    // use the copy function.
    l := [...]int{1, 2, 3}
    m := [...]int{7, 12, 60} // arrays have constant size set at compile time
    var n [len(l) + len(m)]int
    copy(n[:], l[:]) // [:] creates a slice that references the entire array
    copy(n[len(l):], m[:])
    fmt.Println(n)
 
}",1319,35
196,http://rosettacode.org/wiki/ASCII_art_diagram_converter,ASCII art diagram converter,"Given the RFC 1035 message diagram from Section 4.1.1 (Header section format) as a string:
http://www.ietf.org/rfc/rfc1035.txt

+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                      ID                       |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    QDCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ANCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    NSCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ARCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

Where (every column of the table is 1 bit):

ID is 16 bits
QR = Query (0) or Response (1)
Opcode = Four bits defining kind of query:
  0:    a standard query (QUERY)
  1:    an inverse query (IQUERY)
  2:    a server status request (STATUS)
  3-15: reserved for future use
AA = Authoritative Answer bit
TC = Truncation bit
RD = Recursion Desired bit
RA = Recursion Available bit
Z = Reserved
RCODE = Response code
QC = Question Count
ANC = Answer Count
AUC = Authority Count
ADC = Additional Count

Write a function, member function, class or template that accepts a similar multi-line string as input to define a data structure or something else able to decode or store a header with that specified bit structure.

If your language has macros, introspection, code generation, or powerful enough templates, then accept such string at compile-time to define the header data structure statically.

Such ""Header"" function or template should accept a table with 8, 16, 32 or 64 columns, and any number of rows. For simplicity the only allowed symbols to define the table are + - | (plus, minus, pipe), and whitespace. Lines of the input string composed just of whitespace should be ignored. Leading and trailing whitespace in the input string should be ignored, as well as before and after each table row. The box for each bit of the diagram takes four chars ""+--+"". The code should perform a little of validation of the input string, but for brevity a full validation is not required.

Bonus: perform a thoroughly validation of the input string.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math/big""
    ""strings""
)
 
type result struct {
    name  string
    size  int
    start int
    end   int
}
 
func (r result) String() string {
    return fmt.Sprintf(""%-7s   %2d    %3d   %3d"", r.name, r.size, r.start, r.end)
}
 
func validate(diagram string) []string {
    var lines []string
    for _, line := range strings.Split(diagram, ""\n"") {
        line = strings.Trim(line, "" \t"")
        if line != """" {
            lines = append(lines, line)
        }
    }
    if len(lines) == 0 {
        log.Fatal(""diagram has no non-empty lines!"")
    }
    width := len(lines[0])
    cols := (width - 1) / 3
    if cols != 8 && cols != 16 && cols != 32 && cols != 64 {
        log.Fatal(""number of columns should be 8, 16, 32 or 64"")
    }
    if len(lines)%2 == 0 {
        log.Fatal(""number of non-empty lines should be odd"")
    }
    if lines[0] != strings.Repeat(""+--"", cols)+""+"" {
        log.Fatal(""incorrect header line"")
    }
    for i, line := range lines {
        if i == 0 {
            continue
        } else if i%2 == 0 {
            if line != lines[0] {
                log.Fatal(""incorrect separator line"")
            }
        } else if len(line) != width {
            log.Fatal(""inconsistent line widths"")
        } else if line[0] != '|' || line[width-1] != '|' {
            log.Fatal(""non-separator lines must begin and end with '|'"")
        }
    }
    return lines
}
 
func decode(lines []string) []result {
    fmt.Println(""Name     Bits  Start  End"")
    fmt.Println(""=======  ====  =====  ==="")
    start := 0
    width := len(lines[0])
    var results []result
    for i, line := range lines {
        if i%2 == 0 {
            continue
        }
        line := line[1 : width-1]
        for _, name := range strings.Split(line, ""|"") {
            size := (len(name) + 1) / 3
            name = strings.TrimSpace(name)
            res := result{name, size, start, start + size - 1}
            results = append(results, res)
            fmt.Println(res)
            start += size
        }
    }
    return results
}
 
func unpack(results []result, hex string) {
    fmt.Println(""\nTest string in hex:"")
    fmt.Println(hex)
    fmt.Println(""\nTest string in binary:"")
    bin := hex2bin(hex)
    fmt.Println(bin)
    fmt.Println(""\nUnpacked:\n"")
    fmt.Println(""Name     Size  Bit pattern"")
    fmt.Println(""=======  ====  ================"")
    for _, res := range results {
        fmt.Printf(""%-7s   %2d   %s\n"", res.name, res.size, bin[res.start:res.end+1])
    }
}
 
func hex2bin(hex string) string {
    z := new(big.Int)
    z.SetString(hex, 16)
    return fmt.Sprintf(""%0*b"", 4*len(hex), z)
}
 
func main() {
    const diagram = `
        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
         |                      ID                       |
        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
        |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |
        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
        |                    QDCOUNT                    |
        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 
        |                    ANCOUNT                    |
        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
        |                    NSCOUNT                    |
        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
        |                    ARCOUNT                    |
        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    `
    lines := validate(diagram)
    fmt.Println(""Diagram after trimming whitespace and removal of blank lines:\n"")
    for _, line := range lines {
        fmt.Println(line)
    }
    fmt.Println(""\nDecoded:\n"")
    results := decode(lines)
    hex := ""78477bbf5496e12e1bf169a4"" // test string
    unpack(results, hex)
}",3811,128
316,http://rosettacode.org/wiki/Array_length,Array length,"Task

Determine the amount of elements in an array.



As an example use an array holding the strings 'apple' and 'orange'.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
	arr := [...]string{""apple"", ""orange"", ""pear""}
 
	fmt.Printf(""Length of %v is %v.\n"", arr, len(arr))
}",146,9
505,http://rosettacode.org/wiki/Arithmetic/Integer,Arithmetic/Integer,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Get two integers from the user,   and then (for those two integers), display their:

   sum 
   difference 
   product 
   integer quotient
   remainder 
   exponentiation   (if the operator exists) 


Don't include error handling.

For quotient, indicate how it rounds   (e.g. towards zero, towards negative infinity, etc.).

For remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    var a, b int
    fmt.Print(""enter two integers: "")
    fmt.Scanln(&a, &b)
    fmt.Printf(""%d + %d = %d\n"", a, b, a+b)
    fmt.Printf(""%d - %d = %d\n"", a, b, a-b)
    fmt.Printf(""%d * %d = %d\n"", a, b, a*b)
    fmt.Printf(""%d / %d = %d\n"", a, b, a/b)  // truncates towards 0
    fmt.Printf(""%d %% %d = %d\n"", a, b, a%b) // same sign as first operand
    // no exponentiation operator
}",432,15
532,http://rosettacode.org/wiki/Arithmetic_numbers,Arithmetic numbers,"Definition
A positive integer n is an arithmetic number if the average of its positive divisors is also an integer.

Clearly all odd primes p must be arithmetic numbers because their only divisors are 1 and p whose sum is even and hence their average must be an integer. However, the prime number 2 is not an arithmetic number because the average of its divisors is 1.5.

Example
30 is an arithmetic number because its 7 divisors are: [1, 2, 3, 5, 6, 10, 15, 30], their sum is 72 and average 9 which is an integer.

Task
Calculate and show here:

1. The first 100 arithmetic numbers.

2. The xth arithmetic number where x = 1,000 and x = 10,000.

3. How many of the first x arithmetic numbers are composite.

Note that, technically, the arithmetic number 1 is neither prime nor composite.

Stretch
Carry out the same exercise in 2. and 3. above for x = 100,000 and x = 1,000,000.

References
 Wikipedia: Arithmetic number
 OEIS:A003601 - Numbers n such that the average of the divisors of n is an integer



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""rcu""
    ""sort""
)
 
func main() {
    arithmetic := []int{1}
    primes := []int{}
    limit := int(1e6)
    for n := 3; len(arithmetic) < limit; n++ {
        divs := rcu.Divisors(n)
        if len(divs) == 2 {
            primes = append(primes, n)
            arithmetic = append(arithmetic, n)
        } else {
            mean := float64(rcu.SumInts(divs)) / float64(len(divs))
            if mean == math.Trunc(mean) {
                arithmetic = append(arithmetic, n)
            }
        }
    }
    fmt.Println(""The first 100 arithmetic numbers are:"")
    rcu.PrintTable(arithmetic[0:100], 10, 3, false)
 
    for _, x := range []int{1e3, 1e4, 1e5, 1e6} {
        last := arithmetic[x-1]
        lastc := rcu.Commatize(last)
        fmt.Printf(""\nThe %sth arithmetic number is: %s\n"", rcu.Commatize(x), lastc)
        pcount := sort.SearchInts(primes, last) + 1
        if !rcu.IsPrime(last) {
            pcount--
        }
        comp := x - pcount - 1 // 1 is not composite
        compc := rcu.Commatize(comp)
        fmt.Printf(""The count of such numbers <= %s which are composite is %s.\n"", lastc, compc)
    }
}",1180,41
664,http://rosettacode.org/wiki/Arithmetic-geometric_mean/Calculate_Pi,Arithmetic-geometric mean/Calculate Pi,"Almkvist Berndt 1988 begins with an investigation of why the agm is such an efficient algorithm, and proves that it converges quadratically. This is an efficient method to calculate 



π


{\displaystyle \pi }

.

With the same notations used in Arithmetic-geometric mean, we can summarize the paper by writing:





π
=



4


a
g
m

(
1
,
1

/



2



)

2




1
−

∑

n
=
1


∞



2

n
+
1


(

a

n


2


−

g

n


2


)





{\displaystyle \pi ={\frac {4\;\mathrm {agm} (1,1/{\sqrt {2}})^{2}}{1-\sum \limits _{n=1}^{\infty }2^{n+1}(a_{n}^{2}-g_{n}^{2})}}}



This allows you to make the approximation, for any large   N:





π
≈



4


a

N


2




1
−

∑

k
=
1


N



2

k
+
1


(

a

k


2


−

g

k


2


)





{\displaystyle \pi \approx {\frac {4\;a_{N}^{2}}{1-\sum \limits _{k=1}^{N}2^{k+1}(a_{k}^{2}-g_{k}^{2})}}}



The purpose of this task is to demonstrate how to use this approximation in order to compute a large number of decimals of 



π


{\displaystyle \pi }

.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    one := big.NewFloat(1)
    two := big.NewFloat(2)
    four := big.NewFloat(4)
    prec := uint(768) // say
 
    a := big.NewFloat(1).SetPrec(prec)
    g := new(big.Float).SetPrec(prec)
 
    // temporary variables
    t := new(big.Float).SetPrec(prec)
    u := new(big.Float).SetPrec(prec)
 
    g.Quo(a, t.Sqrt(two))
    sum := new(big.Float)
    pow := big.NewFloat(2)
 
    for a.Cmp(g) != 0 {
        t.Add(a, g)
        t.Quo(t, two)
        g.Sqrt(u.Mul(a, g))
        a.Set(t)
        pow.Mul(pow, two)
        t.Sub(t.Mul(a, a), u.Mul(g, g))
        sum.Add(sum, t.Mul(t, pow))
    }
 
    t.Mul(a, a)
    t.Mul(t, four)
    pi := t.Quo(t, u.Sub(one, sum))
    fmt.Println(pi)
}",758,39
715,http://rosettacode.org/wiki/Arena_storage_pool,Arena storage pool,"Dynamically allocated objects take their memory from a heap.

The memory for an object is provided by an allocator which maintains the storage pool used for the heap.

Often a call to allocator is denoted as

P := new T
where   T   is the type of an allocated object,   and   P   is a reference to the object.

The storage pool chosen by the allocator can be determined by either:

 the object type   T
 the type of pointer   P


In the former case objects can be allocated only in one storage pool.

In the latter case objects of the type can be allocated in any storage pool or on the stack.



Task

The task is to show how allocators and user-defined storage pools are supported by the language.

In particular:

 define an arena storage pool.   An arena is a pool in which objects are allocated individually, but freed by groups.
 allocate some objects (e.g., integers) in the pool.


Explain what controls the storage pool choice in the language.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""runtime""
    ""sync""
)
 
// New to Go 1.3 are sync.Pools, basically goroutine-safe free lists.
// There is overhead in the goroutine-safety and if you do not need this
// you might do better by implementing your own free list.
 
func main() {
    // Task 1:  Define a pool (of ints).  Just as the task says, a sync.Pool
    // allocates individually and can free as a group.
    p := sync.Pool{New: func() interface{} {
        fmt.Println(""pool empty"")
        return new(int)
    }}
    // Task 2: Allocate some ints.
    i := new(int)
    j := new(int)
    // Show that they're usable.
    *i = 1
    *j = 2
    fmt.Println(*i + *j) // prints 3
    // Task 2 continued:  Put allocated ints in pool p.
    // Task explanation:  Variable p has a pool as its value.  Another pool
    // could be be created and assigned to a different variable.  You choose
    // a pool simply by using the appropriate variable, p here.
    p.Put(i)
    p.Put(j)
    // Drop references to i and j.  This allows them to be garbage collected;
    // that is, freed as a group.
    i = nil
    j = nil
    // Get ints for i and j again, this time from the pool.  P.Get may reuse
    // an object allocated above as long as objects haven't been garbage
    // collected yet; otherwise p.Get will allocate a new object.
    i = p.Get().(*int)
    j = p.Get().(*int)
    *i = 4
    *j = 5
    fmt.Println(*i + *j) // prints 9
    // One more test, this time forcing a garbage collection.
    p.Put(i)
    p.Put(j)
    i = nil
    j = nil
    runtime.GC()
    i = p.Get().(*int)
    j = p.Get().(*int)
    *i = 7
    *j = 8
    fmt.Println(*i + *j) // prints 15
}",1678,56
854,http://rosettacode.org/wiki/Arithmetic-geometric_mean,Arithmetic-geometric mean,"

 This page uses content from Wikipedia. The original article was at Arithmetic-geometric mean. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Write a function to compute the arithmetic-geometric mean of two numbers.



The arithmetic-geometric mean of two numbers can be (usefully) denoted as 




a
g
m

(
a
,
g
)


{\displaystyle \mathrm {agm} (a,g)}

, and is equal to the limit of the sequence:

 




a

0


=
a
;


g

0


=
g


{\displaystyle a_{0}=a;\qquad g_{0}=g}


 




a

n
+
1


=



1
2



(

a

n


+

g

n


)
;


g

n
+
1


=



a

n



g

n




.


{\displaystyle a_{n+1}={\tfrac {1}{2}}(a_{n}+g_{n});\quad g_{n+1}={\sqrt {a_{n}g_{n}}}.}


Since the limit of 




a

n


−

g

n




{\displaystyle a_{n}-g_{n}}

 tends (rapidly) to zero with iterations, this is an efficient method.

Demonstrate the function by calculating:






a
g
m

(
1
,
1

/



2


)


{\displaystyle \mathrm {agm} (1,1/{\sqrt {2}})}




Also see

   mathworld.wolfram.com/Arithmetic-Geometric Mean

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
const ε = 1e-14
 
func agm(a, g float64) float64 {
    for math.Abs(a-g) > math.Abs(a)*ε {
        a, g = (a+g)*.5, math.Sqrt(a*g)
    }
    return a
}
 
func main() {
    fmt.Println(agm(1, 1/math.Sqrt2))
}",256,19
904,http://rosettacode.org/wiki/Arithmetic/Rational,Arithmetic/Rational,"Task

Create a reasonably complete implementation of rational arithmetic in the particular language using the idioms of the language.



Example

Define a new type called frac with binary operator ""//"" of two integers that returns a structure made up of the numerator and the denominator (as per a rational number).

Further define the appropriate rational unary operators abs and '-', with the binary operators for addition '+', subtraction '-', multiplication '×', division '/', integer division '÷', modulo division, the comparison operators (e.g. '<', '≤', '>', & '≥') and equality operators (e.g. '=' & '≠').

Define standard coercion operators for casting int to frac etc.

If space allows, define standard increment and decrement operators (e.g. '+:=' & '-:=' etc.).

Finally test the operators:
Use the new type frac to find all perfect numbers less than 219 by summing the reciprocal of the factors.



Related task

   Perfect Numbers

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/big""
)
 
func main() {
    var recip big.Rat
    max := int64(1 << 19)
    for candidate := int64(2); candidate < max; candidate++ {
        sum := big.NewRat(1, candidate)
        max2 := int64(math.Sqrt(float64(candidate)))
        for factor := int64(2); factor <= max2; factor++ {
            if candidate%factor == 0 {
                sum.Add(sum, recip.SetFrac64(1, factor))
                if f2 := candidate / factor; f2 != factor {
                    sum.Add(sum, recip.SetFrac64(1, f2))
                }
            }
        }
        if sum.Denom().Int64() == 1 {
            perfectstring := """"
            if sum.Num().Int64() == 1 {
                perfectstring = ""perfect!""
            }
            fmt.Printf(""Sum of recipr. factors of %d = %d exactly %s\n"",
                candidate, sum.Num().Int64(), perfectstring)
        }
    }
}",913,32
936,http://rosettacode.org/wiki/Archimedean_spiral,Archimedean spiral,"
The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.



An Archimedean spiral can be described by the equation:






r
=
a
+
b
θ


{\displaystyle \,r=a+b\theta }


with real numbers a and b.



Task
Draw an Archimedean spiral.



",#Go,Go,"package main
 
import (
	""image""
	""image/color""
	""image/draw""
	""image/png""
	""log""
	""math""
	""os""
)
 
func main() {
	const (
		width, height = 600, 600
		centre        = width / 2.0
		degreesIncr   = 0.1 * math.Pi / 180
		turns         = 2
		stop          = 360 * turns * 10 * degreesIncr
		fileName      = ""spiral.png""
	)
 
	img := image.NewNRGBA(image.Rect(0, 0, width, height)) // create new image
	bg := image.NewUniform(color.RGBA{255, 255, 255, 255}) // prepare white for background
	draw.Draw(img, img.Bounds(), bg, image.ZP, draw.Src)   // fill the background
	fgCol := color.RGBA{255, 0, 0, 255}                    // red plot
 
	a := 1.0
	b := 20.0
 
	for theta := 0.0; theta < stop; theta += degreesIncr {
		r := a + b*theta
		x := r * math.Cos(theta)
		y := r * math.Sin(theta)
		img.Set(int(centre+x), int(centre-y), fgCol)
	}
 
	imgFile, err := os.Create(fileName)
	if err != nil {
		log.Fatal(err)
	}
	defer imgFile.Close()
 
	if err := png.Encode(imgFile, img); err != nil {
		imgFile.Close()
		log.Fatal(err)
	}
}",1028,48
957,http://rosettacode.org/wiki/Arithmetic/Complex,Arithmetic/Complex,"A   complex number   is a number which can be written as:




a
+
b
×
i


{\displaystyle a+b\times i}


(sometimes shown as:




b
+
a
×
i


{\displaystyle b+a\times i}


where   



a


{\displaystyle a}

   and   



b


{\displaystyle b}

  are real numbers,   and   



i


{\displaystyle i}

   is   √ -1 



Typically, complex numbers are represented as a pair of real numbers called the ""imaginary part"" and ""real part"",   where the imaginary part is the number to be multiplied by 



i


{\displaystyle i}

.



Task

 Show addition, multiplication, negation, and inversion of complex numbers in separate functions. (Subtraction and division operations can be made with pairs of these operations.) 
 Print the results for each operation tested.
 Optional: Show complex conjugation.


By definition, the   complex conjugate   of




a
+
b
i


{\displaystyle a+bi}


is




a
−
b
i


{\displaystyle a-bi}





Some languages have complex number libraries available.   If your language does, show the operations.   If your language does not, also show the definition of this type.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/cmplx""
)
 
func main() {
    a := 1 + 1i
    b := 3.14159 + 1.25i
    fmt.Println(""a:      "", a)
    fmt.Println(""b:      "", b)
    fmt.Println(""a + b:  "", a+b)
    fmt.Println(""a * b:  "", a*b)
    fmt.Println(""-a:     "", -a)
    fmt.Println(""1 / a:  "", 1/a)
    fmt.Println(""a̅:      "", cmplx.Conj(a))
}",348,18
961,http://rosettacode.org/wiki/Arithmetic_evaluation,Arithmetic evaluation,"Create a program which parses and evaluates arithmetic expressions.

Requirements

 An abstract-syntax tree (AST) for the expression must be created from parsing the input. 
 The AST must be used in evaluation, also, so the input may not be directly evaluated (e.g. by calling eval or a similar language feature.) 
 The expression will be a string or list of symbols like ""(1+3)*7"". 
 The four symbols + - * / must be supported as binary operators with conventional precedence rules. 
 Precedence-control parentheses must also be supported.


Note

For those who don't remember, mathematical precedence is as follows:

 Parentheses
 Multiplication/Division (left to right)
 Addition/Subtraction (left to right)


C.f
 
 24 game Player.
 Parsing/RPN calculator algorithm.
 Parsing/RPN to infix conversion.

",#Go,Go,"enum Op {
    ADD('+', 2),
    SUBTRACT('-', 2),
    MULTIPLY('*', 1),
    DIVIDE('/', 1);
 
    static {
        ADD.operation = { a, b -> a + b }
        SUBTRACT.operation = { a, b -> a - b }
        MULTIPLY.operation = { a, b -> a * b }
        DIVIDE.operation = { a, b -> a / b }
    }
 
    final String symbol
    final int precedence
    Closure operation
 
    private Op(String symbol, int precedence) {
        this.symbol = symbol
        this.precedence = precedence
    }
 
    String toString() { symbol }
 
    static Op fromSymbol(String symbol) {
        Op.values().find { it.symbol == symbol }
    }
}
 
interface Expression {
    Number evaluate();
}
 
class Constant implements Expression {
    Number value
 
    Constant (Number value) { this.value = value }
 
    Constant (String str) {
        try { this.value = str as BigInteger }
        catch (e) { this.value = str as BigDecimal }
    }
 
    Number evaluate() { value }
 
    String toString() { ""${value}"" }
}
 
class Term implements Expression {
    Op op
    Expression left, right
 
    Number evaluate() { op.operation(left.evaluate(), right.evaluate()) }
 
    String toString() { ""(${op} ${left} ${right})"" }
}
 
void fail(String msg, Closure cond = {true}) {
    if (cond()) throw new IllegalArgumentException(""Cannot parse expression: ${msg}"")
}
 
Expression parse(String expr) {
    def tokens = tokenize(expr)
    def elements = groupByParens(tokens, 0)
    parse(elements)
}
 
List tokenize(String expr) {
    def tokens = []
    def constStr = """"
    def captureConstant = { i ->
        if (constStr) {
            try { tokens << new Constant(constStr) }
            catch (NumberFormatException e) { fail ""Invalid constant '${constStr}' near position ${i}"" }
            constStr = ''
        }
    }
    for(def i = 0; i<expr.size(); i++) {
        def c = expr[i]
        def constSign = c in ['+','-'] && constStr.empty && (tokens.empty || tokens[-1] != ')') 
        def isConstChar = { it in ['.'] + ('0'..'9') || constSign }
        if (c in ([')'] + Op.values()*.symbol) && !constSign) { captureConstant(i) }
        switch (c) {
            case ~/\s/:               break
            case isConstChar:         constStr += c; break
            case Op.values()*.symbol: tokens << Op.fromSymbol(c); break
            case ['(',')']:           tokens << c; break
            default:                  fail ""Invalid character '${c}' at position ${i+1}""
        }
    }
    captureConstant(expr.size())
    tokens
}
 
List groupByParens(List tokens, int depth) {
    def deepness = depth
    def tokenGroups = []
    for (def i = 0; i < tokens.size(); i++) {
        def token = tokens[i]
        switch (token) {
            case '(':
                fail(""'(' too close to end of expression"") { i+2 > tokens.size() }
                def subGroup = groupByParens(tokens[i+1..-1], depth+1)
                tokenGroups << subGroup[0..-2]
                i += subGroup[-1] + 1
                break
            case ')':
                fail(""Unbalanced parens, found extra ')'"") { deepness == 0 }
                tokenGroups << i
                return tokenGroups
            default:
                tokenGroups << token
        }
    }
    fail(""Unbalanced parens, unclosed groupings at end of expression"") { deepness != 0 }
    def n = tokenGroups.size()
    fail(""The operand/operator sequence is wrong"") { n%2 == 0 }
    (0..<n).each {
        def i = it
        fail(""The operand/operator sequence is wrong"") { (i%2 == 0) == (tokenGroups[i] instanceof Op) }
    }
    tokenGroups
}
 
Expression parse(List elements) {
    while (elements.size() > 1) {
        def n = elements.size()
        fail (""The operand/operator sequence is wrong"") { n%2 == 0 }
        def groupLoc = (0..<n).find { i -> elements[i] instanceof List }
        if (groupLoc != null) {
            elements[groupLoc] = parse(elements[groupLoc])
            continue
        }
        def opLoc = (0..<n).find { i -> elements[i] instanceof Op && elements[i].precedence == 1 } \
                        ?: (0..<n).find { i -> elements[i] instanceof Op && elements[i].precedence == 2 }
        if (opLoc != null) {
            fail (""Operator out of sequence"") { opLoc%2 == 0 }
            def term = new Term(left:elements[opLoc-1], op:elements[opLoc], right:elements[opLoc+1])
            elements[(opLoc-1)..(opLoc+1)] = [term]
            continue
        }
    }
    return elements[0] instanceof List ? parse(elements[0]) : elements[0]
}",4523,144
1212,http://rosettacode.org/wiki/Zhang-Suen_thinning_algorithm,Zhang-Suen thinning algorithm,"This is an algorithm used to thin a black and white i.e. one bit per pixel images.

For example, with an input image of:

                                                           
 #################                   #############         
 ##################               ################         
 ###################            ##################         
 ########     #######          ###################         
   ######     #######         #######       ######         
   ######     #######        #######                       
   #################         #######                       
   ################          #######                       
   #################         #######                       
   ######     #######        #######                       
   ######     #######        #######                       
   ######     #######         #######       ######         
 ########     #######          ###################         
 ########     ####### ######    ################## ######  
 ########     ####### ######      ################ ######  
 ########     ####### ######         ############# ######  
                                                           
It produces the thinned output:

                                                           
                                                           
    # ##########                       #######             
     ##        #                   ####       #            
     #          #                 ##                       
     #          #                #                         
     #          #                #                         
     #          #                #                         
     ############               #                          
     #          #               #                          
     #          #                #                         
     #          #                #                         
     #          #                #                         
     #                            ##                       
     #                             ############            
                       ###                          ###    
                                                           
                                                           
Algorithm

Assume black pixels are one and white pixels zero, and that the input image is a rectangular N by M array of ones and zeroes.

The algorithm operates on all black pixels P1 that can have eight neighbours.

The neighbours are, in order, arranged as:


   P9      P2      P3   
   P8      P1      P4   
   P7      P6      P5   



Obviously the boundary pixels of the image cannot have the full eight neighbours.

 Define 



A
(
P
1
)


{\displaystyle A(P1)}

 = the number of transitions from white to black, (0 -> 1) in the sequence P2,P3,P4,P5,P6,P7,P8,P9,P2. (Note the extra P2 at the end - it is circular).
 Define 



B
(
P
1
)


{\displaystyle B(P1)}

 = The number of black pixel neighbours of P1. ( = sum(P2 .. P9) )


Step 1

All pixels are tested and pixels satisfying all the following conditions (simultaneously) are just noted at this stage.

 (0) The pixel is black and has eight neighbours
 (1) 



2
<=
B
(
P
1
)
<=
6


{\displaystyle 2<=B(P1)<=6}


 (2) A(P1) = 1
 (3) At least one of P2 and P4 and P6 is white
 (4) At least one of P4 and P6 and P8 is white
After iterating over the image and collecting all the pixels satisfying all step 1 conditions, all these condition satisfying pixels are set to white.



Step 2

All pixels are again tested and pixels satisfying all the following conditions are just noted at this stage.

 (0) The pixel is black and has eight neighbours
 (1) 



2
<=
B
(
P
1
)
<=
6


{\displaystyle 2<=B(P1)<=6}


 (2) A(P1) = 1
 (3) At least one of P2 and P4 and P8 is white
 (4) At least one of P2 and P6 and P8 is white
After iterating over the image and collecting all the pixels satisfying all step 2 conditions, all these condition satisfying pixels are again set to white.



Iteration

If any pixels were set in this round of either step 1 or step 2 then all steps are repeated until no image pixels are so changed.



Task

 Write a routine to perform Zhang-Suen thinning on an image matrix of ones and zeroes.
 Use the routine to thin the following image and show the output here on this page as either a matrix of ones and zeroes, an image, or an ASCII-art image of space/non-space characters. 
          00000000000000000000000000000000
          01111111110000000111111110000000
          01110001111000001111001111000000
          01110000111000001110000111000000
          01110001111000001110000000000000
          01111111110000001110000000000000
          01110111100000001110000111000000
          01110011110011101111001111011100
          01110001111011100111111110011100
          00000000000000000000000000000000



Reference

 Zhang-Suen Thinning Algorithm, Java Implementation by Nayef Reza.
 ""Character Recognition Systems: A Guide for Students and Practitioners"" By Mohamed Cheriet, Nawwaf Kharma, Cheng-Lin Liu, Ching Suen

",#Go,Go,"package main
 
import (
    ""bytes""
    ""fmt""
    ""strings""
)
 
var in = `
00000000000000000000000000000000
01111111110000000111111110000000
01110001111000001111001111000000
01110000111000001110000111000000
01110001111000001110000000000000
01111111110000001110000000000000
01110111100000001110000111000000
01110011110011101111001111011100
01110001111011100111111110011100
00000000000000000000000000000000`
 
func main() {
    b := wbFromString(in, '1')
    b.zhangSuen()
    fmt.Println(b)
}
 
const (
    white = 0
    black = 1
)
 
type wbArray [][]byte // elements are white or black.
 
// parameter blk is character to read as black.  otherwise kinda rigid,
// expects ascii, leading newline, no trailing newline,
// takes color from low bit of character.
func wbFromString(s string, blk byte) wbArray {
    lines := strings.Split(s, ""\n"")[1:]
    b := make(wbArray, len(lines))
    for i, sl := range lines {
        bl := make([]byte, len(sl))
        for j := 0; j < len(sl); j++ {
            bl[j] = sl[j] & 1
        }
        b[i] = bl
    }
    return b
}
 
// rigid again, hard coded to output space for white, # for black,
// no leading or trailing newline.
var sym = [2]byte{
    white: ' ',
    black: '#',
}
 
func (b wbArray) String() string {
    b2 := bytes.Join(b, []byte{'\n'})
    for i, b1 := range b2 {
        if b1 > 1 {
            continue
        }
        b2[i] = sym[b1]
    }
    return string(b2)
}
 
// neighbor offsets
var nb = [...][2]int{
    2: {-1, 0}, // p2 offsets
    3: {-1, 1}, // ...
    4: {0, 1},
    5: {1, 1},
    6: {1, 0},
    7: {1, -1},
    8: {0, -1},
    9: {-1, -1}, // p9 offsets
}
 
func (b wbArray) reset(en []int) (rs bool) {
    var r, c int
    var p [10]byte
 
    readP := func() {
        for nx := 1; nx <= 9; nx++ {
            n := nb[nx]
            p[nx] = b[r+n[0]][c+n[1]]
        }
    }
 
    shiftRead := func() {
        n := nb[3]
        p[9], p[2], p[3] = p[2], p[3], b[r+n[0]][c+n[1]]
        n = nb[4]
        p[8], p[1], p[4] = p[1], p[4], b[r+n[0]][c+n[1]]
        n = nb[5]
        p[7], p[6], p[5] = p[6], p[5], b[r+n[0]][c+n[1]]
    }
 
    // returns ""A"", count of white->black transitions in circuit of neighbors
    // of an interior pixel b[r][c]
    countA := func() (ct byte) {
        bit := p[9]
        for nx := 2; nx <= 9; nx++ {
            last := bit
            bit = p[nx]
            if last == white {
                ct += bit
            }
        }
        return ct
    }
 
    // returns ""B"", count of black pixels neighboring interior pixel b[r][c].
    countB := func() (ct byte) {
        for nx := 2; nx <= 9; nx++ {
            ct += p[nx]
        }
        return ct
    }
 
    lastRow := len(b) - 1
    lastCol := len(b[0]) - 1
 
    mark := make([][]bool, lastRow)
    for r = range mark {
        mark[r] = make([]bool, lastCol)
    }
 
    for r = 1; r < lastRow; r++ {
        c = 1
        readP()
        for { // column loop
            m := false
            // test for failure of any of the five conditions,
            if !(p[1] == black) {
                goto markDone
            }
            if b1 := countB(); !(2 <= b1 && b1 <= 6) {
                goto markDone
            }
            if !(countA() == 1) {
                goto markDone
            }
            {
                e1, e2 := p[en[1]], p[en[2]]
                if !(p[en[0]]&e1&e2 == 0) {
                    goto markDone
                }
                if !(e1&e2&p[en[3]] == 0) {
                    goto markDone
                }
            }
            // no conditions failed, mark this pixel for reset
            m = true
            rs = true // and mark that image changes
        markDone:
            mark[r][c] = m
            c++
            if c == lastCol {
                break
            }
            shiftRead()
        }
    }
    if rs {
        for r = 1; r < lastRow; r++ {
            for c = 1; c < lastCol; c++ {
                if mark[r][c] {
                    b[r][c] = white
                }
            }
        }
    }
    return rs
}
 
var step1 = []int{2, 4, 6, 8}
var step2 = []int{4, 2, 8, 6}
 
func (b wbArray) zhangSuen() {
    for {
        rs1 := b.reset(step1)
        rs2 := b.reset(step2)
        if !rs1 && !rs2 {
            break
        }
    }
}",4310,189
1260,http://rosettacode.org/wiki/Zeckendorf_arithmetic,Zeckendorf arithmetic,"This task is a total immersion zeckendorf task; using decimal numbers will attract serious disapprobation.

The task is to implement addition, subtraction, multiplication, and division using Zeckendorf number representation. Optionally provide decrement, increment and comparitive operation functions.

Addition
Like binary 1 + 1 = 10, note carry 1 left. There the similarity ends. 10 + 10 = 101, note carry 1 left and 1 right. 100 + 100 = 1001, note carry 1 left and 2 right, this is the general case.

Occurrences of 11 must be changed to 100. Occurrences of 111 may be changed from the right by replacing 11 with 100, or from the left converting 111 to 100 + 100;

Subtraction
10 - 1 = 1. The general rule is borrow 1 right carry 1 left. eg:

  abcde
  10100 -
   1000
  _____
    100  borrow 1 from a leaves 100
  + 100  add the carry
  _____
   1001

A larger example:

  abcdef
  100100 -
    1000
  ______
  1*0100 borrow 1 from b
   + 100 add the carry
  ______
  1*1001

Sadly we borrowed 1 from b which didn't have it to lend. So now b borrows from a:

    1001
  + 1000 add the carry
    ____
   10100

Multiplication
Here you teach your computer its zeckendorf tables. eg. 101 * 1001:

  a = 1 * 101 = 101
  b = 10 * 101 = a + a = 10000
  c = 100 * 101 = b + a = 10101
  d = 1000 * 101 = c + b = 101010

  1001 = d + a therefore 101 * 1001 =
 
  101010
   + 101
  ______
 1000100

Division
Lets try 1000101 divided by 101, so we can use the same table used for multiplication.

  1000101 -
   101010 subtract d (1000 * 101)
  _______
     1000 -
      101 b and c are too large to subtract, so subtract a
     ____
        1 so 1000101 divided by 101 is d + a (1001) remainder 1

Efficient algorithms for Zeckendorf arithmetic is interesting. The sections on addition and subtraction are particularly relevant for this task.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
var (
    dig  = [3]string{""00"", ""01"", ""10""}
    dig1 = [3]string{"""", ""1"", ""10""}
)
 
type Zeckendorf struct{ dVal, dLen int }
 
func NewZeck(x string) *Zeckendorf {
    z := new(Zeckendorf)
    if x == """" {
        x = ""0""
    }
    q := 1
    i := len(x) - 1
    z.dLen = i / 2
    for ; i >= 0; i-- {
        z.dVal += int(x[i]-'0') * q
        q *= 2
    }
    return z
}
 
func (z *Zeckendorf) a(i int) {
    for ; ; i++ {
        if z.dLen < i {
            z.dLen = i
        }
        j := (z.dVal >> uint(i*2)) & 3
        switch j {
        case 0, 1:
            return
        case 2:
            if ((z.dVal >> (uint(i+1) * 2)) & 1) != 1 {
                return
            }
            z.dVal += 1 << uint(i*2+1)
            return
        case 3:
            z.dVal &= ^(3 << uint(i*2))
            z.b((i + 1) * 2)
        }
    }
}
 
func (z *Zeckendorf) b(pos int) {
    if pos == 0 {
        z.Inc()
        return
    }
    if ((z.dVal >> uint(pos)) & 1) == 0 {
        z.dVal += 1 << uint(pos)
        z.a(pos / 2)
        if pos > 1 {
            z.a(pos/2 - 1)
        }
    } else {
        z.dVal &= ^(1 << uint(pos))
        z.b(pos + 1)
        temp := 1
        if pos > 1 {
            temp = 2
        }
        z.b(pos - temp)
    }
}
 
func (z *Zeckendorf) c(pos int) {
    if ((z.dVal >> uint(pos)) & 1) == 1 {
        z.dVal &= ^(1 << uint(pos))
        return
    }
    z.c(pos + 1)
    if pos > 0 {
        z.b(pos - 1)
    } else {
        z.Inc()
    }
}
 
func (z *Zeckendorf) Inc() {
    z.dVal++
    z.a(0)
}
 
func (z1 *Zeckendorf) PlusAssign(z2 *Zeckendorf) {
    for gn := 0; gn < (z2.dLen+1)*2; gn++ {
        if ((z2.dVal >> uint(gn)) & 1) == 1 {
            z1.b(gn)
        }
    }
}
 
func (z1 *Zeckendorf) MinusAssign(z2 *Zeckendorf) {
    for gn := 0; gn < (z2.dLen+1)*2; gn++ {
        if ((z2.dVal >> uint(gn)) & 1) == 1 {
            z1.c(gn)
        }
    }
 
    for z1.dLen > 0 && ((z1.dVal>>uint(z1.dLen*2))&3) == 0 {
        z1.dLen--
    }
}
 
func (z1 *Zeckendorf) TimesAssign(z2 *Zeckendorf) {
    na := z2.Copy()
    nb := z2.Copy()
    nr := new(Zeckendorf)
    for i := 0; i <= (z1.dLen+1)*2; i++ {
        if ((z1.dVal >> uint(i)) & 1) > 0 {
            nr.PlusAssign(nb)
        }
        nt := nb.Copy()
        nb.PlusAssign(na)
        na = nt.Copy()
    }
    z1.dVal = nr.dVal
    z1.dLen = nr.dLen
}
 
func (z *Zeckendorf) Copy() *Zeckendorf {
    return &Zeckendorf{z.dVal, z.dLen}
}
 
func (z1 *Zeckendorf) Compare(z2 *Zeckendorf) int {
    switch {
    case z1.dVal < z2.dVal:
        return -1
    case z1.dVal > z2.dVal:
        return 1
    default:
        return 0
    }
}
 
func (z *Zeckendorf) String() string {
    if z.dVal == 0 {
        return ""0""
    }
    var sb strings.Builder
    sb.WriteString(dig1[(z.dVal>>uint(z.dLen*2))&3])
    for i := z.dLen - 1; i >= 0; i-- {
        sb.WriteString(dig[(z.dVal>>uint(i*2))&3])
    }
    return sb.String()
}
 
func main() {
    fmt.Println(""Addition:"")
    g := NewZeck(""10"")
    g.PlusAssign(NewZeck(""10""))
    fmt.Println(g)
    g.PlusAssign(NewZeck(""10""))
    fmt.Println(g)
    g.PlusAssign(NewZeck(""1001""))
    fmt.Println(g)
    g.PlusAssign(NewZeck(""1000""))
    fmt.Println(g)
    g.PlusAssign(NewZeck(""10101""))
    fmt.Println(g)
 
    fmt.Println(""\nSubtraction:"")
    g = NewZeck(""1000"")
    g.MinusAssign(NewZeck(""101""))
    fmt.Println(g)
    g = NewZeck(""10101010"")
    g.MinusAssign(NewZeck(""1010101""))
    fmt.Println(g)
 
    fmt.Println(""\nMultiplication:"")
    g = NewZeck(""1001"")
    g.TimesAssign(NewZeck(""101""))
    fmt.Println(g)
    g = NewZeck(""101010"")
    g.PlusAssign(NewZeck(""101""))
    fmt.Println(g)
}",3718,184
1262,http://rosettacode.org/wiki/Zumkeller_numbers,Zumkeller numbers,"Zumkeller numbers are the set of numbers whose divisors can be partitioned into two disjoint sets that sum to the same value. Each sum must contain divisor values that are not in the other sum, and all of the divisors must be in one or the other. There are no restrictions on how the divisors are partitioned, only that the two partition sums are equal.



E.G.
 6 is a Zumkeller number; The divisors {1 2 3 6} can be partitioned into two groups {1 2 3} and {6} that both sum to 6.
 10 is not a Zumkeller number; The divisors {1 2 5 10} can not be partitioned into two groups in any way that will both sum to the same value.
 12 is a Zumkeller number; The divisors {1 2 3 4 6 12} can be partitioned into two groups {1 3 4 6} and {2 12} that both sum to 14.


Even Zumkeller numbers are common; odd Zumkeller numbers are much less so. For values below 10^6, there is at least one Zumkeller number in every 12 consecutive integers, and the vast majority of them are even. The odd Zumkeller numbers are very similar to the list from the task Abundant odd numbers; they are nearly the same except for the further restriction that the abundance (A(n) = sigma(n) - 2n), must be even: A(n) mod 2 == 0



Task

 Write a routine (function, procedure, whatever) to find Zumkeller numbers.
 Use the routine to find and display here, on this page, the first 220 Zumkeller numbers.
 Use the routine to find and display here, on this page, the first 40 odd Zumkeller numbers.
 Optional, stretch goal: Use the routine to find and display here, on this page, the first 40 odd Zumkeller numbers that don't end with 5.


See Also

 OEIS:A083207 - Zumkeller numbers to get an impression of different partitions OEIS:A083206 Zumkeller partitions
 OEIS:A174865 - Odd Zumkeller numbers


Related Tasks

 Abundant odd numbers
 Abundant, deficient and perfect number classifications
 Proper divisors , Factors of an integer",#Go,Go,"package main
 
import ""fmt""
 
func getDivisors(n int) []int {
    divs := []int{1, n}
    for i := 2; i*i <= n; i++ {
        if n%i == 0 {
            j := n / i
            divs = append(divs, i)
            if i != j {
                divs = append(divs, j)
            }
        }
    }
    return divs
}
 
func sum(divs []int) int {
    sum := 0
    for _, div := range divs {
        sum += div
    }
    return sum
}
 
func isPartSum(divs []int, sum int) bool {
    if sum == 0 {
        return true
    }
    le := len(divs)
    if le == 0 {
        return false
    }
    last := divs[le-1]
    divs = divs[0 : le-1]
    if last > sum {
        return isPartSum(divs, sum)
    }
    return isPartSum(divs, sum) || isPartSum(divs, sum-last)
}
 
func isZumkeller(n int) bool {
    divs := getDivisors(n)
    sum := sum(divs)
    // if sum is odd can't be split into two partitions with equal sums
    if sum%2 == 1 {
        return false
    }
    // if n is odd use 'abundant odd number' optimization
    if n%2 == 1 {
        abundance := sum - 2*n
        return abundance > 0 && abundance%2 == 0
    }
    // if n and sum are both even check if there's a partition which totals sum / 2
    return isPartSum(divs, sum/2)
}
 
func main() {
    fmt.Println(""The first 220 Zumkeller numbers are:"")
    for i, count := 2, 0; count < 220; i++ {
        if isZumkeller(i) {
            fmt.Printf(""%3d "", i)
            count++
            if count%20 == 0 {
                fmt.Println()
            }
        }
    }
    fmt.Println(""\nThe first 40 odd Zumkeller numbers are:"")
    for i, count := 3, 0; count < 40; i += 2 {
        if isZumkeller(i) {
            fmt.Printf(""%5d "", i)
            count++
            if count%10 == 0 {
                fmt.Println()
            }
        }
    }
    fmt.Println(""\nThe first 40 odd Zumkeller numbers which don't end in 5 are:"")
    for i, count := 3, 0; count < 40; i += 2 {
        if (i % 10 != 5) && isZumkeller(i) {
            fmt.Printf(""%7d "", i)
            count++
            if count%8 == 0 {
                fmt.Println()
            }
        }
    }
    fmt.Println()
}",2141,91
1330,http://rosettacode.org/wiki/Zero_to_the_zero_power,Zero to the zero power,"Some computer programming languages are not exactly consistent   (with other computer programming languages)  

when   raising zero to the zeroth power:     00



Task

Show the results of raising   zero   to the   zeroth   power.



If your computer language objects to      0**0      or      0^0      at compile time,   you may also try something like:

           x = 0
           y = 0
           z = x**y
           say  'z='  z


Show the result here.

And of course use any symbols or notation that is supported in your computer programming language for exponentiation.



See also

 The Wiki entry: Zero to the power of zero. 
 The Wiki entry: History of differing points of view.
 The MathWorld™ entry: exponent laws.
 Also, in the above MathWorld™ entry, see formula (9): 




x

0


=
1


{\displaystyle x^{0}=1}

.
 The OEIS entry: The special case of zero to the zeroth power

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/big""
    ""math/cmplx""
)
 
func main() {
    fmt.Println(""float64:    "", math.Pow(0, 0))
    var b big.Int
    fmt.Println(""big integer:"", b.Exp(&b, &b, nil))
    fmt.Println(""complex:    "", cmplx.Pow(0, 0))
}",263,15
1437,http://rosettacode.org/wiki/Yellowstone_sequence,Yellowstone sequence,"The Yellowstone sequence, also called the Yellowstone permutation, is defined as:

For n <= 3,

   a(n) = n

For n >= 4,

   a(n) = the smallest number not already in sequence such that a(n) is relatively prime to a(n-1) and 
          is not relatively prime to a(n-2).



The sequence is a permutation of the natural numbers, and gets its name from what its authors felt was a spiking, geyser like appearance of a plot of the sequence.



Example

a(4) is 4 because 4 is the smallest number following 1, 2, 3 in the sequence that is relatively prime to the entry before it (3), and is not relatively prime to the number two entries before it (2).



Task
 Find and show as output the first  30  Yellowstone numbers.


Extra
 Demonstrate how to plot, with x = n and y coordinate a(n), the first 100 Yellowstone numbers.


Related tasks

   Greatest common divisor.
   Plot coordinate pairs.


See also

   The OEIS entry:   A098550 The Yellowstone permutation.
   Applegate et al, 2015: The Yellowstone Permutation [1].

",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""os/exec""
)
 
func gcd(x, y int) int {
    for y != 0 {
        x, y = y, x%y
    }
    return x
}
 
func yellowstone(n int) []int {
    m := make(map[int]bool)
    a := make([]int, n+1)
    for i := 1; i < 4; i++ {
        a[i] = i
        m[i] = true
    }
    min := 4
    for c := 4; c <= n; c++ {
        for i := min; ; i++ {
            if !m[i] && gcd(a[c-1], i) == 1 && gcd(a[c-2], i) > 1 {
                a[c] = i
                m[i] = true
                if i == min {
                    min++
                }
                break
            }
        }
    }    
    return a[1:]
}
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func main() {
    x := make([]int, 100)
    for i := 0; i < 100; i++ {
        x[i] = i + 1
    }
    y := yellowstone(100)
    fmt.Println(""The first 30 Yellowstone numbers are:"")
    fmt.Println(y[:30])
    g := exec.Command(""gnuplot"", ""-persist"")
    w, err := g.StdinPipe()
    check(err)
    check(g.Start())
    fmt.Fprintln(w, ""unset key; plot '-'"")
    for i, xi := range x {
        fmt.Fprintf(w, ""%d %d\n"", xi, y[i])
    }
    fmt.Fprintln(w, ""e"")
    w.Close()
    g.Wait()
}",1216,64
1447,http://rosettacode.org/wiki/Zeckendorf_number_representation,Zeckendorf number representation,"Just as numbers can be represented in a positional notation as sums of multiples of the powers of ten (decimal) or two (binary); all the positive integers can be represented as the sum of one or zero times the distinct members of the Fibonacci series.

Recall that the first six distinct Fibonacci numbers are: 1, 2, 3, 5, 8, 13.

The decimal number eleven can be written as 0*13 + 1*8 + 0*5 + 1*3 + 0*2 + 0*1 or 010100 in positional notation where the columns represent multiplication by a particular member of the sequence. Leading zeroes are dropped so that 11 decimal becomes 10100.

10100 is not the only way to make 11 from the Fibonacci numbers however; 0*13 + 1*8 + 0*5 + 0*3 + 1*2 + 1*1 or 010011 would also represent decimal 11. For a true Zeckendorf number there is the added restriction that no two consecutive Fibonacci numbers can be used which leads to the former unique solution.



Task

Generate and show here a table of the Zeckendorf number representations of the decimal numbers zero to twenty, in order.

The intention in this task to find the Zeckendorf form of an arbitrary integer. The Zeckendorf form can be iterated by some bit twiddling rather than calculating each value separately but leave that to another separate task.



Also see

   OEIS A014417   for the the sequence of required results.
   Brown's Criterion - Numberphile


Related task

   Fibonacci sequence

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    for i := 0; i <= 20; i++ {
        fmt.Printf(""%2d %7b\n"", i, zeckendorf(i))
    }
}
 
func zeckendorf(n int) int {
    // initial arguments of fib0 = 1 and fib1 = 1 will produce
    // the Fibonacci sequence {1, 2, 3,..} on the stack as successive
    // values of fib1.
    _, set := zr(1, 1, n, 0)
    return set
}
 
func zr(fib0, fib1, n int, bit uint) (remaining, set int) {
    if fib1 > n {
        return n, 0
    }
    // recurse.
    // construct sequence on the way in, construct ZR on the way out.
    remaining, set = zr(fib1, fib0+fib1, n, bit+1)
    if fib1 <= remaining {
        set |= 1 << bit
        remaining -= fib1
    }
    return
}",704,31
1463,http://rosettacode.org/wiki/Yahoo!_search_interface,Yahoo! search interface,"Create a class for searching Yahoo! results.

It must implement a Next Page method, and read URL, Title and Content from results.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""golang.org/x/net/html""
    ""io/ioutil""
    ""net/http""
    ""regexp""
    ""strings""
)
 
var (
    expr = `<h3 class=""title""><a class=.*?href=""(.*?)"".*?>(.*?)</a></h3>` +
        `.*?<div class=""compText aAbs"" ><p class=.*?>(.*?)</p></div>`
    rx = regexp.MustCompile(expr)
)
 
type YahooResult struct {
    title, url, content string
}
 
func (yr YahooResult) String() string {
    return fmt.Sprintf(""Title  : %s\nUrl    : %s\nContent: %s\n"", yr.title, yr.url, yr.content)
}
 
type YahooSearch struct {
    query string
    page  int
}
 
func (ys YahooSearch) results() []YahooResult {
    search := fmt.Sprintf(""http://search.yahoo.com/search?p=%s&b=%d"", ys.query, ys.page*10+1)
    resp, _ := http.Get(search)
    body, _ := ioutil.ReadAll(resp.Body)
    s := string(body)
    defer resp.Body.Close()
    var results []YahooResult
    for _, f := range rx.FindAllStringSubmatch(s, -1) {
        yr := YahooResult{}
        yr.title = html.UnescapeString(strings.ReplaceAll(strings.ReplaceAll(f[2], ""<b>"", """"), ""</b>"", """"))
        yr.url = f[1]
        yr.content = html.UnescapeString(strings.ReplaceAll(strings.ReplaceAll(f[3], ""<b>"", """"), ""</b>"", """"))
        results = append(results, yr)
    }
    return results
}
 
func (ys YahooSearch) nextPage() YahooSearch {
    return YahooSearch{ys.query, ys.page + 1}
}
 
func main() {
    ys := YahooSearch{""rosettacode"", 0}
    // Limit output to first 5 entries, say, from pages 1 and 2.
    fmt.Println(""PAGE 1 =>\n"")
    for _, res := range ys.results()[0:5] {
        fmt.Println(res)
    }
    fmt.Println(""PAGE 2 =>\n"")
    for _, res := range ys.nextPage().results()[0:5] {
        fmt.Println(res)
    }
}",1702,63
1541,http://rosettacode.org/wiki/Arbitrary-precision_integers_(included),Arbitrary-precision integers (included),"Using the in-built capabilities of your language, calculate the integer value of:

        
  
    
      
        
          5
          
            
              4
              
                
                  3
                  
                    2
                  
                
              
            
          
        
      
    
    {\displaystyle 5^{4^{3^{2}}}}
  


 Confirm that the first and last twenty digits of the answer are: 
     62060698786608744707...92256259918212890625

 Find and show the number of decimal digits in the answer.


Note: Do not submit an implementation of arbitrary precision arithmetic. The intention is to show the capabilities of the language as supplied. If a language has a single, overwhelming, library of varied modules that is endorsed by its home site – such as CPAN for Perl or Boost for C++ – then that may be used instead.
Strictly speaking, this should not be solved by fixed-precision numeric libraries where the precision has to be manually set to a large value; although if this is the only recourse then it may be used with a note explaining that the precision must be set manually to a large enough value.


Related tasks

   Long multiplication
   Exponentiation order
   exponentiation operator
   Exponentiation with infix operators in (or operating on) the base

",#Go,Go,"package main
 
import (
	""fmt""
	""math/big""
)
 
func main() {
	x := big.NewInt(2)
	x = x.Exp(big.NewInt(3), x, nil)
	x = x.Exp(big.NewInt(4), x, nil)
	x = x.Exp(big.NewInt(5), x, nil)
	str := x.String()
	fmt.Printf(""5^(4^(3^2)) has %d digits: %s ... %s\n"",
		len(str),
		str[:20],
		str[len(str)-20:],
	)
}",305,19
1716,http://rosettacode.org/wiki/Arrays,Arrays,"This task is about arrays.

For hashes or associative arrays, please see Creating an Associative Array.

For a definition and in-depth discussion of what an array is, see Array.



Task

Show basic array syntax in your language.

Basically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and
dynamic arrays, pushing a value into it).

Please discuss at Village Pump:   Arrays.

Please merge code in from these obsolete tasks:

   Creating an Array
   Assigning Values to an Array
   Retrieving an Element of an Array


Related tasks

   Collections
   Creating an Associative Array
   Two-dimensional array (runtime)

",#Go,Go,"package main
 
import (
    ""fmt""
)
 
func main() {
    // creates an array of five ints.
    // specified length must be a compile-time constant expression.
    // this allows compiler to do efficient bounds checking.
    var a [5]int
 
    // since length is compile-time constant, len() is a compile time constant
    // and does not have the overhead of a function call.
    fmt.Println(""len(a) ="", len(a))
 
    // elements are always initialized to 0
    fmt.Println(""a ="", a)
 
    // assign a value to an element.  indexing is 0 based.
    a[0] = 3
    fmt.Println(""a ="", a)
 
    // retrieve element value with same syntax
    fmt.Println(""a[0] ="", a[0])
 
    // a slice references an underlying array
    s := a[:4] // this does not allocate new array space.
    fmt.Println(""s ="", s)
 
    // slices have runtime established length and capacity, but len() and
    // cap() are built in to the compiler and have overhead more like
    // variable access than function call.
    fmt.Println(""len(s) ="", len(s), "" cap(s) ="", cap(s))
 
    // slices can be resliced, as long as there is space
    // in the underlying array.
    s = s[:5]
    fmt.Println(""s ="", s)
 
    // s still based on a
    a[0] = 22
    fmt.Println(""a ="", a)
    fmt.Println(""s ="", s)
 
    // append will automatically allocate a larger underlying array as needed.
    s = append(s, 4, 5, 6)
    fmt.Println(""s ="", s)
    fmt.Println(""len(s) ="", len(s), "" cap(s) ="", cap(s))
 
    // s no longer based on a
    a[4] = -1
    fmt.Println(""a ="", a)
    fmt.Println(""s ="", s)
 
    // make creates a slice and allocates a new underlying array
    s = make([]int, 8)
    fmt.Println(""s ="", s)
    fmt.Println(""len(s) ="", len(s), "" cap(s) ="", cap(s))
 
    // the cap()=10 array is no longer referenced
    // and would be garbage collected eventually.
}",1832,63
1759,http://rosettacode.org/wiki/Yin_and_yang,Yin and yang,"One well-known symbol of the philosophy of duality known as yin and yang is the taijitu.



Task

   Create a function that, given a parameter representing size, generates such a symbol scaled to the requested size.
   Generate and display the symbol for two different (small) sizes.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""os""
    ""text/template""
)
 
var tmpl = `<?xml version=""1.0""?>
<svg xmlns=""http://www.w3.org/2000/svg""
    xmlns:xlink=""http://www.w3.org/1999/xlink""
    width=""210"" height=""150"">
<symbol id=""yy"" viewBox=""0 0 200 200"">
<circle stroke=""black"" stroke-width=""2"" fill=""white""
    cx=""100"" cy=""100"" r=""99"" />
<path fill=""black""
    d=""M100 100 a49 49 0 0 0 0 -98
    v-1 a99 99 0 0 1 0 198
    v-1 a49 49 0 0 1 0 -98"" />
<circle fill=""black"" cx=""100"" cy=""51"" r=""17"" />
<circle fill=""white"" cx=""100"" cy=""149"" r=""17"" />
</symbol>
{{range .}}<use xlink:href=""#yy""
    x=""{{.X}}"" y=""{{.Y}}"" width=""{{.Sz}}"" height=""{{.Sz}}""/>
{{end}}</svg>
`
 
// structure specifies position and size to draw symbol
type xysz struct {
    X, Y, Sz int
}
 
// example data to specify drawing the symbol twice,
// with different position and size. 
var yys = []xysz{
    {20, 20, 100},
    {140, 30, 60},
}
 
func main() {
    xt := template.New("""")
    template.Must(xt.Parse(tmpl))
    f, err := os.Create(""yy.svg"")
    if err != nil {
        fmt.Println(err)
        return
    }
    if err := xt.Execute(f, yys); err != nil {
        fmt.Println(err)
    }
    f.Close()
}",1188,52
1777,http://rosettacode.org/wiki/XML/XPath,XML/XPath,"Perform the following three XPath queries on the XML Document below:

 //item[1]: Retrieve the first ""item"" element 
 //price/text(): Perform an action on each ""price"" element (print it out)
 //name: Get an array of all the ""name"" elements
XML Document:

<inventory title=""OmniCorp Store #45x10^3"">
  <section name=""health"">
    <item upc=""123456789"" stock=""12"">
      <name>Invisibility Cream</name>
      <price>14.50</price>
      <description>Makes you invisible</description>
    </item>
    <item upc=""445322344"" stock=""18"">
      <name>Levitation Salve</name>
      <price>23.99</price>
      <description>Levitate yourself for up to 3 hours per application</description>
    </item>
  </section>
  <section name=""food"">
    <item upc=""485672034"" stock=""653"">
      <name>Blork and Freen Instameal</name>
      <price>4.95</price>
      <description>A tasty meal in a tablet; just add water</description>
    </item>
    <item upc=""132957764"" stock=""44"">
      <name>Grob winglets</name>
      <price>3.56</price>
      <description>Tender winglets of Grob. Just add water</description>
    </item>
  </section>
</inventory>
",#Go,Go,"package main
 
import (
	""encoding/xml""
	""fmt""
	""log""
	""os""
)
 
type Inventory struct {
	XMLName  xml.Name `xml:""inventory""`
	Title    string   `xml:""title,attr""`
	Sections []struct {
		XMLName xml.Name `xml:""section""`
		Name    string   `xml:""name,attr""`
		Items   []struct {
			XMLName     xml.Name `xml:""item""`
			Name        string   `xml:""name""`
			UPC         string   `xml:""upc,attr""`
			Stock       int      `xml:""stock,attr""`
			Price       float64  `xml:""price""`
			Description string   `xml:""description""`
		} `xml:""item""`
	} `xml:""section""`
}
 
// To simplify main's error handling
func printXML(s string, v interface{}) {
	fmt.Println(s)
	b, err := xml.MarshalIndent(v, """", ""\t"")
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(string(b))
	fmt.Println()
}
 
func main() {
	fmt.Println(""Reading XML from standard input..."")
 
	var inv Inventory
	dec := xml.NewDecoder(os.Stdin)
	if err := dec.Decode(&inv); err != nil {
		log.Fatal(err)
	}
 
	// At this point, inv is Go struct with all the fields filled
	// in from the XML data. Well-formed XML input that doesn't
	// match the specification of the fields in the Go struct are
	// discarded without error.
 
	// We can reformat the parts we parsed:
	//printXML(""Got:"", inv)
 
	// 1. Retrieve first item:
	item := inv.Sections[0].Items[0]
	fmt.Println(""item variable:"", item)
	printXML(""As XML:"", item)
 
	// 2. Action on each price:
	fmt.Println(""Prices:"")
	var totalValue float64
	for _, s := range inv.Sections {
		for _, i := range s.Items {
			fmt.Println(i.Price)
			totalValue += i.Price * float64(i.Stock)
		}
	}
	fmt.Println(""Total inventory value:"", totalValue)
	fmt.Println()
 
	// 3. Slice of all the names:
	var names []string
	for _, s := range inv.Sections {
		for _, i := range s.Items {
			names = append(names, i.Name)
		}
	}
	fmt.Printf(""names: %q\n"", names)
}",1844,80
1840,http://rosettacode.org/wiki/Zebra_puzzle,Zebra puzzle,"Zebra puzzle

You are encouraged to solve this task according to the task description, using any language you may know.
The Zebra puzzle, a.k.a. Einstein's Riddle,
is a logic puzzle which is to be solved programmatically.



It has several variants, one of them this:

   There are five houses.
   The English man lives in the red house.
   The Swede has a dog.
   The Dane drinks tea.
   The green house is immediately to the left of the white house.
   They drink coffee in the green house.
   The man who smokes Pall Mall has birds.
   In the yellow house they smoke Dunhill.
   In the middle house they drink milk.
   The Norwegian lives in the first house.
   The man who smokes Blend lives in the house next to the house with cats.
   In a house next to the house where they have a horse, they smoke Dunhill.
   The man who smokes Blue Master drinks beer.
   The German smokes Prince.
   The Norwegian lives next to the blue house.
   They drink water in a house next to the house where they smoke Blend. 

The question is, who owns the zebra?

Additionally, list the solution for all the houses.

Optionally, show the solution is unique.



Related tasks

   Dinesman's multiple-dwelling problem
   Twelve statements

",#Go,Go,"package main
 
import (
        ""fmt""
        ""log""
        ""strings""
)
 
// Define some types
 
type HouseSet [5]*House
type House struct {
        n Nationality
        c Colour
        a Animal
        d Drink
        s Smoke
}
type Nationality int8
type Colour int8
type Animal int8
type Drink int8
type Smoke int8
 
// Define the possible values
 
const (
        English Nationality = iota
        Swede
        Dane
        Norwegian
        German
)
const (
        Red Colour = iota
        Green
        White
        Yellow
        Blue
)
const (
        Dog Animal = iota
        Birds
        Cats
        Horse
        Zebra
)
const (
        Tea Drink = iota
        Coffee
        Milk
        Beer
        Water
)
const (
        PallMall Smoke = iota
        Dunhill
        Blend
        BlueMaster
        Prince
)
 
// And how to print them
 
var nationalities = [...]string{""English"", ""Swede"", ""Dane"", ""Norwegian"", ""German""}
var colours = [...]string{""red"", ""green"", ""white"", ""yellow"", ""blue""}
var animals = [...]string{""dog"", ""birds"", ""cats"", ""horse"", ""zebra""}
var drinks = [...]string{""tea"", ""coffee"", ""milk"", ""beer"", ""water""}
var smokes = [...]string{""Pall Mall"", ""Dunhill"", ""Blend"", ""Blue Master"", ""Prince""}
 
func (n Nationality) String() string { return nationalities[n] }
func (c Colour) String() string      { return colours[c] }
func (a Animal) String() string      { return animals[a] }
func (d Drink) String() string       { return drinks[d] }
func (s Smoke) String() string       { return smokes[s] }
func (h House) String() string {
        return fmt.Sprintf(""%-9s  %-6s  %-5s  %-6s  %s"", h.n, h.c, h.a, h.d, h.s)
}
func (hs HouseSet) String() string {
        lines := make([]string, 0, len(hs))
        for i, h := range hs {
                s := fmt.Sprintf(""%d  %s"", i, h)
                lines = append(lines, s)
        }
        return strings.Join(lines, ""\n"")
}
 
// Simple brute force solution
 
func simpleBruteForce() (int, HouseSet) {
        var v []House
        for n := range nationalities {
                for c := range colours {
                        for a := range animals {
                                for d := range drinks {
                                        for s := range smokes {
                                                h := House{
                                                        n: Nationality(n),
                                                        c: Colour(c),
                                                        a: Animal(a),
                                                        d: Drink(d),
                                                        s: Smoke(s),
                                                }
                                                if !h.Valid() {
                                                        continue
                                                }
                                                v = append(v, h)
                                        }
                                }
                        }
                }
        }
        n := len(v)
        log.Println(""Generated"", n, ""valid houses"")
 
        combos := 0
        first := 0
        valid := 0
        var validSet HouseSet
        for a := 0; a < n; a++ {
                if v[a].n != Norwegian { // Condition 10:
                        continue
                }
                for b := 0; b < n; b++ {
                        if b == a {
                                continue
                        }
                        if v[b].anyDups(&v[a]) {
                                continue
                        }
                        for c := 0; c < n; c++ {
                                if c == b || c == a {
                                        continue
                                }
                                if v[c].d != Milk { // Condition 9:
                                        continue
                                }
                                if v[c].anyDups(&v[b], &v[a]) {
                                        continue
                                }
                                for d := 0; d < n; d++ {
                                        if d == c || d == b || d == a {
                                                continue
                                        }
                                        if v[d].anyDups(&v[c], &v[b], &v[a]) {
                                                continue
                                        }
                                        for e := 0; e < n; e++ {
                                                if e == d || e == c || e == b || e == a {
                                                        continue
                                                }
                                                if v[e].anyDups(&v[d], &v[c], &v[b], &v[a]) {
                                                        continue
                                                }
                                                combos++
                                                set := HouseSet{&v[a], &v[b], &v[c], &v[d], &v[e]}
                                                if set.Valid() {
                                                        valid++
                                                        if valid == 1 {
                                                                first = combos
                                                        }
                                                        validSet = set
                                                        //return set
                                                }
                                        }
                                }
                        }
                }
        }
        log.Println(""Tested"", first, ""different combinations of valid houses before finding solution"")
        log.Println(""Tested"", combos, ""different combinations of valid houses in total"")
        return valid, validSet
}
 
// anyDups returns true if h as any duplicate attributes with any of the specified houses
func (h *House) anyDups(list ...*House) bool {
        for _, b := range list {
                if h.n == b.n || h.c == b.c || h.a == b.a || h.d == b.d || h.s == b.s {
                        return true
                }
        }
        return false
}
 
func (h *House) Valid() bool {
        // Condition 2:
        if h.n == English && h.c != Red || h.n != English && h.c == Red {
                return false
        }
        // Condition 3:
        if h.n == Swede && h.a != Dog || h.n != Swede && h.a == Dog {
                return false
        }
        // Condition 4:
        if h.n == Dane && h.d != Tea || h.n != Dane && h.d == Tea {
                return false
        }
        // Condition 6:
        if h.c == Green && h.d != Coffee || h.c != Green && h.d == Coffee {
                return false
        }
        // Condition 7:
        if h.a == Birds && h.s != PallMall || h.a != Birds && h.s == PallMall {
                return false
        }
        // Condition 8:
        if h.c == Yellow && h.s != Dunhill || h.c != Yellow && h.s == Dunhill {
                return false
        }
        // Condition 11:
        if h.a == Cats && h.s == Blend {
                return false
        }
        // Condition 12:
        if h.a == Horse && h.s == Dunhill {
                return false
        }
        // Condition 13:
        if h.d == Beer && h.s != BlueMaster || h.d != Beer && h.s == BlueMaster {
                return false
        }
        // Condition 14:
        if h.n == German && h.s != Prince || h.n != German && h.s == Prince {
                return false
        }
        // Condition 15:
        if h.n == Norwegian && h.c == Blue {
                return false
        }
        // Condition 16:
        if h.d == Water && h.s == Blend {
                return false
        }
        return true
}
 
func (hs *HouseSet) Valid() bool {
        ni := make(map[Nationality]int, 5)
        ci := make(map[Colour]int, 5)
        ai := make(map[Animal]int, 5)
        di := make(map[Drink]int, 5)
        si := make(map[Smoke]int, 5)
        for i, h := range hs {
                ni[h.n] = i
                ci[h.c] = i
                ai[h.a] = i
                di[h.d] = i
                si[h.s] = i
        }
        // Condition 5:
        if ci[Green]+1 != ci[White] {
                return false
        }
        // Condition 11:
        if dist(ai[Cats], si[Blend]) != 1 {
                return false
        }
        // Condition 12:
        if dist(ai[Horse], si[Dunhill]) != 1 {
                return false
        }
        // Condition 15:
        if dist(ni[Norwegian], ci[Blue]) != 1 {
                return false
        }
        // Condition 16:
        if dist(di[Water], si[Blend]) != 1 {
                return false
        }
 
        // Condition 9: (already tested elsewhere)
        if hs[2].d != Milk {
                return false
        }
        // Condition 10: (already tested elsewhere)
        if hs[0].n != Norwegian {
                return false
        }
        return true
}
 
func dist(a, b int) int {
        if a > b {
                return a - b
        }
        return b - a
}
 
func main() {
        log.SetFlags(0)
        n, sol := simpleBruteForce()
        fmt.Println(n, ""solution found"")
        fmt.Println(sol)
}",9481,294
1959,http://rosettacode.org/wiki/Zig-zag_matrix,Zig-zag matrix,"Task

Produce a zig-zag array.



A   zig-zag   array is a square arrangement of the first   N2   natural numbers,   where the

numbers increase sequentially as you zig-zag along the array's   anti-diagonals.

For a graphical representation, see   JPG zigzag   (JPG uses such arrays to encode images).



For example, given   5,   produce this array:

 0  1  5  6 14
 2  4  7 13 15
 3  8 12 16 21
 9 11 17 20 22
10 18 19 23 24



Related tasks

   Spiral matrix
   Identity matrix
   Ulam spiral (for primes)


See also

   Wiktionary entry:   anti-diagonals

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
func zz(n int) []int {
    r := make([]int, n*n)
    i := 0
    n2 := n * 2
    for d := 1; d <= n2; d++ {
        x := d - n
        if x < 0 {
            x = 0
        }
        y := d - 1
        if y > n-1 {
            y = n - 1
        }
        j := n2 - d
        if j > d {
            j = d
        }
        for k := 0; k < j; k++ {
            if d&1 == 0 {
                r[(x+k)*n+y-k] = i
            } else {
                r[(y-k)*n+x+k] = i
            }
            i++
        }
    }
 
    return r
}
 
func main() {
    const n = 5
    w := len(strconv.Itoa(n*n - 1))
    for i, e := range zz(n) {
        fmt.Printf(""%*d "", w, e)
        if i%n == n-1 {
            fmt.Println("""")
        }
    }
}",777,47
2037,http://rosettacode.org/wiki/Y_combinator,Y combinator,"In strict functional programming and the lambda calculus, functions (lambda expressions) don't have state and are only allowed to refer to arguments of enclosing functions.

This rules out the usual definition of a recursive function wherein a function is associated with the state of a variable and this variable's state is used in the body of the function.

The   Y combinator   is itself a stateless function that, when applied to another stateless function, returns a recursive version of the function.

The Y combinator is the simplest of the class of such functions, called fixed-point combinators.



Task

Define the stateless   Y combinator   and use it to compute factorials and Fibonacci numbers from other stateless functions or lambda expressions.



Cf

 Jim Weirich: Adventures in Functional Programming

",#Go_2,Go,"package main
 
import ""fmt""
 
type Func func(int) int
type FuncFunc func(Func) Func
type RecursiveFunc func (RecursiveFunc) Func
 
func main() {
	fac := Y(almost_fac)
	fib := Y(almost_fib)
	fmt.Println(""fac(10) = "", fac(10))
	fmt.Println(""fib(10) = "", fib(10))
}
 
func Y(f FuncFunc) Func {
	g := func(r RecursiveFunc) Func {
		return f(func(x int) int {
			return r(r)(x)
		})
	}
	return g(g)
}
 
func almost_fac(f Func) Func {
	return func(x int) int {
		if x <= 1 {
			return 1
		}
		return x * f(x-1)
	}
}
 
func almost_fib(f Func) Func {
	return func(x int) int {
		if x <= 2 {
			return 1
		}
		return f(x-1)+f(x-2)
	}
}",626,41
2275,http://rosettacode.org/wiki/100_doors,100 doors,"There are 100 doors in a row that are all initially closed.

You make 100 passes by the doors.

The first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).

The second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.

The third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.



Task

Answer the question:   what state are the doors in after the last pass?   Which are open, which are closed?


Alternate:
As noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.

Opening only those doors is an   optimization   that may also be expressed;
however, as should be obvious, this defeats the intent of comparing implementations across programming languages.



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    doors := [100]bool{}
 
    // the 100 passes called for in the task description
    for pass := 1; pass <= 100; pass++ {
        for door := pass-1; door < 100; door += pass {
            doors[door] = !doors[door]
        }
    }
 
    // one more pass to answer the question
    for i, v := range doors {
        if v {
            fmt.Print(""1"")
        } else {
            fmt.Print(""0"")
        }
 
        if i%10 == 9 {
            fmt.Print(""\n"")
        } else {
            fmt.Print("" "")
        }
 
    }
}",567,30
2365,http://rosettacode.org/wiki/Write_to_Windows_event_log,Write to Windows event log,"Task

Write script status to the Windows Event Log



",#Go,Go,"package main
 
import (
    ""fmt""
    ""os/exec""
)
 
func main() {
    command := ""EventCreate""
    args := []string{""/T"", ""INFORMATION"", ""/ID"", ""123"", ""/L"", ""APPLICATION"",
        ""/SO"", ""Go"", ""/D"", ""\""Rosetta Code Example\""""}
    cmd := exec.Command(command, args...)
    err := cmd.Run()
    if err != nil {
        fmt.Println(err)
    }
}",342,17
2467,http://rosettacode.org/wiki/Write_entire_file,Write entire file,"Task

(Over)write a file so that it contains a string.



The reverse of Read entire file—for when you want to update or create a file which you would read in its entirety all at once.



",#Go,Go,"import ""io/ioutil""
 
func main() {
    ioutil.WriteFile(""path/to/your.file"", []byte(""data""), 0644)
}",100,5
2502,http://rosettacode.org/wiki/XML/DOM_serialization,XML/DOM serialization,"Create a simple DOM and having it serialize to:

 <?xml version=""1.0"" ?>
 <root>
     <element>
         Some text here
     </element>
 </root>
",#Go,Go,"package main
 
import (
    ""fmt""
    dom ""gitlab.com/stone.code/xmldom-go.git""
)
 
func main() {
    d, err := dom.ParseStringXml(`
<?xml version=""1.0"" ?>
<root>
    <element>
        Some text here
    </element>
</root>`)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(string(d.ToXml()))
}",327,21
2562,http://rosettacode.org/wiki/Write_float_arrays_to_a_text_file,Write float arrays to a text file,"Task

Write two equal-sized numerical arrays 'x' and 'y' to
a two-column text file named 'filename'.

The first column of the file contains values from an 'x'-array with a
given 'xprecision', the second -- values from 'y'-array with 'yprecision'.

For example, considering:

   x = {1, 2, 3, 1e11};
   y = {1, 1.4142135623730951, 1.7320508075688772, 316227.76601683791}; 
                                                          /* sqrt(x) */
   xprecision = 3;
   yprecision = 5;

The file should look like:

   1    1
   2    1.4142
   3    1.7321
   1e+011   3.1623e+005

This task is intended as a subtask for Measure relative performance of sorting algorithms implementations.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""os""
)
 
var (
    x = []float64{1, 2, 3, 1e11}
    y = []float64{1, 1.4142135623730951, 1.7320508075688772, 316227.76601683791}
 
    xprecision = 3
    yprecision = 5
)
 
func main() {
    if len(x) != len(y) {
        fmt.Println(""x, y different length"")
        return
    }
    f, err := os.Create(""filename"")
    if err != nil {
        fmt.Println(err)
        return
    }
    for i := range x {
        fmt.Fprintf(f, ""%.*e, %.*e\n"", xprecision-1, x[i], yprecision-1, y[i])
    }
    f.Close()
}",542,30
2590,http://rosettacode.org/wiki/World_Cup_group_stage,World Cup group stage,"It's World Cup season (or at least it was when this page was created)!

The World Cup is an international football/soccer tournament that happens every 4 years.   Countries put their international teams together in the years between tournaments and qualify for the tournament based on their performance in other international games.   Once a team has qualified they are put into a group with 3 other teams.

For the first part of the World Cup tournament the teams play in ""group stage"" games where each of the four teams in a group plays all three other teams once.   The results of these games determine which teams will move on to the ""knockout stage"" which is a standard single-elimination tournament.   The two teams from each group with the most standings points move on to the knockout stage.

Each game can result in a win for one team and a loss for the other team or it can result in a draw/tie for each team.

   A win is worth three points.
   A draw/tie is worth one point. 
   A loss is worth zero points.


Task

   Generate all possible outcome combinations for the six group stage games.   With three possible outcomes for each game there should be 36 = 729 of them. 
   Calculate the standings points for each team with each combination of outcomes. 
   Show a histogram (graphical,   ASCII art, or straight counts--whichever is easiest/most fun) of the standings points for all four teams over all possible outcomes.


Don't worry about tiebreakers as they can get complicated.   We are basically looking to answer the question ""if a team gets x standings points, where can they expect to end up in the group standings?"".

Hint: there should be no possible way to end up in second place with less than two points as well as no way to end up in first with less than three.   Oddly enough, there is no way to get 8 points at all.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
    ""strconv""
)
 
var games = [6]string{""12"", ""13"", ""14"", ""23"", ""24"", ""34""}
var results = ""000000""
 
func nextResult() bool {
    if results == ""222222"" {
        return false
    }
    res, _ := strconv.ParseUint(results, 3, 32)
    results = fmt.Sprintf(""%06s"", strconv.FormatUint(res+1, 3))
    return true
}
 
func main() {
    var points [4][10]int
    for {
        var records [4]int
        for i := 0; i < len(games); i++ {
            switch results[i] {
            case '2':
                records[games[i][0]-'1'] += 3
            case '1':
                records[games[i][0]-'1']++
                records[games[i][1]-'1']++
            case '0':
                records[games[i][1]-'1'] += 3
            }
        }
        sort.Ints(records[:])
        for i := 0; i < 4; i++ {
            points[i][records[i]]++
        }
        if !nextResult() {
            break
        }
    }
    fmt.Println(""POINTS       0    1    2    3    4    5    6    7    8    9"")
    fmt.Println(""-------------------------------------------------------------"")
    places := [4]string{""1st"", ""2nd"", ""3rd"", ""4th""}
    for i := 0; i < 4; i++ {
        fmt.Print(places[i], "" place    "")
        for j := 0; j < 10; j++ {
            fmt.Printf(""%-5d"", points[3-i][j])
        }
        fmt.Println()
    }
}",1352,54
2653,http://rosettacode.org/wiki/Xiaolin_Wu%27s_line_algorithm,Xiaolin Wu's line algorithm,"Task

Implement the   Xiaolin Wu's line algorithm   described in Wikipedia.



This algorithm draws anti-aliased lines.



Related task

   See   Bresenham's line algorithm   for aliased lines.

",#Go,Go,"package raster
 
import ""math""
 
func ipart(x float64) float64 {
    return math.Floor(x)
}
 
func round(x float64) float64 {
    return ipart(x + .5)
}
 
func fpart(x float64) float64 {
    return x - ipart(x)
}
 
func rfpart(x float64) float64 {
    return 1 - fpart(x)
}
 
// AaLine plots anti-aliased line by Xiaolin Wu's line algorithm.
func (g *Grmap) AaLine(x1, y1, x2, y2 float64) {
    // straight translation of WP pseudocode
    dx := x2 - x1
    dy := y2 - y1
    ax := dx
    if ax < 0 {
        ax = -ax
    }
    ay := dy
    if ay < 0 {
        ay = -ay
    }
    // plot function set here to handle the two cases of slope
    var plot func(int, int, float64)
    if ax < ay {
        x1, y1 = y1, x1
        x2, y2 = y2, x2
        dx, dy = dy, dx
        plot = func(x, y int, c float64) {
            g.SetPx(y, x, uint16(c*math.MaxUint16))
        }
    } else {
        plot = func(x, y int, c float64) {
            g.SetPx(x, y, uint16(c*math.MaxUint16))
        }
    }
    if x2 < x1 {
        x1, x2 = x2, x1
        y1, y2 = y2, y1
    }
    gradient := dy / dx
 
    // handle first endpoint
    xend := round(x1)
    yend := y1 + gradient*(xend-x1)
    xgap := rfpart(x1 + .5)
    xpxl1 := int(xend) // this will be used in the main loop
    ypxl1 := int(ipart(yend))
    plot(xpxl1, ypxl1, rfpart(yend)*xgap)
    plot(xpxl1, ypxl1+1, fpart(yend)*xgap)
    intery := yend + gradient // first y-intersection for the main loop
 
    // handle second endpoint
    xend = round(x2)
    yend = y2 + gradient*(xend-x2)
    xgap = fpart(x2 + 0.5)
    xpxl2 := int(xend) // this will be used in the main loop
    ypxl2 := int(ipart(yend))
    plot(xpxl2, ypxl2, rfpart(yend)*xgap)
    plot(xpxl2, ypxl2+1, fpart(yend)*xgap)
 
    // main loop
    for x := xpxl1 + 1; x <= xpxl2-1; x++ {
        plot(x, int(ipart(intery)), rfpart(intery))
        plot(x, int(ipart(intery))+1, fpart(intery))
        intery = intery + gradient
    }
}",1955,79
2737,http://rosettacode.org/wiki/Word_ladder,Word ladder,"Yet another shortest path problem. Given two words of equal length the task is to transpose the first into the second.

Only one letter may be changed at a time and the change must result in a word in unixdict, the minimum number of intermediate words should be used.

Demonstrate the following:

A boy can be made into a man: boy -> bay -> ban -> man

With a little more difficulty a girl can be made into a lady: girl -> gill -> gall -> gale -> gaze -> laze -> lazy -> lady

A john can be made into a jane: john -> cohn -> conn -> cone -> cane -> jane

A child can not be turned into an adult.

Optional transpositions of your choice.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""bytes""
    ""fmt""
    ""io/ioutil""
    ""log""
    ""strings""
)
 
func contains(a []string, s string) bool {
    for _, e := range a {
        if e == s {
            return true
        }
    }
    return false
}
 
func oneAway(a, b string) bool {
    sum := 0
    for i := 0; i < len(a); i++ {
        if a[i] != b[i] {
            sum++
        }
    }
    return sum == 1
}
 
func wordLadder(words []string, a, b string) {
    l := len(a)
    var poss []string
    for _, word := range words {
        if len(word) == l {
            poss = append(poss, word)
        }
    }
    todo := [][]string{{a}}
    for len(todo) > 0 {
        curr := todo[0]
        todo = todo[1:]
        var next []string
        for _, word := range poss {
            if oneAway(word, curr[len(curr)-1]) {
                next = append(next, word)
            }
        }
        if contains(next, b) {
            curr = append(curr, b)
            fmt.Println(strings.Join(curr, "" -> ""))
            return
        }
        for i := len(poss) - 1; i >= 0; i-- {
            if contains(next, poss[i]) {
                copy(poss[i:], poss[i+1:])
                poss[len(poss)-1] = """"
                poss = poss[:len(poss)-1]
            }
        }
        for _, s := range next {
            temp := make([]string, len(curr))
            copy(temp, curr)
            temp = append(temp, s)
            todo = append(todo, temp)
        }
    }
    fmt.Println(a, ""into"", b, ""cannot be done."")
}
 
func main() {
    b, err := ioutil.ReadFile(""unixdict.txt"")
    if err != nil {
        log.Fatal(""Error reading file"")
    }
    bwords := bytes.Fields(b)
    words := make([]string, len(bwords))
    for i, bword := range bwords {
        words[i] = string(bword)
    }
    pairs := [][]string{
        {""boy"", ""man""},
        {""girl"", ""lady""},
        {""john"", ""jane""},
        {""child"", ""adult""},
    }
    for _, pair := range pairs {
        wordLadder(words, pair[0], pair[1])
    }
}",2004,89
2790,http://rosettacode.org/wiki/Word_wheel,Word wheel,"A ""word wheel"" is a type of word game commonly found on the ""puzzle"" page of
newspapers. You are presented with nine letters arranged in a circle or 3×3
grid. The objective is to find as many words as you can using only the letters
contained in the wheel or grid. Each word must contain the letter in the centre
of the wheel or grid. Usually there will be a minimum word length of 3 or 4
characters. Each letter may only be used as many times as it appears in the wheel
or grid.



An example
 


 N

 D

 E


 O

 K

 G


 E

 L

 W



Task

Write a program to solve the above ""word wheel"" puzzle.

Specifically:

 Find all words of 3 or more letters using only the letters in the string   ndeokgelw.
 All words must contain the central letter   K.
 Each letter may be used only as many times as it appears in the string.
 For this task we'll use lowercase English letters exclusively.


A ""word"" is defined to be any string contained in the file located at   http://wiki.puzzlers.org/pub/wordlists/unixdict.txt.

If you prefer to use a different dictionary,   please state which one you have used.

Optional extra

Word wheel puzzles usually state that there is at least one nine-letter word to be found.
Using the above dictionary, find the 3x3 grids with at least one nine-letter
solution that generate the largest number of words of three or more letters.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""bytes""
    ""fmt""
    ""io/ioutil""
    ""log""
    ""sort""
    ""strings""
)
 
func main() {
    b, err := ioutil.ReadFile(""unixdict.txt"")
    if err != nil {
        log.Fatal(""Error reading file"")
    }
    letters := ""deegklnow""
    wordsAll := bytes.Split(b, []byte{'\n'})
    // get rid of words under 3 letters or over 9 letters
    var words [][]byte
    for _, word := range wordsAll {
        word = bytes.TrimSpace(word)
        le := len(word)
        if le > 2 && le < 10 {
            words = append(words, word)
        }
    }
    var found []string
    for _, word := range words {
        le := len(word)
        if bytes.IndexByte(word, 'k') >= 0 {
            lets := letters
            ok := true
            for i := 0; i < le; i++ {
                c := word[i]
                ix := sort.Search(len(lets), func(i int) bool { return lets[i] >= c })
                if ix < len(lets) && lets[ix] == c {
                    lets = lets[0:ix] + lets[ix+1:]
                } else {
                    ok = false
                    break
                }
            }
            if ok {
                found = append(found, string(word))
            }
        }
    }
    fmt.Println(""The following"", len(found), ""words are the solutions to the puzzle:"")
    fmt.Println(strings.Join(found, ""\n""))
 
    // optional extra
    mostFound := 0
    var mostWords9 []string
    var mostLetters []byte
    // extract 9 letter words
    var words9 [][]byte
    for _, word := range words {
        if len(word) == 9 {
            words9 = append(words9, word)
        }
    }
    // iterate through them
    for _, word9 := range words9 {
        letterBytes := make([]byte, len(word9))
        copy(letterBytes, word9)
        sort.Slice(letterBytes, func(i, j int) bool { return letterBytes[i] < letterBytes[j] })
        // get distinct bytes
        distinctBytes := []byte{letterBytes[0]}
        for _, b := range letterBytes[1:] {
            if b != distinctBytes[len(distinctBytes)-1] {
                distinctBytes = append(distinctBytes, b)
            }
        }
        distinctLetters := string(distinctBytes)
        for _, letter := range distinctLetters {
            found := 0
            letterByte := byte(letter)
            for _, word := range words {
                le := len(word)
                if bytes.IndexByte(word, letterByte) >= 0 {
                    lets := string(letterBytes)
                    ok := true
                    for i := 0; i < le; i++ {
                        c := word[i]
                        ix := sort.Search(len(lets), func(i int) bool { return lets[i] >= c })
                        if ix < len(lets) && lets[ix] == c {
                            lets = lets[0:ix] + lets[ix+1:]
                        } else {
                            ok = false
                            break
                        }
                    }
                    if ok {
                        found = found + 1
                    }
                }
            }
            if found > mostFound {
                mostFound = found
                mostWords9 = []string{string(word9)}
                mostLetters = []byte{letterByte}
            } else if found == mostFound {
                mostWords9 = append(mostWords9, string(word9))
                mostLetters = append(mostLetters, letterByte)
            }
        }
    }
    fmt.Println(""\nMost words found ="", mostFound)
    fmt.Println(""Nine letter words producing this total:"")
    for i := 0; i < len(mostWords9); i++ {
        fmt.Println(mostWords9[i], ""with central letter"", string(mostLetters[i]))
    }
}",3677,114
2810,http://rosettacode.org/wiki/Word_search,Word search,"A word search puzzle typically consists of a grid of letters in which words are hidden.

There are many varieties of word search puzzles. For the task at hand we will use a rectangular grid in which the words may be placed horizontally, vertically, or diagonally. The words may also be spelled backwards.

The words may overlap but are not allowed to zigzag, or wrap around.




Task 
Create a 10 by 10 word search and fill it using words from the unixdict. Use only words that are longer than 2, and contain no non-alphabetic characters.

The cells not used by the hidden words should contain the message: Rosetta Code, read from left to right, top to bottom. These letters should be somewhat evenly distributed over the grid, not clumped together. The message should be in upper case, the hidden words in lower case. All cells should either contain letters from the hidden words or from the message.

Pack a minimum of 25 words into the grid.

Print the resulting grid and the solutions.




Example
     0  1  2  3  4  5  6  7  8  9

0    n  a  y  r  y  R  e  l  m  f 
1    y  O  r  e  t  s  g  n  a  g 
2    t  n  e  d  i  S  k  y  h  E 
3    n  o  t  n  c  p  c  w  t  T 
4    a  l  s  u  u  n  T  m  a  x 
5    r  o  k  p  a  r  i  s  h  h 
6    a  A  c  f  p  a  e  a  c  C 
7    u  b  u  t  t  t  O  l  u  n 
8    g  y  h  w  a  D  h  p  m  u 
9    m  i  r  p  E  h  o  g  a  n 

parish     (3,5)(8,5)   gangster   (9,1)(2,1)
paucity    (4,6)(4,0)   guaranty   (0,8)(0,1)
prim       (3,9)(0,9)   huckster   (2,8)(2,1)
plasm      (7,8)(7,4)   fancy      (3,6)(7,2)
hogan      (5,9)(9,9)   nolo       (1,2)(1,5)
under      (3,4)(3,0)   chatham    (8,6)(8,0)
ate        (4,8)(6,6)   nun        (9,7)(9,9)
butt       (1,7)(4,7)   hawk       (9,5)(6,2)
why        (3,8)(1,8)   ryan       (3,0)(0,0)
fay        (9,0)(7,2)   much       (8,8)(8,5)
tar        (5,7)(5,5)   elm        (6,0)(8,0)
max        (7,4)(9,4)   pup        (5,3)(3,5)
mph        (8,8)(6,8)




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""log""
    ""math/rand""
    ""os""
    ""regexp""
    ""strings""
    ""time""
)
 
var dirs = [][]int{{1, 0}, {0, 1}, {1, 1}, {1, -1}, {-1, 0}, {0, -1}, {-1, -1}, {-1, 1}}
 
const (
    nRows    = 10
    nCols    = nRows
    gridSize = nRows * nCols
    minWords = 25
)
 
var (
    re1 = regexp.MustCompile(fmt.Sprintf(""^[a-z]{3,%d}$"", nRows))
    re2 = regexp.MustCompile(""[^A-Z]"")
)
 
type grid struct {
    numAttempts int
    cells       [nRows][nCols]byte
    solutions   []string
}
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func readWords(fileName string) []string {
    file, err := os.Open(fileName)
    check(err)
    defer file.Close()
    var words []string
    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
        word := strings.ToLower(strings.TrimSpace(scanner.Text()))
        if re1.MatchString(word) {
            words = append(words, word)
        }
    }
    check(scanner.Err())
    return words
}
 
func createWordSearch(words []string) *grid {
    var gr *grid
outer:
    for i := 1; i < 100; i++ {
        gr = new(grid)
        messageLen := gr.placeMessage(""Rosetta Code"")
        target := gridSize - messageLen
        cellsFilled := 0
        rand.Shuffle(len(words), func(i, j int) {
            words[i], words[j] = words[j], words[i]
        })
        for _, word := range words {
            cellsFilled += gr.tryPlaceWord(word)
            if cellsFilled == target {
                if len(gr.solutions) >= minWords {
                    gr.numAttempts = i
                    break outer
                } else { // grid is full but we didn't pack enough words, start over
                    break
                }
            }
        }
    }
    return gr
}
 
func (gr *grid) placeMessage(msg string) int {
    msg = strings.ToUpper(msg)
    msg = re2.ReplaceAllLiteralString(msg, """")
    messageLen := len(msg)
    if messageLen > 0 && messageLen < gridSize {
        gapSize := gridSize / messageLen
        for i := 0; i < messageLen; i++ {
            pos := i*gapSize + rand.Intn(gapSize)
            gr.cells[pos/nCols][pos%nCols] = msg[i]
        }
        return messageLen
    }
    return 0
}
 
func (gr *grid) tryPlaceWord(word string) int {
    randDir := rand.Intn(len(dirs))
    randPos := rand.Intn(gridSize)
    for dir := 0; dir < len(dirs); dir++ {
        dir = (dir + randDir) % len(dirs)
        for pos := 0; pos < gridSize; pos++ {
            pos = (pos + randPos) % gridSize
            lettersPlaced := gr.tryLocation(word, dir, pos)
            if lettersPlaced > 0 {
                return lettersPlaced
            }
        }
    }
    return 0
}
 
func (gr *grid) tryLocation(word string, dir, pos int) int {
    r := pos / nCols
    c := pos % nCols
    le := len(word)
 
    // check bounds
    if (dirs[dir][0] == 1 && (le+c) > nCols) ||
        (dirs[dir][0] == -1 && (le-1) > c) ||
        (dirs[dir][1] == 1 && (le+r) > nRows) ||
        (dirs[dir][1] == -1 && (le-1) > r) {
        return 0
    }
    overlaps := 0
 
    // check cells
    rr := r
    cc := c
    for i := 0; i < le; i++ {
        if gr.cells[rr][cc] != 0 && gr.cells[rr][cc] != word[i] {
            return 0
        }
        cc += dirs[dir][0]
        rr += dirs[dir][1]
    }
 
    // place
    rr = r
    cc = c
    for i := 0; i < le; i++ {
        if gr.cells[rr][cc] == word[i] {
            overlaps++
        } else {
            gr.cells[rr][cc] = word[i]
        }
        if i < le-1 {
            cc += dirs[dir][0]
            rr += dirs[dir][1]
        }
    }
 
    lettersPlaced := le - overlaps
    if lettersPlaced > 0 {
        sol := fmt.Sprintf(""%-10s (%d,%d)(%d,%d)"", word, c, r, cc, rr)
        gr.solutions = append(gr.solutions, sol)
    }
    return lettersPlaced
}
 
func printResult(gr *grid) {
    if gr.numAttempts == 0 {
        fmt.Println(""No grid to display"")
        return
    }
    size := len(gr.solutions)
    fmt.Println(""Attempts:"", gr.numAttempts)
    fmt.Println(""Number of words:"", size)
    fmt.Println(""\n     0  1  2  3  4  5  6  7  8  9"")
    for r := 0; r < nRows; r++ {
        fmt.Printf(""\n%d   "", r)
        for c := 0; c < nCols; c++ {
            fmt.Printf("" %c "", gr.cells[r][c])
        }
    }
    fmt.Println(""\n"")
    for i := 0; i < size-1; i += 2 {
        fmt.Printf(""%s   %s\n"", gr.solutions[i], gr.solutions[i+1])
    }
    if size%2 == 1 {
        fmt.Println(gr.solutions[size-1])
    }
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    unixDictPath := ""/usr/share/dict/words""
    printResult(createWordSearch(readWords(unixDictPath)))
}",4654,189
2836,http://rosettacode.org/wiki/XML/Output,XML/Output,"Create a function that takes a list of character names and a list of corresponding remarks and returns an XML document of <Character> elements each with a name attributes and each enclosing its remarks.
All <Character> elements are to be enclosed in turn, in an outer <CharacterRemarks> element.

As an example, calling the function with the three names of:

April
Tam O'Shanter
Emily
And three remarks of:

Bubbly: I'm > Tam and <= Emily
Burns: ""When chapman billies leave the street ...""
Short & shrift
Should produce the XML (but not necessarily with the indentation):

<CharacterRemarks>
    <Character name=""April"">Bubbly: I'm &gt; Tam and &lt;= Emily</Character>
    <Character name=""Tam O'Shanter"">Burns: ""When chapman billies leave the street ...""</Character>
    <Character name=""Emily"">Short &amp; shrift</Character>
</CharacterRemarks>
The document may include an <?xml?> declaration and document type declaration, but these are optional. If attempting this task by direct string manipulation, the implementation must include code to perform entity substitution for the characters that have entities defined in the XML 1.0 specification.

Note: the example is chosen to show correct escaping of XML strings.
Note too that although the task is written to take two lists of corresponding data, a single mapping/hash/dictionary of names to remarks is also acceptable.

Note to editors: Program output with escaped characters will be viewed as the character on the page so you need to 'escape-the-escapes' to make the RC entry display what would be shown in a plain text viewer (See this).
Alternately, output can be placed in <lang xml></lang> tags without any special treatment.
",#Go,Go,"package main
 
import (
    ""encoding/xml""
    ""fmt""
)
 
// Function required by task description.
func xRemarks(r CharacterRemarks) (string, error) {
    b, err := xml.MarshalIndent(r, """", ""    "")
    return string(b), err
}
 
// Task description allows the function to take ""a single mapping...""
// This data structure represents a mapping.
type CharacterRemarks struct {
    Character []crm
}
 
type crm struct {
    Name   string `xml:""name,attr""`
    Remark string `xml:"",chardata""`
}
 
func main() {
    x, err := xRemarks(CharacterRemarks{[]crm{
        {`April`, `Bubbly: I'm > Tam and <= Emily`},
        {`Tam O'Shanter`, `Burns: ""When chapman billies leave the street ...""`},
        {`Emily`, `Short & shrift`},
    }})
    if err != nil {
        x = err.Error()
    }
    fmt.Println(x)
}",802,35
2837,http://rosettacode.org/wiki/XML/Input,XML/Input,"Given the following XML fragment, extract the list of student names using whatever means desired. If the only viable method is to use XPath, refer the reader to the task XML and XPath.

<Students>
  <Student Name=""April"" Gender=""F"" DateOfBirth=""1989-01-02"" />
  <Student Name=""Bob"" Gender=""M""  DateOfBirth=""1990-03-04"" />
  <Student Name=""Chad"" Gender=""M""  DateOfBirth=""1991-05-06"" />
  <Student Name=""Dave"" Gender=""M""  DateOfBirth=""1992-07-08"">
    <Pet Type=""dog"" Name=""Rover"" />
  </Student>
  <Student DateOfBirth=""1993-09-10"" Gender=""F"" Name=""&#x00C9;mily"" />
</Students>
Expected Output

April
Bob
Chad
Dave
Émily
",#Go,Go,"package main
 
import (
    ""encoding/xml""
    ""fmt""
)
 
const XML_Data = `
<Students>
   <Student Name=""April"" Gender=""F"" DateOfBirth=""1989-01-02"" />
   <Student Name=""Bob"" Gender=""M""  DateOfBirth=""1990-03-04"" />
   <Student Name=""Chad"" Gender=""M""  DateOfBirth=""1991-05-06"" />
   <Student Name=""Dave"" Gender=""M""  DateOfBirth=""1992-07-08"">
      <Pet Type=""dog"" Name=""Rover"" />
   </Student>
   <Student DateOfBirth=""1993-09-10"" Gender=""F"" Name=""&#x00C9;mily"" />
</Students>
`
 
type Students struct {
    Student []Student
}
 
type Student struct {
    Name string `xml:"",attr""`
    //  Gender      string `xml:"",attr""`
    //  DateOfBirth string `xml:"",attr""`
    //  Pets        []Pet  `xml:""Pet""`
}
 
type Pet struct {
    Type string `xml:"",attr""`
    Name string `xml:"",attr""`
}
 
// xml.Unmarshal quietly skips well formed input with no corresponding
// member in the output data structure.  With Gender, DateOfBirth, and
// Pets commented out of the Student struct, as above, Student contains
// only Name, and this is the only value extracted from the input XML_Data.
func main() {
    var data Students
    err := xml.Unmarshal([]byte(XML_Data), &data)
    if err != nil {
        fmt.Println(err)
        return
    }
    for _, s := range data.Student {
        fmt.Println(s.Name)
    }
}",1301,50
2846,http://rosettacode.org/wiki/Window_management,Window management,"Treat windows or at least window identities as first class objects.

 Store window identities in variables, compare them for equality.
 Provide examples of performing some of the following:
 hide, 
 show, 
 close, 
 minimize, 
 maximize, 
 move,     and 
 resize a window. 


The window of interest may or may not have been created by your program.



",#Go,Go,"package main
 
import (
    ""github.com/gotk3/gotk3/gtk""
    ""log""
    ""time""
)
 
func check(err error, msg string) {
    if err != nil {
        log.Fatal(msg, err)
    }
}
 
func main() {
    gtk.Init(nil)
 
    window, err := gtk.WindowNew(gtk.WINDOW_TOPLEVEL)
    check(err, ""Unable to create window:"")
    window.SetResizable(true)
    window.SetTitle(""Window management"")
    window.SetBorderWidth(5)
    window.Connect(""destroy"", func() {
        gtk.MainQuit()
    })
 
    stackbox, err := gtk.BoxNew(gtk.ORIENTATION_VERTICAL, 10)
    check(err, ""Unable to create stack box:"")
 
    bmax, err := gtk.ButtonNewWithLabel(""Maximize"")
    check(err, ""Unable to create maximize button:"")
    bmax.Connect(""clicked"", func() {
        window.Maximize()
    })
 
    bunmax, err := gtk.ButtonNewWithLabel(""Unmaximize"")
    check(err, ""Unable to create unmaximize button:"")
    bunmax.Connect(""clicked"", func() {
        window.Unmaximize()
    })
 
    bicon, err := gtk.ButtonNewWithLabel(""Iconize"")
    check(err, ""Unable to create iconize button:"")
    bicon.Connect(""clicked"", func() {
        window.Iconify()
    })
 
    bdeicon, err := gtk.ButtonNewWithLabel(""Deiconize"")
    check(err, ""Unable to create deiconize button:"")
    bdeicon.Connect(""clicked"", func() {
        window.Deiconify()
    })
 
    bhide, err := gtk.ButtonNewWithLabel(""Hide"")
    check(err, ""Unable to create hide button:"")
    bhide.Connect(""clicked"", func() {
        // not working on Ubuntu 16.04 but window 'dims' after a few seconds
        window.Hide() 
        time.Sleep(10 * time.Second)
        window.Show()
    })
 
    bshow, err := gtk.ButtonNewWithLabel(""Show"")
    check(err, ""Unable to create show button:"")
    bshow.Connect(""clicked"", func() {
        window.Show()
    })
 
    bmove, err := gtk.ButtonNewWithLabel(""Move"")
    check(err, ""Unable to create move button:"")
    isShifted := false
    bmove.Connect(""clicked"", func() {
        w, h := window.GetSize()
        if isShifted {
            window.Move(w-10, h-10)
        } else {
            window.Move(w+10, h+10)
        }
        isShifted = !isShifted
    })
 
    bquit, err := gtk.ButtonNewWithLabel(""Quit"")
    check(err, ""Unable to create quit button:"")
    bquit.Connect(""clicked"", func() {
        window.Destroy()
    })
 
    stackbox.PackStart(bmax, true, true, 0)
    stackbox.PackStart(bunmax, true, true, 0)
    stackbox.PackStart(bicon, true, true, 0)
    stackbox.PackStart(bdeicon, true, true, 0)
    stackbox.PackStart(bhide, true, true, 0)
    stackbox.PackStart(bshow, true, true, 0)
    stackbox.PackStart(bmove, true, true, 0)
    stackbox.PackStart(bquit, true, true, 0)
 
    window.Add(stackbox)
    window.ShowAll()
    gtk.Main()
}",2727,100
2852,http://rosettacode.org/wiki/Wilson_primes_of_order_n,Wilson primes of order n,"Definition
A Wilson prime of order n is a prime number   p   such that   p2   exactly divides:

     (n − 1)! × (p − n)! − (− 1)n 



If   n   is   1,   the latter formula reduces to the more familiar:   (p - n)! + 1   where the only known examples for   p   are   5,   13,   and   563.



Task
Calculate and show on this page the Wilson primes, if any, for orders n = 1 to 11 inclusive and for primes p < 18   or,

if your language supports big integers, for p < 11,000.



Related task
 Primality by Wilson's theorem

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""rcu""
)
 
func main() {
    const LIMIT = 11000
    primes := rcu.Primes(LIMIT)
    facts := make([]*big.Int, LIMIT)
    facts[0] = big.NewInt(1)
    for i := int64(1); i < LIMIT; i++ {
        facts[i] = new(big.Int)
        facts[i].Mul(facts[i-1], big.NewInt(i))
    }
    sign := int64(1)
    f := new(big.Int)
    zero := new(big.Int)
    fmt.Println("" n:  Wilson primes"")
    fmt.Println(""--------------------"")
    for n := 1; n < 12; n++ {
        fmt.Printf(""%2d:  "", n)
        sign = -sign
        for _, p := range primes {
            if p < n {
                continue
            }
            f.Mul(facts[n-1], facts[p-n])
            f.Sub(f, big.NewInt(sign))
            p2 := int64(p * p)
            bp2 := big.NewInt(p2)
            if f.Rem(f, bp2).Cmp(zero) == 0 {
                fmt.Printf(""%d "", p)
            }
        }
        fmt.Println()
    }
}",933,40
2904,http://rosettacode.org/wiki/Window_creation/X11,Window creation/X11,"Task

Create a simple X11 application,   using an X11 protocol library such as Xlib or XCB,   that draws a box and   ""Hello World""   in a window.

Implementations of this task should   avoid using a toolkit   as much as possible.



",#Go,Go,"package main
 
// Copyright (c) 2013 Alex Kesling
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the ""Software""), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
 
import (
    ""log""
    ""github.com/jezek/xgb""
    ""github.com/jezek/xgb/xproto""
)
 
func main() {
    // Open the connection to the X server
    X, err := xgb.NewConn()
    if err != nil {
        log.Fatal(err)
    }
 
    // geometric objects
    points := []xproto.Point{
        {10, 10},
        {10, 20},
        {20, 10},
        {20, 20}};
 
    polyline := []xproto.Point{
        {50, 10},
        { 5, 20},     // rest of points are relative
        {25,-20},
        {10, 10}};
 
    segments := []xproto.Segment{
        {100, 10, 140, 30},
        {110, 25, 130, 60}};
 
    rectangles := []xproto.Rectangle{
        { 10, 50, 40, 20},
        { 80, 50, 10, 40}};
 
    arcs := []xproto.Arc{
        {10, 100, 60, 40, 0, 90 << 6},
        {90, 100, 55, 40, 0, 270 << 6}};
 
    setup := xproto.Setup(X)
    // Get the first screen
    screen := setup.DefaultScreen(X)
 
    // Create black (foreground) graphic context
    foreground, _ := xproto.NewGcontextId(X)
    mask := uint32(xproto.GcForeground | xproto.GcGraphicsExposures)
    values := []uint32{screen.BlackPixel, 0}
    xproto.CreateGC(X, foreground, xproto.Drawable(screen.Root), mask, values)
 
    // Ask for our window's Id
    win, _ := xproto.NewWindowId(X)
    winDrawable := xproto.Drawable(win)
 
    // Create the window
    mask = uint32(xproto.CwBackPixel | xproto.CwEventMask)
    values = []uint32{screen.WhitePixel, xproto.EventMaskExposure}
    xproto.CreateWindow(X,                  // Connection
            screen.RootDepth,               // Depth
            win,                            // Window Id
            screen.Root,                    // Parent Window
            0, 0,                           // x, y
            150, 150,                       // width, height
            10,                             // border_width
            xproto.WindowClassInputOutput,  // class
            screen.RootVisual,              // visual
            mask, values)                   // masks
 
    // Map the window on the screen
    xproto.MapWindow(X, win)
 
    for {
        evt, err := X.WaitForEvent()
        switch evt.(type) {
            case xproto.ExposeEvent:
                /* We draw the points */
                xproto.PolyPoint(X, xproto.CoordModeOrigin, winDrawable, foreground, points)
 
                /* We draw the polygonal line */
                xproto.PolyLine(X, xproto.CoordModePrevious, winDrawable, foreground, polyline)
 
                /* We draw the segments */
                xproto.PolySegment(X, winDrawable, foreground, segments)
 
                /* We draw the rectangles */
                xproto.PolyRectangle(X, winDrawable, foreground, rectangles)
 
                /* We draw the arcs */
                xproto.PolyArc(X, winDrawable, foreground, arcs)
 
            default:
                /* Unknown event type, ignore it */
        }
 
        if err != nil {
            log.Fatal(err)
        }
    }
    return
}",3964,117
2923,http://rosettacode.org/wiki/Write_language_name_in_3D_ASCII,Write language name in 3D ASCII,"Task

Write/display a language's name in 3D ASCII.



(We can leave the definition of ""3D ASCII"" fuzzy,
so long as the result is interesting or amusing,
not a cheap hack to satisfy the task.)



Related tasks

 draw a sphere
 draw a cuboid
 draw a rotating cube
 draw a Deathstar

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
var lean = font{
    height:  5,
    slant:   1,
    spacing: 2,
    m: map[rune][]string{
        'G': []string{
            `  _/_/_/`,
            `_/      `,
            `_/  _/_/`,
            `_/    _/`,
            `  _/_/_/`,
        },
        'o': []string{
            `        `,
            `  _/_/  `,
            `_/    _/`,
            `_/    _/`,
            `  _/_/  `,
        },
    }}
 
var smallKeyboard = font{
    height:  4,
    slant:   0,
    spacing: -1,
    m: map[rune][]string{
        'G': []string{
            ` ____ `,
            `||G ||`,
            `||__||`,
            `|/__\|`,
        },
        'o': []string{
            ` ____ `,
            `||o ||`,
            `||__||`,
            `|/__\|`,
        },
    }}
 
type font struct {
    height  int
    slant   int
    spacing int
    m       map[rune][]string
}
 
func render(s string, f font) string {
    rows := make([]string, f.height)
    if f.slant != 0 {
        start := 0
        if f.slant > 0 {
            start = f.height
        }
        for i := range rows {
            rows[i] = strings.Repeat("" "", (start-i)*f.slant)
        }
    }
    if f.spacing >= 0 {
        spacing := strings.Repeat("" "", f.spacing)
        for j, c := range s {
            for i, r := range f.m[c] {
                if j > 0 {
                    r = spacing + r
                }
                rows[i] += r
            }
        }
    } else {
        overlap := -f.spacing
        for j, c := range s {
            for i, r := range f.m[c] {
                if j > 0 {
                    r = r[overlap:]
                }
                rows[i] += r
            }
        }
    }
    return strings.Join(rows, ""\n"")
}
 
func main() {
    fmt.Println(render(""Go"", lean))
    fmt.Println(render(""Go"", smallKeyboard))
}",1868,93
3015,http://rosettacode.org/wiki/Wieferich_primes,Wieferich primes,"

 This page uses content from Wikipedia. The original article was at Wieferich prime. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In number theory, a Wieferich prime is a prime number  p  such that  p2  evenly divides  2(p − 1) − 1 .



It is conjectured that there are infinitely many Wieferich primes, but as of March 2021,only two have been identified.



Task 
 Write a routine (function procedure, whatever) to find Wieferich primes.
 Use that routine to identify and display all of the Wieferich primes less than 5000.


See also
 OEIS A001220 - Wieferich primes

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""rcu""
)
 
func main() {
    primes := rcu.Primes(5000)
    zero := new(big.Int)
    one := big.NewInt(1)
    num := new(big.Int)
    fmt.Println(""Wieferich primes < 5,000:"")
    for _, p := range primes {
        num.Set(one)
        num.Lsh(num, uint(p-1))
        num.Sub(num, one)
        den := big.NewInt(int64(p * p))
        if num.Rem(num, den).Cmp(zero) == 0 {
            fmt.Println(rcu.Commatize(p))
        }
    }
}",482,24
3147,http://rosettacode.org/wiki/Weird_numbers,Weird numbers,"In number theory, a weird number is a natural number that is abundant but not semiperfect (and therefore not perfect either).

In other words, the sum of the proper divisors of the number (divisors including 1 but not itself) is greater than the number itself (the number is abundant), but no subset of those divisors sums to the number itself (the number is not semiperfect).

For example:

 12 is not a weird number.
 It is abundant; its proper divisors 1, 2, 3, 4, 6 sum to 16 (which is > 12),
 but it is semiperfect, e.g.:     6 + 4 + 2 == 12.
 70 is a weird number.
 It is abundant; its proper divisors 1, 2, 5, 7, 10, 14, 35 sum to 74 (which is > 70),
 and there is no subset of proper divisors that sum to 70.


Task

Find and display, here on this page, the first 25 weird numbers.



Related tasks

 Abundant, deficient and perfect number classifications
 Proper divisors


See also

 OEIS: A006037 weird numbers
 Wikipedia: weird number
 MathWorld: weird number

",#Go,Go,"package main
 
import ""fmt""
 
func divisors(n int) []int {
    divs := []int{1}
    divs2 := []int{}
    for i := 2; i*i <= n; i++ {
        if n%i == 0 {
            j := n / i
            divs = append(divs, i)
            if i != j {
                divs2 = append(divs2, j)
            }
        }
    }
    for i := len(divs) - 1; i >= 0; i-- {
        divs2 = append(divs2, divs[i])
    }
    return divs2
}
 
func abundant(n int, divs []int) bool {
    sum := 0
    for _, div := range divs {
        sum += div
    }
    return sum > n
}
 
func semiperfect(n int, divs []int) bool {
    le := len(divs)
    if le > 0 {
        h := divs[0]
        t := divs[1:]
        if n < h {
            return semiperfect(n, t)
        } else {
            return n == h || semiperfect(n-h, t) || semiperfect(n, t)
        }
    } else {
        return false
    }
} 
 
func sieve(limit int) []bool {
    // false denotes abundant and not semi-perfect.
    // Only interested in even numbers >= 2
    w := make([]bool, limit)
    for i := 2; i < limit; i += 2 {
        if w[i] {
            continue
        }
        divs := divisors(i)
        if !abundant(i, divs) {
            w[i] = true
        } else if semiperfect(i, divs) {
            for j := i; j < limit; j += i {
                w[j] = true
            }
        }
    }
    return w
}
 
func main() {
    w := sieve(17000)
    count := 0
    const max = 25
    fmt.Println(""The first 25 weird numbers are:"")
    for n := 2; count < max; n += 2 {
        if !w[n] {
            fmt.Printf(""%d "", n)
            count++
        }
    }
    fmt.Println()
}",1619,78
3198,http://rosettacode.org/wiki/Window_creation,Window creation,"Display a GUI window. The window need not have any contents, but should respond to requests to be closed.
",#Go,Go,"package main
 
import (
    ""github.com/mattn/go-gtk/glib""
    ""github.com/mattn/go-gtk/gtk""
)
 
func main() {
    gtk.Init(nil)
    window := gtk.NewWindow(gtk.WINDOW_TOPLEVEL)
    window.Connect(""destroy"",
        func(*glib.CallbackContext) { gtk.MainQuit() }, """")
    window.Show()
    gtk.Main()
}",302,15
3201,http://rosettacode.org/wiki/Word_wrap,Word wrap,"Even today, with proportional fonts and complex layouts, there are still cases where you need to wrap text at a specified column.



Basic task

The basic task is to wrap a paragraph of text in a simple way in your language.

If there is a way to do this that is built-in, trivial, or provided in a standard library, show that. Otherwise implement the minimum length greedy algorithm from Wikipedia.

Show your routine working on a sample of text at two different wrap columns.



Extra credit

Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX algorithm.
If your language provides this, you get easy extra credit,
but you must reference documentation indicating that the algorithm
is something better than a simple minimum length algorithm.

If you have both basic and extra credit solutions, show an example where
the two algorithms give different results.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func wrap(text string, lineWidth int) (wrapped string) {
    words := strings.Fields(text)
    if len(words) == 0 {
        return
    }
    wrapped = words[0]
    spaceLeft := lineWidth - len(wrapped)
    for _, word := range words[1:] {
        if len(word)+1 > spaceLeft {
            wrapped += ""\n"" + word
            spaceLeft = lineWidth - len(word)
        } else {
            wrapped += "" "" + word
            spaceLeft -= 1 + len(word)
        }
    }
    return
}
 
var frog = `
In olden times when wishing still helped one, there lived a king
whose daughters were all beautiful, but the youngest was so beautiful
that the sun itself, which has seen so much, was astonished whenever
it shone in her face.  Close by the king's castle lay a great dark
forest, and under an old lime-tree in the forest was a well, and when
the day was very warm, the king's child went out into the forest and
sat down by the side of the cool fountain, and when she was bored she
took a golden ball, and threw it up on high and caught it, and this
ball was her favorite plaything.`
 
func main() {
    fmt.Println(""wrapped at 80:"")
    fmt.Println(wrap(frog, 80))
    fmt.Println(""wrapped at 72:"")
    fmt.Println(wrap(frog, 72))
}",1274,43
3243,http://rosettacode.org/wiki/Wireworld,Wireworld,"Wireworld
Conway's Game of Life
It is capable of doing sophisticated computations with appropriate programs
(it is actually Turing complete),
and is much simpler to program for.

A Wireworld arena consists of a Cartesian grid of cells,
each of which can be in one of four states.
All cell transitions happen simultaneously.

The cell transition rules are this:



 Input State

 Output State

 Condition


 empty

 empty




 electron head 

 electron tail 




 electron tail 

 conductor




 conductor

 electron head 

 if 1 or 2 cells in the neighborhood of the cell are in the state “electron head”


 conductor

 conductor

 otherwise



Task

Create a program that reads a Wireworld program from a file and displays an animation of the processing. Here is a sample description file (using ""H"" for an electron head, ""t"" for a tail, ""."" for a conductor and a space for empty) you may wish to test with, which demonstrates two cycle-3 generators and an inhibit gate:

tH.........
.   .
   ...
.   .
Ht.. ......

While text-only implementations of this task are possible, mapping cells to pixels is advisable if you wish to be able to display large designs. The logic is not significantly more complex.



",#Go,Go,"package main
 
import (
    ""bytes""
    ""fmt""
    ""io/ioutil""
    ""strings""
)
 
var rows, cols int // extent of input configuration
var rx, cx int     // grid extent (includes border)
var mn []int       // offsets of moore neighborhood
 
func main() {
    // read input configuration from file
    src, err := ioutil.ReadFile(""ww.config"")
    if err != nil {
        fmt.Println(err)
        return
    }
    srcRows := bytes.Split(src, []byte{'\n'})
 
    // compute package variables
    rows = len(srcRows)
    for _, r := range srcRows {
        if len(r) > cols {
            cols = len(r)
        }
    }
    rx, cx = rows+2, cols+2
    mn = []int{-cx-1, -cx, -cx+1, -1, 1, cx-1, cx, cx+1}
 
    // allocate two grids and copy input into first grid
    odd := make([]byte, rx*cx)
    even := make([]byte, rx*cx)
    for ri, r := range srcRows {
        copy(odd[(ri+1)*cx+1:], r)
    }
 
    // run
    for {
        print(odd)
        step(even, odd)
        fmt.Scanln()
 
        print(even)
        step(odd, even)
        fmt.Scanln()
    }
}
 
func print(grid []byte) {
    fmt.Println(strings.Repeat(""__"", cols))
    fmt.Println()
    for r := 1; r <= rows; r++ {
        for c := 1; c <= cols; c++ {
            if grid[r*cx+c] == 0 {
                fmt.Print(""  "")
            } else {
                fmt.Printf("" %c"", grid[r*cx+c])
            }
        }
        fmt.Println()
    }
}
 
func step(dst, src []byte) {
    for r := 1; r <= rows; r++ {
        for c := 1; c <= cols; c++ {
            x := r*cx + c
            dst[x] = src[x]
            switch dst[x] {
            case 'H':
                dst[x] = 't'
            case 't':
                dst[x] = '.'
            case '.':
                var nn int
                for _, n := range mn {
                    if src[x+n] == 'H' {
                        nn++
                    }
                }
                if nn == 1 || nn == 2 {
                    dst[x] = 'H'
                }
            }
        }
    }
}",2009,90
3332,http://rosettacode.org/wiki/Web_scraping,Web scraping,"Task

Create a program that downloads the time from this URL:   http://tycho.usno.navy.mil/cgi-bin/timer.pl   and then prints the current UTC time by extracting just the UTC time from the web page's HTML. Alternatively, if the above url is not working, grab the first date/time off this page's talk page.



If possible, only use libraries that come at no extra monetary cost with the programming language and that are widely available and popular such as CPAN for Perl or Boost for C++.



",#Go,Go,"package main
 
import (
    ""bytes""
    ""encoding/xml""
    ""fmt""
    ""io""
    ""net/http""
    ""regexp""
    ""time""
)
 
func main() {
    resp, err := http.Get(""http://tycho.usno.navy.mil/cgi-bin/timer.pl"")
    if err != nil {
        fmt.Println(err) // connection or request fail
        return
    }
    defer resp.Body.Close()
    var us string
    var ux int
    utc := []byte(""UTC"")
    for p := xml.NewDecoder(resp.Body); ; {
        t, err := p.RawToken()
        switch err {
        case nil:
        case io.EOF:
            fmt.Println(""UTC not found"")
            return
        default:
            fmt.Println(err) // read or parse fail
            return
        }
        if ub, ok := t.(xml.CharData); ok {
            if ux = bytes.Index(ub, utc); ux != -1 {
                // success: found a line with the string ""UTC""
                us = string([]byte(ub))
                break
            }
        }
    }
    // first thing to try: parsing the expected date format
    if t, err := time.Parse(""Jan. 2, 15:04:05 UTC"", us[:ux+3]); err == nil {
        fmt.Println(""parsed UTC:"", t.Format(""January 2, 15:04:05""))
        return
    }
    // fallback: search for anything looking like a time and print that
    tx := regexp.MustCompile(""[0-2]?[0-9]:[0-5][0-9]:[0-6][0-9]"")
    if justTime := tx.FindString(us); justTime > """" {
        fmt.Println(""found UTC:"", justTime)
        return
    }
    // last resort: just print the whole element containing ""UTC"" and hope
    // there is a human readable time in there somewhere.
    fmt.Println(us)
}",1567,56
3333,http://rosettacode.org/wiki/Word_frequency,Word frequency,"Task

Given a text file and an integer   n,   print/display the   n   most
common words in the file   (and the number of their occurrences)   in decreasing frequency.



For the purposes of this task:

   A word is a sequence of one or more contiguous letters.
   You are free to define what a   letter   is. 
   Underscores, accented letters, apostrophes, hyphens, and other special characters can be handled at your discretion.
   You may treat a compound word like   well-dressed   as either one word or two. 
   The word   it's   could also be one or two words as you see fit. 
   You may also choose not to support non US-ASCII characters. 
   Assume words will not span multiple lines.
   Don't worry about normalization of word spelling differences. 
   Treat   color   and   colour   as two distinct words.
   Uppercase letters are considered equivalent to their lowercase counterparts.
   Words of equal frequency can be listed in any order.
   Feel free to explicitly state the thoughts behind the program decisions.


Show example output using Les Misérables from Project Gutenberg as the text file input and display the top   10   most used words.



History

This task was originally taken from programming pearls from Communications of the ACM June 1986 Volume 29 Number 6
where this problem is solved by Donald Knuth using literate programming and then critiqued by Doug McIlroy,
demonstrating solving the problem in a 6 line Unix shell script (provided as an example below).



References

McIlroy's program



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""io/ioutil""
    ""log""
    ""regexp""
    ""sort""
    ""strings""
)
 
type keyval struct {
    key string
    val int
}
 
func main() {
    reg := regexp.MustCompile(`\p{Ll}+`)
    bs, err := ioutil.ReadFile(""135-0.txt"")
    if err != nil {
        log.Fatal(err)
    }
    text := strings.ToLower(string(bs))
    matches := reg.FindAllString(text, -1)
    groups := make(map[string]int)
    for _, match := range matches {
        groups[match]++
    }
    var keyvals []keyval
    for k, v := range groups {
        keyvals = append(keyvals, keyval{k, v})
    }
    sort.Slice(keyvals, func(i, j int) bool {
        return keyvals[i].val > keyvals[j].val
    })
    fmt.Println(""Rank  Word  Frequency"")
    fmt.Println(""====  ====  ========="")
    for rank := 1; rank <= 10; rank++ {
        word := keyvals[rank-1].key
        freq := keyvals[rank-1].val
        fmt.Printf(""%2d    %-4s    %5d\n"", rank, word, freq)
    }
}",958,43
3644,http://rosettacode.org/wiki/War_card_game,War card game,"War Card Game

Simulate the card game War. Use the Bicycle playing card manufacturer's rules. Show a game as played. User input is optional.

References:

 Bicycle card company: War game site
 Wikipedia: War (card game)
Related tasks:

 Playing cards
 Card shuffles
 Deal cards for FreeCell
 Poker hand_analyser
 Go Fish

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
var suits = []string{""♣"", ""♦"", ""♥"", ""♠""}
var faces = []string{""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9"", ""T"", ""J"", ""Q"", ""K"", ""A""}
var cards = make([]string, 52)
var ranks = make([]int, 52)
 
func init() {
    for i := 0; i < 52; i++ {
        cards[i] = fmt.Sprintf(""%s%s"", faces[i%13], suits[i/13])
        ranks[i] = i % 13
    }
}
 
func war() {
    deck := make([]int, 52)
    for i := 0; i < 52; i++ {
        deck[i] = i
    }
    rand.Shuffle(52, func(i, j int) {
        deck[i], deck[j] = deck[j], deck[i]
    })
    hand1 := make([]int, 26, 52)
    hand2 := make([]int, 26, 52)
    for i := 0; i < 26; i++ {
        hand1[25-i] = deck[2*i]
        hand2[25-i] = deck[2*i+1]
    }
    for len(hand1) > 0 && len(hand2) > 0 {
        card1 := hand1[0]
        copy(hand1[0:], hand1[1:])
        hand1[len(hand1)-1] = 0
        hand1 = hand1[0 : len(hand1)-1]
        card2 := hand2[0]
        copy(hand2[0:], hand2[1:])
        hand2[len(hand2)-1] = 0
        hand2 = hand2[0 : len(hand2)-1]
        played1 := []int{card1}
        played2 := []int{card2}
        numPlayed := 2
        for {
            fmt.Printf(""%s\t%s\t"", cards[card1], cards[card2])
            if ranks[card1] > ranks[card2] {
                hand1 = append(hand1, played1...)
                hand1 = append(hand1, played2...)
                fmt.Printf(""Player 1 takes the %d cards. Now has %d.\n"", numPlayed, len(hand1))
                break
            } else if ranks[card1] < ranks[card2] {
                hand2 = append(hand2, played2...)
                hand2 = append(hand2, played1...)
                fmt.Printf(""Player 2 takes the %d cards. Now has %d.\n"", numPlayed, len(hand2))
                break
            } else {
                fmt.Println(""War!"")
                if len(hand1) < 2 {
                    fmt.Println(""Player 1 has insufficient cards left."")
                    hand2 = append(hand2, played2...)
                    hand2 = append(hand2, played1...)
                    hand2 = append(hand2, hand1...)
                    hand1 = hand1[0:0]
                    break
                }
                if len(hand2) < 2 {
                    fmt.Println(""Player 2 has insufficient cards left."")
                    hand1 = append(hand1, played1...)
                    hand1 = append(hand1, played2...)
                    hand1 = append(hand1, hand2...)
                    hand2 = hand2[0:0]
                    break
                }
                fdCard1 := hand1[0] // face down card
                card1 = hand1[1]    // face up card
                copy(hand1[0:], hand1[2:])
                hand1[len(hand1)-1] = 0
                hand1[len(hand1)-2] = 0
                hand1 = hand1[0 : len(hand1)-2]
                played1 = append(played1, fdCard1, card1)
                fdCard2 := hand2[0] // face down card
                card2 = hand2[1]    // face up card
                copy(hand2[0:], hand2[2:])
                hand2[len(hand2)-1] = 0
                hand2[len(hand2)-2] = 0
                hand2 = hand2[0 : len(hand2)-2]
                played2 = append(played2, fdCard2, card2)
                numPlayed += 4
                fmt.Println(""? \t? \tFace down cards."")
            }
        }
    }
    if len(hand1) == 52 {
        fmt.Println(""Player 1 wins the game!"")
    } else {
        fmt.Println(""Player 2 wins the game!"")
    }
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    war()
}",3511,106
3750,http://rosettacode.org/wiki/Vogel%27s_approximation_method,Vogel's approximation method,"Vogel's Approximation Method (VAM) is a technique for finding a good initial feasible solution to an allocation problem.

The powers that be have identified 5 tasks that need to be solved urgently. Being imaginative chaps, they have called them “A”, “B”, “C”, “D”, and “E”. They estimate that:

 A will require 30 hours of work,
 B will require 20 hours of work,
 C will require 70 hours of work,
 D will require 30 hours of work, and
 E will require 60 hours of work.
They have identified 4 contractors willing to do the work, called “W”, “X”, “Y”, and “Z”.

 W has 50 hours available to commit to working,
 X has 60 hours available,
 Y has 50 hours available, and
 Z has 50 hours available.
The cost per hour for each contractor for each task is summarized by the following table:

   A  B  C  D  E
W 16 16 13 22 17
X 14 14 13 19 15
Y 19 19 20 23 50
Z 50 12 50 15 11

The task is to use VAM to allocate contractors to tasks. It scales to large problems, so ideally keep sorts out of the iterative cycle. It works as follows:

Step 1: Balance the given transportation problem if either (total supply>total demand) or (total supply<total demand)
Step 2: Determine the penalty cost for each row and column by subtracting the lowest cell cost in the row or column from the next lowest cell cost in the same row or column.
Step 3: Select the row or column with the highest penalty cost (breaking ties arbitrarily or choosing the lowest-cost cell).
Step 4: Allocate as much as possible to the feasible cell with the lowest transportation cost in the row or column with the highest penalty cost.
Step 5: Repeat steps 2, 3 and 4 until all requirements have been meet.
Step 6: Compute total transportation cost for the feasible allocations.
For this task assume that the model is balanced.

For each task and contractor (row and column above) calculating the difference between the smallest two values produces:

        A       B       C       D       E       W       X       Y       Z
1       2       2       0       4       4       3       1       0       1   E-Z(50)

Determine the largest difference (D or E above). In the case of ties I shall choose the one with the lowest price (in this case E because the lowest price for D is Z=15, whereas for E it is Z=11). For your choice determine the minimum cost (chosen E above so Z=11 is chosen now). Allocate as much as possible from Z to E (50 in this case limited by Z's supply).
Adjust the supply and demand accordingly. If demand or supply becomes 0 for a given task or contractor it plays no further part. In this case Z is out of it. If you choose arbitrarily, and chose D see here for the working.

Repeat until all supply and demand is met:

2       2       2       0       3       2       3       1       0       -   C-W(50)
3       5       5       7       4      35       -       1       0       -   E-X(10)
4       5       5       7       4       -       -       1       0       -   C-X(20)
5       5       5       -       4       -       -       0       0       -   A-X(30)
6       -      19       -      23       -       -       -       4       -   D-Y(30)
        -       -       -       -       -       -       -       -       -   B-Y(20)

Finally calculate the cost of your solution. In the example given it is £3100:

   A  B  C  D  E
W       50
X 30    20    10
Y    20    30
Z             50

The optimal solution determined by GLPK is £3100:

   A  B  C  D  E
W       50
X 10 20 20    10
Y 20       30
Z             50

Cf.
 Transportation problem",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
var supply = []int{50, 60, 50, 50}
var demand = []int{30, 20, 70, 30, 60}
 
var costs = make([][]int, 4)
 
var nRows = len(supply)
var nCols = len(demand)
 
var rowDone = make([]bool, nRows)
var colDone = make([]bool, nCols)
var results = make([][]int, nRows)
 
func init() {
    costs[0] = []int{16, 16, 13, 22, 17}
    costs[1] = []int{14, 14, 13, 19, 15}
    costs[2] = []int{19, 19, 20, 23, 50}
    costs[3] = []int{50, 12, 50, 15, 11}
 
    for i := 0; i < len(results); i++ {
        results[i] = make([]int, nCols)
    }
}
 
func nextCell() []int {
    res1 := maxPenalty(nRows, nCols, true)
    res2 := maxPenalty(nCols, nRows, false)
    switch {
    case res1[3] == res2[3]:
        if res1[2] < res2[2] {
            return res1
        } else {
            return res2
        }
    case res1[3] > res2[3]:
        return res2
    default:
        return res1
    }
}
 
func diff(j, l int, isRow bool) []int {
    min1 := math.MaxInt32
    min2 := min1
    minP := -1
    for i := 0; i < l; i++ {
        var done bool
        if isRow {
            done = colDone[i]
        } else {
            done = rowDone[i]
        }
        if done {
            continue
        }
        var c int
        if isRow {
            c = costs[j][i]
        } else {
            c = costs[i][j]
        }
        if c < min1 {
            min2, min1, minP = min1, c, i
        } else if c < min2 {
            min2 = c
        }
    }
    return []int{min2 - min1, min1, minP}
}
 
func maxPenalty(len1, len2 int, isRow bool) []int {
    md := math.MinInt32
    pc, pm, mc := -1, -1, -1
    for i := 0; i < len1; i++ {
        var done bool
        if isRow {
            done = rowDone[i]
        } else {
            done = colDone[i]
        }
        if done {
            continue
        }
        res := diff(i, len2, isRow)
        if res[0] > md {
            md = res[0]  // max diff
            pm = i       // pos of max diff
            mc = res[1]  // min cost
            pc = res[2]  // pos of min cost
        }
    }
    if isRow {
        return []int{pm, pc, mc, md}
    }
    return []int{pc, pm, mc, md}
}
 
func main() {
    supplyLeft := 0
    for i := 0; i < len(supply); i++ {
        supplyLeft += supply[i]
    }
    totalCost := 0
    for supplyLeft > 0 {
        cell := nextCell()
        r, c := cell[0], cell[1]
        q := demand[c]
        if q > supply[r] {
            q = supply[r]
        }
        demand[c] -= q
        if demand[c] == 0 {
            colDone[c] = true
        }
        supply[r] -= q
        if supply[r] == 0 {
            rowDone[r] = true
        }
        results[r][c] = q
        supplyLeft -= q
        totalCost += q * costs[r][c]
    }
 
    fmt.Println(""    A   B   C   D   E"")
    for i, result := range results {
        fmt.Printf(""%c"", 'W' + i)
        for _, item := range result {
            fmt.Printf(""  %2d"", item)
        }
        fmt.Println()
    }
    fmt.Println(""\nTotal cost ="", totalCost)
}",3029,139
3826,http://rosettacode.org/wiki/Walk_a_directory/Non-recursively,Walk a directory/Non-recursively,"Task

Walk a given directory and print the names of files matching a given pattern.

(How is ""pattern"" defined? substring match? DOS pattern? BASH pattern? ZSH pattern? Perl regular expression?)


Note: This task is for non-recursive methods.   These tasks should read a single directory, not an entire directory tree.

Note: Please be careful when running any code presented here.



Related task

   Walk Directory Tree   (read entire directory tree). 

",#Go,Go,"package main
 
import (
    ""fmt""
    ""path/filepath""
)
 
func main() {
    fmt.Println(filepath.Glob(""*.go""))
}",112,10
3831,http://rosettacode.org/wiki/Voronoi_diagram,Voronoi diagram,"A Voronoi diagram is a diagram consisting of a number of sites.

Each Voronoi site s also has a Voronoi cell consisting of all points closest to s.



Task

Demonstrate how to generate and display a Voroni diagram.



See algo K-means++ clustering.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""image""
    ""image/color""
    ""image/draw""
    ""image/png""
    ""math/rand""
    ""os""
    ""time""
)
 
const (
    imageWidth  = 300
    imageHeight = 200
    nSites      = 10
)
 
func main() {
    writePngFile(generateVoronoi(randomSites()))
}
 
func generateVoronoi(sx, sy []int) image.Image {
    // generate a random color for each site
    sc := make([]color.NRGBA, nSites)
    for i := range sx {
        sc[i] = color.NRGBA{uint8(rand.Intn(256)), uint8(rand.Intn(256)),
            uint8(rand.Intn(256)), 255}
    }
 
    // generate diagram by coloring each pixel with color of nearest site
    img := image.NewNRGBA(image.Rect(0, 0, imageWidth, imageHeight))
    for x := 0; x < imageWidth; x++ {
        for y := 0; y < imageHeight; y++ {
            dMin := dot(imageWidth, imageHeight)
            var sMin int
            for s := 0; s < nSites; s++ {
                if d := dot(sx[s]-x, sy[s]-y); d < dMin {
                    sMin = s
                    dMin = d
                }
            }
            img.SetNRGBA(x, y, sc[sMin])
        }
    }
    // mark each site with a black box
    black := image.NewUniform(color.Black)
    for s := 0; s < nSites; s++ {
        draw.Draw(img, image.Rect(sx[s]-2, sy[s]-2, sx[s]+2, sy[s]+2),
            black, image.ZP, draw.Src)
    }
    return img
}
 
func dot(x, y int) int {
    return x*x + y*y
}
 
func randomSites() (sx, sy []int) {
    rand.Seed(time.Now().Unix())
    sx = make([]int, nSites)
    sy = make([]int, nSites)
    for i := range sx {
        sx[i] = rand.Intn(imageWidth)
        sy[i] = rand.Intn(imageHeight)
    }
    return
}
 
func writePngFile(img image.Image) {
    f, err := os.Create(""voronoi.png"")
    if err != nil {
        fmt.Println(err)
        return
    }
    if err = png.Encode(f, img); err != nil {
        fmt.Println(err)
    }
    if err = f.Close(); err != nil {
        fmt.Println(err)
    }
}",1942,83
3854,http://rosettacode.org/wiki/Vigen%C3%A8re_cipher/Cryptanalysis,Vigenère cipher/Cryptanalysis,"Given some text you suspect has been encrypted with a Vigenère cipher, extract the key and plaintext. There are several methods for doing this. See the Wikipedia entry for more information. Use the following encrypted text:

MOMUD EKAPV TQEFM OEVHP AJMII CDCTI FGYAG JSPXY ALUYM NSMYH
VUXJE LEPXJ FXGCM JHKDZ RYICU HYPUS PGIGM OIYHF WHTCQ KMLRD
ITLXZ LJFVQ GHOLW CUHLO MDSOE KTALU VYLNZ RFGBX PHVGA LWQIS
FGRPH JOOFW GUBYI LAPLA LCAFA AMKLG CETDW VOELJ IKGJB XPHVG
ALWQC SNWBU BYHCU HKOCE XJEYK BQKVY KIIEH GRLGH XEOLW AWFOJ
ILOVV RHPKD WIHKN ATUHN VRYAQ DIVHX FHRZV QWMWV LGSHN NLVZS
JLAKI FHXUF XJLXM TBLQV RXXHR FZXGV LRAJI EXPRV OSMNP KEPDT
LPRWM JAZPK LQUZA ALGZX GVLKL GJTUI ITDSU REZXJ ERXZS HMPST
MTEOE PAPJH SMFNB YVQUZ AALGA YDNMP AQOWT UHDBV TSMUE UIMVH
QGVRW AEFSP EMPVE PKXZY WLKJA GWALT VYYOB YIXOK IHPDS EVLEV
RVSGB JOGYW FHKBL GLXYA MVKIS KIEHY IMAPX UOISK PVAGN MZHPW
TTZPV XFCCD TUHJH WLAPF YULTB UXJLN SIJVV YOVDJ SOLXG TGRVO
SFRII CTMKO JFCQF KTINQ BWVHG TENLH HOGCS PSFPV GJOKM SIFPR
ZPAAS ATPTZ FTPPD PORRF TAXZP KALQA WMIUD BWNCT LEFKO ZQDLX
BUXJL ASIMR PNMBF ZCYLV WAPVF QRHZV ZGZEF KBYIO OFXYE VOWGB
BXVCB XBAWG LQKCM ICRRX MACUO IKHQU AJEGL OIJHH XPVZW JEWBA
FWAML ZZRXJ EKAHV FASMU LVVUT TGK

Letter frequencies for English can be found here.

Specifics for this task:

 Take only the ciphertext as input. You can assume it's all capitalized and has no punctuation, but it might have whitespace.
 Assume the plaintext is written in English.
 Find and output the key.
 Use that key to decrypt and output the original plaintext. Maintaining the whitespace from the ciphertext is optional.
 The algorithm doesn't have to be perfect (which may not be possible) but it should work when given enough ciphertext. The example above is fairly long, and should be plenty for any algorithm.",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
var encoded = 
    ""MOMUD EKAPV TQEFM OEVHP AJMII CDCTI FGYAG JSPXY ALUYM NSMYH"" +
    ""VUXJE LEPXJ FXGCM JHKDZ RYICU HYPUS PGIGM OIYHF WHTCQ KMLRD"" +
    ""ITLXZ LJFVQ GHOLW CUHLO MDSOE KTALU VYLNZ RFGBX PHVGA LWQIS"" +
    ""FGRPH JOOFW GUBYI LAPLA LCAFA AMKLG CETDW VOELJ IKGJB XPHVG"" +
    ""ALWQC SNWBU BYHCU HKOCE XJEYK BQKVY KIIEH GRLGH XEOLW AWFOJ"" +
    ""ILOVV RHPKD WIHKN ATUHN VRYAQ DIVHX FHRZV QWMWV LGSHN NLVZS"" +
    ""JLAKI FHXUF XJLXM TBLQV RXXHR FZXGV LRAJI EXPRV OSMNP KEPDT"" +
    ""LPRWM JAZPK LQUZA ALGZX GVLKL GJTUI ITDSU REZXJ ERXZS HMPST"" +
    ""MTEOE PAPJH SMFNB YVQUZ AALGA YDNMP AQOWT UHDBV TSMUE UIMVH"" +
    ""QGVRW AEFSP EMPVE PKXZY WLKJA GWALT VYYOB YIXOK IHPDS EVLEV"" +
    ""RVSGB JOGYW FHKBL GLXYA MVKIS KIEHY IMAPX UOISK PVAGN MZHPW"" +
    ""TTZPV XFCCD TUHJH WLAPF YULTB UXJLN SIJVV YOVDJ SOLXG TGRVO"" +
    ""SFRII CTMKO JFCQF KTINQ BWVHG TENLH HOGCS PSFPV GJOKM SIFPR"" +
    ""ZPAAS ATPTZ FTPPD PORRF TAXZP KALQA WMIUD BWNCT LEFKO ZQDLX"" +
    ""BUXJL ASIMR PNMBF ZCYLV WAPVF QRHZV ZGZEF KBYIO OFXYE VOWGB"" +
    ""BXVCB XBAWG LQKCM ICRRX MACUO IKHQU AJEGL OIJHH XPVZW JEWBA"" +
    ""FWAML ZZRXJ EKAHV FASMU LVVUT TGK""
 
var freq = [26]float64{
    0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015,
    0.06094, 0.06966, 0.00153, 0.00772, 0.04025, 0.02406, 0.06749,
    0.07507, 0.01929, 0.00095, 0.05987, 0.06327, 0.09056, 0.02758,
    0.00978, 0.02360, 0.00150, 0.01974, 0.00074,
}
 
func sum(a []float64) (sum float64) {
    for _, f := range a {
        sum += f
    }
    return
}
 
func bestMatch(a []float64) int {
    sum := sum(a)
    bestFit, bestRotate := 1e100, 0
    for rotate := 0; rotate < 26; rotate++ {
        fit := 0.0
        for i := 0; i < 26; i++ {
            d := a[(i+rotate)%26]/sum - freq[i]
            fit += d * d / freq[i]
        }
        if fit < bestFit {
            bestFit, bestRotate = fit, rotate
        }
    }
    return bestRotate
}
 
func freqEveryNth(msg []int, key []byte) float64 {
    l := len(msg)
    interval := len(key)
    out := make([]float64, 26)
    accu := make([]float64, 26)
    for j := 0; j < interval; j++ {
        for k := 0; k < 26; k++ {
            out[k] = 0.0
        }
        for i := j; i < l; i += interval {
            out[msg[i]]++
        }
        rot := bestMatch(out)
        key[j] = byte(rot + 65)
        for i := 0; i < 26; i++ {
            accu[i] += out[(i+rot)%26]
        }
    }
    sum := sum(accu)
    ret := 0.0
    for i := 0; i < 26; i++ {
        d := accu[i]/sum - freq[i]
        ret += d * d / freq[i]
    }
    return ret
}
 
func decrypt(text, key string) string {
    var sb strings.Builder
    ki := 0
    for _, c := range text {
        if c < 'A' || c > 'Z' {
            continue
        }
        ci := (c - rune(key[ki]) + 26) % 26
        sb.WriteRune(ci + 65)
        ki = (ki + 1) % len(key)
    }
    return sb.String()
}
 
func main() {
    enc := strings.Replace(encoded, "" "", """", -1)
    txt := make([]int, len(enc))
    for i := 0; i < len(txt); i++ {
        txt[i] = int(enc[i] - 'A')
    }
    bestFit, bestKey := 1e100, """"
    fmt.Println(""  Fit     Length   Key"")
    for j := 1; j <= 26; j++ {
        key := make([]byte, j)
        fit := freqEveryNth(txt, key)
        sKey := string(key)
        fmt.Printf(""%f    %2d     %s"", fit, j, sKey)
        if fit < bestFit {
            bestFit, bestKey = fit, sKey
            fmt.Print("" <--- best so far"")
        }
        fmt.Println()
    }
    fmt.Println(""\nBest key :"", bestKey)
    fmt.Printf(""\nDecrypted text:\n%s\n"", decrypt(enc, bestKey))
}",3617,119
3952,http://rosettacode.org/wiki/Verhoeff_algorithm,Verhoeff algorithm,"Description
The Verhoeff algorithm is a checksum formula for error detection developed by the Dutch mathematician Jacobus Verhoeff and first published in 1969. It was the first decimal check digit algorithm which detects all single-digit errors, and all transposition errors involving two adjacent digits, which was at the time thought impossible with such a code.

As the workings of the algorithm are clearly described in the linked Wikipedia article they will not be repeated here.

Task

Write routines, methods, procedures etc. in your language to generate a Verhoeff checksum digit for non-negative integers of any length and to validate the result. A combined routine is also acceptable.

The more mathematically minded may prefer to generate the 3 tables required from the description provided rather than to hard-code them.

Write your routines in such a way that they can optionally display digit by digit calculations as in the Wikipedia example.

Use your routines to calculate check digits for the integers: 236, 12345 and 123456789012 and then validate them. Also attempt to validate the same integers if the check digits in all cases were 9 rather than what they actually are.

Display digit by digit calculations for the first two integers but not for the third.

Related task

   Damm algorithm

",#Go,Go,"package main
 
import ""fmt""
 
var d = [][]int{
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
    {1, 2, 3, 4, 0, 6, 7, 8, 9, 5},
    {2, 3, 4, 0, 1, 7, 8, 9, 5, 6},
    {3, 4, 0, 1, 2, 8, 9, 5, 6, 7},
    {4, 0, 1, 2, 3, 9, 5, 6, 7, 8},
    {5, 9, 8, 7, 6, 0, 4, 3, 2, 1},
    {6, 5, 9, 8, 7, 1, 0, 4, 3, 2},
    {7, 6, 5, 9, 8, 2, 1, 0, 4, 3},
    {8, 7, 6, 5, 9, 3, 2, 1, 0, 4},
    {9, 8, 7, 6, 5, 4, 3, 2, 1, 0},
}
 
var inv = []int{0, 4, 3, 2, 1, 5, 6, 7, 8, 9}
 
var p = [][]int{
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
    {1, 5, 7, 6, 2, 8, 3, 0, 9, 4},
    {5, 8, 0, 3, 7, 9, 6, 1, 4, 2},
    {8, 9, 1, 6, 0, 4, 3, 5, 2, 7},
    {9, 4, 5, 3, 1, 2, 6, 8, 7, 0},
    {4, 2, 8, 6, 5, 7, 3, 9, 0, 1},
    {2, 7, 9, 3, 8, 0, 6, 4, 1, 5},
    {7, 0, 4, 6, 9, 1, 3, 2, 5, 8},
}
 
func verhoeff(s string, validate, table bool) interface{} {
    if table {
        t := ""Check digit""
        if validate {
            t = ""Validation""
        }
        fmt.Printf(""%s calculations for '%s':\n\n"", t, s)
        fmt.Println("" i  nᵢ  p[i,nᵢ]  c"")
        fmt.Println(""------------------"")
    }
    if !validate {
        s = s + ""0""
    }
    c := 0
    le := len(s) - 1
    for i := le; i >= 0; i-- {
        ni := int(s[i] - 48)
        pi := p[(le-i)%8][ni]
        c = d[c][pi]
        if table {
            fmt.Printf(""%2d  %d      %d     %d\n"", le-i, ni, pi, c)
        }
    }
    if table && !validate {
        fmt.Printf(""\ninv[%d] = %d\n"", c, inv[c])
    }
    if !validate {
        return inv[c]
    }
    return c == 0
}
 
func main() {
    ss := []string{""236"", ""12345"", ""123456789012""}
    ts := []bool{true, true, false, true}
    for i, s := range ss {
        c := verhoeff(s, false, ts[i]).(int)
        fmt.Printf(""\nThe check digit for '%s' is '%d'\n\n"", s, c)
        for _, sc := range []string{s + string(c+48), s + ""9""} {
            v := verhoeff(sc, true, ts[i]).(bool)
            ans := ""correct""
            if !v {
                ans = ""incorrect""
            }
            fmt.Printf(""\nThe validation for '%s' is %s\n\n"", sc, ans)
        }
    }
}",2069,78
3961,http://rosettacode.org/wiki/Water_collected_between_towers,Water collected between towers,"Task

In a two-dimensional world, we begin with any bar-chart (or row of close-packed 'towers', each of unit width), and then it rains,
completely filling all convex enclosures in the chart with water.



9               ██           9               ██    
8               ██           8               ██    
7     ██        ██           7     ██≈≈≈≈≈≈≈≈██    
6     ██  ██    ██           6     ██≈≈██≈≈≈≈██    
5 ██  ██  ██  ████           5 ██≈≈██≈≈██≈≈████    
4 ██  ██  ████████           4 ██≈≈██≈≈████████    
3 ██████  ████████           3 ██████≈≈████████    
2 ████████████████  ██       2 ████████████████≈≈██
1 ████████████████████       1 ████████████████████


In the example above, a bar chart representing the values [5, 3, 7, 2, 6, 4, 5, 9, 1, 2] has filled, collecting 14 units of water.

Write a function, in your language, from a given array of heights, to the number of water units that can be held in this way, by a corresponding bar chart.

Calculate the number of water units that could be collected by bar charts representing each of the following seven series:

   [[1, 5, 3, 7, 2],
    [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],
    [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],
    [5, 5, 5, 5],
    [5, 6, 7, 8],
    [8, 7, 7, 6],
    [6, 7, 10, 7, 6]]


See, also:

 Four Solutions to a Trivial Problem – a Google Tech Talk by Guy Steele
 Water collected between towers on Stack Overflow, from which the example above is taken)
 An interesting Haskell solution, using the Tardis monad, by Phil Freeman in a Github gist.

",#Go,Go," 
package main
 
import ""fmt""
 
func maxl(hm []int ) []int{
	res := make([]int,len(hm))
	max := 1
	for i := 0; i < len(hm);i++{
		if(hm[i] > max){
			max = hm[i]
		}
		res[i] = max;
	}
	return res
}
func maxr(hm []int ) []int{
	res := make([]int,len(hm))
	max := 1
	for i := len(hm) - 1 ; i >= 0;i--{
		if(hm[i] > max){
			max = hm[i]
		}
		res[i] = max;
	}
	return res
}
func min(a,b []int)  []int {
	res := make([]int,len(a))
	for i := 0; i < len(a);i++{
		if a[i] >= b[i]{
			res[i] = b[i]
		}else {
			res[i] = a[i]
		}
	}
	return res
}
func diff(hm, min []int) []int {
	res := make([]int,len(hm))
	for i := 0; i < len(hm);i++{
		if min[i] > hm[i]{
			res[i] = min[i] - hm[i]
		}
	}
	return res
}
func sum(a []int) int {
	res := 0
	for i := 0; i < len(a);i++{
		res += a[i]
	}
	return res
}
 
func waterCollected(hm []int) int {
	maxr := maxr(hm)
	maxl := maxl(hm)
	min := min(maxr,maxl)
	diff := diff(hm,min)
	sum := sum(diff)
	return sum
}
 
 
func main() {
	fmt.Println(waterCollected([]int{1, 5, 3, 7, 2}))
	fmt.Println(waterCollected([]int{5, 3, 7, 2, 6, 4, 5, 9, 1, 2}))
	fmt.Println(waterCollected([]int{2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1}))
	fmt.Println(waterCollected([]int{5, 5, 5, 5}))
	fmt.Println(waterCollected([]int{5, 6, 7, 8}))
	fmt.Println(waterCollected([]int{8, 7, 7, 6}))
	fmt.Println(waterCollected([]int{6, 7, 10, 7, 6}))
}",1362,74
3988,http://rosettacode.org/wiki/Walk_a_directory/Recursively,Walk a directory/Recursively,"Task

Walk a given directory tree and print files matching a given pattern.


Note: This task is for recursive methods.   These tasks should read an entire directory tree, not a single directory.


Note: Please be careful when running any code examples found here.



Related task

   Walk a directory/Non-recursively   (read a single directory). 

",#Go,Go,"package main
 
import (
    ""fmt""
    ""os""
    ""path/filepath""
)
 
func VisitFile(fp string, fi os.FileInfo, err error) error {
    if err != nil {
        fmt.Println(err) // can't walk here,
        return nil       // but continue walking elsewhere
    }
    if fi.IsDir() {
        return nil // not a file.  ignore.
    }
    matched, err := filepath.Match(""*.mp3"", fi.Name())
    if err != nil {
        fmt.Println(err) // malformed pattern
        return err       // this is fatal.
    }
    if matched {
        fmt.Println(fp)
    }
    return nil
}
 
func main() {
    filepath.Walk(""/"", VisitFile)
}",612,30
3990,http://rosettacode.org/wiki/Verify_distribution_uniformity/Naive,Verify distribution uniformity/Naive,"This task is an adjunct to Seven-sided dice from five-sided dice.



Task

Create a function to check that the random integers returned from a small-integer generator function have uniform distribution.



The function should take as arguments:

 The function (or object) producing random integers.
 The number of times to call the integer generator.
 A 'delta' value of some sort that indicates how close to a flat distribution is close enough.


The function should produce:

 Some indication of the distribution achieved.
 An 'error' if the distribution is not flat enough.


Show the distribution checker working when the produced distribution is flat enough and when it is not. (Use a generator from Seven-sided dice from five-sided dice).



See also:

Verify distribution uniformity/Chi-squared test

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/rand""
    ""time""
)
 
// ""given""
func dice5() int {
    return rand.Intn(5) + 1
}
 
// function specified by task ""Seven-sided dice from five-sided dice""
func dice7() (i int) {
    for {
        i = 5*dice5() + dice5()
        if i < 27 {
            break
        }
    }
    return (i / 3) - 1
}
 
// function specified by task ""Verify distribution uniformity/Naive""
//
// Parameter ""f"" is expected to return a random integer in the range 1..n.
// (Values out of range will cause an unceremonious crash.)
// ""Max"" is returned as an ""indication of distribution achieved.""
// It is the maximum delta observed from the count representing a perfectly
// uniform distribution.
// Also returned is a boolean, true if ""max"" is less than threshold
// parameter ""delta.""
func distCheck(f func() int, n int,
    repeats int, delta float64) (max float64, flatEnough bool) {
    count := make([]int, n)
    for i := 0; i < repeats; i++ {
        count[f()-1]++
    }
    expected := float64(repeats) / float64(n)
    for _, c := range count {
        max = math.Max(max, math.Abs(float64(c)-expected))
    }
    return max, max < delta
}
 
// Driver, produces output satisfying both tasks.
func main() {
    rand.Seed(time.Now().UnixNano())
    const calls = 1000000
    max, flatEnough := distCheck(dice7, 7, calls, 500)
    fmt.Println(""Max delta:"", max, ""Flat enough:"", flatEnough)
    max, flatEnough = distCheck(dice7, 7, calls, 500)
    fmt.Println(""Max delta:"", max, ""Flat enough:"", flatEnough)
}",1547,56
3996,http://rosettacode.org/wiki/Visualize_a_tree,Visualize a tree,"A tree structure   (i.e. a rooted, connected acyclic graph)   is often used in programming.

It's often helpful to visually examine such a structure.

There are many ways to represent trees to a reader, such as:

   indented text   (à la unix  tree  command)
   nested HTML tables
   hierarchical GUI widgets
   2D   or   3D   images
   etc.
Task

Write a program to produce a visual representation of some tree.

The content of the tree doesn't matter, nor does the output format, the only requirement being that the output is human friendly.

Make do with the vague term ""friendly"" the best you can.



",#Go,Go,"package main
 
import (
    ""encoding/json""
    ""fmt""
    ""log""
)
 
type Node struct {
    Name     string
    Children []*Node
}
 
func main() {
    tree := &Node{""root"", []*Node{
        &Node{""a"", []*Node{
            &Node{""d"", nil},
            &Node{""e"", []*Node{
                &Node{""f"", nil},
            }}}},
        &Node{""b"", nil},
        &Node{""c"", nil},
    }}
    b, err := json.MarshalIndent(tree, """", ""   "")
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(string(b))
}",505,29
4038,http://rosettacode.org/wiki/Verify_distribution_uniformity/Chi-squared_test,Verify distribution uniformity/Chi-squared test,"Task

Write a function to verify that a given distribution of values is uniform by using the 




χ

2




{\displaystyle \chi ^{2}}

 test to see if the distribution has a likelihood of happening of at least the significance level (conventionally 5%).

The function should return a boolean that is true if the distribution is one that a uniform distribution (with appropriate number of degrees of freedom) may be expected to produce.



Reference

   an entry at the MathWorld website:   chi-squared distribution.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
type ifctn func(float64) float64
 
func simpson38(f ifctn, a, b float64, n int) float64 {
    h := (b - a) / float64(n)
    h1 := h / 3
    sum := f(a) + f(b)
    for j := 3*n - 1; j > 0; j-- {
        if j%3 == 0 {
            sum += 2 * f(a+h1*float64(j))
        } else {
            sum += 3 * f(a+h1*float64(j))
        }
    }
    return h * sum / 8
}
 
func gammaIncQ(a, x float64) float64 {
    aa1 := a - 1
    var f ifctn = func(t float64) float64 {
        return math.Pow(t, aa1) * math.Exp(-t)
    }
    y := aa1
    h := 1.5e-2
    for f(y)*(x-y) > 2e-8 && y < x {
        y += .4
    }
    if y > x {
        y = x
    }
    return 1 - simpson38(f, 0, y, int(y/h/math.Gamma(a)))
}
 
func chi2ud(ds []int) float64 {
    var sum, expected float64
    for _, d := range ds {
        expected += float64(d)
    }
    expected /= float64(len(ds))
    for _, d := range ds {
        x := float64(d) - expected
        sum += x * x
    }
    return sum / expected
}
 
func chi2p(dof int, distance float64) float64 {
    return gammaIncQ(.5*float64(dof), .5*distance)
}
 
const sigLevel = .05
 
func main() {
    for _, dset := range [][]int{
        {199809, 200665, 199607, 200270, 199649},
        {522573, 244456, 139979, 71531, 21461},
    } {
        utest(dset)
    }
}
 
func utest(dset []int) {
    fmt.Println(""Uniform distribution test"")
    var sum int
    for _, c := range dset {
        sum += c
    }
    fmt.Println("" dataset:"", dset)
    fmt.Println("" samples:                      "", sum)
    fmt.Println("" categories:                   "", len(dset))
 
    dof := len(dset) - 1
    fmt.Println("" degrees of freedom:           "", dof)
 
    dist := chi2ud(dset)
    fmt.Println("" chi square test statistic:    "", dist)
 
    p := chi2p(dof, dist)
    fmt.Println("" p-value of test statistic:    "", p)
 
    sig := p < sigLevel
    fmt.Printf("" significant at %2.0f%% level?      %t\n"", sigLevel*100, sig)
    fmt.Println("" uniform?                      "", !sig, ""\n"")
}",2043,90
4049,http://rosettacode.org/wiki/Video_display_modes,Video display modes,"The task is to demonstrate how to switch video display modes within the language. A brief description of the supported video modes would be useful.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""os/exec""
    ""time""
)
 
func main() {
    // query supported display modes
    out, err := exec.Command(""xrandr"", ""-q"").Output()
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(string(out))
    time.Sleep(3 * time.Second)
 
    // change display mode to 1024x768 say (no text output)
    err = exec.Command(""xrandr"", ""-s"", ""1024x768"").Run()
    if err != nil {
        log.Fatal(err)
    }
    time.Sleep(3 * time.Second)
 
    // change it back again to 1366x768 (or whatever is optimal for your system)
    err = exec.Command(""xrandr"", ""-s"", ""1366x768"").Run()
    if err != nil {
        log.Fatal(err)
    }
}",678,31
4152,http://rosettacode.org/wiki/Vigen%C3%A8re_cipher,Vigenère cipher,"Task

Implement a   Vigenère cypher,   both encryption and decryption.

The program should handle keys and text of unequal length,
and should capitalize everything and discard non-alphabetic characters. 

(If your program handles non-alphabetic characters in another way,
make a note of it.)



Related tasks

   Caesar cipher
   Rot-13
   Substitution Cipher

",#Go,Go,"package main
 
import ""fmt""
 
type vkey string
 
func newVigenère(key string) (vkey, bool) {
    v := vkey(upperOnly(key))
    return v, len(v) > 0 // key length 0 invalid
}
 
func (k vkey) encipher(pt string) string {
    ct := upperOnly(pt)
    for i, c := range ct {
        ct[i] = 'A' + (c-'A'+k[i%len(k)]-'A')%26
    }
    return string(ct)
}
 
func (k vkey) decipher(ct string) (string, bool) {
    pt := make([]byte, len(ct))
    for i := range pt {
        c := ct[i]
        if c < 'A' || c > 'Z' {
            return """", false // invalid ciphertext
        }
        pt[i] = 'A' + (c-k[i%len(k)]+26)%26
    }
    return string(pt), true
}
 
// upperOnly extracts letters A-Z, a-z from a string and
// returns them all upper case in a byte slice.
// Useful for vkey constructor and encipher function.
func upperOnly(s string) []byte {
    u := make([]byte, 0, len(s))
    for i := 0; i < len(s); i++ {
        c := s[i]
        if c >= 'A' && c <= 'Z' {
            u = append(u, c)
        } else if c >= 'a' && c <= 'z' {
            u = append(u, c-32)
        }
    }
    return u
}
 
const testKey = ""Vigenère Cipher""
const testPT = `Beware the Jabberwock, my son!
    The jaws that bite, the claws that catch!`
 
func main() {
    fmt.Println(""Supplied key: "", testKey)
    v, ok := newVigenère(testKey)
    if !ok {
        fmt.Println(""Invalid key"")
        return
    }
    fmt.Println(""Effective key:"", v)
    fmt.Println(""Plain text:"", testPT)
    ct := v.encipher(testPT)
    fmt.Println(""Enciphered:"", ct)
    dt, ok := v.decipher(ct)
    if !ok {
        fmt.Println(""Invalid ciphertext"")
        return
    }
    fmt.Println(""Deciphered:"", dt)
}",1670,69
4168,http://rosettacode.org/wiki/Variable_size/Set,Variable size/Set,"Task

Demonstrate how to specify the minimum size of a variable or a data type.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""unsafe""
)
 
func main() {
    i := 5   // default type is int
    r := '5' // default type is rune (which is int32)
    f := 5.  // default type is float64
    c := 5i  // default type is complex128
    fmt.Println(""i:"", unsafe.Sizeof(i), ""bytes"")
    fmt.Println(""r:"", unsafe.Sizeof(r), ""bytes"")
    fmt.Println(""f:"", unsafe.Sizeof(f), ""bytes"")
    fmt.Println(""c:"", unsafe.Sizeof(c), ""bytes"")
    iMin := int8(5)
    rMin := byte('5')
    fMin := float32(5.)
    cMin := complex64(5i)
    fmt.Println(""iMin:"", unsafe.Sizeof(iMin), ""bytes"")
    fmt.Println(""rMin:"", unsafe.Sizeof(rMin), ""bytes"")
    fmt.Println(""fMin:"", unsafe.Sizeof(fMin), ""bytes"")
    fmt.Println(""cMin:"", unsafe.Sizeof(cMin), ""bytes"")
}",747,25
4205,http://rosettacode.org/wiki/Variable-length_quantity,Variable-length quantity,"Implement some operations on variable-length quantities, at least including conversions from a normal number in the language to the binary representation of the variable-length quantity for that number, and vice versa. Any variants are acceptable.



Task

With above operations,

convert these two numbers 0x200000 (2097152 in decimal) and 0x1fffff (2097151 in decimal) into sequences of octets (an eight-bit byte); 
display these sequences of octets;
convert these sequences of octets back to numbers, and check that they are equal to original numbers.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""encoding/binary""
)
 
func main() {
    buf := make([]byte, binary.MaxVarintLen64)
    for _, x := range []int64{0x200000, 0x1fffff} {
        v := buf[:binary.PutVarint(buf, x)]
        fmt.Printf(""%d encodes into %d bytes: %x\n"", x, len(v), v)
        x, _ = binary.Varint(v)
        fmt.Println(x, ""decoded"")
    }
}",357,16
4306,http://rosettacode.org/wiki/Vector,Vector,"Task
Implement a Vector class (or a set of functions) that models a Physical Vector. The four basic operations and a pretty print function should be implemented.



The Vector may be initialized in any reasonable way.

 Start and end points, and direction
 Angular coefficient and value (length)


The four operations to be implemented are:

 Vector  +  Vector addition
 Vector  -  Vector subtraction
 Vector  *  scalar multiplication
 Vector  /  scalar division

",#Go,Go,"package main
 
import ""fmt""
 
type vector []float64
 
func (v vector) add(v2 vector) vector {
    r := make([]float64, len(v))
    for i, vi := range v {
        r[i] = vi + v2[i]
    }
    return r
}
 
func (v vector) sub(v2 vector) vector {
    r := make([]float64, len(v))
    for i, vi := range v {
        r[i] = vi - v2[i]
    }
    return r
}
 
func (v vector) scalarMul(s float64) vector {
    r := make([]float64, len(v))
    for i, vi := range v {
        r[i] = vi * s
    }
    return r
}
 
func (v vector) scalarDiv(s float64) vector {
    r := make([]float64, len(v))
    for i, vi := range v {
        r[i] = vi / s
    }
    return r
}
 
func main() {
    v1 := vector{5, 7}
    v2 := vector{2, 3}
    fmt.Println(v1.add(v2))
    fmt.Println(v1.sub(v2))
    fmt.Println(v1.scalarMul(11))
    fmt.Println(v1.scalarDiv(2))
}",838,46
4378,http://rosettacode.org/wiki/Variable_declaration_reset,Variable declaration reset,"A decidely non-challenging task to highlight a potential difference between programming languages.

Using a straightforward longhand loop as in the JavaScript and Phix examples below, show the locations of elements which are identical to the immediately preceding element in {1,2,2,3,4,4,5}. The (non-blank) results may be 2,5 for zero-based or 3,6 if one-based. 

The purpose is to determine whether variable declaration (in block scope) resets the contents on every iteration.

There is no particular judgement of right or wrong here, just a plain-speaking statement of subtle differences.

Should your first attempt bomb with ""unassigned variable"" exceptions, feel free to code it as (say)

 // int prev // crashes with unassigned variable
    int prev = -1 // predictably no output

If your programming language does not support block scope (eg assembly) it should be omitted from this task.
",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    s := []int{1, 2, 2, 3, 4, 4, 5}
 
    // There is no output as 'prev' is created anew each time
    // around the loop and set implicitly to zero.
    for i := 0; i < len(s); i++ {
        curr := s[i]
        var prev int
        if i > 0 && curr == prev {
            fmt.Println(i)
        }
        prev = curr
    }
 
    // Now 'prev' is created only once and reassigned
    // each time around the loop producing the desired output.
    var prev int
    for i := 0; i < len(s); i++ {
        curr := s[i]
        if i > 0 && curr == prev {
            fmt.Println(i)
        }
        prev = curr
    }
}",659,29
4466,http://rosettacode.org/wiki/Variable_size/Get,Variable size/Get,"Demonstrate how to get the size of a variable.

See also: Host introspection
",#Go,Go,"import ""unsafe""
 
unsafe.Sizeof(x)",34,3
4627,http://rosettacode.org/wiki/Vampire_number,Vampire number,"A vampire number is a natural decimal number with an even number of digits,   that can be factored into two integers.

These two factors are called the   fangs,   and must have the following properties:

   they each contain half the number of the decimal digits of the original number
   together they consist of exactly the same decimal digits as the original number
   at most one of them has a trailing zero


An example of a vampire number and its fangs:    1260 : (21, 60) 



Task

 Print the first   25   vampire numbers and their fangs. 
 Check if the following numbers are vampire numbers and,   if so,   print them and their fangs: 
 16758243290880, 24959017348650, 14593825548650 



Note that a vampire number can have more than one pair of fangs.



See also

 numberphile.com.
 vampire search algorithm
 vampire numbers on OEIS

",#Go,Go,"package main
 
import (
    ""fmt"" 
    ""math"" 
)
 
func max(a, b uint64) uint64 {
    if a > b {
        return a
    }
    return b
}
 
func min(a, b uint64) uint64 {
    if a < b {
        return a
    }
    return b 
}
 
func ndigits(x uint64) (n int) {
    for ; x > 0; x /= 10 {
        n++ 
    }
    return 
}
 
func dtally(x uint64) (t uint64) {
    for ; x > 0; x /= 10 {
        t += 1 << (x % 10 * 6)
    }
    return 
}
 
var tens [20]uint64
 
func init() {
    tens[0] = 1
    for i := 1; i < 20; i++ {
        tens[i] = tens[i-1] * 10
    }
}
 
func fangs(x uint64) (f []uint64) {
    nd := ndigits(x)
    if nd&1 == 1 {
        return
    }
    nd /= 2
    lo := max(tens[nd-1], (x+tens[nd]-2)/(tens[nd]-1))
    hi := min(x/lo, uint64(math.Sqrt(float64(x))))
    t := dtally(x)
    for a := lo; a <= hi; a++ {
        b := x / a
        if a*b == x &&
            (a%10 > 0 || b%10 > 0) &&
            t == dtally(a)+dtally(b) {
            f = append(f, a)
        }
    }
    return
}
 
func showFangs(x uint64, f []uint64) {
    fmt.Print(x)
    if len(f) > 1 {
        fmt.Println()
    }
    for _, a := range f {
        fmt.Println("" ="", a, ""×"", x/a)
    }
}
 
func main() {
    for x, n := uint64(1), 0; n < 26; x++ {
        if f := fangs(x); len(f) > 0 {
            n++
            fmt.Printf(""%2d: "", n)
            showFangs(x, f)
        }
    }
    fmt.Println()
    for _, x := range []uint64{16758243290880, 24959017348650, 14593825548650} {
        if f := fangs(x); len(f) > 0 {
            showFangs(x, f)
        } else {
            fmt.Println(x, ""is not vampiric"")
        }
    }
}",1621,91
4630,http://rosettacode.org/wiki/Variadic_function,Variadic function,"Task

Create a function which takes in a variable number of arguments and prints each one on its own line.

Also show, if possible in your language, how to call the function on a list of arguments constructed at runtime.



Functions of this type are also known as Variadic Functions.



Related task

   Call a function

",#Go,Go,"func printAll(things ... string) {
  // it's as if you declared ""things"" as a []string, containing all the arguments
  for _, x := range things {
    fmt.Println(x)
  }
}",170,6
4743,http://rosettacode.org/wiki/URL_parser,URL parser,"URLs are strings with a simple syntax:

  scheme://[username:password@]domain[:port]/path?query_string#fragment_id



Task

Parse a well-formed URL to retrieve the relevant information:   scheme, domain, path, ...



Note:   this task has nothing to do with URL encoding or URL decoding.



According to the standards, the characters:

     ! * ' ( ) ; : @ & = + $ , / ? % # [ ] 
only need to be percent-encoded   (%)   in case of possible confusion.

Also note that the path, query and fragment are case sensitive, even if the scheme and domain are not.

The way the returned information is provided (set of variables, array, structured, record, object,...)
is language-dependent and left to the programmer, but the code should be clear enough to reuse.

Extra credit is given for clear error diagnostics.

   Here is the official standard:     https://tools.ietf.org/html/rfc3986, 
   and here is a simpler   BNF:     http://www.w3.org/Addressing/URL/5_URI_BNF.html.


Test cases

According to T. Berners-Lee

foo://example.com:8042/over/there?name=ferret#nose     should parse into:

   scheme = foo
   domain = example.com
   port = :8042
   path = over/there
   query = name=ferret
   fragment = nose

urn:example:animal:ferret:nose     should parse into:

   scheme = urn
   path = example:animal:ferret:nose

other URLs that must be parsed include:

   jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true 
   ftp://ftp.is.co.za/rfc/rfc1808.txt 
   http://www.ietf.org/rfc/rfc2396.txt#header1 
   ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two 
   mailto:John.Doe@example.com 
   news:comp.infosystems.www.servers.unix 
   tel:+1-816-555-1212 
   telnet://192.0.2.16:80/ 
   urn:oasis:names:specification:docbook:dtd:xml:4.1.2 

",#Go,Go,"package main
 
import (
	""fmt""
	""log""
	""net""
	""net/url""
)
 
func main() {
	for _, in := range []string{
		""foo://example.com:8042/over/there?name=ferret#nose"",
		""urn:example:animal:ferret:nose"",
		""jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true"",
		""ftp://ftp.is.co.za/rfc/rfc1808.txt"",
		""http://www.ietf.org/rfc/rfc2396.txt#header1"",
		""ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two"",
		""mailto:John.Doe@example.com"",
		""news:comp.infosystems.www.servers.unix"",
		""tel:+1-816-555-1212"",
		""telnet://192.0.2.16:80/"",
		""urn:oasis:names:specification:docbook:dtd:xml:4.1.2"",
 
		""ssh://alice@example.com"",
		""https://bob:pass@example.com/place"",
		""http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64"",
	} {
		fmt.Println(in)
		u, err := url.Parse(in)
		if err != nil {
			log.Println(err)
			continue
		}
		if in != u.String() {
			fmt.Printf(""Note: reassmebles as %q\n"", u)
		}
		printURL(u)
	}
}
 
func printURL(u *url.URL) {
	fmt.Println(""    Scheme:"", u.Scheme)
	if u.Opaque != """" {
		fmt.Println(""    Opaque:"", u.Opaque)
	}
	if u.User != nil {
		fmt.Println(""    Username:"", u.User.Username())
		if pwd, ok := u.User.Password(); ok {
			fmt.Println(""    Password:"", pwd)
		}
	}
	if u.Host != """" {
		if host, port, err := net.SplitHostPort(u.Host); err == nil {
			fmt.Println(""    Host:"", host)
			fmt.Println(""    Port:"", port)
		} else {
			fmt.Println(""    Host:"", u.Host)
		}
	}
	if u.Path != """" {
		fmt.Println(""    Path:"", u.Path)
	}
	if u.RawQuery != """" {
		fmt.Println(""    RawQuery:"", u.RawQuery)
		m, err := url.ParseQuery(u.RawQuery)
		if err == nil {
			for k, v := range m {
				fmt.Printf(""        Key: %q Values: %q\n"", k, v)
			}
		}
	}
	if u.Fragment != """" {
		fmt.Println(""    Fragment:"", u.Fragment)
	}
}",1777,75
4764,http://rosettacode.org/wiki/Validate_International_Securities_Identification_Number,Validate International Securities Identification Number,"An International Securities Identification Number (ISIN) is a unique international identifier for a financial security such as a stock or bond.



Task

Write a function or program that takes a string as input, and checks whether it is a valid ISIN.

It is only valid if it has the correct format,   and   the embedded checksum is correct.

Demonstrate that your code passes the test-cases listed below.



Details

The format of an ISIN is as follows:


┌───────────── a 2-character ISO country code (A-Z)
│ ┌─────────── a 9-character security code (A-Z, 0-9)
│ │        ┌── a checksum digit (0-9)
AU0000XVGZA3



For this task, you may assume that any 2-character alphabetic sequence is a valid country code.

The checksum can be validated as follows:

 Replace letters with digits, by converting each character from base 36 to base 10, e.g. AU0000XVGZA3 →1030000033311635103.
 Perform the Luhn test on this base-10 number.
There is a separate task for this test: Luhn test of credit card numbers.
You don't have to replicate the implementation of this test here   ───   you can just call the existing function from that task.   (Add a comment stating if you did this.)


Test cases



 ISIN

 Validity

 Comment


 US0378331005 
 valid 



 US0373831005 
 not valid 
 The transposition typo is caught by the checksum constraint.


 U50378331005 
 not valid 
 The substitution typo is caught by the format constraint.


 US03378331005 
 not valid 
 The duplication typo is caught by the format constraint.


 AU0000XVGZA3 
 valid 



 AU0000VXGZA3 
 valid 
 Unfortunately, not all transposition typos are caught by the checksum constraint.


 FR0000988040 
 valid 


(The comments are just informational.   Your function should simply return a Boolean result.   See #Raku for a reference solution.)



Related task:

 Luhn test of credit card numbers


Also see

 Interactive online ISIN validator
 Wikipedia article: International Securities Identification Number

",#Go,Go,"package main
 
import ""regexp""
 
var r = regexp.MustCompile(`^[A-Z]{2}[A-Z0-9]{9}\d$`)
 
var inc = [2][10]int{
	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
	{0, 2, 4, 6, 8, 1, 3, 5, 7, 9},
}
 
func ValidISIN(n string) bool {
	if !r.MatchString(n) {
		return false
	}
	var sum, p int
	for i := 10; i >= 0; i-- {
		p = 1 - p
		if d := n[i]; d < 'A' {
			sum += inc[p][d-'0']
		} else {
			d -= 'A'
			sum += inc[p][d%10]
			p = 1 - p
			sum += inc[p][d/10+1]
		}
	}
	sum += int(n[11] - '0')
	return sum%10 == 0
}",498,30
4775,http://rosettacode.org/wiki/Use_another_language_to_call_a_function,Use another language to call a function,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.
This task is inverse to the task Call foreign language function. Consider the following C program:

#include <stdio.h>
 
extern int Query (char * Data, size_t * Length);
 
int main (int argc, char * argv [])
{
   char     Buffer [1024];
   size_t   Size = sizeof (Buffer);
 
   if (0 == Query (Buffer, &Size))
   {
      printf (""failed to call Query\n"");
   }
   else
   {
      char * Ptr = Buffer;
      while (Size-- > 0) putchar (*Ptr++);
      putchar ('\n');
   }
}
Implement the missing Query function in your language, and let this C program call it. The function should place the string Here am I into the buffer which is passed to it as the parameter Data. The buffer size in bytes is passed as the parameter Length. When there is no room in the buffer, Query shall return 0. Otherwise it overwrites the beginning of Buffer, sets the number of overwritten bytes into Length and returns 1.
",#Go,Go,"#include <stdio.h>
#include ""_cgo_export.h""
 
void Run()
{
   char     Buffer [1024];
   size_t   Size = sizeof (Buffer);
 
   if (0 == Query (Buffer, &Size))
   ...",165,10
4884,http://rosettacode.org/wiki/Van_der_Corput_sequence,Van der Corput sequence,"When counting integers in binary, if you put a (binary) point to the righEasyLangt of the count then the column immediately to the left denotes a digit with a multiplier of 




2

0




{\displaystyle 2^{0}}

; the digit in the next column to the left has a multiplier of 




2

1




{\displaystyle 2^{1}}

; and so on.

So in the following table:

  0.
  1.
 10.
 11.
 ...
the binary number ""10"" is 



1
×

2

1


+
0
×

2

0




{\displaystyle 1\times 2^{1}+0\times 2^{0}}

.

You can also have binary digits to the right of the “point”, just as in the decimal number system. In that case, the digit in the place immediately to the right of the point has a weight of 




2

−
1




{\displaystyle 2^{-1}}

, or 



1

/

2


{\displaystyle 1/2}

.
The weight for the second column to the right of the point is 




2

−
2




{\displaystyle 2^{-2}}

 or 



1

/

4


{\displaystyle 1/4}

. And so on.

If you take the integer binary count of the first table, and reflect the digits about the binary point, you end up with the van der Corput sequence of numbers in base 2.

  .0
  .1
  .01
  .11
  ...
The third member of the sequence, binary 0.01, is therefore 



0
×

2

−
1


+
1
×

2

−
2




{\displaystyle 0\times 2^{-1}+1\times 2^{-2}}

 or 



1

/

4


{\displaystyle 1/4}

.



 Distribution of 2500 points each: Van der Corput (top) vs pseudorandom




0
≤
x
<
1


{\displaystyle 0\leq x<1}


Monte Carlo simulations
This sequence is also a superset of the numbers representable by the ""fraction"" field of an old IEEE floating point standard. In that standard, the ""fraction"" field represented the fractional part of a binary number beginning with ""1."" e.g. 1.101001101.

Hint

A hint at a way to generate members of the sequence is to modify a routine used to change the base of an integer:

>>> def base10change(n, base):
	digits = []
	while n:
		n,remainder = divmod(n, base)
		digits.insert(0, remainder)
	return digits
 
>>> base10change(11, 2)
[1, 0, 1, 1]
the above showing that 11 in decimal is 



1
×

2

3


+
0
×

2

2


+
1
×

2

1


+
1
×

2

0




{\displaystyle 1\times 2^{3}+0\times 2^{2}+1\times 2^{1}+1\times 2^{0}}

.

Reflected this would become .1101 or 



1
×

2

−
1


+
1
×

2

−
2


+
0
×

2

−
3


+
1
×

2

−
4




{\displaystyle 1\times 2^{-1}+1\times 2^{-2}+0\times 2^{-3}+1\times 2^{-4}}





Task description

 Create a function/method/routine that given n, generates the n'th term of the van der Corput sequence in base 2.
 Use the function to compute and display the first ten members of the sequence. (The first member of the sequence is for n=0).
 As a stretch goal/extra credit, compute and show members of the sequence for bases other than 2.


See also

 The Basic Low Discrepancy Sequences
 Non-decimal radices/Convert
 Van der Corput sequence

",#Go,Go,"package main
 
import ""fmt""
 
func v2(n uint) (r float64) {
    p := .5
    for n > 0 {
        if n&1 == 1 {
            r += p
        }
        p *= .5
        n >>= 1
    }
    return
}
 
func newV(base uint) func(uint) float64 {
    invb := 1 / float64(base)
    return func(n uint) (r float64) {
        p := invb
        for n > 0 {
            r += p * float64(n%base)
            p *= invb
            n /= base
        }
        return
    }
}
 
func main() {
    fmt.Println(""Base 2:"")
    for i := uint(0); i < 10; i++ {
        fmt.Println(i, v2(i))
    }
    fmt.Println(""Base 3:"")
    v3 := newV(3)
    for i := uint(0); i < 10; i++ {
        fmt.Println(i, v3(i))
    }
}",687,40
4904,http://rosettacode.org/wiki/Van_Eck_sequence,Van Eck sequence,"The sequence is generated by following this pseudo-code:

A:  The first term is zero.
    Repeatedly apply:
        If the last term is *new* to the sequence so far then:
B:          The next term is zero.
        Otherwise:
C:          The next term is how far back this last term occured previously.



Example

Using A:

0
Using B:

0 0
Using C:

0 0 1
Using B:

0 0 1 0
Using C: (zero last occurred two steps back - before the one)

0 0 1 0 2
Using B:

0 0 1 0 2 0
Using C: (two last occurred two steps back - before the zero)

0 0 1 0 2 0 2 2
Using C: (two last occurred one step back)

0 0 1 0 2 0 2 2 1
Using C: (one last appeared six steps back)

0 0 1 0 2 0 2 2 1 6
...



Task

 Create a function/procedure/method/subroutine/... to generate the Van Eck sequence of numbers.
 Use it to display here, on this page:
 The first ten terms of the sequence.
 Terms 991 - to - 1000 of the sequence.


References

 Don't Know (the Van Eck Sequence) - Numberphile video.
 Wikipedia Article: Van Eck's Sequence.
  OEIS sequence: A181391.

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    const max = 1000
    a := make([]int, max) // all zero by default
    for n := 0; n < max-1; n++ {
        for m := n - 1;  m >= 0; m-- {
            if a[m] == a[n] {
                a[n+1] = n - m
                break
            }    
        }
    }
    fmt.Println(""The first ten terms of the Van Eck sequence are:"")
    fmt.Println(a[:10])
    fmt.Println(""\nTerms 991 to 1000 of the sequence are:"")
    fmt.Println(a[990:])
}",481,20
4954,http://rosettacode.org/wiki/UTF-8_encode_and_decode,UTF-8 encode and decode,"As described in UTF-8 and in Wikipedia, UTF-8 is a popular encoding of (multi-byte) Unicode code-points into eight-bit octets.

The goal of this task is to write a encoder that takes a unicode code-point (an integer representing a unicode character) and returns a sequence of 1-4 bytes representing that character in the UTF-8 encoding.

Then you have to write the corresponding decoder that takes a sequence of 1-4 UTF-8 encoded bytes and return the corresponding unicode character.

Demonstrate the functionality of your encoder and decoder on the following five characters:

Character   Name                                  Unicode    UTF-8 encoding (hex)
---------------------------------------------------------------------------------
A           LATIN CAPITAL LETTER A                U+0041     41
ö           LATIN SMALL LETTER O WITH DIAERESIS   U+00F6     C3 B6
Ж           CYRILLIC CAPITAL LETTER ZHE           U+0416     D0 96
€           EURO SIGN                             U+20AC     E2 82 AC
𝄞           MUSICAL SYMBOL G CLEF                 U+1D11E    F0 9D 84 9E

Provided below is a reference implementation in Common Lisp.
",#Go,Go,"package main
 
import (
    ""bytes""
    ""encoding/hex""
    ""fmt""
    ""log""
    ""strings""
)
 
var testCases = []struct {
    rune
    string
}{
    {'A', ""41""},
    {'ö', ""C3 B6""},
    {'Ж', ""D0 96""},
    {'€', ""E2 82 AC""},
    {'𝄞', ""F0 9D 84 9E""},
}
 
func main() {
    for _, tc := range testCases {
        // derive some things from test data
        u := fmt.Sprintf(""U+%04X"", tc.rune)
        b, err := hex.DecodeString(strings.Replace(tc.string, "" "", """", -1))
        if err != nil {
            log.Fatal(""bad test data"")
        }
        // exercise encoder and decoder on test data
        e := encodeUTF8(tc.rune)
        d := decodeUTF8(b)
        // show function return values
        fmt.Printf(""%c  %-7s  %X\n"", d, u, e)
        // validate return values against test data
        if !bytes.Equal(e, b) {
            log.Fatal(""encodeUTF8 wrong"")
        }
        if d != tc.rune {
            log.Fatal(""decodeUTF8 wrong"")
        }
    }
}
 
const (
    // first byte of a 2-byte encoding starts 110 and carries 5 bits of data
    b2Lead = 0xC0 // 1100 0000
    b2Mask = 0x1F // 0001 1111
 
    // first byte of a 3-byte encoding starts 1110 and carries 4 bits of data
    b3Lead = 0xE0 // 1110 0000
    b3Mask = 0x0F // 0000 1111
 
    // first byte of a 4-byte encoding starts 11110 and carries 3 bits of data
    b4Lead = 0xF0 // 1111 0000
    b4Mask = 0x07 // 0000 0111
 
    // non-first bytes start 10 and carry 6 bits of data
    mbLead = 0x80 // 1000 0000
    mbMask = 0x3F // 0011 1111
)
 
func encodeUTF8(r rune) []byte {
    switch i := uint32(r); {
    case i <= 1<<7-1: // max code point that encodes into a single byte
        return []byte{byte(r)}
    case i <= 1<<11-1: // into two bytes
        return []byte{
            b2Lead | byte(r>>6),
            mbLead | byte(r)&mbMask}
    case i <= 1<<16-1: // three
        return []byte{
            b3Lead | byte(r>>12),
            mbLead | byte(r>>6)&mbMask,
            mbLead | byte(r)&mbMask}
    default:
        return []byte{
            b4Lead | byte(r>>18),
            mbLead | byte(r>>12)&mbMask,
            mbLead | byte(r>>6)&mbMask,
            mbLead | byte(r)&mbMask}
    }
}
 
func decodeUTF8(b []byte) rune {
    switch b0 := b[0]; {
    case b0 < 0x80:
        return rune(b0)
    case b0 < 0xE0:
        return rune(b0&b2Mask)<<6 |
            rune(b[1]&mbMask)
    case b0 < 0xF0:
        return rune(b0&b3Mask)<<12 |
            rune(b[1]&mbMask)<<6 |
            rune(b[2]&mbMask)
    default:
        return rune(b0&b4Mask)<<18 |
            rune(b[1]&mbMask)<<12 |
            rune(b[2]&mbMask)<<6 |
            rune(b[3]&mbMask)
    }
}",2650,102
4981,http://rosettacode.org/wiki/User_input/Graphical,User input/Graphical,"

In this task, the goal is to input a string and the integer 75000, from graphical user interface.



See also: User input/Text
",#Go,Go,"package main
 
import (
    ""github.com/gotk3/gotk3/gtk""
    ""log""
    ""math/rand""
    ""strconv""
    ""time""
)
 
func validateInput(window *gtk.Window, str1, str2 string) bool {
    n, err := strconv.ParseFloat(str2, 64)
    if len(str1) == 0 || err != nil || n != 75000 {
        dialog := gtk.MessageDialogNew(
            window,
            gtk.DIALOG_MODAL,
            gtk.MESSAGE_ERROR,
            gtk.BUTTONS_OK,
            ""Invalid input"",
        )
        dialog.Run()
        dialog.Destroy()
        return false
    }
    return true
}
 
func check(err error, msg string) {
    if err != nil {
        log.Fatal(msg, err)
    }
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    gtk.Init(nil)
 
    window, err := gtk.WindowNew(gtk.WINDOW_TOPLEVEL)
    check(err, ""Unable to create window:"")
    window.SetTitle(""Rosetta Code"")
    window.SetPosition(gtk.WIN_POS_CENTER)
    window.Connect(""destroy"", func() {
        gtk.MainQuit()
    })
 
    vbox, err := gtk.BoxNew(gtk.ORIENTATION_VERTICAL, 1)
    check(err, ""Unable to create vertical box:"")
    vbox.SetBorderWidth(1)
 
    hbox1, err := gtk.BoxNew(gtk.ORIENTATION_HORIZONTAL, 1)
    check(err, ""Unable to create first horizontal box:"")
 
    hbox2, err := gtk.BoxNew(gtk.ORIENTATION_HORIZONTAL, 1)
    check(err, ""Unable to create second horizontal box:"")
 
    label, err := gtk.LabelNew(""Enter a string and the number 75000   \n"")
    check(err, ""Unable to create label:"")
 
    sel, err := gtk.LabelNew(""String:      "")
    check(err, ""Unable to create string entry label:"")
 
    nel, err := gtk.LabelNew(""Number: "")
    check(err, ""Unable to create number entry label:"")
 
    se, err := gtk.EntryNew()
    check(err, ""Unable to create string entry:"")
 
    ne, err := gtk.EntryNew()
    check(err, ""Unable to create number entry:"")
 
    hbox1.PackStart(sel, false, false, 2)
    hbox1.PackStart(se, false, false, 2)
 
    hbox2.PackStart(nel, false, false, 2)
    hbox2.PackStart(ne, false, false, 2)
 
    // button to accept
    ab, err := gtk.ButtonNewWithLabel(""Accept"")
    check(err, ""Unable to create accept button:"")
    ab.Connect(""clicked"", func() {
        // read and validate the entered values
        str1, _ := se.GetText()
        str2, _ := ne.GetText()
        if validateInput(window, str1, str2) {
            window.Destroy() // close window if input is OK
        }
    })
 
    vbox.Add(label)
    vbox.Add(hbox1)
    vbox.Add(hbox2)
    vbox.Add(ab)
    window.Add(vbox)
 
    window.ShowAll()
    gtk.Main()
}",2523,97
4988,http://rosettacode.org/wiki/URL_encoding,URL encoding,"Task

Provide a function or mechanism to convert a provided string into URL encoding representation.

In URL encoding, special characters, control characters and extended characters
are converted into a percent symbol followed by a two digit hexadecimal code,
So a space character encodes into %20 within the string.

For the purposes of this task, every character except 0-9, A-Z and a-z requires conversion, so the following characters all require conversion by default:

 ASCII control codes (Character ranges 00-1F hex (0-31 decimal) and 7F (127 decimal).
 ASCII symbols (Character ranges 32-47 decimal (20-2F hex))
 ASCII symbols (Character ranges 58-64 decimal (3A-40 hex))
 ASCII symbols (Character ranges 91-96 decimal (5B-60 hex))
 ASCII symbols (Character ranges 123-126 decimal (7B-7E hex))
 Extended characters with character codes of 128 decimal (80 hex) and above.


Example

The string ""http://foo bar/"" would be encoded as ""http%3A%2F%2Ffoo%20bar%2F"".



Variations

 Lowercase escapes are legal, as in ""http%3a%2f%2ffoo%20bar%2f"".
 Some standards give different rules: RFC 3986, Uniform Resource Identifier (URI): Generic Syntax, section 2.3, says that ""-._~"" should not be encoded. HTML 5, section 4.10.22.5 URL-encoded form data, says to preserve ""-._*"", and to encode space "" "" to ""+"". The options below provide for utilization of an exception string, enabling preservation (non encoding) of particular characters to meet specific standards.


Options

It is permissible to use an exception string (containing a set of symbols
that do not need to be converted).
However, this is an optional feature and is not a requirement of this task.



Related tasks
 
   URL decoding
   URL parser

",#Go,Go,"package main
 
import (
    ""fmt""
    ""net/url""
)
 
func main() {
    fmt.Println(url.QueryEscape(""http://foo bar/""))
}",119,10
5007,http://rosettacode.org/wiki/Update_a_configuration_file,Update a configuration file,"We have a configuration file as follows:

# This is a configuration file in standard configuration file format
#
# Lines begininning with a hash or a semicolon are ignored by the application
# program. Blank lines are also ignored by the application program.

# The first word on each non comment line is the configuration option.
# Remaining words or numbers on the line are configuration parameter
# data fields.

# Note that configuration option names are not case sensitive. However,
# configuration parameter data is case sensitive and the lettercase must
# be preserved.

# This is a favourite fruit
FAVOURITEFRUIT banana

# This is a boolean that should be set
NEEDSPEELING

# This boolean is commented out
; SEEDSREMOVED

# How many bananas we have
NUMBEROFBANANAS 48

The task is to manipulate the configuration file as follows:

 Disable the needspeeling option (using a semicolon prefix)
 Enable the seedsremoved option by removing the semicolon and any leading whitespace
 Change the numberofbananas parameter to 1024
 Enable (or create if it does not exist in the file) a parameter for numberofstrawberries with a value of 62000


Note that configuration option names are not case sensitive. This means that changes should be effected, regardless of the case.

Options should always be disabled by prefixing them with a semicolon.

Lines beginning with hash symbols should not be manipulated and left unchanged in the revised file.

If a configuration option does not exist within the file (in either enabled or disabled form), it should be added during this update. Duplicate configuration option names in the file should be removed, leaving just the first entry.

For the purpose of this task, the revised file should contain appropriate entries, whether enabled or not for needspeeling,seedsremoved,numberofbananas and numberofstrawberries.)

The update should rewrite configuration option names in capital letters. However lines beginning with hashes and any parameter data must not be altered (eg the banana for favourite fruit must not become capitalized). The update process should also replace double semicolon prefixes with just a single semicolon (unless it is uncommenting the option, in which case it should remove all leading semicolons).

Any lines beginning with a semicolon or groups of semicolons, but no following option should be removed, as should any leading or trailing whitespace on the lines. Whitespace between the option and parameters should consist only of a single
space, and any non-ASCII extended characters, tabs characters, or control codes
(other than end of line markers), should also be removed.



Related tasks
 Read a configuration file

",#Go,Go,"package main
 
import (
	""bufio""
	""fmt""
	""io""
	""log""
	""os""
	""strings""
	""unicode""
)
 
// line represents a single line in the configuration file.
type line struct {
	kind     lineKind
	option   string
	value    string
	disabled bool
}
 
// lineKind represents the different kinds of configuration line.
type lineKind int
 
const (
	_ lineKind = iota
	ignore
	parseError
	comment
	blank
	value
)
 
func (l line) String() string {
	switch l.kind {
	case ignore, parseError, comment, blank:
		return l.value
	case value:
		s := l.option
		if l.disabled {
			s = ""; "" + s
		}
		if l.value != """" {
			s += "" "" + l.value
		}
		return s
	}
	panic(""unexpected line kind"")
}
 
func removeDross(s string) string {
	return strings.Map(func(r rune) rune {
		if r < 32 || r > 0x7f || unicode.IsControl(r) {
			return -1
		}
		return r
	}, s)
}
 
func parseLine(s string) line {
	if s == """" {
		return line{kind: blank}
	}
	if s[0] == '#' {
		return line{kind: comment, value: s}
	}
	s = removeDross(s)
	fields := strings.Fields(s)
	if len(fields) == 0 {
		return line{kind: blank}
	}
	// Strip leading semicolons (but record that we found them)
	semi := false
	for len(fields[0]) > 0 && fields[0][0] == ';' {
		semi = true
		fields[0] = fields[0][1:]
	}
	// Lose the first field if it was all semicolons
	if fields[0] == """" {
		fields = fields[1:]
	}
	switch len(fields) {
	case 0:
		// This can only happen if the line starts
		// with a semicolon but has no other information
		return line{kind: ignore}
	case 1:
		return line{
			kind:     value,
			option:   strings.ToUpper(fields[0]),
			disabled: semi,
		}
	case 2:
		return line{
			kind:     value,
			option:   strings.ToUpper(fields[0]),
			value:    fields[1],
			disabled: semi,
		}
	}
	return line{kind: parseError, value: s}
}
 
// Config represents a ""standard"" configuration file.
type Config struct {
	options map[string]int		// index of each option in lines.
	lines   []line
}
 
// index returns the index of the given option in
// c.lines, or -1 if not found.
func (c *Config) index(option string) int {
	if i, ok := c.options[option]; ok {
		return i
	}
	return -1
}
 
// addLine adds a line to the config, ignoring
// duplicate options and ""ignore"" lines.
func (c *Config) addLine(l line) {
	switch l.kind {
	case ignore:
		return
	case value:
		if c.index(l.option) >= 0 {
			return
		}
		c.options[l.option] = len(c.lines)
		c.lines = append(c.lines, l)
	default:
		c.lines = append(c.lines, l)
	}
}
 
// ReadConfig reads a configuration file from path and returns it.
func ReadConfig(path string) (*Config, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	r := bufio.NewReader(f)
	c := &Config{options: make(map[string]int)}
	for {
		s, err := r.ReadString('\n')
		if s != """" {
			if err == nil {
				// strip newline unless we encountered an error without finding one.
				s = s[:len(s)-1]
			}
			c.addLine(parseLine(s))
		}
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, err
		}
	}
	return c, nil
}
 
// Set sets an option to a value, adding the option if necessary.  If
// the option was previously disabled, it will be enabled.
func (c *Config) Set(option string, val string) {
	if i := c.index(option); i >= 0 {
		line := &c.lines[i]
		line.disabled = false
		line.value = val
		return
	}
	c.addLine(line{
		kind:   value,
		option: option,
		value:  val,
	})
}
 
// Enable sets the enabled status of an option. It is
// ignored if the option does not already exist.
func (c *Config) Enable(option string, enabled bool) {
	if i := c.index(option); i >= 0 {
		c.lines[i].disabled = !enabled
	}
}
 
// Write writes the configuration file to the writer.
func (c *Config) Write(w io.Writer) {
	for _, line := range c.lines {
		fmt.Println(line)
	}
}
 
func main() {
	c, err := ReadConfig(""/tmp/cfg"")
	if err != nil {
		log.Fatalln(err)
	}
	c.Enable(""NEEDSPEELING"", false)
	c.Set(""SEEDSREMOVED"", """")
	c.Set(""NUMBEROFBANANAS"", ""1024"")
	c.Set(""NUMBEROFSTRAWBERRIES"", ""62000"")
	c.Write(os.Stdout)
}",4018,204
5086,http://rosettacode.org/wiki/URL_decoding,URL decoding,"This task   (the reverse of   URL encoding   and distinct from   URL parser)   is to provide a function
or mechanism to convert an URL-encoded string into its original unencoded form.



Test cases

   The encoded string   ""http%3A%2F%2Ffoo%20bar%2F""   should be reverted to the unencoded form   ""http://foo bar/"".
   The encoded string   ""google.com/search?q=%60Abdu%27l-Bah%C3%A1""   should revert to the unencoded form   ""google.com/search?q=`Abdu'l-Bahá"".

",#Go,Go,"package main
 
import (
	""fmt""
	""log""
	""net/url""
)
 
func main() {
	for _, escaped := range []string{
		""http%3A%2F%2Ffoo%20bar%2F"",
		""google.com/search?q=%60Abdu%27l-Bah%C3%A1"",
	} {
		u, err := url.QueryUnescape(escaped)
		if err != nil {
			log.Println(err)
			continue
		}
		fmt.Println(u)
	}
}",299,21
5140,http://rosettacode.org/wiki/UPC,UPC,"Goal
 
Convert UPC bar codes to decimal.



Specifically:

The UPC standard is actually a collection of standards -- physical standards, data format standards, product reference standards...

Here,   in this task,   we will focus on some of the data format standards,   with an imaginary physical+electrical implementation which converts physical UPC bar codes to ASCII   (with spaces and   #   characters representing the presence or absence of ink).



Sample input

Below, we have a representation of ten different UPC-A bar codes read by our imaginary bar code reader:

         # #   # ##  #  ## #   ## ### ## ### ## #### # # # ## ##  #   #  ##  ## ###  # ##  ## ### #  # #       
        # # #   ##   ## # #### #   # ## #   ## #   ## # # # ###  # ###  ##  ## ###  # #  ### ###  # # #         
         # #    # # #  ###  #   #    # #  #   #    # # # # ## #   ## #   ## #   ##   # # #### ### ## # #         
       # # ##  ## ##  ##   #  #   #  # ###  # ##  ## # # #   ## ##  #  ### ## ## #   # #### ## #   # #        
         # # ### ## #   ## ## ###  ##  # ##   #   # ## # # ### #  ## ##  #    # ### #  ## ##  #      # #          
          # #  #   # ##  ##  #   #   #  # ##  ##  #   # # # # #### #  ##  # #### #### # #  ##  # #### # #         
         # #  #  ##  ##  # #   ## ##   # ### ## ##   # # # #  #   #   #  #  ### # #    ###  # #  #   # #        
        # # #    # ##  ##   #  # ##  ##  ### #   #  # # # ### ## ## ### ## ### ### ## #  ##  ### ## # #         
         # # ### ##   ## # # #### #   ## # #### # #### # # #   #  # ###  #    # ###  # #    # ###  # # #       
        # # # #### ##   # #### # #   ## ## ### #### # # # #  ### # ###  ###  # # ###  #    # #  ### # #         

Some of these were entered upside down,   and one entry has a timing error.



Task

Implement code to find the corresponding decimal representation of each, rejecting the error.

Extra credit for handling the rows entered upside down   (the other option is to reject them).



Notes

Each digit is represented by 7 bits:

    0:  0 0 0 1 1 0 1
    1:  0 0 1 1 0 0 1
    2:  0 0 1 0 0 1 1
    3:  0 1 1 1 1 0 1
    4:  0 1 0 0 0 1 1
    5:  0 1 1 0 0 0 1
    6:  0 1 0 1 1 1 1
    7:  0 1 1 1 0 1 1
    8:  0 1 1 0 1 1 1
    9:  0 0 0 1 0 1 1

On the left hand side of the bar code a space represents a 0 and a # represents a 1.

On the right hand side of the bar code, a # represents a 0 and a space represents a 1

Alternatively (for the above):   spaces always represent zeros and # characters always represent ones, but the representation is logically negated -- 1s and 0s are flipped -- on the right hand side of the bar code.



The UPC-A bar code structure

   It begins with at least 9 spaces   (which our imaginary bar code reader unfortunately doesn't always reproduce properly), 
   then has a      # #      sequence marking the start of the sequence, 
   then has the six ""left hand"" digits, 
   then has a    # #    sequence in the middle, 
   then has the six ""right hand digits"", 
   then has another    # #    (end sequence),   and finally, 
   then ends with nine trailing spaces   (which might be eaten by wiki edits, and in any event, were not quite captured correctly by our imaginary bar code reader).


Finally, the last digit is a checksum digit which may be used to help detect errors.



Verification

Multiply each digit in the represented 12 digit sequence by the corresponding number in   (3,1,3,1,3,1,3,1,3,1,3,1)   and add the products.

The sum (mod 10) must be 0   (must have a zero as its last digit)   if the UPC number has been read correctly.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""regexp""
)
 
var bits = []string{
    ""0 0 0 1 1 0 1 "",
    ""0 0 1 1 0 0 1 "",
    ""0 0 1 0 0 1 1 "",
    ""0 1 1 1 1 0 1 "",
    ""0 1 0 0 0 1 1 "",
    ""0 1 1 0 0 0 1 "",
    ""0 1 0 1 1 1 1 "",
    ""0 1 1 1 0 1 1 "",
    ""0 1 1 0 1 1 1 "",
    ""0 0 0 1 0 1 1 "",
}
 
var (
    lhs = make(map[string]int)
    rhs = make(map[string]int)
)
 
var weights = []int{3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1}
 
const (
    s = ""# #""
    m = "" # # ""
    e = ""# #""
    d = ""(?:#| ){7}""
)
 
func init() {
    for i := 0; i <= 9; i++ {
        lt := make([]byte, 7)
        rt := make([]byte, 7)
        for j := 0; j < 14; j += 2 {
            if bits[i][j] == '1' {
                lt[j/2] = '#'
                rt[j/2] = ' '
            } else {
                lt[j/2] = ' '
                rt[j/2] = '#'
            }
        }
        lhs[string(lt)] = i
        rhs[string(rt)] = i
    }
}
 
func reverse(s string) string {
    b := []byte(s)
    for i, j := 0, len(b)-1; i < j; i, j = i+1, j-1 {
        b[i], b[j] = b[j], b[i]
    }
    return string(b)
}
 
func main() {
    barcodes := []string{
        ""         # #   # ##  #  ## #   ## ### ## ### ## #### # # # ## ##  #   #  ##  ## ###  # ##  ## ### #  # #       "",
        ""        # # #   ##   ## # #### #   # ## #   ## #   ## # # # ###  # ###  ##  ## ###  # #  ### ###  # # #         "",
        ""         # #    # # #  ###  #   #    # #  #   #    # # # # ## #   ## #   ## #   ##   # # #### ### ## # #         "",
        ""       # # ##  ## ##  ##   #  #   #  # ###  # ##  ## # # #   ## ##  #  ### ## ## #   # #### ## #   # #        "",
        ""         # # ### ## #   ## ## ###  ##  # ##   #   # ## # # ### #  ## ##  #    # ### #  ## ##  #      # #          "",
        ""          # #  #   # ##  ##  #   #   #  # ##  ##  #   # # # # #### #  ##  # #### #### # #  ##  # #### # #         "",
        ""         # #  #  ##  ##  # #   ## ##   # ### ## ##   # # # #  #   #   #  #  ### # #    ###  # #  #   # #        "",
        ""        # # #    # ##  ##   #  # ##  ##  ### #   #  # # # ### ## ## ### ## ### ### ## #  ##  ### ## # #         "",
        ""         # # ### ##   ## # # #### #   ## # #### # #### # # #   #  # ###  #    # ###  # #    # ###  # # #       "",
        ""        # # # #### ##   # #### # #   ## ## ### #### # # # #  ### # ###  ###  # # ###  #    # #  ### # #         "",
    }
 
    // Regular expression to check validity of a barcode and extract digits. However we accept any number
    // of spaces at the beginning or end i.e. we don't enforce a minimum of 9.
    expr := fmt.Sprintf(`^\s*%s(%s)(%s)(%s)(%s)(%s)(%s)%s(%s)(%s)(%s)(%s)(%s)(%s)%s\s*$`,
        s, d, d, d, d, d, d, m, d, d, d, d, d, d, e)
    rx := regexp.MustCompile(expr)
    fmt.Println(""UPC-A barcodes:"")
    for i, bc := range barcodes {
        for j := 0; j <= 1; j++ {
            if !rx.MatchString(bc) {
                fmt.Printf(""%2d: Invalid format\n"", i+1)
                break
            }
            codes := rx.FindStringSubmatch(bc)
            digits := make([]int, 12)
            var invalid, ok bool // False by default.
            for i := 1; i <= 6; i++ {
                digits[i-1], ok = lhs[codes[i]]
                if !ok {
                    invalid = true
                }
                digits[i+5], ok = rhs[codes[i+6]]
                if !ok {
                    invalid = true
                }
            }
            if invalid { // Contains at least one invalid digit.
                if j == 0 { // Try reversing.
                    bc = reverse(bc)
                    continue
                } else {
                    fmt.Printf(""%2d: Invalid digit(s)\n"", i+1)
                    break
                }
            }
            sum := 0
            for i, d := range digits {
                sum += weights[i] * d
            }
            if sum%10 != 0 {
                fmt.Printf(""%2d: Checksum error\n"", i+1)
                break
            } else {
                ud := """"
                if j == 1 {
                    ud = ""(upside down)""
                }
                fmt.Printf(""%2d: %v %s\n"", i+1, digits, ud)
                break
            }
        }
    }
}",4197,126
5154,http://rosettacode.org/wiki/Variables,Variables,"Task

Demonstrate a language's methods of:

   variable declaration
   initialization
   assignment
   datatypes
   scope 
   referencing,     and 
   other variable related facilities

",#Go,Go,x := 3,6,1
5208,http://rosettacode.org/wiki/Vector_products,Vector products,"A vector is defined as having three dimensions as being represented by an ordered collection of three numbers:   (X, Y, Z).

If you imagine a graph with the   x   and   y   axis being at right angles to each other and having a third,   z   axis coming out of the page, then a triplet of numbers,   (X, Y, Z)   would represent a point in the region,   and a vector from the origin to the point.

Given the vectors:

        A = (a1,  a2,  a3) 
        B = (b1,  b2,  b3) 
        C = (c1,  c2,  c3) 

then the following common vector products are defined:

 The dot product       (a scalar quantity)
  A • B = a1b1   +   a2b2   +   a3b3  
 The cross product       (a vector quantity)
  A x B = (a2b3  -   a3b2,     a3b1   -   a1b3,     a1b2   -   a2b1)  
 The scalar triple product       (a scalar quantity)
  A • (B x C) 
 The vector triple product       (a vector quantity)
  A x (B x C) 


Task

Given the three vectors:

        a = ( 3,    4,    5)
        b = ( 4,    3,    5)
        c = (-5,  -12,  -13)

 Create a named function/subroutine/method to compute the dot product of two vectors.
 Create a function to compute the cross product of two vectors.
 Optionally create a function to compute the scalar triple product of three vectors.
 Optionally create a function to compute the vector triple product of three vectors.
 Compute and display: a • b
 Compute and display: a x b
 Compute and display: a • (b x c), the scalar triple product.
 Compute and display: a x (b x c), the vector triple product.


References

   A starting page on Wolfram MathWorld is   Vector Multiplication .
   Wikipedia   dot product. 
   Wikipedia   cross product. 
   Wikipedia   triple product.


Related tasks

   Dot product
   Quaternion type

",#Go,Go,"package main
 
import ""fmt""
 
type vector struct {
    x, y, z float64
}
 
var (
    a = vector{3, 4, 5}
    b = vector{4, 3, 5}
    c = vector{-5, -12, -13}
)
 
func dot(a, b vector) float64 {
    return a.x*b.x + a.y*b.y + a.z*b.z
}
 
func cross(a, b vector) vector {
    return vector{a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x}
}
 
func s3(a, b, c vector) float64 {
    return dot(a, cross(b, c))
}
 
func v3(a, b, c vector) vector {
    return cross(a, cross(b, c))
}
 
func main() {
    fmt.Println(dot(a, b))
    fmt.Println(cross(a, b))
    fmt.Println(s3(a, b, c))
    fmt.Println(v3(a, b, c))
}",617,36
5240,http://rosettacode.org/wiki/User_input/Text,User input/Text,"User input/Text is part of Short Circuit's Console Program Basics selection.
Task
 
Input a string and the integer   75000   from the text console.

See also: User input/Graphical
",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    var s string
    var i int
    if _, err := fmt.Scan(&s, &i); err == nil && i == 75000 {
        fmt.Println(""good"")
    } else {
        fmt.Println(""wrong"")
    }
}",214,13
5717,http://rosettacode.org/wiki/Undefined_values,Undefined values,"
",#Go,Go,"package main
 
import ""fmt""
 
var (
    s []int
    p *int
    f func()
    i interface{}
    m map[int]int
    c chan int
)
 
func main() {
    fmt.Println(""Exercise nil objects:"")
    status()
 
    // initialize objects
    s = make([]int, 1)
    p = &s[0] // yes, reference element of slice just created
    f = func() { fmt.Println(""function call"") }
    i = user(0) // see user defined type just below
    m = make(map[int]int)
    c = make(chan int, 1)
 
    fmt.Println(""\nExercise objects after initialization:"")
    status()
}
 
type user int
 
func (user) m() {
    fmt.Println(""method call"")
}
 
func status() {
    trySlice()
    tryPointer()
    tryFunction()
    tryInterface()
    tryMap()
    tryChannel()
}
 
func reportPanic() {
    if x := recover(); x != nil {
        fmt.Println(""panic:"", x)
    }
}
 
func trySlice() {
    defer reportPanic()
    fmt.Println(""s[0] ="", s[0])
}
 
func tryPointer() {
    defer reportPanic()
    fmt.Println(""*p ="", *p)
}
 
func tryFunction() {
    defer reportPanic()
    f()
}
 
func tryInterface() {
    defer reportPanic()
 
    // normally the nil identifier accesses a nil value for one of
    // six predefined types.  In a type switch however, nil can be used
    // as a type.  In this case, it matches the nil interface.
    switch i.(type) {
    case nil:
        fmt.Println(""i is nil interface"")
    case interface {
        m()
    }:
        fmt.Println(""i has method m"")
    }
 
    // assert type with method and then call method
    i.(interface {
        m()
    }).m()
}
 
func tryMap() {
    defer reportPanic()
    m[0] = 0
    fmt.Println(""m[0] ="", m[0])
}
 
func tryChannel() {
    defer reportPanic()
    close(c)
    fmt.Println(""channel closed"")
}",1729,97
5768,http://rosettacode.org/wiki/Ultra_useful_primes,Ultra useful primes,"An ultra-useful prime is a member of the sequence where each a(n) is the smallest positive integer k such that 2(2n) - k is prime.

k must always be an odd number since 2 to any power is always even.



Task
 Find and show here, on this page, the first 10 elements of the sequence.


Stretch 
 Find and show the next several elements. (The numbers get really big really fast. Only nineteen elements have been identified as of this writing.)


See also
 OEIS:A058220 - Ultra-useful primes: smallest k such that 2^(2^n) - k is prime

",#Go,Go,"package main
 
import (
    ""fmt""
    big ""github.com/ncw/gmp""
)
 
var two = big.NewInt(2)
 
func a(n uint) int {
    one := big.NewInt(1)
    p := new(big.Int).Lsh(one, 1 << n)
    p.Sub(p, one)
    for k := 1; ; k += 2 {
        if p.ProbablyPrime(15) {
            return k
        }
        p.Sub(p, two)
    }
}
 
func main() {
    fmt.Println("" n   k"")
    fmt.Println(""----------"")
    for n := uint(1); n < 14; n++ {
        fmt.Printf(""%2d   %d\n"", n, a(n))
    }
}",474,28
5774,http://rosettacode.org/wiki/Untouchable_numbers,Untouchable numbers,"Definitions

   Untouchable numbers   are also known as   nonaliquot numbers.
   An   untouchable number   is a positive integer that cannot be expressed as the sum of all the proper divisors of any positive integer.   (From Wikipedia)
   The   sum of all the proper divisors   is also known as   the   aliquot sum.
   An   untouchable   are those numbers that are not in the image of the aliquot sum function.   (From Wikipedia)
   Untouchable numbers:   impossible values for the sum of all aliquot parts function.   (From OEIS:   The On-line Encyclopedia of Integer Sequences®)
   An untouchable number is a positive integer that is not the sum of the proper divisors of any number.   (From MathWorld™)


Observations and conjectures

All untouchable numbers   >  5  are composite numbers.

No untouchable number is perfect.

No untouchable number is sociable.

No untouchable number is a Mersenne prime.

No untouchable number is   one more   than a prime number,   since if   p   is prime,   then
the sum of the proper divisors of   p2   is  p + 1.

No untouchable number is   three more   than an odd prime number,   since if   p   is an odd prime,   then the
sum of the proper divisors of   2p   is  p + 3.

The number  5  is believed to be the only odd untouchable number,   but this has not been proven:   it would follow from a
slightly stronger version of the   Goldbach's conjecture,   since the sum of the
proper divisors of   pq   (with   p, q   being
distinct primes)   is   1 + p + q.

There are infinitely many untouchable numbers,   a fact that was proven
by   Paul Erdős.

According to Chen & Zhao,   their natural density is at least   d > 0.06.



Task

   show  (in a grid format)  all untouchable numbers  ≤  2,000.
   show (for the above)   the   count   of untouchable numbers.
   show the   count   of untouchable numbers from unity up to   (inclusive):
                   10
                 100
               1,000
             10,000
           100,000
   ... or as high as is you think is practical.
   all output is to be shown here, on this page.


See also

   Wolfram MathWorld:   untouchable number.
   OEIS:   A005114 untouchable numbers.
   OEIS:   a list of all untouchable numbers below 100,000   (inclusive).
   Wikipedia: untouchable number.
   Wikipedia: Goldbach's conjecture.

",#Go,Go,"package main
 
import ""fmt""
 
func sumDivisors(n int) int {
    sum := 1
    k := 2
    if n%2 == 0 {
        k = 1
    }
    for i := 1 + k; i*i <= n; i += k {
        if n%i == 0 {
            sum += i
            j := n / i
            if j != i {
                sum += j
            }
        }
    }
    return sum
}
 
func sieve(n int) []bool {
    n++
    s := make([]bool, n+1) // all false by default
    for i := 6; i <= n; i++ {
        sd := sumDivisors(i)
        if sd <= n {
            s[sd] = true
        }
    }
    return s
}
 
func primeSieve(limit int) []bool {
    limit++
    // True denotes composite, false denotes prime.
    c := make([]bool, limit) // all false by default
    c[0] = true
    c[1] = true
    // no need to bother with even numbers over 2 for this task
    p := 3 // Start from 3.
    for {
        p2 := p * p
        if p2 >= limit {
            break
        }
        for i := p2; i < limit; i += 2 * p {
            c[i] = true
        }
        for {
            p += 2
            if !c[p] {
                break
            }
        }
    }
    return c
}
 
func commatize(n int) string {
    s := fmt.Sprintf(""%d"", n)
    if n < 0 {
        s = s[1:]
    }
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    if n >= 0 {
        return s
    }
    return ""-"" + s
}
 
func main() {    
    limit := 1000000
    c := primeSieve(limit)
    s := sieve(63 * limit)
    untouchable := []int{2, 5}
    for n := 6; n <= limit; n += 2 {
        if !s[n] && c[n-1] && c[n-3] {
            untouchable = append(untouchable, n)
        }
    }
    fmt.Println(""List of untouchable numbers <= 2,000:"")
    count := 0
    for i := 0; untouchable[i] <= 2000; i++ {
        fmt.Printf(""%6s"", commatize(untouchable[i]))
        if (i+1)%10 == 0 {
            fmt.Println()
        }
        count++
    }
    fmt.Printf(""\n\n%7s untouchable numbers were found  <=     2,000\n"", commatize(count))
    p := 10
    count = 0
    for _, n := range untouchable {
        count++
        if n > p {
            cc := commatize(count - 1)
            cp := commatize(p)
            fmt.Printf(""%7s untouchable numbers were found  <= %9s\n"", cc, cp)
            p = p * 10
            if p == limit {
                break
            }
        }
    }
    cu := commatize(len(untouchable))
    cl := commatize(limit)
    fmt.Printf(""%7s untouchable numbers were found  <= %s\n"", cu, cl)
}",2466,113
5824,http://rosettacode.org/wiki/Unicode_variable_names,Unicode variable names,"Task

 Describe, and give a pointer to documentation on your languages use of characters beyond those of the ASCII character set in the naming of variables.
 Show how to:
 Set a variable with a name including the 'Δ', (delta character), to 1 
 Increment it
 Print its value.


Related task
 
 Case-sensitivity of identifiers

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    Δ := 1
    Δ++
    fmt.Println(Δ)
}",83,9
5843,http://rosettacode.org/wiki/Ukkonen%E2%80%99s_suffix_tree_construction,Ukkonen’s suffix tree construction,"Suffix Trees are very useful in numerous string processing and computational biology problems.

The task is to create a function which implements Ukkonen’s algorithm to create a useful Suffix Tree as described:

Part 1
Part 2
Part 3
Part 4
Part 5
Part 6

Using Arithmetic-geometric mean/Calculate Pi generate the first 1000, 10000, and 100000 decimal places of pi. Using your implementation with an alphabet of 0 through 9 (plus $ say to make the tree explicit) find the longest repeated string in each list. Time your results and demonstrate that your implementation is linear (i.e. that 10000 takes approx. 10 times as long as 1000). You may vary the size of the lists of decimal places of pi to give reasonable answers.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""time""
)
 
var maxChar = 128
 
type Node struct {
    children    []*Node
    suffixLink  *Node
    start       int
    end         *int
    suffixIndex int
}
 
var (
    text                 string
    root                 *Node
    lastNewNode          *Node
    activeNode           *Node
    activeEdge           = -1
    activeLength         = 0
    remainingSuffixCount = 0
    leafEnd              = -1
    rootEnd              *int
    splitEnd             *int
    size                 = -1
)
 
func newNode(start int, end *int) *Node {
    node := new(Node)
    node.children = make([]*Node, maxChar)
    node.suffixLink = root
    node.start = start
    node.end = end
    node.suffixIndex = -1
    return node
}
 
func edgeLength(n *Node) int {
    if n == root {
        return 0
    }
    return *(n.end) - n.start + 1
}
 
func walkDown(currNode *Node) bool {
    if activeLength >= edgeLength(currNode) {
        activeEdge += edgeLength(currNode)
        activeLength -= edgeLength(currNode)
        activeNode = currNode
        return true
    }
    return false
}
 
func extendSuffixTree(pos int) {
    leafEnd = pos
    remainingSuffixCount++
    lastNewNode = nil
    for remainingSuffixCount > 0 {
        if activeLength == 0 {
            activeEdge = pos
        }
        if activeNode.children[text[activeEdge]] == nil {
            activeNode.children[text[activeEdge]] = newNode(pos, &leafEnd)
            if lastNewNode != nil {
                lastNewNode.suffixLink = activeNode
                lastNewNode = nil
            }
        } else {
            next := activeNode.children[text[activeEdge]]
            if walkDown(next) {
                continue
            }
            if text[next.start+activeLength] == text[pos] {
                if lastNewNode != nil && activeNode != root {
                    lastNewNode.suffixLink = activeNode
                    lastNewNode = nil
                }
                activeLength++
                break
            }
            temp := next.start + activeLength - 1
            splitEnd = &temp
            split := newNode(next.start, splitEnd)
            activeNode.children[text[activeEdge]] = split
            split.children[text[pos]] = newNode(pos, &leafEnd)
            next.start += activeLength
            split.children[text[next.start]] = next
            if lastNewNode != nil {
                lastNewNode.suffixLink = split
            }
            lastNewNode = split
        }
        remainingSuffixCount--
        if activeNode == root && activeLength > 0 {
            activeLength--
            activeEdge = pos - remainingSuffixCount + 1
        } else if activeNode != root {
            activeNode = activeNode.suffixLink
        }
    }
}
 
func setSuffixIndexByDFS(n *Node, labelHeight int) {
    if n == nil {
        return
    }
    if n.start != -1 {
        // Uncomment line below to print suffix tree
        // fmt.Print(text[n.start: *(n.end) +1])
    }
    leaf := 1
    for i := 0; i < maxChar; i++ {
        if n.children[i] != nil {
            // Uncomment the 3 lines below to print suffix index
            //if leaf == 1 && n.start != -1 {
            //    fmt.Printf("" [%d]\n"", n.suffixIndex)
            //}
            leaf = 0
            setSuffixIndexByDFS(n.children[i], labelHeight+edgeLength(n.children[i]))
        }
    }
    if leaf == 1 {
        n.suffixIndex = size - labelHeight
        // Uncomment line below to print suffix index
        //fmt.Printf("" [%d]\n"", n.suffixIndex)
    }
}
 
func buildSuffixTree() {
    size = len(text)
    temp := -1
    rootEnd = &temp
    root = newNode(-1, rootEnd)
    activeNode = root
    for i := 0; i < size; i++ {
        extendSuffixTree(i)
    }
    labelHeight := 0
    setSuffixIndexByDFS(root, labelHeight)
}
 
func doTraversal(n *Node, labelHeight int, maxHeight, substringStartIndex *int) {
    if n == nil {
        return
    }
    if n.suffixIndex == -1 {
        for i := 0; i < maxChar; i++ {
            if n.children[i] != nil {
                doTraversal(n.children[i], labelHeight+edgeLength(n.children[i]),
                    maxHeight, substringStartIndex)
            }
        }
    } else if n.suffixIndex > -1 && (*maxHeight < labelHeight-edgeLength(n)) {
        *maxHeight = labelHeight - edgeLength(n)
        *substringStartIndex = n.suffixIndex
    }
}
 
func getLongestRepeatedSubstring(s string) {
    maxHeight := 0
    substringStartIndex := 0
    doTraversal(root, 0, &maxHeight, &substringStartIndex)
    // Uncomment line below to print maxHeight and substringStartIndex
    // fmt.Printf(""maxHeight %d, substringStartIndex %d\n"", maxHeight, substringStartIndex)
    if s == """" {
        fmt.Printf(""  %s is: "", text)
    } else {
        fmt.Printf(""  %s is: "", s)
    }
    k := 0
    for ; k < maxHeight; k++ {
        fmt.Printf(""%c"", text[k+substringStartIndex])
    }
    if k == 0 {
        fmt.Print(""No repeated substring"")
    }
    fmt.Println()
}
 
func calculatePi() *big.Float {
    one := big.NewFloat(1)
    two := big.NewFloat(2)
    four := big.NewFloat(4)
    prec := uint(325 * 1024) // enough to calculate Pi to 100,182 decimal digits
 
    a := big.NewFloat(1).SetPrec(prec)
    g := new(big.Float).SetPrec(prec)
 
    // temporary variables
    t := new(big.Float).SetPrec(prec)
    u := new(big.Float).SetPrec(prec)
 
    g.Quo(a, t.Sqrt(two))
    sum := new(big.Float)
    pow := big.NewFloat(2)
 
    for a.Cmp(g) != 0 {
        t.Add(a, g)
        t.Quo(t, two)
        g.Sqrt(u.Mul(a, g))
        a.Set(t)
        pow.Mul(pow, two)
        t.Sub(t.Mul(a, a), u.Mul(g, g))
        sum.Add(sum, t.Mul(t, pow))
    }
 
    t.Mul(a, a)
    t.Mul(t, four)
    pi := t.Quo(t, u.Sub(one, sum))
    return pi
}
 
func main() {
    tests := []string{
        ""GEEKSFORGEEKS$"",
        ""AAAAAAAAAA$"",
        ""ABCDEFG$"",
        ""ABABABA$"",
        ""ATCGATCGA$"",
        ""banana$"",
        ""abcpqrabpqpq$"",
        ""pqrpqpqabab$"",
    }
    fmt.Println(""Longest Repeated Substring in:\n"")
    for _, test := range tests {
        text = test
        buildSuffixTree()
        getLongestRepeatedSubstring("""")
    }
    fmt.Println()
 
    pi := calculatePi()
    piStr := fmt.Sprintf(""%v"", pi)
    piStr = piStr[2:] // remove initial 3.
    numbers := []int{1e3, 1e4, 1e5}
    maxChar = 58
    for _, number := range numbers {
        start := time.Now()
        text = piStr[0:number] + ""$""
        buildSuffixTree()
        getLongestRepeatedSubstring(fmt.Sprintf(""first %d d.p. of Pi"", number))
        elapsed := time.Now().Sub(start)
        fmt.Printf(""  (this took %s)\n\n"", elapsed)
    }
}",6700,251
5845,http://rosettacode.org/wiki/Unix/ls,Unix/ls,"Task

Write a program that will list everything in the current folder,   similar to:

   the Unix utility   “ls”   [1]       or 
   the Windows terminal command   “DIR” 


The output must be sorted, but printing extended details and producing multi-column output is not required.



Example output
For the list of paths:

/foo/bar
/foo/bar/1
/foo/bar/2
/foo/bar/a
/foo/bar/b



When the program is executed in   `/foo`,   it should print:

bar

and when the program is executed in   `/foo/bar`,   it should print:

1
2
a
b


",#Go,Go,"package main
 
import (
	""fmt""
	""log""
	""os""
	""sort""
)
 
func main() {
	f, err := os.Open(""."")
	if err != nil {
		log.Fatal(err)
	}
	files, err := f.Readdirnames(0)
	f.Close()
	if err != nil {
		log.Fatal(err)
	}
	sort.Strings(files)
	for _, n := range files {
		fmt.Println(n)
	}
}",281,24
5869,http://rosettacode.org/wiki/Unicode_strings,Unicode strings,"As the world gets smaller each day, internationalization becomes more and more important.   For handling multiple languages, Unicode is your best friend.

It is a very capable tool, but also quite complex compared to older single- and double-byte character encodings.

How well prepared is your programming language for Unicode?



Task

Discuss and demonstrate its unicode awareness and capabilities.



Some suggested topics:

   How easy is it to present Unicode strings in source code? 
   Can Unicode literals be written directly, or be part of identifiers/keywords/etc?
   How well can the language communicate with the rest of the world? 
   Is it good at input/output with Unicode?
   Is it convenient to manipulate Unicode strings in the language?
   How broad/deep does the language support Unicode? 
   What encodings (e.g. UTF-8, UTF-16, etc) can be used? 
   Does it support normalization?


Note

This task is a bit unusual in that it encourages general discussion rather than clever coding.



See also

   Unicode variable names
   Terminal control/Display an extended character

",#Go,Go,"    var i int
    var u rune
    for i, u = range ""voilà"" {
        fmt.Println(i, u)
    }",91,5
5870,http://rosettacode.org/wiki/Unprimeable_numbers,Unprimeable numbers,"Definitions

As used here, all unprimeable numbers   (positive integers)   are always expressed in base ten.



───── Definition from OEIS ─────:

Unprimeable numbers are composite numbers that always remain composite when a single decimal digit of the number is changed.



───── Definition from Wiktionary   (referenced from Adam Spencer's book) ─────:

(arithmetic)   that cannot be turned into a prime number by changing just one of its digits to any other
digit.   (sic)



Unprimeable numbers are also spelled:   unprimable.

All one─ and two─digit numbers can be turned into primes by changing a single decimal digit.



Examples

190   isn't unprimeable,   because by changing the zero digit into a three yields   193,   which is a prime.



The number   200   is unprimeable,   since none of the numbers   201, 202, 203, ··· 209   are
prime, and all the other numbers obtained by changing a single digit to
produce   100, 300, 400, ··· 900,   or   210, 220, 230, ··· 290   which are all even.



It is valid to change   189   into   089   by changing the   1   (one)   into
a   0   (zero),   which then the leading zero can be removed,   and then treated as if
the   ""new""   number is   89.



Task

   show the first   35   unprimeable numbers   (horizontally, on one line, preferably with a title)
   show the   600th   unprimeable number
   (optional) show the lowest unprimeable number ending in a specific decimal digit   (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
   (optional) use commas in the numbers where appropriate


Show all output here, on this page.



Also see

   the     OEIS     entry:   A118118 (unprimeable)
   with some useful counts to compare unprimeable number
   the Wiktionary entry (reference from below):   (arithmetic definition) unprimeable
   from the Adam Spencer book   (page 200):   Adam Spencer's World of Numbers       (Xoum Publishing)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
func isPrime(n int) bool {
    switch {
    case n < 2:
        return false
    case n%2 == 0:
        return n == 2
    case n%3 == 0:
        return n == 3
    default:
        d := 5
        for d*d <= n {
            if n%d == 0 {
                return false
            }
            d += 2
            if n%d == 0 {
                return false
            }
            d += 4
        }
        return true
    }
}
 
func commatize(n int) string {
    s := fmt.Sprintf(""%d"", n)
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    return s
}
 
func main() {
    fmt.Println(""The first 35 unprimeable numbers are:"")
    count := 0           // counts all unprimeable numbers
    var firstNum [10]int // stores the first unprimeable number ending with each digit
outer:
    for i, countFirst := 100, 0; countFirst < 10; i++ {
        if isPrime(i) {
            continue // unprimeable number must be composite
        }
        s := strconv.Itoa(i)
        le := len(s)
        b := []byte(s)
        for j := 0; j < le; j++ {
            for k := byte('0'); k <= '9'; k++ {
                if s[j] == k {
                    continue
                }
                b[j] = k
                n, _ := strconv.Atoi(string(b))
                if isPrime(n) {
                    continue outer
                }
            }
            b[j] = s[j] // restore j'th digit to what it was originally
        }
        lastDigit := s[le-1] - '0'
        if firstNum[lastDigit] == 0 {
            firstNum[lastDigit] = i
            countFirst++
        }
        count++
        if count <= 35 {
            fmt.Printf(""%d "", i)
        }
        if count == 35 {
            fmt.Print(""\n\nThe 600th unprimeable number is: "")
        }
        if count == 600 {
            fmt.Printf(""%s\n\n"", commatize(i))
        }
    }
 
    fmt.Println(""The first unprimeable number that ends in:"")
    for i := 0; i < 10; i++ {
        fmt.Printf(""  %d is: %9s\n"", i, commatize(firstNum[i]))
    }
}",2092,87
5956,http://rosettacode.org/wiki/Two_bullet_roulette,Two bullet roulette,"The following is supposedly a question given to mathematics graduates seeking jobs on Wall Street:


 A revolver handgun has a revolving cylinder with six chambers for bullets.
 It is loaded with the following procedure:
 1. Check the first chamber to the right of the trigger for a bullet. If a bullet
is seen, the cylinder is rotated one chamber clockwise and the next chamber
checked until an empty chamber is found.
 2. A cartridge containing a bullet is placed in the empty chamber.
 3. The cylinder is then rotated one chamber clockwise.
 To randomize the cylinder's position, the cylinder is spun, which causes the cylinder to take
a random position from 1 to 6 chamber rotations clockwise from its starting position.
 When the trigger is pulled the gun will fire if there is a bullet in position 0, which is just
counterclockwise from the loading position.
 The gun is unloaded by removing all cartridges from the cylinder.
 According to the legend, a suicidal Russian imperial military officer plays a game of Russian
roulette by putting two bullets in a six-chamber cylinder and pulls the trigger twice.
If the gun fires with a trigger pull, this is considered a successful suicide.
 The cylinder is always spun before the first shot, but it may or may not be spun after putting
in the first bullet and may or may not be spun after taking the first shot.
 Which of the following situations produces the highest probability of suicide?
 A. Spinning the cylinder after loading the first bullet, and spinning again after the first shot.
 B. Spinning the cylinder after loading the first bullet only.
 C. Spinning the cylinder after firing the first shot only.
 D. Not spinning the cylinder either after loading the first bullet or after the first shot.
 E. The probability is the same for all cases.


Task

 Run a repeated simulation of each of the above scenario, calculating the percentage of suicide with a randomization of the four spinning, loading and firing order scenarios.
 Show the results as a percentage of deaths for each type of scenario.
 The hand calculated probabilities are 5/9, 7/12, 5/9, and 1/2. A correct program should produce results close enough to those to allow a correct response to the interview question. 


Reference

Youtube video on the Russian 1895 Nagant revolver [[1]]



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""strings""
    ""time""
)
 
var cylinder = [6]bool{}
 
func rshift() {
    t := cylinder[5]
    for i := 4; i >= 0; i-- {
        cylinder[i+1] = cylinder[i]
    }
    cylinder[0] = t
}
 
func unload() {
    for i := 0; i < 6; i++ {
        cylinder[i] = false
    }
}
 
func load() {
    for cylinder[0] {
        rshift()
    }
    cylinder[0] = true
    rshift()
}
 
func spin() {
    var lim = 1 + rand.Intn(6)
    for i := 1; i < lim; i++ {
        rshift()
    }
}
 
func fire() bool {
    shot := cylinder[0]
    rshift()
    return shot
}
 
func method(s string) int {
    unload()
    for _, c := range s {
        switch c {
        case 'L':
            load()
        case 'S':
            spin()
        case 'F':
            if fire() {
                return 1
            }
        }
    }
    return 0
}
 
func mstring(s string) string {
    var l []string
    for _, c := range s {
        switch c {
        case 'L':
            l = append(l, ""load"")
        case 'S':
            l = append(l, ""spin"")
        case 'F':
            l = append(l, ""fire"")
        }
    }
    return strings.Join(l, "", "")
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    tests := 100000
    for _, m := range []string{""LSLSFSF"", ""LSLSFF"", ""LLSFSF"", ""LLSFF""} {
        sum := 0
        for t := 1; t <= tests; t++ {
            sum += method(m)
        }
        pc := float64(sum) * 100 / float64(tests)
        fmt.Printf(""%-40s produces %6.3f%% deaths.\n"", mstring(m), pc)
    }
}",1545,90
5988,http://rosettacode.org/wiki/Unbias_a_random_generator,Unbias a random generator,"




P

1




{\displaystyle P_{1}}







P

0




{\displaystyle P_{0}}







P

1




{\displaystyle P_{1}}







P

0




{\displaystyle P_{0}}







P

0




{\displaystyle P_{0}}







P

1




{\displaystyle P_{1}}




Task details

 Use your language's random number generator to create a function/method/subroutine/... randN that returns a one or a zero, but with one occurring, on average, 1 out of N times, where N is an integer from the range 3 to 6 inclusive.
 Create a function unbiased that uses only randN as its source of randomness to become an unbiased generator of random ones and zeroes.
 For N over its range, generate and show counts of the outputs of randN and unbiased(randN).


The actual unbiasing should be done by generating two numbers at a time from randN and only returning a 1 or 0 if they are different. As long as you always return the first number or always return the second number, the probabilities discussed above should take over the biased probability of randN.

This task is an implementation of Von Neumann debiasing, first described in a 1951 paper.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
)
 
const samples = 1e6
 
func main() {
    fmt.Println(""Generator  1 count  0 count  % 1 count"")
    for n := 3; n <= 6; n++ {
        // function randN, per task description
        randN := func() int {
            if rand.Intn(n) == 0 {
                return 1
            }
            return 0
        }
        var b [2]int
        for x := 0; x < samples; x++ {
            b[randN()]++
        }
        fmt.Printf(""randN(%d)   %7d  %7d    %5.2f%%\n"",
            n, b[1], b[0], float64(b[1])*100/samples)
 
        // function unbiased, per task description
        unbiased := func() (b int) {
            for b = randN(); b == randN(); b = randN() {
            }
            return
        }
        var u [2]int
        for x := 0; x < samples; x++ {
            u[unbiased()]++
        }
        fmt.Printf(""unbiased   %7d  %7d    %5.2f%%\n"",
            u[1], u[0], float64(u[1])*100/samples)
    }
}",967,40
6064,http://rosettacode.org/wiki/Twin_primes,Twin primes,"Twin primes are pairs of natural numbers   (P1  and  P2)   that satisfy the following:

     P1   and   P2   are primes
     P1  +  2   =   P2


Task

Write a program that displays the number of pairs of twin primes that can be found under a user-specified number

(P1 < user-specified number & P2 < user-specified number).



Extension

 Find all twin prime pairs under 100000, 10000000 and 1000000000.
 What is the time complexity of the program? Are there ways to reduce computation time?


Examples

> Search Size: 100
> 8 twin prime pairs.

> Search Size: 1000
> 35 twin prime pairs.



Also see

   The OEIS entry: A001097: Twin primes. 
   The OEIS entry: A167874: The number of distinct primes < 10^n which are members of twin-prime pairs. 
   The OEIS entry: A077800: List of twin primes {p, p+2}, with repetition. 
   The OEIS entry: A007508: Number of twin prime pairs below 10^n. 

",#Go,Go,"package main
 
import ""fmt""
 
func sieve(limit uint64) []bool {
    limit++
    // True denotes composite, false denotes prime.
    c := make([]bool, limit) // all false by default
    c[0] = true
    c[1] = true
    // no need to bother with even numbers over 2 for this task
    p := uint64(3) // Start from 3.
    for {
        p2 := p * p
        if p2 >= limit {
            break
        }
        for i := p2; i < limit; i += 2 * p {
            c[i] = true
        }
        for {
            p += 2
            if !c[p] {
                break
            }
        }
    }
    return c
}
 
func commatize(n int) string {
    s := fmt.Sprintf(""%d"", n)
    if n < 0 {
        s = s[1:]
    }
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    if n >= 0 {
        return s
    }
    return ""-"" + s
}
 
func main() {
    c := sieve(1e10 - 1)
    limit := 10
    start := 3
    twins := 0
    for i := 1; i < 11; i++ {
        for i := start; i < limit; i += 2 {
            if !c[i] && !c[i-2] {
                twins++
            }
        }
        fmt.Printf(""Under %14s there are %10s pairs of twin primes.\n"", commatize(limit), commatize(twins))
        start = limit + 1
        limit *= 10
    }
}",1258,61
6175,http://rosettacode.org/wiki/Truncate_a_file,Truncate a file,"Task

Truncate a file to a specific length.   This should be implemented as a routine that takes two parameters: the filename and the required file length (in bytes).



Truncation can be achieved using system or library calls intended for such a task, if such methods exist, or by creating a temporary file of a reduced size and renaming it, after first deleting the original file, if no other method is available.   The file may contain non human readable binary data in an unspecified format, so the routine should be ""binary safe"", leaving the contents of the untruncated part of the file unchanged.

If the specified filename does not exist, or the provided length is not less than the current file length, then the routine should raise an appropriate error condition.

On some systems, the provided file truncation facilities might not change the file or may extend the file, if the specified length is greater than the current length of the file.

This task permits the use of such facilities.   However, such behaviour should be noted, or optionally a warning message relating to an non change or increase in file size may be implemented.



",#Go,Go,"import (
    ""fmt""
    ""os""
)
 
if err := os.Truncate(""filename"", newSize); err != nil {
    fmt.Println(err)
}",111,8
6193,http://rosettacode.org/wiki/Tree_datastructures,Tree datastructures,"The following shows a tree of data with nesting denoted by visual levels of indentation:

RosettaCode
    rocks
        code
        comparison
        wiki
    mocks
        trolling
A common datastructure for trees is to define node structures having a name and a, (possibly empty), list of child nodes. The nesting of nodes captures the indentation of the tree. Lets call this the nest form.

# E.g. if child nodes are surrounded by brackets
#      and separated by commas then:
RosettaCode(rocks(code, ...), ...)
# But only an _example_
Another datastructure for trees is to construct from the root an ordered list of the nodes level of indentation and the name of that node. The indentation for the root node is zero; node 'rocks is indented by one level from the left, and so on. Lets call this the indent form.

0 RosettaCode
1 rocks
2 code
...
Task

 Create/use a nest datastructure format and textual representation for arbitrary trees.
 Create/use an indent datastructure format and textual representation for arbitrary trees.
 Create methods/classes/proceedures/routines etc to:
 Change from a nest tree datastructure to an indent one.
 Change from an indent tree datastructure to a nest one
 Use the above to encode the example at the start into the nest format, and show it.
 transform the initial nest format to indent format and show it.
 transform the indent format to final nest format and show it.
 Compare initial and final nest formats which should be the same.
Note

 It's all about showing aspects of the contrasting datastructures as they hold the tree.
 Comparing nested datastructures is secondary - saving formatted output as a string then a string compare would suffice for this task, if its easier.


Show all output on this page.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""io""
    ""os""
    ""strings""
)
 
type nNode struct {
    name     string
    children []nNode
}
 
type iNode struct {
    level int
    name  string
}
 
func printNest(n nNode, level int, w io.Writer) {
    if level == 0 {
        fmt.Fprintln(w, ""\n==Nest form==\n"")
    }
    fmt.Fprintf(w, ""%s%s\n"", strings.Repeat(""  "", level), n.name)
    for _, c := range n.children {
        fmt.Fprintf(w, ""%s"", strings.Repeat(""  "", level+1))
        printNest(c, level+1, w)
    }
}
 
func toNest(iNodes []iNode, start, level int, n *nNode) {
    if level == 0 {
        n.name = iNodes[0].name
    }
    for i := start + 1; i < len(iNodes); i++ {
        if iNodes[i].level == level+1 {
            c := nNode{iNodes[i].name, nil}
            toNest(iNodes, i, level+1, &c)
            n.children = append(n.children, c)
        } else if iNodes[i].level <= level {
            return
        }
    }
}
 
func printIndent(iNodes []iNode, w io.Writer) {
    fmt.Fprintln(w, ""\n==Indent form==\n"")
    for _, n := range iNodes {
        fmt.Fprintf(w, ""%d %s\n"", n.level, n.name)
    }
}
 
func toIndent(n nNode, level int, iNodes *[]iNode) {
    *iNodes = append(*iNodes, iNode{level, n.name})
    for _, c := range n.children {
        toIndent(c, level+1, iNodes)
    }
}
 
func main() {
    n1 := nNode{""RosettaCode"", nil}
    n2 := nNode{""rocks"", []nNode{{""code"", nil}, {""comparison"", nil}, {""wiki"", nil}}}
    n3 := nNode{""mocks"", []nNode{{""trolling"", nil}}}
    n1.children = append(n1.children, n2, n3)
 
    var sb strings.Builder
    printNest(n1, 0, &sb)
    s1 := sb.String()
    fmt.Print(s1)
 
    var iNodes []iNode
    toIndent(n1, 0, &iNodes)
    printIndent(iNodes, os.Stdout)
 
    var n nNode
    toNest(iNodes, 0, 0, &n)
    sb.Reset()
    printNest(n, 0, &sb)
    s2 := sb.String()
    fmt.Print(s2)
 
    fmt.Println(""\nRound trip test satisfied? "", s1 == s2)
}",1913,83
6237,http://rosettacode.org/wiki/Tree_from_nesting_levels,Tree from nesting levels,"Given a flat list of integers greater than zero, representing object nesting
levels, e.g. [1, 2, 4],
generate a tree formed from nested lists of those nesting level integers where:

 Every int appears, in order, at its depth of nesting.
 If the next level int is greater than the previous then it appears in a sub-list of the list containing the previous item


The generated tree data structure should ideally be in a languages nested list format that can
be used for further calculations rather than something just calculated for printing.



An input of [1, 2, 4] should produce the equivalent of: [1, [2, [[4]]]]
where 1 is at depth1, 2 is two deep and 4 is nested 4 deep.

[1, 2, 4, 2, 2, 1] should produce [1, [2, [[4]], 2, 2], 1]. 

All the nesting integers are in the same order but at the correct nesting
levels.

Similarly [3, 1, 3, 1] should generate [[[3]], 1, [[3]], 1]

Task

Generate and show here the results for the following inputs:

 []
 [1, 2, 4]
 [3, 1, 3, 1]
 [1, 2, 3, 1]
 [3, 2, 1, 3]
 [3, 3, 3, 1, 1, 3, 3, 3]

",#Go,Go,"package main
 
import ""fmt""
 
type any = interface{}
 
func toTree(list []int) any {
    s := []any{[]any{}}
    for _, n := range list {
        for n != len(s) {
            if n > len(s) {
                inner := []any{}
                s[len(s)-1] = append(s[len(s)-1].([]any), inner)
                s = append(s, inner)
            } else {
                s = s[0 : len(s)-1]
            }
        }
        s[len(s)-1] = append(s[len(s)-1].([]any), n)
        for i := len(s) - 2; i >= 0; i-- {
            le := len(s[i].([]any))
            s[i].([]any)[le-1] = s[i+1]
        }
    }
    return s[0]
}
 
func main() {
    tests := [][]int{
        {},
        {1, 2, 4},
        {3, 1, 3, 1},
        {1, 2, 3, 1},
        {3, 2, 1, 3},
        {3, 3, 3, 1, 1, 3, 3, 3},
    }
    for _, test := range tests {
        nest := toTree(test)
        fmt.Printf(""%17s => %v\n"", fmt.Sprintf(""%v"", test), nest)
    }
}",924,41
6286,http://rosettacode.org/wiki/Ulam_spiral_(for_primes),Ulam spiral (for primes),"An Ulam spiral (of primes) is a method of visualizing primes when expressed in a (normally counter-clockwise) outward spiral (usually starting at 1),   constructed on a square grid, starting at the ""center"".

An Ulam spiral is also known as a   prime spiral.

The first grid (green) is shown with sequential integers,   starting at   1.

In an Ulam spiral of primes, only the primes are shown (usually indicated by some glyph such as a dot or asterisk),   and all non-primes as shown as a blank   (or some other whitespace).

Of course, the grid and border are not to be displayed (but they are displayed here when using these Wiki HTML tables).

Normally, the spiral starts in the ""center"",   and the   2nd   number is to the viewer's right and the number spiral starts from there in a counter-clockwise direction.

There are other geometric shapes that are used as well, including clock-wise spirals.

Also, some spirals (for the   2nd   number)   is viewed upwards from the   1st   number instead of to the right, but that is just a matter of orientation.

Sometimes, the starting number can be specified to show more visual striking patterns (of prime densities).

[A larger than necessary grid (numbers wise) is shown here to illustrate the pattern of numbers on the diagonals   (which may be used by the method to orientate the direction of spiral-construction algorithm within the example computer programs)].

Then, in the next phase in the transformation of the Ulam prime spiral,   the non-primes are translated to blanks.

In the orange grid below,   the primes are left intact,   and all non-primes are changed to blanks.

Then, in the final transformation of the Ulam spiral (the yellow grid),   translate the primes to a glyph such as a    •    or some other suitable glyph.





 65 
 64 
 63 
 62 
 61 
 60 
 59 
 58 
 57


 66 
 37 
 36 
 35 
 34 
 33 
 32 
 31 
 56


 67 
 38 
 17 
 16 
 15 
 14 
 13 
 30 
 55


 68 
 39 
 18 
  5 
  4 
  3 
 12 
 29 
 54


 69 
 40 
 19 
  6 
  1 
  2 
 11 
 28 
 53


 70 
 41 
 20 
  7 
  8 
  9 
 10 
 27 
 52


 71 
 42 
 21 
 22 
 23 
 24 
 25 
 26 
 51


 72 
 43 
 44 
 45 
 46 
 47 
 48 
 49 
 50


 73 
 74 
 75 
 76 
 77 
 78 
 79 
 80 
 81



   
   
   
   
 61 
   
 59 
   
  


   
 37 
   
   
   
   
   
 31 
  


 67 
   
 17 
   
   
   
 13 
   
  


   
   
   
  5 
   
  3 
   
 29 
  


   
   
 19 
   
   
  2 
 11 
   
 53


   
 41 
   
  7 
   
   
   
   
  


 71 
   
   
   
 23 
   
   
   
  


   
 43 
   
   
   
 47 
   
   
  


 73 
   
   
   
   
   
 79 
   
  



   
   
   
   
  • 
   
  • 
   
  


   
  • 
   
   
   
   
   
  • 
  


  • 
   
  • 
   
   
   
  • 
   
  


   
   
   
  • 
   
  • 
   
  • 
  


   
   
  • 
   
   
  • 
  • 
   
  •


   
  • 
   
  • 
   
   
   
   
  


  • 
   
   
   
  • 
   
   
   
  


   
  • 
   
   
   
  • 
   
   
  


  • 
   
   
   
   
   
  • 
   
  



The Ulam spiral becomes more visually obvious as the grid increases in size.



Task
For any sized   N × N   grid,   construct and show an Ulam spiral (counter-clockwise) of primes starting at some specified initial number   (the default would be 1),   with some suitably   dotty   (glyph) representation to indicate primes,   and the absence of dots to indicate non-primes.

You should demonstrate the generator by showing at Ulam prime spiral large enough to (almost) fill your terminal screen.



Related tasks

   Spiral matrix
   Zig-zag matrix
   Identity matrix 
   Sequence of primes by Trial Division


See also
 Wikipedia entry:   Ulam spiral 
 MathWorld™ entry:   Prime Spiral

",#Go,Go,"package main
 
import (
	""math""
	""fmt""
)
 
type Direction byte
 
const (
	RIGHT Direction = iota
	UP
	LEFT
	DOWN
)
 
func generate(n,i int, c byte) {
	s := make([][]string, n)
	for i := 0; i < n; i++ { s[i] = make([]string, n) }
	dir := RIGHT
	y := n / 2
	var x int
	if (n % 2 == 0) { x = y - 1 } else { x = y } // shift left for even n's
 
	for j := i; j <= n * n - 1 + i; j++ {
		if (isPrime(j)) {
			if (c == 0) { s[y][x] = fmt.Sprintf(""%3d"", j) } else { s[y][x] = fmt.Sprintf(""%2c "", c) }
		} else { s[y][x] = ""---"" }
 
		switch dir {
		case RIGHT : if (x <= n - 1 && s[y - 1][x] == """" && j > i) { dir = UP }
		case UP : if (s[y][x - 1] == """") { dir = LEFT }
		case LEFT : if (x == 0 || s[y + 1][x] == """") { dir = DOWN }
		case DOWN : if (s[y][x + 1] == """") { dir = RIGHT }
		}
 
		switch dir {
		case RIGHT : x += 1
		case UP : y -= 1
		case LEFT : x -= 1
		case DOWN : y += 1
		}
	}
 
	for _, row := range s { fmt.Println(fmt.Sprintf(""%v"", row)) }
	fmt.Println()
}
 
func isPrime(a int) bool {
	if (a == 2) { return true }
	if (a <= 1 || a % 2 == 0) { return false }
	max := int(math.Sqrt(float64(a)))
	for n := 3; n <= max; n += 2 { if (a % n == 0) { return false } }
	return true
}
 
func main() {
	generate(9, 1, 0) // with digits
	generate(9, 1, '*') // with *
}",1272,60
6310,http://rosettacode.org/wiki/Twelve_statements,Twelve statements,"This puzzle is borrowed from   math-frolic.blogspot.



Given the following twelve statements, which of them are true?

 1.  This is a numbered list of twelve statements.
 2.  Exactly 3 of the last 6 statements are true.
 3.  Exactly 2 of the even-numbered statements are true.
 4.  If statement 5 is true, then statements 6 and 7 are both true.
 5.  The 3 preceding statements are all false.
 6.  Exactly 4 of the odd-numbered statements are true.
 7.  Either statement 2 or 3 is true, but not both.
 8.  If statement 7 is true, then 5 and 6 are both true.
 9.  Exactly 3 of the first 6 statements are true.
10.  The next two statements are both true.
11.  Exactly 1 of statements 7, 8 and 9 are true.
12.  Exactly 4 of the preceding statements are true.



Task

When you get tired of trying to figure it out in your head,
write a program to solve it, and print the correct answer or answers.



Extra credit

Print out a table of near misses, that is, solutions that are contradicted by only a single statement.



",#Go,Go,"package main
 
import ""fmt""
 
// its' not too much more work to check all the permutations concurrently
var solution = make(chan int)
var nearMiss = make(chan int)
var done = make(chan bool)
 
func main() {
    // iterate and use the bits as the permutation
    for i := 0; i < 4096; i++ {
        go checkPerm(i)
    }
    // collect the misses and list them after the complete solution(s)
    var ms []int
    for i := 0; i < 4096; {
        select {
        case <-done:
            i++
        case s := <-solution:
            print12(""solution"", s)
        case m := <-nearMiss:
            ms = append(ms, m)
        }
    }
    for _, m := range ms {
        print12(""near miss"", m)
    }
}
 
func print12(label string, bits int) {
    fmt.Print(label, "":"")
    for i := 1; i <= 12; i++ {
        if bits&1 == 1 {
            fmt.Print("" "", i)
        }
        bits >>= 1
    }
    fmt.Println()
}
 
func checkPerm(tz int) {
    // closure returns true if tz bit corresponding to
    // 1-based statement number is 1.
    ts := func(n uint) bool {
        return tz>>(n-1)&1 == 1
    }
    // variadic closure returns number of statements listed as arguments
    // which have corresponding tz bit == 1.
    ntrue := func(xs ...uint) int {
        nt := 0
        for _, x := range xs {
            if ts(x) {
                nt++
            }
        }
        return nt
    }
    // a flag used on repeated calls to test.
    // set to true when first contradiction is found.
    // if another is found, this function (checkPerm) can ""short circuit""
    // and return immediately without checking additional statements.
    var con bool
    // closure called to test each statement
    test := func(statement uint, b bool) {
        switch {
        case ts(statement) == b:
        case con:
            panic(""bail"")
        default:
            con = true
        }
    }
    // short circuit mechanism
    defer func() {
        if x := recover(); x != nil {
            if msg, ok := x.(string); !ok && msg != ""bail"" {
                panic(x)
            }
        }
        done <- true
    }()
 
    // 1. This is a numbered list of twelve statements.
    test(1, true)
 
    // 2. Exactly 3 of the last 6 statements are true.
    test(2, ntrue(7, 8, 9, 10, 11, 12) == 3)
 
    // 3. Exactly 2 of the even-numbered statements are true.
    test(3, ntrue(2, 4, 6, 8, 10, 12) == 2)
 
    // 4. If statement 5 is true, then statements 6 and 7 are both true.
    test(4, !ts(5) || ts(6) && ts(7))
 
    // 5. The 3 preceding statements are all false.
    test(5, !ts(4) && !ts(3) && !ts(2))
 
    // 6. Exactly 4 of the odd-numbered statements are true.
    test(6, ntrue(1, 3, 5, 7, 9, 11) == 4)
 
    // 7. Either statement 2 or 3 is true, but not both.
    test(7, ts(2) != ts(3))
 
    // 8. If statement 7 is true, then 5 and 6 are both true.
    test(8, !ts(7) || ts(5) && ts(6))
 
    // 9. Exactly 3 of the first 6 statements are true.
    test(9, ntrue(1, 2, 3, 4, 5, 6) == 3)
 
    // 10. The next two statements are both true.
    test(10, ts(11) && ts(12))
 
    // 11. Exactly 1 of statements 7, 8 and 9 are true.
    test(11, ntrue(7, 8, 9) == 1)
 
    // 12. Exactly 4 of the preceding statements are true.
    test(12, ntrue(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11) == 4)
 
    // no short circuit? send permutation as either near miss or solution
    if con {
        nearMiss <- tz
    } else {
        solution <- tz
    }
}",3453,127
6311,http://rosettacode.org/wiki/Truth_table,Truth table,"A truth table is a display of the inputs to, and the output of a Boolean function organized as a table where each row gives one combination of input values and the corresponding value of the function.



Task

 Input a Boolean function from the user as a string then calculate and print a formatted truth table for the given function.
 (One can assume that the user input is correct).
 Print and show output for Boolean functions of two and three input variables, but any program should not be limited to that many variables in the function. 
 Either reverse-polish or infix notation expressions are allowed.


Related tasks

   Boolean values
   Ternary logic


See also

   Wolfram MathWorld entry on truth tables.
   some ""truth table"" examples from Google.

",#Go,Go,"package main
 
import (
    ""bufio""
    ""errors""
    ""fmt""
    ""go/ast""
    ""go/parser""
    ""go/token""
    ""os""
    ""reflect""
)
 
func main() {
    in := bufio.NewScanner(os.Stdin)
    for {
        fmt.Print(""Expr:  "")
        in.Scan()
        if err := in.Err(); err != nil {
            fmt.Println(err)
            return
        }
        if !tt(in.Text()) {
            return
        }
    }
}
 
func tt(expr string) bool {
    // call library parser
    tree, err := parser.ParseExpr(expr)
    if err != nil {
        fmt.Println(err)
        return false
    }
    // create handy object to pass around
    e := &evaluator{nil, map[string]bool{}, tree}
    // library tree traversal function calls e.Visit for each node.
    // use this to collect variables of the expression.
    ast.Walk(e, tree)
    // print headings for truth table
    for _, n := range e.names {
        fmt.Printf(""%-6s"", n)
    }
    fmt.Println("" "", expr)
    // start recursive table generation function on first variable
    e.evalVar(0)
    return true
}
 
type evaluator struct {
    names []string        // variables, in order of appearance
    val   map[string]bool // map variables to boolean values
    tree  ast.Expr        // parsed expression as ast
}
 
// visitor function called by library Walk function.
// builds a list of unique variable names.
func (e *evaluator) Visit(n ast.Node) ast.Visitor {
    if id, ok := n.(*ast.Ident); ok {
        if !e.val[id.Name] {
            e.names = append(e.names, id.Name)
            e.val[id.Name] = true
        }
    }
    return e
}
 
// method recurses for each variable of the truth table, assigning it to
// false, then true.  At bottom of recursion, when all variables are
// assigned, it evaluates the expression and outputs one line of the
// truth table
func (e *evaluator) evalVar(nx int) bool {
    if nx == len(e.names) {
        // base case
        v, err := evalNode(e.tree, e.val)
        if err != nil {
            fmt.Println("" "", err)
            return false
        }
        // print variable values
        for _, n := range e.names {
            fmt.Printf(""%-6t"", e.val[n])
        }
        // print expression value
        fmt.Println("" "", v)
        return true
    }
    // recursive case
    for _, v := range []bool{false, true} {
        e.val[e.names[nx]] = v
        if !e.evalVar(nx + 1) {
            return false
        }
    }
    return true
}
 
// recursively evaluate ast
func evalNode(nd ast.Node, val map[string]bool) (bool, error) {
    switch n := nd.(type) {
    case *ast.Ident:
        return val[n.Name], nil
    case *ast.BinaryExpr:
        x, err := evalNode(n.X, val)
        if err != nil {
            return false, err
        }
        y, err := evalNode(n.Y, val)
        if err != nil {
            return false, err
        }
        switch n.Op {
        case token.AND:
            return x && y, nil
        case token.OR:
            return x || y, nil
        case token.XOR:
            return x != y, nil
        default:
            return unsup(n.Op)
        }
    case *ast.UnaryExpr:
        x, err := evalNode(n.X, val)
        if err != nil {
            return false, err
        }
        switch n.Op {
        case token.XOR:
            return !x, nil
        default:
            return unsup(n.Op)
        }
    case *ast.ParenExpr:
        return evalNode(n.X, val)
    }
    return unsup(reflect.TypeOf(nd))
}
 
func unsup(i interface{}) (bool, error) {
    return false, errors.New(fmt.Sprintf(""%v unsupported"", i))
}
 ",3548,143
6421,http://rosettacode.org/wiki/Topic_variable,Topic variable,"Several programming languages offer syntax shortcuts to deal with the notion of ""current"" or ""topic"" variable.

A topic variable is a special variable with a very short name which can also often be omitted.

Demonstrate the utilization and behaviour of the topic variable within the language and explain or demonstrate how the topic variable behaves under different levels of nesting or scope, if this applies, within the language.

For instance you can (but you don't have to) show how the topic variable can be used by assigning the number 



3


{\displaystyle 3}

 to it and then computing its square and square root.



",#Go,Go,"package main
 
import (
    ""math""
    ""os""
    ""strconv""
    ""text/template""
)
 
func sqr(x string) string {
    f, err := strconv.ParseFloat(x, 64)
    if err != nil {
        return ""NA""
    }
    return strconv.FormatFloat(f*f, 'f', -1, 64)
}
 
func sqrt(x string) string {
    f, err := strconv.ParseFloat(x, 64)
    if err != nil {
        return ""NA""
    }
    return strconv.FormatFloat(math.Sqrt(f), 'f', -1, 64)
}
 
func main() {
    f := template.FuncMap{""sqr"": sqr, ""sqrt"": sqrt}
    t := template.Must(template.New("""").Funcs(f).Parse(`. = {{.}}
square: {{sqr .}}
square root: {{sqrt .}}
`))
    t.Execute(os.Stdout, ""3"")
}",635,33
6465,http://rosettacode.org/wiki/Topswops,Topswops,"Topswops is a card game created by John Conway in the 1970's.



Assume you have a particular permutation of a set of   n   cards numbered   1..n   on both of their faces, for example the arrangement of four cards given by   [2, 4, 1, 3]   where the leftmost card is on top.

A round is composed of reversing the first   m   cards where   m   is the value of the topmost card.

Rounds are repeated until the topmost card is the number   1   and the number of swaps is recorded.



For our example the swaps produce:

    
    [2, 4, 1, 3]    # Initial shuffle
    [4, 2, 1, 3]
    [3, 1, 2, 4]
    [2, 1, 3, 4]
    [1, 2, 3, 4]

For a total of four swaps from the initial ordering to produce the terminating case where   1   is on top.



For a particular number    n    of cards,    topswops(n)    is the maximum swaps needed for any starting permutation of the   n   cards.



Task

The task is to generate and show here a table of    n    vs    topswops(n)    for    n    in the range   1..10   inclusive.



Note

Topswops   is also known as   Fannkuch   from the German word   Pfannkuchen   meaning   pancake.



Related tasks

   Number reversal game
   Sorting algorithms/Pancake sort

",#Go,Go,"// Adapted from http://www-cs-faculty.stanford.edu/~uno/programs/topswops.w
// at Donald Knuth's web site.  Algorithm credited there to Pepperdine
// and referenced to Mathematical Gazette 73 (1989), 131-133.
package main
 
import ""fmt""
 
const ( // array sizes
    maxn = 10 // max number of cards
    maxl = 50 // upper bound for number of steps
)
 
func main() {
    for i := 1; i <= maxn; i++ {
        fmt.Printf(""%d: %d\n"", i, steps(i))
    }
}
 
func steps(n int) int {
    var a, b [maxl][maxn + 1]int
    var x [maxl]int
    a[0][0] = 1
    var m int
    for l := 0; ; {
        x[l]++
        k := int(x[l])
        if k >= n {
            if l <= 0 {
                break
            }
            l--
            continue
        }
        if a[l][k] == 0 {
            if b[l][k+1] != 0 {
                continue
            }
        } else if a[l][k] != k+1 {
            continue
        }
        a[l+1] = a[l]
        for j := 1; j <= k; j++ {
            a[l+1][j] = a[l][k-j]
        }
        b[l+1] = b[l]
        a[l+1][0] = k + 1
        b[l+1][k+1] = 1
        if l > m-1 {
            m = l + 1
        }
        l++
        x[l] = 0
    }
    return m
}",1182,55
6515,http://rosettacode.org/wiki/Truncatable_primes,Truncatable primes,"A truncatable prime is a prime number that when you successively remove digits from one end of the prime, you are left with a new prime number.



Examples

The number 997 is called a left-truncatable prime as the numbers 997, 97, and 7 are all prime.

The number 7393 is a right-truncatable prime as the numbers 7393, 739, 73, and 7 formed by removing digits from its right are also prime.

No zeroes are allowed in truncatable primes.



Task

The task is to find the largest left-truncatable and right-truncatable primes less than one million (base 10 is implied).



Related tasks
 
 Find largest left truncatable prime in a given base
 Sieve of Eratosthenes


See also

 Truncatable Prime from MathWorld.]

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    sieve(1e6)
    if !search(6, 1e6, ""left"", func(n, pot int) int { return n % pot }) {
        panic(""997?"")
    }
    if !search(6, 1e6, ""right"", func(n, _ int) int { return n / 10 }) {
        panic(""7393?"")
    }
}
 
var c []bool
 
func sieve(ss int) {
    c = make([]bool, ss)
    c[1] = true
    for p := 2; ; {
        p2 := p * p
        if p2 >= ss {
            break
        }
        for i := p2; i < ss; i += p {
            c[i] = true
        }
        for {
            p++
            if !c[p] {
                break
            }
        }
    }
}
 
func search(digits, pot int, s string, truncFunc func(n, pot int) int) bool {
    n := pot - 1
    pot /= 10
smaller:
    for ; n >= pot; n -= 2 {
        for tn, tp := n, pot; tp > 0; tp /= 10 {
            if tn < tp || c[tn] {
                continue smaller
            }
            tn = truncFunc(tn, tp)
        }
        fmt.Println(""max"", s, ""truncatable:"", n)
        return true
    }
    if digits > 1 {
        return search(digits-1, pot, s, truncFunc)
    }
    return false
}",1106,55
6527,http://rosettacode.org/wiki/Total_circles_area,Total circles area,"Total circles area

You are encouraged to solve this task according to the task description, using any language you may know.
 Example circles
 Example circles filtered
Given some partially overlapping circles on the plane, compute and show the total area covered by them, with four or six (or a little more) decimal digits of precision. The area covered by two or more disks needs to be counted only once.

One point of this Task is also to compare and discuss the relative merits of various solution strategies, their performance, precision and simplicity. This means keeping both slower and faster solutions for a language (like C) is welcome.

To allow a better comparison of the different implementations, solve the problem with this standard dataset, each line contains the x and y coordinates of the centers of the disks and their radii   (11 disks are fully contained inside other disks):

         xc              yc          radius
     1.6417233788   1.6121789534   0.0848270516
    -1.4944608174   1.2077959613   1.1039549836
     0.6110294452  -0.6907087527   0.9089162485
     0.3844862411   0.2923344616   0.2375743054
    -0.2495892950  -0.3832854473   1.0845181219
     1.7813504266   1.6178237031   0.8162655711
    -0.1985249206  -0.8343333301   0.0538864941
    -1.7011985145  -0.1263820964   0.4776976918
    -0.4319462812   1.4104420482   0.7886291537
     0.2178372997  -0.9499557344   0.0357871187
    -0.6294854565  -1.3078893852   0.7653357688
     1.7952608455   0.6281269104   0.2727652452
     1.4168575317   1.0683357171   1.1016025378
     1.4637371396   0.9463877418   1.1846214562
    -0.5263668798   1.7315156631   1.4428514068
    -1.2197352481   0.9144146579   1.0727263474
    -0.1389358881   0.1092805780   0.7350208828
     1.5293954595   0.0030278255   1.2472867347
    -0.5258728625   1.3782633069   1.3495508831
    -0.1403562064   0.2437382535   1.3804956588
     0.8055826339  -0.0482092025   0.3327165165
    -0.6311979224   0.7184578971   0.2491045282
     1.4685857879  -0.8347049536   1.3670667538
    -0.6855727502   1.6465021616   1.0593087096
     0.0152957411   0.0638919221   0.9771215985

The result is   21.56503660... .



Related task

   Circles of given radius through two points.


See also

 http://www.reddit.com/r/dailyprogrammer/comments/zff9o/9062012_challenge_96_difficult_water_droplets/
 http://stackoverflow.com/a/1667789/10562

",#Go,Go,"package main
 
import (
        ""flag""
        ""fmt""
        ""math""
        ""runtime""
        ""sort""
)
 
// Note, the standard ""image"" package has Point and Rectangle but we
// can't use them here since they're defined using int rather than
// float64.
 
type Circle struct{ X, Y, R, rsq float64 }
 
func NewCircle(x, y, r float64) Circle {
        // We pre-calculate r² as an optimization
        return Circle{x, y, r, r * r}
}
 
func (c Circle) ContainsPt(x, y float64) bool {
        return distSq(x, y, c.X, c.Y) <= c.rsq
}
 
func (c Circle) ContainsC(c2 Circle) bool {
        return distSq(c.X, c.Y, c2.X, c2.Y) <= (c.R-c2.R)*(c.R-c2.R)
}
 
func (c Circle) ContainsR(r Rect) (full, corner bool) {
        nw := c.ContainsPt(r.NW())
        ne := c.ContainsPt(r.NE())
        sw := c.ContainsPt(r.SW())
        se := c.ContainsPt(r.SE())
        return nw && ne && sw && se, nw || ne || sw || se
}
 
func (c Circle) North() (float64, float64) { return c.X, c.Y + c.R }
func (c Circle) South() (float64, float64) { return c.X, c.Y - c.R }
func (c Circle) West() (float64, float64)  { return c.X - c.R, c.Y }
func (c Circle) East() (float64, float64)  { return c.X + c.R, c.Y }
 
type Rect struct{ X1, Y1, X2, Y2 float64 }
 
func (r Rect) Area() float64          { return (r.X2 - r.X1) * (r.Y2 - r.Y1) }
func (r Rect) NW() (float64, float64) { return r.X1, r.Y2 }
func (r Rect) NE() (float64, float64) { return r.X2, r.Y2 }
func (r Rect) SW() (float64, float64) { return r.X1, r.Y1 }
func (r Rect) SE() (float64, float64) { return r.X2, r.Y1 }
 
func (r Rect) Centre() (float64, float64) {
        return (r.X1 + r.X2) / 2.0, (r.Y1 + r.Y2) / 2.0
}
 
func (r Rect) ContainsPt(x, y float64) bool {
        return r.X1 <= x && x < r.X2 &&
                r.Y1 <= y && y < r.Y2
}
 
func (r Rect) ContainsPC(c Circle) bool { //  only N,W,E,S points of circle
        return r.ContainsPt(c.North()) ||
                r.ContainsPt(c.South()) ||
                r.ContainsPt(c.West()) ||
                r.ContainsPt(c.East())
}
 
func (r Rect) MinSide() float64 {
        return math.Min(r.X2-r.X1, r.Y2-r.Y1)
}
 
func distSq(x1, y1, x2, y2 float64) float64 {
        Δx, Δy := x2-x1, y2-y1
        return (Δx * Δx) + (Δy * Δy)
}
 
type CircleSet []Circle
 
// sort.Interface for sorting by radius big to small:
func (s CircleSet) Len() int           { return len(s) }
func (s CircleSet) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
func (s CircleSet) Less(i, j int) bool { return s[i].R > s[j].R }
 
func (sp *CircleSet) RemoveContainedC() {
        s := *sp
        sort.Sort(s)
        for i := 0; i < len(s); i++ {
                for j := i + 1; j < len(s); {
                        if s[i].ContainsC(s[j]) {
                                s[j], s[len(s)-1] = s[len(s)-1], s[j]
                                s = s[:len(s)-1]
                        } else {
                                j++
                        }
                }
        }
        *sp = s
}
 
func (s CircleSet) Bounds() Rect {
        x1 := s[0].X - s[0].R
        x2 := s[0].X + s[0].R
        y1 := s[0].Y - s[0].R
        y2 := s[0].Y + s[0].R
        for _, c := range s[1:] {
                x1 = math.Min(x1, c.X-c.R)
                x2 = math.Max(x2, c.X+c.R)
                y1 = math.Min(y1, c.Y-c.R)
                y2 = math.Max(y2, c.Y+c.R)
        }
        return Rect{x1, y1, x2, y2}
}
 
var nWorkers = 4
 
func (s CircleSet) UnionArea(ε float64) (min, max float64) {
        sort.Sort(s)
        stop := make(chan bool)
        inside := make(chan Rect)
        outside := make(chan Rect)
        unknown := make(chan Rect, 5e7) // XXX
 
        for i := 0; i < nWorkers; i++ {
                go s.worker(stop, unknown, inside, outside)
        }
        r := s.Bounds()
        max = r.Area()
        unknown <- r
        for max-min > ε {
                select {
                case r = <-inside:
                        min += r.Area()
                case r = <-outside:
                        max -= r.Area()
                }
        }
        close(stop)
        return min, max
}
 
func (s CircleSet) worker(stop <-chan bool, unk chan Rect, in, out chan<- Rect) {
        for {
                select {
                case <-stop:
                        return
                case r := <-unk:
                        inside, outside := s.CategorizeR(r)
                        switch {
                        case inside:
                                in <- r
                        case outside:
                                out <- r
                        default:
                                // Split
                                midX, midY := r.Centre()
                                unk <- Rect{r.X1, r.Y1, midX, midY}
                                unk <- Rect{midX, r.Y1, r.X2, midY}
                                unk <- Rect{r.X1, midY, midX, r.Y2}
                                unk <- Rect{midX, midY, r.X2, r.Y2}
                        }
                }
        }
}
 
func (s CircleSet) CategorizeR(r Rect) (inside, outside bool) {
        anyCorner := false
        for _, c := range s {
                full, corner := c.ContainsR(r)
                if full {
                        return true, false // inside
                }
                anyCorner = anyCorner || corner
        }
        if anyCorner {
                return false, false // uncertain
        }
        for _, c := range s {
                if r.ContainsPC(c) {
                        return false, false // uncertain
                }
        }
        return false, true // outside
}
 
func main() {
        flag.IntVar(&nWorkers, ""workers"", nWorkers, ""how many worker go routines to use"")
        maxproc := flag.Int(""cpu"", runtime.NumCPU(), ""GOMAXPROCS setting"")
        flag.Parse()
 
        if *maxproc > 0 {
                runtime.GOMAXPROCS(*maxproc)
        } else {
                *maxproc = runtime.GOMAXPROCS(0)
        }
 
        circles := CircleSet{
                NewCircle(1.6417233788, 1.6121789534, 0.0848270516),
                NewCircle(-1.4944608174, 1.2077959613, 1.1039549836),
                NewCircle(0.6110294452, -0.6907087527, 0.9089162485),
                NewCircle(0.3844862411, 0.2923344616, 0.2375743054),
                NewCircle(-0.2495892950, -0.3832854473, 1.0845181219),
                NewCircle(1.7813504266, 1.6178237031, 0.8162655711),
                NewCircle(-0.1985249206, -0.8343333301, 0.0538864941),
                NewCircle(-1.7011985145, -0.1263820964, 0.4776976918),
                NewCircle(-0.4319462812, 1.4104420482, 0.7886291537),
                NewCircle(0.2178372997, -0.9499557344, 0.0357871187),
                NewCircle(-0.6294854565, -1.3078893852, 0.7653357688),
                NewCircle(1.7952608455, 0.6281269104, 0.2727652452),
                NewCircle(1.4168575317, 1.0683357171, 1.1016025378),
                NewCircle(1.4637371396, 0.9463877418, 1.1846214562),
                NewCircle(-0.5263668798, 1.7315156631, 1.4428514068),
                NewCircle(-1.2197352481, 0.9144146579, 1.0727263474),
                NewCircle(-0.1389358881, 0.1092805780, 0.7350208828),
                NewCircle(1.5293954595, 0.0030278255, 1.2472867347),
                NewCircle(-0.5258728625, 1.3782633069, 1.3495508831),
                NewCircle(-0.1403562064, 0.2437382535, 1.3804956588),
                NewCircle(0.8055826339, -0.0482092025, 0.3327165165),
                NewCircle(-0.6311979224, 0.7184578971, 0.2491045282),
                NewCircle(1.4685857879, -0.8347049536, 1.3670667538),
                NewCircle(-0.6855727502, 1.6465021616, 1.0593087096),
                NewCircle(0.0152957411, 0.0638919221, 0.9771215985),
        }
        fmt.Println(""Starting with"", len(circles), ""circles."")
        circles.RemoveContainedC()
        fmt.Println(""Removing redundant ones leaves"", len(circles), ""circles."")
        fmt.Println(""Using"", nWorkers, ""workers with maxprocs ="", *maxproc)
        const ε = 0.0001
        min, max := circles.UnionArea(ε)
        avg := (min + max) / 2.0
        rng := max - min
        fmt.Printf(""Area = %v±%v\n"", avg, rng)
        fmt.Printf(""Area ≈ %.*f\n"", 5, avg)
}",8227,232
6594,http://rosettacode.org/wiki/Trabb_Pardo%E2%80%93Knuth_algorithm,Trabb Pardo–Knuth algorithm,"The TPK algorithm is an early example of a programming chrestomathy.
It was used in Donald Knuth and Luis Trabb Pardo's Stanford tech report The Early Development of Programming Languages.
The report traces the early history of work in developing computer languages in the 1940s and 1950s, giving several translations of the algorithm.

From the wikipedia entry:

ask for 11 numbers to be read into a sequence S
reverse sequence S
for each item in sequence S
    result := call a function to do an operation
    if result overflows
        alert user
    else
        print result

The task is to implement the algorithm:

 Use the function:     



f
(
x
)
=

|

x


|


0.5


+
5

x

3




{\displaystyle f(x)=|x|^{0.5}+5x^{3}}


 The overflow condition is an answer of greater than 400.
 The 'user alert' should not stop processing of other items of the sequence.
 Print a prompt before accepting eleven, textual, numeric inputs.
 You may optionally print the item as well as its associated result, but the results must be in reverse order of input.
 The sequence    S    may be 'implied' and so not shown explicitly.
 Print and show the program in action from a typical run here. (If the output is graphical rather than text then either add a screendump or describe textually what is displayed).

",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math""
)
 
func main() {
    // prompt
    fmt.Print(""Enter 11 numbers: "")
    // accept sequence
    var s [11]float64
    for i := 0; i < 11; {
        if n, _ := fmt.Scan(&s[i]); n > 0 {
            i++
        }
    }
    // reverse sequence
    for i, item := range s[:5] {
        s[i], s[10-i] = s[10-i], item
    }
    // iterate
    for _, item := range s {
        if result, overflow := f(item); overflow {
            // send alerts to stderr
            log.Printf(""f(%g) overflow"", item)
        } else {
            // send normal results to stdout
            fmt.Printf(""f(%g) = %g\n"", item, result)
        }
    }
}
 
func f(x float64) (float64, bool) {
    result := math.Sqrt(math.Abs(x)) + 5*x*x*x
    return result, result > 400
}",801,38
6611,http://rosettacode.org/wiki/Universal_Turing_machine,Universal Turing machine,"One of the foundational mathematical constructs behind computer science
is the universal Turing Machine.



(Alan Turing introduced the idea of such a machine in 1936–1937.)

Indeed one way to definitively prove that a language
is turing-complete
is to implement a universal Turing machine in it.



Task

Simulate such a machine capable
of taking the definition of any other Turing machine and executing it.

Of course, you will not have an infinite tape,
but you should emulate this as much as is possible.

The three permissible actions on the tape are ""left"", ""right"" and ""stay"".

To test your universal Turing machine (and prove your programming language
is Turing complete!), you should execute the following two Turing machines
based on the following definitions.


Simple incrementer

 States: q0, qf
 Initial state: q0
 Terminating states: qf
 Permissible symbols: B, 1
 Blank symbol: B
 Rules:
 (q0, 1, 1, right, q0)
 (q0, B, 1, stay, qf)


The input for this machine should be a tape of 1 1 1


Three-state busy beaver

 States: a, b, c, halt
 Initial state: a
 Terminating states: halt
 Permissible symbols: 0, 1
 Blank symbol: 0
 Rules:
 (a, 0, 1, right, b)
 (a, 1, 1, left, c)
 (b, 0, 1, left, a)
 (b, 1, 1, right, b)
 (c, 0, 1, left, b)
 (c, 1, 1, stay, halt)


The input for this machine should be an empty tape.


Bonus:

5-state, 2-symbol probable Busy Beaver machine from Wikipedia

 States: A, B, C, D, E, H
 Initial state: A
 Terminating states: H
 Permissible symbols: 0, 1
 Blank symbol: 0
 Rules:
 (A, 0, 1, right, B)
 (A, 1, 1, left, C)
 (B, 0, 1, right, C)
 (B, 1, 1, right, B)
 (C, 0, 1, right, D)
 (C, 1, 0, left, E)
 (D, 0, 1, left, A)
 (D, 1, 1, left, D)
 (E, 0, 1, stay, H)
 (E, 1, 0, left, A)


The input for this machine should be an empty tape.

This machine runs for more than 47 millions steps.



",#Go,Go,"package turing
 
type Symbol byte
 
type Motion byte
 
const (
        Left  Motion = 'L'
        Right Motion = 'R'
        Stay  Motion = 'N'
)
 
type Tape struct {
        data      []Symbol
        pos, left int
        blank     Symbol
}
 
// NewTape returns a new tape filled with 'data' and position set to 'start'.
// 'start' does not need to be range, the tape will be extended if required.
func NewTape(blank Symbol, start int, data []Symbol) *Tape {
        t := &Tape{
                data:  data,
                blank: blank,
        }
        if start < 0 {
                t.Left(-start)
        }
        t.Right(start)
        return t
}
 
func (t *Tape) Stay()          {}
func (t *Tape) Data() []Symbol { return t.data[t.left:] }
func (t *Tape) Read() Symbol   { return t.data[t.pos] }
func (t *Tape) Write(s Symbol) { t.data[t.pos] = s }
 
func (t *Tape) Dup() *Tape {
        t2 := &Tape{
                data:  make([]Symbol, len(t.Data())),
                blank: t.blank,
        }
        copy(t2.data, t.Data())
        t2.pos = t.pos - t.left
        return t2
}
 
func (t *Tape) String() string {
        s := """"
        for i := t.left; i < len(t.data); i++ {
                b := t.data[i]
                if i == t.pos {
                        s += ""["" + string(b) + ""]""
                } else {
                        s += "" "" + string(b) + "" ""
                }
        }
        return s
}
 
func (t *Tape) Move(a Motion) {
        switch a {
        case Left:
                t.Left(1)
        case Right:
                t.Right(1)
        case Stay:
                t.Stay()
        }
}
 
const minSz = 16
 
func (t *Tape) Left(n int) {
        t.pos -= n
        if t.pos < 0 {
                // Extend left
                var sz int
                for sz = minSz; cap(t.data[t.left:])-t.pos >= sz; sz <<= 1 {
                }
                newd := make([]Symbol, sz)
                newl := len(newd) - cap(t.data[t.left:])
                n := copy(newd[newl:], t.data[t.left:])
                t.data = newd[:newl+n]
                t.pos += newl - t.left
                t.left = newl
        }
        if t.pos < t.left {
                if t.blank != 0 {
                        for i := t.pos; i < t.left; i++ {
                                t.data[i] = t.blank
                        }
                }
                t.left = t.pos
        }
}
 
func (t *Tape) Right(n int) {
        t.pos += n
        if t.pos >= cap(t.data) {
                // Extend right
                var sz int
                for sz = minSz; t.pos >= sz; sz <<= 1 {
                }
                newd := make([]Symbol, sz)
                n := copy(newd[t.left:], t.data[t.left:])
                t.data = newd[:t.left+n]
        }
        if i := len(t.data); t.pos >= i {
                t.data = t.data[:t.pos+1]
                if t.blank != 0 {
                        for ; i < len(t.data); i++ {
                                t.data[i] = t.blank
                        }
                }
        }
}
 
type State string
 
type Rule struct {
        State
        Symbol
        Write Symbol
        Motion
        Next State
}
 
func (i *Rule) key() key       { return key{i.State, i.Symbol} }
func (i *Rule) action() action { return action{i.Write, i.Motion, i.Next} }
 
type key struct {
        State
        Symbol
}
 
type action struct {
        write Symbol
        Motion
        next State
}
 
type Machine struct {
        tape         *Tape
        start, state State
        transition   map[key]action
        l            func(string, ...interface{}) // XXX
}
 
func NewMachine(rules []Rule) *Machine {
        m := &Machine{transition: make(map[key]action, len(rules))}
        if len(rules) > 0 {
                m.start = rules[0].State
        }
        for _, r := range rules {
                m.transition[r.key()] = r.action()
        }
        return m
}
 
func (m *Machine) Run(input *Tape) (int, *Tape) {
        m.tape = input.Dup()
        m.state = m.start
        for cnt := 0; ; cnt++ {
                if m.l != nil {
                        m.l(""%3d %4s: %v\n"", cnt, m.state, m.tape)
                }
                sym := m.tape.Read()
                act, ok := m.transition[key{m.state, sym}]
                if !ok {
                        return cnt, m.tape
                }
                m.tape.Write(act.write)
                m.tape.Move(act.Motion)
                m.state = act.next
        }
}",4497,177
6672,http://rosettacode.org/wiki/Tonelli-Shanks_algorithm,Tonelli-Shanks algorithm,"

 This page uses content from Wikipedia. The original article was at Tonelli-Shanks algorithm. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In computational number theory, the Tonelli–Shanks algorithm is a technique for solving for x in a congruence of the form:


 x2 ≡ n (mod p)

where n is an integer which is a quadratic residue (mod p), p is an odd prime, and x,n ∈ Fp where Fp = {0, 1, ..., p - 1}.

It is used in cryptography techniques.



To apply the algorithm, we need the Legendre symbol:

The Legendre symbol (a | p) denotes the value of a(p-1)/2 (mod p).

 (a | p) ≡ 1    if a is a square (mod p)
 (a | p) ≡ -1    if a is not a square (mod p)
 (a | p) ≡ 0    if a ≡ 0 (mod p) 


Algorithm pseudo-code


All ≡ are taken to mean (mod p) unless stated otherwise.

 Input: p an odd prime, and an integer n .
 Step 0: Check that n is indeed a square: (n | p) must be ≡ 1 .
 Step 1: By factoring out powers of 2 from p - 1, find q and s such that p - 1 = q2s with q odd .
 If p ≡ 3 (mod 4) (i.e. s = 1), output the two solutions r ≡ ± n(p+1)/4 .
 Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq .
 Step 3: Set r ≡ n(q+1)/2, t ≡ nq, m = s .
 Step 4: Loop the following:
 If t ≡ 1, output r and p - r .
 Otherwise find, by repeated squaring, the lowest i, 0 < i < m , such that t2i ≡ 1 .
 Let b ≡ c2(m - i - 1), and set r ≡ rb, t ≡ tb2, c ≡ b2 and m = i .




Task

Implement the above algorithm.

Find solutions (if any) for

 n = 10 p = 13
 n = 56 p = 101
 n = 1030 p = 10009
 n = 1032 p = 10009
 n = 44402 p = 100049 
Extra credit

 n = 665820697 p = 1000000009 
 n = 881398088036 p = 1000000000039 
 n = 41660815127637347468140745042827704103445750172002 p = 10^50 + 577 


See also

 Modular exponentiation
 Cipolla's algorithm

",#Go,Go,"package main
 
import ""fmt""
 
// Arguments n, p as described in WP
// If Legendre symbol != 1, ok return is false.  Otherwise ok return is true,
// R1 is WP return value R and for convenience R2 is p-R1.
func ts(n, p int) (R1, R2 int, ok bool) {
    // a^e mod p
    powModP := func(a, e int) int {
        s := 1
        for ; e > 0; e-- {
            s = s * a % p
        }
        return s
    }
    // Legendre symbol, returns 1, 0, or -1 mod p -- that's 1, 0, or p-1.
    ls := func(a int) int {
        return powModP(a, (p-1)/2)
    }
    // argument validation
    if ls(n) != 1 {
        return 0, 0, false
    }
    // WP step 1, factor out powers two.
    // variables Q, S named as at WP.
    Q := p - 1
    S := 0
    for Q&1 == 0 {
        S++
        Q >>= 1
    }
    // WP step 1, direct solution
    if S == 1 {
        R1 = powModP(n, (p+1)/4)
        return R1, p - R1, true
    }
    // WP step 2, select z, assign c
    z := 2
    for ; ls(z) != p-1; z++ {
    }
    c := powModP(z, Q)
    // WP step 3, assign R, t, M
    R := powModP(n, (Q+1)/2)
    t := powModP(n, Q)
    M := S
    // WP step 4, loop
    for {
        // WP step 4.1, termination condition
        if t == 1 {
            return R, p - R, true
        }
        // WP step 4.2, find lowest i...
        i := 0
        for z := t; z != 1 && i < M-1; {
            z = z * z % p
            i++
        }
        // WP step 4.3, using a variable b, assign new values of R, t, c, M
        b := c
        for e := M - i - 1; e > 0; e-- {
            b = b * b % p
        }
        R = R * b % p
        c = b * b % p // more convenient to compute c before t
        t = t * c % p
        M = i
    }
}
 
func main() {
    fmt.Println(ts(10, 13))
    fmt.Println(ts(56, 101))
    fmt.Println(ts(1030, 10009))
    fmt.Println(ts(1032, 10009))
    fmt.Println(ts(44402, 100049))
}",1869,77
6698,http://rosettacode.org/wiki/Totient_function,Totient function,"The   totient   function is also known as:

   Euler's totient function
   Euler's phi totient function
   phi totient function
    Φ    function   (uppercase Greek phi)
    φ     function   (lowercase Greek phi)


Definitions   (as per number theory)

The totient function:

   counts the integers up to a given positive integer   n   that are relatively prime to   n
   counts the integers   k   in the range   1 ≤ k ≤ n   for which the greatest common divisor   gcd(n,k)   is equal to   1
   counts numbers   ≤ n   and   prime to   n


If the totient number   (for N)   is one less than   N,   then   N   is prime.



Task

Create a   totient   function and:

   Find and display   (1 per line)   for the 1st   25   integers:
   the integer   (the index)
   the totient number for that integer
   indicate if that integer is prime
   Find and display the   count   of the primes up to          100
   Find and display the   count   of the primes up to       1,000
   Find and display the   count   of the primes up to     10,000
   Find and display the   count   of the primes up to   100,000     (optional)
Show all output here.



Related task

   Perfect totient numbers


Also see

   Wikipedia: Euler's totient function.
   MathWorld: totient function.
   OEIS: Euler totient function phi(n).

",#Go,Go,"package main
 
import ""fmt""
 
func gcd(n, k int) int {
    if n < k || k < 1 {
        panic(""Need n >= k and k >= 1"")
    }
 
    s := 1
    for n&1 == 0 && k&1 == 0 {
        n >>= 1
        k >>= 1
        s <<= 1
    }
 
    t := n
    if n&1 != 0 {
        t = -k
    }
    for t != 0 {
        for t&1 == 0 {
            t >>= 1
        }
        if t > 0 {
            n = t
        } else {
            k = -t
        }
        t = n - k
    }
    return n * s
}
 
func totient(n int) int {
    tot := 0
    for k := 1; k <= n; k++ {
        if gcd(n, k) == 1 {
            tot++
        }
    }
    return tot
}
 
func main() {
    fmt.Println("" n  phi   prime"")
    fmt.Println(""---------------"")
    count := 0
    for n := 1; n <= 25; n++ {
        tot := totient(n)
        isPrime := n-1 == tot
        if isPrime {
            count++
        }
        fmt.Printf(""%2d   %2d   %t\n"", n, tot, isPrime)
    }
    fmt.Println(""\nNumber of primes up to 25     ="", count)
    for n := 26; n <= 100000; n++ {
        tot := totient(n)
        if tot == n-1 {
            count++
        }
        if n == 100 || n == 1000 || n%10000 == 0 {
            fmt.Printf(""\nNumber of primes up to %-6d = %d\n"", n, count)
        }
    }
}",1239,67
6838,http://rosettacode.org/wiki/Tokenize_a_string_with_escaping,Tokenize a string with escaping,"Task[edit]
Write a function or program that can split a string at each non-escaped occurrence of a separator character.

It should accept three input parameters:

   The string
   The separator character
   The escape character


It should output a list of strings.

Details
Rules for splitting:

 The fields that were separated by the separators, become the elements of the output list.
 Empty fields should be preserved, even at the start and end.


Rules for escaping:

 ""Escaped"" means preceded by an occurrence of the escape character that is not already escaped itself.
 When the escape character precedes a character that has no special meaning, it still counts as an escape (but does not do anything special).
 Each occurrence of the escape character that was used to escape something, should not become part of the output.


Test case
Demonstrate that your function satisfies the following test-case:



 Input

 Output





 string:

 one^|uno||three^^^^|four^^^|^cuatro|


 separator character:

 |


 escape character:

 ^





 one|uno


 


 three^^


 four^|cuatro


 


(Print the output list in any format you like, as long as it is it easy to see what the fields are.)


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
	""errors""
	""fmt""
)
 
func TokenizeString(s string, sep, escape rune) (tokens []string, err error) {
	var runes []rune
	inEscape := false
	for _, r := range s {
		switch {
		case inEscape:
			inEscape = false
			fallthrough
		default:
			runes = append(runes, r)
		case r == escape:
			inEscape = true
		case r == sep:
			tokens = append(tokens, string(runes))
			runes = runes[:0]
		}
	}
	tokens = append(tokens, string(runes))
	if inEscape {
		err = errors.New(""invalid terminal escape"")
	}
	return tokens, err
}
 
func main() {
	const sample = ""one^|uno||three^^^^|four^^^|^cuatro|""
	const separator = '|'
	const escape = '^'
 
	fmt.Printf(""Input:   %q\n"", sample)
	tokens, err := TokenizeString(sample, separator, escape)
	if err != nil {
		fmt.Println(""error:"", err)
	} else {
		fmt.Printf(""Tokens: %q\n"", tokens)
	}
}",846,44
6883,http://rosettacode.org/wiki/Thue-Morse,Thue-Morse,"Task

Create a Thue-Morse sequence.



See also
   YouTube entry: The Fairest Sharing Sequence Ever
   YouTube entry: Math and OCD - My story with the Thue-Morse sequence
   Task: Fairshare between two and more

",#Go,Go,"// prints the first few members of the Thue-Morse sequence
 
package main
 
import (
    ""fmt""
    ""bytes""
)
 
// sets tmBuffer to the next member of the Thue-Morse sequence
// tmBuffer must contain a valid Thue-Morse sequence member before the call
func nextTMSequenceMember( tmBuffer * bytes.Buffer ) {
    // ""flip"" the bytes, adding them to the buffer
    for b, currLength, currBytes := 0, tmBuffer.Len(), tmBuffer.Bytes() ; b < currLength; b ++ {
        if currBytes[ b ] == '1' {
            tmBuffer.WriteByte( '0' )
        } else {
            tmBuffer.WriteByte( '1' )
        }
    }
}
 
func main() {
    var tmBuffer bytes.Buffer
    // initial sequence member is ""0""
    tmBuffer.WriteByte( '0' )
    fmt.Println( tmBuffer.String() )
    for i := 2; i <= 7; i ++ {
        nextTMSequenceMember( & tmBuffer )
        fmt.Println( tmBuffer.String() )
    }
}",872,32
6890,http://rosettacode.org/wiki/Topological_sort,Topological sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




Given a mapping between items, and items they depend on, a topological sort orders items so that no item precedes an item it depends upon.

The compiling of a library in the VHDL language has the constraint that a library must be compiled after any library it depends on.

A tool exists that extracts library dependencies.



Task

Write a function that will return a valid compile order of VHDL libraries from their dependencies.

 Assume library names are single words. 
 Items mentioned as only dependents, (sic), have no dependents of their own, but their order of compiling must be given.
 Any self dependencies should be ignored. 
 Any un-orderable dependencies should be flagged.


Use the following data as an example:

LIBRARY          LIBRARY DEPENDENCIES
=======          ====================
des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee
dw01             ieee dw01 dware gtech
dw02             ieee dw02 dware
dw03             std synopsys dware dw03 dw02 dw01 ieee gtech
dw04             dw04 ieee dw01 dware gtech
dw05             dw05 ieee dware
dw06             dw06 ieee dware
dw07             ieee dware
dware            ieee dware
gtech            ieee gtech
ramlib           std ieee
std_cell_lib     ieee std_cell_lib
synopsys


Note: the above data would be un-orderable if, for example, dw04 is added to the list of dependencies of dw01.



C.f.

   Topological sort/Extracted top item.


There are two popular algorithms for topological sorting:

   Kahn's 1962 topological sort [1] 
   depth-first search [2] [3]

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
var data = `
LIBRARY          LIBRARY DEPENDENCIES
=======          ====================
des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee
dw01             ieee dw01 dware gtech
dw02             ieee dw02 dware
dw03             std synopsys dware dw03 dw02 dw01 ieee gtech
dw04             dw04 ieee dw01 dware gtech
dw05             dw05 ieee dware
dw06             dw06 ieee dware
dw07             ieee dware
dware            ieee dware
gtech            ieee gtech
ramlib           std ieee
std_cell_lib     ieee std_cell_lib
synopsys         `
 
func main() {
    g, in, err := parseLibComp(data)
    if err != nil {
        fmt.Println(err)
        return
    }
    order, cyclic := topSortKahn(g, in)
    if cyclic != nil {
        fmt.Println(""Cyclic:"", cyclic)
        return
    }
    fmt.Println(""Order:"", order)
}
 
type graph map[string][]string
type inDegree map[string]int
 
// parseLibComp parses the text format of the task and returns a graph
// representation and a list of the in-degrees of each node.  The returned graph
// represents compile order rather than dependency order.  That is, for each map
// map key n, the map elements are libraries that depend on n being compiled
// first.
func parseLibComp(data string) (g graph, in inDegree, err error) {
    // small sanity check on input
    lines := strings.Split(data, ""\n"")
    if len(lines) < 3 || !strings.HasPrefix(lines[2], ""="") {
        return nil, nil, fmt.Errorf(""data format"")
    }
    // toss header lines
    lines = lines[3:]
    // scan and interpret input, build graph
    g = graph{}
    in = inDegree{}
    for _, line := range lines {
        libs := strings.Fields(line)
        if len(libs) == 0 {
            continue // allow blank lines
        }
        lib := libs[0]
        g[lib] = g[lib]
        for _, dep := range libs[1:] {
            in[dep] = in[dep]
            if dep == lib {
                continue // ignore self dependencies
            }
            successors := g[dep]
            for i := 0; ; i++ {
                if i == len(successors) {
                    g[dep] = append(successors, lib)
                    in[lib]++
                    break
                }
                if dep == successors[i] {
                    break // ignore duplicate dependencies
                }
            }
        }
    }
    return g, in, nil
}
 
// General purpose topological sort, not specific to the application of
// library dependencies.  Adapted from Wikipedia pseudo code, one main
// difference here is that this function does not consume the input graph.
// WP refers to incoming edges, but does not really need them fully represented.
// A count of incoming edges, or the in-degree of each node is enough.  Also,
// WP stops at cycle detection and doesn't output information about the cycle.
// A little extra code at the end of this function recovers the cyclic nodes.
func topSortKahn(g graph, in inDegree) (order, cyclic []string) {
    var L, S []string
    // rem for ""remaining edges,"" this function makes a local copy of the
    // in-degrees and consumes that instead of consuming an input.
    rem := inDegree{}
    for n, d := range in {
        if d == 0 {
            // accumulate ""set of all nodes with no incoming edges""
            S = append(S, n)
        } else {
            // initialize rem from in-degree
            rem[n] = d
        }
    }
    for len(S) > 0 {
        last := len(S) - 1 // ""remove a node n from S""
        n := S[last]
        S = S[:last]
        L = append(L, n) // ""add n to tail of L""
        for _, m := range g[n] {
            // WP pseudo code reads ""for each node m..."" but it means for each
            // node m *remaining in the graph.*  We consume rem rather than
            // the graph, so ""remaining in the graph"" for us means rem[m] > 0.
            if rem[m] > 0 {
                rem[m]--         // ""remove edge from the graph""
                if rem[m] == 0 { // if ""m has no other incoming edges""
                    S = append(S, m) // ""insert m into S""
                }
            }
        }
    }
    // ""If graph has edges,"" for us means a value in rem is > 0.
    for c, in := range rem {
        if in > 0 {
            // recover cyclic nodes
            for _, nb := range g[c] {
                if rem[nb] > 0 {
                    cyclic = append(cyclic, c)
                    break
                }
            }
        }
    }
    if len(cyclic) > 0 {
        return nil, cyclic
    }
    return L, nil
}",4600,140
6942,http://rosettacode.org/wiki/Trigonometric_functions,Trigonometric functions,"Task

If your language has a library or built-in functions for trigonometry, show examples of:

   sine
   cosine
   tangent
   inverses   (of the above)

using the same angle in radians and degrees.

For the non-inverse functions,   each radian/degree pair should use arguments that evaluate to the same angle   (that is, it's not necessary to use the same angle for all three regular functions as long as the two sine calls use the same angle).

For the inverse functions,   use the same number and convert its answer to radians and degrees.

If your language does not have trigonometric functions available or only has some available,   write functions to calculate the functions based on any   known approximation or identity.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
const d = 30.
const r = d * math.Pi / 180
 
var s = .5
var c = math.Sqrt(3) / 2
var t = 1 / math.Sqrt(3)
 
func main() {
    fmt.Printf(""sin(%9.6f deg) = %f\n"", d, math.Sin(d*math.Pi/180))
    fmt.Printf(""sin(%9.6f rad) = %f\n"", r, math.Sin(r))
    fmt.Printf(""cos(%9.6f deg) = %f\n"", d, math.Cos(d*math.Pi/180))
    fmt.Printf(""cos(%9.6f rad) = %f\n"", r, math.Cos(r))
    fmt.Printf(""tan(%9.6f deg) = %f\n"", d, math.Tan(d*math.Pi/180))
    fmt.Printf(""tan(%9.6f rad) = %f\n"", r, math.Tan(r))
    fmt.Printf(""asin(%f) = %9.6f deg\n"", s, math.Asin(s)*180/math.Pi)
    fmt.Printf(""asin(%f) = %9.6f rad\n"", s, math.Asin(s))
    fmt.Printf(""acos(%f) = %9.6f deg\n"", c, math.Acos(c)*180/math.Pi)
    fmt.Printf(""acos(%f) = %9.6f rad\n"", c, math.Acos(c))
    fmt.Printf(""atan(%f) = %9.6f deg\n"", t, math.Atan(t)*180/math.Pi)
    fmt.Printf(""atan(%f) = %9.6f rad\n"", t, math.Atan(t))
}",927,28
7102,http://rosettacode.org/wiki/Time_a_function,Time a function,"Task

Write a program which uses a timer (with the least granularity available
on your system) to time how long a function takes to execute.

Whenever possible, use methods which measure only the processing time used
by the current process; instead of the difference in system time
between start and finish, which could include time used by
other processes on the computer.

This task is intended as a subtask for Measure relative performance of sorting algorithms implementations.



",#Go,Go,"package empty
 
func Empty() {}
 
func Count() {
    // count to a million
    for i := 0; i < 1e6; i++ {
    }
}",113,9
7140,http://rosettacode.org/wiki/Top_rank_per_group,Top rank per group,"Task

Find the top   N   salaries in each department,   where   N   is provided as a parameter.

Use this data as a formatted internal data structure (adapt it to your language-native idioms, rather than parse at runtime), or identify your external data source:

Employee Name,Employee ID,Salary,Department
Tyler Bennett,E10297,32000,D101
John Rappl,E21437,47000,D050
George Woltman,E00127,53500,D101
Adam Smith,E63535,18000,D202
Claire Buckman,E39876,27800,D202
David McClellan,E04242,41500,D101
Rich Holcomb,E01234,49500,D202
Nathan Adams,E41298,21900,D050
Richard Potter,E43128,15900,D101
David Motsinger,E27002,19250,D202
Tim Sampair,E03033,27000,D101
Kim Arlich,E10001,57000,D190
Timothy Grove,E16398,29900,D190


",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
// language-native data description
type Employee struct {
    Name, ID string
    Salary   int
    Dept     string
}
 
type EmployeeList []*Employee
 
var data = EmployeeList{
    {""Tyler Bennett"", ""E10297"", 32000, ""D101""},
    {""John Rappl"", ""E21437"", 47000, ""D050""},
    {""George Woltman"", ""E00127"", 53500, ""D101""},
    {""Adam Smith"", ""E63535"", 18000, ""D202""},
    {""Claire Buckman"", ""E39876"", 27800, ""D202""},
    {""David McClellan"", ""E04242"", 41500, ""D101""},
    {""Rich Holcomb"", ""E01234"", 49500, ""D202""},
    {""Nathan Adams"", ""E41298"", 21900, ""D050""},
    {""Richard Potter"", ""E43128"", 15900, ""D101""},
    {""David Motsinger"", ""E27002"", 19250, ""D202""},
    {""Tim Sampair"", ""E03033"", 27000, ""D101""},
    {""Kim Arlich"", ""E10001"", 57000, ""D190""},
    {""Timothy Grove"", ""E16398"", 29900, ""D190""},
    // Extra data to demonstrate ties
    {""Tie A"", ""E16399"", 29900, ""D190""},
    {""Tie B"", ""E16400"", 29900, ""D190""},
    {""No Tie"", ""E16401"", 29899, ""D190""},
}
 
// We only need one type of ordering/grouping for this task so we could directly
// implement sort.Interface on EmployeeList (or a byDeptSalary alias type) with
// the appropriate Less method.
//
// Instead, we'll add a bit here that makes it easier to use arbitrary orderings.
// This is like the ""SortKeys"" Planet sorting example in the sort package
// documentation, see https://golang.org/pkg/sort
 
type By func(e1, e2 *Employee) bool
type employeeSorter struct {
    list EmployeeList
    by   func(e1, e2 *Employee) bool
}
 
func (by By) Sort(list EmployeeList)         { sort.Sort(&employeeSorter{list, by}) }
func (s *employeeSorter) Len() int           { return len(s.list) }
func (s *employeeSorter) Swap(i, j int)      { s.list[i], s.list[j] = s.list[j], s.list[i] }
func (s *employeeSorter) Less(i, j int) bool { return s.by(s.list[i], s.list[j]) }
 
// For this specific task we could just write the data to an io.Writer
// but in general it's better to return the data in a usable form (for
// example, perhaps other code want's to do something like compare the
// averages of the top N by department).
//
// So we go through the extra effort of returning an []EmployeeList, a
// list of employee lists, one per deparment. The lists are trimmed to
// to the top 'n', which can be larger than n if there are ties for the
// nth salary (callers that don't care about ties could just trim more.)
func (el EmployeeList) TopSalariesByDept(n int) []EmployeeList {
    if n <= 0 || len(el) == 0 {
        return nil
    }
    deptSalary := func(e1, e2 *Employee) bool {
        if e1.Dept != e2.Dept {
            return e1.Dept < e2.Dept
        }
        if e1.Salary != e2.Salary {
            return e1.Salary > e2.Salary
        }
        // Always have some unique field as the last one in a sort list
        return e1.ID < e2.ID
    }
 
    // We could just sort the data in place for this task. But
    // perhaps messing with the order is undesirable or there is
    // other concurrent access. So we'll make a copy and sort that.
    // It's just pointers so the amount to copy is relatively small.
    sorted := make(EmployeeList, len(el))
    copy(sorted, el)
    By(deptSalary).Sort(sorted)
 
    perDept := []EmployeeList{}
    var lastDept string
    var lastSalary int
    for _, e := range sorted {
        if e.Dept != lastDept || len(perDept) == 0 {
            lastDept = e.Dept
            perDept = append(perDept, EmployeeList{e})
        } else {
            i := len(perDept) - 1
            if len(perDept[i]) >= n && e.Salary != lastSalary {
                continue
            }
            perDept[i] = append(perDept[i], e)
            lastSalary = e.Salary
        }
    }
    return perDept
}
 
func main() {
    const n = 3
    top := data.TopSalariesByDept(n)
    if len(top) == 0 {
        fmt.Println(""Nothing to show."")
        return
    }
    fmt.Printf(""Top %d salaries per department\n"", n)
    for _, list := range top {
        fmt.Println(list[0].Dept)
        for _, e := range list {
            fmt.Printf(""    %s %16s %7d\n"", e.ID, e.Name, e.Salary)
        }
    }
}",4132,121
7213,http://rosettacode.org/wiki/Tic-tac-toe,Tic-tac-toe,"
Task

Play a game of tic-tac-toe.

Ensure that legal moves are played and that a winning position is notified.


Tic-tac-toe   is also known as:

   naughts and crosses 
   tic tac toe 
   tick tack toe 
   three in a row 
   tres en rayo       and
   Xs  and  Os


See also
   MathWorld™, Tic-Tac-Toe game.
   Wikipedia tic-tac-toe.

",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""math/rand""
    ""os""
    ""strings""
)
 
var b []byte
 
func printBoard() {
    fmt.Printf(""%s\n%s\n%s\n"", b[0:3], b[3:6], b[6:9])
}
 
var pScore, cScore int
var pMark, cMark byte = 'X', 'O'
var in = bufio.NewReader(os.Stdin)
 
func main() {
    b = make([]byte, 9)
    fmt.Println(""Play by entering a digit."")
    for {
        // start of game
        for i := range b {
            b[i] = '1' + byte(i)
        }
        computerStart := cMark == 'X'
        if computerStart {
            fmt.Println(""I go first, playing X's"")
        } else {
            fmt.Println(""You go first, playing X's"")
        }
    TakeTurns:
        for {
            if !computerStart {
                if !playerTurn() {
                    return
                }
                if gameOver() {
                    break TakeTurns
                }
 
            }
            computerStart = false
            computerTurn()
            if gameOver() {
                break TakeTurns
            }
        }
        fmt.Println(""Score: you"", pScore, ""me"", cScore)
        fmt.Println(""\nLet's play again."")
    }
}
 
func playerTurn() bool {
    var pm string
    var err error
    for i := 0; i < 3; i++ { // retry loop
        printBoard()
        fmt.Printf(""%c's move? "", pMark)
        if pm, err = in.ReadString('\n'); err != nil {
            fmt.Println(err)
            return false
        }
        pm = strings.TrimSpace(pm)
        if pm >= ""1"" && pm <= ""9"" && b[pm[0]-'1'] == pm[0] {
            x := pm[0] - '1'
            b[x] = pMark
            return true
        }
    }
    fmt.Println(""You're not playing right."")
    return false
}
 
var choices = make([]int, 9)
 
func computerTurn() {
    printBoard()
    var x int
    defer func() {
        fmt.Println(""My move:"", x+1)
        b[x] = cMark
    }()
    // look for two in a row
    block := -1
    for _, l := range lines {
        var mine, yours int
        x = -1
        for _, sq := range l {
            switch b[sq] {
            case cMark:
                mine++
            case pMark:
                yours++
            default:
                x = sq
            }
        }
        if mine == 2 && x >= 0 {
            return // strategy 1: make winning move
        }
        if yours == 2 && x >= 0 {
            block = x
        } 
    }
    if block >= 0 {
        x = block // strategy 2: make blocking move
        return
    }
    // default strategy: random move
    choices = choices[:0]
    for i, sq := range b { 
        if sq == '1'+byte(i) {
            choices = append(choices, i)
        }
    }
    x = choices[rand.Intn(len(choices))]
}   
 
func gameOver() bool {
    // check for win
    for _, l := range lines {
        if b[l[0]] == b[l[1]] && b[l[1]] == b[l[2]] {
            printBoard()
            if b[l[0]] == cMark {
                fmt.Println(""I win!"")
                cScore++
                pMark, cMark = 'X', 'O'
            } else {
                fmt.Println(""You win!"")
                pScore++
                pMark, cMark = 'O', 'X'
            }
            return true 
        } 
    }
    // check for empty squares
    for i, sq := range b {
        if sq == '1'+byte(i) {
            return false
        }
    }
    fmt.Println(""Cat game."")
    pMark, cMark = cMark, pMark
    return true
}
 
var lines = [][]int{
    {0, 1, 2}, // rows
    {3, 4, 5},
    {6, 7, 8},
    {0, 3, 6}, // columns
    {1, 4, 7},
    {2, 5, 8},
    {0, 4, 8}, // diagonals
    {2, 4, 6},
}",3551,160
7224,http://rosettacode.org/wiki/Tree_traversal,Tree traversal,"Task

Implement a binary tree where each node carries an integer,   and implement:

   pre-order,
   in-order, 
   post-order,     and 
   level-order   traversal. 


Use those traversals to output the following tree:

         1
        / \
       /   \
      /     \
     2       3
    / \     /
   4   5   6
  /       / \
 7       8   9

The correct output should look like this:

preorder:    1 2 4 7 5 3 6 8 9
inorder:     7 4 2 5 1 8 6 9 3
postorder:   7 4 5 2 8 9 6 3 1
level-order: 1 2 3 4 5 6 7 8 9



See also

   Wikipedia article:   Tree traversal.

",#Go,Go,"package main
 
import ""fmt""
 
type node struct {
    value       int
    left, right *node
}
 
func (n *node) iterPreorder(visit func(int)) {
    if n == nil {
        return
    }
    visit(n.value)
    n.left.iterPreorder(visit)
    n.right.iterPreorder(visit)
}
 
func (n *node) iterInorder(visit func(int)) {
    if n == nil {
        return
    }
    n.left.iterInorder(visit)
    visit(n.value)
    n.right.iterInorder(visit)
}
 
func (n *node) iterPostorder(visit func(int)) {
    if n == nil {
        return
    }
    n.left.iterPostorder(visit)
    n.right.iterPostorder(visit)
    visit(n.value)
}
 
func (n *node) iterLevelorder(visit func(int)) {
    if n == nil {
        return
    }
    for queue := []*node{n}; ; {
        n = queue[0]
        visit(n.value)
        copy(queue, queue[1:])
        queue = queue[:len(queue)-1]
        if n.left != nil {
            queue = append(queue, n.left)
        }
        if n.right != nil {
            queue = append(queue, n.right)
        }
        if len(queue) == 0 {
            return
        }
    }
}
 
func main() {
    tree := &node{1,
        &node{2,
            &node{4,
                &node{7, nil, nil},
                nil},
            &node{5, nil, nil}},
        &node{3,
            &node{6,
                &node{8, nil, nil},
                &node{9, nil, nil}},
            nil}}
    fmt.Print(""preorder:    "")
    tree.iterPreorder(visitor)
    fmt.Println()
    fmt.Print(""inorder:     "") 
    tree.iterInorder(visitor)
    fmt.Println()
    fmt.Print(""postorder:   "")
    tree.iterPostorder(visitor)
    fmt.Println() 
    fmt.Print(""level-order: "")
    tree.iterLevelorder(visitor)
    fmt.Println()
}
 
func visitor(value int) {
    fmt.Print(value, "" "")
}",1746,86
7225,http://rosettacode.org/wiki/Tokenize_a_string,Tokenize a string,"Separate the string ""Hello,How,Are,You,Today"" by commas into an array (or list) so that each element of it stores a different word.

Display the words to the 'user', in the simplest manner possible, separated by a period.

To simplify, you may display a trailing period.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func main() {
    s := ""Hello,How,Are,You,Today""
    fmt.Println(strings.Join(strings.Split(s, "",""), "".""))
}",160,11
7489,http://rosettacode.org/wiki/Towers_of_Hanoi,Towers of Hanoi,"Task

Solve the   Towers of Hanoi   problem with recursion.



",#Go,Go,"package main
 
import ""fmt""
 
// a towers of hanoi solver just has one method, play
type solver interface {
    play(int)
}
 
func main() {
    var t solver    // declare variable of solver type
    t = new(towers) // type towers must satisfy solver interface
    t.play(4)
}
 
// towers is example of type satisfying solver interface
type towers struct {
    // an empty struct.  some other solver might fill this with some
    // data representation, maybe for algorithm validation, or maybe for
    // visualization.
}
 
// play is sole method required to implement solver type
func (t *towers) play(n int) {
    // drive recursive solution, per task description
    t.moveN(n, 1, 2, 3)
}
 
// recursive algorithm
func (t *towers) moveN(n, from, to, via int) {
    if n > 0 {
        t.moveN(n-1, from, via, to)
        t.move1(from, to)
        t.moveN(n-1, via, to, from)
    }
}
 
// example function prints actions to screen.
// enhance with validation or visualization as needed.
func (t *towers) move1(from, to int) {
    fmt.Println(""move disk from rod"", from, ""to rod"", to)
}",1086,42
7792,http://rosettacode.org/wiki/The_sieve_of_Sundaram,The sieve of Sundaram,"The sieve of Eratosthenes: you've been there; done that; have the T-shirt. The sieve of Eratosthenes was ancient history when Euclid was a schoolboy. You are ready for something less than 3000 years old. You are ready for The sieve of Sundaram.

Starting with the ordered set of +ve integers, mark every third starting at 4 (4;7;10...).

Step through the set and if the value is not marked output 2*n+1. So from 1 to 4 output 3 5 7.

4 is marked so skip for 5 and 6 output 11 and 13.

7 is marked, so no output but now also mark every fifth starting at 12 (12;17;22...)

as per to 10 and now mark every seventh starting at 17 (17;24;31....)

as per for every further third element (13;16;19...) mark every (9th;11th;13th;...) element.

The output will be the ordered set of odd primes.

Using your function find and output the first 100 and the millionth Sundaram prime.

The faithless amongst you may compare the results with those generated by The sieve of Eratosthenes.

References

 The article on Wikipedia.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""rcu""
    ""time""
)
 
func sos(n int) []int {
    if n < 3 {
        return []int{}
    }
    var primes []int
    k := (n-3)/2 + 1
    marked := make([]bool, k) // all false by default
    limit := (int(math.Sqrt(float64(n)))-3)/2 + 1
    for i := 0; i < limit; i++ {
        p := 2*i + 3
        s := (p*p - 3) / 2
        for j := s; j < k; j += p {
            marked[j] = true
        }
    }
    for i := 0; i < k; i++ {
        if !marked[i] {
            primes = append(primes, 2*i+3)
        }
    }
    return primes
}
 
// odds only
func soe(n int) []int {
    if n < 3 {
        return []int{}
    }
    var primes []int
    k := (n-3)/2 + 1
    marked := make([]bool, k) // all false by default
    limit := (int(math.Sqrt(float64(n)))-3)/2 + 1
    for i := 0; i < limit; i++ {
        if !marked[i] {
            p := 2*i + 3
            s := (p*p - 3) / 2
            for j := s; j < k; j += p {
                marked[j] = true
            }
        }
    }
    for i := 0; i < k; i++ {
        if !marked[i] {
            primes = append(primes, 2*i+3)
        }
    }
    return primes
}
 
func main() {
    const limit = int(16e6) // say
    start := time.Now()
    primes := sos(limit)
    elapsed := int(time.Since(start).Milliseconds())
    climit := rcu.Commatize(limit)
    celapsed := rcu.Commatize(elapsed)
    million := rcu.Commatize(1e6)
    millionth := rcu.Commatize(primes[1e6-1])
    fmt.Printf(""Using the Sieve of Sundaram generated primes up to %s in %s ms.\n\n"", climit, celapsed)
    fmt.Println(""First 100 odd primes generated by the Sieve of Sundaram:"")
    for i, p := range primes[0:100] {
        fmt.Printf(""%3d "", p)
        if (i+1)%10 == 0 {
            fmt.Println()
        }
    }
    fmt.Printf(""\nThe %s Sundaram prime is %s\n"", million, millionth)
 
    start = time.Now()
    primes = soe(limit)
    elapsed = int(time.Since(start).Milliseconds())
    celapsed = rcu.Commatize(elapsed)
    millionth = rcu.Commatize(primes[1e6-1])
    fmt.Printf(""\nUsing the Sieve of Eratosthenes would have generated them in %s ms.\n"", celapsed)
    fmt.Printf(""\nAs a check, the %s Sundaram prime would again have been %s\n"", million, millionth)
}",2235,85
7814,http://rosettacode.org/wiki/Thiele%27s_interpolation_formula,Thiele's interpolation formula,"

 This page uses content from Wikipedia. The original article was at Thiele's interpolation formula. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Thiele's interpolation formula is an interpolation formula for a function f(•) of a single variable.   It is expressed as a continued fraction:

 



f
(
x
)
=
f
(

x

1


)
+








x
−

x

1












ρ

1


(

x

1


,

x

2


)
+








x
−

x

2












ρ

2


(

x

1


,

x

2


,

x

3


)
−
f
(

x

1


)
+








x
−

x

3












ρ

3


(

x

1


,

x

2


,

x

3


,

x

4


)
−

ρ

1


(

x

1


,

x

2


)
+
⋯

















{\displaystyle f(x)=f(x_{1})+{\cfrac {x-x_{1}}{\rho _{1}(x_{1},x_{2})+{\cfrac {x-x_{2}}{\rho _{2}(x_{1},x_{2},x_{3})-f(x_{1})+{\cfrac {x-x_{3}}{\rho _{3}(x_{1},x_{2},x_{3},x_{4})-\rho _{1}(x_{1},x_{2})+\cdots }}}}}}}






ρ


{\displaystyle \rho }

   represents the   reciprocal difference,   demonstrated here for reference:

 




ρ

1


(

x

0


,

x

1


)
=




x

0


−

x

1




f
(

x

0


)
−
f
(

x

1


)





{\displaystyle \rho _{1}(x_{0},x_{1})={\frac {x_{0}-x_{1}}{f(x_{0})-f(x_{1})}}}


 




ρ

2


(

x

0


,

x

1


,

x

2


)
=




x

0


−

x

2





ρ

1


(

x

0


,

x

1


)
−

ρ

1


(

x

1


,

x

2


)



+
f
(

x

1


)


{\displaystyle \rho _{2}(x_{0},x_{1},x_{2})={\frac {x_{0}-x_{2}}{\rho _{1}(x_{0},x_{1})-\rho _{1}(x_{1},x_{2})}}+f(x_{1})}


 




ρ

n


(

x

0


,

x

1


,
…
,

x

n


)
=




x

0


−

x

n





ρ

n
−
1


(

x

0


,

x

1


,
…
,

x

n
−
1


)
−

ρ

n
−
1


(

x

1


,

x

2


,
…
,

x

n


)



+

ρ

n
−
2


(

x

1


,
…
,

x

n
−
1


)


{\displaystyle \rho _{n}(x_{0},x_{1},\ldots ,x_{n})={\frac {x_{0}-x_{n}}{\rho _{n-1}(x_{0},x_{1},\ldots ,x_{n-1})-\rho _{n-1}(x_{1},x_{2},\ldots ,x_{n})}}+\rho _{n-2}(x_{1},\ldots ,x_{n-1})}


Demonstrate Thiele's interpolation function by:

 Building a   32   row trig table of values   for   



x


{\displaystyle x}

   from   0   by   0.05   to   1.55   of the trig functions:
   sin
   cos
   tan
 Using columns from this table define an inverse - using Thiele's interpolation - for each trig function;
 Finally: demonstrate the following well known trigonometric identities:
    6 × sin-1 ½ = 



π


{\displaystyle \pi }


    3 × cos-1 ½ = 



π


{\displaystyle \pi }


    4 × tan-1 1 = 



π


{\displaystyle \pi }

 

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func main() {
    // task 1: build 32 row trig table
    const nn = 32
    const step = .05
    xVal := make([]float64, nn)
    tSin := make([]float64, nn)
    tCos := make([]float64, nn)
    tTan := make([]float64, nn)
    for i := range xVal {
        xVal[i] = float64(i) * step
        tSin[i], tCos[i] = math.Sincos(xVal[i])
        tTan[i] = tSin[i] / tCos[i]
    }
    // task 2: define inverses
    iSin := thieleInterpolator(tSin, xVal)
    iCos := thieleInterpolator(tCos, xVal)
    iTan := thieleInterpolator(tTan, xVal)
    // task 3: demonstrate identities
    fmt.Printf(""%16.14f\n"", 6*iSin(.5))
    fmt.Printf(""%16.14f\n"", 3*iCos(.5))
    fmt.Printf(""%16.14f\n"", 4*iTan(1))
}
 
func thieleInterpolator(x, y []float64) func(float64) float64 {
    n := len(x)
    ρ := make([][]float64, n)
    for i := range ρ {
        ρ[i] = make([]float64, n-i)
        ρ[i][0] = y[i]
    }
    for i := 0; i < n-1; i++ {
        ρ[i][1] = (x[i] - x[i+1]) / (ρ[i][0] - ρ[i+1][0])
    }
    for i := 2; i < n; i++ {
        for j := 0; j < n-i; j++ {
            ρ[j][i] = (x[j]-x[j+i])/(ρ[j][i-1]-ρ[j+1][i-1]) + ρ[j+1][i-2]
        }
    }
    // ρ0 used in closure.  the rest of ρ becomes garbage.
    ρ0 := ρ[0]
    return func(xin float64) float64 {
        var a float64
        for i := n - 1; i > 1; i-- {
            a = (xin - x[i-1]) / (ρ0[i] - ρ0[i-2] + a)
        }
        return y[0] + (xin-x[0])/(ρ0[1]+a)
    }
}",1476,55
7874,http://rosettacode.org/wiki/Textonyms,Textonyms,"When entering text on a phone's digital pad it is possible that a particular combination of digits corresponds to more than one word. Such are called textonyms.

Assuming the digit keys are mapped to letters as follows:

    2 -> ABC
    3 -> DEF
    4 -> GHI
    5 -> JKL
    6 -> MNO
    7 -> PQRS
    8 -> TUV
    9 -> WXYZ  



Task

Write a program that finds textonyms in a list of words such as  
Textonyms/wordlist   or  
unixdict.txt.

The task should produce a report:

There are #{0} words in #{1} which can be represented by the digit key mapping.
They require #{2} digit combinations to represent them.
#{3} digit combinations represent Textonyms.

Where:

#{0} is the number of words in the list which can be represented by the digit key mapping.
#{1} is the URL of the wordlist being used.
#{2} is the number of digit combinations required to represent the words in #{0}.
#{3} is the number of #{2} which represent more than one word.

At your discretion show a couple of examples of your solution displaying Textonyms.

E.G.:

 2748424767 -> ""Briticisms"", ""criticisms""



Extra credit

Use a word list and keypad mapping other than English.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
	""bufio""
	""flag""
	""fmt""
	""io""
	""log""
	""os""
	""strings""
	""unicode""
)
 
func main() {
	log.SetFlags(0)
	log.SetPrefix(""textonyms: "")
 
	wordlist := flag.String(""wordlist"", ""wordlist"", ""file containing the list of words to check"")
	flag.Parse()
	if flag.NArg() != 0 {
		flag.Usage()
		os.Exit(2)
	}
 
	t := NewTextonym(phoneMap)
	_, err := ReadFromFile(t, *wordlist)
	if err != nil {
		log.Fatal(err)
	}
	t.Report(os.Stdout, *wordlist)
}
 
// phoneMap is the digit to letter mapping of a typical phone.
var phoneMap = map[byte][]rune{
	'2': []rune(""ABC""),
	'3': []rune(""DEF""),
	'4': []rune(""GHI""),
	'5': []rune(""JKL""),
	'6': []rune(""MNO""),
	'7': []rune(""PQRS""),
	'8': []rune(""TUV""),
	'9': []rune(""WXYZ""),
}
 
// ReadFromFile is a generic convience function that allows the use of a
// filename with an io.ReaderFrom and handles errors related to open and
// closing the file.
func ReadFromFile(r io.ReaderFrom, filename string) (int64, error) {
	f, err := os.Open(filename)
	if err != nil {
		return 0, err
	}
	n, err := r.ReadFrom(f)
	if cerr := f.Close(); err == nil && cerr != nil {
		err = cerr
	}
	return n, err
}
 
type Textonym struct {
	numberMap map[string][]string // map numeric string into words
	letterMap map[rune]byte       // map letter to digit
	count     int                 // total number of words in numberMap
	textonyms int                 // number of numeric strings with >1 words
}
 
func NewTextonym(dm map[byte][]rune) *Textonym {
	lm := make(map[rune]byte, 26)
	for d, ll := range dm {
		for _, l := range ll {
			lm[l] = d
		}
	}
	return &Textonym{letterMap: lm}
}
 
func (t *Textonym) ReadFrom(r io.Reader) (n int64, err error) {
	t.numberMap = make(map[string][]string)
	buf := make([]byte, 0, 32)
	sc := bufio.NewScanner(r)
	sc.Split(bufio.ScanWords)
scan:
	for sc.Scan() {
		buf = buf[:0]
		word := sc.Text()
 
		// XXX we only bother approximating the number of bytes
		// consumed. This isn't used in the calling code and was
		// only included to match the io.ReaderFrom interface.
		n += int64(len(word)) + 1
 
		for _, r := range word {
			d, ok := t.letterMap[unicode.ToUpper(r)]
			if !ok {
				//log.Printf(""ignoring %q\n"", word)
				continue scan
			}
			buf = append(buf, d)
		}
		//log.Printf(""scanned %q\n"", word)
		num := string(buf)
		t.numberMap[num] = append(t.numberMap[num], word)
		t.count++
		if len(t.numberMap[num]) == 2 {
			t.textonyms++
		}
		//log.Printf(""%q → %v\t→ %v\n"", word, num, t.numberMap[num])
	}
	return n, sc.Err()
}
 
func (t *Textonym) Most() (most int, subset map[string][]string) {
	for k, v := range t.numberMap {
		switch {
		case len(v) > most:
			subset = make(map[string][]string)
			most = len(v)
			fallthrough
		case len(v) == most:
			subset[k] = v
		}
	}
	return most, subset
}
 
func (t *Textonym) Report(w io.Writer, name string) {
	// Could be fancy and use text/template package but fmt is sufficient
	fmt.Fprintf(w, `
There are %v words in %q which can be represented by the digit key mapping.
They require %v digit combinations to represent them.
%v digit combinations represent Textonyms.
`,
		t.count, name, len(t.numberMap), t.textonyms)
 
	n, sub := t.Most()
	fmt.Fprintln(w, ""\nThe numbers mapping to the most words map to"",
		n, ""words each:"")
	for k, v := range sub {
		fmt.Fprintln(w, ""\t"", k, ""maps to:"", strings.Join(v, "", ""))
	}
}",3351,141
7882,http://rosettacode.org/wiki/The_Name_Game,The Name Game,"Write a program that accepts a name as input and outputs the lyrics to the Shirley Ellis song ""The Name Game"".



The regular verse

Unless your name begins with a vowel (A, E, I, O, U), 'B', 'F' or 'M' you don't have to care about special rules.
The verse for the name 'Gary' would be like this:

   Gary, Gary, bo-bary
   Banana-fana fo-fary
   Fee-fi-mo-mary
   Gary! 

At the end of every line, the name gets repeated without the first letter: Gary becomes ary
If we take (X) as the full name (Gary) and (Y) as the name without the first letter (ary) the verse would look like this:

   (X), (X), bo-b(Y)
   Banana-fana fo-f(Y)
   Fee-fi-mo-m(Y)
   (X)! 

Vowel as first letter of the name

If you have a vowel as the first letter of your name (e.g. Earl) you do not truncate the name.
The verse looks like this:

   Earl, Earl, bo-bearl
   Banana-fana fo-fearl
   Fee-fi-mo-mearl
   Earl! 

'B', 'F' or 'M' as first letter of the name

In case of a 'B', an 'F' or an 'M' (e.g. Billy, Felix, Mary) there is a special rule.
The line which would 'rebuild' the name (e.g. bo-billy) is sang without the first letter of the name.
The verse for the name Billy looks like this:

   Billy, Billy, bo-illy
   Banana-fana fo-filly
   Fee-fi-mo-milly
   Billy! 

For the name 'Felix', this would be right:

   Felix, Felix, bo-belix
   Banana-fana fo-elix
   Fee-fi-mo-melix
   Felix!


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func printVerse(name string) {
    x := strings.Title(strings.ToLower(name))
    y := x[1:]
    if strings.Contains(""AEIOU"", x[:1]) {
        y = strings.ToLower(x)
    }
    b := ""b"" + y
    f := ""f"" + y
    m := ""m"" + y
    switch x[0] {
    case 'B':
        b = y
    case 'F':
        f = y
    case 'M':
        m = y
    }
    fmt.Printf(""%s, %s, bo-%s\n"", x, x, b)
    fmt.Printf(""Banana-fana fo-%s\n"", f)
    fmt.Printf(""Fee-fi-mo-%s\n"", m)
    fmt.Printf(""%s!\n\n"", x)
}
 
func main() {
    names := [6]string{""gARY"", ""Earl"", ""Billy"", ""Felix"", ""Mary"", ""SHIRley""}
    for _, name := range names {
        printVerse(name)
    }
}",690,36
7904,http://rosettacode.org/wiki/Text_processing/2,Text processing/2,"The following task concerns data that came from a pollution monitoring station with twenty-four instruments monitoring twenty-four aspects of pollution in the air. Periodically a record is added to the file, each record being a line of 49 fields separated by white-space, which can be one or more space or tab characters.

The fields (from the left) are:

 DATESTAMP [ VALUEn FLAGn ] * 24

i.e. a datestamp followed by twenty-four repetitions of a floating-point instrument value and that instrument's associated integer flag. Flag values are >= 1 if the instrument is working and < 1 if there is some problem with it, in which case that instrument's value should be ignored.

A sample from the full data file readings.txt, which is also used in the Text processing/1 task, follows:

Data is no longer available at that link. Zipped mirror available here

1991-03-30	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1
1991-03-31	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	20.000	1	20.000	1	20.000	1	35.000	1	50.000	1	60.000	1	40.000	1	30.000	1	30.000	1	30.000	1	25.000	1	20.000	1	20.000	1	20.000	1	20.000	1	20.000	1	35.000	1
1991-03-31	40.000	1	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2
1991-04-01	0.000	-2	13.000	1	16.000	1	21.000	1	24.000	1	22.000	1	20.000	1	18.000	1	29.000	1	44.000	1	50.000	1	43.000	1	38.000	1	27.000	1	27.000	1	24.000	1	23.000	1	18.000	1	12.000	1	13.000	1	14.000	1	15.000	1	13.000	1	10.000	1
1991-04-02	8.000	1	9.000	1	11.000	1	12.000	1	12.000	1	12.000	1	27.000	1	26.000	1	27.000	1	33.000	1	32.000	1	31.000	1	29.000	1	31.000	1	25.000	1	25.000	1	24.000	1	21.000	1	17.000	1	14.000	1	15.000	1	12.000	1	12.000	1	10.000	1
1991-04-03	10.000	1	9.000	1	10.000	1	10.000	1	9.000	1	10.000	1	15.000	1	24.000	1	28.000	1	24.000	1	18.000	1	14.000	1	12.000	1	13.000	1	14.000	1	15.000	1	14.000	1	15.000	1	13.000	1	13.000	1	13.000	1	12.000	1	10.000	1	10.000	1

Task

 Confirm the general field format of the file.
 Identify any DATESTAMPs that are duplicated.
 Report the number of records that have good readings for all instruments.

",#Go,Go,"package main
 
import (
	""bufio""
	""fmt""
	""log""
	""os""
	""strconv""
	""strings""
	""time""
)
 
const (
	filename   = ""readings.txt""
	readings   = 24             // per line
	fields     = readings*2 + 1 // per line
	dateFormat = ""2006-01-02""
)
 
func main() {
	file, err := os.Open(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()
	var allGood, uniqueGood int
	// map records not only dates seen, but also if an all-good record was
	// seen for the key date.
	m := make(map[time.Time]bool)
	s := bufio.NewScanner(file)
	for s.Scan() {
		f := strings.Fields(s.Text())
		if len(f) != fields {
			log.Fatal(""unexpected format,"", len(f), ""fields."")
		}
		ts, err := time.Parse(dateFormat, f[0])
		if err != nil {
			log.Fatal(err)
		}
		good := true
		for i := 1; i < fields; i += 2 {
			flag, err := strconv.Atoi(f[i+1])
			if err != nil {
				log.Fatal(err)
			}
			if flag > 0 { // value is good
				_, err := strconv.ParseFloat(f[i], 64)
				if err != nil {
					log.Fatal(err)
				}
			} else { // value is bad
				good = false
			}
		}
		if good {
			allGood++
		}
		previouslyGood, seen := m[ts]
		if seen {
			fmt.Println(""Duplicate datestamp:"", f[0])
		}
		m[ts] = previouslyGood || good
		if !previouslyGood && good {
			uniqueGood++
		}
	}
	if err := s.Err(); err != nil {
		log.Fatal(err)
	}
 
	fmt.Println(""\nData format valid."")
	fmt.Println(allGood, ""records with good readings for all instruments."")
	fmt.Println(uniqueGood,
		""unique dates with good readings for all instruments."")
}",1505,75
7967,http://rosettacode.org/wiki/Terminal_control/Unicode_output,Terminal control/Unicode output,"The task is to check that the terminal supports Unicode output, before outputting a Unicode character. If the terminal supports Unicode, then the terminal should output a Unicode delta (U+25b3). If the terminal does not support Unicode, then an appropriate error should be raised.

Note that it is permissible to use system configuration data to determine terminal capabilities if the system provides such a facility.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""os""
    ""strings""
)
 
func main() {
    lang := strings.ToUpper(os.Getenv(""LANG""))
    if strings.Contains(lang, ""UTF"") {
        fmt.Printf(""This terminal supports unicode and U+25b3 is : %c\n"", '\u25b3')
    } else {
        fmt.Println(""This terminal does not support unicode"")
    }
}",327,16
7981,http://rosettacode.org/wiki/Text_processing/Max_licenses_in_use,Text processing/Max licenses in use,"A company currently pays a fixed sum for the use of a particular licensed software package.   In determining if it has a good deal it decides to calculate its maximum use of the software from its license management log file.

Assume the software's licensing daemon faithfully records a checkout event when a copy of the software starts and a checkin event when the software finishes to its log file.

An example of checkout and checkin events are:

 License OUT @ 2008/10/03_23:51:05 for job 4974
 ...
 License IN  @ 2008/10/04_00:18:22 for job 4974



Task

Save the 10,000 line log file from    here   into a local file, then write a program to scan the file extracting both the maximum licenses that were out at any time, and the time(s) at which this occurs.

Mirror of log file available as a zip here (offsite mirror).



",#Go,Go,"package main
 
import (
    ""bufio""
    ""bytes""
    ""fmt""
    ""log""
    ""os""
)
 
const (
    filename   = ""mlijobs.txt""
    inoutField = 1
    timeField  = 3
    numFields  = 7
)
 
func main() {
    file, err := os.Open(filename)
    if err != nil {
        log.Fatal(err)
    }
    defer file.Close()
    var ml, out int
    var mlTimes []string
    in := []byte(""IN"")
    s := bufio.NewScanner(file)
    for s.Scan() {
        f := bytes.Fields(s.Bytes())
        if len(f) != numFields {
            log.Fatal(""unexpected format,"", len(f), ""fields."")
        }
        if bytes.Equal(f[inoutField], in) {
            out--
            if out < 0 {
                log.Fatalf(""negative license use at %s"", f[timeField])
            }
            continue
        }
        out++
        if out < ml {
            continue
        }
 
        if out > ml {
            ml = out
            mlTimes = mlTimes[:0]
        }
        mlTimes = append(mlTimes, string(f[timeField]))
    }
    if err = s.Err(); err != nil {
        log.Fatal(err)
    }
 
    fmt.Println(""max licenses:"", ml)
    fmt.Println(""at:"")
    for _, t := range mlTimes {
        fmt.Println("" "", t)
    }
}",1178,60
8102,http://rosettacode.org/wiki/Terminal_control/Ringing_the_terminal_bell,Terminal control/Ringing the terminal bell,"

Task

Make the terminal running the program ring its ""bell"".



On modern terminal emulators, this may be done by playing some other sound which might or might not be configurable, or by flashing the title bar or inverting the colors of the screen, but was classically a physical bell within the terminal.   It is usually used to indicate a problem where a wrong character has been typed.

In most terminals, if the   Bell character   (ASCII code 7,    \a  in C)   is printed by the program, it will cause the terminal to ring its bell.   This is a function of the terminal, and is independent of the programming language of the program, other than the ability to print a particular character to standard out.



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
  fmt.Print(""\a"")
}",63,7
8125,http://rosettacode.org/wiki/Terminal_control/Preserve_screen,Terminal control/Preserve screen,"

Task

Clear the screen, output something on the display, and then restore the screen to the preserved state that it was in before the task was carried out.

There is no requirement to change the font or kerning in this task, however character decorations and attributes are expected to be preserved.   If the implementer decides to change the font or kerning during the display of the temporary screen, then these settings need to be restored prior to exit.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""time""
)
 
func main() {
    fmt.Print(""\033[?1049h\033[H"")
    fmt.Println(""Alternate screen buffer\n"")
    s := ""s""
    for i := 5; i > 0; i-- {
        if i == 1 {
            s = """"
        }
        fmt.Printf(""\rgoing back in %d second%s..."", i, s)
        time.Sleep(time.Second)
    }
    fmt.Print(""\033[?1049l"")
}",361,20
8175,http://rosettacode.org/wiki/Terminal_control/Positional_read,Terminal control/Positional read,"Determine the character displayed on the screen at column 3, row 6 and store that character in a variable. Note that it is permissible to utilize system or language provided methods or system provided facilities, system maintained records or available buffers or system maintained display records to achieve this task, rather than query the terminal directly, if those methods are more usual for the system type or language.
",#Go,Go,"package main
 
/*
#include <windows.h>
*/
import ""C""
import ""fmt""
 
func main() {
    for i := 0; i < 80*25; i++ {
        fmt.Print(""A"")  // fill 80 x 25 console with 'A's
    }
    fmt.Println()
    conOut := C.GetStdHandle(C.STD_OUTPUT_HANDLE)
    info := C.CONSOLE_SCREEN_BUFFER_INFO{}
    pos := C.COORD{}
    C.GetConsoleScreenBufferInfo(conOut, &info)
    pos.X = info.srWindow.Left + 3 // column number 3 of display window
    pos.Y = info.srWindow.Top + 6  // row number 6 of display window
    var c C.wchar_t
    var le C.ulong
    ret := C.ReadConsoleOutputCharacterW(conOut, &c, 1, pos, &le)
    if ret == 0 || le <= 0 {
        fmt.Println(""Something went wrong!"")
        return
    }
    fmt.Printf(""The character at column 3, row 6 is '%c'\n"", c) 
}",766,28
8178,http://rosettacode.org/wiki/The_ISAAC_Cipher,The ISAAC Cipher,"ISAAC is a cryptographically secure pseudo-random number generator (CSPRNG) and stream cipher. It was developed by Bob Jenkins from 1993 (http://burtleburtle.net/bob/rand/isaac.html) and placed in the Public Domain. ISAAC is fast - especially when optimised - and portable to most architectures in nearly all programming and scripting languages.
It is also simple and succinct, using as it does just two 256-word arrays for its state.

ISAAC stands for ""Indirection, Shift, Accumulate, Add, and Count"" which are the principal bitwise operations employed.
To date - and that's after more than 20 years of existence - ISAAC has not been broken (unless GCHQ or NSA did it, but they wouldn't be telling).
ISAAC thus deserves a lot more attention than it has hitherto received and it would be salutary to see it more universally implemented.



Task

Translate ISAAC's reference C or Pascal code into your language of choice.

The RNG should then be seeded with the string ""this is my secret key"" and
finally the message ""a Top Secret secret"" should be encrypted on that key.
Your program's output cipher-text will be a string of hexadecimal digits.

Optional: Include a decryption check by re-initializing ISAAC and performing
the same encryption pass on the cipher-text.

Please use the C or Pascal as a reference guide to these operations.

Two encryption schemes are possible:
(1) XOR (Vernam) or
(2) Caesar-shift mod 95 (Vigenère).
XOR is the simplest; C-shifting offers greater security.

You may choose either scheme, or both, but please specify which you used.
Here are the alternative sample outputs for checking purposes:

Message: a Top Secret secret
Key    : this is my secret key
XOR    : 1C0636190B1260233B35125F1E1D0E2F4C5422
MOD    : 734270227D36772A783B4F2A5F206266236978
XOR dcr: a Top Secret secret
MOD dcr: a Top Secret secret

No official seeding method for ISAAC has been published, but for this task
we may as well just inject the bytes of our key into the randrsl array,
padding with zeroes before mixing, like so:

// zeroise mm array
FOR i:= 0 TO 255 DO mm[i]:=0;
// check seed's highest array element
m := High(seed);
// inject the seed
FOR i:= 0 TO 255 DO BEGIN
	// in case seed[] has less than 256 elements.
	IF i>m THEN randrsl[i]:=0  
		ELSE randrsl[i]:=seed[i];
END;
// initialize ISAAC with seed
RandInit(true);

ISAAC can of course also be initialized with a single 32-bit unsigned integer in the manner of traditional RNGs, and indeed used as such for research and gaming purposes.
But building a strong and simple ISAAC-based stream cipher - replacing the irreparably broken RC4 - is our goal here: ISAAC's intended purpose.



",#Go,Go,"package main
 
import ""fmt""
 
const (
    msg = ""a Top Secret secret""
    key = ""this is my secret key""
)
 
func main() {
    var z state
    z.seed(key)
    fmt.Println(""Message: "", msg)
    fmt.Println(""Key    : "", key)
    fmt.Println(""XOR    : "", z.vernam(msg))
}
 
type state struct {
    aa, bb, cc uint32
    mm         [256]uint32
    randrsl    [256]uint32
    randcnt    int
}
 
func (z *state) isaac() {
    z.cc++
    z.bb += z.cc
    for i, x := range z.mm {
        switch i % 4 {
        case 0:
            z.aa = z.aa ^ z.aa<<13
        case 1:
            z.aa = z.aa ^ z.aa>>6
        case 2:
            z.aa = z.aa ^ z.aa<<2
        case 3:
            z.aa = z.aa ^ z.aa>>16
        }
        z.aa += z.mm[(i+128)%256]
        y := z.mm[x>>2%256] + z.aa + z.bb
        z.mm[i] = y
        z.bb = z.mm[y>>10%256] + x
        z.randrsl[i] = z.bb
    }
}
 
func (z *state) randInit() {
    const gold = uint32(0x9e3779b9)
    a := [8]uint32{gold, gold, gold, gold, gold, gold, gold, gold}
    mix1 := func(i int, v uint32) {
        a[i] ^= v
        a[(i+3)%8] += a[i]
        a[(i+1)%8] += a[(i+2)%8]
    }
    mix := func() {
        mix1(0, a[1]<<11)
        mix1(1, a[2]>>2)
        mix1(2, a[3]<<8)
        mix1(3, a[4]>>16)
        mix1(4, a[5]<<10)
        mix1(5, a[6]>>4)
        mix1(6, a[7]<<8)
        mix1(7, a[0]>>9)
    }
    for i := 0; i < 4; i++ {
        mix()
    }
    for i := 0; i < 256; i += 8 {
        for j, rj := range z.randrsl[i : i+8] {
            a[j] += rj
        }
        mix()
        for j, aj := range a {
            z.mm[i+j] = aj
        }
    }
    for i := 0; i < 256; i += 8 {
        for j, mj := range z.mm[i : i+8] {
            a[j] += mj
        }
        mix()
        for j, aj := range a {
            z.mm[i+j] = aj
        }
    }
    z.isaac()
}
 
func (z *state) seed(seed string) {
    for i, r := range seed {
        if i == 256 {
            break
        }
        z.randrsl[i] = uint32(r)
    }
    z.randInit()
}
 
func (z *state) random() (r uint32) {
    r = z.randrsl[z.randcnt]
    z.randcnt++
    if z.randcnt == 256 {
        z.isaac()
        z.randcnt = 0
    }
    return
}
 
func (z *state) randA() byte {
    return byte(z.random()%95 + 32)
}
 
func (z *state) vernam(msg string) string {
    b := []byte(msg)
    for i := range b {
        b[i] ^= z.randA()
    }
    return fmt.Sprintf(""%X"", b)
}",2394,119
8179,http://rosettacode.org/wiki/Test_integerness,Test integerness,"Mathematically,

 the integers Z are included in the rational numbers Q,
 which are included in the real numbers R,
 which can be generalized to the complex numbers C.


This means that each of those larger sets, and the data types used to represent them, include some integers.

Task[edit]
Given a rational, real, or complex number of any type, test whether it is mathematically an integer.

Your code should handle all numeric data types commonly used in your programming language.

Discuss any limitations of your code.

Definition
For the purposes of this task, integerness means that a number could theoretically be represented as an integer at no loss of precision (given an infinitely wide integer type).

In other words:



 Set

 Common representation

 C++ type

 Considered an integer...


 rational numbers Q

 fraction

 std::ratio

 ...if its denominator is 1 (in reduced form)


 real numbers Z
(approximated)

 fixed-point



 ...if it has no non-zero digits after the decimal point


 floating-point

 float, double

 ...if the number of significant decimal places of its mantissa isn't greater than its exponent


 complex numbers C

 pair of real numbers

 std::complex

 ...if its real part is considered an integer and its imaginary part is zero

Extra credit
Optionally, make your code accept a tolerance parameter for fuzzy testing. The tolerance is the maximum amount by which the number may differ from the nearest integer, to still be considered an integer.

This is useful in practice, because when dealing with approximate numeric types (such as floating point), there may already be round-off errors from previous calculations. For example, a float value of 0.9999999998 might actually be intended to represent the integer 1.

Test cases


 Input

 Output

 Comment


 Type

 Value

 exact

 tolerance = 0.00001


 decimal

 25.000000

 true




 24.999999

 false

 true




 25.000100

 false




 floating-point

 -2.1e120

 true

 This one is tricky, because in most languages it is too large to fit into a native integer type.
It is, nonetheless, mathematically an integer, and your code should identify it as such.


 -5e-2

 false




 NaN

 false




 Inf

 false

 This one is debatable. If your code considers it an integer, that's okay too.


 complex

 5.0+0.0i

 true




 5-5i

 false



(The types and notations shown in these tables are merely examples – you should use the native data types and number literals of your programming language and standard library. Use a different set of test-cases, if this one doesn't demonstrate all relevant behavior.)

",#Go,Go,"package main
 
import (
	""fmt""
	""math""
	""math/big""
	""reflect""
	""strings""
	""unsafe""
)
 
// Go provides an integerness test only for the big.Rat and big.Float types
// in the standard library.
 
// The fundamental piece of code needed for built-in floating point types
// is a test on the float64 type:
 
func Float64IsInt(f float64) bool {
	_, frac := math.Modf(f)
	return frac == 0
}
 
// Other built-in or stanadard library numeric types are either always
// integer or can be easily tested using Float64IsInt.
 
func Float32IsInt(f float32) bool {
	return Float64IsInt(float64(f))
}
 
func Complex128IsInt(c complex128) bool {
	return imag(c) == 0 && Float64IsInt(real(c))
}
 
func Complex64IsInt(c complex64) bool {
	return imag(c) == 0 && Float64IsInt(float64(real(c)))
}
 
// Usually just the above statically typed functions would be all that is used,
// but if it is desired to have a single function that can test any arbitrary
// type, including the standard math/big types, user defined types based on
// an integer, float, or complex builtin types, or user defined types that
// have an IsInt() method, then reflection can be used.
 
type hasIsInt interface {
	IsInt() bool
}
 
var bigIntT = reflect.TypeOf((*big.Int)(nil))
 
func IsInt(i interface{}) bool {
	if ci, ok := i.(hasIsInt); ok {
		// Handles things like *big.Rat
		return ci.IsInt()
	}
	switch v := reflect.ValueOf(i); v.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16,
		reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16,
		reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		// Built-in types and any custom type based on them
		return true
	case reflect.Float32, reflect.Float64:
		// Built-in floats and anything based on them
		return Float64IsInt(v.Float())
	case reflect.Complex64, reflect.Complex128:
		// Built-in complexes and anything based on them
		return Complex128IsInt(v.Complex())
	case reflect.String:
		// Could also do strconv.ParseFloat then FloatIsInt but
		// big.Rat handles everything ParseFloat can plus more.
		// Note, there is no strconv.ParseComplex.
		if r, ok := new(big.Rat).SetString(v.String()); ok {
			return r.IsInt()
		}
	case reflect.Ptr:
		// Special case for math/big.Int
		if v.Type() == bigIntT {
			return true
		}
	}
	return false
}
 
// The rest is just demonstration and display
 
type intbased int16
type complexbased complex64
type customIntegerType struct {
	// Anything that stores or represents a sub-set
	// of integer values in any way desired.
}
 
func (customIntegerType) IsInt() bool    { return true }
func (customIntegerType) String() string { return ""<…>"" }
 
func main() {
	hdr := fmt.Sprintf(""%27s  %-6s %s\n"", ""Input"", ""IsInt"", ""Type"")
	show2 := func(t bool, i interface{}, args ...interface{}) {
		istr := fmt.Sprint(i)
		fmt.Printf(""%27s  %-6t %T "", istr, t, i)
		fmt.Println(args...)
	}
	show := func(i interface{}, args ...interface{}) {
		show2(IsInt(i), i, args...)
	}
 
	fmt.Print(""Using Float64IsInt with float64:\n"", hdr)
	neg1 := -1.
	for _, f := range []float64{
		0, neg1 * 0, -2, -2.000000000000001, 10. / 2, 22. / 3,
		math.Pi,
		math.MinInt64, math.MaxUint64,
		math.SmallestNonzeroFloat64, math.MaxFloat64,
		math.NaN(), math.Inf(1), math.Inf(-1),
	} {
		show2(Float64IsInt(f), f)
	}
 
	fmt.Print(""\nUsing Complex128IsInt with complex128:\n"", hdr)
	for _, c := range []complex128{
		3, 1i, 0i, 3.4,
	} {
		show2(Complex128IsInt(c), c)
	}
 
	fmt.Println(""\nUsing reflection:"")
	fmt.Print(hdr)
	show(""hello"")
	show(math.MaxFloat64)
	show(""9e100"")
	f := new(big.Float)
	show(f)
	f.SetString(""1e-3000"")
	show(f)
	show(""(4+0i)"", ""(complex strings not parsed)"")
	show(4 + 0i)
	show(rune('§'), ""or rune"")
	show(byte('A'), ""or byte"")
	var t1 intbased = 5200
	var t2a, t2b complexbased = 5 + 0i, 5 + 1i
	show(t1)
	show(t2a)
	show(t2b)
	x := uintptr(unsafe.Pointer(&t2b))
	show(x)
	show(math.MinInt32)
	show(uint64(math.MaxUint64))
	b, _ := new(big.Int).SetString(strings.Repeat(""9"", 25), 0)
	show(b)
	r := new(big.Rat)
	show(r)
	r.SetString(""2/3"")
	show(r)
	show(r.SetFrac(b, new(big.Int).SetInt64(9)))
	show(""12345/5"")
	show(new(customIntegerType))
}",4129,157
8245,http://rosettacode.org/wiki/Test_a_function,Test a function,"

Task

Using a well-known testing-specific library/module/suite for your language, write some tests for your language's entry in Palindrome.

If your language does not have a testing specific library well known to the language's community then state this or omit the language.


",#Go,Go,"package pal
 
import ""testing""
 
func TestPals(t *testing.T) {
    pals := []string{
        """",
        ""."",
        ""11"",
        ""ere"",
        ""ingirumimusnocteetconsumimurigni"",
    }
    for _, s := range pals {
        if !IsPal(s) {
            t.Error(""IsPal returned false on palindrome,"", s)
        }
    }
}
 
func TestNonPals(t *testing.T) {
    nps := []string{
        ""no"",
        ""odd"",
        ""salàlas"",
    }
    for _, s := range nps {
        if IsPal(s) {
            t.Error(""IsPal returned true on non-palindrome,"", s)
        }
    }
}",563,31
8259,http://rosettacode.org/wiki/Terminal_control/Hiding_the_cursor,Terminal control/Hiding the cursor,"The task is to hide the cursor and show it again.



",#Go,Go,"package main
 
import (
    ""os""
    ""os/exec""
    ""time""
)
 
func main() {
    tput(""civis"") // hide
    time.Sleep(3 * time.Second)
    tput(""cvvis"") // show
    time.Sleep(3 * time.Second)
}
 
func tput(arg string) error {
    cmd := exec.Command(""tput"", arg)
    cmd.Stdout = os.Stdout
    return cmd.Run()
}",312,20
8264,http://rosettacode.org/wiki/Terminal_control/Inverse_video,Terminal control/Inverse video,"Task

Display a word in inverse video   (or reverse video)   followed by a word in normal video.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""os""
    ""os/exec""
)
 
func main() {
    tput(""rev"")
    fmt.Print(""Rosetta"")
    tput(""sgr0"")
    fmt.Println("" Code"")
}
 
func tput(arg string) error {
    cmd := exec.Command(""tput"", arg)
    cmd.Stdout = os.Stdout
    return cmd.Run()
}",278,20
8385,http://rosettacode.org/wiki/Terminal_control/Display_an_extended_character,Terminal control/Display an extended character,"Task

Display an extended (non ASCII) character onto the terminal.

Specifically, display a    £    (GBP currency sign).



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    fmt.Println(""£"")
}",66,7
8481,http://rosettacode.org/wiki/Terminal_control/Dimensions,Terminal control/Dimensions,"Determine the height and width of the terminal, and store this information into variables for subsequent use.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""os""
 
    ""golang.org/x/crypto/ssh/terminal""
)
 
func main() {
    w, h, err := terminal.GetSize(int(os.Stdout.Fd()))
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(h, w)
}",246,17
8489,http://rosettacode.org/wiki/Terminal_control/Cursor_positioning,Terminal control/Cursor positioning,"

Task

Move the cursor to column   3,   row   6,   and display the word   ""Hello""   (without the quotes),   so that the letter   H   is in column   3   on row   6.



",#Go,Go,"package main
 
import (
    ""bytes""
    ""fmt""
    ""os""
    ""os/exec""
)
 
func main() {
    cmd := exec.Command(""tput"", ""-S"")
    cmd.Stdin = bytes.NewBufferString(""clear\ncup 5 2"")
    cmd.Stdout = os.Stdout
    cmd.Run()
    fmt.Println(""Hello"")
}",248,16
8627,http://rosettacode.org/wiki/Terminal_control/Cursor_movement,Terminal control/Cursor movement,"Task

Demonstrate how to achieve movement of the terminal cursor:

 how to move the cursor one position to the left
 how to move the cursor one position to the right
 how to move the cursor up one line (without affecting its horizontal position)
 how to move the cursor down one line (without affecting its horizontal position)
 how to move the cursor to the beginning of the line
 how to move the cursor to the end of the line
 how to move the cursor to the top left corner of the screen
 how to move the cursor to the bottom right corner of the screen


For the purpose of this task, it is not permitted to overwrite any characters or attributes on any part of the screen (so outputting a space is not a suitable solution to achieve a movement to the right).



Handling of out of bounds locomotion
This task has no specific requirements to trap or correct cursor movement beyond the terminal boundaries, so the implementer should decide what behavior fits best in terms of the chosen language.   Explanatory notes may be added to clarify how an out of bounds action would behave and the generation of error messages relating to an out of bounds cursor position is permitted.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""time""
    ""os""
    ""os/exec""
    ""strconv""
)
 
func main() {
    tput(""clear"") // clear screen
    tput(""cup"", ""6"", ""3"") // an initial position
    time.Sleep(1 * time.Second)
    tput(""cub1"") // left
    time.Sleep(1 * time.Second)
    tput(""cuf1"") // right
    time.Sleep(1 * time.Second)
    tput(""cuu1"") // up
    time.Sleep(1 * time.Second)
    // cud1 seems broken for me.  cud 1 works fine though.
    tput(""cud"", ""1"") // down
    time.Sleep(1 * time.Second)
    tput(""cr"") // begining of line
    time.Sleep(1 * time.Second)
    // get screen size here
    var h, w int
    cmd := exec.Command(""stty"", ""size"")
    cmd.Stdin = os.Stdin
    d, _ := cmd.Output()
    fmt.Sscan(string(d), &h, &w)
    // end of line
    tput(""hpa"", strconv.Itoa(w-1))
    time.Sleep(2 * time.Second)
    // top left
    tput(""home"")
    time.Sleep(2 * time.Second)
    // bottom right
    tput(""cup"", strconv.Itoa(h-1), strconv.Itoa(w-1))
    time.Sleep(3 * time.Second)
}
 
func tput(args ...string) error {
    cmd := exec.Command(""tput"", args...)
    cmd.Stdout = os.Stdout
    return cmd.Run()
}",1125,47
8676,http://rosettacode.org/wiki/Text_processing/1,Text processing/1,"This task has been flagged for clarification. Code on this page in its current state may be flagged incorrect once this task has been clarified. See this page's Talk page for discussion.
Often data is produced by one program, in the wrong format for later use by another program or person. In these situations another program can be written to parse and transform the original data into a format useful to the other. The term ""Data Munging"" is often used in programming circles for this task.

A request on the comp.lang.awk newsgroup led to a typical data munging task:

I have to analyse data files that have the following format:
Each row corresponds to 1 day and the field logic is: $1 is the date,
followed by 24 value/flag pairs, representing measurements at 01:00,
02:00 ... 24:00 of the respective day. In short:

<date> <val1> <flag1> <val2> <flag2> ...  <val24> <flag24>

Some test data is available at: 
... (nolonger available at original location)

I have to sum up the values (per day and only valid data, i.e. with
flag>0) in order to calculate the mean. That's not too difficult.
However, I also need to know what the ""maximum data gap"" is, i.e. the
longest period with successive invalid measurements (i.e values with
flag<=0)
The data is free to download and use and is of this format:

Data is no longer available at that link. Zipped mirror available here (offsite mirror).

1991-03-30	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1
1991-03-31	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	20.000	1	20.000	1	20.000	1	35.000	1	50.000	1	60.000	1	40.000	1	30.000	1	30.000	1	30.000	1	25.000	1	20.000	1	20.000	1	20.000	1	20.000	1	20.000	1	35.000	1
1991-03-31	40.000	1	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2
1991-04-01	0.000	-2	13.000	1	16.000	1	21.000	1	24.000	1	22.000	1	20.000	1	18.000	1	29.000	1	44.000	1	50.000	1	43.000	1	38.000	1	27.000	1	27.000	1	24.000	1	23.000	1	18.000	1	12.000	1	13.000	1	14.000	1	15.000	1	13.000	1	10.000	1
1991-04-02	8.000	1	9.000	1	11.000	1	12.000	1	12.000	1	12.000	1	27.000	1	26.000	1	27.000	1	33.000	1	32.000	1	31.000	1	29.000	1	31.000	1	25.000	1	25.000	1	24.000	1	21.000	1	17.000	1	14.000	1	15.000	1	12.000	1	12.000	1	10.000	1
1991-04-03	10.000	1	9.000	1	10.000	1	10.000	1	9.000	1	10.000	1	15.000	1	24.000	1	28.000	1	24.000	1	18.000	1	14.000	1	12.000	1	13.000	1	14.000	1	15.000	1	14.000	1	15.000	1	13.000	1	13.000	1	13.000	1	12.000	1	10.000	1	10.000	1

Only a sample of the data showing its format is given above. The full example file may be downloaded here.

Structure your program to show statistics for each line of the file, (similar to the original Python, Perl, and AWK examples below), followed by summary statistics for the file. When showing example output just show a few line statistics and the full end summary.
",#Go,Go,"package main
 
import (
	""bufio""
	""fmt""
	""log""
	""os""
	""strconv""
	""strings""
)
 
const (
	filename = ""readings.txt""
	readings = 24             // per line
	fields   = readings*2 + 1 // per line
)
 
func main() {
	file, err := os.Open(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()
	var (
		badRun, maxRun   int
		badDate, maxDate string
		fileSum          float64
		fileAccept       int
	)
	endBadRun := func() {
		if badRun > maxRun {
			maxRun = badRun
			maxDate = badDate
		}
		badRun = 0
	}
	s := bufio.NewScanner(file)
	for s.Scan() {
		f := strings.Fields(s.Text())
		if len(f) != fields {
			log.Fatal(""unexpected format,"", len(f), ""fields."")
		}
		var accept int
		var sum float64
		for i := 1; i < fields; i += 2 {
			flag, err := strconv.Atoi(f[i+1])
			if err != nil {
				log.Fatal(err)
			}
			if flag <= 0 { // value is bad
				if badRun++; badRun == 1 {
					badDate = f[0]
				}
			} else { // value is good
				endBadRun()
				value, err := strconv.ParseFloat(f[i], 64)
				if err != nil {
					log.Fatal(err)
				}
				sum += value
				accept++
			}
		}
		fmt.Printf(""Line: %s  Reject %2d  Accept: %2d  Line_tot:%9.3f"",
			f[0], readings-accept, accept, sum)
		if accept > 0 {
			fmt.Printf(""  Line_avg:%8.3f\n"", sum/float64(accept))
		} else {
			fmt.Println()
		}
		fileSum += sum
		fileAccept += accept
	}
	if err := s.Err(); err != nil {
		log.Fatal(err)
	}
	endBadRun()
 
	fmt.Println(""\nFile     ="", filename)
	fmt.Printf(""Total    = %.3f\n"", fileSum)
	fmt.Println(""Readings = "", fileAccept)
	if fileAccept > 0 {
		fmt.Printf(""Average  =  %.3f\n"", fileSum/float64(fileAccept))
	}
	if maxRun == 0 {
		fmt.Println(""\nAll data valid."")
	} else {
		fmt.Printf(""\nMax data gap = %d, beginning on line %s.\n"",
			maxRun, maxDate)
	}
}",1771,91
8735,http://rosettacode.org/wiki/Teacup_rim_text,Teacup rim text,"On a set of coasters we have, there's a picture of a teacup.   On the rim of the teacup the word   TEA   appears a number of times separated by bullet characters   (•).

It occurred to me that if the bullet were removed and the words run together,   you could start at any letter and still end up with a meaningful three-letter word.

So start at the   T   and read   TEA.   Start at the   E   and read   EAT,   or start at the   A   and read   ATE.

That got me thinking that maybe there are other words that could be used rather that   TEA.   And that's just English.   What about Italian or Greek or ... um ... Telugu.

For English, we will use the unixdict (now) located at:   unixdict.txt.

(This will maintain continuity with other Rosetta Code tasks that also use it.)



Task

Search for a set of words that could be printed around the edge of a teacup.   The words in each set are to be of the same length, that length being greater than two (thus precluding   AH   and   HA,   for example.)

Having listed a set, for example   [ate tea eat],   refrain from displaying permutations of that set, e.g.:   [eat tea ate]   etc.

The words should also be made of more than one letter   (thus precluding   III   and   OOO   etc.)

The relationship between these words is (using ATE as an example) that the first letter of the first becomes the last letter of the second.   The first letter of the second becomes the last letter of the third.   So   ATE   becomes   TEA   and   TEA   becomes   EAT.

All of the possible permutations, using this particular permutation technique, must be words in the list.

The set you generate for   ATE   will never included the word   ETA   as that cannot be reached via the first-to-last movement method.

Display one line for each set of teacup rim words.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""log""
    ""os""
    ""sort""
    ""strings""
)
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func readWords(fileName string) []string {
    file, err := os.Open(fileName)
    check(err)
    defer file.Close()
    var words []string
    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
        word := strings.ToLower(strings.TrimSpace(scanner.Text()))
        if len(word) >= 3 {
            words = append(words, word)
        }
    }
    check(scanner.Err())
    return words
}
 
func rotate(runes []rune) {
    first := runes[0]
    copy(runes, runes[1:])
    runes[len(runes)-1] = first
}
 
func main() {
    dicts := []string{""mit_10000.txt"", ""unixdict.txt""} // local copies
    for _, dict := range dicts {
        fmt.Printf(""Using %s:\n\n"", dict)
        words := readWords(dict)
        n := len(words)
        used := make(map[string]bool)
    outer:
        for _, word := range words {
            runes := []rune(word)
            variants := []string{word}
            for i := 0; i < len(runes)-1; i++ {
                rotate(runes)
                word2 := string(runes)
                if word == word2 || used[word2] {
                    continue outer
                }
                ix := sort.SearchStrings(words, word2)
                if ix == n || words[ix] != word2 {
                    continue outer
                }
                variants = append(variants, word2)
            }
            for _, variant := range variants {
                used[variant] = true
            }
            fmt.Println(variants)
        }
        fmt.Println()
    }
}",1674,70
8772,http://rosettacode.org/wiki/Terminal_control/Coloured_text,Terminal control/Coloured text,"Task

Display a word in various colours on the terminal.

The system palette, or colours such as Red, Green, Blue, Magenta, Cyan, and Yellow can be used.



Optionally demonstrate:

 How the system should determine if the terminal supports colour
 Setting of the background colour
 How to cause blinking or flashing (if supported by the terminal)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""os""
    ""os/exec""
)
 
func main() {
    color(red)
    fmt.Println(""Red"")
    color(green)
    fmt.Println(""Green"")
    color(blue)
    fmt.Println(""Blue"")
}
 
const (
    blue  = ""1""
    green = ""2""
    red   = ""4""
)
 
func color(c string) {
    cmd := exec.Command(""tput"", ""setf"", c)
    cmd.Stdout = os.Stdout
    cmd.Run()
}",367,28
8812,http://rosettacode.org/wiki/Tarjan,Tarjan,"

 This page uses content from Wikipedia. The original article was at Graph. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Tarjan's algorithm is an algorithm in graph theory for finding the strongly connected components of a graph.

It runs in linear time, matching the time bound for alternative methods including Kosaraju's algorithm and the path-based strong component algorithm.

Tarjan's Algorithm is named for its discoverer, Robert Tarjan.



References

 The article on Wikipedia.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
// (same data as zkl example)
var g = [][]int{
    0: {1},
    2: {0},
    5: {2, 6},
    6: {5},
    1: {2},
    3: {1, 2, 4},
    4: {5, 3},
    7: {4, 7, 6},
}
 
func main() {
    tarjan(g, func(c []int) { fmt.Println(c) })
}
 
// the function calls the emit argument for each component identified.
// each component is a list of nodes.
func tarjan(g [][]int, emit func([]int)) {
    var indexed, stacked big.Int
    index := make([]int, len(g))
    lowlink := make([]int, len(g))
    x := 0
    var S []int
    var sc func(int) bool
    sc = func(n int) bool {
        index[n] = x
        indexed.SetBit(&indexed, n, 1)
        lowlink[n] = x
        x++
        S = append(S, n)
        stacked.SetBit(&stacked, n, 1)
        for _, nb := range g[n] {
            if indexed.Bit(nb) == 0 {
                if !sc(nb) {
                    return false
                }
                if lowlink[nb] < lowlink[n] {
                    lowlink[n] = lowlink[nb]
                }
            } else if stacked.Bit(nb) == 1 {
                if index[nb] < lowlink[n] {
                    lowlink[n] = index[nb]
                }
            }
        }
        if lowlink[n] == index[n] {
            var c []int
            for {
                last := len(S) - 1
                w := S[last]
                S = S[:last]
                stacked.SetBit(&stacked, w, 0)
                c = append(c, w)
                if w == n {
                    emit(c)
                    break
                }
            }
        }
        return true
    }
    for n := range g {
        if indexed.Bit(n) == 0 && !sc(n) {
            return
        }
    }
}",1715,75
8820,http://rosettacode.org/wiki/Ternary_logic,Ternary logic,"

 This page uses content from Wikipedia. The original article was at Ternary logic. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In logic, a three-valued logic (also trivalent, ternary, or trinary logic, sometimes abbreviated 3VL) is any of several many-valued logic systems in which there are three truth values indicating true, false and some indeterminate third value.

This is contrasted with the more commonly known bivalent logics (such as classical sentential or boolean logic) which provide only for true and false.

Conceptual form and basic ideas were initially created by Łukasiewicz, Lewis and Sulski.

These were then re-formulated by Grigore Moisil in an axiomatic algebraic form, and also extended to n-valued logics in 1945.


Example Ternary Logic Operators in Truth Tables:




not a


 ¬


 True 
 False


 Maybe 
 Maybe


 False 
 True




a and b


 ∧

 True 
 Maybe 
 False


 True 
 True 
 Maybe 
 False


 Maybe 
 Maybe 
 Maybe 
 False


 False 
 False 
 False 
 False




a or b


 ∨

 True 
 Maybe 
 False


 True 
 True 
 True 
 True


 Maybe 
 True 
 Maybe 
 Maybe


 False 
 True 
 Maybe 
 False





if a then b


 ⊃

 True 
 Maybe 
 False


 True 
 True 
 Maybe 
 False


 Maybe 
 True 
 Maybe 
 Maybe


 False 
 True 
 True 
 True




a is equivalent to b


 ≡

 True 
 Maybe 
 False


 True 
 True 
 Maybe 
 False


 Maybe 
 Maybe 
 Maybe 
 Maybe


 False 
 False 
 Maybe 
 True




Task

 Define a new type that emulates ternary logic by storing data trits.
 Given all the binary logic operators of the original programming language, reimplement these operators for the new Ternary logic type trit.
 Generate a sampling of results using trit variables.
 Kudos for actually thinking up a test case algorithm where ternary logic is intrinsically useful, optimises the test case algorithm and is preferable to binary logic.


Note:   Setun   (Сетунь) was a   balanced ternary   computer developed in 1958 at   Moscow State University.   The device was built under the lead of   Sergei Sobolev   and   Nikolay Brusentsov.   It was the only modern   ternary computer,   using three-valued ternary logic
",#Go,Go,"package main
 
import ""fmt""
 
type trit int8
 
const (
    trFalse trit = iota - 1
    trMaybe
    trTrue
)
 
func (t trit) String() string {
    switch t {
    case trFalse:
        return ""False""
    case trMaybe:
        return ""Maybe""
    case trTrue:
        return ""True ""
    }
    panic(""Invalid trit"")
}
 
func trNot(t trit) trit {
    return -t
}
 
func trAnd(s, t trit) trit {
    if s < t {
        return s
    }
    return t
}
 
func trOr(s, t trit) trit {
    if s > t {
        return s
    }
    return t
}
 
func trEq(s, t trit) trit {
    return s * t
}
 
func main() {
    trSet := []trit{trFalse, trMaybe, trTrue}
 
    fmt.Println(""t     not t"")
    for _, t := range trSet {
        fmt.Println(t, trNot(t))
    }
 
    fmt.Println(""\ns     t     s and t"")
    for _, s := range trSet {
        for _, t := range trSet {
            fmt.Println(s, t, trAnd(s, t))
        }
    }
 
    fmt.Println(""\ns     t     s or t"")
    for _, s := range trSet {
        for _, t := range trSet {
            fmt.Println(s, t, trOr(s, t))
        }
    }
 
    fmt.Println(""\ns     t     s eq t"")
    for _, s := range trSet {
        for _, t := range trSet {
            fmt.Println(s, t, trEq(s, t))
        }
    }
}",1232,75
8886,http://rosettacode.org/wiki/Tau_number,Tau number,"A Tau number is a positive integer divisible by the count of its positive divisors.



Task
Show the first   100   Tau numbers.
The numbers shall be generated during run-time (i.e. the code may not contain string literals, sets/arrays of integers, or alike).



Related task
  Tau function

",#Go,Go,"package main
 
import ""fmt""
 
func countDivisors(n int) int {
    count := 0
    i := 1
    k := 2
    if n%2 == 0 {
        k = 1
    }
    for i*i <= n {
        if n%i == 0 {
            count++
            j := n / i
            if j != i {
                count++
            }
        }
        i += k
    }
    return count
}
 
func main() {
    fmt.Println(""The first 100 tau numbers are:"")
    count := 0
    i := 1
    for count < 100 {
        tf := countDivisors(i)
        if i%tf == 0 {
            fmt.Printf(""%4d  "", i)
            count++
            if count%10 == 0 {
                fmt.Println()
            }
        }
        i++
    }
}",660,40
8900,http://rosettacode.org/wiki/The_Twelve_Days_of_Christmas,The Twelve Days of Christmas,"Task

Write a program that outputs the lyrics of the Christmas carol The Twelve Days of Christmas.
The lyrics can be found here.

(You must reproduce the words in the correct order, but case, format, and punctuation are left to your discretion.)




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
	""fmt""
)
 
func main() {
	days := []string{""first"", ""second"", ""third"", ""fourth"", ""fifth"", ""sixth"",
		""seventh"", ""eighth"", ""ninth"", ""tenth"", ""eleventh"", ""twelfth""}
 
	gifts := []string{""A Partridge in a Pear Tree"", ""Two Turtle Doves and"", ""Three French Hens"",
		""Four Calling Birds"", ""Five Gold Rings"", ""Six Geese a-Laying"",
		""Seven Swans a-Swimming"", ""Eight Maids a-Milking"", ""Nine Ladies Dancing"",
		""Ten Lords a-Leaping"", ""Eleven Pipers Piping"", ""Twelve Drummers Drumming""}
 
	for i := 0; i < 12; i++ {
		fmt.Printf(""On the %s day of Christmas,\n"", days[i])
		fmt.Println(""My true love sent to me:"")
 
		for j := i; j >= 0; j-- {
			fmt.Println(gifts[j])
		}
		fmt.Println()
	}
}
 ",708,26
8905,http://rosettacode.org/wiki/Table_creation/Postal_addresses,Table creation/Postal addresses,"Task

Create a table to store addresses.

You may assume that all the addresses to be stored will be located in the USA.   As such, you will need (in addition to a field holding a unique identifier) a field holding the street address, a field holding the city, a field holding the state code, and a field holding the zipcode.   Choose appropriate types for each field.

For non-database languages, show how you would open a connection to a database (your choice of which) and create an address table in it. You should follow the existing models here for how you would structure the table.



",#Go,Go,"package main
 
import (
    ""database/sql""
    ""fmt""
    ""log""
 
    _ ""github.com/mattn/go-sqlite3""
)
 
func main() {
    // task req: show database connection
    db, err := sql.Open(""sqlite3"", ""rc.db"")
    if err != nil {
        log.Print(err)
        return
    }
    defer db.Close()
    // task req: create table with typed fields, including a unique id
    _, err = db.Exec(`create table addr (
        id     int unique,
        street text,
        city   text,
        state  text,
        zip    text
    )`)
    if err != nil {
        log.Print(err)
        return
    }
    // show output:  query the created field names and types
    rows, err := db.Query(`pragma table_info(addr)`)
    if err != nil {
        log.Print(err)
        return
    }
    var field, storage string
    var ignore sql.RawBytes
    for rows.Next() {
        err = rows.Scan(&ignore, &field, &storage, &ignore, &ignore, &ignore)
        if err != nil {
            log.Print(err)
            return
        }
        fmt.Println(field, storage)
    }
}",1044,47
8946,http://rosettacode.org/wiki/Terminal_control/Clear_the_screen,Terminal control/Clear the screen,"Task

Clear the terminal window.



",#Go,Go,"package main
 
import (
    ""os""
    ""os/exec""
)
 
func main() {
    c := exec.Command(""clear"")
    c.Stdout = os.Stdout
    c.Run()
}",134,12
9027,http://rosettacode.org/wiki/Taxicab_numbers,Taxicab numbers,"
A   taxicab number   (the definition that is being used here)   is a positive integer that can be expressed as the sum of two positive cubes in more than one way.



The first taxicab number is   1729,   which is:

 13   +   123       and also
 93   +   103.


Taxicab numbers are also known as:

   taxi numbers
   taxi-cab numbers
   taxi cab numbers
   Hardy-Ramanujan numbers


Task

 Compute and display the lowest 25 taxicab numbers (in numeric order, and in a human-readable format).
 For each of the taxicab numbers, show the number as well as it's constituent cubes.


Extra credit
 Show the 2,000th taxicab number, and a half dozen more


See also

 A001235: taxicab numbers on The On-Line Encyclopedia of Integer Sequences.
 Hardy-Ramanujan Number on MathWorld.
 taxicab number on MathWorld.
 taxicab number on Wikipedia   (includes the story on how taxi-cab numbers came to be called).

",#Go,Go,"package main
 
import (
	""container/heap""
	""fmt""
	""strings""
)
 
type CubeSum struct {
	x, y  uint16
	value uint64
}
 
func (c *CubeSum) fixvalue() { c.value = cubes[c.x] + cubes[c.y] }
 
type CubeSumHeap []*CubeSum
 
func (h CubeSumHeap) Len() int            { return len(h) }
func (h CubeSumHeap) Less(i, j int) bool  { return h[i].value < h[j].value }
func (h CubeSumHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }
func (h *CubeSumHeap) Push(x interface{}) { (*h) = append(*h, x.(*CubeSum)) }
func (h *CubeSumHeap) Pop() interface{} {
	x := (*h)[len(*h)-1]
	*h = (*h)[:len(*h)-1]
	return x
}
 
type TaxicabGen struct {
	n int
	h CubeSumHeap
}
 
var cubes []uint64 // cubes[i] == i*i*i
func cubesExtend(i int) {
	for n := uint64(len(cubes)); n <= uint64(i); n++ {
		cubes = append(cubes, n*n*n)
	}
}
 
func (g *TaxicabGen) min() CubeSum {
	for len(g.h) == 0 || g.h[0].value > cubes[g.n] {
		g.n++
		cubesExtend(g.n)
		heap.Push(&g.h, &CubeSum{uint16(g.n), 1, cubes[g.n] + 1})
	}
	// Note, we use g.h[0] to ""peek"" at the min heap entry.
	c := *(g.h[0])
	if c.y+1 <= c.x {
		// Instead of Pop and Push we modify in place and fix.
		g.h[0].y++
		g.h[0].fixvalue()
		heap.Fix(&g.h, 0)
	} else {
		heap.Pop(&g.h)
	}
	return c
}
 
// Originally this was just: type Taxicab [2]CubeSum
// and we always returned two sums. Now we return all the sums.
type Taxicab []CubeSum
 
func (t Taxicab) String() string {
	var b strings.Builder
	fmt.Fprintf(&b, ""%12d"", t[0].value)
	for _, p := range t {
		fmt.Fprintf(&b, "" =%5d³ +%5d³"", p.x, p.y)
	}
	return b.String()
}
 
func (g *TaxicabGen) Next() Taxicab {
	a, b := g.min(), g.min()
	for a.value != b.value {
		a, b = b, g.min()
	}
	//return Taxicab{a,b}
 
	// Originally this just returned Taxicab{a,b} and we didn't look
	// further into the heap. Since we start by looking at the next
	// pair, that is okay until the first Taxicab number with four
	// ways of expressing the cube, which doesn't happen until the
	// 97,235th Taxicab:
	//     6963472309248 = 16630³ + 13322³ = 18072³ + 10200³
	//                   = 18948³ +  5436³ = 19083³ +  2421³
	// Now we return all ways so we need to peek into the heap.
	t := Taxicab{a, b}
	for g.h[0].value == b.value {
		t = append(t, g.min())
	}
	return t
}
 
func main() {
	const (
		low  = 25
		mid  = 2e3
		high = 4e4
	)
	var tg TaxicabGen
	firstn := 3 // To show the first triple, quadruple, etc
	for i := 1; i <= high+6; i++ {
		t := tg.Next()
		switch {
		case len(t) >= firstn:
			firstn++
			fallthrough
		case i <= low || (mid <= i && i <= mid+6) || i >= high:
			//fmt.Printf(""h:%-4d  "", len(tg.h))
			fmt.Printf(""%5d: %v\n"", i, t)
		}
	}
}",2642,113
9035,http://rosettacode.org/wiki/Tau_function,Tau function,"Given a positive integer, count the number of its positive divisors.



Task
Show the result for the first   100   positive integers.



Related task
  Tau number

",#Go,Go,"package main
 
import ""fmt""
 
func countDivisors(n int) int {
    count := 0
    i := 1
    k := 2
    if n%2 == 0 {
        k = 1
    }
    for i*i <= n {
        if n%i == 0 {
            count++
            j := n / i
            if j != i {
                count++
            }
        }
        i += k
    }
    return count
}
 
func main() {
    fmt.Println(""The tau functions for the first 100 positive integers are:"")
    for i := 1; i <= 100; i++ {
        fmt.Printf(""%2d  "", countDivisors(i))
        if i%20 == 0 {
            fmt.Println()
        }
    }
}",571,33
9086,http://rosettacode.org/wiki/Sylvester%27s_sequence,Sylvester's sequence,"

 This page uses content from Wikipedia. The original article was at Sylvester's sequence. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In number theory, Sylvester's sequence is an integer sequence in which each term of the sequence is the product of the previous terms, plus one.

Its values grow doubly exponentially, and the sum of its reciprocals forms a series of unit fractions that converges to 1 more rapidly than any other series of unit fractions with the same number of terms.

Further, the sum of the first k terms of the infinite series of reciprocals provides the closest possible underestimate of 1 by any k-term Egyptian fraction.



Task

 Write a routine (function, procedure, generator, whatever) to calculate Sylvester's sequence.
 Use that routine to show the values of the first 10 elements in the sequence.
 Show the sum of the reciprocals of the first 10 elements on the sequence, ideally as an exact fraction.


Related tasks

 Egyptian fractions
 Harmonic series


See also
 
 OEIS A000058 - Sylvester's sequence

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    one := big.NewInt(1)
    two := big.NewInt(2)
    next := new(big.Int)
    sylvester := []*big.Int{two}
    prod := new(big.Int).Set(two)
    count := 1
    for count < 10 {
        next.Add(prod, one)
        sylvester = append(sylvester, new(big.Int).Set(next))
        count++
        prod.Mul(prod, next)
    }
    fmt.Println(""The first 10 terms in the Sylvester sequence are:"")
    for i := 0; i < 10; i++ {
        fmt.Println(sylvester[i])
    }
 
    sumRecip := new(big.Rat)
    for _, s := range sylvester {
        sumRecip.Add(sumRecip, new(big.Rat).SetFrac(one, s))
    }
    fmt.Println(""\nThe sum of their reciprocals as a rational number is:"")
    fmt.Println(sumRecip)
    fmt.Println(""\nThe sum of their reciprocals as a decimal number (to 211 places) is:"")
    fmt.Println(sumRecip.FloatString(211))
}",892,34
9127,http://rosettacode.org/wiki/Superpermutation_minimisation,Superpermutation minimisation,"A superpermutation of N different characters is a string consisting of an arrangement of multiple copies of those N different characters in which every permutation of those characters can be found as a substring.

For example, representing the characters as A..Z, using N=2 we choose to use the first two characters 'AB'. 

The permutations of 'AB' are the two, (i.e. two-factorial), strings: 'AB' and 'BA'.

A too obvious method of generating a superpermutation is to just join all the permutations together forming 'ABBA'.

A little thought will produce the shorter (in fact the shortest) superpermutation of 'ABA' - it contains 'AB' at the beginning and contains 'BA' from the middle to the end.

The ""too obvious"" method of creation generates a string of length N!*N. Using this as a yardstick, the task is to investigate other methods of generating superpermutations of N from 1-to-7 characters, that never generate larger superpermutations.

Show descriptions and comparisons of algorithms used here, and select the ""Best"" algorithm as being the one generating shorter superpermutations.

The problem of generating the shortest superpermutation for each N might be NP complete, although the minimal strings for small values of N have been found by brute -force searches.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




Reference

 The Minimal Superpermutation Problem. by Nathaniel Johnston.
 oeis A180632 gives 0-5 as 0, 1, 3, 9, 33, 153. 6 is thought to be 872.
 Superpermutations - Numberphile. A video
 Superpermutations: the maths problem solved by 4chan - Standupmaths. A video of recent (2018) mathematical progress.
 New Superpermutations Discovered! Standupmaths & Numberphile.

",#Go,Go,"package main
 
import ""fmt""
 
const max = 12
 
var (
    super []byte
    pos   int
    cnt   [max]int
)
 
// 1! + 2! + ... + n!
func factSum(n int) int {
    s := 0
    for x, f := 0, 1; x < n; {
        x++
        f *= x
        s += f
    }
    return s
}
 
func r(n int) bool {
    if n == 0 {
        return false
    }
    c := super[pos-n]
    cnt[n]--
    if cnt[n] == 0 {
        cnt[n] = n
        if !r(n - 1) {
            return false
        }
    }
    super[pos] = c
    pos++
    return true
}
 
func superperm(n int) {
    pos = n
    le := factSum(n)
    super = make([]byte, le)
    for i := 0; i <= n; i++ {
        cnt[i] = i
    }
    for i := 1; i <= n; i++ {
        super[i-1] = byte(i) + '0'
    }
 
    for r(n) {
    }
}
 
func main() {
    for n := 0; n < max; n++ {
        fmt.Printf(""superperm(%2d) "", n)
        superperm(n)
        fmt.Printf(""len = %d\n"", len(super))
    }
}",912,62
9191,http://rosettacode.org/wiki/Super-d_numbers,Super-d numbers,"A super-d number is a positive, decimal (base ten) integer   n   such that   d × nd   has at least   d   consecutive digits   d   where

   2 ≤ d ≤ 9

For instance, 753 is a super-3 number because 3 × 7533 = 1280873331.


Super-d   numbers are also shown on   MathWorld™   as   super-d    or   super-d.



Task

 Write a function/procedure/routine to find super-d numbers.
 For   d=2   through   d=6,   use the routine to show the first   10   super-d numbers.


Extra credit

 Show the first   10   super-7, super-8, and/or super-9 numbers   (optional).


See also

   Wolfram MathWorld - Super-d Number.
   OEIS: A014569 - Super-3 Numbers.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""strings""
    ""time""
)
 
func main() {
    start := time.Now()
    rd := []string{""22"", ""333"", ""4444"", ""55555"", ""666666"", ""7777777"", ""88888888"", ""999999999""}
    one := big.NewInt(1)
    nine := big.NewInt(9)
    for i := big.NewInt(2); i.Cmp(nine) <= 0; i.Add(i, one) {
        fmt.Printf(""First 10 super-%d numbers:\n"", i)
        ii := i.Uint64()
        k := new(big.Int)
        count := 0
    inner:
        for j := big.NewInt(3); ; j.Add(j, one) {
            k.Exp(j, i, nil)
            k.Mul(i, k)
            ix := strings.Index(k.String(), rd[ii-2])
            if ix >= 0 {
                count++
                fmt.Printf(""%d "", j)
                if count == 10 {
                    fmt.Printf(""\nfound in %d ms\n\n"", time.Since(start).Milliseconds())
                    break inner
                }
            }
        }
    }
}",905,35
9234,http://rosettacode.org/wiki/Superellipse,Superellipse,"A superellipse is a geometric figure defined as the set of all points (x, y) with



 





|


x
a


|


n



+


|


y
b


|


n



=
1
,


{\displaystyle \left|{\frac {x}{a}}\right|^{n}\!+\left|{\frac {y}{b}}\right|^{n}\!=1,}




where n, a, and b are positive numbers.



Task
Draw a superellipse with n = 2.5, and a = b = 200



",#Go,Go,"package main
 
import (
    ""github.com/fogleman/gg""
    ""math""
)
 
/* assumes a and b are always equal */
func superEllipse(dc *gg.Context, n float64, a int) {
    hw := float64(dc.Width() / 2)
    hh := float64(dc.Height() / 2)
 
    // calculate y for each x
    y := make([]float64, a+1)
    for x := 0; x <= a; x++ {
        aa := math.Pow(float64(a), n)
        xx := math.Pow(float64(x), n)
        y[x] = math.Pow(aa-xx, 1.0/n)
    }
 
    // draw quadrants
    for x := a; x >= 0; x-- {
        dc.LineTo(hw+float64(x), hh-y[x])
    }
    for x := 0; x <= a; x++ {
        dc.LineTo(hw+float64(x), hh+y[x])
    }
    for x := a; x >= 0; x-- {
        dc.LineTo(hw-float64(x), hh+y[x])
    }
    for x := 0; x <= a; x++ {
        dc.LineTo(hw-float64(x), hh-y[x])
    }
 
    dc.SetRGB(1, 1, 1) // white ellipse
    dc.Fill()
}
 
func main() {
    dc := gg.NewContext(500, 500)
    dc.SetRGB(0, 0, 0) // black background
    dc.Clear()
    superEllipse(dc, 2.5, 200)
    dc.SavePNG(""superellipse.png"")
}",1011,45
9259,http://rosettacode.org/wiki/Synchronous_concurrency,Synchronous concurrency,"The goal of this task is to create two concurrent activities (""Threads"" or ""Tasks"", not processes.) that share data synchronously. Your language may provide syntax or libraries to perform concurrency. Different languages provide different implementations of concurrency, often with different names. Some languages use the term threads, others use the term tasks, while others use co-processes. This task should not be implemented using fork, spawn, or the Linux/UNIX/Win32 pipe command, as communication should be between threads, not processes.

One of the concurrent units will read from a file named ""input.txt"" and send the contents of that file, one line at a time, to the other concurrent unit, which will print the line it receives to standard output. The printing unit must count the number of lines it prints. After the concurrent unit reading the file sends its last line to the printing unit, the reading unit will request the number of lines printed by the printing unit. The reading unit will then print the number of lines printed by the printing unit.

This task requires two-way communication between the concurrent units. All concurrent units must cleanly terminate at the end of the program.
",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""log""
    ""os""
)
 
func main() {
    lines := make(chan string)
    count := make(chan int)
    go func() {
        c := 0
        for l := range lines {
            fmt.Println(l)
            c++
        }
        count <- c
    }()
 
    f, err := os.Open(""input.txt"")
    if err != nil {
        log.Fatal(err)
    }
    for s := bufio.NewScanner(f); s.Scan(); {
        lines <- s.Text()
    }
    f.Close()
    close(lines)
    fmt.Println(""Number of lines:"", <-count)
}",525,32
9308,http://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping,Sutherland-Hodgman polygon clipping,"The   Sutherland-Hodgman clipping algorithm   finds the polygon that is the intersection between an arbitrary polygon (the “subject polygon”) and a convex polygon (the “clip polygon”).

It is used in computer graphics (especially 2D graphics) to reduce the complexity of a scene being displayed by eliminating parts of a polygon that do not need to be displayed.



Task

Take the closed polygon defined by the points:

 



[
(
50
,
150
)
,
(
200
,
50
)
,
(
350
,
150
)
,
(
350
,
300
)
,
(
250
,
300
)
,
(
200
,
250
)
,
(
150
,
350
)
,
(
100
,
250
)
,
(
100
,
200
)
]


{\displaystyle [(50,150),(200,50),(350,150),(350,300),(250,300),(200,250),(150,350),(100,250),(100,200)]}


and clip it by the rectangle defined by the points:

 



[
(
100
,
100
)
,
(
300
,
100
)
,
(
300
,
300
)
,
(
100
,
300
)
]


{\displaystyle [(100,100),(300,100),(300,300),(100,300)]}


Print the sequence of points that define the resulting clipped polygon.



Extra credit

Display all three polygons on a graphical surface, using a different color for each polygon and filling the resulting polygon.

(When displaying you may use either a north-west or a south-west origin, whichever is more convenient for your display mechanism.)



",#Go,Go,"package main
 
import ""fmt""
 
type point struct {
    x, y float32
}
 
var subjectPolygon = []point{{50, 150}, {200, 50}, {350, 150}, {350, 300},
    {250, 300}, {200, 250}, {150, 350}, {100, 250}, {100, 200}}
 
var clipPolygon = []point{{100, 100}, {300, 100}, {300, 300}, {100, 300}}
 
func main() {
    var cp1, cp2, s, e point
    inside := func(p point) bool {
        return (cp2.x-cp1.x)*(p.y-cp1.y) > (cp2.y-cp1.y)*(p.x-cp1.x)
    }
    intersection := func() (p point) {
        dcx, dcy := cp1.x-cp2.x, cp1.y-cp2.y
        dpx, dpy := s.x-e.x, s.y-e.y
        n1 := cp1.x*cp2.y - cp1.y*cp2.x
        n2 := s.x*e.y - s.y*e.x
        n3 := 1 / (dcx*dpy - dcy*dpx)
        p.x = (n1*dpx - n2*dcx) * n3
        p.y = (n1*dpy - n2*dcy) * n3
        return
    }
    outputList := subjectPolygon
    cp1 = clipPolygon[len(clipPolygon)-1]
    for _, cp2 = range clipPolygon { // WP clipEdge is cp1,cp2 here
        inputList := outputList
        outputList = nil
        s = inputList[len(inputList)-1]
        for _, e = range inputList {
            if inside(e) {
                if !inside(s) {
                    outputList = append(outputList, intersection())
                }
                outputList = append(outputList, e)
            } else if inside(s) {
                outputList = append(outputList, intersection())
            }
            s = e
        }
        cp1 = cp2
    }
    fmt.Println(outputList)
}",1433,49
9347,http://rosettacode.org/wiki/Take_notes_on_the_command_line,Take notes on the command line,"Take notes on the command line is part of Short Circuit's Console Program Basics selection.
Invoking NOTES without commandline arguments displays the current contents of the local NOTES.TXT if it exists.
If NOTES has arguments, the current date and time are appended to the local NOTES.TXT followed by a newline.
Then all the arguments, joined with spaces, prepended with a tab, and appended with a trailing newline, are written to NOTES.TXT.
If NOTES.TXT doesn't already exist in the current directory then a new NOTES.TXT file should be created.
",#Go,Go,"package main
 
import (
	""fmt""
	""io""
	""os""
	""strings""
	""time""
)
 
func addNote(fn string, note string) error {
	f, err := os.OpenFile(fn, os.O_RDWR|os.O_APPEND|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	_, err = fmt.Fprint(f, time.Now().Format(time.RFC1123), ""\n\t"", note, ""\n"")
	// To be extra careful with errors from Close():
	if cErr := f.Close(); err == nil {
		err = cErr
	}
	return err
}
 
func showNotes(w io.Writer, fn string) error {
	f, err := os.Open(fn)
	if err != nil {
		if os.IsNotExist(err) {
			return nil // don't report ""no such file""
		}
		return err
	}
	_, err = io.Copy(w, f)
	f.Close()
	return err
}
 
func main() {
	const fn = ""NOTES.TXT""
	var err error
	if len(os.Args) > 1 {
		err = addNote(fn, strings.Join(os.Args[1:], "" ""))
	} else {
		err = showNotes(os.Stdout, fn)
	}
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}",875,49
9394,http://rosettacode.org/wiki/Summarize_primes,Summarize primes,"Task

Considering in order of length, n, all sequences of consecutive
primes, p, from 2 onwards, where p < 1000 and n>0, select those
sequences whose sum is prime, and for these display the length of the
sequence, the last item in the sequence, and the sum.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""rcu""
)
 
func main() {
    primes := rcu.Primes(999)
    sum, n, c := 0, 0, 0
    fmt.Println(""Summing the first n primes (<1,000) where the sum is itself prime:"")
    fmt.Println(""  n  cumulative sum"")
    for _, p := range primes {
        n++
        sum += p
        if rcu.IsPrime(sum) {
            c++
            fmt.Printf(""%3d   %6s\n"", n, rcu.Commatize(sum))
        }
    }
    fmt.Println()
    fmt.Println(c, ""such prime sums found"")
}",488,23
9614,http://rosettacode.org/wiki/Summarize_and_say_sequence,Summarize and say sequence,"There are several ways to generate a self-referential sequence. One very common one (the Look-and-say sequence) is to start with a positive integer, then generate the next term by concatenating enumerated groups of adjacent alike digits:

       0, 10, 1110, 3110, 132110, 1113122110, 311311222110 ...

The terms generated grow in length geometrically and never converge.

Another way to generate a self-referential sequence is to summarize the previous term.

Count how many of each alike digit there is, then concatenate the sum and digit for each of the sorted enumerated digits. Note that the first five terms are the same as for the previous sequence.

       0, 10, 1110, 3110, 132110, 13123110, 23124110 ... 

Sort the digits largest to smallest. Do not include counts of digits that do not appear in the previous term.

Depending on the seed value, series generated this way always either converge to a stable value or to a short cyclical pattern. (For our purposes, I'll use converge to mean an element matches a previously seen element.) The sequence shown, with a seed value of 0, converges to a stable value of 1433223110 after 11 iterations. The seed value that converges most quickly is 22. It goes stable after the first element. (The next element is 22, which has been seen before.)



Task

Find all the positive integer seed values under 1000000, for the above convergent self-referential sequence, that takes the largest number of iterations before converging. Then print out the number of iterations and the sequence they return. Note that different permutations of the digits of the seed will yield the same sequence. For this task, assume leading zeros are not permitted.

Seed Value(s): 9009 9090 9900

Iterations: 21 

Sequence: (same for all three seeds except for first element)
9009
2920
192210
19222110
19323110
1923123110
1923224110
191413323110
191433125110
19151423125110
19251413226110
1916151413325110
1916251423127110
191716151413326110
191726151423128110
19181716151413327110
19182716151423129110
29181716151413328110
19281716151423228110
19281716151413427110
19182716152413228110

Related tasks

   Fours is the number of letters in the ...
   Look-and-say sequence
   Number names
   Self-describing numbers
   Spelling of ordinal numbers



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




Also see

   The On-Line Encyclopedia of Integer Sequences.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
func main() {
    var maxLen int
    var seqMaxLen [][]string
    for n := 1; n < 1e6; n++ {
        switch s := seq(n); {
        case len(s) == maxLen:
            seqMaxLen = append(seqMaxLen, s)
        case len(s) > maxLen:
            maxLen = len(s)
            seqMaxLen = [][]string{s}
        }
    }
    fmt.Println(""Max sequence length:"", maxLen)
    fmt.Println(""Sequences:"", len(seqMaxLen))
    for _, seq := range seqMaxLen {
        fmt.Println(""Sequence:"")
        for _, t := range seq {
            fmt.Println(t)
        }
    }
}
 
func seq(n int) []string {
    s := strconv.Itoa(n)
    ss := []string{s}
 
    for {
        dSeq := sortD(s)
        d := dSeq[0]
        nd := 1
        s = """"
        for i := 1; ; i++ {
            if i == len(dSeq) {
                s = fmt.Sprintf(""%s%d%c"", s, nd, d)
                break
            }
            if dSeq[i] == d {
                nd++
            } else {
                s = fmt.Sprintf(""%s%d%c"", s, nd, d)
                d = dSeq[i]
                nd = 1
            }
        }
        for _, s0 := range ss {
            if s == s0 {
                return ss
            }
        }
        ss = append(ss, s)
    }
    panic(""unreachable"")
}
 
func sortD(s string) []rune {
    r := make([]rune, len(s))
    for i, d := range s {
        j := 0
        for ; j < i; j++ {
            if d > r[j] {
                copy(r[j+1:], r[j:i])
                break
            }
        }
        r[j] = d
    }
    return r
}",1559,75
9633,http://rosettacode.org/wiki/Symmetric_difference,Symmetric difference,"Task
Given two sets A and B, compute 



(
A
∖
B
)
∪
(
B
∖
A
)
.


{\displaystyle (A\setminus B)\cup (B\setminus A).}



That is, enumerate the items that are in A or B but not both. This set is called the symmetric difference of A and B.

In other words: 



(
A
∪
B
)
∖
(
A
∩
B
)


{\displaystyle (A\cup B)\setminus (A\cap B)}

 (the set of items that are in at least one of A or B minus the set of items that are in both A and B).

Optionally, give the individual differences (



A
∖
B


{\displaystyle A\setminus B}

 and 



B
∖
A


{\displaystyle B\setminus A}

) as well.



Test cases
A = {John, Bob, Mary, Serena}
B = {Jim, Mary, John, Bob}



Notes
 If your code uses lists of items to represent sets then ensure duplicate items in lists are correctly handled. For example two lists representing sets of a = [""John"", ""Serena"", ""Bob"", ""Mary"", ""Serena""] and b = [""Jim"", ""Mary"", ""John"", ""Jim"", ""Bob""] should produce the result of just two strings: [""Serena"", ""Jim""], in any order.
 In the mathematical notation above A \ B gives the set of items in A that are not in B; A ∪ B gives the set of items in both A and B, (their union); and A ∩ B gives the set of items that are in both A and B (their intersection).

",#Go,Go,"package main
 
import ""fmt""
 
var a = map[string]bool{""John"": true, ""Bob"": true, ""Mary"": true, ""Serena"": true}
var b = map[string]bool{""Jim"": true, ""Mary"": true, ""John"": true, ""Bob"": true}
 
func main() {
    sd := make(map[string]bool)
    for e := range a {
        if !b[e] {
            sd[e] = true
        }
    }
    for e := range b {
        if !a[e] {
            sd[e] = true
        }
    }
    fmt.Println(sd)
}",424,21
9701,http://rosettacode.org/wiki/Temperature_conversion,Temperature conversion,"There are quite a number of temperature scales. For this task we will concentrate on four of the perhaps best-known ones:
Kelvin, Celsius, Fahrenheit, and Rankine.

The Celsius and Kelvin scales have the same magnitude, but different null points.

 0 degrees Celsius corresponds to 273.15 kelvin.
 0 kelvin is absolute zero.
The Fahrenheit and Rankine scales also have the same magnitude, but different null points.

 0 degrees Fahrenheit corresponds to 459.67 degrees Rankine.
 0 degrees Rankine is absolute zero.
The Celsius/Kelvin and Fahrenheit/Rankine scales have a ratio of 5 : 9.



Task
Write code that accepts a value of kelvin, converts it to values of the three other scales, and prints the result.



Example

K  21.00

C  -252.15

F  -421.87

R  37.80


",#Go,Go,"package main
 
import (
    ""fmt""
    ""os""
    ""strconv""
)
 
func main() {
    if len(os.Args) != 2 {
        fmt.Println(""Usage: k <Kelvin>"")
        return
    }
    k, err := strconv.ParseFloat(os.Args[1], 64)
    if err != nil {
        fmt.Println(err)
        return
    }
    if k < 0 {
        fmt.Println(""Kelvin must be >= 0."")
        return
    }
    fmt.Printf(""K  %.2f\n"", k)
    fmt.Printf(""C  %.2f\n"", k-273.15)
    fmt.Printf(""F  %.2f\n"", k*9/5-459.67)
    fmt.Printf(""R  %.2f\n"", k*9/5)
}",506,27
9775,http://rosettacode.org/wiki/System_time,System time,"Task

Output the system time   (any units will do as long as they are noted) either by a system command or one built into the language.

The system time can be used for debugging, network information, random number seeds, or something as simple as program performance.



Related task

   Date format


See also

   Retrieving system time (wiki)

",#Go,Go,"package main
 
import ""time""
import ""fmt""
 
func main() {
    t := time.Now()
    fmt.Println(t)                                    // default format
    fmt.Println(t.Format(""Mon Jan  2 15:04:05 2006"")) // some custom format
}",227,10
9939,http://rosettacode.org/wiki/Sum_of_elements_below_main_diagonal_of_matrix,Sum of elements below main diagonal of matrix,"Task

Find and display the sum of elements that are below the main diagonal of a matrix.

The matrix should be a square matrix.



 ───   Matrix to be used:   ───


     [[1,3,7,8,10],
      [2,4,16,14,4],
      [3,1,9,18,11],
      [12,14,17,18,20],
      [7,1,3,9,5]] 


",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
)
 
func main() {
    m := [][]int{
        {1, 3, 7, 8, 10},
        {2, 4, 16, 14, 4},
        {3, 1, 9, 18, 11},
        {12, 14, 17, 18, 20},
        {7, 1, 3, 9, 5},
    }
    if len(m) != len(m[0]) {
        log.Fatal(""Matrix must be square."")
    }
    sum := 0
    for i := 1; i < len(m); i++ {
        for j := 0; j < i; j++ {
            sum = sum + m[i][j]
        }
    }
    fmt.Println(""Sum of elements below main diagonal is"", sum)
}",492,26
9980,http://rosettacode.org/wiki/Sum_and_product_puzzle,Sum and product puzzle,"Task[edit]
Solve the ""Impossible Puzzle"":


X and Y are two different whole numbers greater than 1. Their sum is no greater than 100, and Y is greater than X. S and P are two mathematicians (and consequently perfect logicians); S knows the sum X+Y and P knows the product X*Y. Both S and P know all the information in this paragraph.
The following conversation occurs:

 S says ""P does not know X and Y.""
 P says ""Now I know X and Y.""
 S says ""Now I also know X and Y!""
What are X and Y?


Guidance
It can be hard to wrap one's head around what the three lines of dialog between S (the ""sum guy"") and P (the ""product guy"") convey about the values of X and Y.

So for your convenience, here's a break-down:





 Quote

 Implied fact


 1)

 S says ""P does not know X and Y.""

 For every possible sum decomposition of the number X+Y, the product has in turn more than one product decomposition.


 2)

 P says ""Now I know X and Y.""

 The number X*Y has only one product decomposition for which fact 1 is true.


 3)

 S says ""Now I also know X and Y.""

 The number X+Y has only one sum decomposition for which fact 2 is true.

Terminology:

 ""sum decomposition"" of a number = Any pair of positive integers (A, B) so that A+B equals the number. Here, with the additional constraint 2 ≤ A < B.
 ""product decomposition"" of a number = Any pair of positive integers (A, B) so that A*B equals the number. Here, with the additional constraint 2 ≤ A < B.


Your program can solve the puzzle by considering all possible pairs (X, Y) in the range 2 ≤ X < Y ≤ 98, and then successively eliminating candidates based on the three facts. It turns out only one solution remains!

See the Python example for an implementation that uses this approach with a few optimizations.

See also
   Wikipedia:   Sum and Product Puzzle
",#Go,Go,"package main
 
import ""fmt""
 
type pair struct{ x, y int }
 
func main() {
	//const max = 100
	// Use 1685 (the highest with a unique answer) instead
	// of 100 just to make it work a little harder :).
	const max = 1685
	var all []pair
	for a := 2; a < max; a++ {
		for b := a + 1; b < max-a; b++ {
			all = append(all, pair{a, b})
		}
	}
	fmt.Println(""There are"", len(all), ""pairs where a+b <"", max, ""(and a<b)"")
	products := countProducts(all)
 
	// Those for which no sum decomposition has unique product to are
	// S mathimatician's possible pairs.
	var sPairs []pair
pairs:
	for _, p := range all {
		s := p.x + p.y
		// foreach a+b=s (a<b)
		for a := 2; a < s/2+s&1; a++ {
			b := s - a
			if products[a*b] == 1 {
				// Excluded because P would have a unique product
				continue pairs
			}
		}
		sPairs = append(sPairs, p)
	}
	fmt.Println(""S starts with"", len(sPairs), ""possible pairs."")
	//fmt.Println(""S pairs:"", sPairs)
	sProducts := countProducts(sPairs)
 
	// Look in sPairs for those with a unique product to get
	// P mathimatician's possible pairs.
	var pPairs []pair
	for _, p := range sPairs {
		if sProducts[p.x*p.y] == 1 {
			pPairs = append(pPairs, p)
		}
	}
	fmt.Println(""P then has"", len(pPairs), ""possible pairs."")
	//fmt.Println(""P pairs:"", pPairs)
	pSums := countSums(pPairs)
 
	// Finally, look in pPairs for those with a unique sum
	var final []pair
	for _, p := range pPairs {
		if pSums[p.x+p.y] == 1 {
			final = append(final, p)
		}
	}
 
	// Nicely show any answers.
	switch len(final) {
	case 1:
		fmt.Println(""Answer:"", final[0].x, ""and"", final[0].y)
	case 0:
		fmt.Println(""No possible answer."")
	default:
		fmt.Println(len(final), ""possible answers:"", final)
	}
}
 
func countProducts(list []pair) map[int]int {
	m := make(map[int]int)
	for _, p := range list {
		m[p.x*p.y]++
	}
	return m
}
 
func countSums(list []pair) map[int]int {
	m := make(map[int]int)
	for _, p := range list {
		m[p.x+p.y]++
	}
	return m
}
 
// not used, manually inlined above
func decomposeSum(s int) []pair {
	pairs := make([]pair, 0, s/2)
	for a := 2; a < s/2+s&1; a++ {
		pairs = append(pairs, pair{a, s - a})
	}
	return pairs
}",2145,95
10047,http://rosettacode.org/wiki/Suffixation_of_decimal_numbers,Suffixation of decimal numbers,"Suffixation:   a letter or a group of letters added to the end of a word to change its meaning.

       ─────   or, as used herein   ─────
Suffixation:   the addition of a metric or ""binary"" metric suffix to a number, with/without rounding.



Task

Write a function(s) to append (if possible)   a metric   or   a ""binary"" metric   suffix to a
number   (displayed in decimal).

The number may be rounded   (as per user specification)   (via shortening of the number when the number of
digits past the decimal point are to be used).



Task requirements

   write a function (or functions) to add   (if possible)   a suffix to a number
   the function(s) should be able to express the number (possibly with a suffix) in as many decimal digits as specified
   the sign should be preserved   (if present)
   the number may have commas within the number   (the commas need not be preserved)
   the number may have a decimal point and/or an exponent as in:   -123.7e-01
   the suffix that might be appended should be in uppercase;   however, the   i   should be in lowercase
   support:
   the            metric suffixes:   K  M  G  T  P  E  Z  Y  X  W  V  U
   the binary metric suffixes:   Ki Mi Gi Ti Pi Ei Zi Yi Xi Wi Vi Ui
   the (full name) suffix:   googol   (lowercase)   (equal to 1e100)     (optional)
   a number of decimal digits past the decimal point   (with rounding).   The default is to display all significant digits
   validation of the (supplied/specified) arguments is optional but recommended
   display   (with identifying text):
   the original number   (with identifying text)
   the number of digits past the decimal point being used   (or none, if not specified)
   the type of suffix being used   (metric or ""binary"" metric)
   the (new) number with the appropriate   (if any)   suffix
   all output here on this page


Metric suffixes to be supported   (whether or not they're officially sanctioned)

     K     multiply the number by  10^3              kilo      (1,000)
     M     multiply the number by  10^6              mega      (1,000,000)
     G     multiply the number by  10^9              giga      (1,000,000,000)
     T     multiply the number by  10^12             tera      (1,000,000,000,000)
     P     multiply the number by  10^15             peta      (1,000,000,000,000,000)
     E     multiply the number by  10^18             exa       (1,000,000,000,000,000,000)
     Z     multiply the number by  10^21             zetta     (1,000,000,000,000,000,000,000)
     Y     multiply the number by  10^24             yotta     (1,000,000,000,000,000,000,000,000)
     X     multiply the number by  10^27             xenta     (1,000,000,000,000,000,000,000,000,000)
     W     multiply the number by  10^30             wekta     (1,000,000,000,000,000,000,000,000,000,000)
     V     multiply the number by  10^33             vendeka   (1,000,000,000,000,000,000,000,000,000,000,000)
     U     multiply the number by  10^36             udekta    (1,000,000,000,000,000,000,000,000,000,000,000,000)



""Binary"" suffixes to be supported   (whether or not they're officially sanctioned)

     Ki    multiply the number by  2^10              kibi      (1,024)
     Mi    multiply the number by  2^20              mebi      (1,048,576)
     Gi    multiply the number by  2^30              gibi      (1,073,741,824)
     Ti    multiply the number by  2^40              tebi      (1,099,571,627,776)
     Pi    multiply the number by  2^50              pebi      (1,125,899,906,884,629)
     Ei    multiply the number by  2^60              exbi      (1,152,921,504,606,846,976)
     Zi    multiply the number by  2^70              zebi      (1,180,591,620,717,411,303,424)
     Yi    multiply the number by  2^80              yobi      (1,208,925,819,614,629,174,706,176)
     Xi    multiply the number by  2^90              xebi      (1,237,940,039,285,380,274,899,124,224)
     Wi    multiply the number by  2^100             webi      (1,267,650,600,228,229,401,496,703,205,376)
     Vi    multiply the number by  2^110             vebi      (1,298,074,214,633,706,907,132,624,082,305,024)
     Ui    multiply the number by  2^120             uebi      (1,329,227,995,784,915,872,903,807,060,280,344,576)



For instance, with this pseudo─code

                                 /* 1st arg: the number to be transformed.*/
                                 /* 2nd arg: # digits past the dec. point.*/
                                 /* 3rd arg: the type of suffix to use.   */
                                 /*         2   indicates ""binary"" suffix.*/
                                 /*        10   indicates  decimal suffix.*/
     a = '456,789,100,000,000'   /* ""A""  has  eight  trailing zeros.      */
     say ' aa=' suffize(a)       /* Display a suffized number to terminal.*/
                                 /* The  ""1""   below shows one decimal ···*/
                                 /*         digit past the decimal point. */
     n = suffize(a, 1)           /* SUFFIZE  is the function name.        */
     n = suffize(a, 1, 10)       /* (identical to the above statement.)   */
     say '  n=' n                /* Display value of  N  to terminal.     */
                                 /* Note the rounding that occurs.        */
     f = suffize(a, 1,  2)       /* SUFFIZE  with one fractional digit    */
     say '  f=' f                /* Display value of  F  to terminal.     */
                                 /* Display value in ""binary"" metric.     */
     bin = suffize(a, 5, 2)      /* SUFFIZE with binary metric suffix.    */
     say 'bin=' bin              /* Display value of  BIN  to terminal.   */
     win = suffize(a, 0, 2)      /* SUFFIZE with binary metric suffix.    */
     say 'win=' win              /* Display value of  WIN  to terminal.   */
     xvi = ' +16777216 '         /* this used to be a big computer ···    */
     big = suffize(xvi, , 2)     /* SUFFIZE with binary metric suffix.    */
     say 'big=' big              /* Display value of  BIG  to terminal.   */

would display:

      aa= 456.7891T
       n= 456.8T
       f= 415.4Ti
     bin= 415.44727Ti
     win= 415Ti
     big= 16Mi



Use these test cases

               87,654,321
              -998,877,665,544,332,211,000      3
              +112,233                          0
               16,777,216                       1
               456,789,100,000,000              2
               456,789,100,000,000              2      10
               456,789,100,000,000              5       2
               456,789,100,000.000e+00          0      10
              +16777216                         ,       2
               1.2e101
               (your primary disk free space)   1                  ◄■■■■■■■ optional



Use whatever parameterizing your computer language supports,   and it's permitted to create as many
separate functions as are needed   (if needed)   if   function arguments aren't allowed to
be omitted or varied.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""strconv""
    ""strings""
)
 
var suffixes = "" KMGTPEZYXWVU""
var ggl = googol()
 
func googol() *big.Float {
    g1 := new(big.Float).SetPrec(500)
    g1.SetInt64(10000000000)
    g := new(big.Float)
    g.Set(g1)
    for i := 2; i <= 10; i++ {
        g.Mul(g, g1)
    }
    return g
}
 
func suffize(arg string) {
    fields := strings.Fields(arg)
    a := fields[0]
    if a == """" {
        a = ""0""
    }
    var places, base int
    var frac, radix string
    switch len(fields) {
    case 1:
        places = -1
        base = 10
    case 2:
        places, _ = strconv.Atoi(fields[1])
        base = 10
        frac = strconv.Itoa(places)
    case 3:
        if fields[1] == "","" {
            places = 0
            frac = "",""
        } else {
            places, _ = strconv.Atoi(fields[1])
            frac = strconv.Itoa(places)
        }
        base, _ = strconv.Atoi(fields[2])
        if base != 2 && base != 10 {
            base = 10
        }
        radix = strconv.Itoa(base)
    }
    a = strings.Replace(a, "","", """", -1) // get rid of any commas
    sign := """"
    if a[0] == '+' || a[0] == '-' {
        sign = string(a[0])
        a = a[1:] // remove any sign after storing it
    }
    b := new(big.Float).SetPrec(500)
    d := new(big.Float).SetPrec(500)
    b.SetString(a)
    g := false
    if b.Cmp(ggl) >= 0 {
        g = true
    }
    if !g && base == 2 {
        d.SetUint64(1024)
    } else if !g && base == 10 {
        d.SetUint64(1000)
    } else {
        d.Set(ggl)
    }
    c := 0
    for b.Cmp(d) >= 0 && c < 12 { // allow b >= 1K if c would otherwise exceed 12
        b.Quo(b, d)
        c++
    }
    var suffix string
    if !g {
        suffix = string(suffixes[c])
    } else {
        suffix = ""googol""
    }
    if base == 2 {
        suffix += ""i""
    }
    fmt.Println(""   input number ="", fields[0])
    fmt.Println(""  fraction digs ="", frac)
    fmt.Println(""specified radix ="", radix)
    fmt.Print(""     new number = "")
    if places >= 0 {
        fmt.Printf(""%s%.*f%s\n"", sign, places, b, suffix)
    } else {
        fmt.Printf(""%s%s%s\n"", sign, b.Text('g', 50), suffix)
    }
    fmt.Println()
}
 
func main() {
    tests := []string{
        ""87,654,321"",
        ""-998,877,665,544,332,211,000      3"",
        ""+112,233                          0"",
        ""16,777,216                        1"",
        ""456,789,100,000,000"",
        ""456,789,100,000,000               2      10"",
        ""456,789,100,000,000               5       2"",
        ""456,789,100,000.000e+00           0      10"",
        ""+16777216                         ,       2"",
        ""1.2e101"",
        ""446,835,273,728                   1"",
        ""1e36"",
        ""1e39"", // there isn't a big enough suffix for this one but it's less than googol
    }
    for _, test := range tests {
        suffize(test)
    }
}",2897,119
10276,http://rosettacode.org/wiki/Substitution_cipher,Substitution cipher,"Substitution Cipher Implementation - File Encryption/Decryption



Task

Encrypt a input/source file by replacing every upper/lower case alphabets of the source file with another predetermined upper/lower case alphabets or symbols and save it into another output/encrypted file and then again convert that output/encrypted file into original/decrypted file.

This type of Encryption/Decryption scheme is often called a Substitution Cipher.



Related tasks

 Caesar cipher
 Rot-13
 Vigenère Cipher/Cryptanalysis


See also

 Wikipedia: Substitution cipher

",#Go,Go,"package main
 
import (    
    ""fmt""
    ""strings""
)
 
var key = ""]kYV}(!7P$n5_0i R:?jOWtF/=-pe'AD&@r6%ZXs\""v*N[#wSl9zq2^+g;LoB`aGh{3.HIu4fbK)mU8|dMET><,Qc\\C1yxJ""
 
func encode(s string) string {
    bs := []byte(s)
    for i := 0; i < len(bs); i++ {
        bs[i] = key[int(bs[i]) - 32]
    }
    return string(bs)
}
 
func decode(s string) string {
    bs := []byte(s)
    for i := 0; i < len(bs); i++ {
        bs[i] = byte(strings.IndexByte(key, bs[i]) + 32)
    }
    return string(bs)
}
 
func main() {
    s := ""The quick brown fox jumps over the lazy dog, who barks VERY loudly!""
    enc := encode(s)
    fmt.Println(""Encoded: "", enc)
    fmt.Println(""Decoded: "", decode(enc))
}",688,31
10306,http://rosettacode.org/wiki/Sum_to_100,Sum to 100,"Task

Find solutions to the    sum to one hundred    puzzle.



Add (insert) the mathematical
operators      +    or    -      (plus
or minus)   before any of the digits in the

decimal numeric string    123456789    such that the
resulting mathematical expression adds up to a

particular sum   (in this iconic case,   100).



Example:

             123 + 4 - 5 + 67 - 89   =   100     

Show all output here.



   Show all solutions that sum to    100 
   Show the sum that has the maximum   number   of solutions   (from zero to infinity‡)
   Show the lowest positive sum that   can't   be expressed   (has no solutions),   using the rules for this task
   Show the ten highest numbers that can be expressed using the rules for this task   (extra credit)


‡   (where   infinity   would be a relatively small   123,456,789)



An example of a sum that can't be expressed   (within the rules of this task)   is:   5074

(which,   of course,   isn't the lowest positive sum that can't be expressed).



",#Go,Go,"package main
 
import (
	""fmt""
	""sort""
)
 
const pow3_8 = 3 * 3 * 3 * 3 * 3 * 3 * 3 * 3 // 3^8
const pow3_9 = 3 * pow3_8                    // 3^9
const maxExprs = 2 * pow3_8                  // not 3^9 since first op can't be Join
 
type op uint8
 
const (
	Add  op = iota // insert a ""+""
	Sub            //     or a ""-""
	Join           //     or just join together
)
 
// code is an encoding of [9]op, the nine ""operations""
// we do on each each digit. The op for 1 is in
// the highest bits, the op for 9 in the lowest.
type code uint16
 
// evaluate 123456789 with + - or """" prepended to each as indicated by `c`.
func (c code) evaluate() (sum int) {
	num, pow := 0, 1
	for k := 9; k >= 1; k-- {
		num += pow * k
		switch op(c % 3) {
		case Add:
			sum += num
			num, pow = 0, 1
		case Sub:
			sum -= num
			num, pow = 0, 1
		case Join:
			pow *= 10
		}
		c /= 3
	}
	return sum
}
 
func (c code) String() string {
	buf := make([]byte, 0, 18)
	a, b := code(pow3_9), code(pow3_8)
	for k := 1; k <= 9; k++ {
		switch op((c % a) / b) {
		case Add:
			if k > 1 {
				buf = append(buf, '+')
			}
		case Sub:
			buf = append(buf, '-')
		}
		buf = append(buf, '0'+byte(k))
		a, b = b, b/3
	}
	return string(buf)
}
 
type sumCode struct {
	sum  int
	code code
}
type sumCodes []sumCode
 
type sumCount struct {
	sum   int
	count int
}
type sumCounts []sumCount
 
// For sorting (could also use sort.Slice with just Less).
func (p sumCodes) Len() int            { return len(p) }
func (p sumCodes) Swap(i, j int)       { p[i], p[j] = p[j], p[i] }
func (p sumCodes) Less(i, j int) bool  { return p[i].sum < p[j].sum }
func (p sumCounts) Len() int           { return len(p) }
func (p sumCounts) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
func (p sumCounts) Less(i, j int) bool { return p[i].count > p[j].count }
 
// For printing.
func (sc sumCode) String() string {
	return fmt.Sprintf(""% 10d = %v"", sc.sum, sc.code)
}
func (sc sumCount) String() string {
	return fmt.Sprintf(""% 10d has %d solutions"", sc.sum, sc.count)
}
 
func main() {
	// Evaluate all expressions.
	expressions := make(sumCodes, 0, maxExprs/2)
	counts := make(sumCounts, 0, 1715)
	for c := code(0); c < maxExprs; c++ {
		// All negative sums are exactly like their positive
		// counterpart with all +/- switched, we don't need to
		// keep track of them.
		sum := c.evaluate()
		if sum >= 0 {
			expressions = append(expressions, sumCode{sum, c})
		}
	}
	sort.Sort(expressions)
 
	// Count all unique sums
	sc := sumCount{expressions[0].sum, 1}
	for _, e := range expressions[1:] {
		if e.sum == sc.sum {
			sc.count++
		} else {
			counts = append(counts, sc)
			sc = sumCount{e.sum, 1}
		}
	}
	counts = append(counts, sc)
	sort.Sort(counts)
 
	// Extract required results
 
	fmt.Println(""All solutions that sum to 100:"")
	i := sort.Search(len(expressions), func(i int) bool {
		return expressions[i].sum >= 100
	})
	for _, e := range expressions[i:] {
		if e.sum != 100 {
			break
		}
		fmt.Println(e)
	}
 
	fmt.Println(""\nThe positive sum with maximum number of solutions:"")
	fmt.Println(counts[0])
 
	fmt.Println(""\nThe lowest positive number that can't be expressed:"")
	s := 1
	for _, e := range expressions {
		if e.sum == s {
			s++
		} else if e.sum > s {
			fmt.Printf(""% 10d\n"", s)
			break
		}
	}
 
	fmt.Println(""\nThe ten highest numbers that can be expressed:"")
	for _, e := range expressions[len(expressions)-10:] {
		fmt.Println(e)
	}
}",3420,150
10470,http://rosettacode.org/wiki/Successive_prime_differences,Successive prime differences,"The series of increasing prime numbers begins: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, ...

The task applies a filter to the series returning groups of successive primes, (s'primes), that differ from the next by a given value or values.

Example 1: Specifying that the difference between s'primes be 2 leads to the groups:

(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), ...

(Known as Twin primes or Prime pairs)

Example 2: Specifying more than one difference between s'primes leads to groups of size one greater than the number of differences. Differences of 2, 4 leads to the groups:

(5, 7, 11), (11, 13, 17), (17, 19, 23), (41, 43, 47), .... 

In the first group 7 is two more than 5 and 11 is four more than 7; as well as 5, 7, and 11 being successive primes.
Differences are checked in the order of the values given, (differences of 4, 2 would give different groups entirely).

Task

 In each case use a list of primes less than 1_000_000
 For the following Differences show the first and last group, as well as the number of groups found:
 Differences of 2.
 Differences of 1.
 Differences of 2, 2.
 Differences of 2, 4.
 Differences of 4, 2.
 Differences of 6, 4, 2.
 Show output here.

Note: Generation of a list of primes is a secondary aspect of the task. Use of a built in function, well known library, or importing/use of prime generators from other Rosetta Code tasks is encouraged.

references
https://pdfs.semanticscholar.org/78a1/7349819304863ae061df88dbcb26b4908f03.pdf
https://www.primepuzzles.net/puzzles/puzz_011.htm
https://matheplanet.de/matheplanet/nuke/html/viewtopic.php?topic=232720&start=0",#Go,Go,"package main
 
import ""fmt""
 
func sieve(limit int) []int {
    primes := []int{2}
    c := make([]bool, limit+1) // composite = true
    // no need to process even numbers > 2
    p := 3
    for {
        p2 := p * p
        if p2 > limit {
            break
        }
        for i := p2; i <= limit; i += 2 * p {
            c[i] = true
        }
        for {
            p += 2
            if !c[p] {
                break
            }
        }
    }
    for i := 3; i <= limit; i += 2 {
        if !c[i] {
            primes = append(primes, i)
        }
    }
    return primes
}
 
func successivePrimes(primes, diffs []int) [][]int {
    var results [][]int
    dl := len(diffs)
outer:
    for i := 0; i < len(primes)-dl; i++ {
        group := make([]int, dl+1)
        group[0] = primes[i]
        for j := i; j < i+dl; j++ {
            if primes[j+1]-primes[j] != diffs[j-i] {
                group = nil
                continue outer
            }
            group[j-i+1] = primes[j+1]
        }
        results = append(results, group)
        group = nil
    }
    return results
}
 
func main() {
    primes := sieve(999999)
    diffsList := [][]int{{2}, {1}, {2, 2}, {2, 4}, {4, 2}, {6, 4, 2}}
    fmt.Println(""For primes less than 1,000,000:-\n"")
    for _, diffs := range diffsList {
        fmt.Println(""  For differences of"", diffs, ""->"")
        sp := successivePrimes(primes, diffs)
        if len(sp) == 0 {
            fmt.Println(""    No groups found"")
            continue
        }
        fmt.Println(""    First group   = "", sp[0])
        fmt.Println(""    Last group    = "", sp[len(sp)-1])
        fmt.Println(""    Number found  = "", len(sp))
        fmt.Println()
    }
}",1706,69
10473,http://rosettacode.org/wiki/Subtractive_generator,Subtractive generator,"A subtractive generator calculates a sequence of random numbers, where each number is congruent to the subtraction of two previous numbers from the sequence. 

The formula is

 




r

n


=

r

(
n
−
i
)


−

r

(
n
−
j
)




(
mod

m
)



{\displaystyle r_{n}=r_{(n-i)}-r_{(n-j)}{\pmod {m}}}


for some fixed values of 



i


{\displaystyle i}

, 



j


{\displaystyle j}

 and 



m


{\displaystyle m}

, all positive integers. Supposing that 



i
>
j


{\displaystyle i>j}

, then the state of this generator is the list of the previous numbers from 




r

n
−
i




{\displaystyle r_{n-i}}

 to 




r

n
−
1




{\displaystyle r_{n-1}}

. Many states generate uniform random integers from 



0


{\displaystyle 0}

 to 



m
−
1


{\displaystyle m-1}

, but some states are bad. A state, filled with zeros, generates only zeros. If 



m


{\displaystyle m}

 is even, then a state, filled with even numbers, generates only even numbers. More generally, if 



f


{\displaystyle f}

 is a factor of 



m


{\displaystyle m}

, then a state, filled with multiples of 



f


{\displaystyle f}

, generates only multiples of 



f


{\displaystyle f}

.

All subtractive generators have some weaknesses. The formula correlates 




r

n




{\displaystyle r_{n}}

, 




r

(
n
−
i
)




{\displaystyle r_{(n-i)}}

 and 




r

(
n
−
j
)




{\displaystyle r_{(n-j)}}

; these three numbers are not independent, as true random numbers would be. Anyone who observes 



i


{\displaystyle i}

 consecutive numbers can predict the next numbers, so the generator is not cryptographically secure. The authors of Freeciv (utility/rand.c) and xpat2 (src/testit2.c) knew another problem: the low bits are less random than the high bits.

The subtractive generator has a better reputation than the linear congruential generator, perhaps because it holds more state. A subtractive generator might never multiply numbers: this helps where multiplication is slow. A subtractive generator might also avoid division: the value of 




r

(
n
−
i
)


−

r

(
n
−
j
)




{\displaystyle r_{(n-i)}-r_{(n-j)}}

 is always between 



−
m


{\displaystyle -m}

 and 



m


{\displaystyle m}

, so a program only needs to add 



m


{\displaystyle m}

 to negative numbers.

The choice of 



i


{\displaystyle i}

 and 



j


{\displaystyle j}

 affects the period of the generator. A popular choice is 



i
=
55


{\displaystyle i=55}

 and 



j
=
24


{\displaystyle j=24}

, so the formula is

 




r

n


=

r

(
n
−
55
)


−

r

(
n
−
24
)




(
mod

m
)



{\displaystyle r_{n}=r_{(n-55)}-r_{(n-24)}{\pmod {m}}}


The subtractive generator from xpat2 uses

 




r

n


=

r

(
n
−
55
)


−

r

(
n
−
24
)




(
mod


10

9


)



{\displaystyle r_{n}=r_{(n-55)}-r_{(n-24)}{\pmod {10^{9}}}}


The implementation is by J. Bentley and comes from program_tools/universal.c of the DIMACS (netflow) archive at Rutgers University. It credits Knuth, TAOCP, Volume 2, Section 3.2.2 (Algorithm A).

Bentley uses this clever algorithm to seed the generator.

 Start with a single 



s
e
e
d


{\displaystyle seed}

 in range 



0


{\displaystyle 0}

 to 




10

9


−
1


{\displaystyle 10^{9}-1}

.
 Set 




s

0


=
s
e
e
d


{\displaystyle s_{0}=seed}

 and 




s

1


=
1


{\displaystyle s_{1}=1}

. The inclusion of 




s

1


=
1


{\displaystyle s_{1}=1}

 avoids some bad states (like all zeros, or all multiples of 10).
 Compute 




s

2


,

s

3


,
.
.
.
,

s

54




{\displaystyle s_{2},s_{3},...,s_{54}}

 using the subtractive formula 




s

n


=

s

(
n
−
2
)


−

s

(
n
−
1
)




(
mod


10

9


)



{\displaystyle s_{n}=s_{(n-2)}-s_{(n-1)}{\pmod {10^{9}}}}

.
 Reorder these 55 values so 




r

0


=

s

34




{\displaystyle r_{0}=s_{34}}

, 




r

1


=

s

13




{\displaystyle r_{1}=s_{13}}

, 




r

2


=

s

47




{\displaystyle r_{2}=s_{47}}

, ..., 




r

n


=

s

(
34
∗
(
n
+
1
)


(
mod

55
)

)




{\displaystyle r_{n}=s_{(34*(n+1){\pmod {55}})}}

.
 This is the same order as 




s

0


=

r

54




{\displaystyle s_{0}=r_{54}}

, 




s

1


=

r

33




{\displaystyle s_{1}=r_{33}}

, 




s

2


=

r

12




{\displaystyle s_{2}=r_{12}}

, ..., 




s

n


=

r

(
(
34
∗
n
)
−
1


(
mod

55
)

)




{\displaystyle s_{n}=r_{((34*n)-1{\pmod {55}})}}

.
 This rearrangement exploits how 34 and 55 are relatively prime.
 Compute the next 165 values 




r

55




{\displaystyle r_{55}}

 to 




r

219




{\displaystyle r_{219}}

. Store the last 55 values.
This generator yields the sequence 




r

220




{\displaystyle r_{220}}

, 




r

221




{\displaystyle r_{221}}

, 




r

222




{\displaystyle r_{222}}

 and so on. For example, if the seed is 292929, then the sequence begins with 




r

220


=
467478574


{\displaystyle r_{220}=467478574}

, 




r

221


=
512932792


{\displaystyle r_{221}=512932792}

, 




r

222


=
539453717


{\displaystyle r_{222}=539453717}

. By starting at 




r

220




{\displaystyle r_{220}}

, this generator avoids a bias from the first numbers of the sequence. This generator must store the last 55 numbers of the sequence, so to compute the next 




r

n




{\displaystyle r_{n}}

. Any array or list would work; a ring buffer is ideal but not necessary.

Implement a subtractive generator that replicates the sequences from xpat2.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""os""
)
 
// A fairly close port of the Bentley code, but parameterized to better
// conform to the algorithm description in the task, which didn't assume
// constants for i, j, m, and seed.  also parameterized here are k,
// the reordering factor, and s, the number of intial numbers to discard,
// as these are dependant on i.
func newSG(i, j, k, s, m, seed int) func() int {
    // check parameters for range and mutual consistency
    assert(i > 0, ""i must be > 0"")
    assert(j > 0, ""j must be > 0"")
    assert(i > j, ""i must be > j"")
    assert(k > 0, ""k must be > 0"")
    p, q := i, k
    if p < q {
        p, q = q, p
    }
    for q > 0 {
        p, q = q, p%q
    }
    assert(p == 1, ""k, i must be relatively prime"")
    assert(s >= i, ""s must be >= i"")
    assert(m > 0, ""m must be > 0"")
    assert(seed >= 0, ""seed must be >= 0"")
    // variables for closure f
    arr := make([]int, i)
    a := 0
    b := j
    // f is Bently RNG lprand
    f := func() int {
        if a == 0 {
            a = i
        }
        a--
        if b == 0 {
            b = i
        }
        b--
        t := arr[a] - arr[b]
        if t < 0 {
            t += m
        }
        arr[a] = t
        return t
    }
    // Bentley seed algorithm sprand
    last := seed
    arr[0] = last
    next := 1
    for i0 := 1; i0 < i; i0++ {
        ii := k * i0 % i
        arr[ii] = next
        next = last - next
        if next < 0 {
            next += m
        }
        last = arr[ii]
    }
    for i0 := i; i0 < s; i0++ {
        f()
    }
    // return the fully initialized RNG
    return f
}
 
func assert(p bool, m string) {
    if !p {
        fmt.Println(m)
        os.Exit(1)
    }
}
 
func main() {
    // 1st test case included in program_tools/universal.c.
    // (2nd test case fails.  A single digit is missing, indicating a typo.)
    ptTest(0, 1, []int{921674862, 250065336, 377506581})
 
    // reproduce 3 values given in task description
    skip := 220
    sg := newSG(55, 24, 21, skip, 1e9, 292929)
    for n := skip; n <= 222; n++ {
        fmt.Printf(""r(%d) = %d\n"", n, sg())
    }
}
 
func ptTest(nd, s int, rs []int) {
    sg := newSG(55, 24, 21, 220+nd, 1e9, s)
    for _, r := range rs {
        a := sg()
        if r != a {
            fmt.Println(""Fail"")
            os.Exit(1) 
        }
    }
}",2361,100
10493,http://rosettacode.org/wiki/Strong_and_weak_primes,Strong and weak primes,"

Definitions   (as per number theory)

   The   prime(p)   is the    pth   prime.
   prime(1)   is   2
   prime(4)   is   7
   A    strong   prime   is when     prime(p)   is   >   [prime(p-1) + prime(p+1)] ÷ 2
   A     weak    prime   is when     prime(p)   is   <   [prime(p-1) + prime(p+1)] ÷ 2


Note that the definition for   strong primes   is different when used in the context of   cryptography.



Task

   Find and display (on one line) the first   36   strong primes.
   Find and display the   count   of the strong primes below   1,000,000.
   Find and display the   count   of the strong primes below 10,000,000.
   Find and display (on one line) the first   37   weak primes.
   Find and display the   count   of the weak primes below   1,000,000.
   Find and display the   count   of the weak primes below 10,000,000.
   (Optional)   display the   counts   and   ""below numbers""   with commas.
Show all output here.



Related Task

   Safe primes and unsafe primes.


Also see

   The OEIS article A051634: strong primes.
   The OEIS article A051635: weak primes.

",#Go,Go,"package main
 
import ""fmt""
 
func sieve(limit int) []bool {
    limit++
    // True denotes composite, false denotes prime.
    // Don't bother marking even numbers >= 4 as composite.
    c := make([]bool, limit)
    c[0] = true
    c[1] = true
 
    p := 3 // start from 3
    for {
        p2 := p * p
        if p2 >= limit {
            break
        }
        for i := p2; i < limit; i += 2 * p {
            c[i] = true
        }
        for {
            p += 2
            if !c[p] {
                break
            }
        }
    }
    return c
}
 
func commatize(n int) string {
    s := fmt.Sprintf(""%d"", n)
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    return s
}
 
func main() {
    // sieve up to 10,000,019 - the first prime after 10 million
    const limit = 1e7 + 19
    sieved := sieve(limit)
    // extract primes
    var primes = []int{2}
    for i := 3; i <= limit; i += 2 {
        if !sieved[i] {
            primes = append(primes, i)
        }
    }
    // extract strong and weak primes
    var strong []int
    var weak = []int{3}                  // so can use integer division for rest
    for i := 2; i < len(primes)-1; i++ { // start from 5
        if primes[i] > (primes[i-1]+primes[i+1])/2 {
            strong = append(strong, primes[i])
        } else if primes[i] < (primes[i-1]+primes[i+1])/2 {
            weak = append(weak, primes[i])
        }
    }
 
    fmt.Println(""The first 36 strong primes are:"")
    fmt.Println(strong[:36])
    count := 0
    for _, p := range strong {
        if p >= 1e6 {
            break
        }
        count++
    }
    fmt.Println(""\nThe number of strong primes below 1,000,000 is"", commatize(count))
    fmt.Println(""\nThe number of strong primes below 10,000,000 is"", commatize(len(strong)))
 
    fmt.Println(""\nThe first 37 weak primes are:"")
    fmt.Println(weak[:37])
    count = 0
    for _, p := range weak {
        if p >= 1e6 {
            break
        }
        count++
    }
    fmt.Println(""\nThe number of weak primes below 1,000,000 is"", commatize(count))
    fmt.Println(""\nThe number of weak primes below 10,000,000 is"", commatize(len(weak)))
}",2195,86
10516,http://rosettacode.org/wiki/Sum_of_squares,Sum of squares,"Task

Write a program to find the sum of squares of a numeric vector.

The program should work on a zero-length vector (with an answer of   0).



Related task

   Mean

",#Go,Go,"package main
 
import ""fmt""
 
var v = []float32{1, 2, .5}
 
func main() {
    var sum float32
    for _, x := range v {
        sum += x * x
    }
    fmt.Println(sum)
}",169,13
10685,http://rosettacode.org/wiki/Sum_multiples_of_3_and_5,Sum multiples of 3 and 5,"Task

The objective is to write a function that finds the sum of all positive multiples of 3 or 5 below n.

Show output for n = 1000.

This is is the same as Project Euler problem 1.

Extra credit: do this efficiently for n = 1e20 or higher.



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    fmt.Println(s35(1000))
}
 
func s35(n int) int {
    n--
    threes := n / 3
    fives := n / 5
    fifteen := n / 15
 
    threes = 3 * threes * (threes + 1)
    fives = 5 * fives * (fives + 1)
    fifteen = 15 * fifteen * (fifteen + 1)
 
    n = (threes + fives - fifteen) / 2
 
    return n
}",343,22
10686,http://rosettacode.org/wiki/Sum_digits_of_an_integer,Sum digits of an integer,"Task

Take a   Natural Number   in a given base and return the sum of its digits:

   110         sums to   1
   123410   sums to   10
   fe16       sums to   29
   f0e16     sums to   29

",#Go,Go,"// File digit.go
 
package digit
 
import (
	""math/big""
	""strconv""
)
 
func SumString(n string, base int) (int, error) {
	i, ok := new(big.Int).SetString(n, base)
	if !ok {
		return 0, strconv.ErrSyntax
	}
	if i.Sign() < 0 {
		return 0, strconv.ErrRange
	}
	if i.BitLen() <= 64 {
		return Sum(i.Uint64(), base), nil
	}
	return SumBig(i, base), nil
}
 
func Sum(i uint64, base int) (sum int) {
	b64 := uint64(base)
	for ; i > 0; i /= b64 {
		sum += int(i % b64)
	}
	return
}
 
func SumBig(n *big.Int, base int) (sum int) {
	i := new(big.Int).Set(n)
	b := new(big.Int).SetUint64(uint64(base))
	r := new(big.Int)
	for i.BitLen() > 0 {
		i.DivMod(i, b, r)
		sum += int(r.Uint64())
	}
	return
}",689,41
10782,http://rosettacode.org/wiki/Strip_block_comments,Strip block comments,"A block comment begins with a   beginning delimiter   and ends with a   ending delimiter,   including the delimiters.   These delimiters are often multi-character sequences.



Task

Strip block comments from program text (of a programming language much like classic C).

Your demos should at least handle simple, non-nested and multi-line block comment delimiters.

The block comment delimiters are the two-character sequences:

      /*      (beginning delimiter)
      */      (ending delimiter)


Sample text for stripping:

  /**
   * Some comments
   * longer comments here that we can parse.
   *
   * Rahoo 
   */
   function subroutine() {
    a = /* inline comment */ b + c ;
   }
   /*/ <-- tricky comments */

   /**
    * Another comment.
    */
    function something() {
    }

Extra credit

Ensure that the stripping code is not hard-coded to the particular delimiters described above, but instead allows the caller to specify them.   (If your language supports them,   optional parameters   may be useful for this.)




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
// idiomatic to name a function newX that allocates an object, initializes it,
// and returns it ready to use.  the object in this case is a closure.
func newStripper(start, end string) func(string) string {
    // default to c-style block comments
    if start == """" || end == """" {
        start, end = ""/*"", ""*/""
    }
    // closes on variables start, end.
    return func(source string) string {
        for {
            cs := strings.Index(source, start)
            if cs < 0 {
                break
            }
            ce := strings.Index(source[cs+2:], end)
            if ce < 0 {
                break
            }
            source = source[:cs] + source[cs+ce+4:]
        }
        return source
    }
}
 
func main() {
    // idiomatic is that zero values indicate to use meaningful defaults
    stripC := newStripper("""", """")
 
    // strip function now defined and can be called any number of times
    // without respecifying delimiters
    fmt.Println(stripC(`  /**
   * Some comments
   * longer comments here that we can parse.
   *
   * Rahoo
   */
   function subroutine() {
    a = /* inline comment */ b + c ;
   }
   /*/ <-- tricky comments */
 
   /**
    * Another comment.
    */
    function something() {
    }`))
}",1304,54
10849,http://rosettacode.org/wiki/Sum_and_product_of_an_array,Sum and product of an array,"Task

Compute the sum and product of an array of integers.



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    sum, prod := 0, 1
    for _, x := range []int{1,2,5} {
        sum += x
        prod *= x
    }
    fmt.Println(sum, prod)
}",172,12
10882,http://rosettacode.org/wiki/Subleq,Subleq,"Subleq is an example of a One-Instruction Set Computer (OISC).

It is named after its only instruction, which is SUbtract and Branch if Less than or EQual to zero.

Task
Your task is to create an interpreter which emulates a SUBLEQ machine.

The machine's memory consists of an array of signed integers.   These integers may be interpreted in three ways:

   simple numeric values 
   memory addresses 
   characters for input or output
Any reasonable word size that accommodates all three of the above uses is fine.

The program should load the initial contents of the emulated machine's memory, set the instruction pointer to the first address (which is defined to be address 0), and begin emulating the machine, which works as follows:

   Let A be the value in the memory location identified by the instruction pointer;   let B and C be the values stored in the next two consecutive addresses in memory.
   Advance the instruction pointer three words, to point at the address after the address containing C.
   If A is   -1   (negative unity),   then a character is read from the machine's input and its numeric value stored in the address given by B.   C is unused.
   If B is   -1   (negative unity),   then the number contained in the address given by A is interpreted as a character and written to the machine's output.   C is unused.
   Otherwise, both A and B are treated as addresses.   The number contained in address A is subtracted from the number in address B (and the difference left in address B).   If the result is positive, execution continues uninterrupted; if the result is zero or negative, the number in C becomes the new instruction pointer.
   If the instruction pointer becomes negative, execution halts.
Your solution may initialize the emulated machine's memory in any convenient manner, but if you accept it as input, it should be a separate input stream from the one fed to the emulated machine once it is running. And if fed as text input, it should be in the form of raw subleq ""machine code"" - whitespace-separated decimal numbers, with no symbolic names or other assembly-level extensions, to be loaded into memory starting at address   0   (zero).

For purposes of this task, show the output of your solution when fed the below   ""Hello, world!""   program.

As written, this example assumes ASCII or a superset of it, such as any of the Latin-N character sets or Unicode;   you may translate the numbers representing characters (starting with 72=ASCII 'H') into another character set if your implementation runs in a non-ASCII-compatible environment. If 0 is not an appropriate terminator in your character set, the program logic will need some adjustment as well.

15 17 -1 17 -1 -1 16 1 -1 16 3 -1 15 15 0 0 -1 72 101 108 108 111 44 32 119 111 114 108 100 33 10 0
The above ""machine code"" corresponds to something like this in a hypothetical assembler language for a signed 8-bit version of the machine:

start:
    0f 11 ff subleq (zero), (message), -1
    11 ff ff subleq (message), -1, -1    ; output character at message
    10 01 ff subleq (neg1), (start+1), -1
    10 03 ff subleq (neg1), (start+3), -1
    0f 0f 00 subleq (zero), (zero), start
; useful constants
zero: 
    00      .data 0  
neg1: 
    ff      .data -1
; the message to print
message: .data ""Hello, world!\n\0""
    48 65 6c 6c 6f 2c 20 77 6f 72 6c 64 21 0a 00

",#Go,Go,"package main
 
import (
	""io""
	""log""
	""os""
)
 
func main() {
	var mem = []int{
		15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15, 0, 0, -1,
		//'H', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\n',
		72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33, 10,
		0,
	}
	for ip := 0; ip >= 0; {
		switch {
		case mem[ip] == -1:
			mem[mem[ip+1]] = readbyte()
		case mem[ip+1] == -1:
			writebyte(mem[mem[ip]])
		default:
			b := mem[ip+1]
			v := mem[b] - mem[mem[ip]]
			mem[b] = v
			if v <= 0 {
				ip = mem[ip+2]
				continue
			}
		}
		ip += 3
	}
}
 
func readbyte() int {
	var b [1]byte
	if _, err := io.ReadFull(os.Stdin, b[:]); err != nil {
		log.Fatalln(""read:"", err)
	}
	return int(b[0])
}
 
func writebyte(b int) {
	if _, err := os.Stdout.Write([]byte{byte(b)}); err != nil {
		log.Fatalln(""write:"", err)
	}
}",840,47
10926,http://rosettacode.org/wiki/Strip_comments_from_a_string,Strip comments from a string,"Strip comments from a string

You are encouraged to solve this task according to the task description, using any language you may know.
The task is to remove text that follow any of a set of comment markers, (in these examples either a hash or a semicolon) from a string or input line.


Whitespace debacle:   There is some confusion about whether to remove any whitespace from the input line.

As of 2 September 2011, at least 8 languages (C, C++, Java, Perl, Python, Ruby, sed, UNIX Shell) were incorrect, out of 36 total languages, because they did not trim whitespace by 29 March 2011 rules. Some other languages might be incorrect for the same reason.

Please discuss this issue at Talk:Strip comments from a string.

 From 29 March 2011, this task required that: ""The comment marker and any whitespace at the beginning or ends of the resultant line should be removed. A line without comments should be trimmed of any leading or trailing whitespace before being produced as a result."" The task had 28 languages, which did not all meet this new requirement.
 From 28 March 2011, this task required that: ""Whitespace before the comment marker should be removed.""
 From 30 October 2010, this task did not specify whether or not to remove whitespace.


The following examples will be truncated to either ""apples, pears "" or ""apples, pears"".

(This example has flipped between ""apples, pears "" and ""apples, pears"" in the past.)

apples, pears # and bananas
apples, pears ; and bananas




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
	""fmt""
	""strings""
	""unicode""
)
 
const commentChars = ""#;""
 
func stripComment(source string) string {
	if cut := strings.IndexAny(source, commentChars); cut >= 0 {
		return strings.TrimRightFunc(source[:cut], unicode.IsSpace)
	}
	return source
}
 
func main() {
	for _, s := range []string{
		""apples, pears # and bananas"",
		""apples, pears ; and bananas"",
		""no bananas"",
	} {
		fmt.Printf(""source:   %q\n"", s)
		fmt.Printf(""stripped: %q\n"", stripComment(s))
	}
}",489,27
10943,http://rosettacode.org/wiki/Strip_control_codes_and_extended_characters_from_a_string,Strip control codes and extended characters from a string,"Task

Strip control codes and extended characters from a string.



The solution should demonstrate how to achieve each of the following results:

   a string with control codes stripped (but extended characters not stripped)
   a string with control codes and extended characters stripped


In ASCII, the control codes have decimal codes 0 through to 31 and 127.

On an ASCII based system, if the control codes are stripped, the resultant string would have all of its characters within the range of 32 to 126 decimal on the ASCII table.

On a non-ASCII based system, we consider characters that do not have a corresponding glyph on the ASCII table (within the ASCII range of 32 to 126 decimal) to be an extended character for the purpose of this task.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms  (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
	""golang.org/x/text/transform""
	""golang.org/x/text/unicode/norm""
	""fmt""
	""strings""
)
 
// two byte-oriented functions identical except for operator comparing c to 127.
func stripCtlFromBytes(str string) string {
	b := make([]byte, len(str))
	var bl int
	for i := 0; i < len(str); i++ {
		c := str[i]
		if c >= 32 && c != 127 {
			b[bl] = c
			bl++
		}
	}
	return string(b[:bl])
}
 
func stripCtlAndExtFromBytes(str string) string {
	b := make([]byte, len(str))
	var bl int
	for i := 0; i < len(str); i++ {
		c := str[i]
		if c >= 32 && c < 127 {
			b[bl] = c
			bl++
		}
	}
	return string(b[:bl])
}
 
// two UTF-8 functions identical except for operator comparing c to 127
func stripCtlFromUTF8(str string) string {
	return strings.Map(func(r rune) rune {
		if r >= 32 && r != 127 {
			return r
		}
		return -1
	}, str)
}
 
func stripCtlAndExtFromUTF8(str string) string {
	return strings.Map(func(r rune) rune {
		if r >= 32 && r < 127 {
			return r
		}
		return -1
	}, str)
}
 
// Advanced Unicode normalization and filtering,
// see http://blog.golang.org/normalization and
// http://godoc.org/golang.org/x/text/unicode/norm for more
// details.
func stripCtlAndExtFromUnicode(str string) string {
	isOk := func(r rune) bool {
		return r < 32 || r >= 127
	}
	// The isOk filter is such that there is no need to chain to norm.NFC
	t := transform.Chain(norm.NFKD, transform.RemoveFunc(isOk))
	// This Transformer could also trivially be applied as an io.Reader
	// or io.Writer filter to automatically do such filtering when reading
	// or writing data anywhere.
	str, _, _ = transform.String(t, str)
	return str
}
 
const src = ""déjà vu"" + // precomposed unicode
	""\n\000\037 \041\176\177\200\377\n"" + // various boundary cases
	""as⃝df̅"" // unicode combining characters
 
func main() {
	fmt.Println(""source text:"")
	fmt.Println(src)
	fmt.Println(""\nas bytes, stripped of control codes:"")
	fmt.Println(stripCtlFromBytes(src))
	fmt.Println(""\nas bytes, stripped of control codes and extended characters:"")
	fmt.Println(stripCtlAndExtFromBytes(src))
	fmt.Println(""\nas UTF-8, stripped of control codes:"")
	fmt.Println(stripCtlFromUTF8(src))
	fmt.Println(""\nas UTF-8, stripped of control codes and extended characters:"")
	fmt.Println(stripCtlAndExtFromUTF8(src))
	fmt.Println(""\nas decomposed and stripped Unicode:"")
	fmt.Println(stripCtlAndExtFromUnicode(src))
}",2385,90
10976,http://rosettacode.org/wiki/String_prepend,String prepend,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Create a string variable equal to any text value.

Prepend the string variable with another string literal.

If your language supports any idiomatic ways to do this without referring to the variable twice in one expression, include such solutions.



To illustrate the operation, show the content of the variable.



",#Go,Go,"s := ""world!""
s = ""Hello, "" + s",31,2
10998,http://rosettacode.org/wiki/Substring/Top_and_tail,Substring/Top and tail,"The task is to demonstrate how to remove the first and last characters from a string.

The solution should demonstrate how to obtain the following results:

 String with first character removed
 String with last character removed
 String with both the first and last characters removed


If the program uses UTF-8 or UTF-16, it must work on any valid Unicode code point, whether in the Basic Multilingual Plane or above it.

The program must reference logical characters (code points), not 8-bit code units for UTF-8 or 16-bit code units for UTF-16.

Programs for other encodings (such as 8-bit ASCII, or EUC-JP) are not required to handle all Unicode characters.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""unicode/utf8""
)
 
func main() {
    // ASCII contents:  Interpreting ""characters"" as bytes.
    s := ""ASCII""
    fmt.Println(""String:                "", s)
    fmt.Println(""First byte removed:    "", s[1:])
    fmt.Println(""Last byte removed:     "", s[:len(s)-1])
    fmt.Println(""First and last removed:"", s[1:len(s)-1])
    // UTF-8 contents:  ""Characters"" as runes (unicode code points)
    u := ""Δημοτική""
    fmt.Println(""String:                "", u)
    _, sizeFirst := utf8.DecodeRuneInString(u)
    fmt.Println(""First rune removed:    "", u[sizeFirst:])
    _, sizeLast := utf8.DecodeLastRuneInString(u)
    fmt.Println(""Last rune removed:     "", u[:len(u)-sizeLast])
    fmt.Println(""First and last removed:"", u[sizeFirst:len(u)-sizeLast])
}",786,23
11095,http://rosettacode.org/wiki/Strip_whitespace_from_a_string/Top_and_tail,Strip whitespace from a string/Top and tail,"Task

Demonstrate how to strip leading and trailing whitespace from a string.

The solution should demonstrate how to achieve the following three results:

 String with leading whitespace removed
 String with trailing whitespace removed
 String with both leading and trailing whitespace removed


For the purposes of this task whitespace includes non printable characters such as the space character, the tab character, and other such characters that have no corresponding graphical representation.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
    ""unicode""
)
 
var simple = `
    simple   `
 
func main() {
    show(""original"", simple)
    show(""leading ws removed"", strings.TrimLeftFunc(simple, unicode.IsSpace))
    show(""trailing ws removed"", strings.TrimRightFunc(simple, unicode.IsSpace))
    // equivalent to strings.TrimFunc(simple, unicode.IsSpace)
    show(""both removed"", strings.TrimSpace(simple))
}
 
func show(label, str string) {
    fmt.Printf(""%s: |%s| %v\n"", label, str, []rune(str))
}",507,22
11128,http://rosettacode.org/wiki/Sudoku,Sudoku,"Task

Solve a partially filled-in normal   9x9   Sudoku grid   and display the result in a human-readable format.

references

 Algorithmics of Sudoku   may help implement this.
 Python Sudoku Solver Computerphile video.

",#Go,Go,"package main
 
import ""fmt""
 
// sudoku puzzle representation is an 81 character string 
var puzzle = """" +
    ""394  267 "" +
    ""   3  4  "" +
    ""5  69  2 "" +
    "" 45   9  "" +
    ""6       7"" +
    ""  7   58 "" +
    "" 1  67  8"" +
    ""  9  8   "" +
    "" 264  735""
 
func main() {
    printGrid(""puzzle:"", puzzle)
    if s := solve(puzzle); s == """" {
        fmt.Println(""no solution"")
    } else {
        printGrid(""solved:"", s)
    }
}
 
// print grid (with title) from 81 character string
func printGrid(title, s string) {
    fmt.Println(title)
    for r, i := 0, 0; r < 9; r, i = r+1, i+9 {
        fmt.Printf(""%c %c %c | %c %c %c | %c %c %c\n"", s[i], s[i+1], s[i+2],
            s[i+3], s[i+4], s[i+5], s[i+6], s[i+7], s[i+8])
        if r == 2 || r == 5 {
            fmt.Println(""------+-------+------"")
        }
    }
}   
 
// solve puzzle in 81 character string format.
// if solved, result is 81 character string.
// if not solved, result is the empty string.
func solve(u string) string {
    // construct an dlx object with 324 constraint columns.
    // other than the number 324, this is not specific to sudoku.
    d := newDlxObject(324)
    // now add constraints that define sudoku rules.
    for r, i := 0, 0; r < 9; r++ {
        for c := 0; c < 9; c, i = c+1, i+1 {
            b := r/3*3 + c/3
            n := int(u[i] - '1')
            if n >= 0 && n < 9 {
                d.addRow([]int{i, 81 + r*9 + n, 162 + c*9 + n,
                    243 + b*9 + n})
            } else {
                for n = 0; n < 9; n++ {
                    d.addRow([]int{i, 81 + r*9 + n, 162 + c*9 + n,
                        243 + b*9 + n})
                }
            }
        }
    }
    // run dlx.  not sudoku specific.
    d.search()
    // extract the sudoku-specific 81 character result from the dlx solution.
    return d.text()
}
 
// Knuth's data object
type x struct {
    c          *y
    u, d, l, r *x
    // except x0 is not Knuth's.  it's pointer to first constraint in row,
    // so that the sudoku string can be constructed from the dlx solution.
    x0 *x
}
 
// Knuth's column object
type y struct {
    x
    s int // size
    n int // name
}
 
// an object to hold the matrix and solution
type dlx struct {
    ch []y  // all column headers
    h  *y   // ch[0], the root node
    o  []*x // solution
}
 
// constructor creates the column headers but no rows.
func newDlxObject(nCols int) *dlx {
    ch := make([]y, nCols+1)
    h := &ch[0]
    d := &dlx{ch, h, nil}
    h.c = h
    h.l = &ch[nCols].x
    ch[nCols].r = &h.x
    nh := ch[1:]
    for i := range ch[1:] {
        hi := &nh[i]
        ix := &hi.x
        hi.n = i
        hi.c = hi
        hi.u = ix
        hi.d = ix
        hi.l = &h.x
        h.r = ix
        h = hi
    }
    return d
}   
 
// rows define constraints
func (d *dlx) addRow(nr []int) {
    if len(nr) == 0 {
        return
    }
    r := make([]x, len(nr))
    x0 := &r[0]
    for x, j := range nr {
        ch := &d.ch[j+1]
        ch.s++
        np := &r[x]
        np.c = ch
        np.u = ch.u
        np.d = &ch.x
        np.l = &r[(x+len(r)-1)%len(r)]
        np.r = &r[(x+1)%len(r)]
        np.u.d, np.d.u, np.l.r, np.r.l = np, np, np, np
        np.x0 = x0
    }
}
 
// extracts 81 character sudoku string
func (d *dlx) text() string {
    b := make([]byte, len(d.o))
    for _, r := range d.o {
        x0 := r.x0
        b[x0.c.n] = byte(x0.r.c.n%9) + '1'
    }
    return string(b)
}   
 
// the dlx algorithm 
func (d *dlx) search() bool {
    h := d.h
    j := h.r.c
    if j == h {
        return true
    }
    c := j 
    for minS := j.s; ; {
        j = j.r.c
        if j == h {
            break
        }
        if j.s < minS {
            c, minS = j, j.s
        }
    }
 
    cover(c)
    k := len(d.o)
    d.o = append(d.o, nil)
    for r := c.d; r != &c.x; r = r.d {
        d.o[k] = r
        for j := r.r; j != r; j = j.r {
            cover(j.c)
        }
        if d.search() {
            return true
        }
        r = d.o[k]
        c = r.c
        for j := r.l; j != r; j = j.l {
            uncover(j.c)
        }
    }
    d.o = d.o[:len(d.o)-1]
    uncover(c)
    return false
}
 
func cover(c *y) {
    c.r.l, c.l.r = c.l, c.r
    for i := c.d; i != &c.x; i = i.d {
        for j := i.r; j != i; j = j.r {
            j.d.u, j.u.d = j.u, j.d
            j.c.s--
        }
    }
}
 
func uncover(c *y) {
    for i := c.u; i != &c.x; i = i.u {
        for j := i.l; j != i; j = j.l {
            j.c.s++
            j.d.u, j.u.d = j, j
        }
    }
    c.r.l, c.l.r = &c.x, &c.x
}",4596,202
11284,http://rosettacode.org/wiki/Sum_of_a_series,Sum of a series,"Compute the   nth   term of a series,   i.e. the sum of the   n   first terms of the corresponding sequence.

Informally this value, or its limit when   n   tends to infinity, is also called the sum of the series, thus the title of this task.

For this task, use:

 




S

n


=

∑

k
=
1


n




1

k

2






{\displaystyle S_{n}=\sum _{k=1}^{n}{\frac {1}{k^{2}}}}




 and compute   




S

1000




{\displaystyle S_{1000}}




This approximates the   zeta function   for   S=2,   whose exact value

 



ζ
(
2
)
=



π

2


6




{\displaystyle \zeta (2)={\pi ^{2} \over 6}}


is the solution of the Basel problem.



",#Go,Go,"package main
 
import (""fmt""; ""math"")
 
func main() {
    fmt.Println(""known:   "", math.Pi*math.Pi/6)
    sum := 0.
    for i := 1e3; i > 0; i-- {
        sum += 1 / (i * i)
    }
    fmt.Println(""computed:"", sum)
}",215,12
11399,http://rosettacode.org/wiki/Strip_a_set_of_characters_from_a_string,Strip a set of characters from a string,"Task

Create a function that strips a set of characters from a string.



The function should take two arguments:

   a string to be stripped 
   a string containing the set of characters to be stripped


The returned string should contain the first string, stripped of any characters in the second argument:

 print stripchars(""She was a soul stripper. She took my heart!"",""aei"")
Sh ws  soul strppr. Sh took my hrt!



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func stripchars(str, chr string) string {
    return strings.Map(func(r rune) rune {
        if strings.IndexRune(chr, r) < 0 {
            return r
        }
        return -1
    }, str)
}
 
func main() {
    fmt.Println(stripchars(""She was a soul stripper. She took my heart!"",
        ""aei""))
}",350,20
11469,http://rosettacode.org/wiki/String_interpolation_(included),String interpolation (included),"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Given a string and defined variables or values, string interpolation is the replacement of defined character sequences in the string by values or variable values.

 For example, given an original string of ""Mary had a X lamb."", a value of ""big"", and if the language replaces X in its interpolation routine, then the result of its interpolation would be the string ""Mary had a big lamb"".
(Languages usually include an infrequently used character or sequence of characters to indicate what is to be replaced such as ""%"", or ""#"" rather than ""X"").


Task

 Use your languages inbuilt string interpolation abilities to interpolate a string missing the text ""little"" which is held in a variable, to produce the output string ""Mary had a little lamb"".
 If possible, give links to further documentation on your languages string interpolation features.

Note: The task is not to create a string interpolation routine, but to show a language's built-in capability.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go," 
package main
 
import (
    ""fmt""
)
 
func main() {
    str := ""Mary had a %s lamb""
    txt := ""little""
    out := fmt.Sprintf(str, txt)
    fmt.Println(out)
}
 ",163,14
11550,http://rosettacode.org/wiki/String_comparison,String comparison,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Demonstrate how to compare two strings from within the language and how to achieve a lexical comparison.



The task should demonstrate:

 Comparing two strings for exact equality
 Comparing two strings for inequality (i.e., the inverse of exact equality)
 Comparing two strings to see if one is lexically ordered before than the other
 Comparing two strings to see if one is lexically ordered after than the other
 How to achieve both case sensitive comparisons and case insensitive comparisons within the language
 How the language handles comparison of numeric strings if these are not treated lexically
 Demonstrate any other kinds of string comparisons that the language provides, particularly as it relates to your type system. 


For example, you might demonstrate the difference between generic/polymorphic comparison and coercive/allomorphic comparison if your language supports such a distinction.



Here ""generic/polymorphic"" comparison means that the function or operator you're using doesn't always do string comparison, but bends the actual semantics of the comparison depending on the types one or both arguments; with such an operator, you achieve string comparison only if the arguments are sufficiently string-like in type or appearance.

In contrast, a ""coercive/allomorphic"" comparison function or operator has fixed string-comparison semantics regardless of the argument type;   instead of the operator bending, it's the arguments that are forced to bend instead and behave like strings if they can,   and the operator simply fails if the arguments cannot be viewed somehow as strings.   A language may have one or both of these kinds of operators;   see the Raku entry for an example of a language with both kinds of operators.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func main() {
    // Go language string comparison operators:
    c := ""cat""
    d := ""dog""
    if c == d {
        fmt.Println(c, ""is bytewise identical to"", d)
    }
    if c != d {
        fmt.Println(c, ""is bytewise different from"", d)
    }
    if c > d {
        fmt.Println(c, ""is lexically bytewise greater than"", d)
    }
    if c < d {
        fmt.Println(c, ""is lexically bytewise less than"", d)
    }
    if c >= d {
        fmt.Println(c, ""is lexically bytewise greater than or equal to"", d)
    }
    if c <= d {
        fmt.Println(c, ""is lexically bytewise less than or equal to"", d)
    }
    // Go is strongly typed and will not directly compare a value of string
    // type to a value of numeric type.
 
    // A case insensitive compare can be done with a function in the strings
    // package in the Go standard library:
    eqf := `when interpreted as UTF-8 and compared under Unicode
simple case folding rules.`
    if strings.EqualFold(c, d) {
        fmt.Println(c, ""equal to"", d, eqf)
    } else {
        fmt.Println(c, ""not equal to"", d, eqf)
    }
 
    // Seeing that the built in operators work bytewise and the library
    // case folding functions interpret UTF-8, you might then ask about
    // other equality and inequality tests that interpret UTF-8.
    // Functions for this are not in the Go standard library but are in
    // the Go ""sub repository"" at golang.org/x/text.  There is support
    // for Unicode normalization, collation tables, and locale sensitive
    // comparisons.
}",1579,50
11567,http://rosettacode.org/wiki/Substring,Substring,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses




Task

Display a substring:

   starting from   n   characters in and of   m   length;
   starting from   n   characters in,   up to the end of the string;
   whole string minus the last character;
   starting from a known   character   within the string and of   m   length;
   starting from a known   substring   within the string and of   m   length.


If the program uses UTF-8 or UTF-16,   it must work on any valid Unicode code point,
whether in the   Basic Multilingual Plane   or above it.

The program must reference logical characters (code points),   not 8-bit code units for UTF-8 or 16-bit code units for UTF-16.

Programs for other encodings (such as 8-bit ASCII, or EUC-JP) are not required to handle all Unicode characters.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func main() {
    s := ""ABCDEFGH""
    n, m := 2, 3
    // for reference
    fmt.Println(""Index: "", ""01234567"")
    fmt.Println(""String:"", s)
    // starting from n characters in and of m length
    fmt.Printf(""Start %d, length %d:    %s\n"", n, m, s[n : n+m])
    // starting from n characters in, up to the end of the string
    fmt.Printf(""Start %d, to end:      %s\n"", n, s[n:])
    // whole string minus last character
    fmt.Printf(""All but last:         %s\n"", s[:len(s)-1])
    // starting from a known character within the string and of m length
    dx := strings.IndexByte(s, 'D')
    fmt.Printf(""Start 'D', length %d:  %s\n"", m, s[dx : dx+m])
    // starting from a known substring within the string and of m length
    sx := strings.Index(s, ""DE"")
    fmt.Printf(`Start ""DE"", length %d: %s`+""\n"", m, s[sx : sx+m])
}",878,26
11596,http://rosettacode.org/wiki/String_concatenation,String concatenation,"String concatenation

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a string variable equal to any text value.

Create another string variable whose value is the original variable concatenated with another string literal.

To illustrate the operation, show the content of the variables.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    // text assigned to a string variable
    s := ""hello""
 
    // output string variable
    fmt.Println(s)
 
    // this output requested by original task descrption, although
    // not really required by current wording of task description.
    fmt.Println(s + "" literal"")
 
    // concatenate variable and literal, assign result to another string variable
    s2 := s + "" literal""
 
    // output second string variable
    fmt.Println(s2)
}",491,21
11858,http://rosettacode.org/wiki/String_case,String case,"Task

Take the string     alphaBETA     and demonstrate how to convert it to:

   upper-case     and 
   lower-case


Use the default encoding of a string literal or plain ASCII if there is no string literal in your language.

Note: In some languages alphabets toLower and toUpper is not reversable.

Show any additional case conversion functions   (e.g. swapping case, capitalizing the first letter, etc.)   that may be included in the library of your language.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
    ""unicode""
    ""unicode/utf8""
)
 
func main() {
    show(""alphaBETA"")
    show(""alpha BETA"")
    // Three digraphs that should render similar to DZ, Lj, and nj.
    show(""Ǆǈǌ"")
    // Unicode apostrophe in third word.
    show(""o'hare O'HARE o’hare don't"")
}
 
func show(s string) {
    fmt.Println(""\nstring:         "",
        s, "" len:"", utf8.RuneCountInString(s), ""runes"") // DZLjnj
    fmt.Println(""All upper case: "", strings.ToUpper(s)) // DZLJNJ
    fmt.Println(""All lower case: "", strings.ToLower(s)) // dzljnj
    fmt.Println(""All title case: "", strings.ToTitle(s)) // DzLjNj
    fmt.Println(""Title words:    "", strings.Title(s))   // Dzljnj
    fmt.Println(""Swapping case:  "",                     // DzLjNJ
        strings.Map(unicode.SimpleFold, s))
}",813,28
11859,http://rosettacode.org/wiki/String_matching,String matching,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Given two strings, demonstrate the following three types of string matching:

   Determining if the first string starts with second string
   Determining if the first string contains the second string at any location
   Determining if the first string ends with the second string


Optional requirements:

   Print the location of the match for part 2
   Handle multiple occurrences of a string for part 2.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func match(first, second string) {
    fmt.Printf(""1. %s starts with %s: %t\n"",
        first, second, strings.HasPrefix(first, second))
    i := strings.Index(first, second)
    fmt.Printf(""2. %s contains %s: %t,\n"", first, second, i >= 0)
    if i >= 0 {
        fmt.Printf(""2.1. at location %d,\n"", i)
        for start := i+1;; {
            if i = strings.Index(first[start:], second); i < 0 {
                break
            }
            fmt.Printf(""2.2. at location %d,\n"", start+i)
            start += i+1
        }
        fmt.Println(""2.2. and that's all"")
    }
    fmt.Printf(""3. %s ends with %s: %t\n"",
        first, second, strings.HasSuffix(first, second))
}
 
func main() {
    match(""abracadabra"", ""abr"")
}",780,30
11932,http://rosettacode.org/wiki/String_length,String length,"Task

Find the character and byte length of a string.

This means encodings like UTF-8 need to be handled properly, as there is not necessarily a one-to-one relationship between bytes and characters.

By character, we mean an individual Unicode code point, not a user-visible grapheme containing combining characters.

For example, the character length of ""møøse"" is 5 but the byte length is 7 in UTF-8 and 10 in UTF-16.

Non-BMP code points (those between 0x10000 and 0x10FFFF) must also be handled correctly: answers should produce actual character counts in code points, not in code unit counts.

Therefore a string like ""𝔘𝔫𝔦𝔠𝔬𝔡𝔢"" (consisting of the 7 Unicode characters U+1D518 U+1D52B U+1D526 U+1D520 U+1D52C U+1D521 U+1D522) is 7 characters long, not 14 UTF-16 code units; and it is 28 bytes long whether encoded in UTF-8 or in UTF-16.

Please mark your examples with ===Character Length=== or ===Byte Length===.

If your language is capable of providing the string length in graphemes, mark those examples with ===Grapheme Length===.

For example, the string ""J̲o̲s̲é̲"" (""J\x{332}o\x{332}s\x{332}e\x{301}\x{332}"") has 4 user-visible graphemes, 9 characters (code points), and 14 bytes when encoded in UTF-8.





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    m := ""møøse""
    u := ""𝔘𝔫𝔦𝔠𝔬𝔡𝔢""
    j := ""J̲o̲s̲é̲""
    fmt.Printf(""%d %s % x\n"", len(m), m, m)
    fmt.Printf(""%d %s %x\n"", len(u), u, u)
    fmt.Printf(""%d %s % x\n"", len(j), j, j)
}",232,12
12823,http://rosettacode.org/wiki/Stirling_numbers_of_the_second_kind,Stirling numbers of the second kind,"Stirling numbers of the second kind, or Stirling partition numbers, are the
number of ways to partition a set of n objects into k non-empty subsets. They are
closely related to Bell numbers, and may be derived from them.



Stirling numbers of the second kind obey the recurrence relation:

   S2(n, 0) and S2(0, k) = 0 # for n, k > 0
   S2(n, n) = 1
   S2(n + 1, k) = k * S2(n, k) + S2(n, k - 1)



Task

 Write a routine (function, procedure, whatever) to find Stirling numbers of the second kind. There are several methods to generate Stirling numbers of the second kind. You are free to choose the most appropriate for your language. If your language has a built-in, or easily, publicly available library implementation, it is acceptable to use that.
 Using the routine, generate and show here, on this page, a table (or triangle) showing the Stirling numbers of the second kind, S2(n, k), up to S2(12, 12). it is optional to show the row / column for n == 0 and k == 0. It is optional to show places where S2(n, k) == 0 (when k > n).
 If your language supports large integers, find and show here, on this page, the maximum value of S2(n, k) where n == 100.


See also

 Wikipedia - Stirling numbers of the second kind
 OEIS:A008277 - Stirling numbers of the second kind


Related Tasks

 Stirling numbers of the first kind
 Bell numbers
 Lah numbers

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    limit := 100
    last := 12
    s2 := make([][]*big.Int, limit+1)
    for n := 0; n <= limit; n++ {
        s2[n] = make([]*big.Int, limit+1)
        for k := 0; k <= limit; k++ {
            s2[n][k] = new(big.Int)
        }
        s2[n][n].SetInt64(int64(1))
    }
    var t big.Int
    for n := 1; n <= limit; n++ {
        for k := 1; k <= n; k++ {
            t.SetInt64(int64(k))
            t.Mul(&t, s2[n-1][k])
            s2[n][k].Add(&t, s2[n-1][k-1])
        }
    }
    fmt.Println(""Stirling numbers of the second kind: S2(n, k):"")
    fmt.Printf(""n/k"")
    for i := 0; i <= last; i++ {
        fmt.Printf(""%9d "", i)
    }
    fmt.Printf(""\n--"")
    for i := 0; i <= last; i++ {
        fmt.Printf(""----------"")
    }
    fmt.Println()
    for n := 0; n <= last; n++ {
        fmt.Printf(""%2d "", n)
        for k := 0; k <= n; k++ {
            fmt.Printf(""%9d "", s2[n][k])
        }
        fmt.Println()
    }
    fmt.Println(""\nMaximum value from the S2(100, *) row:"")
    max := new(big.Int).Set(s2[limit][0])
    for k := 1; k <= limit; k++ {
        if s2[limit][k].Cmp(max) > 0 {
            max.Set(s2[limit][k])
        }
    }
    fmt.Println(max)
    fmt.Printf(""which has %d digits.\n"", len(max.String()))
}",1304,53
12829,http://rosettacode.org/wiki/Strassen%27s_algorithm,Strassen's algorithm,"Description
In linear algebra, the Strassen algorithm   (named after Volker Strassen),   is an algorithm for matrix multiplication.

It is faster than the standard matrix multiplication algorithm and is useful in practice for large matrices,   but would be slower than the fastest known algorithms for extremely large matrices.



Task
Write a routine, function, procedure etc. in your language to implement the Strassen algorithm for matrix multiplication.

While practical implementations of Strassen's algorithm usually switch to standard methods of matrix multiplication for small enough sub-matrices (currently anything less than   512×512   according to Wikipedia),   for the purposes of this task you should not switch until reaching a size of 1 or 2.



Related task
 Matrix multiplication


See also
 Wikipedia article

",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math""
)
 
type Matrix [][]float64
 
func (m Matrix) rows() int { return len(m) }
func (m Matrix) cols() int { return len(m[0]) }
 
func (m Matrix) add(m2 Matrix) Matrix {
    if m.rows() != m2.rows() || m.cols() != m2.cols() {
        log.Fatal(""Matrices must have the same dimensions."")
    }
    c := make(Matrix, m.rows())
    for i := 0; i < m.rows(); i++ {
        c[i] = make([]float64, m.cols())
        for j := 0; j < m.cols(); j++ {
            c[i][j] = m[i][j] + m2[i][j]
        }
    }
    return c
}
 
func (m Matrix) sub(m2 Matrix) Matrix {
    if m.rows() != m2.rows() || m.cols() != m2.cols() {
        log.Fatal(""Matrices must have the same dimensions."")
    }
    c := make(Matrix, m.rows())
    for i := 0; i < m.rows(); i++ {
        c[i] = make([]float64, m.cols())
        for j := 0; j < m.cols(); j++ {
            c[i][j] = m[i][j] - m2[i][j]
        }
    }
    return c
}
 
func (m Matrix) mul(m2 Matrix) Matrix {
    if m.cols() != m2.rows() {
        log.Fatal(""Cannot multiply these matrices."")
    }
    c := make(Matrix, m.rows())
    for i := 0; i < m.rows(); i++ {
        c[i] = make([]float64, m2.cols())
        for j := 0; j < m2.cols(); j++ {
            for k := 0; k < m2.rows(); k++ {
                c[i][j] += m[i][k] * m2[k][j]
            }
        }
    }
    return c
}
 
func (m Matrix) toString(p int) string {
    s := make([]string, m.rows())
    pow := math.Pow(10, float64(p))
    for i := 0; i < m.rows(); i++ {
        t := make([]string, m.cols())
        for j := 0; j < m.cols(); j++ {
            r := math.Round(m[i][j]*pow) / pow
            t[j] = fmt.Sprintf(""%g"", r)
            if t[j] == ""-0"" {
                t[j] = ""0""
            }
        }
        s[i] = fmt.Sprintf(""%v"", t)
    }
    return fmt.Sprintf(""%v"", s)
}
 
func params(r, c int) [4][6]int {
    return [4][6]int{
        {0, r, 0, c, 0, 0},
        {0, r, c, 2 * c, 0, c},
        {r, 2 * r, 0, c, r, 0},
        {r, 2 * r, c, 2 * c, r, c},
    }
}
 
func toQuarters(m Matrix) [4]Matrix {
    r := m.rows() / 2
    c := m.cols() / 2
    p := params(r, c)
    var quarters [4]Matrix
    for k := 0; k < 4; k++ {
        q := make(Matrix, r)
        for i := p[k][0]; i < p[k][1]; i++ {
            q[i-p[k][4]] = make([]float64, c)
            for j := p[k][2]; j < p[k][3]; j++ {
                q[i-p[k][4]][j-p[k][5]] = m[i][j]
            }
        }
        quarters[k] = q
    }
    return quarters
}
 
func fromQuarters(q [4]Matrix) Matrix {
    r := q[0].rows()
    c := q[0].cols()
    p := params(r, c)
    r *= 2
    c *= 2
    m := make(Matrix, r)
    for i := 0; i < c; i++ {
        m[i] = make([]float64, c)
    }
    for k := 0; k < 4; k++ {
        for i := p[k][0]; i < p[k][1]; i++ {
            for j := p[k][2]; j < p[k][3]; j++ {
                m[i][j] = q[k][i-p[k][4]][j-p[k][5]]
            }
        }
    }
    return m
}
 
func strassen(a, b Matrix) Matrix {
    if a.rows() != a.cols() || b.rows() != b.cols() || a.rows() != b.rows() {
        log.Fatal(""Matrices must be square and of equal size."")
    }
    if a.rows() == 0 || (a.rows()&(a.rows()-1)) != 0 {
        log.Fatal(""Size of matrices must be a power of two."")
    }
    if a.rows() == 1 {
        return a.mul(b)
    }
    qa := toQuarters(a)
    qb := toQuarters(b)
    p1 := strassen(qa[1].sub(qa[3]), qb[2].add(qb[3]))
    p2 := strassen(qa[0].add(qa[3]), qb[0].add(qb[3]))
    p3 := strassen(qa[0].sub(qa[2]), qb[0].add(qb[1]))
    p4 := strassen(qa[0].add(qa[1]), qb[3])
    p5 := strassen(qa[0], qb[1].sub(qb[3]))
    p6 := strassen(qa[3], qb[2].sub(qb[0]))
    p7 := strassen(qa[2].add(qa[3]), qb[0])
    var q [4]Matrix
    q[0] = p1.add(p2).sub(p4).add(p6)
    q[1] = p4.add(p5)
    q[2] = p6.add(p7)
    q[3] = p2.sub(p3).add(p5).sub(p7)
    return fromQuarters(q)
}
 
func main() {
    a := Matrix{{1, 2}, {3, 4}}
    b := Matrix{{5, 6}, {7, 8}}
    c := Matrix{{1, 1, 1, 1}, {2, 4, 8, 16}, {3, 9, 27, 81}, {4, 16, 64, 256}}
    d := Matrix{{4, -3, 4.0 / 3, -1.0 / 4}, {-13.0 / 3, 19.0 / 4, -7.0 / 3, 11.0 / 24},
        {3.0 / 2, -2, 7.0 / 6, -1.0 / 4}, {-1.0 / 6, 1.0 / 4, -1.0 / 6, 1.0 / 24}}
    e := Matrix{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}
    f := Matrix{{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1}}
    fmt.Println(""Using 'normal' matrix multiplication:"")
    fmt.Printf(""  a * b = %v\n"", a.mul(b))
    fmt.Printf(""  c * d = %v\n"", c.mul(d).toString(6))
    fmt.Printf(""  e * f = %v\n"", e.mul(f))
    fmt.Println(""\nUsing 'Strassen' matrix multiplication:"")
    fmt.Printf(""  a * b = %v\n"", strassen(a, b))
    fmt.Printf(""  c * d = %v\n"", strassen(c, d).toString(6))
    fmt.Printf(""  e * f = %v\n"", strassen(e, f))
}",4754,165
12901,http://rosettacode.org/wiki/Straddling_checkerboard,Straddling checkerboard,"Task

Implement functions to encrypt and decrypt a message using the straddling checkerboard method. The checkerboard should take a 28 character alphabet (A-Z plus a full stop and an escape character) and two different numbers representing the blanks in the first row. The output will be a series of decimal digits.

Numbers should be encrypted by inserting the escape character before each digit, then including the digit unencrypted. This should be reversed for decryption.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func main() {
    key := `
 8752390146
 ET AON RIS
5BC/FGHJKLM
0PQD.VWXYZU`
    p := ""you have put on 7.5 pounds since I saw you.""
    fmt.Println(p)
    c := enc(key, p)
    fmt.Println(c)
    fmt.Println(dec(key, c))
}
 
func enc(bd, pt string) (ct string) {
    enc := make(map[byte]string)
    row := strings.Split(bd, ""\n"")[1:]
    r2d := row[2][:1]
    r3d := row[3][:1]
    for col := 1; col <= 10; col++ {
        d := string(row[0][col])
        enc[row[1][col]] = d
        enc[row[2][col]] = r2d+d
        enc[row[3][col]] = r3d+d
    }
    num := enc['/']
    delete(enc, '/')
    delete(enc, ' ')
    for i := 0; i < len(pt); i++ {
        if c := pt[i]; c <= '9' && c >= '0' {
            ct += num + string(c)
        } else {
            if c <= 'z' && c >= 'a' {
                c -= 'a'-'A'
            }
            ct += enc[c]
        }
    }
    return
}
 
func dec(bd, ct string) (pt string) {
    row := strings.Split(bd, ""\n"")[1:]
    var cx [10]int
    for i := 1; i <= 10; i++ {
        cx[row[0][i]-'0'] = i
    }
    r2d := row[2][0]-'0'
    r3d := row[3][0]-'0'
    for i := 0; i < len(ct); i++ {
        var r int
        switch d := ct[i]-'0'; d {
        case r2d:
            r = 2
        case r3d:
            r = 3
        default:
            pt += string(row[1][cx[d]])
            continue
        }
        i++
        if b := row[r][cx[ct[i]-'0']]; b == '/' {
            i++
            pt += string(ct[i])
        } else {
            pt += string(b)
        }
    }
    return
}",1575,76
12907,http://rosettacode.org/wiki/Stirling_numbers_of_the_first_kind,Stirling numbers of the first kind,"Stirling numbers of the first kind, or Stirling cycle numbers, count permutations according to their number
of cycles (counting fixed points as cycles of length one).

They may be defined directly to be the number of permutations of n
elements with k disjoint cycles.

Stirling numbers of the first kind express coefficients of polynomial expansions of falling or rising factorials.

Depending on the application, Stirling numbers of the first kind may be ""signed""
or ""unsigned"". Signed Stirling numbers of the first kind arise when the
polynomial expansion is expressed in terms of falling factorials; unsigned when
expressed in terms of rising factorials. The only substantial difference is that,
for signed Stirling numbers of the first kind, values of S1(n, k) are negative
when n + k is odd.

Stirling numbers of the first kind follow the simple identities:

   S1(0, 0) = 1
   S1(n, 0) = 0 if n > 0
   S1(n, k) = 0 if k > n
   S1(n, k) = S1(n - 1, k - 1) + (n - 1) * S1(n - 1, k) # For unsigned
     or
   S1(n, k) = S1(n - 1, k - 1) - (n - 1) * S1(n - 1, k) # For signed



Task

 Write a routine (function, procedure, whatever) to find Stirling numbers of the first kind. There are several methods to generate Stirling numbers of the first kind. You are free to choose the most appropriate for your language. If your language has a built-in, or easily, publicly available library implementation, it is acceptable to use that.
 Using the routine, generate and show here, on this page, a table (or triangle) showing the Stirling numbers of the first kind, S1(n, k), up to S1(12, 12). it is optional to show the row / column for n == 0 and k == 0. It is optional to show places where S1(n, k) == 0 (when k > n). You may choose to show signed or unsigned Stirling numbers of the first kind, just make a note of which was chosen.
 If your language supports large integers, find and show here, on this page, the maximum value of S1(n, k) where n == 100.


See also

 Wikipedia - Stirling numbers of the first kind
 OEIS:A008275 - Signed Stirling numbers of the first kind
 OEIS:A130534 - Unsigned Stirling numbers of the first kind


Related Tasks

 Stirling numbers of the second kind
 Lah numbers

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    limit := 100
    last := 12
    unsigned := true
    s1 := make([][]*big.Int, limit+1)
    for n := 0; n <= limit; n++ {
        s1[n] = make([]*big.Int, limit+1)
        for k := 0; k <= limit; k++ {
            s1[n][k] = new(big.Int)
        }
    }
    s1[0][0].SetInt64(int64(1))
    var t big.Int
    for n := 1; n <= limit; n++ {
        for k := 1; k <= n; k++ {
            t.SetInt64(int64(n - 1))
            t.Mul(&t, s1[n-1][k])            
            if unsigned {
                s1[n][k].Add(s1[n-1][k-1], &t)
            } else {
                s1[n][k].Sub(s1[n-1][k-1], &t)
            }           
        }
    }
    fmt.Println(""Unsigned Stirling numbers of the first kind: S1(n, k):"")
    fmt.Printf(""n/k"")
    for i := 0; i <= last; i++ {
        fmt.Printf(""%9d "", i)
    }
    fmt.Printf(""\n--"")
    for i := 0; i <= last; i++ {
        fmt.Printf(""----------"")
    }
    fmt.Println()
    for n := 0; n <= last; n++ {
        fmt.Printf(""%2d "", n)
        for k := 0; k <= n; k++ {
            fmt.Printf(""%9d "", s1[n][k])
        }
        fmt.Println()
    }
    fmt.Println(""\nMaximum value from the S1(100, *) row:"")
    max := new(big.Int).Set(s1[limit][0])
    for k := 1; k <= limit; k++ {
        if s1[limit][k].Cmp(max) > 0 {
            max.Set(s1[limit][k])
        }
    }
    fmt.Println(max)
    fmt.Printf(""which has %d digits.\n"", len(max.String()))
}",1468,58
12932,http://rosettacode.org/wiki/Stream_merge,Stream merge," 2-stream merge
 Read two sorted streams of items from external source (e.g. disk, or network), and write one stream of sorted items to external sink.
 Common algorithm: keep 1 buffered item from each source, select minimal of them, write it, fetch another item from that stream from which the written item was.
 N-stream merge
 The same as above, but reading from    N    sources.
 Common algorithm: same as above, but keep buffered items and their source descriptors in a heap.


Assume streams are very big. You must not suck them whole in the memory, but read them as streams.



",#Go,Go,"package main
 
import (
    ""container/heap""
    ""fmt""
    ""io""
    ""log""
    ""os""
    ""strings""
)
 
var s1 = ""3 14 15""
var s2 = ""2 17 18""
var s3 = """"
var s4 = ""2 3 5 7""
 
func main() {
    fmt.Print(""merge2: "")
    merge2(
        os.Stdout,
        strings.NewReader(s1),
        strings.NewReader(s2))
    fmt.Println()
 
    fmt.Print(""mergeN: "")
    mergeN(
        os.Stdout,
        strings.NewReader(s1),
        strings.NewReader(s2),
        strings.NewReader(s3),
        strings.NewReader(s4))
    fmt.Println()
}
 
func r1(r io.Reader) (v int, ok bool) {
    switch _, err := fmt.Fscan(r, &v); {
    case err == nil:
        return v, true
    case err != io.EOF:
        log.Fatal(err)
    }
    return
}
 
func merge2(m io.Writer, s1, s2 io.Reader) {
    v1, d1 := r1(s1)
    v2, d2 := r1(s2)
    var v int
    for d1 || d2 {
        if !d2 || d1 && v1 < v2 {
            v = v1
            v1, d1 = r1(s1)
        } else {
            v = v2
            v2, d2 = r1(s2)
        }
        fmt.Fprint(m, v, "" "")
    }
}
 
type sv struct {
    s io.Reader
    v int
}
 
type sh []sv
 
func (s sh) Len() int            { return len(s) }
func (s sh) Less(i, j int) bool  { return s[i].v < s[j].v }
func (s sh) Swap(i, j int)       { s[i], s[j] = s[j], s[i] }
func (p *sh) Push(x interface{}) { *p = append(*p, x.(sv)) }
func (p *sh) Pop() interface{} {
    s := *p
    last := len(s) - 1
    v := s[last]
    *p = s[:last]
    return v
}
 
func mergeN(m io.Writer, s ...io.Reader) {
    var h sh
    for _, s := range s {
        if v, d := r1(s); d {
            h = append(h, sv{s, v})
        }
    }
    heap.Init(&h)
    for len(h) > 0 {
        p := heap.Pop(&h).(sv)
        fmt.Fprint(m, p.v, "" "")
        if v, d := r1(p.s); d {
            heap.Push(&h, sv{p.s, v})
        }
    }
}",1804,95
12961,http://rosettacode.org/wiki/String_append,String append,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Most languages provide a way to concatenate two string values, but some languages also provide a convenient way to append in-place to an existing string variable without referring to the variable twice.



Task

Create a string variable equal to any text value.

Append the string variable with another string literal in the most idiomatic way, without double reference if your language supports it.

Show the contents of the variable after the append operation.



",#Go,Go,"s := ""foo""
s += ""bar""",21,2
13026,http://rosettacode.org/wiki/Statistics/Normal_distribution,Statistics/Normal distribution,"The Normal (or Gaussian) distribution is a frequently used distribution in statistics. While most programming languages provide a uniformly distributed random number generator, one can derive normally distributed random numbers from a uniform generator.



The task

 Take a uniform random number generator and create a large (you decide how large) set of numbers that follow a normal (Gaussian) distribution. Calculate the dataset's mean and standard deviation, and show a histogram of the data.
 Mention any native language support for the generation of normally distributed random numbers.


Reference

 You may refer to code in Statistics/Basic if available.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/rand""
    ""strings""
)
 
// Box-Muller
func norm2() (s, c float64) {
    r := math.Sqrt(-2 * math.Log(rand.Float64()))
    s, c = math.Sincos(2 * math.Pi * rand.Float64())
    return s * r, c * r
}
 
func main() {
    const (
        n     = 10000
        bins  = 12
        sig   = 3
        scale = 100
    )
    var sum, sumSq float64
    h := make([]int, bins)
    for i, accum := 0, func(v float64) {
        sum += v
        sumSq += v * v
        b := int((v + sig) * bins / sig / 2)
        if b >= 0 && b < bins {
            h[b]++
        }
    }; i < n/2; i++ {
        v1, v2 := norm2()
        accum(v1)
        accum(v2)
    }
    m := sum / n
    fmt.Println(""mean:"", m)
    fmt.Println(""stddev:"", math.Sqrt(sumSq/float64(n)-m*m))
    for _, p := range h {
        fmt.Println(strings.Repeat(""*"", p/scale))
    }
}",884,44
13049,http://rosettacode.org/wiki/Start_from_a_main_routine,Start from a main routine,"

Some languages (like Gambas and Visual Basic) support two startup modes.   Applications written in these languages start with an open window that waits for events, and it is necessary to do some trickery to cause a main procedure to run instead.   Data driven or event driven languages may also require similar trickery to force a startup procedure to run.



Task

Demonstrate the steps involved in causing the application to run a main procedure, rather than an event driven window at startup.

Languages that always run from main() can be omitted from this task.



",#Go,Go,"package main
 
import ""fmt""
 
var count = 0
 
func foo() {
    fmt.Println(""foo called"")
}
 
func init() {
    fmt.Println(""first init called"")
    foo()
}
 
func init() {
    fmt.Println(""second init called"")
    main()
}
 
func main() {
    count++
    fmt.Println(""main called when count is"", count)
}",304,24
13085,http://rosettacode.org/wiki/State_name_puzzle,State name puzzle,"Background

This task is inspired by Mark Nelson's DDJ Column ""Wordplay"" and one of the weekly puzzle challenges from Will Shortz on NPR Weekend Edition [1] and originally attributed to David Edelheit.

The challenge was to take the names of two U.S. States, mix them all together, then rearrange the letters to form the names of two different U.S. States (so that all four state names differ from one another).

What states are these?



The problem was reissued on the Unicon Discussion Web which includes several solutions with analysis. Several techniques may be helpful and you may wish to refer to Gödel numbering, equivalence relations, and equivalence classes. The basic merits of these were discussed in the Unicon Discussion Web.

A second challenge in the form of a set of fictitious new states was also presented.



Task

Write a program to solve the challenge using both the original list of states and the fictitious list.



Caveats

 case and spacing aren't significant - just letters (harmonize case)
 don't expect the names to be in any order - such as being sorted
 don't rely on names to be unique (eliminate duplicates - meaning if Iowa appears twice you can only use it once)


Comma separated list of state names used in the original puzzle:

    ""Alabama"",  ""Alaska"",  ""Arizona"",  ""Arkansas"",
    ""California"",  ""Colorado"",  ""Connecticut"",  ""Delaware"",  
    ""Florida"",  ""Georgia"",  ""Hawaii"",  ""Idaho"",  ""Illinois"",  
    ""Indiana"",  ""Iowa"",  ""Kansas"",  ""Kentucky"",  ""Louisiana"",
    ""Maine"",  ""Maryland"",  ""Massachusetts"",  ""Michigan"",
    ""Minnesota"",  ""Mississippi"",  ""Missouri"",  ""Montana"",
    ""Nebraska"",  ""Nevada"",  ""New Hampshire"",  ""New Jersey"",
    ""New Mexico"",  ""New York"",  ""North Carolina"",  ""North Dakota"",
    ""Ohio"",  ""Oklahoma"",  ""Oregon"",  ""Pennsylvania"",  ""Rhode Island"",
    ""South Carolina"",  ""South Dakota"",  ""Tennessee"",  ""Texas"",
    ""Utah"",  ""Vermont"",  ""Virginia"",
    ""Washington"",  ""West Virginia"",  ""Wisconsin"",  ""Wyoming""

Comma separated list of additional fictitious state names to be added to the original (Includes a duplicate):

""New Kory"",  ""Wen Kory"",  ""York New"",  ""Kory New"",  ""New Kory""




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""unicode""
)
 
var states = []string{""Alabama"", ""Alaska"", ""Arizona"", ""Arkansas"",
    ""California"", ""Colorado"", ""Connecticut"",
    ""Delaware"",
    ""Florida"", ""Georgia"", ""Hawaii"",
    ""Idaho"", ""Illinois"", ""Indiana"", ""Iowa"",
    ""Kansas"", ""Kentucky"", ""Louisiana"",
    ""Maine"", ""Maryland"", ""Massachusetts"", ""Michigan"",
    ""Minnesota"", ""Mississippi"", ""Missouri"", ""Montana"",
    ""Nebraska"", ""Nevada"", ""New Hampshire"", ""New Jersey"",
    ""New Mexico"", ""New York"", ""North Carolina"", ""North Dakota"",
    ""Ohio"", ""Oklahoma"", ""Oregon"",
    ""Pennsylvania"", ""Rhode Island"",
    ""South Carolina"", ""South Dakota"", ""Tennessee"", ""Texas"",
    ""Utah"", ""Vermont"", ""Virginia"",
    ""Washington"", ""West Virginia"", ""Wisconsin"", ""Wyoming""}
 
func main() {
    play(states)
    play(append(states,
        ""New Kory"", ""Wen Kory"", ""York New"", ""Kory New"", ""New Kory""))
}
 
func play(states []string) {
    fmt.Println(len(states), ""states:"")
    // get list of unique state names
    set := make(map[string]bool, len(states))
    for _, s := range states {
        set[s] = true
    }
    // make parallel arrays for unique state names and letter histograms
    s := make([]string, len(set))
    h := make([][26]byte, len(set))
    var i int
    for us := range set {
        s[i] = us
        for _, c := range us {
            if u := uint(unicode.ToLower(c)) - 'a'; u < 26 {
                h[i][u]++
            }
        }
        i++
    }
    // use map to find matches.  map key is sum of histograms of
    // two different states.  map value is indexes of the two states.
    type pair struct {
        i1, i2 int
    }
    m := make(map[string][]pair)
    b := make([]byte, 26) // buffer for summing histograms
    for i1, h1 := range h {
        for i2 := i1 + 1; i2 < len(h); i2++ {
            // sum histograms
            for i := range b {
                b[i] = h1[i] + h[i2][i]
            }
            k := string(b) // make key from buffer.
            // now loop over any existing pairs with the same key,
            // printing any where both states of this pair are different
            // than the states of the existing pair
            for _, x := range m[k] {
                if i1 != x.i1 && i1 != x.i2 && i2 != x.i1 && i2 != x.i2 {
                    fmt.Printf(""%s, %s = %s, %s\n"", s[i1], s[i2],
                        s[x.i1], s[x.i2])
                }
            }
            // store this pair in the map whether printed or not.
            m[k] = append(m[k], pair{i1, i2})
        }
    }
}",2543,77
13182,http://rosettacode.org/wiki/Stack_traces,Stack traces,"Many programming languages allow for introspection of the current call stack environment. This can be for a variety of purposes such as enforcing security checks, debugging, or for getting access to the stack frame of callers.



Task

Print out (in a manner considered suitable for the platform) the current call stack.

The amount of information printed for each frame on the call stack is not constrained, but should include at least the name of the function or method at that level of the stack frame.

You may explicitly add a call to produce the stack trace to the (example) code being instrumented for examination.

The task should allow the program to continue after generating the stack trace.

The task report here must include the trace from a sample program.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""runtime""
)
 
func main() {
    stackTrace := make([]byte, 1024)
    n := runtime.Stack(stackTrace, true)
    stackTrace = stackTrace[:n]
    fmt.Printf(""%s\n"", stackTrace)
    fmt.Printf(""(%d bytes)\n"", len(stackTrace))
}",260,14
13205,http://rosettacode.org/wiki/Stem-and-leaf_plot,Stem-and-leaf plot,"Create a well-formatted stem-and-leaf plot from the following data set, where the leaves are the last digits:

12 127 28 42 39 113 42 18 44 118 44 37 113 124 37 48 127 36 29 31 125 139 131 115 105 132 104 123 35 113 122 42 117 119 58 109 23 105 63 27 44 105 99 41 128 121 116 125 32 61 37 127 29 113 121 58 114 126 53 114 96 25 109 7 31 141 46 13 27 43 117 116 27 7 68 40 31 115 124 42 128 52 71 118 117 38 27 106 33  117 116 111 40 119 47 105 57 122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34 133 45 120 30 127 31 116 146
The primary intent of this task is the presentation of information. It is acceptable to hardcode the data set or characteristics of it (such as what the stems are) in the example, insofar as it is impractical to make the example generic to any data set. For example, in a computation-less language like HTML the data set may be entirely prearranged within the example; the interesting characteristics are how the proper visual formatting is arranged.

If possible, the output should not be a bitmap image. Monospaced plain text is acceptable, but do better if you can. It may be a window, i.e. not a file.


Note: If you wish to try multiple data sets, you might try this generator.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
    ""strconv""
    ""strings""
)
 
var data = `12 127 28 42` //...omitted...127 31 116 146`
 
func main() {
    // load data into map
    m := make(map[int][]string)
    for _, s := range strings.Fields(data) {
        if len(s) == 1 {
            m[0] = append(m[0], s)
        } else if i, err := strconv.Atoi(s[:len(s)-1]); err == nil {
            m[i] = append(m[i], s[len(s)-1:])
        } else {
            panic(""non numeric data"")
        }
    }
    // sort stem
    s := make([]int, len(m))
    var i int
    for k := range m {
        s[i] = k
        i++
    }
    sort.Ints(s)
    // print
    for k := s[0]; ; k++ {
        v := m[k]
        sort.Strings(v)
        fmt.Printf(""%2d | %s\n"", k, strings.Join(v, "" ""))
        if k == s[len(s)-1] {
            break
        }
    }
}",839,41
13244,http://rosettacode.org/wiki/Stair-climbing_puzzle,Stair-climbing puzzle,"From Chung-Chieh Shan (LtU):

Your stair-climbing robot has a very simple low-level API: the ""step"" function takes no argument and attempts to climb one step as a side effect. Unfortunately, sometimes the attempt fails and the robot clumsily falls one step instead. The ""step"" function detects what happens and returns a boolean flag: true on success, false on failure.

Write a function ""step_up"" that climbs one step up [from the initial position] (by repeating ""step"" attempts if necessary). Assume that the robot is not already at the top of the stairs, and neither does it ever reach the bottom of the stairs. How small can you make ""step_up""? Can you avoid using variables (even immutable ones) and numbers?

Here's a pseudo-code of a simple recursive solution without using variables:

func step_up()
{
    if not step() {
        step_up();
        step_up();
    }
}

Inductive proof that step_up() steps up one step, if it terminates:

 Base case (if the step() call returns true): it stepped up one step. QED
 Inductive case (if the step() call returns false): Assume that recursive calls to step_up() step up one step. It stepped down one step (because step() returned false), but now we step up two steps using two step_up() calls. QED


The second (tail) recursion above can be turned into an iteration, as follows:

func step_up()
{
    while not step() {
        step_up();
    }
}
",#Go,Go,func step_up(){for !step(){step_up()}},38,1
13263,http://rosettacode.org/wiki/Square_form_factorization,Square form factorization,"Task.
Daniel Shanks's Square Form Factorization (SquFoF).

Invented around 1975, ‘On a 32-bit computer, SquFoF is the clear champion factoring algorithm
for numbers between 1010 and 1018, and will likely remain so.’



An integral binary quadratic form is a polynomial
f(x,y) = ax2 + bxy + cy2
with integer coefficients and discriminant D = b2 – 4ac.
For each positive discriminant there are multiple forms (a, b, c).

The next form in a periodic sequence (cycle) of adjacent forms is found by applying a reduction operator
rho, essentially a variant of Euclid's algorithm for finding the continued fraction of a square root.
Using floor(√N), rho constructs a principal form
(1, b, c) with D = 4N.

SquFoF is based on the existence of cycles containing ambiguous forms, with the property that a divides b.
They come in pairs of associated forms (a, b, c) and (c, b, a) called symmetry points.
If an ambiguous form is found (there is one for each divisor of D), write the discriminant as
(ak)2 – 4ac = a(a·k2 – 4c) = 4N
and (if a is not equal to 1 or 2) N is split.

Shanks used square forms to jump to a random ambiguous cycle. Fact: if any form in an ambiguous cycle
is squared, that square form will always land in the principal cycle. Conversely, the square root of any
form in the principal cycle lies in an ambiguous cycle. (Possibly the principal cycle itself).

A square form is easy to find: the last coefficient c is a perfect square. This happens about once
every ∜N-th cycle step and for even indices only. Let rho compute the inverse square root form and track
the ambiguous cycle backward until the symmetry point is reached. (Taking the inverse reverses the cycle).
Then a or a/2 divides D and therefore N.

To avoid trivial factorizations, Shanks created a list (queue) to hold small coefficients appearing
early in the principal cycle, that may be roots of square forms found later on. If these forms are skipped,
no roots land in the principal cycle itself and cases a = 1 or a = 2 do not happen.

Sometimes the cycle length is too short to find a proper square form. This is fixed by running five instances
of SquFoF in parallel, with input N and 3, 5, 7, 11 times N; the discriminants then will have different periods.
If N is prime or the cube of a prime, there are improper squares only and the program will duly report failure.

Reference.
[1] A detailed analysis of SquFoF (2007)


",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func isqrt(x uint64) uint64 {
    x0 := x >> 1
    x1 := (x0 + x/x0) >> 1
    for x1 < x0 {
        x0 = x1
        x1 = (x0 + x/x0) >> 1
    }
    return x0
}
 
func gcd(x, y uint64) uint64 {
    for y != 0 {
        x, y = y, x%y
    }
    return x
}
 
var multiplier = []uint64{
    1, 3, 5, 7, 11, 3 * 5, 3 * 7, 3 * 11, 5 * 7, 5 * 11, 7 * 11, 3 * 5 * 7, 3 * 5 * 11, 3 * 7 * 11, 5 * 7 * 11, 3 * 5 * 7 * 11,
}
 
func squfof(N uint64) uint64 {
    s := uint64(math.Sqrt(float64(N)) + 0.5)
    if s*s == N {
        return s
    }
    for k := 0; k < len(multiplier) && N <= math.MaxUint64/multiplier[k]; k++ {
        D := multiplier[k] * N
        P := isqrt(D)
        Pprev := P
        Po := Pprev
        Qprev := uint64(1)
        Q := D - Po*Po
        L := uint32(isqrt(8 * s))
        B := 3 * L
        i := uint32(2)
        var b, q, r uint64
        for ; i < B; i++ {
            b = uint64((Po + P) / Q)
            P = b*Q - P
            q = Q
            Q = Qprev + b*(Pprev-P)
            r = uint64(math.Sqrt(float64(Q)) + 0.5)
            if (i&1) == 0 && r*r == Q {
                break
            }
            Qprev = q
            Pprev = P
        }
        if i >= B {
            continue
        }
        b = uint64((Po - P) / r)
        P = b*r + P
        Pprev = P
        Qprev = r
        Q = (D - Pprev*Pprev) / Qprev
        i = 0
        for {
            b = uint64((Po + P) / Q)
            Pprev = P
            P = b*Q - P
            q = Q
            Q = Qprev + b*(Pprev-P)
            Qprev = q
            i++
            if P == Pprev {
                break
            }
        }
        r = gcd(N, Qprev)
        if r != 1 && r != N {
            return r
        }
    }
    return 0
}
 
func main() {
    examples := []uint64{
        2501,
        12851,
        13289,
        75301,
        120787,
        967009,
        997417,
        7091569,
        13290059,
        42854447,
        223553581,
        2027651281,
        11111111111,
        100895598169,
        1002742628021,
        60012462237239,
        287129523414791,
        9007199254740931,
        11111111111111111,
        314159265358979323,
        384307168202281507,
        419244183493398773,
        658812288346769681,
        922337203685477563,
        1000000000000000127,
        1152921505680588799,
        1537228672809128917,
        4611686018427387877,
    }
    fmt.Println(""Integer              Factor     Quotient"")
    fmt.Println(""------------------------------------------"")
    for _, N := range examples {
        fact := squfof(N)
        quot := ""fail""
        if fact > 0 {
            quot = fmt.Sprintf(""%d"", N/fact)
        }
        fmt.Printf(""%-20d %-10d %s\n"", N, fact, quot)
    }
}",2805,127
13310,http://rosettacode.org/wiki/Stern-Brocot_sequence,Stern-Brocot sequence,"For this task, the Stern-Brocot sequence is to be generated by an algorithm similar to that employed in generating the Fibonacci sequence.

 The first and second members of the sequence are both 1:
     1, 1
 Start by considering the second member of the sequence
 Sum the considered member of the sequence and its precedent, (1 + 1) = 2, and append it to the end of the sequence:
     1, 1, 2
 Append the considered member of the sequence to the end of the sequence:
     1, 1, 2, 1
 Consider the next member of the series, (the third member i.e. 2)
 GOTO 3
 
         ─── Expanding another loop we get: ───

 Sum the considered member of the sequence and its precedent, (2 + 1) = 3, and append it to the end of the sequence:
     1, 1, 2, 1, 3
 Append the considered member of the sequence to the end of the sequence:
     1, 1, 2, 1, 3, 2
 Consider the next member of the series, (the fourth member i.e. 1)


The task is to

 Create a function/method/subroutine/procedure/... to generate the Stern-Brocot sequence of integers using the method outlined above.
 Show the first fifteen members of the sequence. (This should be: 1, 1, 2, 1, 3, 2, 3, 1, 4, 3, 5, 2, 5, 3, 4)
 Show the (1-based) index of where the numbers 1-to-10 first appears in the sequence.
 Show the (1-based) index of where the number 100 first appears in the sequence.
 Check that the greatest common divisor of all the two consecutive members of the series up to the 1000th member, is always one.

Show your output on this page.



Related tasks

   Fusc sequence.
   Continued fraction/Arithmetic


Ref

 Infinite Fractions - Numberphile (Video).
 Trees, Teeth, and Time: The mathematics of clock making. 
 A002487 The On-Line Encyclopedia of Integer Sequences.

",#Go,Go,"package main
 
import (
    ""fmt""
 
    ""sternbrocot""
)
 
func main() {
    // Task 1, using the conventional sort of generator that generates
    // terms endlessly.
    g := sb.Generator()
 
    // Task 2, demonstrating the generator.
    fmt.Println(""First 15:"")
    for i := 1; i <= 15; i++ {
        fmt.Printf(""%2d:  %d\n"", i, g())
    }
 
    // Task 2 again, showing a simpler technique that might or might not be
    // considered to ""generate"" terms.
    s := sb.New()
    fmt.Println(""First 15:"", s.FirstN(15))
 
    // Tasks 3 and 4.
    for _, x := range []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100} {
        fmt.Printf(""%3d at 1-based index %d\n"", x, 1+s.Find(x))
    }
 
    // Task 5.
    fmt.Println(""1-based indexes: gcd"")
    for n, f := range s.FirstN(1000)[:999] {
        g := gcd(f, (*s)[n+1])
        fmt.Printf(""%d,%d: gcd(%d, %d) = %d\n"", n+1, n+2, f, (*s)[n+1], g)
        if g != 1 {
            panic(""oh no!"")
            return
        }
    }
}
 
// gcd copied from greatest common divisor task
func gcd(x, y int) int {
    for y != 0 {
        x, y = y, x%y
    }
    return x
}",1109,48
13321,http://rosettacode.org/wiki/Square-free_integers,Square-free integers,"Task

Write a function to test if a number is   square-free.



A   square-free   is an integer which is divisible by no perfect square other
than   1   (unity).

For this task, only positive square-free numbers will be used.



Show here (on this page) all square-free integers (in a horizontal format) that are between:

   1   ───►   145     (inclusive)
   1 trillion   ───►   1 trillion + 145     (inclusive)


(One trillion = 1,000,000,000,000)



Show here (on this page) the count of square-free integers from:

   1   ───►   one hundred     (inclusive)
   1   ───►   one thousand     (inclusive)
   1   ───►   ten thousand     (inclusive)
   1   ───►   one hundred thousand     (inclusive)
   1   ───►   one million     (inclusive)


See also

   the Wikipedia entry:   square-free integer

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func sieve(limit uint64) []uint64 {
    primes := []uint64{2}
    c := make([]bool, limit+1) // composite = true
    // no need to process even numbers > 2
    p := uint64(3)
    for {
        p2 := p * p
        if p2 > limit {
            break
        }
        for i := p2; i <= limit; i += 2 * p {
            c[i] = true
        }
        for {
            p += 2
            if !c[p] {
                break
            }
        }
    }
    for i := uint64(3); i <= limit; i += 2 {
        if !c[i] {
            primes = append(primes, i)
        }
    }
    return primes
}
 
func squareFree(from, to uint64) (results []uint64) {
    limit := uint64(math.Sqrt(float64(to)))
    primes := sieve(limit)
outer:
    for i := from; i <= to; i++ {
        for _, p := range primes {
            p2 := p * p
            if p2 > i {
                break
            }
            if i%p2 == 0 {
                continue outer
            }
        }
        results = append(results, i)
    }
    return
}
 
const trillion uint64 = 1000000000000
 
func main() {
    fmt.Println(""Square-free integers from 1 to 145:"")
    sf := squareFree(1, 145)
    for i := 0; i < len(sf); i++ {
        if i > 0 && i%20 == 0 {
            fmt.Println()
        }
        fmt.Printf(""%4d"", sf[i])
    }
 
    fmt.Printf(""\n\nSquare-free integers from %d to %d:\n"", trillion, trillion+145)
    sf = squareFree(trillion, trillion+145)
    for i := 0; i < len(sf); i++ {
        if i > 0 && i%5 == 0 {
            fmt.Println()
        }
        fmt.Printf(""%14d"", sf[i])
    }
 
    fmt.Println(""\n\nNumber of square-free integers:\n"")
    a := [...]uint64{100, 1000, 10000, 100000, 1000000}
    for _, n := range a {
        fmt.Printf(""  from %d to %d = %d\n"", 1, n, len(squareFree(1, n)))
    }
}",1834,81
13387,http://rosettacode.org/wiki/SQL-based_authentication,SQL-based authentication,"This task has three parts:

 Connect to a MySQL database (connect_db)
 Create user/password records in the following table (create_user)
 Authenticate login requests against the table (authenticate_user)
This is the table definition:

CREATE TABLE users (
    userid INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(32) UNIQUE KEY NOT NULL,
    pass_salt tinyblob NOT NULL,
            -- a string of 16 random bytes
    pass_md5 tinyblob NOT NULL
            -- binary MD5 hash of pass_salt concatenated with the password
);
(pass_salt and pass_md5 would be binary(16) values, but MySQL versions before 5.0.15 strip trailing spaces when selecting them.)
",#Go,Go,"package main
 
import (
    ""bytes""
    ""crypto/md5""
    ""crypto/rand""
    ""database/sql""
    ""fmt""
 
    _ ""github.com/go-sql-driver/mysql""
)
 
func connectDB() (*sql.DB, error) {
    return sql.Open(""mysql"", ""rosetta:code@/rc"")
}
 
func createUser(db *sql.DB, user, pwd string) error {
    salt := make([]byte, 16)
    rand.Reader.Read(salt)
    _, err := db.Exec(`insert into users (username, pass_salt, pass_md5)
        values (?, ?, ?)`, user, salt, saltHash(salt, pwd))
    if err != nil {
        return fmt.Errorf(""User %s already exits"", user)
    }
    return nil
}
 
func authenticateUser(db *sql.DB, user, pwd string) error {
    var salt, hash []byte
    row := db.QueryRow(`select pass_salt, pass_md5 from users
        where username=?`, user)
    if err := row.Scan(&salt, &hash); err != nil {
        return fmt.Errorf(""User %s unknown"", user)
    }
    if !bytes.Equal(saltHash(salt, pwd), hash) {
        return fmt.Errorf(""User %s invalid password"", user)
    }
    return nil
}
 
func saltHash(salt []byte, pwd string) []byte {
    h := md5.New()
    h.Write(salt)
    h.Write([]byte(pwd))
    return h.Sum(nil)
}
 
func main() {
    // demonstrate
    db, err := connectDB()
    defer db.Close()
    createUser(db, ""sam"", ""123"")
    err = authenticateUser(db, ""sam"", ""123"")
    if err == nil {
        fmt.Println(""User sam authenticated"")
    }
 
    // extra
    fmt.Println()
    // show contents of database
    rows, _ := db.Query(`select username, pass_salt, pass_md5 from users`)
    var user string
    var salt, hash []byte
    for rows.Next() {
        rows.Scan(&user, &salt, &hash)
        fmt.Printf(""%s %x %x\n"", user, salt, hash)
    }
    // try creating same user again
    err = createUser(db, ""sam"", ""123"")
    fmt.Println(err)
    // try authenticating unknown user
    err = authenticateUser(db, ""pam"", ""123"")
    fmt.Println(err)
    // try wrong password
    err = authenticateUser(db, ""sam"", ""1234"")
    fmt.Println(err)
    // clear table to run program again
    db.Exec(`truncate table users`)
}",2045,79
13446,http://rosettacode.org/wiki/Statistics/Basic,Statistics/Basic,"Statistics is all about large groups of numbers.
When talking about a set of sampled data, most frequently used is their mean value and standard deviation (stddev).
If you have set of data 




x

i




{\displaystyle x_{i}}

 where 



i
=
1
,
2
,
…
,
n




{\displaystyle i=1,2,\ldots ,n\,\!}

, the mean is 






x
¯



≡


1
n



∑

i



x

i




{\displaystyle {\bar {x}}\equiv {1 \over n}\sum _{i}x_{i}}

, while the stddev is 



σ
≡




1
n



∑

i




(

x

i


−



x
¯



)


2






{\displaystyle \sigma \equiv {\sqrt {{1 \over n}\sum _{i}\left(x_{i}-{\bar {x}}\right)^{2}}}}

.

When examining a large quantity of data, one often uses a histogram, which shows the counts of data samples falling into a prechosen set of intervals (or bins).
When plotted, often as bar graphs, it visually indicates how often each data value occurs.

Task Using your language's random number routine, generate real numbers in the range of [0, 1]. It doesn't matter if you chose to use open or closed range.
Create 100 of such numbers (i.e. sample size 100) and calculate their mean and stddev.
Do so for sample size of 1,000 and 10,000, maybe even higher if you feel like.
Show a histogram of any of these sets.
Do you notice some patterns about the standard deviation?

Extra Sometimes so much data need to be processed that it's impossible to keep all of them at once. Can you calculate the mean, stddev and histogram of a trillion numbers? (You don't really need to do a trillion numbers, just show how it can be done.)

Hint

For a finite population with equal probabilities at all points, one can derive:








(
x
−


x
¯



)

2



¯


=



x

2


¯


−



x
¯



2




{\displaystyle {\overline {(x-{\overline {x}})^{2}}}={\overline {x^{2}}}-{\overline {x}}^{2}}


Or, more verbosely:







1
N



∑

i
=
1


N


(

x

i


−


x
¯



)

2


=


1
N



(

∑

i
=
1


N



x

i


2


)

−



x
¯



2


.


{\displaystyle {\frac {1}{N}}\sum _{i=1}^{N}(x_{i}-{\overline {x}})^{2}={\frac {1}{N}}\left(\sum _{i=1}^{N}x_{i}^{2}\right)-{\overline {x}}^{2}.}


See also
 Statistics/Normal distribution
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/rand""
    ""strings""
)
 
func main() {
    sample(100)
    sample(1000)
    sample(10000)
}
 
func sample(n int) {
    // generate data
    d := make([]float64, n)
    for i := range d {
        d[i] = rand.Float64()
    }
    // show mean, standard deviation
    var sum, ssq float64
    for _, s := range d {
        sum += s
        ssq += s * s
    }
    fmt.Println(n, ""numbers"")
    m := sum / float64(n)
    fmt.Println(""Mean:  "", m)
    fmt.Println(""Stddev:"", math.Sqrt(ssq/float64(n)-m*m))
    // show histogram
    h := make([]int, 10)
    for _, s := range d {
        h[int(s*10)]++
    }
    for _, c := range h {
        fmt.Println(strings.Repeat(""*"", c*205/int(n)))
    }
    fmt.Println()
}",761,41
13544,http://rosettacode.org/wiki/Speech_synthesis,Speech synthesis,"Render the text       This is an example of speech synthesis      as speech.



Related task

   using a speech engine to highlight words



",#Go,Go,"package main
 
import (
    ""go/build""
    ""log""
    ""path/filepath""
 
    ""github.com/unixpickle/gospeech""
    ""github.com/unixpickle/wav""
)
 
const pkgPath = ""github.com/unixpickle/gospeech""
const input = ""This is an example of speech synthesis.""
 
func main() {
    p, err := build.Import(pkgPath, ""."", build.FindOnly)
    if err != nil {
        log.Fatal(err)
    }
    d := filepath.Join(p.Dir, ""dict/cmudict-IPA.txt"")
    dict, err := gospeech.LoadDictionary(d)
    if err != nil {
        log.Fatal(err)
    }
    phonetics := dict.TranslateToIPA(input)
    synthesized := gospeech.DefaultVoice.Synthesize(phonetics)
    wav.WriteFile(synthesized, ""output.wav"")
}",671,28
13641,http://rosettacode.org/wiki/Spinning_rod_animation/Text,Spinning rod animation/Text,"Task

An animation with the following frames in the following order (if certain characters aren't available or can't be used correctly in the programming language, alternate characters can replace any of these frames) must animate with a delay of 0.25 seconds between each frame, with the previous frame being cleared before the next frame appears: 

   |
   /
   - or ─
   \



A stand-alone version that loops and/or a version that doesn't loop can be made. These examples can also be converted into a system used in game development which is called on a HUD or GUI element requiring it to be called each frame to output the text, and advance the frame when the frame delay has passed. You can also use alternate text such as the . animation ( . | .. | ... | .. | repeat from . ) or the logic can be updated to include a ping/pong style where the frames advance forward, reach the end and then play backwards and when they reach the beginning they start over ( technically, you'd stop one frame prior to prevent the first frame playing twice, or write it another way ).



There are many different ways you can incorporate text animations. Here are a few text ideas - each frame is in quotes. If you can think of any, add them to this page! There are 2 examples for several of these; the first is the base animation with only unique sets of characters. The second consists of the primary set from a - n and doubled, minus the first and last element ie: We only want the center. This way an animation can play forwards, and then in reverse ( ping ponging ) without having to code that feature. For the animations with 3 elements, we only add 1, the center. with 4, it becomes 6. with 10, it becomes 18.



We don't need the second option for some of the animations if they connect smoothly, when animated, back to the first element. ... doesn't connect with . cleanly - there is a large leap. The rotating pipe meets the first perfectly so it isn't necessary, etc..





   Dots - Option A requires ping / pong enabled script. Option B just adds the elements in the center.
   '.', '..', '...'
   '.', '..', '...', '..'
   Pipe - This has the uniform sideways pipe instead of a hyphen to prevent non-uniform sizing.
   '|', '/', '─', '\'
   Stars - Option A requires ping / pong enabled script. Option B just adds the elements from the center.
   '⁎', '⁑', '⁂'
   '⁎', '⁑', '⁂', '⁑'
   Clock - These need to be ordered. I haven't done this yet as the application I was testing the system in doesn't support these wingdings / icons. But this would look quite nice and you could set it up to go forward, or backward during an undo process, etc..
   '🕛', '🕧', '🕐', '🕜', '🕑', '🕝', '🕒', '🕞', '🕓', '🕟', '🕔', '🕠', '🕕', '🕖', '🕗', '🕘', '🕙', '🕚', '🕡', '🕢', '🕣', '🕤', '🕥', '🕦'
   Arrows:
   '⬍', '⬈', '➞', '⬊', '⬍', '⬋', '⬅', '⬉'
   Bird - This looks decent but may be missing something.
   '︷', '︵', '︹', '︺', '︶', '︸'
   '︷', '︵', '︹', '︺', '︶', '︸', '︶', '︺', '︹', '︵'
   Plants - This isn't quite complete
   '☘', '❀', '❁'
   '☘', '❀', '❁', '❀'
   Eclipse - From Raku Throbber post author
   '🌑', '🌒', '🌓', '🌔', '🌕', '🌖', '🌗', '🌘'

",#Go,Go,"package main
 
import (
    ""fmt""
    ""time""
)
 
func main() {
    a := `|/-\`
    fmt.Printf(""\033[?25l"")  // hide the cursor
    start := time.Now()
    for {
        for i := 0; i < 4; i++ {
            fmt.Print(""\033[2J"")       // clear terminal
            fmt.Printf(""\033[0;0H"")    // place cursor at top left corner
            for j := 0; j < 80; j++ {  // 80 character terminal width, say
                fmt.Printf(""%c"", a[i])
            }
            time.Sleep(250 * time.Millisecond)
        }
        if time.Since(start).Seconds() >= 20.0 { // stop after 20 seconds, say
            break
        }
    }
    fmt.Print(""\033[?25h"") // restore the cursor
}",673,26
13661,http://rosettacode.org/wiki/Square_but_not_cube,Square but not cube,"Task

Show the first   30   positive integers which are squares but not cubes of such integers.

Optionally, show also the first   3   positive integers which are both squares and cubes,   and mark them as such.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func main() {
    for n, count := 1, 0; count < 30; n++ {
        sq := n * n
        cr := int(math.Cbrt(float64(sq)))
        if cr*cr*cr != sq {
            count++
            fmt.Println(sq)
        } else {
            fmt.Println(sq, ""is square and cube"")
        }
    }
}",329,19
13721,http://rosettacode.org/wiki/Split_a_character_string_based_on_change_of_character,Split a character string based on change of character,"

Task

Split a (character) string into comma (plus a blank) delimited
strings based on a change of character   (left to right).

Show the output here   (use the 1st example below).



Blanks should be treated as any other character   (except
they are problematic to display clearly).   The same applies
to commas.



For instance, the string:

 gHHH5YY++///\ 

should be split and show:

 g, HHH, 5, YY, ++, ///, \ 




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func main() {
    fmt.Println(scc(`gHHH5YY++///\`))
}
 
func scc(s string) string {
    if len(s) < 2 {
        return s
    }
    var b strings.Builder
    p := s[0]
    b.WriteByte(p)
    for _, c := range []byte(s[1:]) {
        if c != p {
            b.WriteString("", "")
        }
        b.WriteByte(c)
        p = c
    }
    return b.String()
}",404,27
13730,http://rosettacode.org/wiki/Spelling_of_ordinal_numbers,Spelling of ordinal numbers,"Ordinal numbers   (as used in this Rosetta Code task),   are numbers that describe the   position   of something in a list.

It is this context that ordinal numbers will be used, using an English-spelled name of an ordinal number.



The ordinal numbers are   (at least, one form of them):

  1st  2nd  3rd  4th  5th  6th  7th  ···  99th  100th  ···  1000000000th  ···  etc

sometimes expressed as:

  1st  2nd  3rd  4th  5th  6th  7th  ···  99th  100th  ···  1000000000th  ···



For this task, the following (English-spelled form) will be used:

  first second third fourth fifth sixth seventh ninety-nineth one hundredth one billionth



Furthermore, the American version of numbers will be used here   (as opposed to the British).

2,000,000,000   is two billion,   not   two milliard.



Task

Write a driver and a function (subroutine/routine ···) that returns the English-spelled ordinal version of a specified number   (a positive integer).

Optionally, try to support as many forms of an integer that can be expressed:   123   00123.0   1.23e2   all are forms of the same integer.

Show all output here.



Test cases

Use (at least) the test cases of:

  1  2  3  4  5  11  65  100  101  272  23456  8007006005004003



Related tasks

   Number names
   N'th

",#Go,Go,"import (
	""fmt""
	""strings""
)
 
func main() {
	for _, n := range []int64{
		1, 2, 3, 4, 5, 11, 65, 100, 101, 272, 23456, 8007006005004003,
	} {
		fmt.Println(sayOrdinal(n))
	}
}
 
var irregularOrdinals = map[string]string{
	""one"":    ""first"",
	""two"":    ""second"",
	""three"":  ""third"",
	""five"":   ""fifth"",
	""eight"":  ""eighth"",
	""nine"":   ""ninth"",
	""twelve"": ""twelfth"",
}
 
func sayOrdinal(n int64) string {
	s := say(n)
	i := strings.LastIndexAny(s, "" -"")
	i++
	// Now s[:i] is everything upto and including the space or hyphen
	// and s[i:] is the last word; we modify s[i:] as required.
	// Since LastIndex returns -1 if there was no space/hyphen,
	// `i` will be zero and this will still be fine.
	if x, ok := irregularOrdinals[s[i:]]; ok {
		s = s[:i] + x
	} else if s[len(s)-1] == 'y' {
		s = s[:i] + s[i:len(s)-1] + ""ieth""
	} else {
		s = s[:i] + s[i:] + ""th""
	}
	return s
}
 
// Below is a copy of https://rosettacode.org/wiki/Number_names#Go
 
var small = [...]string{""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"",
	""seven"", ""eight"", ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"",
	""fourteen"", ""fifteen"", ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen""}
var tens = [...]string{"""", """", ""twenty"", ""thirty"", ""forty"",
	""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""}
var illions = [...]string{"""", "" thousand"", "" million"", "" billion"",
	"" trillion"", "" quadrillion"", "" quintillion""}
 
func say(n int64) string {
	var t string
	if n < 0 {
		t = ""negative ""
		// Note, for math.MinInt64 this leaves n negative.
		n = -n
	}
	switch {
	case n < 20:
		t += small[n]
	case n < 100:
		t += tens[n/10]
		s := n % 10
		if s > 0 {
			t += ""-"" + small[s]
		}
	case n < 1000:
		t += small[n/100] + "" hundred""
		s := n % 100
		if s > 0 {
			t += "" "" + say(s)
		}
	default:
		// work right-to-left
		sx := """"
		for i := 0; n > 0; i++ {
			p := n % 1000
			n /= 1000
			if p > 0 {
				ix := say(p) + illions[i]
				if sx != """" {
					ix += "" "" + sx
				}
				sx = ix
			}
		}
		t += sx
	}
	return t
}",1990,91
13871,http://rosettacode.org/wiki/Special_variables,Special variables,"Special variables have a predefined meaning within a computer programming language.



Task

List the special variables used within the language.



",#Go,Go," 
# &keyword # type returned(indicators) - brief description
# indicators:
#    * - generates multiple values
#    = - modifiable
#    ? - may fail (e.g. status inquiry)
#    U - Unicon
#    G - Icon or Unicon with Graphics
#
&allocated   # integer(*) - report memory allocated in total and by storage regions
&ascii       # cset -  ASCII character set
&clock       # string - time of day
&col         # integer(=G) - column location of pointer
&collections # integer(*) - garbage collection activity in total and by storage region
&column      # integer(U) - source code column
&control     # null(?G) - control key state
&cset        # cset - universal character set
&current     # co-expression - current co-expression
&date        # string - today's date
&dateline    # string - time stamp
&digits      # cset - digit characters
&dump        # integer(=) - termination dump
&e           # real - natural log e
&error       # integer(=) - enable/disable error conversion/fail on error
&errno       # integer(?) - variable containing error number from previous posix command
&errornumber # integer(?) - error number of last error converted to failure
&errortext   # string(?) - error message of last error converted to failure
&errorvalue  # any(?) - erroneous value of last error converted to failure
&errout      # file - standard error file
&eventcode   # integer(=U) - program execution event in monitored program
&eventsource # co-expression(=U) - source of events in monitoring program
&eventvalue  # any(=U) - value from event in monitored program
&fail        # none - always fails
&features    # string(*) - identifying features in this version of Icon/Unicon
&file        # string -  current source file
&host        # string - host machine name
&input       # file - standard input file
&interval    # integer(G) - time between input events
&lcase       # cset - lowercase letters
&ldrag       # integer(G) - left button drag
&letters     # cset - letters
&level       # integer - call depth
&line        # integer - current source line number
&lpress      # integer(G) - left button press
&lrelease    # integer(G) - left button release
&main        # co-expression - main task
&mdrag       # integer(G) - middle button drag
&meta        # null(?G) - meta key state
&mpress      # integer(G) - middle button press
&mrelease    # integer(G) - middle button release
&now         # integer(U) - current time
&null        # null - null value
&output      # file - standard output file
&pick        # string (U) - variable containing the result of 3D selection
&phi         # real - golden ratio
&pos         # integer(=) - string scanning position
&progname    # string(=) - program name
&random      # integer(=) - random number seed
&rdrag       # integer(G) - right button drag
&regions     # integer(*) - region sizes
&resize      # integer(G) - window resize
&row         # integer(=G) - row location of pointer
&rpress      # integer(G) - right button press
&rrelease    # integer(G) - right button release
&shift       # null(?G) - shift key state
&source      # co-expression - invoking co-expression
&storage     # integer(*) - memory in use in each region
&subject     # string - string scanning subject
&syserr      # integer - halt on system error
&time        # integer(=) - elapsed time in milliseconds
&trace       # integer(=) - trace program
&ucase       # cset - upper case letters
&version     # string - version
&window      # window(=G) - the current graphics rendering window
&x           # integer(=G) - pointer horizontal position
&y           # integer(=G) - pointer vertical position
# keywords may also fail if the corresponding feature is not present.
# Other variants of Icon (e.g. MT-Icon) will have different mixes of keywords.",3768,78
13928,http://rosettacode.org/wiki/Stable_marriage_problem,Stable marriage problem,"Solve the Stable marriage problem using the Gale/Shapley algorithm.


Problem description

Given an equal number of men and women to be paired for marriage, each man ranks all the women in order of his preference and each woman ranks all the men in order of her preference.

A stable set of engagements for marriage is one where no man prefers a woman over the one he is engaged to, where that other woman also prefers that man over the one she is engaged to. I.e. with consulting marriages, there would be no reason for the engagements between the people to change.

Gale and Shapley proved that there is a stable set of engagements for any set of preferences and the first link above gives their algorithm for finding a set of stable engagements.


Task Specifics

Given ten males:

   abe, bob, col, dan, ed, fred, gav, hal, ian, jon

And ten females:

   abi, bea, cath, dee, eve, fay, gay, hope, ivy, jan

And a complete list of ranked preferences, where the most liked is to the left:

  abe: abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay
  bob: cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay
  col: hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan
  dan: ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi
   ed: jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay
 fred: bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay
  gav: gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay
  hal: abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee
  ian: hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve
  jon: abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope
   
  abi: bob, fred, jon, gav, ian, abe, dan, ed, col, hal
  bea: bob, abe, col, fred, gav, dan, ian, ed, jon, hal
 cath: fred, bob, ed, gav, hal, col, ian, abe, dan, jon
  dee: fred, jon, col, abe, ian, hal, gav, dan, bob, ed
  eve: jon, hal, fred, dan, abe, gav, col, ed, ian, bob
  fay: bob, abe, ed, ian, jon, dan, fred, gav, col, hal
  gay: jon, gav, hal, fred, bob, abe, col, ed, dan, ian
 hope: gav, jon, bob, abe, ian, dan, hal, ed, col, fred
  ivy: ian, col, hal, gav, fred, bob, abe, ed, jon, dan
  jan: ed, hal, gav, abe, bob, jon, col, ian, fred, dan

 Use the Gale Shapley algorithm to find a stable set of engagements
 Perturb this set of engagements to form an unstable set of engagements then check this new set for stability.

References

 The Stable Marriage Problem. (Eloquent description and background information).
 Gale-Shapley Algorithm Demonstration.
 Another Gale-Shapley Algorithm Demonstration.
 Stable Marriage Problem - Numberphile (Video).
 Stable Marriage Problem (the math bit) (Video).
 The Stable Marriage Problem and School Choice. (Excellent exposition)

",#Go,Go,"package main
 
import ""fmt""
 
// Asymetry in the algorithm suggests different data structures for the
// map value types of the proposers and the recipients.  Proposers go down
// their list of preferences in order, and do not need random access.
// Recipients on the other hand must compare their preferences to arbitrary
// proposers.  A slice is adequate for proposers, but a map allows direct
// lookups for recipients and avoids looping code.
type proposers map[string][]string
 
var mPref = proposers{
    ""abe"": []string{
        ""abi"", ""eve"", ""cath"", ""ivy"", ""jan"",
        ""dee"", ""fay"", ""bea"", ""hope"", ""gay""},
    ""bob"": []string{
        ""cath"", ""hope"", ""abi"", ""dee"", ""eve"",
        ""fay"", ""bea"", ""jan"", ""ivy"", ""gay""},
    ""col"": []string{
        ""hope"", ""eve"", ""abi"", ""dee"", ""bea"",
        ""fay"", ""ivy"", ""gay"", ""cath"", ""jan""},
    ""dan"": []string{
        ""ivy"", ""fay"", ""dee"", ""gay"", ""hope"",
        ""eve"", ""jan"", ""bea"", ""cath"", ""abi""},
    ""ed"": []string{
        ""jan"", ""dee"", ""bea"", ""cath"", ""fay"",
        ""eve"", ""abi"", ""ivy"", ""hope"", ""gay""},
    ""fred"": []string{
        ""bea"", ""abi"", ""dee"", ""gay"", ""eve"",
        ""ivy"", ""cath"", ""jan"", ""hope"", ""fay""},
    ""gav"": []string{
        ""gay"", ""eve"", ""ivy"", ""bea"", ""cath"",
        ""abi"", ""dee"", ""hope"", ""jan"", ""fay""},
    ""hal"": []string{
        ""abi"", ""eve"", ""hope"", ""fay"", ""ivy"",
        ""cath"", ""jan"", ""bea"", ""gay"", ""dee""},
    ""ian"": []string{
        ""hope"", ""cath"", ""dee"", ""gay"", ""bea"",
        ""abi"", ""fay"", ""ivy"", ""jan"", ""eve""},
    ""jon"": []string{
        ""abi"", ""fay"", ""jan"", ""gay"", ""eve"",
        ""bea"", ""dee"", ""cath"", ""ivy"", ""hope""},
}
 
type recipients map[string]map[string]int
 
var wPref = recipients{
    ""abi"": map[string]int{
        ""bob"": 1, ""fred"": 2, ""jon"": 3, ""gav"": 4, ""ian"": 5,
        ""abe"": 6, ""dan"": 7, ""ed"": 8, ""col"": 9, ""hal"": 10},
    ""bea"": map[string]int{
        ""bob"": 1, ""abe"": 2, ""col"": 3, ""fred"": 4, ""gav"": 5,
        ""dan"": 6, ""ian"": 7, ""ed"": 8, ""jon"": 9, ""hal"": 10},
    ""cath"": map[string]int{
        ""fred"": 1, ""bob"": 2, ""ed"": 3, ""gav"": 4, ""hal"": 5,
        ""col"": 6, ""ian"": 7, ""abe"": 8, ""dan"": 9, ""jon"": 10},
    ""dee"": map[string]int{
        ""fred"": 1, ""jon"": 2, ""col"": 3, ""abe"": 4, ""ian"": 5,
        ""hal"": 6, ""gav"": 7, ""dan"": 8, ""bob"": 9, ""ed"": 10},
    ""eve"": map[string]int{
        ""jon"": 1, ""hal"": 2, ""fred"": 3, ""dan"": 4, ""abe"": 5,
        ""gav"": 6, ""col"": 7, ""ed"": 8, ""ian"": 9, ""bob"": 10},
    ""fay"": map[string]int{
        ""bob"": 1, ""abe"": 2, ""ed"": 3, ""ian"": 4, ""jon"": 5,
        ""dan"": 6, ""fred"": 7, ""gav"": 8, ""col"": 9, ""hal"": 10},
    ""gay"": map[string]int{
        ""jon"": 1, ""gav"": 2, ""hal"": 3, ""fred"": 4, ""bob"": 5,
        ""abe"": 6, ""col"": 7, ""ed"": 8, ""dan"": 9, ""ian"": 10},
    ""hope"": map[string]int{
        ""gav"": 1, ""jon"": 2, ""bob"": 3, ""abe"": 4, ""ian"": 5,
        ""dan"": 6, ""hal"": 7, ""ed"": 8, ""col"": 9, ""fred"": 10},
    ""ivy"": map[string]int{
        ""ian"": 1, ""col"": 2, ""hal"": 3, ""gav"": 4, ""fred"": 5,
        ""bob"": 6, ""abe"": 7, ""ed"": 8, ""jon"": 9, ""dan"": 10},
    ""jan"": map[string]int{
        ""ed"": 1, ""hal"": 2, ""gav"": 3, ""abe"": 4, ""bob"": 5,
        ""jon"": 6, ""col"": 7, ""ian"": 8, ""fred"": 9, ""dan"": 10},
}
 
func main() {
    // get parings by Gale/Shapley algorithm
    ps := pair(mPref, wPref)
    // show results
    fmt.Println(""\nresult:"")
    if !validateStable(ps, mPref, wPref) {
        return 
    }
    // perturb
    for {
        i := 0 
        var w2, m2 [2]string
        for w, m := range ps {
            w2[i] = w
            m2[i] = m
            if i == 1 {
                break
            }
            i++
        }
        fmt.Println(""\nexchanging partners of"", m2[0], ""and"", m2[1])
        ps[w2[0]] = m2[1]
        ps[w2[1]] = m2[0] 
        // validate perturbed parings
        if !validateStable(ps, mPref, wPref) {
            return
        }
        // if those happened to be stable as well, perturb more
    }
}   
 
type parings map[string]string // map[recipient]proposer (or map[w]m)
 
// Pair implements the Gale/Shapley algorithm.
func pair(pPref proposers, rPref recipients) parings {
    // code is destructive on the maps, so work with copies
    pFree := proposers{}
    for k, v := range pPref {
        pFree[k] = append([]string{}, v...)
    }
    rFree := recipients{}
    for k, v := range rPref {
        rFree[k] = v
    }
    // struct only used in this function.
    // preferences must be saved in case engagement is broken.
    type save struct {
        proposer string
        pPref    []string
        rPref    map[string]int
    }
    proposals := map[string]save{} // key is recipient (w)
 
    // WP pseudocode comments prefaced with WP: m is proposer, w is recipient.
    // WP: while ∃ free man m who still has a woman w to propose to
    for len(pFree) > 0 { // while there is a free proposer,
        var proposer string
        var ppref []string
        for proposer, ppref = range pFree {
            break // pick a proposer at random, whatever range delivers first.
        }
        if len(ppref) == 0 {
            continue // if proposer has no possible recipients, skip
        }
        // WP: w = m's highest ranked such woman to whom he has not yet proposed
        recipient := ppref[0] // highest ranged is first in list.
        ppref = ppref[1:]     // pop from list
        var rpref map[string]int
        var ok bool
        // WP: if w is free
        if rpref, ok = rFree[recipient]; ok {
            // WP: (m, w) become engaged
            // (common code follows if statement)
        } else {
            // WP: else some pair (m', w) already exists
            s := proposals[recipient] // get proposal saved preferences
            // WP: if w prefers m to m'
            if s.rPref[proposer] < s.rPref[s.proposer] {
                fmt.Println(""engagement broken:"", recipient, s.proposer)
                // WP: m' becomes free
                pFree[s.proposer] = s.pPref // return proposer to the map
                // WP: (m, w) become engaged
                rpref = s.rPref
                // (common code follows if statement)
            } else {
                // WP: else (m', w) remain engaged
                pFree[proposer] = ppref // update preferences in map
                continue
            } 
        }
        fmt.Println(""engagement:"", recipient, proposer)
        proposals[recipient] = save{proposer, ppref, rpref}
        delete(pFree, proposer)
        delete(rFree, recipient)
    }
    // construct return value 
    ps := parings{}
    for recipient, s := range proposals {
        ps[recipient] = s.proposer
    }
    return ps
}
 
func validateStable(ps parings, pPref proposers, rPref recipients) bool {
    for r, p := range ps {
        fmt.Println(r, p)
    }
    for r, p := range ps {
        for _, rp := range pPref[p] {
            if rp == r {
                break
            }
            rprefs := rPref[rp]
            if rprefs[p] < rprefs[ps[rp]] {
                fmt.Println(""unstable."")
                fmt.Printf(""%s and %s would prefer each other over""+
                    "" their current pairings.\n"", p, rp)
                return false
            }
        }
    }
    fmt.Println(""stable."")
    return true
}",7191,204
13956,http://rosettacode.org/wiki/Sorting_algorithms/Strand_sort,Sorting algorithms/Strand sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Strand sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Implement the Strand sort.

This is a way of sorting numbers by extracting shorter sequences of already sorted numbers from an unsorted list.



",#Go,Go,"package main
 
import ""fmt""
 
type link struct {
    int
    next *link
}
 
func linkInts(s []int) *link {
    if len(s) == 0 {
        return nil
    }
    return &link{s[0], linkInts(s[1:])}
}
 
func (l *link) String() string {
    if l == nil {
        return ""nil""
    }
    r := fmt.Sprintf(""[%d"", l.int)
    for l = l.next; l != nil; l = l.next {
        r = fmt.Sprintf(""%s %d"", r, l.int)
    }
    return r + ""]""
}
 
func main() {
    a := linkInts([]int{170, 45, 75, -90, -802, 24, 2, 66})
    fmt.Println(""before:"", a)
    b := strandSort(a)
    fmt.Println(""after: "", b)
}
 
func strandSort(a *link) (result *link) {
    for a != nil {
        // build sublist
        sublist := a
        a = a.next
        sTail := sublist
        for p, pPrev := a, a; p != nil; p = p.next {
            if p.int > sTail.int {
                // append to sublist
                sTail.next = p
                sTail = p
                // remove from a
                if p == a {
                    a = p.next
                } else {
                    pPrev.next = p.next
                }
            } else {
                pPrev = p
            }
        }
        sTail.next = nil // terminate sublist
        if result == nil {
            result = sublist
            continue
        }
        // merge
        var m, rr *link
        if sublist.int < result.int {
            m = sublist
            sublist = m.next
            rr = result
        } else {
            m = result
            rr = m.next
        }
        result = m
        for {
            if sublist == nil {
                m.next = rr
                break
            }
            if rr == nil {
                m.next = sublist
                break
            }
            if sublist.int < rr.int {
                m.next = sublist
                m = sublist
                sublist = m.next
            } else {
                m.next = rr
                m = rr
                rr = m.next
            }
        }
    }
    return
}",2027,93
14031,http://rosettacode.org/wiki/Sparkline_in_unicode,Sparkline in unicode,"A sparkline is a graph of successive values laid out horizontally
where the height of the line is proportional to the values in succession.



Task

Use the following series of Unicode characters to create a program
that takes a series of numbers separated by one or more whitespace or comma characters
and generates a sparkline-type bar graph of the values on a single line of output.

The eight characters: '▁▂▃▄▅▆▇█'

(Unicode values U+2581 through U+2588).

Use your program to show sparklines for the following input,
here on this page:

 1 2 3 4 5 6 7 8 7 6 5 4 3 2 1
 1.5, 0.5 3.5, 2.5 5.5, 4.5 7.5, 6.5 
(note the mix of separators in this second case)!
Notes
 
 A space is not part of the generated sparkline.
 The sparkline may be accompanied by simple statistics of the data such as its range.
 A suggestion emerging in later discussion (see Discussion page) is that the bounds between bins should ideally be set to yield the following results for two particular edge cases:
 ""0, 1, 19, 20"" -> ▁▁██
 (Aiming to use just two spark levels)
 ""0, 999, 4000, 4999, 7000, 7999"" -> ▁▁▅▅██
 (Aiming to use just three spark levels)
 It may be helpful to include these cases in output tests.
 You may find that the unicode sparklines on this page are rendered less noisily by Google Chrome than by Firefox or Safari.

",#Go,Go,"package main
 
import (
    ""bufio""
    ""errors""
    ""fmt""
    ""math""
    ""os""
    ""regexp""
    ""strconv""
    ""strings""
)
 
func main() {
    fmt.Println(""Numbers please separated by space/commas:"")
    sc := bufio.NewScanner(os.Stdin)
    sc.Scan()
    s, n, min, max, err := spark(sc.Text())
    if err != nil {
        fmt.Println(err)
        return
    }
    if n == 1 {
        fmt.Println(""1 value ="", min)
    } else {
        fmt.Println(n, ""values.  Min:"", min, ""Max:"", max)
    }
    fmt.Println(s)
}
 
var sep = regexp.MustCompile(`[\s,]+`)
 
func spark(s0 string) (sp string, n int, min, max float64, err error) {
    ss := sep.Split(s0, -1)
    n = len(ss)
    vs := make([]float64, n)
    var v float64
    min = math.Inf(1)
    max = math.Inf(-1)
    for i, s := range ss {
        switch v, err = strconv.ParseFloat(s, 64); {
        case err != nil:
        case math.IsNaN(v):
            err = errors.New(""NaN not supported."")
        case math.IsInf(v, 0):
            err = errors.New(""Inf not supported."")
        default:
            if v < min {
                min = v
            }
            if v > max {
                max = v
            }
            vs[i] = v
            continue
        }
        return
    }
    if min == max {
        sp = strings.Repeat(""▄"", n)
    } else {
        rs := make([]rune, n)
        f := 8 / (max - min)
        for j, v := range vs {
            i := rune(f * (v - min))
            if i > 7 {
                i = 7
            }
            rs[j] = '▁' + i
        }
        sp = string(rs)
    }
    return
}",1581,74
14043,http://rosettacode.org/wiki/Special_characters,Special characters,"Special characters are symbols (single characters or sequences of characters) that have a ""special"" built-in meaning in the language and typically cannot be used in identifiers.

Escape sequences are methods that the language uses to remove the special meaning from the symbol, enabling it to be used as a normal character, or sequence of characters when this can be done.



Task

List the special characters and show escape sequences in the language.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"-- comment here until end of line
{- comment here -}",52,2
14178,http://rosettacode.org/wiki/Stack,Stack,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
A stack is a container of elements with   last in, first out   access policy.   Sometimes it also called LIFO.

The stack is accessed through its top.

The basic stack operations are:

   push   stores a new element onto the stack top;
   pop   returns the last pushed stack element, while removing it from the stack;
   empty   tests if the stack contains no elements.


Sometimes the last pushed stack element is made accessible for immutable access (for read) or mutable access (for write):

   top   (sometimes called peek to keep with the p theme) returns the topmost element without modifying the stack.


Stacks allow a very simple hardware implementation.

They are common in almost all processors.

In programming, stacks are also very popular for their way (LIFO) of resource management, usually memory.

Nested scopes of language objects are naturally implemented by a stack (sometimes by multiple stacks).

This is a classical way to implement local variables of a re-entrant or recursive subprogram. Stacks are also used to describe a formal computational framework.

See stack machine.

Many algorithms in pattern matching, compiler construction (e.g. recursive descent parsers), and machine learning (e.g. based on tree traversal) have a natural representation in terms of stacks.



Task

Create a stack supporting the basic operations: push, pop, empty.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#Go,Go,var intStack []int,18,1
14214,http://rosettacode.org/wiki/Spiral_matrix,Spiral matrix,"Task

Produce a spiral array.



A   spiral array   is a square arrangement of the first    N2   natural numbers,   where the

numbers increase sequentially as you go around the edges of the array spiraling inwards.



For example, given   5,   produce this array:

 0  1  2  3  4
15 16 17 18  5
14 23 24 19  6
13 22 21 20  7
12 11 10  9  8



Related tasks

   Zig-zag matrix 
   Identity_matrix
   Ulam_spiral_(for_primes)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
var n = 5
 
func main() {
    if n < 1 {
        return
    }
    top, left, bottom, right := 0, 0, n-1, n-1
    sz := n * n
    a := make([]int, sz)
    i := 0
    for left < right {
        // work right, along top
        for c := left; c <= right; c++ {
            a[top*n+c] = i
            i++
        }
        top++
        // work down right side
        for r := top; r <= bottom; r++ {
            a[r*n+right] = i
            i++
        }
        right--
        if top == bottom {
            break
        }
        // work left, along bottom
        for c := right; c >= left; c-- {
            a[bottom*n+c] = i
            i++
        }
        bottom--
        // work up left side
        for r := bottom; r >= top; r-- {
            a[r*n+left] = i
            i++
        }
        left++
    }
    // center (last) element
    a[top*n+left] = i
 
    // print
    w := len(strconv.Itoa(n*n - 1))
    for i, e := range a {
        fmt.Printf(""%*d "", w, e)
        if i%n == n-1 {
            fmt.Println("""")
        }
    }
}",1100,58
14247,http://rosettacode.org/wiki/Sorting_algorithms/Sleep_sort,Sorting algorithms/Sleep sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


In general, sleep sort works by starting a separate task for each item to be sorted, where each task sleeps for an interval corresponding to the item's sort key, then emits the item. Items are then collected sequentially in time.

Task: Write a program that implements sleep sort. Have it accept non-negative integers on the command line and print the integers in sorted order. If this is not idomatic in your language or environment, input and output may be done differently. Enhancements for optimization, generalization, practicality, robustness, and so on are not required.

Sleep sort was presented anonymously on 4chan and has been discussed on Hacker News.
",#Go,Go,"package main
 
import (
	""fmt""
	""log""
	""os""
	""strconv""
	""time""
)
 
func main() {
	out := make(chan uint64)
	for _, a := range os.Args[1:] {
		i, err := strconv.ParseUint(a, 10, 64)
		if err != nil {
			log.Fatal(err)
		}
		go func(n uint64) {
			time.Sleep(time.Duration(n) * time.Millisecond)
			out <- n
		}(i)
	}
	for _ = range os.Args[1:] {
		fmt.Println(<-out)
	}
}",370,26
14311,http://rosettacode.org/wiki/Sorting_algorithms/Stooge_sort,Sorting algorithms/Stooge sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Stooge sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Show the   Stooge Sort   for an array of integers.



The Stooge Sort algorithm is as follows:

algorithm stoogesort(array L, i = 0, j = length(L)-1)
     if L[j] < L[i] then
         L[i] ↔ L[j]
     if j - i > 1 then
         t := (j - i + 1)/3
         stoogesort(L, i  , j-t)
         stoogesort(L, i+t, j  )
         stoogesort(L, i  , j-t)
     return L


",#Go,Go,"package main
 
import ""fmt""
 
var a = []int{170, 45, 75, -90, -802, 24, 2, 66}
 
func main() {
    fmt.Println(""before:"", a)
    stoogesort(a)
    fmt.Println(""after: "", a)
    fmt.Println(""nyuk nyuk nyuk"")
}
 
func stoogesort(a []int) {
    last := len(a) - 1
    if a[last] < a[0] {
        a[0], a[last] = a[last], a[0]
    }
    if last > 1 {
        t := len(a) / 3
        stoogesort(a[:len(a)-t])
        stoogesort(a[t:])
        stoogesort(a[:len(a)-t])
    }
}",470,25
14372,http://rosettacode.org/wiki/Sorting_algorithms/Permutation_sort,Sorting algorithms/Permutation sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Implement a permutation sort, which proceeds by generating the possible permutations
of the input array/list until discovering the sorted one.

Pseudocode:

while not InOrder(list) do
    nextPermutation(list)
done


",#Go,Go,"package main
 
import ""fmt""
 
var a = []int{170, 45, 75, -90, -802, 24, 2, 66}
 
// in place permutation sort of slice a
func main() {
    fmt.Println(""before:"", a)
    if len(a) > 1 && !recurse(len(a) - 1) {
        // recurse should never return false from the top level.
        // if it does, it means some code somewhere is busted,
        // either the the permutation generation code or the
        // sortedness testing code.
        panic(""sorted permutation not found!"")
    }
    fmt.Println(""after: "", a)
}
 
// recursive permutation generator
func recurse(last int) bool {
    if last <= 0 {
        // bottom of recursion.  test if sorted.
        for i := len(a) - 1; a[i] >= a[i-1]; i-- {
            if i == 1 {
                return true
            }
        }
        return false
    }
    for i := 0; i <= last; i++ {
        a[i], a[last] = a[last], a[i]
        if recurse(last - 1) {
            return true
        }
        a[i], a[last] = a[last], a[i]
    }
    return false
}",1006,39
14428,http://rosettacode.org/wiki/Sorting_algorithms/Shell_sort,Sorting algorithms/Shell sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array of elements using the Shell sort algorithm, a diminishing increment sort.

The Shell sort   (also known as Shellsort or Shell's method)   is named after its inventor, Donald Shell, who published the algorithm in 1959.

Shell sort is a sequence of interleaved insertion sorts based on an increment sequence.
The increment size is reduced after each pass until the increment size is 1.

With an increment size of 1, the sort is a basic insertion sort, but by this time the data is guaranteed to be almost sorted, which is insertion sort's ""best case"".

Any sequence will sort the data as long as it ends in 1, but some work better than others.

Empirical studies have shown a geometric increment sequence with a ratio of about 2.2 work well in practice.
[1]

Other good sequences are found at the On-Line Encyclopedia of Integer Sequences.



",#Go,Go,"package main
 
import ""fmt""
 
var a = []int{170, 45, 75, -90, -802, 24, 2, 66}
 
func main() {
    fmt.Println(""before:"", a)
    for inc := len(a) / 2; inc > 0; inc = (inc + 1) * 5 / 11 {
        for i := inc; i < len(a); i++ {
            j, temp := i, a[i]
            for ; j >= inc && a[j-inc] > temp; j -= inc {
                a[j] = a[j-inc]
            }
            a[j] = temp
        }
    }
    fmt.Println(""after: "", a)
}",434,19
14434,http://rosettacode.org/wiki/Sorting_algorithms/Radix_sort,Sorting algorithms/Radix sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




Task

Sort an integer array with the   radix sort algorithm.

The primary purpose is to complete the characterization of sort algorithms task.



",#Go,Go,"package main
 
import (
    ""bytes""
    ""encoding/binary""
    ""fmt""
)
 
// declarations for word size of data
type word int32
const wordLen = 4
const highBit = -1 << 31
 
var data = []word{170, 45, 75, -90, -802, 24, 2, 66}
 
func main() {
    buf := bytes.NewBuffer(nil)
    ds := make([][]byte, len(data))
    for i, x := range data {
        binary.Write(buf, binary.LittleEndian, x^highBit)
        b := make([]byte, wordLen)
        buf.Read(b)
        ds[i] = b
    }
    bins := make([][][]byte, 256)
    for i := 0; i < wordLen; i++ {
        for _, b := range ds {
            bins[b[i]] = append(bins[b[i]], b)
        }
        j := 0
        for k, bs := range bins {
            copy(ds[j:], bs)
            j += len(bs)
            bins[k] = bs[:0]
        }
    }
    fmt.Println(""original:"", data)
    var w word
    for i, b := range ds {
        buf.Write(b)
        binary.Read(buf, binary.LittleEndian, &w)
        data[i] = w^highBit
    }
    fmt.Println(""sorted:  "", data)
}",997,45
14499,http://rosettacode.org/wiki/Sorting_algorithms/Patience_sort,Sorting algorithms/Patience sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Sort an array of numbers (of any convenient size) into ascending order using   Patience sorting.



Related task

   Longest increasing subsequence

",#Go,Go,"package main
 
import (
  ""fmt""
  ""container/heap""
  ""sort""
)
 
type IntPile []int
func (self IntPile) Top() int { return self[len(self)-1] }
func (self *IntPile) Pop() int {
    x := (*self)[len(*self)-1]
    *self = (*self)[:len(*self)-1]
    return x
}
 
type IntPilesHeap []IntPile
func (self IntPilesHeap) Len() int { return len(self) }
func (self IntPilesHeap) Less(i, j int) bool { return self[i].Top() < self[j].Top() }
func (self IntPilesHeap) Swap(i, j int) { self[i], self[j] = self[j], self[i] }
func (self *IntPilesHeap) Push(x interface{}) { *self = append(*self, x.(IntPile)) }
func (self *IntPilesHeap) Pop() interface{} {
    x := (*self)[len(*self)-1]
    *self = (*self)[:len(*self)-1]
    return x
}
 
func patience_sort (n []int) {
  var piles []IntPile
  // sort into piles
  for _, x := range n {
    j := sort.Search(len(piles), func (i int) bool { return piles[i].Top() >= x })
    if j != len(piles) {
      piles[j] = append(piles[j], x)
    } else {
      piles = append(piles, IntPile{ x })
    }
  }
 
  // priority queue allows us to merge piles efficiently
  hp := IntPilesHeap(piles)
  heap.Init(&hp)
  for i, _ := range n {
    smallPile := heap.Pop(&hp).(IntPile)
    n[i] = smallPile.Pop()
    if len(smallPile) != 0 {
      heap.Push(&hp, smallPile)
    }
  }
  if len(hp) != 0 {
    panic(""something went wrong"")
  }
}
 
func main() {
    a := []int{4, 65, 2, -31, 0, 99, 83, 782, 1}
    patience_sort(a)
    fmt.Println(a)
}",1463,59
14615,http://rosettacode.org/wiki/Sorting_algorithms/Pancake_sort,Sorting algorithms/Pancake sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array of integers (of any convenient size) into ascending order using Pancake sorting.

In short, instead of individual elements being sorted, the only operation allowed is to ""flip"" one end of the list, like so:

          Before:   6 7 8 9 2 5 3 4 1
          After:    9 8 7 6 2 5 3 4 1

Only one end of the list can be flipped; this should be the low end, but the high end is okay if it's easier to code or works better, but it must be the same end for the entire solution. (The end flipped can't be arbitrarily changed.)

Show both the initial, unsorted list and the final sorted list.

(Intermediate steps during sorting are optional.)

Optimizations are optional (but recommended).



Related tasks

   Number reversal game
   Topswops


Also see

   Wikipedia article:   pancake sorting.

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    list := pancake{31, 41, 59, 26, 53, 58, 97, 93, 23, 84}
    fmt.Println(""unsorted:"", list)
 
    list.sort()
    fmt.Println(""sorted!  "", list)
}
 
type pancake []int
 
func (a pancake) sort() {
    for uns := len(a) - 1; uns > 0; uns-- {
        // find largest in unsorted range
        lx, lg := 0, a[0]
        for i := 1; i <= uns; i++ {
            if a[i] > lg {
                lx, lg = i, a[i]
            }
        }
        // move to final position in two flips
        a.flip(lx)
        a.flip(uns)
    }
}
 
func (a pancake) flip(r int) {
    for l := 0; l < r; l, r = l+1, r-1 {
        a[l], a[r] = a[r], a[l]
    }
}",682,34
14620,http://rosettacode.org/wiki/Soundex,Soundex,"Soundex is an algorithm for creating indices for words based on their pronunciation.



Task

The goal is for homophones to be encoded to the same representation so that they can be matched despite minor differences in spelling   (from the   soundex   Wikipedia article).

Caution

There is a major issue in many of the implementations concerning the separation of two consonants that have the same soundex code! According to the official Rules [[1]]. So check for instance if Ashcraft is coded to A-261.

 If a vowel (A, E, I, O, U) separates two consonants that have the same soundex code, the consonant to the right of the vowel is coded. Tymczak is coded as T-522 (T, 5 for the M, 2 for the C, Z ignored (see ""Side-by-Side"" rule above), 2 for the K). Since the vowel ""A"" separates the Z and K, the K is coded.
 If ""H"" or ""W"" separate two consonants that have the same soundex code, the consonant to the right of the vowel is not coded. Example: Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 for the F). It is not coded A-226.

",#Go,Go,"package main
 
import (
    ""errors""
    ""fmt""
    ""unicode""
)
 
var code = []byte(""01230127022455012623017202"")
 
func soundex(s string) (string, error) {
    var sx [4]byte
    var sxi int
    var cx, lastCode byte
    for i, c := range s {
        switch {
        case !unicode.IsLetter(c):
            if c < ' ' || c == 127 {
                return """", errors.New(""ASCII control characters disallowed"")
            }
            if i == 0 {
                return """", errors.New(""initial character must be a letter"")
            }
            lastCode = '0'
            continue
        case c >= 'A' && c <= 'Z':
            cx = byte(c - 'A')
        case c >= 'a' && c <= 'z':
            cx = byte(c - 'a')
        default:
            return """", errors.New(""non-ASCII letters unsupported"")
        }
        // cx is valid letter index at this point
        if i == 0 {
            sx[0] = cx + 'A'
            sxi = 1
            continue
        }
        switch x := code[cx]; x {
        case '7', lastCode:
        case '0':
            lastCode = '0'
        default:
            sx[sxi] = x
            if sxi == 3 {
                return string(sx[:]), nil
            }
            sxi++
            lastCode = x
        }
    }
    if sxi == 0 {
        return """", errors.New(""no letters present"")
    }
    for ; sxi < 4; sxi++ {
        sx[sxi] = '0'
    }
    return string(sx[:]), nil
}
 
func main() {
    for _, s := range []string{
        ""Robert"",   // WP test case = R163
        ""Rupert"",   // WP test case = R163
        ""Rubin"",    // WP test case = R150
        ""ashcroft"", // WP test case = A261
        ""ashcraft"", // s and c combine across h, t not needed
        ""moses"",    // s's don't combine across e
        ""O'Mally"",  // apostrophe allowed, adjacent ll's combine
        ""d jay"",    // spaces allowed
        ""R2-D2"",    // digits, hyphen allowed
        ""12p2"",     // just not in leading position
        ""naïve"",    // non ASCII disallowed
        """",         // empty string disallowed
        ""bump\t"",   // ASCII control characters disallowed
    } {
        if x, err := soundex(s); err == nil {
            fmt.Println(""soundex"", s, ""="", x)
        } else {
            fmt.Printf(""\""%s\"" fail. %s\n"", s, err)
        }
    }
}",2282,83
14704,http://rosettacode.org/wiki/Sorting_algorithms/Selection_sort,Sorting algorithms/Selection sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array (or list) of elements using the Selection sort algorithm.



It works as follows:

First find the smallest element in the array and exchange it with the element in the first position, then find the second smallest element and exchange it with the element in the second position, and continue in this way until the entire array is sorted.



Its asymptotic complexity is    O(n2)    making it inefficient on large arrays.

Its primary purpose is for when writing data is very expensive (slow) when compared to reading, eg. writing to flash memory or EEPROM.

No other sorting algorithm has less data movement.



References

   Rosetta Code:   O     (complexity).
   Wikipedia:   Selection sort.
   Wikipedia:   [Big O notation].

",#Go,Go,"package main
 
import ""fmt""
 
var a = []int{170, 45, 75, -90, -802, 24, 2, 66}
 
func main() {
    fmt.Println(""before:"", a)
    selectionSort(a)
    fmt.Println(""after: "", a)
}
 
func selectionSort(a []int) {
    last := len(a) - 1
    for i := 0; i < last; i++ {
        aMin := a[i]
        iMin := i
        for j := i + 1; j < len(a); j++ {
            if a[j] < aMin {
                aMin = a[j]
                iMin = j
            }
        }
        a[i], a[iMin] = aMin, a[i]
    }
}",494,26
15047,http://rosettacode.org/wiki/Sorting_algorithms/Heapsort,Sorting algorithms/Heapsort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Heapsort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Heapsort is an in-place sorting algorithm with worst case and average complexity of   O(n logn).

The basic idea is to turn the array into a binary heap structure, which has the property that it allows efficient retrieval and removal of the maximal element.

We repeatedly ""remove"" the maximal element from the heap, thus building the sorted list from back to front.

A heap sort requires random access, so can only be used on an array-like data structure.

Pseudocode:

function heapSort(a, count) is
   input: an unordered array a of length count
 
   (first place a in max-heap order)
   heapify(a, count)
 
   end := count - 1
   while end > 0 do
      (swap the root(maximum value) of the heap with the
       last element of the heap)
      swap(a[end], a[0])
      (decrement the size of the heap so that the previous
       max value will stay in its proper place)
      end := end - 1
      (put the heap back in max-heap order)
      siftDown(a, 0, end)



function heapify(a,count) is
   (start is assigned the index in a of the last parent node)
   start := (count - 2) / 2
   
   while start ≥ 0 do
      (sift down the node at index start to the proper place
       such that all nodes below the start index are in heap
       order)
      siftDown(a, start, count-1)
      start := start - 1
   (after sifting down the root all nodes/elements are in heap order)
 
function siftDown(a, start, end) is
   (end represents the limit of how far down the heap to sift)
   root := start

   while root * 2 + 1 ≤ end do       (While the root has at least one child)
      child := root * 2 + 1           (root*2+1 points to the left child)
      (If the child has a sibling and the child's value is less than its sibling's...)
      if child + 1 ≤ end and a[child] < a[child + 1] then
         child := child + 1           (... then point to the right child instead)
      if a[root] < a[child] then     (out of max-heap order)
         swap(a[root], a[child])
         root := child                (repeat to continue sifting down the child now)
      else
         return



Write a function to sort a collection of integers using heapsort.



",#Go,Go,"package main
 
import (
  ""sort""
  ""container/heap""
  ""fmt""
)
 
type HeapHelper struct {
    container sort.Interface
    length    int
}
 
func (self HeapHelper) Len() int { return self.length }
// We want a max-heap, hence reverse the comparison
func (self HeapHelper) Less(i, j int) bool { return self.container.Less(j, i) }
func (self HeapHelper) Swap(i, j int) { self.container.Swap(i, j) }
// this should not be called
func (self *HeapHelper) Push(x interface{}) { panic(""impossible"") }
func (self *HeapHelper) Pop() interface{} {
    self.length--
    return nil // return value not used
}
 
func heapSort(a sort.Interface) {
    helper := HeapHelper{ a, a.Len() }
    heap.Init(&helper)
    for helper.length > 0 {
        heap.Pop(&helper)
    }
}
 
func main() {
    a := []int{170, 45, 75, -90, -802, 24, 2, 66}
    fmt.Println(""before:"", a)
    heapSort(sort.IntSlice(a))
    fmt.Println(""after: "", a)
}",915,38
15080,http://rosettacode.org/wiki/Sorting_algorithms/Quicksort,Sorting algorithms/Quicksort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Quicksort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Sort an array (or list) elements using the   quicksort   algorithm.

The elements must have a   strict weak order   and the index of the array can be of any discrete type.

For languages where this is not possible, sort an array of integers.



Quicksort, also known as   partition-exchange sort,   uses these steps.

   Choose any element of the array to be the pivot.
   Divide all other elements (except the pivot) into two partitions.
   All elements less than the pivot must be in the first partition.
   All elements greater than the pivot must be in the second partition.
   Use recursion to sort both partitions.
   Join the first sorted partition, the pivot, and the second sorted partition.


The best pivot creates partitions of equal length (or lengths differing by   1).

The worst pivot creates an empty partition (for example, if the pivot is the first or last element of a sorted array).

The run-time of Quicksort ranges from    O(n log n)    with the best pivots, to    O(n2)    with the worst pivots, where    n    is the number of elements in the array.



This is a simple quicksort algorithm, adapted from Wikipedia.

function quicksort(array)
    less, equal, greater := three empty arrays
    if length(array) > 1  
        pivot := select any element of array
        for each x in array
            if x < pivot then add x to less
            if x = pivot then add x to equal
            if x > pivot then add x to greater
        quicksort(less)
        quicksort(greater)
        array := concatenate(less, equal, greater)

A better quicksort algorithm works in place, by swapping elements within the array, to avoid the memory allocation of more arrays.

function quicksort(array)
    if length(array) > 1
        pivot := select any element of array
        left := first index of array
        right := last index of array
        while left ≤ right
            while array[left] < pivot
                left := left + 1
            while array[right] > pivot
                right := right - 1
            if left ≤ right
                swap array[left] with array[right]
                left := left + 1
                right := right - 1
        quicksort(array from first index to right)
        quicksort(array from left to last index)

Quicksort has a reputation as the fastest sort. Optimized variants of quicksort are common features of many languages and libraries. One often contrasts quicksort with   merge sort,   because both sorts have an average time of    O(n log n). 

 ""On average, mergesort does fewer comparisons than quicksort, so it may be better when complicated comparison routines are used. Mergesort also takes advantage of pre-existing order, so it would be favored for using sort() to merge several sorted arrays. On the other hand, quicksort is often faster for small arrays, and on arrays of a few distinct values, repeated many times."" — http://perldoc.perl.org/sort.html
Quicksort is at one end of the spectrum of divide-and-conquer algorithms, with merge sort at the opposite end.

 Quicksort is a conquer-then-divide algorithm, which does most of the work during the partitioning and the recursive calls. The subsequent reassembly of the sorted partitions involves trivial effort.
 Merge sort is a divide-then-conquer algorithm. The partioning happens in a trivial way, by splitting the input array in half. Most of the work happens during the recursive calls and the merge phase.


With quicksort, every element in the first partition is less than or equal to every element in the second partition. Therefore, the merge phase of quicksort is so trivial that it needs no mention!

This task has not specified whether to allocate new arrays, or sort in place. This task also has not specified how to choose the pivot element. (Common ways to are to choose the first element, the middle element, or the median of three elements.) Thus there is a variety among the following implementations.



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    list := []int{31, 41, 59, 26, 53, 58, 97, 93, 23, 84}
    fmt.Println(""unsorted:"", list)
 
    quicksort(list)
    fmt.Println(""sorted!  "", list)
}
 
func quicksort(a []int) {
    var pex func(int, int)
    pex = func(lower, upper int) {
        for {
            switch upper - lower {
            case -1, 0: // 0 or 1 item in segment.  nothing to do here!
                return
            case 1: // 2 items in segment
                // < operator respects strict weak order
                if a[upper] < a[lower] {
                    // a quick exchange and we're done.
                    a[upper], a[lower] = a[lower], a[upper]
                }
                return
            // Hoare suggests optimized sort-3 or sort-4 algorithms here,
            // but does not provide an algorithm.
            }
 
            // Hoare stresses picking a bound in a way to avoid worst case
            // behavior, but offers no suggestions other than picking a
            // random element.  A function call to get a random number is
            // relatively expensive, so the method used here is to simply
            // choose the middle element.  This at least avoids worst case
            // behavior for the obvious common case of an already sorted list.
            bx := (upper + lower) / 2
            b := a[bx]  // b = Hoare's ""bound"" (aka ""pivot"")
            lp := lower // lp = Hoare's ""lower pointer""
            up := upper // up = Hoare's ""upper pointer""
        outer:
            for {
                // use < operator to respect strict weak order
                for lp < upper && !(b < a[lp]) {
                    lp++
                }
                for {
                    if lp > up {
                        // ""pointers crossed!""
                        break outer
                    }
                    // < operator for strict weak order
                    if a[up] < b {
                        break // inner
                    }
                    up--
                }
                // exchange
                a[lp], a[up] = a[up], a[lp]
                lp++
                up--
            }
            // segment boundary is between up and lp, but lp-up might be
            // 1 or 2, so just call segment boundary between lp-1 and lp.
            if bx < lp {
                // bound was in lower segment
                if bx < lp-1 {
                    // exchange bx with lp-1
                    a[bx], a[lp-1] = a[lp-1], b
                }
                up = lp - 2
            } else {
                // bound was in upper segment
                if bx > lp {
                    // exchange
                    a[bx], a[lp] = a[lp], b
                }
                up = lp - 1
                lp++
            }
            // ""postpone the larger of the two segments"" = recurse on
            // the smaller segment, then iterate on the remaining one.
            if up-lower < upper-lp {
                pex(lower, up)
                lower = lp
            } else {
                pex(lp, upper)
                upper = up
            }
        }
    }
    pex(0, len(a)-1)
}",3206,93
15081,http://rosettacode.org/wiki/Sorting_algorithms/Insertion_sort,Sorting algorithms/Insertion sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Insertion sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



An O(n2) sorting algorithm which moves elements one at a time into the correct position.
The algorithm consists of inserting one element at a time into the previously sorted part of the array, moving higher ranked elements up as necessary.
To start off, the first (or smallest, or any arbitrary) element of the unsorted array is considered to be the sorted part.

Although insertion sort is an O(n2) algorithm, its simplicity, low overhead, good locality of reference and efficiency make it a good choice in two cases: 


   small   n, 

   as the final finishing-off algorithm for O(n logn) algorithms such as mergesort and quicksort.


The algorithm is as follows (from wikipedia):

function insertionSort(array A)
    for i from 1 to length[A]-1 do
        value := A[i] 
        j := i-1
        while j >= 0 and A[j] > value do
            A[j+1] := A[j]
            j := j-1
        done
        A[j+1] = value
    done

Writing the algorithm for integers will suffice.



",#Go,Go,"package main
 
import ""fmt""
 
func insertionSort(a []int) {
    for i := 1; i < len(a); i++ {
        value := a[i]
        j := i - 1
        for j >= 0 && a[j] > value {
            a[j+1] = a[j]
            j = j - 1
        }
        a[j+1] = value
    }
}
 
func main() {
    list := []int{31, 41, 59, 26, 53, 58, 97, 93, 23, 84}
    fmt.Println(""unsorted:"", list)
 
    insertionSort(list)
    fmt.Println(""sorted!  "", list)
}",432,23
15135,http://rosettacode.org/wiki/Sorting_algorithms/Merge_sort,Sorting algorithms/Merge sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


The   merge sort   is a recursive sort of order    n*log(n). 

It is notable for having a worst case and average complexity of    O(n*log(n)),    and a best case complexity of    O(n)    (for pre-sorted input).

The basic idea is to split the collection into smaller groups by halving it until the groups only have one element or no elements   (which are both entirely sorted groups).

Then merge the groups back together so that their elements are in order.

This is how the algorithm gets its   divide and conquer   description.



Task

Write a function to sort a collection of integers using the merge sort.



The merge sort algorithm comes in two parts:

   a sort function     and 
   a merge function 

The functions in pseudocode look like this:

function mergesort(m)
   var list left, right, result
   if length(m) ≤ 1
       return m
   else
       var middle = length(m) / 2
       for each x in m up to middle - 1
           add x to left
       for each x in m at and after middle
           add x to right
       left = mergesort(left)
       right = mergesort(right)
       if last(left) ≤ first(right) 
          append right to left
          return left
       result = merge(left, right)
       return result

function merge(left,right)
   var list result
   while length(left) > 0 and length(right) > 0
       if first(left) ≤ first(right)
           append first(left) to result
           left = rest(left)
       else
           append first(right) to result
           right = rest(right)
   if length(left) > 0 
       append rest(left) to result
   if length(right) > 0 
       append rest(right) to result
   return result



See also

   the Wikipedia entry:    merge sort


Note:   better performance can be expected if, rather than recursing until    length(m) ≤ 1,    an insertion sort is used for    length(m)    smaller than some threshold larger than   1.   However, this complicates the example code, so it is not shown here.



",#Go,Go,"package main
 
import ""fmt""
 
var a = []int{170, 45, 75, -90, -802, 24, 2, 66}
var s = make([]int, len(a)/2+1) // scratch space for merge step
 
func main() {
    fmt.Println(""before:"", a)
    mergeSort(a)
    fmt.Println(""after: "", a)
}
 
func mergeSort(a []int) {
    if len(a) < 2 {
        return
    }
    mid := len(a) / 2
    mergeSort(a[:mid])
    mergeSort(a[mid:])
    if a[mid-1] <= a[mid] {
        return
    }
    // merge step, with the copy-half optimization
    copy(s, a[:mid])
    l, r := 0, mid
    for i := 0; ; i++ {
        if s[l] <= a[r] {
            a[i] = s[l]
            l++
            if l == mid {
                break
            }
        } else {
            a[i] = a[r]
            r++
            if r == len(a) {
                copy(a[i+1:], s[l:mid])
                break
            }
        }
    }
    return
}",857,44
15386,http://rosettacode.org/wiki/Sorting_algorithms/Cocktail_sort_with_shifting_bounds,Sorting algorithms/Cocktail sort with shifting bounds,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Cocktail sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The   cocktail sort   is an improvement on the   Bubble Sort.



A cocktail sort is also known as:

   cocktail shaker sort
   happy hour sort
   bidirectional bubble sort
   a bubble sort variation
   a selection sort variation
   ripple sort
   shuffle sort
   shuttle sort


The improvement is basically that values ""bubble""   (migrate)   both directions through the
array,   because on each iteration the cocktail sort   bubble sorts   once
forwards and once backwards.

After   ii   passes,   the first   ii   and the
last   ii   elements in the array are in their correct
positions,   and don't have to be checked (again).

By shortening the part of the array that is sorted each time,   the number of
comparisons can be halved.



Pseudocode for the    2nd    algorithm   (from
Wikipedia)   with an added comment and changed indentations:

function A = cocktailShakerSort(A)
% `beginIdx` and `endIdx` marks the first and last index to check.
beginIdx = 1;
endIdx = length(A) - 1;
 
    while beginIdx <= endIdx
    newBeginIdx = endIdx;
    newEndIdx = beginIdx;
        for ii = beginIdx:endIdx
            if A(ii) > A(ii + 1)
                [A(ii+1), A(ii)] = deal(A(ii), A(ii+1));
                newEndIdx = ii;
            end
        end
 
    % decreases `endIdx` because the elements after `newEndIdx` are in correct order
    endIdx = newEndIdx - 1;
 
    % (FOR  (below)  decrements the  II  index by -1.
 
        for ii = endIdx:-1:beginIdx
            if A(ii) > A(ii + 1)
                [A(ii+1), A(ii)] = deal(A(ii), A(ii+1));
                newBeginIdx = ii;
            end
        end
 
    % increases `beginIdx` because the elements before `newBeginIdx` are in correct order.
    beginIdx = newBeginIdx + 1;
    end
end
%   indicates a comment,   and   deal   indicates a   swap.



Task

Implement a   cocktail sort   and optionally show the sorted output here on this page.

See the   discussion   page for some timing comparisons.



Related task

   cocktail sort

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
// translation of pseudo-code
func cocktailShakerSort(a []int) {
    var begin = 0
    var end = len(a) - 2
    for begin <= end {
        newBegin := end
        newEnd := begin
        for i := begin; i <= end; i++ {
            if a[i] > a[i+1] {
                a[i+1], a[i] = a[i], a[i+1]
                newEnd = i
            }
        }
        end = newEnd - 1
        for i := end; i >= begin; i-- {
            if a[i] > a[i+1] {
                a[i+1], a[i] = a[i], a[i+1]
                newBegin = i
            }
        }
        begin = newBegin + 1
    }
}
 
// from the RC Cocktail sort task (no optimizations)
func cocktailSort(a []int) {
    last := len(a) - 1
    for {
        swapped := false
        for i := 0; i < last; i++ {
            if a[i] > a[i+1] {
                a[i], a[i+1] = a[i+1], a[i]
                swapped = true
            }
        }
        if !swapped {
            return
        }
        swapped = false
        for i := last - 1; i >= 0; i-- {
            if a[i] > a[i+1] {
                a[i], a[i+1] = a[i+1], a[i]
                swapped = true
            }
        }
        if !swapped {
            return
        }
    }
}
 
func main() {
    // First make sure the routines are working correctly.
    a := []int{21, 4, -9, 62, -7, 107, -62, 4, 0, -170}
    fmt.Println(""Original array:"", a)
    b := make([]int, len(a))
    copy(b, a) // as sorts mutate array in place
    cocktailSort(a)
    fmt.Println(""Cocktail sort :"", a)
    cocktailShakerSort(b)
    fmt.Println(""C/Shaker sort :"", b)
 
    // timing comparison code
    rand.Seed(time.Now().UnixNano())
    fmt.Println(""\nRelative speed of the two sorts"")
    fmt.Println(""  N    x faster (CSS v CS)"")
    fmt.Println(""-----  -------------------"")
    const runs = 10 // average over 10 runs say
    for _, n := range []int{1000, 2000, 4000, 8000, 10000, 20000} {
        sum := 0.0
        for i := 1; i <= runs; i++ {
            // get 'n' random numbers in range [0, 100,000]
            // with every other number being negated
            nums := make([]int, n)
            for i := 0; i < n; i++ {
                rn := rand.Intn(100000)
                if i%2 == 1 {
                    rn = -rn
                }
                nums[i] = rn
            }
            // copy the array
            nums2 := make([]int, n)
            copy(nums2, nums)
 
            start := time.Now()
            cocktailSort(nums)
            elapsed := time.Since(start)
            start2 := time.Now()
            cocktailShakerSort(nums2)
            elapsed2 := time.Since(start2)
            sum += float64(elapsed) / float64(elapsed2)
        }
        fmt.Printf("" %2dk      %0.3f\n"", n/1000, sum/runs)
    }
}",2801,104
15499,http://rosettacode.org/wiki/Sorting_Algorithms/Circle_Sort,Sorting Algorithms/Circle Sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Sort an array of integers (of any convenient size) into ascending order using Circlesort.

In short, compare the first element to the last element, then the second element to the second last element, etc.

Then split the array in two and recurse until there is only one single element in the array, like this:

Before:
6 7 8 9 2 5 3 4 1
After:
1 4 3 5 2 9 8 7 6

Repeat this procedure until quiescence (i.e. until there are no swaps).

Show both the initial, unsorted list and the final sorted list. (Intermediate steps during sorting are optional.)

Optimizations (like doing 0.5 log2(n) iterations and then continue with an Insertion sort) are optional. 


Pseudo code:

 function circlesort (index lo, index hi, swaps)
 {
   if lo == hi return (swaps)
   high := hi
   low := lo
   mid := int((hi-lo)/2)
   while lo < hi {
     if  (value at lo) > (value at hi) {
        swap.values (lo,hi)
        swaps++
     }
     lo++
     hi--
   }
   if lo == hi
     if (value at lo) > (value at hi+1) {
         swap.values (lo,hi+1)
         swaps++
     }
   swaps := circlesort(low,low+mid,swaps)
   swaps := circlesort(low+mid+1,high,swaps)
   return(swaps)
 }
 while circlesort (0, sizeof(array)-1, 0)



See also

 For more information on Circle sorting, see Sourceforge.

",#Go,Go,"package main
 
import ""fmt""
 
func circleSort(a []int, lo, hi, swaps int) int {
    if lo == hi {
        return swaps
    }
    high, low := hi, lo
    mid := (hi - lo) / 2
    for lo < hi {
        if a[lo] > a[hi] {
            a[lo], a[hi] = a[hi], a[lo]
            swaps++
        }
        lo++
        hi--
    }
    if lo == hi {
        if a[lo] > a[hi+1] {
            a[lo], a[hi+1] = a[hi+1], a[lo]
            swaps++
        }
    }
    swaps = circleSort(a, low, low+mid, swaps)
    swaps = circleSort(a, low+mid+1, high, swaps)
    return swaps
}
 
func main() {
    aa := [][]int{
        {6, 7, 8, 9, 2, 5, 3, 4, 1},
        {2, 14, 4, 6, 8, 1, 3, 5, 7, 11, 0, 13, 12, -1},
    }
    for _, a := range aa {
        fmt.Printf(""Original: %v\n"", a)
        for circleSort(a, 0, len(a)-1, 0) != 0 {
            // empty block
        }
        fmt.Printf(""Sorted  : %v\n\n"", a)
    }
}",901,42
15623,http://rosettacode.org/wiki/Sorting_algorithms/Comb_sort,Sorting algorithms/Comb sort,"Sorting algorithms/Comb sort

You are encouraged to solve this task according to the task description, using any language you may know.

Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Implement a   comb sort.



The Comb Sort is a variant of the Bubble Sort.

Like the Shell sort, the Comb Sort increases the gap used in comparisons and exchanges.

Dividing the gap by   



(
1
−

e

−
φ



)

−
1


≈
1.247330950103979


{\displaystyle (1-e^{-\varphi })^{-1}\approx 1.247330950103979}

    works best, but    1.3   may be more practical.



Some implementations use the insertion sort once the gap is less than a certain amount.



Also see

   the Wikipedia article:   Comb sort.


Variants:

 Combsort11 makes sure the gap ends in (11, 8, 6, 4, 3, 2, 1), which is significantly faster than the other two possible endings.
 Combsort with different endings changes to a more efficient sort when the data is almost sorted (when the gap is small).   Comb sort with a low gap isn't much better than the Bubble Sort.


Pseudocode:

function combsort(array input)
    gap := input.size //initialize gap size
    loop until gap = 1 and swaps = 0
        //update the gap value for a next comb. Below is an example
        gap := int(gap / 1.25)
        if gap < 1
          //minimum gap is 1
          gap := 1
        end if
        i := 0
        swaps := 0 //see Bubble Sort for an explanation
        //a single ""comb"" over the input list
        loop until i + gap >= input.size //see Shell sort for similar idea
            if input[i] > input[i+gap]
                swap(input[i], input[i+gap])
                swaps := 1 // Flag a swap has occurred, so the
                           // list is not guaranteed sorted
            end if
            i := i + 1
        end loop
    end loop
end function


",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    a := []int{170, 45, 75, -90, -802, 24, 2, 66}
    fmt.Println(""before:"", a)
    combSort(a)
    fmt.Println(""after: "", a)
}
 
func combSort(a []int) {
    if len(a) < 2 {
        return
    }
    for gap := len(a); ; {
        if gap > 1 {
            gap = gap * 4 / 5
        }
        swapped := false
        for i := 0; ; {
            if a[i] > a[i+gap] {
                a[i], a[i+gap] = a[i+gap], a[i]
                swapped = true
            }
            i++
            if i+gap >= len(a) {
                break
            }
        }
        if gap == 1 && !swapped {
            break
        }
    }
}",667,35
15689,http://rosettacode.org/wiki/Sorting_algorithms/Bogosort,Sorting algorithms/Bogosort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Bogosort a list of numbers.



Bogosort simply shuffles a collection randomly until it is sorted.

""Bogosort"" is a perversely inefficient algorithm only used as an in-joke.

Its average run-time is   O(n!)   because the chance that any given shuffle of a set will end up in sorted order is about one in   n   factorial,   and the worst case is infinite since there's no guarantee that a random shuffling will ever produce a sorted sequence.

Its best case is   O(n)   since a single pass through the elements may suffice to order them.



Pseudocode:

while not InOrder(list) do
   Shuffle(list)
done



The Knuth shuffle may be used to implement the shuffle part of this algorithm.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""sort""
    ""time""
)
 
func main() {
    list := []int{31, 41, 59, 26, 53, 58, 97, 93, 23, 84}
    rand.Seed(time.Now().UnixNano())
    fmt.Println(""unsorted:"", list)
    temp := make([]int, len(list))
    copy(temp, list)
    for !sort.IntsAreSorted(temp) {
        for i, v := range rand.Perm(len(list)) {
            temp[i] = list[v]
        }
    }
    fmt.Println(""sorted!  "", temp)
}",443,22
15694,http://rosettacode.org/wiki/Sorting_algorithms/Counting_sort,Sorting algorithms/Counting sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Counting sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Implement the Counting sort.   This is a way of sorting integers when the minimum and maximum value are known.



Pseudocode

function countingSort(array, min, max):
    count: array of (max - min + 1) elements
    initialize count with 0
    for each number in array do
        count[number - min] := count[number - min] + 1
    done
    z := 0
    for i from min to max do
        while ( count[i - min] > 0 ) do
            array[z] := i
            z := z+1
            count[i - min] := count[i - min] - 1
        done
    done

The min and max can be computed apart, or be known a priori.


Note:   we know that, given an array of integers,   its maximum and minimum values can be always found;   but if we imagine the worst case for an array that can hold up to 32 bit integers,   we see that in order to hold the counts,   an array of up to 232 elements may be needed.   I.E.:   we need to hold a count value up to 232-1,   which is a little over 4.2 Gbytes.   So the counting sort is more practical when the range is (very) limited,   and minimum and maximum values are known   a priori.     (However, as a counterexample,   the use of   sparse arrays   minimizes the impact of the memory usage,   as well as removing the need of having to know the minimum and maximum values   a priori.)



",#Go,Go,"package main
 
import (
    ""fmt""
    ""runtime""
    ""strings""
)
 
var a = []int{170, 45, 75, -90, -802, 24, 2, 66}
var aMin, aMax = -1000, 1000
 
func main() {
    fmt.Println(""before:"", a)
    countingSort(a, aMin, aMax)
    fmt.Println(""after: "", a)
}
 
func countingSort(a []int, aMin, aMax int) {
    defer func() {
        if x := recover(); x != nil {
            // one error we'll handle and print a little nicer message
            if _, ok := x.(runtime.Error); ok &&
                strings.HasSuffix(x.(error).Error(), ""index out of range"") {
                fmt.Printf(""data value out of range (%d..%d)\n"", aMin, aMax)
                return
            }
            // anything else, we re-panic
            panic(x)
        }
    }()
 
    count := make([]int, aMax-aMin+1)
    for _, x := range a {
        count[x-aMin]++
    }
    z := 0
    // optimization over task pseudocode:   variable c is used instead of
    // count[i-min].  This saves some unneccessary calculations.
    for i, c := range count {
        for ; c > 0; c-- {
            a[z] = i + aMin
            z++
        }
    }
}",1114,45
15746,http://rosettacode.org/wiki/Sort_an_outline_at_every_level,Sort an outline at every level,"Task

Write and test a function over an indented plain text outline which either:

 Returns a copy of the outline in which the sub-lists at every level of indentation are sorted, or
 reports that the indentation characters or widths are not consistent enough to make the outline structure clear.


Your code should detect and warn of at least two types of inconsistent indentation:

 inconsistent use of whitespace characters (e.g. mixed use of tabs and spaces)
 inconsistent indent widths. For example, an indentation with an odd number of spaces in an outline in which the unit indent appears to be 2 spaces, or 4 spaces.


Your code should be able to detect and handle both tab-indented, and space-indented (e.g. 4 space, 2 space etc) outlines, without being given any advance warning of the indent characters used, or the size of the indent units.

You should also be able to specify different types of sort, for example, as a minimum, both ascending and descending lexical sorts.

Your sort should not alter the type or size of the indentation units used in the input outline.



(For an application of Indent Respectful Sort, see the Sublime Text package of that name. The Python source text [1] is available for inspection on Github).


Tests

 Sort every level of the (4 space indented) outline below lexically, once ascending and once descending.
zeta
    beta
    gamma
        lambda
        kappa
        mu
    delta
alpha
    theta
    iota
    epsilon
 Do the same with a tab-indented equivalent of the same outline.
zeta
	gamma
		mu
		lambda
		kappa
	delta
	beta
alpha
	theta
	iota
	epsilon


The output sequence of an ascending lexical sort of each level should be:

alpha
    epsilon
    iota
    theta
zeta
    beta
    delta
    gamma
        kappa
        lambda
        mu
The output sequence of a descending lexical sort of each level should be:

zeta
    gamma
        mu
        lambda
        kappa
    delta
    beta
alpha
    theta
    iota
    epsilon
 Attempt to separately sort each of the following two outlines, reporting any inconsistencies detected in their indentations by your validation code.
alpha
    epsilon
	iota
    theta
zeta
    beta
    delta
    gamma
    	kappa
        lambda
        mu
zeta
    beta
   gamma
        lambda
         kappa
        mu
    delta
alpha
    theta
    iota
    epsilon


Related tasks

   Functional_coverage_tree
   Display_an_outline_as_a_nested_table

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""sort""
    ""strings""
)
 
func sortedOutline(originalOutline []string, ascending bool) {
    outline := make([]string, len(originalOutline))
    copy(outline, originalOutline) // make copy in case we mutate it
    indent := """"
    del := ""\x7f""
    sep := ""\x00""
    var messages []string
    if strings.TrimLeft(outline[0], "" \t"") != outline[0] {
        fmt.Println(""    outline structure is unclear"")
        return
    }
    for i := 1; i < len(outline); i++ {
        line := outline[i]
        lc := len(line)
        if strings.HasPrefix(line, ""  "") || strings.HasPrefix(line, "" \t"") || line[0] == '\t' {
            lc2 := len(strings.TrimLeft(line, "" \t""))
            currIndent := line[0 : lc-lc2]
            if indent == """" {
                indent = currIndent
            } else {
                correctionNeeded := false
                if (strings.ContainsRune(currIndent, '\t') && !strings.ContainsRune(indent, '\t')) ||
                    (!strings.ContainsRune(currIndent, '\t') && strings.ContainsRune(indent, '\t')) {
                    m := fmt.Sprintf(""corrected inconsistent whitespace use at line %q"", line)
                    messages = append(messages, indent+m)
                    correctionNeeded = true
                } else if len(currIndent)%len(indent) != 0 {
                    m := fmt.Sprintf(""corrected inconsistent indent width at line %q"", line)
                    messages = append(messages, indent+m)
                    correctionNeeded = true
                }
                if correctionNeeded {
                    mult := int(math.Round(float64(len(currIndent)) / float64(len(indent))))
                    outline[i] = strings.Repeat(indent, mult) + line[lc-lc2:]
                }
            }
        }
    }
    levels := make([]int, len(outline))
    levels[0] = 1
    margin := """"
    for level := 1; ; level++ {
        allPos := true
        for i := 1; i < len(levels); i++ {
            if levels[i] == 0 {
                allPos = false
                break
            }
        }
        if allPos {
            break
        }
        mc := len(margin)
        for i := 1; i < len(outline); i++ {
            if levels[i] == 0 {
                line := outline[i]
                if strings.HasPrefix(line, margin) && line[mc] != ' ' && line[mc] != '\t' {
                    levels[i] = level
                }
            }
        }
        margin += indent
    }
    lines := make([]string, len(outline))
    lines[0] = outline[0]
    var nodes []string
    for i := 1; i < len(outline); i++ {
        if levels[i] > levels[i-1] {
            if len(nodes) == 0 {
                nodes = append(nodes, outline[i-1])
            } else {
                nodes = append(nodes, sep+outline[i-1])
            }
        } else if levels[i] < levels[i-1] {
            j := levels[i-1] - levels[i]
            nodes = nodes[0 : len(nodes)-j]
        }
        if len(nodes) > 0 {
            lines[i] = strings.Join(nodes, """") + sep + outline[i]
        } else {
            lines[i] = outline[i]
        }
    }
    if ascending {
        sort.Strings(lines)
    } else {
        maxLen := len(lines[0])
        for i := 1; i < len(lines); i++ {
            if len(lines[i]) > maxLen {
                maxLen = len(lines[i])
            }
        }
        for i := 0; i < len(lines); i++ {
            lines[i] = lines[i] + strings.Repeat(del, maxLen-len(lines[i]))
        }
        sort.Sort(sort.Reverse(sort.StringSlice(lines)))
    }
    for i := 0; i < len(lines); i++ {
        s := strings.Split(lines[i], sep)
        lines[i] = s[len(s)-1]
        if !ascending {
            lines[i] = strings.TrimRight(lines[i], del)
        }
    }
    if len(messages) > 0 {
        fmt.Println(strings.Join(messages, ""\n""))
        fmt.Println()
    }
    fmt.Println(strings.Join(lines, ""\n""))
}
 
func main() {
    outline := []string{
        ""zeta"",
        ""    beta"",
        ""    gamma"",
        ""        lambda"",
        ""        kappa"",
        ""        mu"",
        ""    delta"",
        ""alpha"",
        ""    theta"",
        ""    iota"",
        ""    epsilon"",
    }
 
    outline2 := make([]string, len(outline))
    for i := 0; i < len(outline); i++ {
        outline2[i] = strings.ReplaceAll(outline[i], ""    "", ""\t"")
    }
 
    outline3 := []string{
        ""alpha"",
        ""    epsilon"",
        ""        iota"",
        ""    theta"",
        ""zeta"",
        ""    beta"",
        ""    delta"",
        ""    gamma"",
        ""    \t   kappa"", // same length but \t instead of space
        ""        lambda"",
        ""        mu"",
    }
 
    outline4 := []string{
        ""zeta"",
        ""    beta"",
        ""   gamma"",
        ""        lambda"",
        ""         kappa"",
        ""        mu"",
        ""    delta"",
        ""alpha"",
        ""    theta"",
        ""    iota"",
        ""    epsilon"",
    }
 
    fmt.Println(""Four space indented outline, ascending sort:"")
    sortedOutline(outline, true)
 
    fmt.Println(""\nFour space indented outline, descending sort:"")
    sortedOutline(outline, false)
 
    fmt.Println(""\nTab indented outline, ascending sort:"")
    sortedOutline(outline2, true)
 
    fmt.Println(""\nTab indented outline, descending sort:"")
    sortedOutline(outline2, false)
 
    fmt.Println(""\nFirst unspecified outline, ascending sort:"")
    sortedOutline(outline3, true)
 
    fmt.Println(""\nFirst unspecified outline, descending sort:"")
    sortedOutline(outline3, false)
 
    fmt.Println(""\nSecond unspecified outline, ascending sort:"")
    sortedOutline(outline4, true)
 
    fmt.Println(""\nSecond unspecified outline, descending sort:"")
    sortedOutline(outline4, false)
}",5733,192
15811,http://rosettacode.org/wiki/Sorting_algorithms/Bead_sort,Sorting algorithms/Bead sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array of positive integers using the Bead Sort Algorithm.

A   bead sort   is also known as a   gravity sort.



Algorithm has   O(S),   where   S   is the sum of the integers in the input set:   Each bead is moved individually.

This is the case when bead sort is implemented without a mechanism to assist in finding empty spaces below the beads, such as in software implementations.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""sync""
)
 
var a = []int{170, 45, 75, 90, 802, 24, 2, 66}
var aMax = 1000
 
const bead = 'o'
 
func main() {
    fmt.Println(""before:"", a)
    beadSort()
    fmt.Println(""after: "", a)
}
 
func beadSort() {
    // All space in the abacus = aMax poles x len(a) rows.
    all := make([]byte, aMax*len(a))
    // Slice up space by pole.  (The space could be sliced by row instead,
    // but slicing by pole seemed a more intuitive model of a physical abacus.)
    abacus := make([][]byte, aMax)
    for pole, space := 0, all; pole < aMax; pole++ {
        abacus[pole] = space[:len(a)]
        space = space[len(a):]
    }
    // Use a sync.Waitgroup as the checkpoint mechanism.
    var wg sync.WaitGroup
    // Place beads for each number concurrently. (Presumably beads can be
    // ""snapped on"" to the middle of a pole without disturbing neighboring
    // beads.)  Also note 'row' here is a row of the abacus.
    wg.Add(len(a))
    for row, n := range a {
        go func(row, n int) {
            for pole := 0; pole < n; pole++ {
                abacus[pole][row] = bead
            }
            wg.Done()
        }(row, n)
    }
    wg.Wait()
    // Now tip the abacus, letting beads fall on each pole concurrently.
    wg.Add(aMax)
    for _, pole := range abacus {
        go func(pole []byte) {
            // Track the top of the stack of beads that have already fallen.
            top := 0
            for row, space := range pole {
                if space == bead {
                    // Move each bead individually, but move it from its
                    // starting row to the top of stack in a single operation.
                    // (More physical simulation such as discovering the top
                    // of stack by inspection, or modeling gravity, are
                    // possible, but didn't seem called for by the task.
                    pole[row] = 0
                    pole[top] = bead
                    top++
                }
            }
            wg.Done()
        }(pole)
    }
    wg.Wait()
    // Read out sorted numbers by row.
    for row := range a {
        x := 0
        for pole := 0; pole < aMax && abacus[pole][row] == bead; pole++ {
            x++
        }
        a[len(a)-1-row] = x
    }
}",2295,74
15869,http://rosettacode.org/wiki/Sort_numbers_lexicographically,Sort numbers lexicographically,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Given an integer   n,   return   1──►n   (inclusive)   in lexicographical order.



Show all output here on this page.



Example

Given   13,

return:   [1,10,11,12,13,2,3,4,5,6,7,8,9].
",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
    ""strconv""
)
 
func lexOrder(n int) []int {
    first, last, k := 1, n, n
    if n < 1 {
        first, last, k = n, 1, 2-n
    }
    strs := make([]string, k)
    for i := first; i <= last; i++ {
        strs[i-first] = strconv.Itoa(i)
    }
    sort.Strings(strs)
    ints := make([]int, k)
    for i := 0; i < k; i++ {
        ints[i], _ = strconv.Atoi(strs[i])
    }
    return ints
}
 
func main() {
    fmt.Println(""In lexicographical order:\n"")
    for _, n := range []int{0, 5, 13, 21, -22} {
        fmt.Printf(""%3d: %v\n"", n, lexOrder(n))
    }
}",604,31
15891,http://rosettacode.org/wiki/Sorting_algorithms/Gnome_sort,Sorting algorithms/Gnome sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Gnome sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Gnome sort is a sorting algorithm which is similar to Insertion sort, except that moving an element to its proper place is accomplished by a series of swaps, as in Bubble Sort.

The pseudocode for the algorithm is:

function gnomeSort(a[0..size-1])
    i := 1
    j := 2
    while i < size do
        if a[i-1] <= a[i] then
            // for descending sort, use >= for comparison
            i := j
            j := j + 1 
        else
            swap a[i-1] and a[i]
            i := i - 1
            if i = 0 then
                i := j
                j := j + 1
            endif
        endif
    done



Task

Implement the Gnome sort in your language to sort an array (or list) of numbers.



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    a := []int{170, 45, 75, -90, -802, 24, 2, 66}
    fmt.Println(""before:"", a)
    gnomeSort(a)
    fmt.Println(""after: "", a)
}
 
func gnomeSort(a []int) {
    for i, j := 1, 2; i < len(a); {
        if a[i-1] > a[i] {
            a[i-1], a[i] = a[i], a[i-1]
            i--
            if i > 0 {
                continue
            }
        }
        i = j
        j++
    }
}",425,24
15958,http://rosettacode.org/wiki/Sort_stability,Sort stability,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


When sorting records in a table by a particular column or field, a stable sort will always retain the relative order of records that have the same key.



Example

In this table of countries and cities, a stable sort on the second column, the cities, would keep the   US Birmingham   above the   UK Birmingham.

(Although an unstable sort might, in this case, place the   US Birmingham   above the   UK Birmingham,   a stable sort routine would guarantee it).

UK  London
US  New York
US  Birmingham
UK  Birmingham

Similarly, stable sorting on just the first column would generate UK London as the first item and US Birmingham as the last item   (since the order of the elements having the same first word –   UK or US   – would be maintained).



Task

   Examine the documentation on any in-built sort routines supplied by a language.
   Indicate if an in-built routine is supplied
   If supplied, indicate whether or not the in-built routine is stable.


(This Wikipedia table shows the stability of some common sort routines).



",#Go,Go,"def cityList = ['UK  London', 'US  New York', 'US  Birmingham', 'UK  Birmingham',].asImmutable()
[
    'Sort by city': { city -> city[4..-1] },
    'Sort by country': { city -> city[0..3] },
].each{ String label, Closure orderBy ->
    println ""\n\nBefore ${label}""
    cityList.each { println it }
    println ""\nAfter ${label}""
    cityList.sort(false, orderBy).each{ println it }
}",384,10
15970,http://rosettacode.org/wiki/Sorting_algorithms/Cocktail_sort,Sorting algorithms/Cocktail sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Cocktail sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The cocktail shaker sort is an improvement on the Bubble Sort.

The improvement is basically that values ""bubble"" both directions through the array, because on each iteration the cocktail shaker sort bubble sorts once forwards and once backwards. Pseudocode for the algorithm (from wikipedia):

function cocktailSort( A : list of sortable items )
 do
   swapped := false
   for each i in 0 to length( A ) - 2 do
     if A[ i ] > A[ i+1 ] then // test whether the two 
                               // elements are in the wrong 
                               // order
       swap( A[ i ], A[ i+1 ] ) // let the two elements
                                // change places
       swapped := true;
   if swapped = false then
     // we can exit the outer loop here if no swaps occurred.
     break do-while loop;
   swapped := false
   for each i in length( A ) - 2 down to 0 do
     if A[ i ] > A[ i+1 ] then
       swap( A[ i ], A[ i+1 ] )
       swapped := true;
 while swapped; // if no elements have been swapped, 
                // then the list is sorted

Related task

   cocktail sort with shifting bounds

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    a := []int{170, 45, 75, -90, -802, 24, 2, 66}
    fmt.Println(""before:"", a)
    cocktailSort(a)
    fmt.Println(""after: "", a)
}
 
func cocktailSort(a []int) {
    last := len(a) - 1
    for {
        swapped := false
        for i := 0; i < last; i++ {
            if a[i] > a[i+1] {
                a[i], a[i+1] = a[i+1], a[i]
                swapped = true
            }
        }
        if !swapped {
            return
        }
        swapped = false
        for i := last - 1; i >= 0; i-- {
            if a[i] > a[i+1] {
                a[i], a[i+1] = a[i+1], a[i]
                swapped = true
            }
        }
        if !swapped {
            return
        }
    }
}",735,36
15979,http://rosettacode.org/wiki/Sort_three_variables,Sort three variables,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort   (the values of)   three variables   (X,   Y,   and   Z)   that contain any value   (numbers and/or literals).

If that isn't possible in your language, then just sort numbers   (and note if they can be floating point, integer, or other).

I.E.:   (for the three variables   x,   y,   and   z),   where:

                        x =  'lions, tigers, and'
                        y =  'bears, oh my!'
                        z =  '(from the ""Wizard of OZ"")'

After sorting, the three variables would hold:

                        x =  '(from the ""Wizard of OZ"")'
                        y =  'bears, oh my!'
                        z =  'lions, tigers, and'

For numeric value sorting, use:
I.E.:   (for the three variables   x,   y,   and   z),   where:

                        x =  77444
                        y =    -12
                        z =      0

After sorting, the three variables would hold:

                        x =    -12
                        y =      0
                        z =  77444

The variables should contain some form of a number, but specify if the algorithm
used can be for floating point or integers.   Note any limitations.

The values may or may not be unique.

The method used for sorting can be any algorithm;   the goal is to use the most idiomatic in the computer programming language used.

More than one algorithm could be shown if one isn't clearly the better choice.



One algorithm could be:

                        •  store the three variables   x, y, and z
                                 into an array (or a list)   A
                         
                        •  sort  (the three elements of)  the array   A
                         
                        •  extract the three elements from the array and place them in the
                                 variables x, y, and z   in order of extraction



Another algorithm   (only for numeric values):

       x= 77444 
       y=   -12 
       z=     0      
    low= x                                          
    mid= y                                          
   high= z 
      x= min(low,  mid,  high)            /*determine the lowest value of X,Y,Z. */    
      z= max(low,  mid,  high)            /*    ""      ""  highest  ""    "" "" "" ""  */    
      y=     low + mid + high - x - z     /*    ""      ""  middle   ""    "" "" "" ""  */      



Show the results of the sort here on this page using at least the values of those shown above.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""sort""
)
 
var (
    stringsIn = []string{
        `lions, tigers, and`,
        `bears, oh my!`,
        `(from the ""Wizard of OZ"")`}
    intsIn = []int{77444, -12, 0}
)
 
func main() {
    {
        // initialize three vars
        x, y, z := stringsIn[0], stringsIn[1], stringsIn[2]
 
        // I. Task suggested technique, move values to array (slice).
        // It's consise and relies on library code.
        s := []string{x, y, z}
        sort.Strings(s)
        x, y, z = s[0], s[1], s[2]
 
        // validate
        if x > y || y > z {
            log.Fatal()
        }
 
        // II. Likely fastest technique, minimizing tests and data movement.
        // Least consise though, hardest to understand, and most chance to make
        // a coding mistake.
        x, y, z = stringsIn[0], stringsIn[1], stringsIn[2] // (initialize)
        if x < y {
            switch {
            case y < z:
            case x < z:
                y, z = z, y
            default:
                x, y, z = z, x, y
            }
        } else {
            switch {
            case x < z:
                x, y = y, x
            case z < y:
                x, z = z, x
            default:
                x, y, z = y, z, x
            }
        }
        if x > y || y > z { // (validate)
            log.Fatal()
        }
 
        // III.  A little more consise than II, easier to understand, almost
        // as fast.
        x, y, z = stringsIn[0], stringsIn[1], stringsIn[2] // (initialize)
        if x > y {
            x, y = y, x
        }
        if y > z {
            y, z = z, y
        }
        if x > y {
            x, y = y, x
        }
        if x > y || y > z { // (validate)
            log.Fatal()
        }
        fmt.Println(""sorted strings:"")
        fmt.Println("" "", x)
        fmt.Println("" "", y)
        fmt.Println("" "", z)
        fmt.Println(""original data:"")
        fmt.Println("" "", stringsIn[0])
        fmt.Println("" "", stringsIn[1])
        fmt.Println("" "", stringsIn[2])
    }
    // same techniques, with integer test case
    {
        // task suggested technique
        x, y, z := intsIn[0], intsIn[1], intsIn[2] // (initialize)
        s := []int{x, y, z}
        sort.Ints(s)
        x, y, z = s[0], s[1], s[2]
        if x > y || y > z { // (validate)
            log.Fatal()
        }
 
        // minimizing data movement
        x, y, z = intsIn[0], intsIn[1], intsIn[2] // (initialize)
        if x < y {
            switch {
            case y < z:
            case x < z:
                y, z = z, y
            default:
                x, y, z = z, x, y
            }
        } else {
            switch {
            case x < z:
                x, y = y, x
            case z < y:
                x, z = z, x
            default:
                x, y, z = y, z, x
            }
        }
        if x > y || y > z { // (validate)
            log.Fatal()
        }
 
        // three swaps
        x, y, z = intsIn[0], intsIn[1], intsIn[2] // (initialize)
        if x > y {
            x, y = y, x
        }
        if y > z {
            y, z = z, y
        }
        if x > y {
            x, y = y, x
        }
        if x > y || y > z { // (validate)
            log.Fatal()
        }
        fmt.Println(""sorted ints:"", x, y, z)
        fmt.Println(""original data:"", intsIn)
    }
    // To put any of these techniques in a function, a function could just
    // take three values and return them sorted.
    {
        sort3 := func(x, y, z int) (int, int, int) {
            if x > y {
                x, y = y, x
            }
            if y > z {
                y, z = z, y
            }
            if x > y {
                x, y = y, x
            }
            return x, y, z
        }
        x, y, z := intsIn[0], intsIn[1], intsIn[2] // (initialize)
        x, y, z = sort3(x, y, z)
        if x > y || y > z { // (validate)
            log.Fatal()
        }
    }
    // Alternatively, a function could take pointers
    {
        sort3 := func(x, y, z *int) {
            if *x > *y {
                *x, *y = *y, *x
            }
            if *y > *z {
                *y, *z = *z, *y
            }
            if *x > *y {
                *x, *y = *y, *x
            }
        }
        x, y, z := intsIn[0], intsIn[1], intsIn[2] // (initialize)
        sort3(&x, &y, &z)
        if x > y || y > z { // (validate)
            log.Fatal()
        }
    }
}",4488,175
16139,http://rosettacode.org/wiki/Sort_using_a_custom_comparator,Sort using a custom comparator,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array (or list) of strings in order of descending length, and in ascending lexicographic order for strings of equal length.

Use a sorting facility provided by the language/library, combined with your own callback comparison function.


Note:   Lexicographic order is case-insensitive.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
    ""strings""
)
 
type sortable []string
 
func (s sortable) Len() int      { return len(s) }
func (s sortable) Swap(i, j int) { s[i], s[j] = s[j], s[i] }
func (s sortable) Less(i, j int) bool {
    a, b := s[i], s[j]
    if len(a) != len(b) {
        return len(a) > len(b)
    }
    return strings.ToLower(a) < strings.ToLower(b)
}
 
func main() {
    var s sortable = strings.Fields(""To tell your name the livelong day To an admiring bog"")
    fmt.Println(s, ""(original)"")
 
    sort.Sort(s)
    fmt.Println(s, ""(sorted)"")
}",572,27
16153,http://rosettacode.org/wiki/Solve_a_Numbrix_puzzle,Solve a Numbrix puzzle,"Numbrix puzzles are similar to Hidato.
The most important difference is that it is only possible to move 1 node left, right, up, or down (sometimes referred to as the Von Neumann neighborhood).
Published puzzles also tend not to have holes in the grid and may not always indicate the end node.
Two examples follow:

Example 1
Problem.

 0  0  0  0  0  0  0  0  0
 0  0 46 45  0 55 74  0  0
 0 38  0  0 43  0  0 78  0
 0 35  0  0  0  0  0 71  0
 0  0 33  0  0  0 59  0  0
 0 17  0  0  0  0  0 67  0
 0 18  0  0 11  0  0 64  0
 0  0 24 21  0  1  2  0  0
 0  0  0  0  0  0  0  0  0

Solution.

 49 50 51 52 53 54 75 76 81
 48 47 46 45 44 55 74 77 80
 37 38 39 40 43 56 73 78 79
 36 35 34 41 42 57 72 71 70
 31 32 33 14 13 58 59 68 69
 30 17 16 15 12 61 60 67 66
 29 18 19 20 11 62 63 64 65
 28 25 24 21 10  1  2  3  4
 27 26 23 22  9  8  7  6  5

Example 2
Problem.

 0  0  0  0  0  0  0  0  0
 0 11 12 15 18 21 62 61  0
 0  6  0  0  0  0  0 60  0
 0 33  0  0  0  0  0 57  0
 0 32  0  0  0  0  0 56  0
 0 37  0  1  0  0  0 73  0
 0 38  0  0  0  0  0 72  0
 0 43 44 47 48 51 76 77  0
 0  0  0  0  0  0  0  0  0

Solution.

  9 10 13 14 19 20 63 64 65
  8 11 12 15 18 21 62 61 66
  7  6  5 16 17 22 59 60 67
 34 33  4  3 24 23 58 57 68
 35 32 31  2 25 54 55 56 69
 36 37 30  1 26 53 74 73 70
 39 38 29 28 27 52 75 72 71
 40 43 44 47 48 51 76 77 78
 41 42 45 46 49 50 81 80 79

Task
Write a program to solve puzzles of this ilk,
demonstrating your program by solving the above examples.
Extra credit for other interesting examples.



Related tasks

 A* search algorithm
 Solve a Holy Knight's tour
 Knight's tour
 N-queens problem
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Solve a Hopido puzzle
 Solve the no connection puzzle

",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
    ""strconv""
    ""strings""
)
 
var example1 = []string{
    ""00,00,00,00,00,00,00,00,00"",
    ""00,00,46,45,00,55,74,00,00"",
    ""00,38,00,00,43,00,00,78,00"",
    ""00,35,00,00,00,00,00,71,00"",
    ""00,00,33,00,00,00,59,00,00"",
    ""00,17,00,00,00,00,00,67,00"",
    ""00,18,00,00,11,00,00,64,00"",
    ""00,00,24,21,00,01,02,00,00"",
    ""00,00,00,00,00,00,00,00,00"",
}
 
var example2 = []string{
    ""00,00,00,00,00,00,00,00,00"",
    ""00,11,12,15,18,21,62,61,00"",
    ""00,06,00,00,00,00,00,60,00"",
    ""00,33,00,00,00,00,00,57,00"",
    ""00,32,00,00,00,00,00,56,00"",
    ""00,37,00,01,00,00,00,73,00"",
    ""00,38,00,00,00,00,00,72,00"",
    ""00,43,44,47,48,51,76,77,00"",
    ""00,00,00,00,00,00,00,00,00"",
}
 
var moves = [][2]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}
 
var (
    grid        [][]int
    clues       []int
    totalToFill = 0
)
 
func solve(r, c, count, nextClue int) bool {
    if count > totalToFill {
        return true
    }
 
    back := grid[r][c]
 
    if back != 0 && back != count {
        return false
    }
 
    if back == 0 && nextClue < len(clues) && clues[nextClue] == count {
        return false
    }
 
    if back == count {
        nextClue++
    }
 
    grid[r][c] = count
    for _, move := range moves {
        if solve(r+move[1], c+move[0], count+1, nextClue) {
            return true
        }
    }
    grid[r][c] = back
    return false
}
 
func printResult(n int) {
    fmt.Println(""Solution for example"", n, ""\b:"")
    for _, row := range grid {
        for _, i := range row {
            if i == -1 {
                continue
            }
            fmt.Printf(""%2d "", i)
        }
        fmt.Println()
    }
}
 
func main() {
    for n, board := range [2][]string{example1, example2} {
        nRows := len(board) + 2
        nCols := len(strings.Split(board[0], "","")) + 2
        startRow, startCol := 0, 0
        grid = make([][]int, nRows)
        totalToFill = (nRows - 2) * (nCols - 2)
        var lst []int
 
        for r := 0; r < nRows; r++ {
            grid[r] = make([]int, nCols)
            for c := 0; c < nCols; c++ {
                grid[r][c] = -1
            }
            if r >= 1 && r < nRows-1 {
                row := strings.Split(board[r-1], "","")
                for c := 1; c < nCols-1; c++ {
                    val, _ := strconv.Atoi(row[c-1])
                    if val > 0 {
                        lst = append(lst, val)
                    }
                    if val == 1 {
                        startRow, startCol = r, c
                    }
                    grid[r][c] = val
                }
            }
        }
 
        sort.Ints(lst)
        clues = lst
        if solve(startRow, startCol, 1, 0) {
            printResult(n + 1)
        }
    }
}",2788,119
16222,http://rosettacode.org/wiki/Solve_a_Hopido_puzzle,Solve a Hopido puzzle,"Hopido puzzles are similar to  Hidato. The most important difference is that the only moves allowed are: hop over one tile diagonally; and over two tiles horizontally and vertically. It should be possible to start anywhere in the path, the end point isn't indicated and there are no intermediate clues. Hopido Design Post Mortem contains the following:

""Big puzzles represented another problem. Up until quite late in the project our puzzle solver was painfully slow with most puzzles above 7×7 tiles. Testing the solution from each starting point could take hours. If the tile layout was changed even a little, the whole puzzle had to be tested again. We were just about to give up the biggest puzzles entirely when our programmer suddenly came up with a magical algorithm that cut the testing process down to only minutes. Hooray!""

Knowing the kindness in the heart of every contributor to Rosetta Code, I know that we shall feel that as an act of humanity we must solve these puzzles for them in let's say milliseconds.

Example:

. 0 0 . 0 0 .
0 0 0 0 0 0 0
0 0 0 0 0 0 0
. 0 0 0 0 0 .
. . 0 0 0 . .
. . . 0 . . .

Extra credits are available for other interesting designs.



Related tasks

 A* search algorithm
 Solve a Holy Knight's tour
 Knight's tour
 N-queens problem
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Solve a Numbrix puzzle
 Solve the no connection puzzle

",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
var board = []string{
    "".00.00."",
    ""0000000"",
    ""0000000"",
    "".00000."",
    ""..000.."",
    ""...0..."",
}
 
var moves = [][2]int{
    {-3, 0}, {0, 3}, {3, 0}, {0, -3},
    {2, 2}, {2, -2}, {-2, 2}, {-2, -2},
}
 
var grid [][]int
 
var totalToFill = 0
 
func solve(r, c, count int) bool {
    if count > totalToFill {
        return true
    }
    nbrs := neighbors(r, c)
    if len(nbrs) == 0 && count != totalToFill {
        return false
    }
    sort.Slice(nbrs, func(i, j int) bool {
        return nbrs[i][2] < nbrs[j][2]
    })
 
    for _, nb := range nbrs {
        r = nb[0]
        c = nb[1]
        grid[r][c] = count
        if solve(r, c, count+1) {
            return true
        }
        grid[r][c] = 0
    }
    return false
}
 
func neighbors(r, c int) (nbrs [][3]int) {
    for _, m := range moves {
        x := m[0]
        y := m[1]
        if grid[r+y][c+x] == 0 {
            num := countNeighbors(r+y, c+x) - 1
            nbrs = append(nbrs, [3]int{r + y, c + x, num})
        }
    }
    return
}
 
func countNeighbors(r, c int) int {
    num := 0
    for _, m := range moves {
        if grid[r+m[1]][c+m[0]] == 0 {
            num++
        }
    }
    return num
}
 
func printResult() {
    for _, row := range grid {
        for _, i := range row {
            if i == -1 {
                fmt.Print(""   "")
            } else {
                fmt.Printf(""%2d "", i)
            }
        }
        fmt.Println()
    }
}
 
func main() {
    nRows := len(board) + 6
    nCols := len(board[0]) + 6
    grid = make([][]int, nRows)
    for r := 0; r < nRows; r++ {
        grid[r] = make([]int, nCols)
        for c := 0; c < nCols; c++ {
            grid[r][c] = -1
        }
        for c := 3; c < nCols-3; c++ {
            if r >= 3 && r < nRows-3 {
                if board[r-3][c-3] == '0' {
                    grid[r][c] = 0
                    totalToFill++
                }
            }
        }
    }
    pos, r, c := -1, 0, 0
    for {
        for {
            pos++
            r = pos / nCols
            c = pos % nCols
            if grid[r][c] != -1 {
                break
            }
        }
        grid[r][c] = 1
        if solve(r, c, 2) {
            break
        }
        grid[r][c] = 0
        if pos >= nRows*nCols {
            break
        }
    }
    printResult()
}",2393,123
16229,http://rosettacode.org/wiki/Sort_a_list_of_object_identifiers,Sort a list of object identifiers,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Object identifiers (OID)


Task

Show how to sort a list of OIDs, in their natural sort order.

Details
 An OID consists of one or more non-negative integers in base 10, separated by dots. It starts and ends with a number.
 Their natural sort order is lexicographical with regard to the dot-separated fields, using numeric comparison between fields.
Test case


 Input (list of strings)

 Output (list of strings)



1.3.6.1.4.1.11.2.17.19.3.4.0.10
1.3.6.1.4.1.11.2.17.5.2.0.79
1.3.6.1.4.1.11.2.17.19.3.4.0.4
1.3.6.1.4.1.11150.3.4.0.1
1.3.6.1.4.1.11.2.17.19.3.4.0.1
1.3.6.1.4.1.11150.3.4.0



1.3.6.1.4.1.11.2.17.5.2.0.79
1.3.6.1.4.1.11.2.17.19.3.4.0.1
1.3.6.1.4.1.11.2.17.19.3.4.0.4
1.3.6.1.4.1.11.2.17.19.3.4.0.10
1.3.6.1.4.1.11150.3.4.0
1.3.6.1.4.1.11150.3.4.0.1


Related tasks
 Natural sorting
 Sort using a custom comparator
",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math/big""
    ""sort""
    ""strings""
)
 
var testCases = []string{
    ""1.3.6.1.4.1.11.2.17.19.3.4.0.10"",
    ""1.3.6.1.4.1.11.2.17.5.2.0.79"",
    ""1.3.6.1.4.1.11.2.17.19.3.4.0.4"",
    ""1.3.6.1.4.1.11150.3.4.0.1"",
    ""1.3.6.1.4.1.11.2.17.19.3.4.0.1"",
    ""1.3.6.1.4.1.11150.3.4.0"",
}
 
// a parsed representation
type oid []big.Int
 
// ""constructor"" parses string representation
func newOid(s string) oid {
    ns := strings.Split(s, ""."")
    os := make(oid, len(ns))
    for i, n := range ns {
        if _, ok := os[i].SetString(n, 10); !ok || os[i].Sign() < 0 {
            return nil
        }
    }
    return os
}
 
// ""stringer"" formats into string representation
func (o oid) String() string {
    s := make([]string, len(o))
    for i, n := range o {
        s[i] = n.String()
    }
    return strings.Join(s, ""."")
}
 
func main() {
    // parse test cases
    os := make([]oid, len(testCases))
    for i, s := range testCases {
        os[i] = newOid(s)
        if os[i] == nil {
            log.Fatal(""invalid OID"")
        }
    }
    // sort
    sort.Slice(os, func(i, j int) bool {
        // ""less"" function must return true if os[i] < os[j]
        oi := os[i]
        for x, v := range os[j] {
            // lexicographic defintion: less if prefix or if element is <
            if x == len(oi) || oi[x].Cmp(&v) < 0 {
                return true
            }
            if oi[x].Cmp(&v) > 0 {
                break
            }
        }
        return false
    })
    // output sorted list
    for _, o := range os {
        fmt.Println(o)
    }
}",1618,72
16275,http://rosettacode.org/wiki/Smallest_number_k_such_that_k%2B2%5Em_is_composite_for_all_m_less_than_k,Smallest number k such that k+2^m is composite for all m less than k,"Generate the sequence of numbers a(k), where each k is the smallest positive integer such that k + 2m is composite for every positive integer m less than k.



For example
Suppose k == 7; test m == 1 through m == 6. If any are prime, the test fails.

Is 7 + 21 (9) prime? False

Is 7 + 22 (11) prime? True

So 7 is not an element of this sequence.

It is only necessary to test odd natural numbers k. An even number, plus any positive integer power of 2 is always composite.



Task 
Find and display, here on this page, the first 5 elements of this sequence.



See also
OEIS:A033939 - Odd k for which k+2^m is composite for all m < k


",#Go,Go,"package main
 
import (
    ""fmt""
    big ""github.com/ncw/gmp""
)
 
// returns true if k is a sequence member, false otherwise
func a(k int64) bool {
    if k == 1 {
        return false
    }
    bk := big.NewInt(k)
    for m := uint(1); m < uint(k); m++ {
        n := big.NewInt(1)
        n.Lsh(n, m)
        n.Add(n, bk)
        if n.ProbablyPrime(15) {
            return false
        }
    }
    return true
}
 
func main() {
    count := 0
    k := int64(1)
    for count < 5 {
        if a(k) {
            fmt.Printf(""%d "", k)
            count++
        }
        k += 2
    }
    fmt.Println()
}",607,36
16324,http://rosettacode.org/wiki/Sort_disjoint_sublist,Sort disjoint sublist,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Given a list of values and a set of integer indices into that value list, the task is to sort the values at the given indices, while preserving the values at indices outside the set of those to be sorted.

Make your example work with the following list of values and set of indices:

 Values: [7, 6, 5, 4, 3, 2, 1, 0]
 Indices: {6, 1, 7}
Where the correct result would be:

 [7, 0, 5, 4, 3, 2, 1, 6].
In case of one-based indexing, rather than the zero-based indexing above, you would use the indices {7, 2, 8} instead.

The indices are described as a set rather than a list but any collection-type of those indices without duplication may be used as long as the example is insensitive to the order of indices given.



Cf.
   Order disjoint list items

",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
func main() {
    // givens
    values := []int{7, 6, 5, 4, 3, 2, 1, 0}
    indices := map[int]int{6: 0, 1: 0, 7: 0}
 
    orderedValues := make([]int, len(indices))
    orderedIndices := make([]int, len(indices))
    i := 0
    for j := range indices {
        // validate that indices are within list boundaries
        if j < 0 || j >= len(values) {
            fmt.Println(""Invalid index: "", j)
            return
        }
        // extract elements to sort
        orderedValues[i] = values[j]
        orderedIndices[i] = j
        i++
    }
    // sort
    sort.Ints(orderedValues)
    sort.Ints(orderedIndices)
 
    fmt.Println(""initial:"", values)
    // replace sorted values
    for i, v := range orderedValues {
        values[orderedIndices[i]] = v
    }
    fmt.Println(""sorted: "", values)
}",855,37
16340,http://rosettacode.org/wiki/Solve_a_Holy_Knight%27s_tour,Solve a Holy Knight's tour,"
Chess coaches have been known to inflict a kind of torture on beginners by taking a chess board, placing pennies on some squares and requiring that a Knight's tour be constructed that avoids the squares with pennies.

This kind of knight's tour puzzle is similar to   Hidato.

The present task is to produce a solution to such problems. At least demonstrate your program by solving the following:



Example

  0 0 0 
  0   0 0 
  0 0 0 0 0 0 0
0 0 0     0   0
0   0     0 0 0
1 0 0 0 0 0 0
    0 0   0
      0 0 0

Note that the zeros represent the available squares, not the pennies.

Extra credit is available for other interesting examples.



Related tasks

 A* search algorithm
 Knight's tour
 N-queens problem
 Solve a Hidato puzzle
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle

",#Go,Go,"package main
 
import ""fmt""
 
var moves = [][2]int{
    {-1, -2}, {1, -2}, {-1, 2}, {1, 2}, {-2, -1}, {-2, 1}, {2, -1}, {2, 1},
}
 
var board1 = "" xxx    "" +
    "" x xx   "" +
    "" xxxxxxx"" +
    ""xxx  x x"" +
    ""x x  xxx"" +
    ""sxxxxxx "" +
    ""  xx x  "" +
    ""   xxx  ""
 
var board2 = "".....s.x....."" +
    "".....x.x....."" +
    ""....xxxxx...."" +
    "".....xxx....."" +
    ""..x..x.x..x.."" +
    ""xxxxx...xxxxx"" +
    ""..xx.....xx.."" +
    ""xxxxx...xxxxx"" +
    ""..x..x.x..x.."" +
    "".....xxx....."" +
    ""....xxxxx...."" +
    "".....x.x....."" +
    "".....x.x.....""
 
func solve(pz [][]int, sz, sx, sy, idx, cnt int) bool {
    if idx > cnt {
        return true
    }
    for i := 0; i < len(moves); i++ {
        x := sx + moves[i][0]
        y := sy + moves[i][1]
        if (x >= 0 && x < sz) && (y >= 0 && y < sz) && pz[x][y] == 0 {
            pz[x][y] = idx
            if solve(pz, sz, x, y, idx+1, cnt) {
                return true
            }
            pz[x][y] = 0
        }
    }
    return false
}
 
func findSolution(b string, sz int) {
    pz := make([][]int, sz)
    for i := 0; i < sz; i++ {
        pz[i] = make([]int, sz)
        for j := 0; j < sz; j++ {
            pz[i][j] = -1
        }
    }
    var x, y, idx, cnt int
    for j := 0; j < sz; j++ {
        for i := 0; i < sz; i++ {
            switch b[idx] {
            case 'x':
                pz[i][j] = 0
                cnt++
            case 's':
                pz[i][j] = 1
                cnt++
                x, y = i, j
            }
            idx++
        }
    }
 
    if solve(pz, sz, x, y, 2, cnt) {
        for j := 0; j < sz; j++ {
            for i := 0; i < sz; i++ {
                if pz[i][j] != -1 {
                    fmt.Printf(""%02d  "", pz[i][j])
                } else {
                    fmt.Print(""--  "")
                }
            }
            fmt.Println()
        }
    } else {
        fmt.Println(""Cannot solve this puzzle!"")
    }
}
 
func main() {
    findSolution(board1, 8)
    fmt.Println()
    findSolution(board2, 13)
}",2058,94
16342,http://rosettacode.org/wiki/SOAP,SOAP,"In this task, the goal is to create a SOAP client which accesses functions defined at http://example.com/soap/wsdl, and calls the functions soapFunc( ) and anotherSoapFunc( ).

This task has been flagged for clarification. Code on this page in its current state may be flagged incorrect once this task has been clarified. See this page's Talk page for discussion.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""github.com/tiaguinho/gosoap""
    ""log""
)
 
type CheckVatResponse struct {
    CountryCode string `xml:""countryCode""`
    VatNumber   string `xml:""vatNumber""`
    RequestDate string `xml:""requestDate""`
    Valid       string `xml:""valid""`
    Name        string `xml:""name""`
    Address     string `xml:""address""`
}
 
var (
    rv CheckVatResponse
)
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func main() {
    // create SOAP client
    soap, err := gosoap.SoapClient(""http://ec.europa.eu/taxation_customs/vies/checkVatService.wsdl"")
 
    // map parameter names to values
    params := gosoap.Params{
        ""vatNumber"":   ""6388047V"",
        ""countryCode"": ""IE"",
    }
 
    // call 'checkVat' function
    err = soap.Call(""checkVat"", params)
    check(err)
 
    // unmarshal response to 'rv'
    err = soap.Unmarshal(&rv)
    check(err)
 
    // print response
    fmt.Println(""Country Code  : "", rv.CountryCode)
    fmt.Println(""Vat Number    : "", rv.VatNumber)
    fmt.Println(""Request Date  : "", rv.RequestDate)
    fmt.Println(""Valid         : "", rv.Valid)
    fmt.Println(""Name          : "", rv.Name)
    fmt.Println(""Address       : "", rv.Address)
}",1234,53
16384,http://rosettacode.org/wiki/Solve_the_no_connection_puzzle,Solve the no connection puzzle,"You are given a box with eight holes labelled   A-to-H,   connected by fifteen straight lines in the pattern as shown below:

             A   B
            /│\ /│\
           / │ X │ \
          /  │/ \│  \
         C───D───E───F
          \  │\ /│  /
           \ │ X │ /
            \│/ \│/
             G   H

You are also given eight pegs numbered   1-to-8.



Objective

Place the eight pegs in the holes so that the (absolute) difference between any two numbers connected by any line is greater than one.



Example

In this attempt:

             4   7
            /│\ /│\
           / │ X │ \
          /  │/ \│  \
         8───1───6───2
          \  │\ /│  /
           \ │ X │ /
            \│/ \│/
             3   5

Note that   7   and   6   are connected and have a difference of   1,   so it is   not   a solution.



Task
Produce and show here   one   solution to the puzzle.



Related tasks

   A* search algorithm
   Solve a Holy Knight's tour
   Knight's tour
   N-queens problem
   Solve a Hidato puzzle
   Solve a Holy Knight's tour
   Solve a Hopido puzzle
   Solve a Numbrix puzzle
   4-rings or 4-squares puzzle


See also
No Connection Puzzle (youtube).



",#Go,Go,"package main
 
import (
	""fmt""
	""strings""
)
 
func main() {
	p, tests, swaps := Solution()
	fmt.Println(p)
	fmt.Println(""Tested"", tests, ""positions and did"", swaps, ""swaps."")
}
 
// Holes A=0, B=1, …, H=7
// With connections:
const conn = `
       A   B
      /|\ /|\
     / | X | \
    /  |/ \|  \
   C - D - E - F
    \  |\ /|  /
     \ | X | /
      \|/ \|/
       G   H`
 
var connections = []struct{ a, b int }{
	{0, 2}, {0, 3}, {0, 4}, // A to C,D,E
	{1, 3}, {1, 4}, {1, 5}, // B to D,E,F
	{6, 2}, {6, 3}, {6, 4}, // G to C,D,E
	{7, 3}, {7, 4}, {7, 5}, // H to D,E,F
	{2, 3}, {3, 4}, {4, 5}, // C-D, D-E, E-F
}
 
type pegs [8]int
 
// Valid checks if the pegs are a valid solution.
// If the absolute difference between any pair of connected pegs is
// greater than one it is a valid solution.
func (p *pegs) Valid() bool {
	for _, c := range connections {
		if absdiff(p[c.a], p[c.b]) <= 1 {
			return false
		}
	}
	return true
}
 
// Solution is a simple recursive brute force solver,
// it stops at the first found solution.
// It returns the solution, the number of positions tested,
// and the number of pegs swapped.
func Solution() (p *pegs, tests, swaps int) {
	var recurse func(int) bool
	recurse = func(i int) bool {
		if i >= len(p)-1 {
			tests++
			return p.Valid()
		}
		// Try each remain peg from p[i:] in p[i]
		for j := i; j < len(p); j++ {
			swaps++
			p[i], p[j] = p[j], p[i]
			if recurse(i + 1) {
				return true
			}
			p[i], p[j] = p[j], p[i]
		}
		return false
	}
	p = &pegs{1, 2, 3, 4, 5, 6, 7, 8}
	recurse(0)
	return
}
 
func (p *pegs) String() string {
	return strings.Map(func(r rune) rune {
		if 'A' <= r && r <= 'H' {
			return rune(p[r-'A'] + '0')
		}
		return r
	}, conn)
}
 
func absdiff(a, b int) int {
	if a > b {
		return a - b
	}
	return b - a
}",1790,90
16503,http://rosettacode.org/wiki/Sokoban,Sokoban,"Demonstrate how to find a solution to a given Sokoban level. For the purpose of this task (formally, a PSPACE-complete problem) any method may be used. However a move-optimal or push-optimal (or any other -optimal) solutions is preferred.

Sokoban levels are usually stored as a character array where

 space is an empty square
 # is a wall
 @ is the player
 $ is a box
 . is a goal
 + is the player on a goal
 * is a box on a goal
#######
#     #
#     #
#. #  #
#. $$ #
#.$$  #
#.#  @#
#######
Sokoban solutions are usually stored in the LURD format, where lowercase l, u, r and d represent a move in that (left, up, right, down) direction and capital LURD represents a push.

Please state if you use some other format for either the input or output, and why.

For more information, see the Sokoban wiki.


",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func main() {
    level := `
#######
#     #
#     #
#. #  #
#. $$ #
#.$$  #
#.#  @#
#######`
    fmt.Printf(""level:%s\n"", level)
    fmt.Printf(""solution:\n%s\n"", solve(level))
}   
 
func solve(board string) string {
    buffer = make([]byte, len(board))
    width := strings.Index(board[1:], ""\n"") + 1
    dirs := []struct {
        move, push string 
        dPos       int
    }{
        {""u"", ""U"", -width},
        {""r"", ""R"", 1},
        {""d"", ""D"", width},
        {""l"", ""L"", -1},
    }
    visited := map[string]bool{board: true}
    open := []state{state{board, """", strings.Index(board, ""@"")}}
    for len(open) > 0 {
        s1 := &open[0]
        open = open[1:]
        for _, dir := range dirs {
            var newBoard, newSol string
            newPos := s1.pos + dir.dPos
            switch s1.board[newPos] {
            case '$', '*':
                newBoard = s1.push(dir.dPos)
                if newBoard == """" || visited[newBoard] {
                    continue
                }
                newSol = s1.cSol + dir.push
                if strings.IndexAny(newBoard, "".+"") < 0 {
                    return newSol
                }
            case ' ', '.':
                newBoard = s1.move(dir.dPos)
                if visited[newBoard] {
                    continue
                }
                newSol = s1.cSol + dir.move
            default:
                continue
            }
            open = append(open, state{newBoard, newSol, newPos})
            visited[newBoard] = true
        }
    }
    return ""No solution""
}
 
type state struct {
    board string
    cSol  string
    pos   int
}
 
var buffer []byte
 
func (s *state) move(dPos int) string {
    copy(buffer, s.board)
    if buffer[s.pos] == '@' {
        buffer[s.pos] = ' '
    } else {
        buffer[s.pos] = '.'
    }
    newPos := s.pos + dPos
    if buffer[newPos] == ' ' {
        buffer[newPos] = '@'
    } else {
        buffer[newPos] = '+'
    }
    return string(buffer)
}
 
func (s *state) push(dPos int) string {
    newPos := s.pos + dPos
    boxPos := newPos + dPos
    switch s.board[boxPos] {
    case ' ', '.':
    default:
        return """"
    }
    copy(buffer, s.board)
    if buffer[s.pos] == '@' {
        buffer[s.pos] = ' '
    } else {
        buffer[s.pos] = '.'
    }
    if buffer[newPos] == '$' {
        buffer[newPos] = '@'
    } else {
        buffer[newPos] = '+'
    }
    if buffer[boxPos] == ' ' {
        buffer[boxPos] = '$'
    } else {
        buffer[boxPos] = '*'
    }
    return string(buffer)
}",2599,117
16533,http://rosettacode.org/wiki/Sleeping_Beauty_problem,Sleeping Beauty problem,"Background on the task
In decision theory, The Sleeping Beauty Problem
is a problem invented by Arnold Zoboff and first publicized on Usenet. The experimental
subject, named Sleeping Beauty, agrees to an experiment as follows:
Sleeping Beauty volunteers to be put into a deep sleep on a Sunday. There is then a fair coin toss.
If this coin toss comes up heads, Sleeping Beauty wakes once (on Monday) and is asked to
estimate the probability that the coin toss was heads. Her estimate is recorded and she is
then put back to sleep for 2 days until Wednesday, at which time the experiment's results are tallied.



If instead the coin toss is tails, Sleeping Beauty wakes as before on Monday and asked to
estimate the probability the coin toss was heads, but is then given a drug which makes her forget
that she had been woken on Monday before being put back to sleep again. She then wakes only 1 day
later, on Tuesday. She is then asked (on Tuesday) again to guess the probability that the coin toss
was heads or tails. She is then put back to sleep and awakes as before 1 day later, on Wednesday.



Some decision makers have argued that since the coin toss was fair Sleeping Beauty should always
estimate the probability of heads as 1/2, since she does not have any additional information. Others
have disagreed, saying that if Sleeping Beauty knows the study design she also knows that she is twice
as likely to wake up and be asked to estimate the coin flip on tails than on heads, so the estimate
should be 1/3 heads.

Task
Given the above problem, create a Monte Carlo estimate of the actual results. The program should find the
proportion of heads on waking and asking Sleeping Beauty for an estimate, as a credence or as a percentage of the times Sleeping Beauty
is asked the question.


",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""rcu""
    ""time""
)
 
func sleepingBeauty(reps int) float64 {
    wakings := 0
    heads := 0
    for i := 0; i < reps; i++ {
        coin := rand.Intn(2) // heads = 0, tails = 1 say
        wakings++
        if coin == 0 {
            heads++
        } else {
            wakings++
        }
    }
    fmt.Printf(""Wakings over %s repetitions = %s\n"", rcu.Commatize(reps), rcu.Commatize(wakings))
    return float64(heads) / float64(wakings) * 100
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    pc := sleepingBeauty(1e6)
    fmt.Printf(""Percentage probability of heads on waking = %f%%\n"", pc)
}",660,30
16624,http://rosettacode.org/wiki/Smarandache_prime-digital_sequence,Smarandache prime-digital sequence,"The Smarandache prime-digital sequence (SPDS for brevity) is the sequence of primes whose digits are themselves prime.

For example 257 is an element of this sequence because it is prime itself and its digits: 2, 5 and 7 are also prime.

Task
 Show the first 25 SPDS primes.
 Show the hundredth SPDS prime.


See also

 OEIS A019546: Primes whose digits are primes.
 https://www.scribd.com/document/214851583/On-the-Smarandache-prime-digital-subsequence-sequences

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
var b = new(big.Int)
 
func isSPDSPrime(n uint64) bool {
    nn := n
    for nn > 0 {
        r := nn % 10
        if r != 2 && r != 3 && r != 5 && r != 7 {
            return false
        }
        nn /= 10
    }
    b.SetUint64(n)
    if b.ProbablyPrime(0) { // 100% accurate up to 2 ^ 64
        return true
    }
    return false
}
 
func listSPDSPrimes(startFrom, countFrom, countTo uint64, printOne bool) uint64 {
    count := countFrom
    for n := startFrom; ; n += 2 {
        if isSPDSPrime(n) {
            count++
            if !printOne {
                fmt.Printf(""%2d. %d\n"", count, n)
            }
            if count == countTo {
                if printOne {
                    fmt.Println(n)
                }
                return n
            }
        }
    }
}
 
func main() {
    fmt.Println(""The first 25 terms of the Smarandache prime-digital sequence are:"")
    fmt.Println("" 1. 2"")
    n := listSPDSPrimes(3, 1, 25, false)
    fmt.Println(""\nHigher terms:"")
    indices := []uint64{25, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000}
    for i := 1; i < len(indices); i++ {
        fmt.Printf(""%6d. "", indices[i])
        n = listSPDSPrimes(n+2, indices[i-1], indices[i], true)
    }
}",1288,54
16692,http://rosettacode.org/wiki/Sort_an_integer_array,Sort an integer array,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array (or list) of integers in ascending numerical order.



Use a sorting facility provided by the language/library if possible.



",#Go,Go,"package main
import ""fmt""
import ""sort""
 
func main() {
  nums := []int {2, 4, 3, 1, 2}
  sort.Ints(nums)
  fmt.Println(nums)
}",127,9
16704,http://rosettacode.org/wiki/Sockets,Sockets,"For this exercise a program is open a socket to localhost on port 256 and send the message ""hello socket world"" before closing the socket.

Catching any exceptions or errors is not required.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""net""
)
 
func main() {
    conn, err := net.Dial(""tcp"", ""localhost:256"")
    if err != nil {
        fmt.Println(err)
        return
    }
    defer conn.Close()
    _, err = conn.Write([]byte(""hello socket world""))
    if err != nil {
        fmt.Println(err)
    }
}",307,19
16717,http://rosettacode.org/wiki/Sort_an_array_of_composite_structures,Sort an array of composite structures,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Sort an array of composite structures by a key.



For example, if you define a composite structure that presents a name-value pair (in pseudo-code):

Define structure pair such that: 
   name as a string
   value as a string

and an array of such pairs:

   x: array of pairs

then define a sort routine that sorts the array x by the key name.

This task can always be accomplished with Sorting Using a Custom Comparator.

If your language is not listed here, please see the other article.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
type pair struct {
    name, value string
}
type csArray []pair
 
// three methods satisfy sort.Interface
func (a csArray) Less(i, j int) bool { return a[i].name < a[j].name }
func (a csArray) Len() int           { return len(a) }
func (a csArray) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
 
var x = csArray{
    pair{""joe"", ""120""},
    pair{""foo"", ""31""},
    pair{""bar"", ""251""},
}
 
func main() {
    sort.Sort(x)
    for _, p := range x {
        fmt.Printf(""%5s: %s\n"", p.name, p.value)
    }
}",552,29
16751,http://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort,Sorting algorithms/Bubble sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


A   bubble   sort is generally considered to be the simplest sorting algorithm.

A   bubble   sort is also known as a   sinking   sort.



Because of its simplicity and ease of visualization, it is often taught in introductory computer science courses.

Because of its abysmal O(n2) performance, it is not used often for large (or even medium-sized) datasets.

The bubble sort works by passing sequentially over a list, comparing each value to the one immediately after it.   If the first value is greater than the second, their positions are switched.   Over a number of passes, at most equal to the number of elements in the list, all of the values drift into their correct positions (large values ""bubble"" rapidly toward the end, pushing others down around them).  
Because each pass finds the maximum item and puts it at the end, the portion of the list to be sorted can be reduced at each pass.  
A boolean variable is used to track whether any changes have been made in the current pass; when a pass completes without changing anything, the algorithm exits.

This can be expressed in pseudo-code as follows (assuming 1-based indexing):

repeat
    if itemCount <= 1
        return
    hasChanged := false
    decrement itemCount
    repeat with index from 1 to itemCount
        if (item at index) > (item at (index + 1))
            swap (item at index) with (item at (index + 1))
            hasChanged := true
until hasChanged = false



Task

Sort an array of elements using the bubble sort algorithm.   The elements must have a total order and the index of the array can be of any discrete type.   For languages where this is not possible, sort an array of integers.



References

 The article on Wikipedia.
 Dance interpretation.

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    list := []int{31, 41, 59, 26, 53, 58, 97, 93, 23, 84}
    fmt.Println(""unsorted:"", list)
 
    bubblesort(list)
    fmt.Println(""sorted!  "", list)
}
 
func bubblesort(a []int) {
    for itemCount := len(a) - 1; ; itemCount-- {
        hasChanged := false
        for index := 0; index < itemCount; index++ {
            if a[index] > a[index+1] {
                a[index], a[index+1] = a[index+1], a[index]
                hasChanged = true
            }
        }
        if hasChanged == false {
            break
        }
    }
}",581,26
16757,http://rosettacode.org/wiki/Snake,Snake,"

 This page uses content from Wikipedia. The original article was at Snake_(video_game). The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Snake is a game where the player maneuvers a line which grows in length every time the snake reaches a food source.



Task
Implement a variant of the Snake game, in any interactive environment, in which a sole player attempts to eat items by running into them with the head of the snake.

Each item eaten makes the snake longer and a new item is randomly generated somewhere else on the plane.

The game ends when the snake attempts to eat himself.



",#Go,Go,"package main
 
import (
	""errors""
	""fmt""
	""log""
	""math/rand""
	""time""
 
	termbox ""github.com/nsf/termbox-go""
)
 
func main() {
	rand.Seed(time.Now().UnixNano())
	score, err := playSnake()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(""Final score:"", score)
}
 
type snake struct {
	body          []position // tail to head positions of the snake
	heading       direction
	width, height int
	cells         []termbox.Cell
}
 
type position struct {
	X int
	Y int
}
 
type direction int
 
const (
	North direction = iota
	East
	South
	West
)
 
func (p position) next(d direction) position {
	switch d {
	case North:
		p.Y--
	case East:
		p.X++
	case South:
		p.Y++
	case West:
		p.X--
	}
	return p
}
 
func playSnake() (int, error) {
	err := termbox.Init()
	if err != nil {
		return 0, err
	}
	defer termbox.Close()
 
	termbox.Clear(fg, bg)
	termbox.HideCursor()
	s := &snake{
		// It would be more efficient to use a circular
		// buffer instead of a plain slice for s.body.
		body:  make([]position, 0, 32),
		cells: termbox.CellBuffer(),
	}
	s.width, s.height = termbox.Size()
	s.drawBorder()
	s.startSnake()
	s.placeFood()
	s.flush()
 
	moveCh, errCh := s.startEventLoop()
	const delay = 125 * time.Millisecond
	for t := time.NewTimer(delay); ; t.Reset(delay) {
		var move direction
		select {
		case err = <-errCh:
			return len(s.body), err
		case move = <-moveCh:
			if !t.Stop() {
				<-t.C // handles race between moveCh and t.C
			}
		case <-t.C:
			move = s.heading
		}
		if s.doMove(move) {
			time.Sleep(1 * time.Second)
			break
		}
	}
 
	return len(s.body), err
}
 
func (s *snake) startEventLoop() (<-chan direction, <-chan error) {
	moveCh := make(chan direction)
	errCh := make(chan error, 1)
	go func() {
		defer close(errCh)
		for {
			switch ev := termbox.PollEvent(); ev.Type {
			case termbox.EventKey:
				switch ev.Ch { // WSAD and HJKL movement
				case 'w', 'W', 'k', 'K':
					moveCh <- North
				case 'a', 'A', 'h', 'H':
					moveCh <- West
				case 's', 'S', 'j', 'J':
					moveCh <- South
				case 'd', 'D', 'l', 'L':
					moveCh <- East
				case 0:
					switch ev.Key { // Cursor key movement
					case termbox.KeyArrowUp:
						moveCh <- North
					case termbox.KeyArrowDown:
						moveCh <- South
					case termbox.KeyArrowLeft:
						moveCh <- West
					case termbox.KeyArrowRight:
						moveCh <- East
					case termbox.KeyEsc: // Quit
						return
					}
				}
			case termbox.EventResize:
				// TODO
				errCh <- errors.New(""terminal resizing unsupported"")
				return
			case termbox.EventError:
				errCh <- ev.Err
				return
			case termbox.EventInterrupt:
				return
			}
		}
	}()
	return moveCh, errCh
}
 
func (s *snake) flush() {
	termbox.Flush()
	s.cells = termbox.CellBuffer()
}
 
func (s *snake) getCellRune(p position) rune {
	i := p.Y*s.width + p.X
	return s.cells[i].Ch
}
func (s *snake) setCell(p position, c termbox.Cell) {
	i := p.Y*s.width + p.X
	s.cells[i] = c
}
 
func (s *snake) drawBorder() {
	for x := 0; x < s.width; x++ {
		s.setCell(position{x, 0}, border)
		s.setCell(position{x, s.height - 1}, border)
	}
	for y := 0; y < s.height-1; y++ {
		s.setCell(position{0, y}, border)
		s.setCell(position{s.width - 1, y}, border)
	}
}
 
func (s *snake) placeFood() {
	for {
		// a random empty cell
		x := rand.Intn(s.width-2) + 1
		y := rand.Intn(s.height-2) + 1
		foodp := position{x, y}
		r := s.getCellRune(foodp)
		if r != ' ' {
			continue
		}
		s.setCell(foodp, food)
		return
	}
}
 
func (s *snake) startSnake() {
	// a random cell somewhat near the center
	x := rand.Intn(s.width/2) + s.width/4
	y := rand.Intn(s.height/2) + s.height/4
	head := position{x, y}
	s.setCell(head, snakeHead)
	s.body = append(s.body[:0], head)
	s.heading = direction(rand.Intn(4))
}
 
func (s *snake) doMove(move direction) bool {
	head := s.body[len(s.body)-1]
	s.setCell(head, snakeBody)
	head = head.next(move)
	s.heading = move
	s.body = append(s.body, head)
	r := s.getCellRune(head)
	s.setCell(head, snakeHead)
	gameOver := false
	switch r {
	case food.Ch:
		s.placeFood()
	case border.Ch, snakeBody.Ch:
		gameOver = true
		fallthrough
	case empty.Ch:
		s.setCell(s.body[0], empty)
		s.body = s.body[1:]
	default:
		panic(r)
	}
	s.flush()
	return gameOver
}
 
const (
	fg = termbox.ColorWhite
	bg = termbox.ColorBlack
)
 
// Symbols to use.
// Could use Unicode instead of simple ASCII.
var (
	empty     = termbox.Cell{Ch: ' ', Bg: bg, Fg: fg}
	border    = termbox.Cell{Ch: '+', Bg: bg, Fg: termbox.ColorBlue}
	snakeBody = termbox.Cell{Ch: '#', Bg: bg, Fg: termbox.ColorGreen}
	snakeHead = termbox.Cell{Ch: 'O', Bg: bg, Fg: termbox.ColorYellow | termbox.AttrBold}
	food      = termbox.Cell{Ch: '@', Bg: bg, Fg: termbox.ColorRed}
)",4681,235
16760,http://rosettacode.org/wiki/Solve_a_Hidato_puzzle,Solve a Hidato puzzle,"The task is to write a program which solves Hidato (aka Hidoku) puzzles.

The rules are:

 You are given a grid with some numbers placed in it. The other squares in the grid will be blank.
 The grid is not necessarily rectangular.
 The grid may have holes in it.
 The grid is always connected.
 The number “1” is always present, as is another number that is equal to the number of squares in the grid. Other numbers are present so as to force the solution to be unique.
 It may be assumed that the difference between numbers present on the grid is not greater than lucky 13.
 The aim is to place a natural number in each blank square so that in the sequence of numbered squares from “1” upwards, each square is in the wp:Moore neighborhood of the squares immediately before and after it in the sequence (except for the first and last squares, of course, which only have one-sided constraints).
 Thus, if the grid was overlaid on a chessboard, a king would be able to make legal moves along the path from first to last square in numerical order.
 A square may only contain one number.
 In a proper Hidato puzzle, the solution is unique.

For example the following problem


has the following solution, with path marked on it:




Related tasks

 A* search algorithm
 N-queens problem
 Solve a Holy Knight's tour
 Solve a Knight's tour
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle;

",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
    ""strconv""
    ""strings""
)
 
var board [][]int
var start, given []int
 
func setup(input []string) {
    /* This task is not about input validation, so
       we're going to trust the input to be valid */
    puzzle := make([][]string, len(input))
    for i := 0; i < len(input); i++ {
        puzzle[i] = strings.Fields(input[i])
    }
    nCols := len(puzzle[0])
    nRows := len(puzzle)
    list := make([]int, nRows*nCols)
    board = make([][]int, nRows+2)
    for i := 0; i < nRows+2; i++ {
        board[i] = make([]int, nCols+2)
        for j := 0; j < nCols+2; j++ {
            board[i][j] = -1
        }
    }
    for r := 0; r < nRows; r++ {
        row := puzzle[r]
        for c := 0; c < nCols; c++ {
            switch cell := row[c]; cell {
            case ""_"":
                board[r+1][c+1] = 0
            case ""."":
                break
            default:
                val, _ := strconv.Atoi(cell)
                board[r+1][c+1] = val
                list = append(list, val)
                if val == 1 {
                    start = append(start, r+1, c+1)
                }
            }
        }
    }
    sort.Ints(list)
    given = make([]int, len(list))
    for i := 0; i < len(given); i++ {
        given[i] = list[i]
    }
}
 
func solve(r, c, n, next int) bool {
    if n > given[len(given)-1] {
        return true
    }
 
    back := board[r][c]
    if back != 0 && back != n {
        return false
    }
 
    if back == 0 && given[next] == n {
        return false
    }
 
    if back == n {
        next++
    }
 
    board[r][c] = n
    for i := -1; i < 2; i++ {
        for j := -1; j < 2; j++ {
            if solve(r+i, c+j, n+1, next) {
                return true
            }
        }
    }
 
    board[r][c] = back
    return false
}
 
func printBoard() {
    for _, row := range board {
        for _, c := range row {
            switch {
            case c == -1:
                fmt.Print("" . "")
            case c > 0:
                fmt.Printf(""%2d "", c)
            default:
                fmt.Print(""__ "")
            }
        }
        fmt.Println()
    }
}
 
func main() {
    input := []string{
        ""_ 33 35 _ _ . . ."",
        ""_ _ 24 22 _ . . ."",
        ""_ _ _ 21 _ _ . ."",
        ""_ 26 _ 13 40 11 . ."",
        ""27 _ _ _ 9 _ 1 ."",
        "". . _ _ 18 _ _ ."",
        "". . . . _ 7 _ _"",
        "". . . . . . 5 _"",
    }
    setup(input)
    printBoard()
    fmt.Println(""\nFound:"")
    solve(start[0], start[1], 1, 0)
    printBoard()
}",2560,118
16959,http://rosettacode.org/wiki/Smith_numbers,Smith numbers,"Smith numbers are numbers such that the sum of the decimal digits of the integers that make up that number is the same as the sum of the decimal digits of its prime factors excluding 1.

By definition, all primes are excluded as they (naturally) satisfy this condition!

Smith numbers are also known as   joke   numbers.



Example
Using the number 166

Find the prime factors of 166 which are: 2 x 83

Then, take those two prime factors and sum all their decimal digits: 2 + 8 + 3 which is 13

Then, take the decimal digits of 166 and add their decimal digits: 1 + 6 + 6 which is 13

Therefore, the number 166 is a Smith number.



Task
Write a program to find all Smith numbers below 10000.



See also
 from Wikipedia:   [Smith number].
 from MathWorld:   [Smith number]. 
 from OEIS A6753:   [OEIS sequence A6753].
 from OEIS A104170:   [Number of Smith numbers below 10^n]. 
 from The Prime pages:   [Smith numbers].

",#Go,Go," 
package main
 
import ""fmt""
 
func numPrimeFactors(x uint) int {
	var p uint = 2
	var pf int
	if x == 1 {
		return 1
	}
	for {
		if (x % p) == 0 {
			pf++
			x /= p
			if x == 1 {
				return pf
			}
		} else {
			p++
		}
	}
}
 
func primeFactors(x uint, arr []uint) {
	var p uint = 2
	var pf int
	if x == 1 {
		arr[pf] = 1
		return
	}
	for {
		if (x % p) == 0 {
			arr[pf] = p
			pf++
			x /= p
			if x == 1 {
				return
			}
		} else {
			p++
		}
	}
}
 
func sumDigits(x uint) uint {
	var sum uint
	for x != 0 {
		sum += x % 10
		x /= 10
	}
	return sum
}
 
func sumFactors(arr []uint, size int) uint {
	var sum uint
	for a := 0; a < size; a++ {
		sum += sumDigits(arr[a])
	}
	return sum
}
 
func listAllSmithNumbers(maxSmith uint) {
	var arr []uint
	var a uint
	for a = 4; a < maxSmith; a++ {
		numfactors := numPrimeFactors(a)
		arr = make([]uint, numfactors)
		if numfactors < 2 {
			continue
		}
		primeFactors(a, arr)
		if sumDigits(a) == sumFactors(arr, numfactors) {
			fmt.Printf(""%4d "", a)
		}
	}
}
 
func main() {
	const maxSmith = 10000
	fmt.Printf(""All the Smith Numbers less than %d are:\n"", maxSmith)
	listAllSmithNumbers(maxSmith)
	fmt.Println()
}
 ",1166,85
17286,http://rosettacode.org/wiki/Singleton,Singleton,"A Global Singleton is a class of which only one instance exists within a program.

Any attempt to use non-static members of the class involves performing operations on this one instance.



",#Go,Go,"package main
 
import (
    ""log""
    ""math/rand""
    ""sync""
    ""time""
)
 
var (
    instance string
    once     sync.Once // initialize instance with once.Do
)
 
func claim(color string, w *sync.WaitGroup) {
    time.Sleep(time.Duration(rand.Intn(1e8))) // hesitate up to .1 sec
    log.Println(""trying to claim"", color)
    once.Do(func() { instance = color })
    log.Printf(""tried %s. instance: %s"", color, instance)
    w.Done()
}
 
func main() {
    rand.Seed(time.Now().Unix())
    var w sync.WaitGroup
    w.Add(2)
    go claim(""red"", &w) // these two attempts run concurrently
    go claim(""blue"", &w)
    w.Wait()
    log.Println(""after trying both, instance ="", instance)
}",686,31
17327,http://rosettacode.org/wiki/Simulate_input/Keyboard,Simulate input/Keyboard,"Task

Send simulated keystrokes to a GUI window, or terminal.

You should specify whether the target may be externally created
(i.e., if the keystrokes are going to an application
other than the application that is creating them).



",#Go,Go,"package main
 
import (
    ""github.com/micmonay/keybd_event""
    ""log""
    ""runtime""
    ""time""
)
 
func main() {
    kb, err := keybd_event.NewKeyBonding()
    if err != nil {
        log.Fatal(err)
    }
 
    // For linux, need to wait 2 seconds
    if runtime.GOOS == ""linux"" {
        time.Sleep(2 * time.Second)
    }
 
    //set keys
    kb.SetKeys(keybd_event.VK_D, keybd_event.VK_I, keybd_event.VK_R, keybd_event.VK_ENTER)
 
    //launch
    err = kb.Launching()
    if err != nil {
        log.Fatal(err)
    }
}",523,29
17333,http://rosettacode.org/wiki/Simulate_input/Mouse,Simulate input/Mouse,,#Go,Go,"package main
 
import ""github.com/go-vgo/robotgo""
 
func main() {
    robotgo.MouseClick(""left"", false) // single clicks left mouse button
    robotgo.MouseClick(""right"", true) // double clicks right mouse button
}",214,8
17504,http://rosettacode.org/wiki/Singly-linked_list/Element_definition,Singly-linked list/Element definition,"singly-linked list
See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack",#Go,Go,"type Ele struct {
    Data interface{}
    Next *Ele
}
 
func (e *Ele) Append(data interface{}) *Ele {
    if e.Next == nil {
        e.Next = &Ele{data, nil}
    } else {
        tmp := &Ele{data, e.Next}
        e.Next = tmp
    }
    return e.Next
}
 
func (e *Ele) String() string {
    return fmt.Sprintf(""Ele: %v"", e.Data)
}",330,18
17549,http://rosettacode.org/wiki/Singly-linked_list/Traversal,Singly-linked list/Traversal,"Traverse from the beginning of a singly-linked list to the end.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#Go,Go,"start := &Ele{""tacos"", nil}
end := start.Append(""burritos"")
end = end.Append(""fajitas"")
end = end.Append(""enchilatas"")
for iter := start; iter != nil; iter = iter.Next {
    fmt.Println(iter)
}",193,7
17563,http://rosettacode.org/wiki/Singly-linked_list/Element_insertion,Singly-linked list/Element insertion,"Singly-Linked List (element)
singly-linked list
Using this method, insert an element C into a list comprised of elements A->B, following element A.

See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#Go,Go,"package main
 
import ""fmt""
 
type Ele struct {
    Data interface{}
    Next *Ele
}
 
func (e *Ele) insert(data interface{}) {
    if e == nil {
        panic(""attept to modify nil"")
    }
    e.Next = &Ele{data, e.Next}
}
 
func (e *Ele) printList() {
    if e == nil {
        fmt.Println(nil)
        return
    }
    fmt.Printf(""(%v"", e.Data)
    for {
        e = e.Next
        if e == nil {
            fmt.Println("")"")
            return
        }
        fmt.Print("" "", e.Data)
    }
}
 
func main() {
    h := &Ele{""A"", &Ele{""B"", nil}}
    h.printList()
    h.insert(""C"")
    h.printList()
}",602,38
17678,http://rosettacode.org/wiki/Sleep,Sleep,"Task

Write a program that does the following in this order:

 Input an amount of time to sleep in whatever units are most natural for your language (milliseconds, seconds, ticks, etc.). This unit should be noted in comments or in a description.
 Print ""Sleeping...""
 Sleep the main thread for the given amount of time.
 Print ""Awake!""
 End.


Related task

   Nautical bell

",#Go,Go,"package main
 
import ""time""
import ""fmt""
 
func main() {
    fmt.Print(""Enter number of seconds to sleep: "")
    var sec float64
    fmt.Scanf(""%f"", &sec)
    fmt.Print(""Sleeping…"")
    time.Sleep(time.Duration(sec * float64(time.Second)))
    fmt.Println(""\nAwake!"")
}",270,13
17726,http://rosettacode.org/wiki/Sierpinski_square_curve,Sierpinski square curve,"

Task
Produce a graphical or ASCII-art representation of a Sierpinski square curve of at least order 3.
",#Go,Go,"package main
 
import (
    ""github.com/fogleman/gg""
    ""github.com/trubitsyn/go-lindenmayer""
    ""log""
    ""math""
)
 
const twoPi = 2 * math.Pi
 
var (
    width  = 770.0
    height = 770.0
    dc     = gg.NewContext(int(width), int(height))
)
 
var cx, cy, h, theta float64
 
func main() {
    dc.SetRGB(0, 0, 1) // blue background
    dc.Clear()
    cx, cy = 10, height/2+5
    h = 6
    sys := lindenmayer.Lsystem{
        Variables: []rune{'X'},
        Constants: []rune{'F', '+', '-'},
        Axiom:     ""F+XF+F+XF"",
        Rules: []lindenmayer.Rule{
            {""X"", ""XF-F+F-XF+F+XF-F+F-X""},
        },
        Angle: math.Pi / 2, // 90 degrees in radians
    }
    result := lindenmayer.Iterate(&sys, 5)
    operations := map[rune]func(){
        'F': func() {
            newX, newY := cx+h*math.Sin(theta), cy-h*math.Cos(theta)
            dc.LineTo(newX, newY)
            cx, cy = newX, newY
        },
        '+': func() {
            theta = math.Mod(theta+sys.Angle, twoPi)
        },
        '-': func() {
            theta = math.Mod(theta-sys.Angle, twoPi)
        },
    }
    if err := lindenmayer.Process(result, operations); err != nil {
        log.Fatal(err)
    }
    // needed to close the square at the extreme left
    operations['+']()
    operations['F']()
 
    // create the image and save it
    dc.SetRGB255(255, 255, 0) // yellow curve
    dc.SetLineWidth(2)
    dc.Stroke()
    dc.SavePNG(""sierpinski_square_curve.png"")
}",1463,60
17749,http://rosettacode.org/wiki/Simple_windowed_application,Simple windowed application,"Task

Create a window that has:

   a label that says   ""There have been no clicks yet"" 
   a button that says   ""click me""


Upon clicking the button with the mouse, the label should change and show the number of times the button has been clicked.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""github.com/mattn/go-gtk/gtk""
)
 
func main() {
    gtk.Init(nil)
    window := gtk.NewWindow(gtk.WINDOW_TOPLEVEL)
    window.SetTitle(""Click me"")
    label := gtk.NewLabel(""There have been no clicks yet"")
    var clicks int
    button := gtk.NewButtonWithLabel(""click me"")
    button.Clicked(func() {
        clicks++
        if clicks == 1 {
            label.SetLabel(""Button clicked 1 time"")
        } else {
            label.SetLabel(fmt.Sprintf(""Button clicked %d times"",
                clicks))
        }
    })
    vbox := gtk.NewVBox(false, 1)
    vbox.Add(label)
    vbox.Add(button)
    window.Add(vbox)
    window.Connect(""destroy"", func() {
        gtk.MainQuit()
    })
    window.ShowAll()
    gtk.Main()
}",761,33
17839,http://rosettacode.org/wiki/Sierpinski_arrowhead_curve,Sierpinski arrowhead curve,"Task
Produce a graphical or ASCII-art representation of a  Sierpinski arrowhead curve  of at least order  3.



",#Go,Go,"package main
 
import (
    ""github.com/fogleman/gg""
    ""math""
)
 
var (
    width  = 770.0
    height = 770.0
    dc     = gg.NewContext(int(width), int(height))
    iy     = 1.0
    theta  = 0
)
 
var cx, cy, h float64
 
func arrowhead(order int, length float64) {
    // if order is even, we can just draw the curve
    if order&1 == 0 {
        curve(order, length, 60)
    } else {
        turn(60)
        curve(order, length, -60)
    }
    drawLine(length) // needed to make base symmetric
}
 
func drawLine(length float64) {
    dc.LineTo(cx-width/2+h, (height-cy)*iy+2*h)
    rads := gg.Radians(float64(theta))
    cx += length * math.Cos(rads)
    cy += length * math.Sin(rads)
}
 
func turn(angle int) {
    theta = (theta + angle) % 360
}
 
func curve(order int, length float64, angle int) {
    if order == 0 {
        drawLine(length)
    } else {
        curve(order-1, length/2, -angle)
        turn(angle)
        curve(order-1, length/2, angle)
        turn(angle)
        curve(order-1, length/2, -angle)
    }
}
 
func main() {
    dc.SetRGB(0, 0, 0) // black background
    dc.Clear()
    order := 6
    if order&1 == 0 {
        iy = -1 // apex will point upwards
    }
    cx, cy = width/2, height
    h = cx / 2
    arrowhead(order, cx)
    dc.SetRGB255(255, 0, 255) // magenta curve
    dc.SetLineWidth(2)
    dc.Stroke()
    dc.SavePNG(""sierpinski_arrowhead_curve.png"")
}",1399,66
17944,http://rosettacode.org/wiki/Sierpinski_pentagon,Sierpinski pentagon,"Produce a graphical or ASCII-art representation of a Sierpinski pentagon (aka a Pentaflake) of order 5. Your code should also be able to correctly generate representations of lower orders: 1 to 4.





See also
 Sierpinski pentagon

",#Go,Go,"package main
 
import (
    ""github.com/fogleman/gg""
    ""image/color""
    ""math""
)
 
var (
    red     = color.RGBA{255, 0, 0, 255}
    green   = color.RGBA{0, 255, 0, 255}
    blue    = color.RGBA{0, 0, 255, 255}
    magenta = color.RGBA{255, 0, 255, 255}
    cyan    = color.RGBA{0, 255, 255, 255}
)
 
var (
    w, h        = 640, 640
    dc          = gg.NewContext(w, h)
    deg72       = gg.Radians(72)
    scaleFactor = 1 / (2 + math.Cos(deg72)*2)
    palette     = [5]color.Color{red, green, blue, magenta, cyan}
    colorIndex  = 0
)
 
func drawPentagon(x, y, side float64, depth int) {
    angle := 3 * deg72
    if depth == 0 {
        dc.MoveTo(x, y)
        for i := 0; i < 5; i++ {
            x += math.Cos(angle) * side
            y -= math.Sin(angle) * side
            dc.LineTo(x, y)
            angle += deg72
        }
        dc.SetColor(palette[colorIndex])
        dc.Fill()
        colorIndex = (colorIndex + 1) % 5
    } else {
        side *= scaleFactor
        dist := side * (1 + math.Cos(deg72)*2)
        for i := 0; i < 5; i++ {
            x += math.Cos(angle) * dist
            y -= math.Sin(angle) * dist
            drawPentagon(x, y, side, depth-1)
            angle += deg72
        }
    }
}
 
func main() {
    dc.SetRGB(1, 1, 1) // White background
    dc.Clear()
    order := 5 // Can also set this to 1, 2, 3 or 4
    hw := float64(w / 2)
    margin := 20.0
    radius := hw - 2*margin
    side := radius * math.Sin(math.Pi/5) * 2
    drawPentagon(hw, 3*margin, side, order-1)
    dc.SavePNG(""sierpinski_pentagon.png"")
}",1566,61
17946,http://rosettacode.org/wiki/Sierpinski_triangle/Graphical,Sierpinski triangle/Graphical,"Produce a graphical representation of a Sierpinski triangle of order N in any orientation.

An example of Sierpinski's triangle (order = 8) looks like this: 



",#Go,Go,"package main
 
import (
    ""fmt""
    ""image""
    ""image/color""
    ""image/draw""
    ""image/png""
    ""os""
)
 
func main() {
    const order = 8
    const width = 1 << order
    const margin = 10
    bounds := image.Rect(-margin, -margin, width+2*margin, width+2*margin)
    im := image.NewGray(bounds)
    gBlack := color.Gray{0}
    gWhite := color.Gray{255}
    draw.Draw(im, bounds, image.NewUniform(gWhite), image.ZP, draw.Src)
 
    for y := 0; y < width; y++ {
        for x := 0; x < width; x++ {
            if x&y == 0 {
                im.SetGray(x, y, gBlack)
            }
        }
    }
    f, err := os.Create(""sierpinski.png"")
    if err != nil {
        fmt.Println(err)
        return
    }
    if err = png.Encode(f, im); err != nil {
        fmt.Println(err)
    }
    if err = f.Close(); err != nil {
        fmt.Println(err)
    }
}",854,40
18058,http://rosettacode.org/wiki/Show_the_epoch,Show the epoch,"Task
 
Choose popular date libraries used by your language and show the   epoch   those libraries use.

A demonstration is preferable   (e.g. setting the internal representation of the date to 0 ms/ns/etc.,   or another way that will still show the epoch even if it is changed behind the scenes by the implementers),   but text from (with links to) documentation is also acceptable where a demonstration is impossible/impractical.

For consistency's sake, show the date in UTC time where possible.



Related task

   Date format

",#Go,Go,"package main
import (""fmt""; ""time"")
 
func main() {
    fmt.Println(time.Time{})
}",82,6
18078,http://rosettacode.org/wiki/Shortest_common_supersequence,Shortest common supersequence,"The   shortest common supersequence   is a problem closely related to the   longest common subsequence,   which you can use as an external function for this task.



Task

Given two strings 



u


{\displaystyle u}

 and 



v


{\displaystyle v}

, find the shortest possible sequence 



s


{\displaystyle s}

, which is the shortest common super-sequence of 



u


{\displaystyle u}

 and 



v


{\displaystyle v}

 where both 



u


{\displaystyle u}

 and 



v


{\displaystyle v}

 are a subsequence of 



s


{\displaystyle s}

. Defined as such, 



s


{\displaystyle s}

 is not necessarily unique.

Demonstrate this by printing 



s


{\displaystyle s}

 where 



u
=


{\displaystyle u=}

“abcbdab” and 



v
=


{\displaystyle v=}

“bdcaba”.



Also see

 Wikipedia: shortest common supersequence 

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func lcs(x, y string) string {
    xl, yl := len(x), len(y)
    if xl == 0 || yl == 0 {
        return """"
    }
    x1, y1 := x[:xl-1], y[:yl-1]
    if x[xl-1] == y[yl-1] {
        return fmt.Sprintf(""%s%c"", lcs(x1, y1), x[xl-1])
    }
    x2, y2 := lcs(x, y1), lcs(x1, y)
    if len(x2) > len(y2) {
        return x2
    } else {
        return y2
    }
}
 
func scs(u, v string) string {
    ul, vl := len(u), len(v)
    lcs := lcs(u, v)
    ui, vi := 0, 0
    var sb strings.Builder
    for i := 0; i < len(lcs); i++ {
        for ui < ul && u[ui] != lcs[i] {
            sb.WriteByte(u[ui])
            ui++
        }
        for vi < vl && v[vi] != lcs[i] {
            sb.WriteByte(v[vi])
            vi++
        }
        sb.WriteByte(lcs[i])
        ui++
        vi++
    }
    if ui < ul {
        sb.WriteString(u[ui:])
    }
    if vi < vl {
        sb.WriteString(v[vi:])
    }
    return sb.String()
}
 
func main() {
    u := ""abcbdab""
    v := ""bdcaba""
    fmt.Println(scs(u, v))
}",1049,56
18125,http://rosettacode.org/wiki/Simple_database,Simple database,"Task

Write a simple tool to track a small set of data.

The tool should have a command-line interface to enter at least two different values.

The entered data should be stored in a structured format and saved to disk.

It does not matter what kind of data is being tracked.   It could be a collection (CDs, coins, baseball cards, books), a diary, an electronic organizer (birthdays/anniversaries/phone numbers/addresses), etc.



You should track the following details:

 A description of the item. (e.g., title, name)
 A category or tag (genre, topic, relationship such as “friend” or “family”)
 A date (either the date when the entry was made or some other date that is meaningful, like the birthday); the date may be generated or entered manually
 Other optional fields


The command should support the following Command-line arguments to run:

 Add a new entry
 Print the latest entry
 Print the latest entry for each category
 Print all entries sorted by a date


The category may be realized as a tag or as structure (by making all entries in that category subitems)

The file format on disk should be human readable, but it need not be standardized.   A natively available format that doesn't need an external library is preferred.   Avoid developing your own format if you can use an already existing one.   If there is no existing format available, pick one of:

   JSON
   S-Expressions
   YAML
   others


Related task

   Take notes on the command line 

",#Go,Go,"package main
 
import (
    ""encoding/json""
    ""fmt""
    ""io""
    ""os""
    ""sort""
    ""strings""
    ""time""
    ""unicode""
)
 
// Database record format.  Time stamp and name are required.
// Tags and notes are optional.
type Item struct {
    Stamp time.Time
    Name  string
    Tags  []string `json:"",omitempty""`
    Notes string   `json:"",omitempty""`
}
 
// Item implements stringer interface
func (i *Item) String() string {
    s := i.Stamp.Format(time.ANSIC) + ""\n  Name:  "" + i.Name
    if len(i.Tags) > 0 {
        s = fmt.Sprintf(""%s\n  Tags:  %v"", s, i.Tags)
    }
    if i.Notes > """" {
        s += ""\n  Notes: "" + i.Notes
    }
    return s
}
 
// collection of Items
type db []*Item
 
// db implements sort.Interface
func (d db) Len() int           { return len(d) }
func (d db) Swap(i, j int)      { d[i], d[j] = d[j], d[i] }
func (d db) Less(i, j int) bool { return d[i].Stamp.Before(d[j].Stamp) }
 
// hard coded database file name
const fn = ""sdb.json""
 
func main() {
    if len(os.Args) == 1 {
        latest()
        return
    }
    switch os.Args[1] {
    case ""add"":
        add()
    case ""latest"":
        latest()
    case ""tags"":
        tags()
    case ""all"":
        all()
    case ""help"":
        help()
    default:
        usage(""unrecognized command"")
    }
}
 
func usage(err string) {
    if err > """" {
        fmt.Println(err)
    }
    fmt.Println(`usage:  sdb [command] [data]
    where command is one of add, latest, tags, all, or help.`)
}
 
func help() {
    usage("""")
    fmt.Println(`
Commands must be in lower case.
If no command is specified, the default command is latest.
 
Latest prints the latest item.
All prints all items in chronological order.
Tags prints the lastest item for each tag.
Help prints this message.
 
Add adds data as a new record.  The format is,
 
  name [tags] [notes]
 
Name is the name of the item and is required for the add command.
 
Tags are optional.  A tag is a single word.
A single tag can be specified without enclosing brackets.
Multiple tags can be specified by enclosing them in square brackets.
 
Text remaining after tags is taken as notes.  Notes do not have to be
enclosed in quotes or brackets.  The brackets above are only showing
that notes are optional.
 
Quotes may be useful however--as recognized by your operating system shell
or command line--to allow entry of arbitrary text.  In particular, quotes
or escape characters may be needed to prevent the shell from trying to
interpret brackets or other special characters.
 
Examples:
sdb add Bookends                        // no tags, no notes
sdb add Bookends rock my favorite       // tag: rock, notes: my favorite
sdb add Bookends [rock folk]            // two tags
sdb add Bookends [] ""Simon & Garfunkel"" // notes, no tags
sdb add ""Simon&Garfunkel [artist]""      // name: Simon&Garfunkel, tag: artist
 
As shown in the last example, if you use features of your shell to pass
all data as a single string, the item name and tags will still be identified
by separating whitespace.
 
The database is stored in JSON format in the file ""sdb.json""
`)  
}
 
// load data for read only purposes.
func load() (db, bool) {
    d, f, ok := open()
    if ok {
        f.Close()
        if len(d) == 0 {
            fmt.Println(""no items"")
            ok = false
        }
    }
    return d, ok
}
 
// open database, leave open
func open() (d db, f *os.File, ok bool) {
    var err error
    f, err = os.OpenFile(fn, os.O_RDWR|os.O_CREATE, 0666)
    if err != nil {
        fmt.Println(""cant open??"")
        fmt.Println(err)
        return
    }
    jd := json.NewDecoder(f)
    err = jd.Decode(&d)
    // EOF just means file was empty.  That's okay with us.
    if err != nil && err != io.EOF {
        fmt.Println(err)
        f.Close()
        return
    }
    ok = true
    return
}
 
// handle latest command
func latest() {
    d, ok := load()
    if !ok {
        return
    }
    sort.Sort(d)
    fmt.Println(d[len(d)-1])
}
 
// handle all command
func all() {
    d, ok := load()
    if !ok {
        return
    }
    sort.Sort(d)
    for _, i := range d {
        fmt.Println(""-----------------------------------"")
        fmt.Println(i)
    }
    fmt.Println(""-----------------------------------"")
}
 
// handle tags command
func tags() {
    d, ok := load()
    if !ok {
        return
    }
    // we have to traverse the entire list to collect tags so there
    // is no point in sorting at this point.
    // collect set of unique tags associated with latest item for each
    latest := make(map[string]*Item)
    for _, item := range d {
        for _, tag := range item.Tags {
            li, ok := latest[tag]
            if !ok || item.Stamp.After(li.Stamp) {
                latest[tag] = item
            }
        }
    }
    // invert to set of unique items, associated with subset of tags
    // for which the item is the latest.
    type itemTags struct {
        item *Item
        tags []string
    }
    inv := make(map[*Item][]string)
    for tag, item := range latest {
        inv[item] = append(inv[item], tag)
    }
    // now we sort just the items we will output
    li := make(db, len(inv))
    i := 0
    for item := range inv {
        li[i] = item
        i++
    }
    sort.Sort(li)
    // finally ready to print
    for _, item := range li {
        tags := inv[item]
        fmt.Println(""-----------------------------------"")
        fmt.Println(""Latest item with tags"", tags)
        fmt.Println(item)
    }
    fmt.Println(""-----------------------------------"")
}
 
// handle add command
func add() { 
    if len(os.Args) < 3 {
        usage(""add command requires data"")
        return
    } else if len(os.Args) == 3 {
        add1()
    } else {
        add4()
    }
}   
 
// add command with one data string.  look for ws as separators.
func add1() {
    data := strings.TrimLeftFunc(os.Args[2], unicode.IsSpace)
    if data == """" {
        // data must have at least some non-whitespace
        usage(""invalid name"")
        return 
    }
    sep := strings.IndexFunc(data, unicode.IsSpace)
    if sep < 0 {
        // data consists only of a name
        addItem(data, nil, """")
        return
    }
    name := data[:sep]
    data = strings.TrimLeftFunc(data[sep:], unicode.IsSpace)
    if data == """" {
        // nevermind trailing ws, it's still only a name
        addItem(name, nil, """")
        return
    }
    if data[0] == '[' {
        sep = strings.Index(data, ""]"")
        if sep < 0 {
            // close bracketed list for the user.  no notes.
            addItem(name, strings.Fields(data[1:]), """")
        } else {
            // brackets make things easy
            addItem(name, strings.Fields(data[1:sep]),
                strings.TrimLeftFunc(data[sep+1:], unicode.IsSpace))
        }
        return
    }
    sep = strings.IndexFunc(data, unicode.IsSpace)
    if sep < 0 {
        // remaining word is a tag
        addItem(name, []string{data}, """")
    } else {
        // there's a tag and some data
        addItem(name, []string{data[:sep]},
            strings.TrimLeftFunc(data[sep+1:], unicode.IsSpace))
    }
}
 
// add command with multiple strings remaining on command line
func add4() {
    name := os.Args[2]
    tag1 := os.Args[3]
    if tag1[0] != '[' {
        // no brackets makes things easy
        addItem(name, []string{tag1}, strings.Join(os.Args[4:], "" ""))
        return
    }
    if tag1[len(tag1)-1] == ']' {
        // tags all in one os.Arg is easy too
        addItem(name, strings.Fields(tag1[1:len(tag1)-1]),
            strings.Join(os.Args[4:], "" ""))
        return
    }
    // start a list for tags
    var tags []string
    if tag1 > ""["" {
        tags = []string{tag1[1:]}
    }
    for x, tag := range os.Args[4:] {
        if tag[len(tag)-1] != ']' {
            tags = append(tags, tag)
        } else {
            // found end of tag list
            if tag > ""]"" {
                tags = append(tags, tag[:len(tag)-1])
            }
            addItem(name, tags, strings.Join(os.Args[5+x:], "" ""))
            return
        }
    }
    // close bracketed list for the user.  no notes.
    addItem(name, tags, """")
}
 
// complete the add command
func addItem(name string, tags []string, notes string) {
    db, f, ok := open()
    if !ok {
        return
    }
    defer f.Close()
    // add the item and format JSON
    db = append(db, &Item{time.Now(), name, tags, notes})
    sort.Sort(db)
    js, err := json.MarshalIndent(db, """", ""  "")
    if err != nil {
        fmt.Println(err)
        return
    }
    // time to overwrite the file
    if _, err = f.Seek(0, 0); err != nil {
        fmt.Println(err)
        return
    }
    f.Truncate(0)
    if _, err = f.Write(js); err != nil {
        fmt.Println(err)
    }
}",8774,340
18248,http://rosettacode.org/wiki/Shoelace_formula_for_polygonal_area,Shoelace formula for polygonal area,"Given the n + 1 vertices x[0], y[0] .. x[N], y[N] of a simple polygon described in a clockwise direction, then the polygon's area can be calculated by:

abs( (sum(x[0]*y[1] + ... x[n-1]*y[n]) + x[N]*y[0]) -
     (sum(x[1]*y[0] + ... x[n]*y[n-1]) + x[0]*y[N])
   ) / 2
(Where abs returns the absolute value)

Task

Write a function/method/routine to use the the Shoelace formula to calculate the area of the polygon described by the ordered points:

     (3,4), (5,11), (12,8), (9,5), and (5,6) 



Show the answer here, on this page.



",#Go,Go,"package main
 
import ""fmt""
 
type point struct{ x, y float64 }
 
func shoelace(pts []point) float64 {
    sum := 0.
    p0 := pts[len(pts)-1]
    for _, p1 := range pts {
        sum += p0.y*p1.x - p0.x*p1.y
        p0 = p1
    }
    return sum / 2
}
 
func main() {
    fmt.Println(shoelace([]point{{3, 4}, {5, 11}, {12, 8}, {9, 5}, {5, 6}}))
}",346,19
18307,http://rosettacode.org/wiki/Shell_one-liner,Shell one-liner,"Task

Show how to specify and execute a short program in the language from a command shell, where the input to the command shell is only one line in length.

Avoid depending on the particular shell or operating system used as much as is reasonable; if the language has notable implementations which have different command argument syntax, or the systems those implementations run on have different styles of shells, it would be good to show multiple examples.



",#Go,Go,"echo 'package main;func main(){println(""hlowrld"")}'>/tmp/h.go;go run /tmp/h.go",78,1
18312,http://rosettacode.org/wiki/Sierpinski_triangle,Sierpinski triangle,"Task
Produce an ASCII representation of a Sierpinski triangle of order   N.



Example
The Sierpinski triangle of order   4   should look like this:

                       *
                      * *
                     *   *
                    * * * *
                   *       *
                  * *     * *
                 *   *   *   *
                * * * * * * * *
               *               *
              * *             * *
             *   *           *   *
            * * * *         * * * *
           *       *       *       *
          * *     * *     * *     * *
         *   *   *   *   *   *   *   *
        * * * * * * * * * * * * * * * *



Related tasks
 Sierpinski triangle/Graphical for graphics images of this pattern. 
 Sierpinski carpet

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
    ""unicode/utf8""
)
 
var order = 4
var grain = ""*""
 
func main() {
    t := []string{grain + strings.Repeat("" "", utf8.RuneCountInString(grain))}
    for ; order > 0; order-- {
        sp := strings.Repeat("" "", utf8.RuneCountInString(t[0])/2)
        top := make([]string, len(t))
        for i, s := range t {
            top[i] = sp + s + sp
            t[i] += s
        }
        t = append(top, t...)
    }
    for _, r := range t {
        fmt.Println(r)
    }
}",517,26
18396,http://rosettacode.org/wiki/SHA-256_Merkle_tree,SHA-256 Merkle tree,"As described in its documentation, Amazon S3 Glacier requires that all uploaded files come with a checksum computed as a Merkle Tree using SHA-256.

Specifically, the SHA-256 hash is computed for each 1MiB block of the file. And then, starting from the beginning of the file, the raw hashes of consecutive blocks are paired up and concatenated together, and a new hash is computed from each concatenation. Then these are paired up and concatenated and hashed, and the process continues until there is only one hash left, which is the final checksum. The hexadecimal representation of this checksum is the value that must be included with the AWS API call to upload the object (or complete a multipart upload).

Implement this algorithm in your language; you can use the code from the SHA-256 task for the actual hash computations. For better manageability and portability, build the tree using a smaller block size of only 1024 bytes, and demonstrate it on the RosettaCode title image with that block size. The final result should be the hexadecimal digest value a4f902cf9d51fe51eda156a6792e1445dff65edf3a217a1f3334cc9cf1495c2c.
",#Go,Go,"package main
 
import (
    ""crypto/sha256""
    ""fmt""
    ""io""
    ""log""
    ""os""
)
 
func main() {
    const blockSize = 1024
    f, err := os.Open(""title.png"")
    if err != nil {
        log.Fatal(err)
    }
    defer f.Close()
 
    var hashes [][]byte
    buffer := make([]byte, blockSize)
    h := sha256.New()
    for {
        bytesRead, err := f.Read(buffer)
        if err != nil {
            if err != io.EOF {
                log.Fatal(err)
            }
            break
        }
        h.Reset()
        h.Write(buffer[:bytesRead])
        hashes = append(hashes, h.Sum(nil))
    }
    buffer = make([]byte, 64)
    for len(hashes) > 1 {
        var hashes2 [][]byte
        for i := 0; i < len(hashes); i += 2 {
            if i < len(hashes)-1 {                
                copy(buffer, hashes[i])
                copy(buffer[32:], hashes[i+1])
                h.Reset()
                h.Write(buffer)
                hashes2 = append(hashes2, h.Sum(nil))
            } else {
                hashes2 = append(hashes2, hashes[i])
            }
        }
        hashes = hashes2
    }
    fmt.Printf(""%x"", hashes[0])
    fmt.Println()
}",1161,52
18412,http://rosettacode.org/wiki/Set_right-adjacent_bits,Set right-adjacent bits,"Given a left-to-right ordered collection of e bits, b, where 1 <= e <= 10000,
and a zero or more integer n :

 Output the result of setting the n bits to the right of any set bit in b 
(if those bits are present in b and therefore also preserving the width, e).

Some examples:

   Set of examples showing how one bit in a nibble gets changed:
       
       n = 2; Width e = 4:
       
            Input b: 1000
             Result: 1110
       
            Input b: 0100
             Result: 0111
       
            Input b: 0010
             Result: 0011
       
            Input b: 0000
             Result: 0000
   
   Set of examples with the same input with set bits of varying distance apart:
   
       n = 0; Width e = 66:
       
            Input b: 010000000000100000000010000000010000000100000010000010000100010010
             Result: 010000000000100000000010000000010000000100000010000010000100010010
       
       n = 1; Width e = 66:
       
            Input b: 010000000000100000000010000000010000000100000010000010000100010010
             Result: 011000000000110000000011000000011000000110000011000011000110011011
       
       n = 2; Width e = 66:
       
            Input b: 010000000000100000000010000000010000000100000010000010000100010010
             Result: 011100000000111000000011100000011100000111000011100011100111011111
       
       n = 3; Width e = 66:
       
            Input b: 010000000000100000000010000000010000000100000010000010000100010010
             Result: 011110000000111100000011110000011110000111100011110011110111111111


Task:

 Implement a routine to perform the setting of right-adjacent bits on representations of bits that will scale over the given range of input width e.
 Use it to show, here, the results for the input examples above.
 Print the output aligned in a way that allows easy checking by eye of the binary input vs output.",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
type test struct {
    bs string
    n  int
}
 
func setRightBits(bits []byte, e, n int) []byte {
    if e == 0 || n <= 0 {
        return bits
    }
    bits2 := make([]byte, len(bits))
    copy(bits2, bits)
    for i := 0; i < e-1; i++ {
        c := bits[i]
        if c == 1 {
            j := i + 1
            for j <= i+n && j < e {
                bits2[j] = 1
                j++
            }
        }
    }
    return bits2
}
 
func main() {
    b := ""010000000000100000000010000000010000000100000010000010000100010010""
    tests := []test{
        test{""1000"", 2}, test{""0100"", 2}, test{""0010"", 2}, test{""0000"", 2},
        test{b, 0}, test{b, 1}, test{b, 2}, test{b, 3},
    }
    for _, test := range tests {
        bs := test.bs
        e := len(bs)
        n := test.n
        fmt.Println(""n ="", n, ""\b; Width e ="", e, ""\b:"")
        fmt.Println(""    Input b:"", bs)
        bits := []byte(bs)
        for i := 0; i < len(bits); i++ {
            bits[i] = bits[i] - '0'
        }
        bits = setRightBits(bits, e, n)
        var sb strings.Builder
        for i := 0; i < len(bits); i++ {
            sb.WriteByte(bits[i] + '0')
        }
        fmt.Println(""    Result :"", sb.String())
    }
}",1268,55
18489,http://rosettacode.org/wiki/Sexy_primes,Sexy primes,"

 This page uses content from Wikipedia. The original article was at Sexy_prime. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In mathematics, sexy primes are prime numbers that differ from each other by six.

For example, the numbers 5 and 11 are both sexy primes, because 11 minus 6 is 5.

The term ""sexy prime"" is a pun stemming from the Latin word for six: sex.



Sexy prime pairs: Sexy prime pairs are groups of two primes that differ by 6. e.g. (5 11), (7 13), (11 17)

See sequences: OEIS:A023201 and OEIS:A046117

Sexy prime triplets: Sexy prime triplets are groups of three primes where each differs from the next by 6. e.g. (5 11 17), (7 13 19), (17 23 29)

See sequences: OEIS:A046118, OEIS:A046119 and OEIS:A046120

Sexy prime quadruplets: Sexy prime quadruplets are groups of four primes where each differs from the next by 6. e.g. (5 11 17 23), (11 17 23 29)

See sequences: OEIS:A023271, OEIS:A046122, OEIS:A046123 and OEIS:A046124

Sexy prime quintuplets: Sexy prime quintuplets are groups of five primes with a common difference of 6. One of the terms must be divisible by 5, because 5 and 6 are relatively prime. Thus, the only possible sexy prime quintuplet is (5 11 17 23 29)

Task

For each of pairs, triplets, quadruplets and quintuplets, Find and display the count of each group type of sexy primes less than one million thirty-five (1,000,035).
Display at most the last 5, less than one million thirty-five, of each sexy prime group type.
Find and display the count of the unsexy primes less than one million thirty-five.
Find and display the last 10 unsexy primes less than one million thirty-five.
Note that 1000033 SHOULD NOT be counted in the pair count. It is sexy, but not in a pair within the limit. However, it also SHOULD NOT be listed in the unsexy primes since it is sexy. 

",#Go,Go,"package main
 
import ""fmt""
 
func sieve(limit int) []bool {
    limit++
    // True denotes composite, false denotes prime.
    c := make([]bool, limit) // all false by default
    c[0] = true
    c[1] = true
    // no need to bother with even numbers over 2 for this task
    p := 3 // Start from 3.
    for {
        p2 := p * p
        if p2 >= limit {
            break
        }
        for i := p2; i < limit; i += 2 * p {
            c[i] = true
        }
        for {
            p += 2
            if !c[p] {
                break
            }
        }
    }
    return c
}
 
func commatize(n int) string {
    s := fmt.Sprintf(""%d"", n)
    if n < 0 {
        s = s[1:]
    }
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    if n >= 0 {
        return s
    }
    return ""-"" + s
}
 
func printHelper(cat string, le, lim, max int) (int, int, string) {
    cle, clim := commatize(le), commatize(lim)
    if cat != ""unsexy primes"" {
        cat = ""sexy prime "" + cat
    }
    fmt.Printf(""Number of %s less than %s = %s\n"", cat, clim, cle)
    last := max
    if le < last {
        last = le
    }
    verb := ""are""
    if last == 1 {
        verb = ""is""
    }
    return le, last, verb
}
 
func main() {
    lim := 1000035
    sv := sieve(lim - 1)
    var pairs [][2]int
    var trips [][3]int
    var quads [][4]int
    var quins [][5]int
    var unsexy = []int{2, 3}
    for i := 3; i < lim; i += 2 {
        if i > 5 && i < lim-6 && !sv[i] && sv[i-6] && sv[i+6] {
            unsexy = append(unsexy, i)
            continue
        }
        if i < lim-6 && !sv[i] && !sv[i+6] {
            pair := [2]int{i, i + 6}
            pairs = append(pairs, pair)
        } else {
            continue
        }
        if i < lim-12 && !sv[i+12] {
            trip := [3]int{i, i + 6, i + 12}
            trips = append(trips, trip)
        } else {
            continue
        }
        if i < lim-18 && !sv[i+18] {
            quad := [4]int{i, i + 6, i + 12, i + 18}
            quads = append(quads, quad)
        } else {
            continue
        }
        if i < lim-24 && !sv[i+24] {
            quin := [5]int{i, i + 6, i + 12, i + 18, i + 24}
            quins = append(quins, quin)
        }
    }
    le, n, verb := printHelper(""pairs"", len(pairs), lim, 5)
    fmt.Printf(""The last %d %s:\n  %v\n\n"", n, verb, pairs[le-n:])
 
    le, n, verb = printHelper(""triplets"", len(trips), lim, 5)
    fmt.Printf(""The last %d %s:\n  %v\n\n"", n, verb, trips[le-n:])
 
    le, n, verb = printHelper(""quadruplets"", len(quads), lim, 5)
    fmt.Printf(""The last %d %s:\n  %v\n\n"", n, verb, quads[le-n:])
 
    le, n, verb = printHelper(""quintuplets"", len(quins), lim, 5)
    fmt.Printf(""The last %d %s:\n  %v\n\n"", n, verb, quins[le-n:])
 
    le, n, verb = printHelper(""unsexy primes"", len(unsexy), lim, 10)
    fmt.Printf(""The last %d %s:\n  %v\n\n"", n, verb, unsexy[le-n:])
}",2936,113
18570,http://rosettacode.org/wiki/Short-circuit_evaluation,Short-circuit evaluation,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops



Assume functions   a   and   b   return boolean values,   and further, the execution of function   b   takes considerable resources without side effects, and is to be minimized.

If we needed to compute the conjunction   (and):

  x = a() and b() 
Then it would be best to not compute the value of   b()   if the value of   a()   is computed as   false,   as the value of   x   can then only ever be    false.

Similarly, if we needed to compute the disjunction (or):

  y = a() or b() 
Then it would be best to not compute the value of   b()   if the value of   a()   is computed as   true,   as the value of   y   can then only ever be   true.

Some languages will stop further computation of boolean equations as soon as the result is known, so-called   short-circuit evaluation   of boolean expressions



Task

Create two functions named   a   and   b,   that take and return the same boolean value.

The functions should also print their name whenever they are called.

Calculate and assign the values of the following equations to a variable in such a way that function   b   is only called when necessary:

  x = a(i) and b(j) 
  y = a(i) or b(j) 

If the language does not have short-circuit evaluation, this might be achieved with nested     if     statements.



",#Go,Go,"package main
 
import ""fmt""
 
func a(v bool) bool {
    fmt.Print(""a"")
    return v
}
 
func b(v bool) bool {
    fmt.Print(""b"")
    return v
}
 
func test(i, j bool) {
    fmt.Printf(""Testing a(%t) && b(%t)\n"", i, j)
    fmt.Print(""Trace:  "")
    fmt.Println(""\nResult:"", a(i) && b(j))
 
    fmt.Printf(""Testing a(%t) || b(%t)\n"", i, j)
    fmt.Print(""Trace:  "")
    fmt.Println(""\nResult:"", a(i) || b(j))
 
    fmt.Println("""")
}
 
func main() {
    test(false, false)
    test(false, true)
    test(true, false)
    test(true, true)
}",536,32
18619,http://rosettacode.org/wiki/Set_puzzle,Set puzzle,"Set Puzzles are created with a deck of cards from the Set Game™. The object of the puzzle is to find sets of 3 cards in a rectangle of cards that have been dealt face up. 


There are 81 cards in a deck.
Each card contains a unique variation of the following four features: color, symbol, number and shading.

 there are three colors:
    red, green, purple

 there are three symbols:
    oval, squiggle, diamond

 there is a number of symbols on the card:
    one, two, three

 there are three shadings:
    solid, open, striped

Three cards form a set if each feature is either the same on each card, or is different on each card. For instance: all 3 cards are red, all 3 cards have a different symbol, all 3 cards have a different number of symbols, all 3 cards are striped.

There are two degrees of difficulty: basic and advanced. The basic mode deals 9 cards, that contain exactly 4 sets; the advanced mode deals 12 cards that contain exactly 6 sets.

When creating sets you may use the same card more than once.




Task
Write code that deals the cards (9 or 12, depending on selected mode) from a shuffled deck in which the total number of sets that could be found is 4 (or 6, respectively); and print the contents of the cards and the sets.

For instance:



DEALT 9 CARDS:

green, one, oval, striped
green, one, diamond, open
green, one, diamond, striped
green, one, diamond, solid
purple, one, diamond, open
purple, two, squiggle, open
purple, three, oval, open
red, three, oval, open
red, three, diamond, solid

CONTAINING 4 SETS:

green, one, oval, striped
purple, two, squiggle, open
red, three, diamond, solid


green, one, diamond, open
green, one, diamond, striped
green, one, diamond, solid


green, one, diamond, open
purple, two, squiggle, open
red, three, oval, open


purple, one, diamond, open
purple, two, squiggle, open
purple, three, oval, open

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
const (
    number = [3]string{""1"", ""2"", ""3""}
    color  = [3]string{""red"", ""green"", ""purple""}
    shade  = [3]string{""solid"", ""open"", ""striped""}
    shape  = [3]string{""oval"", ""squiggle"", ""diamond""}
)
 
type card int
 
func (c card) String() string {
    return fmt.Sprintf(""%s %s %s %s"",
        number[c/27],
        color[c/9%3],
        shade[c/3%3],
        shape[c%3])
}
 
func main() {
    rand.Seed(time.Now().Unix())
    game(""Basic"", 9, 4)
    game(""Advanced"", 12, 6)
}
 
func game(level string, cards, sets int) {
    // create deck
    d := make([]card, 81)
    for i := range d {
        d[i] = card(i)
    }
    var found [][3]card
    for len(found) != sets {
        found = found[:0]
        // deal
        for i := 0; i < cards; i++ {
            j := rand.Intn(81 - i)
            d[i], d[j] = d[j], d[i]
        }
        //  consider all triplets
        for i := 2; i < cards; i++ {
            c1 := d[i]
            for j := 1; j < i; j++ {
                c2 := d[j]
            l3:
                for _, c3 := range d[:j] {
                    for f := card(1); f < 81; f *= 3 {
                        if (c1/f%3 + c2/f%3 + c3/f%3) % 3 != 0 {
                            continue l3 // not a set
                        }
                    }
                    // it's a set
                    found = append(found, [3]card{c1, c2, c3})
                }
            }
        }
    }
    // found the right number
    fmt.Printf(""%s game.  %d cards, %d sets.\n"", level, cards, sets)
    fmt.Println(""Cards:"")
    for _, c := range d[:cards] {
        fmt.Println(""  "", c)
    }
    fmt.Println(""Sets:"")
    for _, s := range found {
        fmt.Printf(""  %s\n  %s\n  %s\n"",s[0],s[1],s[2])
    }
}",1796,74
18634,http://rosettacode.org/wiki/Seven-sided_dice_from_five-sided_dice,Seven-sided dice from five-sided dice,"Task

(Given an equal-probability generator of one of the integers 1 to 5
as dice5),   create dice7 that generates a pseudo-random integer from
1 to 7 in equal probability using only dice5 as a source of random
numbers,   and check the distribution for at least one million calls using the function created in   Simple Random Distribution Checker.


Implementation suggestion:
dice7 might call dice5 twice, re-call if four of the 25
combinations are given, otherwise split the other 21 combinations
into 7 groups of three, and return the group index from the rolls.

(Task adapted from an answer here)
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/rand""
    ""time""
)
 
// ""given""
func dice5() int {
    return rand.Intn(5) + 1
}
 
// function specified by task ""Seven-sided dice from five-sided dice""
func dice7() (i int) {
    for {
        i = 5*dice5() + dice5()
        if i < 27 {
            break
        }
    }
    return (i / 3) - 1
}
 
// function specified by task ""Verify distribution uniformity/Naive""
//
// Parameter ""f"" is expected to return a random integer in the range 1..n.
// (Values out of range will cause an unceremonious crash.)
// ""Max"" is returned as an ""indication of distribution achieved.""
// It is the maximum delta observed from the count representing a perfectly
// uniform distribution.
// Also returned is a boolean, true if ""max"" is less than threshold
// parameter ""delta.""
func distCheck(f func() int, n int,
    repeats int, delta float64) (max float64, flatEnough bool) {
    count := make([]int, n)
    for i := 0; i < repeats; i++ {
        count[f()-1]++
    }
    expected := float64(repeats) / float64(n)
    for _, c := range count {
        max = math.Max(max, math.Abs(float64(c)-expected))
    }
    return max, max < delta
}
 
// Driver, produces output satisfying both tasks.
func main() {
    rand.Seed(time.Now().UnixNano())
    const calls = 1000000
    max, flatEnough := distCheck(dice7, 7, calls, 500)
    fmt.Println(""Max delta:"", max, ""Flat enough:"", flatEnough)
    max, flatEnough = distCheck(dice7, 7, calls, 500)
    fmt.Println(""Max delta:"", max, ""Flat enough:"", flatEnough)
}",1547,56
18638,http://rosettacode.org/wiki/Sierpinski_carpet,Sierpinski carpet,"Task
Produce a graphical or ASCII-art representation of a Sierpinski carpet of order   N.



For example, the Sierpinski carpet of order   3   should look like this:

###########################
# ## ## ## ## ## ## ## ## #
###########################
###   ######   ######   ###
# #   # ## #   # ## #   # #
###   ######   ######   ###
###########################
# ## ## ## ## ## ## ## ## #
###########################
#########         #########
# ## ## #         # ## ## #
#########         #########
###   ###         ###   ###
# #   # #         # #   # #
###   ###         ###   ###
#########         #########
# ## ## #         # ## ## #
#########         #########
###########################
# ## ## ## ## ## ## ## ## #
###########################
###   ######   ######   ###
# #   # ## #   # ## #   # #
###   ######   ######   ###
###########################
# ## ## ## ## ## ## ## ## #
###########################

The use of the   #   character is not rigidly required for ASCII art.

The important requirement is the placement of whitespace and non-whitespace characters.



Related task

   Sierpinski triangle

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
    ""unicode/utf8""
)
 
var order = 3
var grain = ""#""
 
func main() {
    carpet := []string{grain}
    for ; order > 0; order-- {
        // repeat expression allows for multiple character
        // grain and for multi-byte UTF-8 characters.
        hole := strings.Repeat("" "", utf8.RuneCountInString(carpet[0]))
        middle := make([]string, len(carpet))
        for i, s := range carpet {
            middle[i] = s + hole + s
            carpet[i] = strings.Repeat(s, 3)
        }
        carpet = append(append(carpet, middle...), carpet...)
    }
    for _, r := range carpet {
        fmt.Println(r)
    }
}",664,28
18659,http://rosettacode.org/wiki/SHA-1,SHA-1,"SHA-1 or SHA1 is a one-way hash function;
it computes a 160-bit message digest.
SHA-1 often appears in security protocols; for example,
many HTTPS websites use RSA with SHA-1 to secure their connections.
BitTorrent uses SHA-1 to verify downloads.
Git and Mercurial use SHA-1 digests to identify commits.

A US government standard, FIPS 180-1, defines SHA-1.

Find the SHA-1 message digest for a string of octets. You may either call a SHA-1 library, or implement SHA-1 in your language. Both approaches interest Rosetta Code.



 Warning: SHA-1 has known weaknesses. Theoretical attacks may find a collision after 252 operations, or perhaps fewer.
This is much faster than a brute force attack of 280 operations. USgovernment deprecated SHA-1.
For production-grade cryptography, users may consider a stronger alternative, such as SHA-256 (from the SHA-2 family) or the upcoming SHA-3.

",#Go,Go,"package main
 
import (
    ""crypto/sha1""
    ""fmt""
)
 
func main() {
    h := sha1.New()
    h.Write([]byte(""Rosetta Code""))
    fmt.Printf(""%x\n"", h.Sum(nil))
}",162,12
18687,http://rosettacode.org/wiki/SHA-256,SHA-256,"SHA-256 is the recommended stronger alternative to SHA-1. See FIPS PUB 180-4 for implementation details.

Either by using a dedicated library or implementing the algorithm in your language, show that the SHA-256 digest of the string ""Rosetta code"" is: 764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf
",#Go,Go,"package main
 
import (
    ""crypto/sha256""
    ""fmt""
    ""log""
)
 
func main() {
    h := sha256.New()
    if _, err := h.Write([]byte(""Rosetta code"")); err != nil {
        log.Fatal(err)
    }
    fmt.Printf(""%x\n"", h.Sum(nil))
}",232,15
18787,http://rosettacode.org/wiki/Show_ASCII_table,Show ASCII table,"Task

Show  the ASCII character set  from values   32   to   127   (decimal)   in a table format.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    for i := 0; i < 16; i++ {
        for j := 32 + i; j < 128; j += 16 {
            k := string(j)
            switch j {
            case 32:
                k = ""Spc""
            case 127:
                k = ""Del""
            }
            fmt.Printf(""%3d : %-3s   "", j, k)
        }
        fmt.Println()
    }
}",362,19
18801,http://rosettacode.org/wiki/Sequence:_smallest_number_greater_than_previous_term_with_exactly_n_divisors,Sequence: smallest number greater than previous term with exactly n divisors,"Calculate the sequence where each term an is the smallest natural number greater than the previous term, that has exactly n divisors.



Task
Show here, on this page, at least the first 15 terms of the sequence.



See also
 OEIS:A069654


Related tasks
 Sequence: smallest number with exactly n divisors
 Sequence: nth number with exactly n divisors‎‎

",#Go,Go,"package main
 
import ""fmt""
 
func countDivisors(n int) int {
    count := 0
    for i := 1; i*i <= n; i++ {
        if n%i == 0 {
            if i == n/i {
                count++
            } else {
                count += 2
            }
        }
    }
    return count
}
 
func main() {
    const max = 15
    fmt.Println(""The first"", max, ""terms of the sequence are:"")
    for i, next := 1, 1; next <= max; i++ {
        if next == countDivisors(i) {
            fmt.Printf(""%d "", i)
            next++
        }
    }
    fmt.Println()
}",546,29
18816,http://rosettacode.org/wiki/Sequence:_nth_number_with_exactly_n_divisors,Sequence: nth number with exactly n divisors,"Calculate the sequence where each term an is the nth that has n divisors.

Task
Show here, on this page, at least the first 15 terms of the sequence.

See also
OEIS:A073916
Related tasks
Sequence: smallest number greater than previous term with exactly n divisors
Sequence: smallest number with exactly n divisors",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/big""
)
 
var bi = new(big.Int)
 
func isPrime(n int) bool {
    bi.SetUint64(uint64(n))
    return bi.ProbablyPrime(0)
}
 
func generateSmallPrimes(n int) []int {
    primes := make([]int, n)
    primes[0] = 2
    for i, count := 3, 1; count < n; i += 2 {
        if isPrime(i) {
            primes[count] = i
            count++
        }
    }
    return primes
}
 
func countDivisors(n int) int {
    count := 1
    for n%2 == 0 {
        n >>= 1
        count++
    }
    for d := 3; d*d <= n; d += 2 {
        q, r := n/d, n%d
        if r == 0 {
            dc := 0
            for r == 0 {
                dc += count
                n = q
                q, r = n/d, n%d
            }
            count += dc
        }
    }
    if n != 1 {
        count *= 2
    }
    return count
}
 
func main() {
    const max = 33
    primes := generateSmallPrimes(max)
    z := new(big.Int)
    p := new(big.Int)
    fmt.Println(""The first"", max, ""terms in the sequence are:"")
    for i := 1; i <= max; i++ {
        if isPrime(i) {
            z.SetUint64(uint64(primes[i-1]))
            p.SetUint64(uint64(i - 1))
            z.Exp(z, p, nil)
            fmt.Printf(""%2d : %d\n"", i, z)
        } else {
            count := 0
            for j := 1; ; j++ {
                if i%2 == 1 {
                    sq := int(math.Sqrt(float64(j)))
                    if sq*sq != j {
                        continue
                    }
                }
                if countDivisors(j) == i {
                    count++
                    if count == i {
                        fmt.Printf(""%2d : %d\n"", i, j)
                        break
                    }
                }
            }
        }
    }
}",1769,83
18840,http://rosettacode.org/wiki/Sequence:_smallest_number_with_exactly_n_divisors,Sequence: smallest number with exactly n divisors,"Calculate the sequence where each term   an   is the smallest natural number that has exactly   n   divisors.



Task
Show here, on this page, at least the first  15  terms of the sequence.



Related tasks

 Sequence: smallest number greater than previous term with exactly n divisors
 Sequence: nth number with exactly n divisors‎‎


See also

 OEIS:A005179

",#Go,Go,"package main
 
import ""fmt""
 
func countDivisors(n int) int {
    count := 0
    for i := 1; i*i <= n; i++ {
        if n%i == 0 {
            if i == n/i {
                count++
            } else {
                count += 2
            }
        }
    }
    return count
}
 
func main() {
    const max = 15
    seq := make([]int, max)
    fmt.Println(""The first"", max, ""terms of the sequence are:"")
    for i, n := 1, 0; n < max; i++ {
        if k := countDivisors(i); k <= max && seq[k-1] == 0 {
            seq[k-1] = i
            n++
        }
    }
    fmt.Println(seq)
}",583,30
18932,http://rosettacode.org/wiki/Sequence_of_primorial_primes,Sequence of primorial primes,"The sequence of primorial primes is given as the increasing values of n where primorial(n) ± 1 is prime.

Noting that the n'th primorial is defined as the multiplication of the smallest n primes, the sequence is of the number of primes, in order that when multiplied together is one-off being a prime number itself.



Task

Generate and show here the first ten values of the sequence.



Optional extended task

Show the first twenty members of the series.



Notes
 
 This task asks for the primorial indices that create the final primorial prime numbers, so there should be no ten-or-more digit numbers in the program output (although extended precision integers will be needed for intermediate results).
 There is some confusion in the references, but for the purposes of this task the sequence begins with n = 1.
 Probabilistic primality tests are allowed, as long as they are good enough such that the output shown is correct.


Related tasks

 Primorial numbers
 Factorial


See also

 Primorial prime Wikipedia.
 Primorial prime from The Prime Glossary.
 Sequence A088411 from The On-Line Encyclopedia of Integer Sequences

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    one := big.NewInt(1)
    pm := big.NewInt(1) // primorial
    var px, nx int
    var pb big.Int // a scratch value
    primes(4000, func(p int64) bool {
        pm.Mul(pm, pb.SetInt64(p))
        px++
        if pb.Add(pm, one).ProbablyPrime(0) ||
            pb.Sub(pm, one).ProbablyPrime(0) {
            fmt.Print(px, "" "")
            nx++
            if nx == 20 {
                fmt.Println()
                return false
            }
        }
        return true
    })
}
 
// Code taken from task Sieve of Eratosthenes, and put into this function
// that calls callback function f for each prime < limit, but terminating
// if the callback returns false.
func primes(limit int, f func(int64) bool) {
    c := make([]bool, limit)
    c[0] = true
    c[1] = true
    lm := int64(limit)
    p := int64(2)
    for {
        f(p)
        p2 := p * p
        if p2 >= lm {
            break
        }
        for i := p2; i < lm; i += p {
            c[i] = true
        }
        for {
            p++
            if !c[p] {
                break
            }
        }
    }
    for p++; p < lm; p++ {
        if !c[p] && !f(p) {
            break
        }
    }
}",1243,59
18936,http://rosettacode.org/wiki/Set_consolidation,Set consolidation,"Given two sets of items then if any item is common to any set then the result of applying consolidation to those sets is a set of sets whose contents is:

 The two input sets if no common item exists between the two input sets of items.
 The single set that is the union of the two input sets if they share a common item.

Given N sets of items where N>2 then the result is the same as repeatedly replacing all combinations of two sets by their consolidation until no further consolidation between set pairs is possible.
If N<2 then consolidation has no strict meaning and the input can be returned.

Example 1:
Given the two sets {A,B} and {C,D} then there is no common element between the sets and the result is the same as the input.
Example 2:
Given the two sets {A,B} and {B,D} then there is a common element B between the sets and the result is the single set {B,D,A}. (Note that order of items in a set is immaterial: {A,B,D} is the same as {B,D,A} and {D,A,B}, etc).
Example 3:
Given the three sets {A,B} and {C,D} and {D,B} then there is no common element between the sets {A,B} and {C,D} but the sets {A,B} and {D,B} do share a common element that consolidates to produce the result {B,D,A}. On examining this result with the remaining set, {C,D}, they share a common element and so consolidate to the final output of the single set {A,B,C,D}
Example 4:
The consolidation of the five sets:
{H,I,K}, {A,B}, {C,D}, {D,B}, and {F,G,H}
Is the two sets:
{A, C, B, D}, and {G, F, I, H, K}

See also

 Connected component (graph theory)
 Range consolidation

",#Go,Go,"package main
 
import ""fmt""
 
type set map[string]bool
 
var testCase = []set{
    set{""H"": true, ""I"": true, ""K"": true},
    set{""A"": true, ""B"": true},
    set{""C"": true, ""D"": true},
    set{""D"": true, ""B"": true},
    set{""F"": true, ""G"": true, ""H"": true},
}
 
func main() {
    fmt.Println(consolidate(testCase))
}
 
func consolidate(sets []set) []set {
    setlist := []set{}
    for _, s := range sets {
        if s != nil && len(s) > 0 {
            setlist = append(setlist, s)
        }
    }
    for i, s1 := range setlist {
        if len(s1) > 0 {
            for _, s2 := range setlist[i+1:] {
                if s1.disjoint(s2) {
                    continue
                }
                for e := range s1 {
                    s2[e] = true
                    delete(s1, e)
                }
                s1 = s2
            }
        }
    }
    r := []set{}
    for _, s := range setlist {
        if len(s) > 0 {
            r = append(r, s)
        }
    }
    return r
}
 
func (s1 set) disjoint(s2 set) bool {
    for e := range s2 {
        if s1[e] {
            return false
        }
    }
    return true
}",1137,56
18961,http://rosettacode.org/wiki/Send_an_unknown_method_call,Send an unknown method call,"Task

Invoke an object method where the name of the method to be invoked can be generated at run time.



Related tasks

 Respond to an unknown method call.
 Runtime evaluation

",#Go,Go,"package main
 
import (
    ""fmt""
    ""reflect""
)
 
type example struct{}
 
// the method must be exported to be accessed through reflection.
func (example) Foo() int {
    return 42
}
 
func main() {
    // create an object with a method
    var e example
    // get the method by name
    m := reflect.ValueOf(e).MethodByName(""Foo"")
    // call the method with no argments
    r := m.Call(nil)
    // interpret first return value as int
    fmt.Println(r[0].Int()) // => 42
}",477,24
19045,http://rosettacode.org/wiki/Selectively_replace_multiple_instances_of_a_character_within_a_string,Selectively replace multiple instances of a character within a string,"Task
This is admittedly a trivial task but I thought it would be interesting to see how succinctly (or otherwise) different languages can handle it.

Given the string: ""abracadabra"", replace programatically:

 the first 'a' with 'A'
 the second 'a' with 'B'
 the fourth 'a' with 'C'
 the fifth 'a' with 'D'
 the first 'b' with 'E'
 the second 'r' with 'F'


Note that there is no replacement for the third 'a', second 'b' or first 'r'.

The answer should, of course, be : ""AErBcadCbFD"".


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func main() {
    s := ""abracadabra""
    ss := []byte(s)
    var ixs []int
    for ix, c := range s {
        if c == 'a' {
            ixs = append(ixs, ix)
        }
    }
    repl := ""ABaCD""
    for i := 0; i < 5; i++ {
        ss[ixs[i]] = repl[i]
    }
    s = string(ss)
    s = strings.Replace(s, ""b"", ""E"", 1)
    s = strings.Replace(s, ""r"", ""F"", 2)
    s = strings.Replace(s, ""F"", ""r"", 1)
    fmt.Println(s)
}",469,26
19050,http://rosettacode.org/wiki/Set_of_real_numbers,Set of real numbers,"All real numbers form the uncountable set ℝ. Among its subsets, relatively simple are the convex sets, each expressed as a range between two real numbers a and b where a ≤ b. There are actually four cases for the meaning of ""between"", depending on open or closed boundary:

 [a, b]: {x | a ≤ x and x ≤ b }
 (a, b): {x | a < x and x < b }
 [a, b): {x | a ≤ x and x < b }
 (a, b]: {x | a < x and x ≤ b }
Note that if a = b, of the four only [a, a] would be non-empty.

Task

 Devise a way to represent any set of real numbers, for the definition of 'any' in the implementation notes below.
 Provide methods for these common set operations (x is a real number; A and B are sets):
 x ∈ A: determine if x is an element of A
 example: 1 is in [1, 2), while 2, 3, ... are not.
 A ∪ B: union of A and B, i.e. {x | x ∈ A or x ∈ B}
 example: [0, 2) ∪ (1, 3) = [0, 3); [0, 1) ∪ (2, 3] = well, [0, 1) ∪ (2, 3]
 A ∩ B: intersection of A and B, i.e. {x | x ∈ A and x ∈ B}
 example: [0, 2) ∩ (1, 3) = (1, 2); [0, 1) ∩ (2, 3] = empty set
 A - B: difference between A and B, also written as A \ B, i.e. {x | x ∈ A and x ∉ B}
 example: [0, 2) − (1, 3) = [0, 1]
 Test your implementation by checking if numbers 0, 1, and 2 are in any of the following sets:
 (0, 1] ∪ [0, 2)
 [0, 2) ∩ (1, 2]
 [0, 3) − (0, 1)
 [0, 3) − [0, 1]
Implementation notes

 'Any' real set means 'sets that can be expressed as the union of a finite number of convex real sets'. Cantor's set needs not apply.
 Infinities should be handled gracefully; indeterminate numbers (NaN) can be ignored.
 You can use your machine's native real number representation, which is probably IEEE floating point, and assume it's good enough (it usually is).
Optional work

 Create a function to determine if a given set is empty (contains no element).
 Define A = {x | 0 < x < 10 and |sin(π x²)| > 1/2 }, B = {x | 0 < x < 10 and |sin(π x)| > 1/2}, calculate the length of the real axis covered by the set A − B. Note that 
|sin(π x)| > 1/2 is the same as n + 1/6 < x < n + 5/6 for all integers n; your program does not need to derive this by itself.
",#Go,Go,"package main
 
import ""fmt""
 
type Set func(float64) bool
 
func Union(a, b Set) Set      { return func(x float64) bool { return a(x) || b(x) } }
func Inter(a, b Set) Set      { return func(x float64) bool { return a(x) && b(x) } }
func Diff(a, b Set) Set       { return func(x float64) bool { return a(x) && !b(x) } }
func open(a, b float64) Set   { return func(x float64) bool { return a < x && x < b } }
func closed(a, b float64) Set { return func(x float64) bool { return a <= x && x <= b } }
func opCl(a, b float64) Set   { return func(x float64) bool { return a < x && x <= b } }
func clOp(a, b float64) Set   { return func(x float64) bool { return a <= x && x < b } }
 
func main() {
	s := make([]Set, 4)
	s[0] = Union(opCl(0, 1), clOp(0, 2))  // (0,1] ∪ [0,2)
	s[1] = Inter(clOp(0, 2), opCl(1, 2))  // [0,2) ∩ (1,2]
	s[2] = Diff(clOp(0, 3), open(0, 1))   // [0,3) − (0,1)
	s[3] = Diff(clOp(0, 3), closed(0, 1)) // [0,3) − [0,1]
 
	for i := range s {
		for x := float64(0); x < 3; x++ {
			fmt.Printf(""%v ∈ s%d: %t\n"", x, i, s[i](x))
		}
		fmt.Println()
	}
}",1065,28
19156,http://rosettacode.org/wiki/Send_email,Send email,"Task

Write a function to send an email.

The function should have parameters for setting From, To and Cc addresses; the Subject, and the message text, and optionally fields for the server name and login details.

 If appropriate, explain what notifications of problems/success are given.
 Solutions using libraries or functions from the language are preferred, but failing that, external programs can be used with an explanation.
 Note how portable the solution given is between operating systems when multi-OS languages are used.


(Remember to obfuscate any sensitive data used in examples)



",#Go,Go,"package main
 
import (
	""bufio""
	""bytes""
	""errors""
	""flag""
	""fmt""
	""io/ioutil""
	""net/smtp""
	""os""
	""strings""
)
 
type Message struct {
	From    string
	To      []string
	Cc      []string
	Subject string
	Content string
}
 
func (m Message) Bytes() (r []byte) {
	to := strings.Join(m.To, "","")
	cc := strings.Join(m.Cc, "","")
 
	r = append(r, []byte(""From: ""+m.From+""\n"")...)
	r = append(r, []byte(""To: ""+to+""\n"")...)
	r = append(r, []byte(""Cc: ""+cc+""\n"")...)
	r = append(r, []byte(""Subject: ""+m.Subject+""\n\n"")...)
	r = append(r, []byte(m.Content)...)
 
	return
}
 
func (m Message) Send(host string, port int, user, pass string) (err error) {
	err = check(host, user, pass)
	if err != nil {
		return
	}
 
	err = smtp.SendMail(fmt.Sprintf(""%v:%v"", host, port),
		smtp.PlainAuth("""", user, pass, host),
		m.From,
		m.To,
		m.Bytes(),
	)
 
	return
}
 
func check(host, user, pass string) error {
	if host == """" {
		return errors.New(""Bad host"")
	}
	if user == """" {
		return errors.New(""Bad username"")
	}
	if pass == """" {
		return errors.New(""Bad password"")
	}
 
	return nil
}
 
func main() {
	var flags struct {
		host string
		port int
		user string
		pass string
	}
	flag.StringVar(&flags.host, ""host"", """", ""SMTP server to connect to"")
	flag.IntVar(&flags.port, ""port"", 587, ""Port to connect to SMTP server on"")
	flag.StringVar(&flags.user, ""user"", """", ""Username to authenticate with"")
	flag.StringVar(&flags.pass, ""pass"", """", ""Password to authenticate with"")
	flag.Parse()
 
	err := check(flags.host, flags.user, flags.pass)
	if err != nil {
		flag.Usage()
		os.Exit(1)
	}
 
	bufin := bufio.NewReader(os.Stdin)
 
	fmt.Printf(""From: "")
	from, err := bufin.ReadString('\n')
	if err != nil {
		fmt.Printf(""Error: %v\n"", err)
		os.Exit(1)
	}
	from = strings.Trim(from, "" \t\n\r"")
 
	var to []string
	for {
		fmt.Printf(""To (Blank to finish): "")
		tmp, err := bufin.ReadString('\n')
		if err != nil {
			fmt.Printf(""Error: %v\n"", err)
			os.Exit(1)
		}
		tmp = strings.Trim(tmp, "" \t\n\r"")
 
		if tmp == """" {
			break
		}
 
		to = append(to, tmp)
	}
 
	var cc []string
	for {
		fmt.Printf(""Cc (Blank to finish): "")
		tmp, err := bufin.ReadString('\n')
		if err != nil {
			fmt.Printf(""Error: %v\n"", err)
			os.Exit(1)
		}
		tmp = strings.Trim(tmp, "" \t\n\r"")
 
		if tmp == """" {
			break
		}
 
		cc = append(cc, tmp)
	}
 
	fmt.Printf(""Subject: "")
	subject, err := bufin.ReadString('\n')
	if err != nil {
		fmt.Printf(""Error: %v\n"", err)
		os.Exit(1)
	}
	subject = strings.Trim(subject, "" \t\n\r"")
 
	fmt.Printf(""Content (Until EOF):\n"")
	content, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		fmt.Printf(""Error: %v\n"", err)
		os.Exit(1)
	}
	content = bytes.Trim(content, "" \t\n\r"")
 
	m := Message{
		From:    from,
		To:      to,
		Cc:      cc,
		Subject: subject,
		Content: string(content),
	}
 
	fmt.Printf(""\nSending message...\n"")
	err = m.Send(flags.host, flags.port, flags.user, flags.pass)
	if err != nil {
		fmt.Printf(""Error: %v\n"", err)
		os.Exit(1)
	}
 
	fmt.Printf(""Message sent.\n"")
}",2996,161
19318,http://rosettacode.org/wiki/Self_numbers,Self numbers,"A number n is a self number if there is no number g such that g + the sum of g's digits = n. So 18 is not a self number because 9+9=18, 43 is not a self number because 35+5+3=43.


The task is:

 Display the first 50 self numbers;
 I believe that the 100000000th self number is 1022727208. You should either confirm or dispute my conjecture.

224036583-1 is a Mersenne prime, claimed to also be a self number. Extra credit to anyone proving it.


See also
 
OEIS: A003052 - Self numbers or Colombian numbers
Wikipedia: Self numbers",#Go,Go,"package main
 
import (
    ""fmt""
    ""time""
)
 
func sumDigits(n int) int {
    sum := 0
    for n > 0 {
        sum += n % 10
        n /= 10
    }
    return sum
}
 
func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
 
func main() {
    st := time.Now()
    count := 0
    var selfs []int
    i := 1
    pow := 10
    digits := 1
    offset := 9
    lastSelf := 0
    for count < 1e8 {
        isSelf := true
        start := max(i-offset, 0)
        sum := sumDigits(start)
        for j := start; j < i; j++ {
            if j+sum == i {
                isSelf = false
                break
            }
            if (j+1)%10 != 0 {
                sum++
            } else {
                sum = sumDigits(j + 1)
            }
        }
        if isSelf {
            count++
            lastSelf = i
            if count <= 50 {
                selfs = append(selfs, i)
                if count == 50 {
                    fmt.Println(""The first 50 self numbers are:"")
                    fmt.Println(selfs)
                }
            }
        }
        i++
        if i%pow == 0 {
            pow *= 10
            digits++
            offset = digits * 9
        }
    }
    fmt.Println(""\nThe 100 millionth self number is"", lastSelf)
    fmt.Println(""Took"", time.Since(st))
}",1321,68
19441,http://rosettacode.org/wiki/Self-describing_numbers,Self-describing numbers,"Self-describing numbers

You are encouraged to solve this task according to the task description, using any language you may know.
There are several so-called ""self-describing"" or ""self-descriptive"" integers.

An integer is said to be ""self-describing"" if it has the property that, when digit positions are labeled 0 to N-1, the digit in each position is equal to the number of times that that digit appears in the number.

For example,   2020   is a four-digit self describing number:

   position   0   has value   2   and there are two 0s in the number;
   position   1   has value   0   and there are no 1s in the number;
   position   2   has value   2   and there are two 2s;
   position   3   has value   0   and there are zero 3s.


Self-describing numbers < 100.000.000  are:     1210,   2020,   21200,   3211000,   42101000.



Task Description
 Write a function/routine/method/... that will check whether a given positive integer is self-describing.
 As an optional stretch goal - generate and display the set of self-describing numbers.


Related tasks

   Fours is the number of letters in the ...
   Look-and-say sequence
   Number names
   Self-referential sequence
   Spelling of ordinal numbers

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
    ""strings""
)
 
// task 1 requirement
func sdn(n int64) bool {
    if n >= 1e10 {
        return false
    }
    s := strconv.FormatInt(n, 10)
    for d, p := range s {
        if int(p)-'0' != strings.Count(s, strconv.Itoa(d)) {
            return false
        }
    }
    return true
}
 
// task 2 code (takes a while to run)
func main() {
    for n := int64(0); n < 1e10; n++ {
        if sdn(n) {
            fmt.Println(n)
        }
    }
}",496,30
19483,http://rosettacode.org/wiki/Semiprime,Semiprime,"Semiprime numbers are natural numbers that are products of exactly two (possibly equal) prime numbers.


Semiprimes   are also known as:

   semi-primes
   biprimes
   bi-primes
    2-almost    primes
   or simply:    P2  


Example
 
   1679  =  23 × 73  

(This particular number was chosen as the length of the Arecibo message).



Task

Write a function determining whether a given number is semiprime.



See also

 The Wikipedia article:  semiprime.
 The Wikipedia article:  almost prime.
 The OEIS sequence:  A001358: semiprimes  which has a shorter definition: the product of two primes.

",#Go,Go,"package main
 
import ""fmt""
 
func semiprime(n int) bool {
    nf := 0
    for i := 2; i <= n; i++ {
        for n%i == 0 {
            if nf == 2 {
                return false
            }
            nf++
            n /= i
        }
    }
    return nf == 2
}
 
func main() {
    for v := 1675; v <= 1680; v++ {
        fmt.Println(v, ""->"", semiprime(v))
    }
}",367,23
19490,http://rosettacode.org/wiki/Sequence_of_primes_by_trial_division,Sequence of primes by trial division,"Sequence of primes by trial division

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Generate a sequence of primes by means of trial division.



Trial division is an algorithm where a candidate number is tested for being a prime by trying to divide it by other numbers.

You may use primes, or any numbers of your choosing, as long as the result is indeed a sequence of primes.

The sequence may be bounded (i.e. up to some limit), unbounded, starting from the start (i.e. 2) or above some given value.

Organize your function as you wish, in particular, it might resemble a filtering operation, or a sieving operation.

If you want to use a ready-made is_prime function, use one from the Primality by trial division page (i.e., add yours there if it isn't there already).



Related tasks

   count in factors
   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes

",#Go,Go,"package main
 
import ""fmt""
 
func NumsFromBy(from int, by int, ch chan<- int) {
  for i := from; ; i+=by {
    ch <- i
  }
}
 
func Filter(in <-chan int, out chan<- int, prime int) {
  for {
    i := <-in
    if i%prime != 0 {            // here is the trial division
      out <- i
    }
  }
}
 
func Sieve(out chan<- int) { 
  out <- 3
  q := 9
  ps := make(chan int)
  go Sieve(ps)                   // separate primes supply
  p := <-ps         
  nums := make(chan int)
  go NumsFromBy(5,2,nums)        // end of setup
  for i := 0; ; i++ {
    n := <-nums
    if n < q {
    	out <- n                 // n is prime
    } else {
        ch1 := make(chan int)    // n == q == p*p
        go Filter(nums, ch1, p)  // creation of a filter by p, at p*p
        nums = ch1
    	p = <-ps                 // next prime
    	q = p*p                  //   and its square
    }
  }
}
 
func primes (c chan<- int) {
  c <- 2
  go Sieve(c)
}
 
func main() {
  ch := make(chan int)
  go primes(ch)
  fmt.Print(""First twenty:"")
  for i := 0; i < 20; i++ {
    fmt.Print("" "", <-ch)
  }
  fmt.Println()
}",1094,55
19570,http://rosettacode.org/wiki/Semordnilap,Semordnilap,"A semordnilap is a word (or phrase) that spells a different word (or phrase) backward. ""Semordnilap"" is a word that itself is a semordnilap.

Example: lager and regal

Task
This task does not consider semordnilap phrases, only single words.
Using only words from this list, report the total number of unique semordnilap pairs, and print 5 examples.
Two matching semordnilaps, such as lager and regal, should be counted as one unique pair.
(Note that the word ""semordnilap"" is not in the above dictionary.)




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""io/ioutil""
    ""log""
    ""strings""
)
 
func main() {
    // read file into memory as one big block
    data, err := ioutil.ReadFile(""unixdict.txt"")
    if err != nil {
        log.Fatal(err)
    }
    // copy the block, split it up into words
    words := strings.Split(string(data), ""\n"")
    // optional, free the first block for garbage collection
    data = nil
    // put words in a map, also determine length of longest word
    m := make(map[string]bool)
    longest := 0
    for _, w := range words {
        m[string(w)] = true
        if len(w) > longest {
            longest = len(w)
        }
    }
    // allocate a buffer for reversing words
    r := make([]byte, longest)
    // iterate over word list
    sem := 0
    var five []string
    for _, w := range words {
        // first, delete from map.  this prevents a palindrome from matching
        // itself, and also prevents it's reversal from matching later.
        delete(m, w)
        // use buffer to reverse word
        last := len(w) - 1
        for i := 0; i < len(w); i++ {
            r[i] = w[last-i]
        }
        rs := string(r[:len(w)])
        // see if reversed word is in map, accumulate results
        if m[rs] {
            sem++
            if len(five) < 5 {
                five = append(five, w+""/""+rs)
            }
        }
    }
    // print results
    fmt.Println(sem, ""pairs"")
    fmt.Println(""examples:"")
    for _, e := range five {
        fmt.Println(""  "", e)
    }
}",1518,58
19613,http://rosettacode.org/wiki/Sequence_of_non-squares,Sequence of non-squares,"Task

Show that the following remarkable formula gives the sequence of non-square natural numbers:

            n + floor(1/2 + sqrt(n)) 

 Print out the values for    n    in the range   1   to   22
 Show that no squares occur for    n    less than one million


This is sequence   A000037   in the OEIS database.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func remarkable(n int) int {
    return n + int(.5+math.Sqrt(float64(n)))
}
 
func main() {
    // task 1
    fmt.Println(""  n  r(n)"")
    fmt.Println(""---  ---"")
    for n := 1; n <= 22; n++ {
        fmt.Printf(""%3d  %3d\n"", n, remarkable(n))
    }
 
    // task 2
    const limit = 1e6
    fmt.Println(""\nChecking for squares for n <"", limit)
    next := 2
    nextSq := 4
    for n := 1; n < limit; n++ {
        r := remarkable(n)
        switch {
        case r == nextSq:
            panic(n)
        case r > nextSq:
            fmt.Println(nextSq, ""didn't occur"")
            next++
            nextSq = next * next
        }
    }
    fmt.Println(""No squares occur for n <"", limit)
}",742,37
19688,http://rosettacode.org/wiki/Set,Set,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
A   set  is a collection of elements, without duplicates and without order.



Task

Show each of these set operations:

 Set creation
 Test m ∈ S -- ""m is an element in set S""
 A ∪ B -- union; a set of all elements either in set A or in set B.
 A ∩ B -- intersection; a set of all elements in both set A and set B.
 A ∖ B -- difference; a set of all elements in set A, except those in set B.
 A ⊆ B -- subset; true if every element in set A is also in set B.
 A = B -- equality; true if every element of set A is in set B and vice versa.


As an option, show some other set operations.

(If A ⊆ B, but A ≠ B, then A is called a true or proper subset of B, written A ⊂ B or A ⊊ B.)

As another option, show how to modify a mutable set.



One might implement a set using an associative array (with set elements as array keys and some dummy value as the values).

One might also implement a set with a binary search tree, or with a hash table, or with an ordered array of binary bits (operated on with bit-wise binary operators).

The basic test, m ∈ S, is O(n) with a sequential list of elements, O(log n) with a balanced binary search tree, or (O(1) average-case, O(n) worst case) with a hash table.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#Go,Go,"package main
 
import ""fmt""
 
// Define set as a type to hold a set of complex numbers.  A type
// could be defined similarly to hold other types of elements.  A common
// variation is to make a map of interface{} to represent a set of
// mixed types.  Also here the map value is a bool.  By always storing
// true, the code is nicely readable.  A variation to use less memory
// is to make the map value an empty struct.  The relative advantages
// can be debated.
type set map[complex128]bool
 
func main() {
    // task: set creation
    s0 := make(set)             // create empty set
    s1 := set{3: true}          // create set with one element
    s2 := set{3: true, 1: true} // create set with two elements
 
    // option: another way to create a set
    s3 := newSet(3, 1, 4, 1, 5, 9)
 
    // option: output!
    fmt.Println(""s0:"", s0)
    fmt.Println(""s1:"", s1)
    fmt.Println(""s2:"", s2)
    fmt.Println(""s3:"", s3)
 
    // task: element predicate
    fmt.Printf(""%v ∈ s0: %t\n"", 3, s0.hasElement(3))
    fmt.Printf(""%v ∈ s3: %t\n"", 3, s3.hasElement(3))
    fmt.Printf(""%v ∈ s3: %t\n"", 2, s3.hasElement(2))
 
    // task: union
    b := set{4: true, 2: true}
    fmt.Printf(""s3 ∪ %v: %v\n"", b, union(s3, b))
 
    // task: intersection
    fmt.Printf(""s3 ∩ %v: %v\n"", b, intersection(s3, b))
 
    // task: difference
    fmt.Printf(""s3 \\ %v: %v\n"", b, difference(s3, b))
 
    // task: subset predicate
    fmt.Printf(""%v ⊆ s3: %t\n"", b, subset(b, s3))
    fmt.Printf(""%v ⊆ s3: %t\n"", s2, subset(s2, s3))
    fmt.Printf(""%v ⊆ s3: %t\n"", s0, subset(s0, s3))
 
    // task: equality
    s2Same := set{1: true, 3: true}
    fmt.Printf(""%v = s2: %t\n"", s2Same, equal(s2Same, s2))
 
    // option: proper subset
    fmt.Printf(""%v ⊂ s2: %t\n"", s2Same, properSubset(s2Same, s2))
    fmt.Printf(""%v ⊂ s3: %t\n"", s2Same, properSubset(s2Same, s3))
 
    // option: delete.  it's built in.
    delete(s3, 3)
    fmt.Println(""s3, 3 deleted:"", s3)
}
 
func newSet(ms ...complex128) set {
    s := make(set)
    for _, m := range ms {
        s[m] = true
    }
    return s
}
 
func (s set) String() string {
    if len(s) == 0 {
        return ""∅""
    }
    r := ""{""
    for e := range s {
        r = fmt.Sprintf(""%s%v, "", r, e)
    }
    return r[:len(r)-2] + ""}""
}
 
func (s set) hasElement(m complex128) bool {
    return s[m]
}
 
func union(a, b set) set {
    s := make(set)
    for e := range a {
        s[e] = true
    }
    for e := range b {
        s[e] = true
    }
    return s
}
 
func intersection(a, b set) set {
    s := make(set)
    for e := range a {
        if b[e] {
            s[e] = true
        }
    }
    return s
}
 
func difference(a, b set) set {
    s := make(set)
    for e := range a {
        if !b[e] {
            s[e] = true
        }
    }
    return s
}
 
func subset(a, b set) bool {
    for e := range a {
        if !b[e] {
            return false
        }
    }
    return true
}
 
func equal(a, b set) bool {
    return len(a) == len(b) && subset(a, b)
}
 
func properSubset(a, b set) bool {
    return len(a) < len(b) && subset(a, b)
}",3088,131
19764,http://rosettacode.org/wiki/SEDOLs,SEDOLs,"Task

For each number list of 6-digit SEDOLs, calculate and append the checksum digit.



That is, given this input:

710889
B0YBKJ
406566
B0YBLH
228276
B0YBKL
557910
B0YBKR
585284
B0YBKT
B00030

Produce this output:

7108899
B0YBKJ7
4065663
B0YBLH2
2282765
B0YBKL9
5579107
B0YBKR5
5852842
B0YBKT7
B000300

Extra credit

Check each input is correctly formed, especially with respect to valid characters allowed in a SEDOL string.



Related tasks

   Luhn test
   ISIN

",#Go,Go," 
package main
 
import (
    ""fmt""
    ""strings""
    ""strconv""
)
 
const input = `710889
B0YBKJ
406566
B0YBLH
228276
B0YBKL
557910
B0YBKR
585284
B0YBKT
B00030
 
B
B0003
B000300
A00030
E00030
I00030
O00030
U00030
β00030
β0003`
 
var weight = [...]int{1,3,1,7,3,9}
 
func csd(code string) string {
    switch len(code) {
    case 6:
    case 0:
        return ""No data""
    default:
        return ""Invalid length""
    }
    sum := 0
    for i, c := range code {
        n, err := strconv.ParseInt(string(c), 36, 0)
        if err != nil || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {
            return ""Invalid character""
        }
        sum += int(n)*weight[i]
    }
    return strconv.Itoa(9-(sum-1)%10)
}   
 
func main() {
    for _, s := range strings.Split(input, ""\n"") {
        d := csd(s)
        if len(d) > 1 {
            fmt.Printf("":%s: %s\n"", s, d)
        } else {
            fmt.Println(s + d)
        }
    }
}
 ",949,64
20024,http://rosettacode.org/wiki/Sieve_of_Eratosthenes,Sieve of Eratosthenes,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.


The Sieve of Eratosthenes is a simple algorithm that finds the prime numbers up to a given integer.



Task

Implement the   Sieve of Eratosthenes   algorithm, with the only allowed optimization that the outer loop can stop at the square root of the limit, and the inner loop may start at the square of the prime just found.

That means especially that you shouldn't optimize by using pre-computed wheels, i.e. don't assume you need only to cross out odd numbers (wheel based on 2), numbers equal to 1 or 5 modulo 6 (wheel based on 2 and 3), or similar wheels based on low primes.

If there's an easy way to add such a wheel based optimization, implement it as an alternative version.



Note

 It is important that the sieve algorithm be the actual algorithm used to find prime numbers for the task.


Related tasks

   Emirp primes
   count in factors
   prime decomposition
   factors of an integer
   extensible prime generator
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",#Go,Go,"package main
import ""fmt""
 
func main() {
    const limit = 201 // means sieve numbers < 201
 
    // sieve
    c := make([]bool, limit) // c for composite.  false means prime candidate
    c[1] = true              // 1 not considered prime
    p := 2
    for {
        // first allowed optimization:  outer loop only goes to sqrt(limit)
        p2 := p * p
        if p2 >= limit {
            break
        }
        // second allowed optimization:  inner loop starts at sqr(p)
        for i := p2; i < limit; i += p {
            c[i] = true // it's a composite
 
        }
        // scan to get next prime for outer loop
        for {
            p++
            if !c[p] {
                break
            }
        }
    }
 
    // sieve complete.  now print a representation.
    for n := 1; n < limit; n++ {
        if c[n] {
            fmt.Print(""  ."")
        } else {
            fmt.Printf(""%3d"", n)
        }
        if n%20 == 0 {
            fmt.Println("""")
        }
    }
}",993,42
20092,http://rosettacode.org/wiki/Secure_temporary_file,Secure temporary file,"Task

Create a temporary file, securely and exclusively (opening it such that there are no possible race conditions).

It's fine assuming local filesystem semantics (NFS or other networking filesystems can have signficantly more complicated semantics for satisfying the ""no race conditions"" criteria).

The function should automatically resolve name collisions and should only fail in cases where permission is denied, the filesystem is read-only or full, or similar conditions exist (returning an error or raising an exception as appropriate to the language/environment).



",#Go,Go,"package main
 
import (
	""fmt""
	""io/ioutil""
	""log""
	""os""
)
 
func main() {
	f, err := ioutil.TempFile("""", ""foo"")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
 
	// We need to make sure we remove the file
	// once it is no longer needed.
	defer os.Remove(f.Name())
 
	// … use the file via 'f' …
	fmt.Fprintln(f, ""Using temporary file:"", f.Name())
	f.Seek(0, 0)
	d, err := ioutil.ReadAll(f)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf(""Wrote and read: %s\n"", d)
 
        // The defer statements above will close and remove the
        // temporary file here (or on any return of this function).
}",610,32
20137,http://rosettacode.org/wiki/Scope_modifiers,Scope modifiers,"Most programming languages offer support for subroutines.
When execution changes between subroutines, different sets of variables and functions (""scopes"") are available to the program.
Frequently these sets are defined by the placement of the variable and function declarations (""static scoping"" or ""lexical scoping"").
These sets may also be defined by special modifiers to the variable and function declarations.

Show the different scope modifiers available in your language and briefly explain how they change the scope of their variable or function.
If your language has no scope modifiers, note it.
",#Go,Go,"global var1    # used outside of procedures
 
procedure one() # a global procedure (the only kind)
local  var2    # used inside of procedures
static var3    # also used inside of procedures
end",193,6
20168,http://rosettacode.org/wiki/Scope/Function_names_and_labels,Scope/Function names and labels,"Task

Explain or demonstrate the levels of visibility of function names and labels within the language.



See also

 Variables for levels of scope relating to visibility of program variables
 Scope modifiers for general scope modification facilities

",#Go,Go,"package main
 
import (
    ""fmt""
    ""runtime""
 
    ""ex""
)
 
func main() {
    // func nested() { ... not allowed here
 
    // this is okay, variable f declared and assigned a function literal.
    f := func() {
        // this mess prints the name of the function to show that it's an
        // anonymous function defined in package main
        pc, _, _, _ := runtime.Caller(0)
        fmt.Println(runtime.FuncForPC(pc).Name(), ""here!"")
    }
 
    ex.X(f) // function value passed to exported function
 
    // ex.x() non-exported function not visible here
}",565,24
20238,"http://rosettacode.org/wiki/Sailors,_coconuts_and_a_monkey_problem","Sailors, coconuts and a monkey problem","Five sailors are shipwrecked on an island and collect a large pile of coconuts during the day.

That night the first sailor wakes up and decides to take his first share early so tries to divide the pile of coconuts equally into five piles but finds that there is one coconut left over, so he tosses it to a monkey and then hides ""his"" one of the five equally sized piles of coconuts and pushes the other four piles together to form a single visible pile of coconuts again and goes to bed.

To cut a long story short, each of the sailors in turn gets up once during the night and performs the same actions of dividing the coconut pile into five, finding that one coconut is left over and giving that single remainder coconut to the monkey.

In the morning (after the surreptitious and separate action of each of the five sailors during the night), the remaining coconuts are divided into five equal piles for each of the sailors, whereupon it is found that the pile of coconuts divides equally amongst the sailors with no remainder. (Nothing for the monkey in the morning.)



The task

 Calculate the minimum possible size of the initial pile of coconuts collected during the first day.
 Use a method that assumes an answer is possible, and then applies the constraints of the tale to see if it is correct. (I.e. no applying some formula that generates the correct answer without integer divisions and remainders and tests on remainders; but constraint solvers are allowed.)
 Calculate the size of the initial pile of coconuts if six sailors were marooned and went through a similar process (but split into six piles instead of five of course).
 Show your answers here.


Extra credit (optional)

 Give some indication of the number of coconuts each sailor hides during the night.


Note

 Of course the tale is told in a world where the collection of any amount of coconuts in a day and multiple divisions of the pile, etc can occur in time fitting the story line, so as not to affect the mathematics.
 The tale is also told in a version where the monkey also gets a coconut in the morning. This is not that tale!


C.f

 Monkeys and Coconuts - Numberphile (Video) Analytical solution.
 A002021: Pile of coconuts problem The On-Line Encyclopedia of Integer Sequences. (Although some of its references may use the alternate form of the tale).

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    coconuts := 11
outer:
    for ns := 2; ns < 10; ns++ {
        hidden := make([]int, ns)
        coconuts = (coconuts/ns)*ns + 1
        for {
            nc := coconuts
            for s := 1; s <= ns; s++ {
                if nc%ns == 1 {
                    hidden[s-1] = nc / ns
                    nc -= hidden[s-1] + 1
                    if s == ns && nc%ns == 0 {
                        fmt.Println(ns, ""sailors require a minimum of"", coconuts, ""coconuts"")
                        for t := 1; t <= ns; t++ {
                            fmt.Println(""\tSailor"", t, ""hides"", hidden[t-1])
                        }
                        fmt.Println(""\tThe monkey gets"", ns)
                        fmt.Println(""\tFinally, each sailor takes"", nc/ns, ""\b\n"")
                        continue outer
                    }
                } else {
                    break
                }
            }
            coconuts += ns
        }
    }
}",1000,33
20269,http://rosettacode.org/wiki/Same_fringe,Same fringe,"Write a routine that will compare the leaves (""fringe"") of two binary trees to determine whether they are the same list of leaves when visited left-to-right. The structure or balance of the trees does not matter; only the number, order, and value of the leaves is important.

Any solution is allowed here, but many computer scientists will consider it inelegant to collect either fringe in its entirety before starting to collect the other one. In fact, this problem is usually proposed in various forums as a way to show off various forms of concurrency (tree-rotation algorithms have also been used to get around the need to collect one tree first). Thinking of it a slightly different way, an elegant solution is one that can perform the minimum amount of work to falsify the equivalence of the fringes when they differ somewhere in the middle, short-circuiting the unnecessary additional traversals and comparisons.

Any representation of a binary tree is allowed, as long as the nodes are orderable, and only downward links are used (for example, you may not use parent or sibling pointers to avoid recursion).
",#Go,Go,"package main
 
import ""fmt""
 
type node struct {
    int
    left, right *node
}
 
// function returns a channel that yields the leaves of the tree.
// the channel is closed after all leaves are received.
func leaves(t *node) chan int {
    ch := make(chan int)
    // recursive function to walk tree.
    var f func(*node)
    f = func(n *node) {
        if n == nil {
            return
        }
        // leaves are identified by having no children.
        if n.left == nil && n.right == nil {
            ch <- n.int
        } else {
            f(n.left)
            f(n.right)
        }
    }
    // goroutine runs concurrently with others.
    // it walks the tree then closes the channel.
    go func() {
        f(t)
        close(ch)
    }()
    return ch
}
 
func sameFringe(t1, t2 *node) bool {
    f1 := leaves(t1)
    f2 := leaves(t2)
    for l1 := range f1 {
        // both trees must yield a leaf, and the leaves must be equal.
        if l2, ok := <-f2; !ok || l1 != l2 {
            return false
        }
    }
    // there must be nothing left in f2 after consuming all of f1.
    _, ok := <-f2
    return !ok
}
 
func main() {
    // the different shapes of the trees is shown with indention.
    // the leaves are easy to spot by the int: key.
    t1 := &node{3,
        &node{1,
            &node{int: 1},
            &node{int: 2}},
        &node{8,
            &node{int: 5},
            &node{int: 13}}}
    // t2 with negative values for internal nodes that can't possibly match
    // positive values in t1, just to show that only leaves are being compared.
    t2 := &node{-8,
        &node{-3,
            &node{-1,
                &node{int: 1},
                &node{int: 2}},
            &node{int: 5}},
        &node{int: 13}}
    fmt.Println(sameFringe(t1, t2)) // prints true.
}",1818,71
20291,http://rosettacode.org/wiki/Safe_addition,Safe addition,"Implementation of   interval arithmetic   and more generally fuzzy number arithmetic require operations that yield safe upper and lower bounds of the exact result.

For example, for an addition, it is the operations    +↑    and    +↓    defined as:    a +↓ b ≤ a + b ≤ a +↑ b. 

Additionally it is desired that the width of the interval    (a +↑ b) - (a +↓ b)    would be about the machine epsilon after removing the exponent part.

Differently to the standard floating-point arithmetic, safe interval arithmetic is accurate (but still imprecise).

I.E.:   the result of each defined operation contains (though does not identify) the exact mathematical outcome.

Usually a   FPU's   have machine    +,-,*,/    operations accurate within the machine precision.

To illustrate it, let us consider a machine with decimal floating-point arithmetic that has the precision is 3 decimal points.

If the result of the machine addition is    1.23,    then the exact mathematical result is within the interval    ]1.22, 1.24[. 

When the machine rounds towards zero, then the exact result is within    [1.23,1.24[.    This is the basis for an implementation of safe addition.



Task;
Show how    +↓    and    +↑    can be implemented in your language using the standard floating-point type.

Define an interval type based on the standard floating-point one,   and implement an interval-valued addition of two floating-point numbers considering them exact, in short an operation that yields the interval    [a +↓ b, a +↑ b]. 
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
// type requested by task
type interval struct {
    lower, upper float64
}
 
// a constructor
func stepAway(x float64) interval {
    return interval {
        math.Nextafter(x, math.Inf(-1)),
        math.Nextafter(x, math.Inf(1))}
}
 
// function requested by task
func safeAdd(a, b float64) interval {
    return stepAway(a + b)
 
}
 
// example
func main() {
    a, b := 1.2, .03
    fmt.Println(a, b, safeAdd(a, b))
}",472,30
20336,http://rosettacode.org/wiki/Ruth-Aaron_numbers,Ruth-Aaron numbers,"A Ruth–Aaron pair consists of two consecutive integers (e.g., 714 and 715) for which the sums of the prime divisors of each integer are equal. So called because 714 is Babe Ruth's lifetime home run record; Hank Aaron's 715th home run broke this record and 714 and 715 have the same prime divisor sum.



A Ruth–Aaron triple consists of three consecutive integers with the same properties.



There is a second variant of Ruth–Aaron numbers, one which uses prime factors rather than prime divisors. The difference; divisors are unique, factors may be repeated. The 714, 715 pair appears in both, so the name still fits.



It is common to refer to each Ruth–Aaron group by the first number in it.



Task
 Find and show, here on this page, the first 30 Ruth-Aaron numbers (factors).
 Find and show, here on this page, the first 30 Ruth-Aaron numbers (divisors).


Stretch
 Find and show the first Ruth-Aaron triple (factors).
 Find and show the first Ruth-Aaron triple (divisors).


See also
Wikipedia: Ruth–Aaron pair
OEIS:A006145 - Ruth-Aaron numbers (1): sum of prime divisors of n = sum of prime divisors of n+1
OEIS:A039752 - Ruth-Aaron numbers (2): sum of prime divisors of n = sum of prime divisors of n+1 (both taken with multiplicity)",#Go,Go,"package main
 
import (
    ""fmt""
    ""rcu""
)
 
func prune(a []int) []int {
    prev := a[0]
    b := []int{prev}
    for i := 1; i < len(a); i++ {
        if a[i] != prev {
            b = append(b, a[i])
            prev = a[i]
        }
    }
    return b
}
 
func main() {
    var resF, resD, resT, factors1 []int
    factors2 := []int{2}
    factors3 := []int{3}
    var sum1, sum2, sum3 int = 0, 2, 3
    var countF, countD, countT int
    for n := 2; countT < 1 || countD < 30 || countF < 30; n++ {
        factors1 = factors2
        factors2 = factors3
        factors3 = rcu.PrimeFactors(n + 2)
        sum1 = sum2
        sum2 = sum3
        sum3 = rcu.SumInts(factors3)
        if countF < 30 && sum1 == sum2 {
            resF = append(resF, n)
            countF++
        }
        if sum1 == sum2 && sum2 == sum3 {
            resT = append(resT, n)
            countT++
        }
        if countD < 30 {
            factors4 := make([]int, len(factors1))
            copy(factors4, factors1)
            factors5 := make([]int, len(factors2))
            copy(factors5, factors2)
            factors4 = prune(factors4)
            factors5 = prune(factors5)
            if rcu.SumInts(factors4) == rcu.SumInts(factors5) {
                resD = append(resD, n)
                countD++
            }
        }
    }
    fmt.Println(""First 30 Ruth-Aaron numbers (factors):"")
    fmt.Println(resF)
    fmt.Println(""\nFirst 30 Ruth-Aaron numbers (divisors):"")
    fmt.Println(resD)
    fmt.Println(""\nFirst Ruth-Aaron triple (factors):"")
    fmt.Println(resT[0])
 
    resT = resT[:0]
    factors1 = factors1[:0]
    factors2 = factors2[:1]
    factors2[0] = 2
    factors3 = factors3[:1]
    factors3[0] = 3
    countT = 0
    for n := 2; countT < 1; n++ {
        factors1 = factors2
        factors2 = factors3
        factors3 = prune(rcu.PrimeFactors(n + 2))
        sum1 = sum2
        sum2 = sum3
        sum3 = rcu.SumInts(factors3)
        if sum1 == sum2 && sum2 == sum3 {
            resT = append(resT, n)
            countT++
        }
    }
    fmt.Println(""\nFirst Ruth-Aaron triple (divisors):"")
    fmt.Println(resT[0])
}",2153,82
20343,http://rosettacode.org/wiki/Search_a_list_of_records,Search a list of records,"Many programming languages provide convenient ways to look for a known value in a simple list of strings or numbers.

But what if the elements of the list are themselves compound records/objects/data-structures, and the search condition is more complex than a simple equality test?

Task[edit]
Write a function/method/etc. that can find the first element in a given list matching a given condition.

It should be as generic and reusable as possible.

(Of course if your programming language already provides such a feature, you can use that instead of recreating it.)

Then to demonstrate its functionality, create the data structure specified under #Data set, and perform on it the searches specified under #Test cases.

Data set
The data structure to be used contains the names and populations (in millions) of the 10 largest metropolitan areas in Africa, and looks as follows when represented in JSON:

[
  { ""name"": ""Lagos"",                ""population"": 21.0  },
  { ""name"": ""Cairo"",                ""population"": 15.2  },
  { ""name"": ""Kinshasa-Brazzaville"", ""population"": 11.3  },
  { ""name"": ""Greater Johannesburg"", ""population"":  7.55 },
  { ""name"": ""Mogadishu"",            ""population"":  5.85 },
  { ""name"": ""Khartoum-Omdurman"",    ""population"":  4.98 },
  { ""name"": ""Dar Es Salaam"",        ""population"":  4.7  },
  { ""name"": ""Alexandria"",           ""population"":  4.58 },
  { ""name"": ""Abidjan"",              ""population"":  4.4  },
  { ""name"": ""Casablanca"",           ""population"":  3.98 }
]
However, you shouldn't parse it from JSON, but rather represent it natively in your programming language.

 The top-level data structure should be an ordered collection (i.e. a list, array, vector, or similar).
 Each element in this list should be an associative collection that maps from keys to values (i.e. a struct, object, hash map, dictionary, or similar).
 Each of them has two entries: One string value with key ""name"", and one numeric value with key ""population"".
 You may rely on the list being sorted by population count, as long as you explain this to readers.


If any of that is impossible or unreasonable in your programming language, then feel free to deviate, as long as you explain your reasons in a comment above your solution.

Test cases


 Search

 Expected result


 Find the (zero-based) index of the first city in the list whose name is ""Dar Es Salaam""

 6


 Find the name of the first city in this list whose population is less than 5 million

 Khartoum-Omdurman


 Find the population of the first city in this list whose name starts with the letter ""A""

 4.58

Guidance
If your programming language supports higher-order programming, then the most elegant way to implement the requested functionality in a generic and reusable way, might be to write a function (maybe called ""find_index"" or similar), that takes two arguments:

 The list to search through.
 A function/lambda/closure (the so-called ""predicate""), which will be applied in turn to each element in the list, and whose boolean return value defines whether that element matches the search requirement.
If this is not the approach which would be most natural or idiomatic in your language, explain why, and show what is.

Related tasks
 Search a list
",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
type element struct {
    name       string
    population float64
}
 
var list = []element{
    {""Lagos"", 21},
    {""Cairo"", 15.2},
    {""Kinshasa-Brazzaville"", 11.3},
    {""Greater Johannesburg"", 7.55},
    {""Mogadishu"", 5.85},
    {""Khartoum-Omdurman"", 4.98},
    {""Dar Es Salaam"", 4.7},
    {""Alexandria"", 4.58},
    {""Abidjan"", 4.4},
    {""Casablanca"", 3.98},
}
 
func find(cond func(*element) bool) int {
    for i := range list {
        if cond(&list[i]) {
            return i
        }
    }
    return -1
}
 
func main() {
    fmt.Println(find(func(e *element) bool {
        return e.name == ""Dar Es Salaam""
    }))
 
    i := find(func(e *element) bool {
        return e.population < 5
    })
    if i < 0 {
        fmt.Println(""*** not found ***"")
    } else {
        fmt.Println(list[i].name)
    }
 
    i = find(func(e *element) bool {
        return strings.HasPrefix(e.name, ""A"")
    })
    if i < 0 {
        fmt.Println(""*** not found ***"")
    } else {
        fmt.Println(list[i].population)
    }
}",1076,57
20366,http://rosettacode.org/wiki/Safe_primes_and_unsafe_primes,Safe primes and unsafe primes,"Definitions

   A   safe prime   is a prime   p   and where   (p-1)/2   is also prime.
   The corresponding prime  (p-1)/2   is known as a   Sophie Germain   prime.
   An   unsafe prime   is a prime   p   and where   (p-1)/2   isn't   a prime.
   An   unsafe prime   is a prime that   isn't   a   safe   prime.


Task

   Find and display (on one line) the first   35   safe primes.
   Find and display the   count   of the safe primes below   1,000,000.
   Find and display the   count   of the safe primes below 10,000,000.
   Find and display (on one line) the first   40   unsafe primes.
   Find and display the   count   of the unsafe primes below   1,000,000.
   Find and display the   count   of the unsafe primes below 10,000,000.
   (Optional)   display the   counts   and   ""below numbers""   with commas.
Show all output here.



Related Task

   strong and weak primes.


Also see

   The OEIS article:     safe   primes.
   The OEIS article:   unsafe primes.

",#Go,Go,"package main
 
import ""fmt""
 
func sieve(limit uint64) []bool {
    limit++
    // True denotes composite, false denotes prime.
    c := make([]bool, limit) // all false by default
    c[0] = true
    c[1] = true
    // apart from 2 all even numbers are of course composite
    for i := uint64(4); i < limit; i += 2 {
        c[i] = true
    }
    p := uint64(3) // Start from 3.
    for {
        p2 := p * p
        if p2 >= limit {
            break
        }
        for i := p2; i < limit; i += 2 * p {
            c[i] = true
        }
        for {
            p += 2
            if !c[p] {
                break
            }
        }
    }
    return c
}
 
func commatize(n int) string {
    s := fmt.Sprintf(""%d"", n)
    if n < 0 {
        s = s[1:]
    }
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    if n >= 0 {
        return s
    }
    return ""-"" + s
}
 
func main() {
    // sieve up to 10 million
    sieved := sieve(1e7)
    var safe = make([]int, 35)
    count := 0
    for i := 3; count < 35; i += 2 {
        if !sieved[i] && !sieved[(i-1)/2] {
            safe[count] = i
            count++
        }
    }
    fmt.Println(""The first 35 safe primes are:\n"", safe, ""\n"")
 
    count = 0
    for i := 3; i < 1e6; i += 2 {
        if !sieved[i] && !sieved[(i-1)/2] {
            count++
        }
    }
    fmt.Println(""The number of safe primes below 1,000,000 is"", commatize(count), ""\n"")
 
    for i := 1000001; i < 1e7; i += 2 {
        if !sieved[i] && !sieved[(i-1)/2] {
            count++
        }
    }
    fmt.Println(""The number of safe primes below 10,000,000 is"", commatize(count), ""\n"")
 
    unsafe := make([]int, 40)
    unsafe[0] = 2 // since (2 - 1)/2 is not prime
    count = 1
    for i := 3; count < 40; i += 2 {
        if !sieved[i] && sieved[(i-1)/2] {
            unsafe[count] = i
            count++
        }
    }
    fmt.Println(""The first 40 unsafe primes are:\n"", unsafe, ""\n"")
 
    count = 1
    for i := 3; i < 1e6; i += 2 {
        if !sieved[i] && sieved[(i-1)/2] {
            count++
        }
    }
    fmt.Println(""The number of unsafe primes below 1,000,000 is"", commatize(count), ""\n"")
 
    for i := 1000001; i < 1e7; i += 2 {
        if !sieved[i] && sieved[(i-1)/2] {
            count++
        }
    }
    fmt.Println(""The number of unsafe primes below 10,000,000 is"", commatize(count), ""\n"")
}",2416,102
20431,http://rosettacode.org/wiki/Runtime_evaluation,Runtime evaluation,"Task

Demonstrate a language's ability for programs to execute code written in the language provided at runtime.

Show what kind of program fragments are permitted (e.g. expressions vs. statements), and how to get values in and out (e.g. environments, arguments, return values), if applicable what lexical/static environment the program is evaluated in, and what facilities for restricting (e.g. sandboxes, resource limits) or customizing (e.g. debugging facilities) the execution.

You may not invoke a separate evaluator program, or invoke a compiler and then its output, unless the interface of that program, and the syntax and means of executing it, are considered part of your language/library/platform.

For a more constrained task giving a specific program fragment to evaluate, see Eval in environment.



",#Go,Go,"package main
import (
	""fmt""
	""bitbucket.org/binet/go-eval/pkg/eval""
	""go/token""
)
 
func main() {
	w := eval.NewWorld();
	fset := token.NewFileSet();
 
	code, err := w.Compile(fset, ""1 + 2"")
	if err != nil {
		fmt.Println(""Compile error"");
		return
	}
 
	val, err := code.Run();
	if err != nil {
		fmt.Println(""Run time error"");
		return;
	}
	fmt.Println(""Return value:"", val) //prints, well, 3
 
}",399,25
20532,http://rosettacode.org/wiki/Runtime_evaluation/In_an_environment,Runtime evaluation/In an environment,"x
x
x


Do so in a way which:

 does not involve string manipulation of the input source code
 is plausibly extensible to a runtime-chosen set of bindings rather than just x
 does not make x a global variable


or note that these are impossible.



See also

 For more general examples and language-specific details, see Eval.
 Dynamic variable names is a similar task.

",#Go,Go,"package main
 
import (
    ""bitbucket.org/binet/go-eval/pkg/eval""
    ""fmt""
    ""go/parser""
    ""go/token""
)
 
func main() {
    // an expression on x
    squareExpr := ""x*x""
 
    // parse to abstract syntax tree
    fset := token.NewFileSet()
    squareAst, err := parser.ParseExpr(squareExpr)
    if err != nil {
        fmt.Println(err)
        return
    }
    // create an environment or ""world""
    w := eval.NewWorld()
 
    // allocate a variable
    wVar := new(intV)
 
    // bind the variable to the name x
    err = w.DefineVar(""x"", eval.IntType, wVar)
    if err != nil {
        fmt.Println(err)
        return
    }
    // bind the expression AST to the world
    squareCode, err := w.CompileExpr(fset, squareAst)
    if err != nil {
        fmt.Println(err)
        return
    }
    // directly manipulate value of variable within world
    *wVar = 5
    // evaluate
    r0, err := squareCode.Run()
    if err != nil {
        fmt.Println(err)
        return
    }
    // change value
    *wVar--
    // revaluate
    r1, err := squareCode.Run()
    if err != nil {
        fmt.Println(err)
        return
    }
    // print difference
    fmt.Println(r0.(eval.IntValue).Get(nil) - r1.(eval.IntValue).Get(nil))
}
 
// int value implementation.
type intV int64
 
func (v *intV) String() string              { return fmt.Sprint(*v) }
func (v *intV) Get(*eval.Thread) int64      { return int64(*v) }
func (v *intV) Set(_ *eval.Thread, x int64) { *v = intV(x) }
func (v *intV) Assign(t *eval.Thread, o eval.Value) {
    *v = intV(o.(eval.IntValue).Get(t))
}",1571,67
20625,http://rosettacode.org/wiki/RSA_code,RSA code,"Given an RSA key (n,e,d), construct a program to encrypt and decrypt plaintext messages strings.

Background

RSA code is used to encode secret messages. It is named after Ron Rivest, Adi Shamir, and Leonard Adleman who published it at MIT in 1977. The advantage of this type of encryption is that you can distribute the number “



n


{\displaystyle n}

” and “



e


{\displaystyle e}

” (which makes up the Public Key used for encryption) to everyone. The Private Key used for decryption “



d


{\displaystyle d}

” is kept secret, so that only the recipient can read the encrypted plaintext.

The process by which this is done is that a message, for example “Hello World” is encoded as numbers (This could be encoding as ASCII or as a subset of characters 



a
=
01
,
b
=
02
,
.
.
.
,
z
=
26


{\displaystyle a=01,b=02,...,z=26}

). This yields a string of numbers, generally referred to as ""numerical plaintext"", “



P


{\displaystyle P}

”. For example, “Hello World” encoded with a=1,...,z=26 by hundreds would yield 



08051212152315181204


{\displaystyle 08051212152315181204}

.

The plaintext must also be split into blocks so that the numerical plaintext is smaller than 



n


{\displaystyle n}

 otherwise the decryption will fail.

The ciphertext, 



C


{\displaystyle C}

, is then computed by taking each block of 



P


{\displaystyle P}

, and computing

 



C
≡

P

e



mod


n


{\displaystyle C\equiv P^{e}\mod n}


Similarly, to decode, one computes

 



P
≡

C

d



mod


n


{\displaystyle P\equiv C^{d}\mod n}

 
To generate a key, one finds 2 (ideally large) primes 



p


{\displaystyle p}

 and 



q


{\displaystyle q}

. the value “



n


{\displaystyle n}

” is simply: 



n
=
p
×
q


{\displaystyle n=p\times q}

.
One must then choose an “



e


{\displaystyle e}

” such that 



gcd
(
e
,
(
p
−
1
)
×
(
q
−
1
)
)
=
1


{\displaystyle \gcd(e,(p-1)\times (q-1))=1}

. That is to say, 



e


{\displaystyle e}

 and 



(
p
−
1
)
×
(
q
−
1
)


{\displaystyle (p-1)\times (q-1)}

 are relatively prime to each other.

The decryption value 



d


{\displaystyle d}

 is then found by solving

 



d
×
e
≡
1

mod


(
p
−
1
)
×
(
q
−
1
)


{\displaystyle d\times e\equiv 1\mod (p-1)\times (q-1)}


The security of the code is based on the secrecy of the Private Key (decryption exponent) “



d


{\displaystyle d}

” and the difficulty in factoring “



n


{\displaystyle n}

”. Research into RSA facilitated advances in factoring and a number of factoring challenges. Keys of 768 bits have been successfully factored. While factoring of keys of 1024 bits has not been demonstrated, NIST expected them to be factorable by 2010 and now recommends 2048 bit keys going forward (see Asymmetric algorithm key lengths or NIST 800-57 Pt 1 Revised Table 4: Recommended algorithms and minimum key sizes).

Summary of the task requirements:

 Encrypt and Decrypt a short message or two using RSA with a demonstration key. 
 Implement RSA do not call a library.
 Encode and decode the message using any reversible method of your choice (ASCII or a=1,..,z=26 are equally fine). 
 Either support blocking or give an error if the message would require blocking)
 Demonstrate that your solution could support real keys by using a non-trivial key that requires large integer support (built-in or libraries). There is no need to include library code but it must be referenced unless it is built into the language. The following keys will be meet this requirement;however, they are NOT long enough to be considered secure:
 n = 9516311845790656153499716760847001433441357
 e = 65537
 d = 5617843187844953170308463622230283376298685
 Messages can be hard-coded into the program, there is no need for elaborate input coding.
 Demonstrate that your implementation works by showing plaintext, intermediate results, encrypted text, and decrypted text.


 Warning
Rosetta Code is not a place you should rely on for examples of code in critical roles, including security.
Cryptographic routines should be validated before being used.
For a discussion of limitations and please refer to Talk:RSA_code#Difference_from_practical_cryptographical_version.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    var n, e, d, bb, ptn, etn, dtn big.Int
    pt := ""Rosetta Code""
    fmt.Println(""Plain text:            "", pt)
 
    // a key set big enough to hold 16 bytes of plain text in
    // a single block (to simplify the example) and also big enough
    // to demonstrate efficiency of modular exponentiation.
    n.SetString(""9516311845790656153499716760847001433441357"", 10)
    e.SetString(""65537"", 10)
    d.SetString(""5617843187844953170308463622230283376298685"", 10)
 
    // convert plain text to a number
    for _, b := range []byte(pt) {
        ptn.Or(ptn.Lsh(&ptn, 8), bb.SetInt64(int64(b)))
    }
    if ptn.Cmp(&n) >= 0 {
        fmt.Println(""Plain text message too long"")
        return
    }
    fmt.Println(""Plain text as a number:"", &ptn)
 
    // encode a single number
    etn.Exp(&ptn, &e, &n)
    fmt.Println(""Encoded:               "", &etn)
 
    // decode a single number
    dtn.Exp(&etn, &d, &n)
    fmt.Println(""Decoded:               "", &dtn)
 
    // convert number to text
    var db [16]byte
    dx := 16
    bff := big.NewInt(0xff)
    for dtn.BitLen() > 0 {
        dx--
        db[dx] = byte(bb.And(&dtn, bff).Int64())
        dtn.Rsh(&dtn, 8)
    }
    fmt.Println(""Decoded number as text:"", string(db[dx:]))
}",1309,48
20637,http://rosettacode.org/wiki/Rosetta_Code/Rank_languages_by_number_of_users,Rosetta Code/Rank languages by number of users,"Task

Sort most popular programming languages based on the number of users on Rosetta Code.

Show the languages with at least 100 users.



A method to solve the task

Users of a computer programming language   X   are those referenced in the page:

 https://rosettacode.org/wiki/Category:X_User,     or preferably: 
 https://rosettacode.org/mw/index.php?title=Category:X_User&redirect=no to avoid re-directions. 

In order to find the list of such categories,   it's possible to first parse the entries of:

 http://rosettacode.org/mw/index.php?title=Special:Categories&limit=5000. 

Then download and parse each computer language   users   category to find the number of users of that computer language.



Sample output on 18 February 2019:

Language             Users
--------------------------
C                      391
Java                   276
C++                    275
Python                 262
JavaScript             238
Perl                   171
PHP                    167
SQL                    138
UNIX Shell             131
BASIC                  120
C sharp                118
Pascal                 116
Haskell                102
A Rosetta Code user usually declares using a language with the mylang template. This template is expected to appear on the User page. However, in some cases it appears in a user Talk page. It's not necessary to take this into account. For instance, among the 373 C users in the table above, 3 are actually declared in a Talk page.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""io/ioutil""
    ""net/http""
    ""regexp""
    ""sort""
    ""strconv""
)
 
type Result struct {
    lang  string
    users int
}
 
func main() {
    const minimum = 25
    ex := `""Category:(.+?)( User)?""(\}|,""categoryinfo"":\{""size"":(\d+),)`
    re := regexp.MustCompile(ex)
    page := ""http://rosettacode.org/mw/api.php?""
    action := ""action=query""
    format := ""format=json""
    fversion := ""formatversion=2""
    generator := ""generator=categorymembers""
    gcmTitle := ""gcmtitle=Category:Language%20users""
    gcmLimit := ""gcmlimit=500""
    prop := ""prop=categoryinfo""
    rawContinue := ""rawcontinue=""
    page += fmt.Sprintf(""%s&%s&%s&%s&%s&%s&%s&%s"", action, format, fversion,
        generator, gcmTitle, gcmLimit, prop, rawContinue)
    resp, _ := http.Get(page)
    body, _ := ioutil.ReadAll(resp.Body)
    matches := re.FindAllStringSubmatch(string(body), -1)
    resp.Body.Close()
    var results []Result
    for _, match := range matches {
        if len(match) == 5 {
            users, _ := strconv.Atoi(match[4]) 
            if users >= minimum {
                result := Result{match[1], users}
                results = append(results, result)
            }
        }
    }
    sort.Slice(results, func(i, j int) bool {
        return results[j].users < results[i].users
    })
 
    fmt.Println(""Rank  Users  Language"")
    fmt.Println(""----  -----  --------"")
    rank := 0
    lastUsers := 0
    lastRank := 0
    for i, result := range results {
        eq := "" ""
        rank = i + 1
        if lastUsers == result.users {
            eq = ""=""
            rank = lastRank
        } else {
            lastUsers = result.users
            lastRank = rank
        }
        fmt.Printf("" %-2d%s   %3d    %s\n"", rank, eq, result.users, result.lang)
    }
}",1812,67
20733,http://rosettacode.org/wiki/Rosetta_Code/Fix_code_tags,Rosetta Code/Fix code tags,"Task

Fix Rosetta Code deprecated code tags, with these rules:

Change <%s> to <lang %s>
Change </%s> to </lang>
Change <code %s> to <lang %s>
Change </code> to </lang>



Usage

./convert.py < wikisource.txt > converted.txt


",#Go,Go,"package main
 
import ""fmt""
import ""io/ioutil""
import ""log""
import ""os""
import ""regexp""
import ""strings""
 
func main() {
	err := fix()
	if err != nil {
		log.Fatalln(err)
	}
}
 
func fix() (err error) {
	buf, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		return err
	}
	out, err := Lang(string(buf))
	if err != nil {
		return err
	}
	fmt.Println(out)
	return nil
}
 
func Lang(in string) (out string, err error) {
	reg := regexp.MustCompile(""<[^>]+>"")
	out = reg.ReplaceAllStringFunc(in, repl)
	return out, nil
}
 
func repl(in string) (out string) {
	if in == ""</code>"" {
		// Change </code> to </ lang>
		return ""</""+""lang>""
	}
 
	// mid is the content in between '<' and '>'.
	mid := in[1 : len(in)-1]
 
	// thanks, random lua guy
	var langs = []string{
		""abap"", ""actionscript"", ""actionscript3"", ""ada"", ""apache"", ""applescript"",
		""apt_sources"", ""asm"", ""asp"", ""autoit"", ""avisynth"", ""bash"", ""basic4gl"",
		""bf"", ""blitzbasic"", ""bnf"", ""boo"", ""c"", ""caddcl"", ""cadlisp"", ""cfdg"", ""cfm"",
		""cil"", ""c_mac"", ""cobol"", ""cpp"", ""cpp-qt"", ""csharp"", ""css"", ""d"", ""delphi"",
		""diff"", ""_div"", ""dos"", ""dot"", ""eiffel"", ""email"", ""fortran"", ""freebasic"",
		""genero"", ""gettext"", ""glsl"", ""gml"", ""gnuplot"", ""go"", ""groovy"", ""haskell"",
		""hq9plus"", ""html4strict"", ""idl"", ""ini"", ""inno"", ""intercal"", ""io"", ""java"",
		""java5"", ""javascript"", ""kixtart"", ""klonec"", ""klonecpp"", ""latex"", ""lisp"",
		""lolcode"", ""lotusformulas"", ""lotusscript"", ""lscript"", ""lua"", ""m68k"",
		""make"", ""matlab"", ""mirc"", ""modula3"", ""mpasm"", ""mxml"", ""mysql"", ""nsis"",
		""objc"", ""ocaml"", ""ocaml-brief"", ""oobas"", ""oracle11"", ""oracle8"", ""pascal"",
		""per"", ""perl"", ""php"", ""php-brief"", ""pic16"", ""pixelbender"", ""plsql"",
		""povray"", ""powershell"", ""progress"", ""prolog"", ""providex"", ""python"",
		""qbasic"", ""rails"", ""reg"", ""robots"", ""ruby"", ""sas"", ""scala"", ""scheme"",
		""scilab"", ""sdlbasic"", ""smalltalk"", ""smarty"", ""sql"", ""tcl"", ""teraterm"",
		""text"", ""thinbasic"", ""tsql"", ""typoscript"", ""vb"", ""vbnet"", ""verilog"",
		""vhdl"", ""vim"", ""visualfoxpro"", ""visualprolog"", ""whitespace"", ""winbatch"",
		""xml"", ""xorg_conf"", ""xpp"", ""z80"",
	}
	for _, lang := range langs {
		if mid == lang {
			// Change <%s> to <lang %s>
			return fmt.Sprintf(""<lang %s>"", lang)
		}
 
		if strings.HasPrefix(mid, ""/"") {
			if mid[len(""/""):] == lang {
				// Change </%s> to </ lang>
				return ""</""+""lang>""
			}
		}
 
		if strings.HasPrefix(mid, ""code "") {
			if mid[len(""code ""):] == lang {
				// Change <code %s> to <lang %s>
				return fmt.Sprintf(""<lang %s>"", lang)
			}
		}
	}
 
	return in
}",2494,88
20806,http://rosettacode.org/wiki/Search_a_list,Search a list,"Task[edit]
Find the index of a string (needle) in an indexable, ordered collection of strings (haystack).

Raise an exception if the needle is missing.

If there is more than one occurrence then return the smallest index to the needle.

Extra credit
Return the largest index to a needle that has multiple occurrences in the haystack.

See also
 Search a list of records
",#Go,Go,"package main
 
var haystack = []string{""Zig"", ""Zag"", ""Wally"", ""Ronald"", ""Bush"", ""Krusty"",
    ""Charlie"", ""Bush"", ""Bozo"", ""Zag"", ""mouse"", ""hat"", ""cup"", ""deodorant"",
    ""television"", ""soap"", ""methamphetamine"", ""severed cat heads"", ""foo"",
    ""bar"", ""baz"", ""quux"", ""quuux"", ""quuuux"", ""bazola"", ""ztesch"", ""foo"",
    ""bar"", ""thud"", ""grunt"", ""foo"", ""bar"", ""bletch"", ""foo"", ""bar"", ""fum"",
    ""fred"", ""jim"", ""sheila"", ""barney"", ""flarp"", ""zxc"", ""spqr"", "";wombat"",
    ""shme"", ""foo"", ""bar"", ""baz"", ""bongo"", ""spam"", ""eggs"", ""snork"", ""foo"",
    ""bar"", ""zot"", ""blarg"", ""wibble"", ""toto"", ""titi"", ""tata"", ""tutu"", ""pippo"",
    ""pluto"", ""paperino"", ""aap"", ""noot"", ""mies"", ""oogle"", ""foogle"", ""boogle"",
    ""zork"", ""gork"", ""bork"", ""sodium"", ""phosphorous"", ""californium"",
    ""copernicium"", ""gold"", ""thallium"", ""carbon"", ""silver"", ""gold"", ""copper"",
    ""helium"", ""sulfur""}",853,14
20832,http://rosettacode.org/wiki/Runge-Kutta_method,Runge-Kutta method,"Given the example Differential equation:






y
′

(
t
)
=
t
×


y
(
t
)




{\displaystyle y'(t)=t\times {\sqrt {y(t)}}}


With initial condition:






t

0


=
0


{\displaystyle t_{0}=0}

 and 




y

0


=
y
(

t

0


)
=
y
(
0
)
=
1


{\displaystyle y_{0}=y(t_{0})=y(0)=1}


This equation has an exact solution:





y
(
t
)
=



1
16



(

t

2


+
4

)

2




{\displaystyle y(t)={\tfrac {1}{16}}(t^{2}+4)^{2}}




Task
Demonstrate the commonly used explicit   fourth-order Runge–Kutta method   to solve the above differential equation.

 Solve the given differential equation over the range 



t
=
0
…
10


{\displaystyle t=0\ldots 10}

 with a step value of 



δ
t
=
0.1


{\displaystyle \delta t=0.1}

 (101 total points, the first being given)
 Print the calculated values of 



y


{\displaystyle y}

 at whole numbered 



t


{\displaystyle t}

's (



0.0
,
1.0
,
…
10.0


{\displaystyle 0.0,1.0,\ldots 10.0}

) along with error as compared to the exact solution.


Method summary
Starting with a given 




y

n




{\displaystyle y_{n}}

 and 




t

n




{\displaystyle t_{n}}

 calculate:





δ

y

1


=
δ
t
×

y
′

(

t

n


,

y

n


)



{\displaystyle \delta y_{1}=\delta t\times y'(t_{n},y_{n})\quad }






δ

y

2


=
δ
t
×

y
′

(

t

n


+



1
2



δ
t
,

y

n


+



1
2



δ

y

1


)


{\displaystyle \delta y_{2}=\delta t\times y'(t_{n}+{\tfrac {1}{2}}\delta t,y_{n}+{\tfrac {1}{2}}\delta y_{1})}






δ

y

3


=
δ
t
×

y
′

(

t

n


+



1
2



δ
t
,

y

n


+



1
2



δ

y

2


)


{\displaystyle \delta y_{3}=\delta t\times y'(t_{n}+{\tfrac {1}{2}}\delta t,y_{n}+{\tfrac {1}{2}}\delta y_{2})}






δ

y

4


=
δ
t
×

y
′

(

t

n


+
δ
t
,

y

n


+
δ

y

3


)



{\displaystyle \delta y_{4}=\delta t\times y'(t_{n}+\delta t,y_{n}+\delta y_{3})\quad }


then:






y

n
+
1


=

y

n


+



1
6



(
δ

y

1


+
2
δ

y

2


+
2
δ

y

3


+
δ

y

4


)


{\displaystyle y_{n+1}=y_{n}+{\tfrac {1}{6}}(\delta y_{1}+2\delta y_{2}+2\delta y_{3}+\delta y_{4})}







t

n
+
1


=

t

n


+
δ
t



{\displaystyle t_{n+1}=t_{n}+\delta t\quad }



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
type ypFunc func(t, y float64) float64
type ypStepFunc func(t, y, dt float64) float64
 
// newRKStep takes a function representing a differential equation
// and returns a function that performs a single step of the forth-order
// Runge-Kutta method.
func newRK4Step(yp ypFunc) ypStepFunc {
    return func(t, y, dt float64) float64 {
        dy1 := dt * yp(t, y)
        dy2 := dt * yp(t+dt/2, y+dy1/2)
        dy3 := dt * yp(t+dt/2, y+dy2/2)
        dy4 := dt * yp(t+dt, y+dy3)
        return y + (dy1+2*(dy2+dy3)+dy4)/6
    }
}
 
// example differential equation
func yprime(t, y float64) float64 {
    return t * math.Sqrt(y)
}
 
// exact solution of example
func actual(t float64) float64 {
    t = t*t + 4
    return t * t / 16
}
 
func main() {
    t0, tFinal := 0, 10 // task specifies times as integers,
    dtPrint := 1        // and to print at whole numbers.
    y0 := 1.            // initial y.
    dtStep := .1        // step value.
 
    t, y := float64(t0), y0
    ypStep := newRK4Step(yprime)
    for t1 := t0 + dtPrint; t1 <= tFinal; t1 += dtPrint {
        printErr(t, y) // print intermediate result
        for steps := int(float64(dtPrint)/dtStep + .5); steps > 1; steps-- {
            y = ypStep(t, y, dtStep)
            t += dtStep
        }
        y = ypStep(t, y, float64(t1)-t) // adjust step to integer time
        t = float64(t1)
    }
    printErr(t, y) // print final result
}
 
func printErr(t, y float64) {
    fmt.Printf(""y(%.1f) = %f Error: %e\n"", t, y, math.Abs(actual(t)-y))
}",1567,57
20833,http://rosettacode.org/wiki/Rosetta_Code/Find_unimplemented_tasks,Rosetta Code/Find unimplemented tasks,"Task

Given the name of a language on Rosetta Code, find all tasks which are not implemented in that language.



Note: Implementations should allow for fetching more data than can be returned in one request to Rosetta Code.

You'll need to use the Media Wiki API, which you can find out about locally, here, or in Media Wiki's API documentation at, API:Query
",#Go,Go,"package main
 
import (
    ""encoding/xml""
    ""fmt""
    ""io""
    ""net/http""
    ""net/url""
)
 
const language = ""Go""
 
var baseQuery = ""http://rosettacode.org/mw/api.php?action=query"" +
    ""&format=xml&list=categorymembers&cmlimit=100""
 
func req(u string, foundCm func(string)) string {
    resp, err := http.Get(u)
    if err != nil {
        fmt.Println(err) // connection or request fail
        return """"
    }
    defer resp.Body.Close()
    for p := xml.NewDecoder(resp.Body); ; {
        t, err := p.RawToken()
        switch s, ok := t.(xml.StartElement); {
        case err == io.EOF:
            return """"
        case err != nil:
            fmt.Println(err)
            return """"
        case !ok:
            continue
        case s.Name.Local == ""cm"":
            for _, a := range s.Attr {
                if a.Name.Local == ""title"" {
                    foundCm(a.Value)
                }
            }
        case s.Name.Local == ""categorymembers"" && len(s.Attr) > 0 &&
            s.Attr[0].Name.Local == ""cmcontinue"":
            return url.QueryEscape(s.Attr[0].Value)
        }
    }
    return """"
}
 
func main() {
    // get language members, store in a map
    langMap := make(map[string]bool)
    storeLang := func(cm string) { langMap[cm] = true }
    languageQuery := baseQuery + ""&cmtitle=Category:"" + language
    continueAt := req(languageQuery, storeLang)
    for continueAt > """" {
        continueAt = req(languageQuery+""&cmcontinue=""+continueAt, storeLang)
    }
 
    // a quick check to avoid long output
    if len(langMap) == 0 {
        fmt.Println(""no tasks implemented for"", language)
        return
    }
 
    // get tasks, print as we go along
    printUnImp := func(cm string) {
        if !langMap[cm] {
            fmt.Println(cm)
        }
    }
    taskQuery := baseQuery + ""&cmtitle=Category:Programming_Tasks""
    continueAt = req(taskQuery, printUnImp)
    for continueAt > """" {
        continueAt = req(taskQuery+""&cmcontinue=""+continueAt, printUnImp)
    }
}",2014,74
20855,http://rosettacode.org/wiki/S-expressions,S-expressions,"S-Expressions   are one convenient way to parse and store data.



Task

Write a simple reader and writer for S-Expressions that handles quoted and unquoted strings, integers and floats.

The reader should read a single but nested S-Expression from a string and store it in a suitable datastructure (list, array, etc).

Newlines and other whitespace may be ignored unless contained within a quoted string.

“()”   inside quoted strings are not interpreted, but treated as part of the string.

Handling escaped quotes inside a string is optional;   thus “(foo""bar)” maybe treated as a string “foo""bar”, or as an error.

For this, the reader need not recognize “\” for escaping, but should, in addition, recognize numbers if the language has appropriate datatypes.

Languages that support it may treat unquoted strings as symbols.

Note that with the exception of “()""” (“\” if escaping is supported) and whitespace there are no special characters. Anything else is allowed without quotes.

The reader should be able to read the following input

((data ""quoted data"" 123 4.5)
 (data (!@# (4.5) ""(more"" ""data)"")))
and turn it into a native datastructure. (see the Pike, Python and Ruby implementations for examples of native data structures.)

The writer should be able to take the produced list and turn it into a new S-Expression.
Strings that don't contain whitespace or parentheses () don't need to be quoted in the resulting S-Expression, but as a simplification, any string may be quoted.



Extra Credit

Let the writer produce pretty printed output with indenting and line-breaks.



",#Go,Go,"package main
 
import (
    ""errors""
    ""fmt""
    ""reflect""
    ""strconv""
    ""strings""
    ""unicode""
)
 
var input = `((data ""quoted data"" 123 4.5)
 (data (!@# (4.5) ""(more"" ""data)"")))`
 
func main() {
    fmt.Println(""input:"")
    fmt.Println(input)
 
    s, err := parseSexp(input)
    if err != nil {
        fmt.Println(""error:"", err)
        return
    }
 
    fmt.Println(""\nparsed:"")
    fmt.Println(s)
 
    fmt.Println(""\nrepresentation:"")
    s.dump(0)
}
 
// dynamic types for i are string, qString, int, float64, list, and error.
type sexp struct {
    i interface{}
}
type qString string
type list []sexp
 
func (s sexp) String() string {
    return fmt.Sprintf(""%v"", s.i)
}
 
func (q qString) String() string {
    return strconv.Quote(string(q))
}
 
func (l list) String() string {
    if len(l) == 0 {
        return ""()""
    }
    b := fmt.Sprintf(""(%v"", l[0])
    for _, s := range l[1:] {
        b = fmt.Sprintf(""%s %v"", b, s)
    }
    return b + "")""
}
 
// parseSexp parses a string into a Go representation of an s-expression.
//
// Quoted strings go from one "" to the next.  There is no escape character,
// all characters except "" are valid.
//
// Otherwise atoms are any string of characters between any of '(', ')',
// '""', or white space characters.  If the atom parses as a Go int type
// using strconv.Atoi, it is taken as int; if it parses as a Go float64
// type using strconv.ParseFloat, it is taken as float64; otherwise it is
// taken as an unquoted string.
//
// Unmatched (, ), or "" are errors.
// An empty or all whitespace input string is an error.
// Left over text after the sexp is an error.
//
// An empty list is a valid sexp, but there is no nil, no cons, no dot.
func parseSexp(s string) (sexp, error) {
    s1, rem := ps2(s, -1)
    if err, isErr := s1.i.(error); isErr {
        return sexp{}, err
    }
    if rem > """" {
        return s1, errors.New(""Left over text: "" + rem)
    }
    return s1, nil
}
 
// recursive.  n = -1 means not parsing a list.  n >= 0 means the number
// of list elements parsed so far.  string result is unparsed remainder
// of the input string s0.
func ps2(s0 string, n int) (x sexp, rem string) {
    tok, s1 := gettok(s0)
    switch t := tok.(type) {
    case error:
        return sexp{tok}, s1
    case nil: // this is also an error
        if n < 0 {
            return sexp{errors.New(""blank input string"")}, s0
        } else {
            return sexp{errors.New(""unmatched ("")}, """"
        }
    case byte:
        switch {
        case t == '(':
            x, s1 = ps2(s1, 0) // x is a list
            if _, isErr := x.i.(error); isErr {
                return x, s0
            }
        case n < 0:
            return sexp{errors.New(""unmatched )"")}, """"
        default:
            // found end of list.  allocate space for it.
            return sexp{make(list, n)}, s1
        }
    default:
        x = sexp{tok} // x is an atom
    }
    if n < 0 {
        // not in a list, just return the s-expression x
        return x, s1
    }
    // in a list.  hold on to x while we parse the rest of the list.
    l, s1 := ps2(s1, n+1)
    // result l is either an error or the allocated list, not completely
    // filled in yet.
    if _, isErr := l.i.(error); !isErr {
        // as long as no errors, drop x into its place in the list
        l.i.(list)[n] = x
    }
    return l, s1
}
 
// gettok gets one token from string s.
// return values are the token and the remainder of the string.
// dynamic type of tok indicates result:
// nil:  no token.  string was empty or all white space.
// byte:  one of '(' or ')'
// otherwise string, qString, int, float64, or error.
func gettok(s string) (tok interface{}, rem string) {
    s = strings.TrimSpace(s)
    if s == """" {
        return nil, """"
    }
    switch s[0] {
    case '(', ')':
        return s[0], s[1:]
    case '""': 
        if i := strings.Index(s[1:], `""`); i >= 0 {
            return qString(s[1 : i+1]), s[i+2:]
        } 
        return errors.New(`unmatched ""`), s
    }
    i := 1
    for i < len(s) && s[i] != '(' && s[i] != ')' && s[i] != '""' &&
        !unicode.IsSpace(rune(s[i])) {
        i++
    }
    if j, err := strconv.Atoi(s[:i]); err == nil {
        return j, s[i:]
    }
    if f, err := strconv.ParseFloat(s[:i], 64); err == nil {
        return f, s[i:]
    }
    return s[:i], s[i:]
}
 
func (s sexp) dump(i int) {
    fmt.Printf(""%*s%v: "", i*3, """", reflect.TypeOf(s.i))
    if l, isList := s.i.(list); isList {
        fmt.Println(len(l), ""elements"")
        for _, e := range l {
            e.dump(i + 1)
        }
    } else {
        fmt.Println(s.i)
    }
}",4647,174
20860,http://rosettacode.org/wiki/RPG_attributes_generator,RPG attributes generator,"RPG   =   Role Playing Game.



You're running a tabletop RPG, and your players are creating characters.

Each character has six core attributes: strength, dexterity, constitution, intelligence, wisdom, and charisma.

One way of generating values for these attributes is to roll four, 6-sided dice (d6) and sum the three highest rolls, discarding the lowest roll.

Some players like to assign values to their attributes in the order they're rolled.

To ensure generated characters don't put players at a disadvantage, the following requirements must be satisfied:

 The total of all character attributes must be at least 75.
 At least two of the attributes must be at least 15.

However, this can require a lot of manual dice rolling. A programatic solution would be much faster.



Task

Write a program that:

 Generates 4 random, whole values between 1 and 6.
 Saves the sum of the 3 largest values.
 Generates a total of 6 values this way.
 Displays the total, and all 6 values once finished.

 The order in which each value was generated must be preserved.
 The total of all 6 values must be at least 75.
 At least 2 of the values must be 15 or more.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""sort""
    ""time""
)
 
func main() {
    s := rand.NewSource(time.Now().UnixNano())
    r := rand.New(s)
    for {
        var values [6]int
        vsum := 0
        for i := range values {
            var numbers [4]int
            for j := range numbers {
                numbers[j] = 1 + r.Intn(6)
            }
            sort.Ints(numbers[:])
            nsum := 0
            for _, n := range numbers[1:] {
                nsum += n
            }
            values[i] = nsum
            vsum += values[i]
        }
        if vsum < 75 {
            continue
        }
        vcount := 0
        for _, v := range values {
            if v >= 15 {
                vcount++
            }
        }
        if vcount < 2 {
            continue
        }
        fmt.Println(""The 6 random numbers generated are:"")
        fmt.Println(values)
        fmt.Println(""\nTheir sum is"", vsum, ""and"", vcount, ""of them are >= 15"")
        break
    }
}",1004,46
20864,http://rosettacode.org/wiki/Rosetta_Code/Rank_languages_by_popularity,Rosetta Code/Rank languages by popularity,"Rosetta Code/Rank languages by popularity

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Sort the most popular computer programming languages based in number of members in Rosetta Code categories.

Sample output on 01 juin 2022 at 14:13 +02

Rank:  1 (1,540 entries) Phix
Rank:  2 (1,531 entries) Wren
Rank:  3 (1,507 entries) Julia
Rank:  4 (1,494 entries) Go
Rank:  5 (1,488 entries) Raku
Rank:  6 (1,448 entries) Perl
Rank:  7 (1,402 entries) Nim
Rank:  8 (1,382 entries) Python
Rank:  9 (1,204 entries) C
Rank: 10 (1,152 entries) REXX
...


Notes
 
   Each language typically demonstrates one or two methods of accessing the data: 
   with web scraping   (via http://www.rosettacode.org/mw/index.php?title=Special:Categories&limit=5000)
   with the API method   (examples below for Awk, Perl, Ruby, Tcl, etc). 
   The scraping and API solutions can be separate subsections, see the Tcl example.
   Filtering wrong results is optional.   You can check against Special:MostLinkedCategories (if using web scraping)
If you use the API, and do elect to filter, you may check your results against this complete, accurate, sortable, wikitable listing of all 869 programming languages, updated periodically, typically weekly.
   A complete ranked listing of all   813   languages (from the REXX example) is included here   ──►   output from the REXX program.

",#Go,Go,"package main
 
import (
	""encoding/xml""
	""fmt""
	""io""
	""io/ioutil""
	""log""
	""net/http""
	""net/url""
	""regexp""
	""sort""
	""strconv""
	""strings""
)
 
var baseQuery = ""http://rosettacode.org/mw/api.php?action=query"" +
	""&format=xml&list=categorymembers&cmlimit=500""
 
func req(u string, foundCm func(string)) string {
	resp, err := http.Get(u)
	if err != nil {
		log.Fatal(err) // connection or request fail
	}
	defer resp.Body.Close()
	for p := xml.NewDecoder(resp.Body); ; {
		t, err := p.RawToken()
		switch s, ok := t.(xml.StartElement); {
		case err == io.EOF:
			return """"
		case err != nil:
			log.Fatal(err)
		case !ok:
			continue
		case s.Name.Local == ""cm"":
			for _, a := range s.Attr {
				if a.Name.Local == ""title"" {
					foundCm(a.Value)
				}
			}
		case s.Name.Local == ""categorymembers"" && len(s.Attr) > 0 &&
			s.Attr[0].Name.Local == ""cmcontinue"":
			return url.QueryEscape(s.Attr[0].Value)
		}
	}
	return """"
}
 
// satisfy sort interface (reverse sorting)
type pop struct {
	string
	int
}
type popList []pop
 
func (pl popList) Len() int      { return len(pl) }
func (pl popList) Swap(i, j int) { pl[i], pl[j] = pl[j], pl[i] }
func (pl popList) Less(i, j int) bool {
	switch d := pl[i].int - pl[j].int; {
	case d > 0:
		return true
	case d < 0:
		return false
	}
	return pl[i].string < pl[j].string
}
 
func main() {
	// get languages, store in a map
	langMap := make(map[string]bool)
	storeLang := func(cm string) {
		if strings.HasPrefix(cm, ""Category:"") {
			cm = cm[9:]
		}
		langMap[cm] = true
	}
	languageQuery := baseQuery + ""&cmtitle=Category:Programming_Languages""
	continueAt := req(languageQuery, storeLang)
	for continueAt != """" {
		continueAt = req(languageQuery+""&cmcontinue=""+continueAt, storeLang)
	}
	// allocate slice for sorting
	s := make(popList, 0, len(langMap))
 
	// get big list of categories
	resp, err := http.Get(""http://rosettacode.org/mw/index.php"" +
		""?title=Special:Categories&limit=5000"")
	if err != nil {
		log.Fatal(err)
	}
	page, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
 
	// split out fields of interest and populate sortable slice
	rx := regexp.MustCompile(""<li><a.*>(.*)</a>.*[(]([0-9]+) member"")
	for _, sm := range rx.FindAllSubmatch(page, -1) {
		ls := string(sm[1])
		if langMap[ls] {
			if n, err := strconv.Atoi(string(sm[2])); err == nil {
				s = append(s, pop{ls, n})
			}
		}
	}
 
	// output
	sort.Sort(s)
	lastCnt, lastIdx := -1, 1
	for i, lang := range s {
		if lang.int != lastCnt {
			lastCnt = lang.int
			lastIdx = i + 1
		}
		fmt.Printf(""%3d. %3d - %s\n"", lastIdx, lang.int, lang.string)
	}
}",2572,115
20905,http://rosettacode.org/wiki/Rosetta_Code/Find_bare_lang_tags,Rosetta Code/Find bare lang tags,"Task

Find all    <lang>    tags without a language specified in the text of a page.

Display counts by language section:

Description

<lang>Pseudocode</lang>

=={{header|C}}==
<lang C>printf(""Hello world!\n"");</lang>

=={{header|Perl}}==
<lang>print ""Hello world!\n""</lang>

should display something like

2 bare language tags.

1 in perl
1 in no language



Extra credit

Allow multiple files to be read.   Summarize all results by language:

5 bare language tags.

2 in c ([[Foo]], [[Bar]])
1 in perl ([[Foo]])
2 in no language ([[Baz]])



Extra extra credit

Use the   Media Wiki API   to test actual RC tasks.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""io/ioutil""
    ""log""
    ""os""
    ""regexp""
    ""strings""
)
 
type header struct {
    start, end int
    lang       string
}
 
type data struct {
    count int
    names *[]string
}
 
func newData(count int, name string) *data {
    return &data{count, &[]string{name}}
}
 
var bmap = make(map[string]*data)
 
func add2bmap(lang, name string) {
    pd := bmap[lang]
    if pd != nil {
        pd.count++
        *pd.names = append(*pd.names, name)
    } else {
        bmap[lang] = newData(1, name)
    }
}
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func main() {
    expr := `==\s*{{\s*header\s*\|\s*([^\s\}]+)\s*}}\s*==`
    expr2 := fmt.Sprintf(""<%s>.*?</%s>"", ""lang"", ""lang"")  
    r := regexp.MustCompile(expr)
    r2 := regexp.MustCompile(expr2)
    fileNames := []string{""example.txt"", ""example2.txt"", ""example3.txt""}
    for _, fileName := range fileNames {
        f, err := os.Open(fileName)
        check(err)
        b, err := ioutil.ReadAll(f)
        check(err)
        f.Close()
        text := string(b)
        fmt.Printf(""Contents of %s:\n\n%s\n\n"", fileName, text)
        m := r.FindAllStringIndex(text, -1)
        headers := make([]header, len(m))
        if len(m) > 0 {
            for i, p := range m {
                headers[i] = header{p[0], p[1] - 1, """"}
            }
            m2 := r.FindAllStringSubmatch(text, -1)
            for i, s := range m2 {
                headers[i].lang = strings.ToLower(s[1])
            }
        }
        last := len(headers) - 1
        if last == -1 { // if there are no headers in the file add a dummy one
            headers = append(headers, header{-1, -1, ""no language""})
            last = 0
        }
        m3 := r2.FindAllStringIndex(text, -1)
        for _, p := range m3 {
            if p[1] < headers[0].start {
                add2bmap(""no language"", fileName)
            } else if p[0] > headers[last].end {
                add2bmap(headers[last].lang, fileName)
            } else {
                for i := 0; i < last; i++ {
                    if p[0] > headers[i].end && p[0] < headers[i+1].start {
                        add2bmap(headers[i].lang, fileName)
                        break
                    }
                }
            }
        }
    }
    fmt.Println(""Results:\n"")
    count := 0
    for _, v := range bmap {
        count += v.count
    }
    fmt.Printf("" %d bare language tags.\n\n"", count)
    for k, v := range bmap {
        fmt.Printf(""  %d in %-11s %v\n"", v.count, k, *v.names)
    }
}",2582,99
20916,http://rosettacode.org/wiki/Rosetta_Code/Count_examples,Rosetta Code/Count examples,"task
Essentially, count the number of occurrences of =={{header| on each task page.

Output:

100 doors: 20 examples.
99 Bottles of Beer: 29 examples.
Abstract type: 10 examples.

Total: X examples.
For a full output, updated periodically, see Rosetta Code/Count examples/Full list.

You'll need to use the Media Wiki API, which you can find out about locally, here, or in Media Wiki's API documentation at, API:Query
",#Go,Go,"package main
 
import (
    ""bytes""
    ""encoding/xml""
    ""fmt""
    ""io""
    ""io/ioutil""
    ""net/http""
    ""net/url""
    ""strings""
)
 
func req(u string, foundCm func(string)) string {
    resp, err := http.Get(u)
    if err != nil {
        fmt.Println(err) // connection or request fail
        return """"
    }
    defer resp.Body.Close()
    for p := xml.NewDecoder(resp.Body); ; {
        t, err := p.RawToken()
        switch s, ok := t.(xml.StartElement); {
        case err == io.EOF:
            return """"
        case err != nil:
            fmt.Println(err)
            return """"
        case !ok:
            continue
        case s.Name.Local == ""cm"":
            for _, a := range s.Attr {
                if a.Name.Local == ""title"" {
                    foundCm(a.Value)
                }
            }
        case s.Name.Local == ""categorymembers"" && len(s.Attr) > 0 &&
            s.Attr[0].Name.Local == ""cmcontinue"":
            return url.QueryEscape(s.Attr[0].Value)
        }
    }
    return """"
}
 
func main() {
    taskQuery := ""http://rosettacode.org/mw/api.php?action=query"" +
        ""&format=xml&list=categorymembers&cmlimit=500"" +
        ""&cmtitle=Category:Programming_Tasks""
    continueAt := req(taskQuery, count)
    for continueAt > """" {
        continueAt = req(taskQuery+""&cmcontinue=""+continueAt, count)
    }
    fmt.Printf(""Total: %d examples.\n"", total)
}
 
var marker = []byte(""=={{header|"")
var total int
 
func count(cm string) {
    taskFmt := ""http://rosettacode.org/mw/index.php?title=%s&action=raw""
    taskEsc := url.QueryEscape(strings.Replace(cm, "" "", ""_"", -1))
    resp, err := http.Get(fmt.Sprintf(taskFmt, taskEsc))
    var page []byte
    if err == nil {
        page, err = ioutil.ReadAll(resp.Body)
        resp.Body.Close()
    }
    if err != nil {
        fmt.Println(err)
        return
    }
    examples := bytes.Count(page, marker)
    fmt.Printf(""%s: %d\n"", cm, examples)
    total += examples
}",1962,75
21052,http://rosettacode.org/wiki/Roots_of_a_quadratic_function,Roots of a quadratic function,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.
Write a program to find the roots of a quadratic equation, i.e., solve the equation 



a

x

2


+
b
x
+
c
=
0


{\displaystyle ax^{2}+bx+c=0}

.
Your program must correctly handle non-real roots, but it need not check that 



a
≠
0


{\displaystyle a\neq 0}

.

The problem of solving a quadratic equation is a good example of how dangerous it can be to ignore the peculiarities of floating-point arithmetic.
The obvious way to implement the quadratic formula suffers catastrophic loss of accuracy when one of the roots to be found is much closer to 0 than the other.
In their classic textbook on numeric methods Computer Methods for Mathematical Computations, George Forsythe, Michael Malcolm, and Cleve Moler suggest trying the naive algorithm with 



a
=
1


{\displaystyle a=1}

, 



b
=
−

10

5




{\displaystyle b=-10^{5}}

, and 



c
=
1


{\displaystyle c=1}

.
(For double-precision floats, set 



b
=
−

10

9




{\displaystyle b=-10^{9}}

.)
Consider the following implementation in Ada:

with Ada.Text_IO;                        use Ada.Text_IO;
with Ada.Numerics.Elementary_Functions;  use Ada.Numerics.Elementary_Functions;
 
procedure Quadratic_Equation is
   type Roots is array (1..2) of Float;
   function Solve (A, B, C : Float) return Roots is
      SD : constant Float := sqrt (B**2 - 4.0 * A * C);
      AA : constant Float := 2.0 * A;
   begin
      return ((- B + SD) / AA, (- B - SD) / AA);
   end Solve;
 
   R : constant Roots := Solve (1.0, -10.0E5, 1.0);
begin
   Put_Line (""X1 ="" & Float'Image (R (1)) & "" X2 ="" & Float'Image (R (2)));
end Quadratic_Equation;

Output:
X1 = 1.00000E+06 X2 = 0.00000E+00
As we can see, the second root has lost all significant figures. The right answer is that X2 is about 




10

−
6




{\displaystyle 10^{-6}}

. The naive method is numerically unstable.

Suggested by Middlebrook (D-OA), a better numerical method: to define two parameters 



q
=


a
c



/

b


{\displaystyle q={\sqrt {ac}}/b}

 and 



f
=
1

/

2
+


1
−
4

q

2





/

2


{\displaystyle f=1/2+{\sqrt {1-4q^{2}}}/2}



and the two roots of the quardratic are: 






−
b

a


f


{\displaystyle {\frac {-b}{a}}f}

 and 






−
c


b
f





{\displaystyle {\frac {-c}{bf}}}




Task: do it better. This means that given 



a
=
1


{\displaystyle a=1}

, 



b
=
−

10

9




{\displaystyle b=-10^{9}}

, and 



c
=
1


{\displaystyle c=1}

, both of the roots your program returns should be greater than 




10

−
11




{\displaystyle 10^{-11}}

. Or, if your language can't do floating-point arithmetic any more precisely than single precision, your program should be able to handle 



b
=
−

10

6




{\displaystyle b=-10^{6}}

. Either way, show what your program gives as the roots of the quadratic in question. See page 9 of
""What Every Scientist Should Know About Floating-Point Arithmetic"" for a possible algorithm.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func qr(a, b, c float64) ([]float64, []complex128) {
    d := b*b-4*a*c
    switch {
    case d == 0:
        // single root
        return []float64{-b/(2*a)}, nil
    case d > 0:
        // two real roots
        if b < 0 {
            d = math.Sqrt(d)-b
        } else {
            d = -math.Sqrt(d)-b
        }
        return []float64{d/(2*a), (2*c)/d}, nil
    case d < 0:
        // two complex roots
 
        den := 1/(2*a)
        t1 := complex(-b*den, 0)
        t2 := complex(0, math.Sqrt(-d)*den)
        return nil, []complex128{t1+t2, t1-t2}
    }
    // otherwise d overflowed or a coefficient was NAN
    return []float64{d}, nil
}
 
func test(a, b, c float64) {
    fmt.Print(""coefficients: "", a, b, c, "" -> "")
    r, i := qr(a, b, c)
    switch len(r) {
    case 1:
        fmt.Println(""one real root:"", r[0])
    case 2:
        fmt.Println(""two real roots:"", r[0], r[1])
    default:
        fmt.Println(""two complex roots:"", i[0], i[1])
    }
}
 
func main() {
    for _, c := range [][3]float64{
        {1, -2, 1},
        {1, 0, 1},
        {1, -10, 1},
        {1, -1000, 1},
        {1, -1e9, 1},
    } {
        test(c[0], c[1], c[2])
    }
}",1220,57
21068,http://rosettacode.org/wiki/Roots_of_unity,Roots of unity,"The purpose of this task is to explore working with   complex numbers.



Task

Given   n,   find the   nth   roots of unity.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/cmplx""
)
 
func main() {
    for n := 2; n <= 5; n++ {
        fmt.Printf(""%d roots of 1:\n"", n)
        for _, r := range roots(n) {
            fmt.Printf(""  %18.15f\n"", r)
        }
    }
}
 
func roots(n int) []complex128 {
    r := make([]complex128, n)
    for i := 0; i < n; i++ {
        r[i] = cmplx.Rect(1, 2*math.Pi*float64(i)/float64(n))
    }
    return r
}",425,24
21336,http://rosettacode.org/wiki/Roots_of_a_function,Roots of a function,"Task

Create a program that finds and outputs the roots of a given function, range and (if applicable) step width.

The program should identify whether the root is exact or approximate.



For this task, use:      ƒ(x)   =   x3 - 3x2 + 2x 
",#Go,Go,"package main
 
import (
	""fmt""
	""math""
)
 
func main() {
	example := func(x float64) float64 { return x*x*x - 3*x*x + 2*x }
	findroots(example, -.5, 2.6, 1)
}
 
func findroots(f func(float64) float64, lower, upper, step float64) {
	for x0, x1 := lower, lower+step; x0 < upper; x0, x1 = x1, x1+step {
		x1 = math.Min(x1, upper)
		r, status := secant(f, x0, x1)
		if status != """" && r >= x0 && r < x1 {
			fmt.Printf(""  %6.3f %s\n"", r, status)
		}
	}
}
 
func secant(f func(float64) float64, x0, x1 float64) (float64, string) {
	var f0 float64
	f1 := f(x0)
	for i := 0; i < 100; i++ {
		f0, f1 = f1, f(x1)
		switch {
		case f1 == 0:
			return x1, ""exact""
		case math.Abs(x1-x0) < 1e-6:
			return x1, ""approximate""
		}
		x0, x1 = x1, x1-f1*(x1-x0)/(f1-f0)
	}
	return 0, """"
}",771,37
21405,http://rosettacode.org/wiki/Run-length_encoding,Run-length encoding,"Run-length encoding

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Given a string containing uppercase characters (A-Z), compress repeated 'runs' of the same character by storing the length of that run, and provide a function to reverse the compression.

The output can be anything, as long as you can recreate the input with it.



Example

 Input: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW
 Output: 12W1B12W3B24W1B14W


Note: the encoding step in the above example is the same as a step of the Look-and-say sequence.



",#Go,Go,"package main
 
import ""fmt""
 
// encoding scheme:
// encode to byte array
// byte value < 26 means single character: byte value + 'A'
// byte value 26..255 means (byte value - 24) copies of next byte
func rllEncode(s string) (r []byte) {
    if s == """" {
        return
    }
    c := s[0]
    if c < 'A' || c > 'Z' {
        panic(""invalid"")
    }
    nc := byte(1)
    for i := 1; i < len(s); i++ {
        d := s[i]
        switch {
        case d != c:
        case nc < (255 - 24):
            nc++
            continue
        }
        if nc > 1 {
            r = append(r, nc+24)
        }
        r = append(r, c-'A')
        if d < 'A' || d > 'Z' {
            panic(""invalid"")
        }
        c = d
        nc = 1
    }
    if nc > 1 {
        r = append(r, nc+24)
    }
    r = append(r, c-'A')
    return
}
 
func main() {
    s := ""WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW""
    fmt.Println(""source: "", len(s), ""bytes:"", s)
    e := rllEncode(s)
    fmt.Println(""encoded:"", len(e), ""bytes:"", e)
    d := rllDecode(e)
    fmt.Println(""decoded:"", len(d), ""bytes:"", d)
    fmt.Println(""decoded = source:"", d == s)
}
 
func rllDecode(e []byte) string {
    var c byte
    var d []byte
    for i := 0; i < len(e); i++ {
        b := e[i]
        if b < 26 {
            c = 1
        } else {
            c = b - 24
            i++
            b = e[i]
        }
        for c > 0 {
            d = append(d, b+'A')
            c--
        }
    }
    return string(d)
}",1507,71
21437,http://rosettacode.org/wiki/Rock-paper-scissors,Rock-paper-scissors,"Task

Implement the classic children's game Rock-paper-scissors, as well as a simple predictive   AI   (artificial intelligence)   player.

Rock Paper Scissors is a two player game.

Each player chooses one of rock, paper or scissors, without knowing the other player's choice.

The winner is decided by a set of rules:

   Rock beats scissors
   Scissors beat paper
   Paper beats rock


If both players choose the same thing, there is no winner for that round.

For this task, the computer will be one of the players.

The operator will select Rock, Paper or Scissors and the computer will keep a record of the choice frequency, and use that information to make a weighted random choice in an attempt to defeat its opponent.



Extra credit

Support additional choices   additional weapons.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""strings""
    ""time""
)
 
const rps = ""rps""
 
var msg = []string{
    ""Rock breaks scissors"",
    ""Paper covers rock"",
    ""Scissors cut paper"",
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    fmt.Println(""Rock Paper Scissors"")
    fmt.Println(""Enter r, p, or s as your play.  Anything else ends the game."")
    fmt.Println(""Running score shown as <your wins>:<my wins>"")
    var pi string // player input
    var aScore, pScore int
    sl := 3               // for output alignment
    pcf := make([]int, 3) // pcf = player choice frequency
    var plays int
    aChoice := rand.Intn(3) // ai choice for first play is completely random
    for {
        // get player choice
        fmt.Print(""Play: "")
        _, err := fmt.Scanln(&pi)  // lazy
        if err != nil || len(pi) != 1 {
            break
        }
        pChoice := strings.Index(rps, pi)
        if pChoice < 0 {
            break
        }
        pcf[pChoice]++
        plays++
 
        // show result of play
        fmt.Printf(""My play:%s%c.  "", strings.Repeat("" "", sl-2), rps[aChoice])
        switch (aChoice - pChoice + 3) % 3 {
        case 0:
            fmt.Println(""Tie."")
        case 1:
            fmt.Printf(""%s.  My point.\n"", msg[aChoice])
            aScore++
        case 2:
            fmt.Printf(""%s.  Your point.\n"", msg[pChoice])
            pScore++
        }
 
        // show score
        sl, _ = fmt.Printf(""%d:%d  "", pScore, aScore)
 
        // compute ai choice for next play
        switch rn := rand.Intn(plays); {
        case rn < pcf[0]:
            aChoice = 1
        case rn < pcf[0]+pcf[1]:
            aChoice = 2
        default:
            aChoice = 0
        }
    }
}",1747,69
21581,http://rosettacode.org/wiki/Rot-13,Rot-13,"

Task

Implement a   rot-13   function   (or procedure, class, subroutine, or other ""callable"" object as appropriate to your programming environment).

Optionally wrap this function in a utility program   (like tr,   which acts like a common UNIX utility, performing a line-by-line rot-13 encoding of every line of input contained in each file listed on its command line,   or (if no filenames are passed thereon) acting as a filter on its   ""standard input.""



(A number of UNIX scripting languages and utilities, such as   awk   and   sed   either default to processing files in this way or have command line switches or modules to easily implement these wrapper semantics, e.g.,   Perl   and   Python).

The   rot-13   encoding is commonly known from the early days of Usenet ""Netnews"" as a way of obfuscating text to prevent casual reading of   spoiler   or potentially offensive material.

Many news reader and mail user agent programs have built-in rot-13 encoder/decoders or have the ability to feed a message through any external utility script for performing this (or other) actions.

The definition of the rot-13 function is to simply replace every letter of the ASCII alphabet with the letter which is ""rotated"" 13 characters ""around"" the 26 letter alphabet from its normal cardinal position   (wrapping around from   z   to   a   as necessary).

Thus the letters   abc   become   nop   and so on.

Technically rot-13 is a   ""mono-alphabetic substitution cipher""   with a trivial   ""key"".

A proper implementation should work on upper and lower case letters, preserve case, and pass all non-alphabetic characters
in the input stream through without alteration.



Related tasks

   Caesar cipher
   Substitution Cipher
   Vigenère Cipher/Cryptanalysis



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func rot13char(c rune) rune {
    if c >= 'a' && c <= 'm' || c >= 'A' && c <= 'M' {
        return c + 13
    } else if c >= 'n' && c <= 'z' || c >= 'N' && c <= 'Z' {
        return c - 13
    }
    return c
}
 
func rot13(s string) string {
    return strings.Map(rot13char, s)
}
 
func main() {
    fmt.Println(rot13(""nowhere ABJURER""))
}",392,23
21665,http://rosettacode.org/wiki/Roman_numerals/Decode,Roman numerals/Decode,"Task

Create a function that takes a Roman numeral as its argument and returns its value as a numeric decimal integer.

You don't need to validate the form of the Roman numeral.

Modern Roman numerals are written by expressing each decimal digit of the number to be encoded separately,

starting with the leftmost decimal digit and skipping any 0s   (zeroes).

1990 is rendered as   MCMXC     (1000 = M,   900 = CM,   90 = XC)     and

2008 is rendered as   MMVIII       (2000 = MM,   8 = VIII).

The Roman numeral for 1666,   MDCLXVI,   uses each letter in descending order.



",#Go,Go,"package main
 
import (
    ""errors""
    ""fmt""
)
 
var m = map[rune]int{
    'I': 1,
    'V': 5,
    'X': 10,
    'L': 50,
    'C': 100,
    'D': 500,
    'M': 1000,
}
 
func parseRoman(s string) (r int, err error) {
    if s == """" {
        return 0, errors.New(""Empty string"")
    }
    is := []rune(s) // easier to convert string up front
    var c0 rune     // c0: roman character last read
    var cv0 int     // cv0: value of cv
 
    // the key to the algorithm is to process digits from right to left
    for i := len(is) - 1; i >= 0; i-- {
        // read roman digit
        c := is[i]
        k := c == '\u0305' // unicode overbar combining character
        if k {
            if i == 0 {
                return 0, errors.New(
                    ""Overbar combining character invalid at position 0"")
            }
            i--
            c = is[i]
        }
        cv := m[c]
        if cv == 0 {
            if c == 0x0305 {
                return 0, fmt.Errorf(
                    ""Overbar combining character invalid at position %d"", i)
            } else {
                return 0, fmt.Errorf(
                    ""Character unrecognized as Roman digit: %c"", c)
            }
        }
        if k {
            c = -c // convention indicating overbar
            cv *= 1000
        }
 
        // handle cases of new, same, subtractive, changed, in that order.
        switch {
        default: // case 4: digit change
            fallthrough
        case c0 == 0: // case 1: no previous digit
            c0 = c
            cv0 = cv
        case c == c0: // case 2: same digit
        case cv*5 == cv0 || cv*10 == cv0: // case 3: subtractive
            // handle next digit as new.
            // a subtractive digit doesn't count as a previous digit.
            c0 = 0
            r -= cv  // subtract...
            continue // ...instead of adding
        }
        r += cv // add, in all cases except subtractive
    }
    return r, nil
}
 
func main() {
    // parse three numbers mentioned in task description
    for _, r := range []string{""MCMXC"", ""MMVIII"", ""MDCLXVI""} {
        v, err := parseRoman(r)
        if err != nil {
            fmt.Println(err)
        } else {
            fmt.Println(r, ""=="", v)
        }
    }
}",2262,84
21714,http://rosettacode.org/wiki/Roman_numerals/Encode,Roman numerals/Encode,"Task

Create a function taking a positive integer as its parameter and returning a string containing the Roman numeral representation of that integer. Modern Roman numerals are written by expressing each digit separately, starting with the left most digit and skipping any digit with a value of zero.



In Roman numerals:

 1990 is rendered: 1000=M, 900=CM, 90=XC; resulting in MCMXC
 2008 is written as 2000=MM, 8=VIII; or MMVIII
 1666 uses each Roman symbol in descending order: MDCLXVI

",#Go,Go,"package main
 
import ""fmt""
 
var (
    m0 = []string{"""", ""I"", ""II"", ""III"", ""IV"", ""V"", ""VI"", ""VII"", ""VIII"", ""IX""}
    m1 = []string{"""", ""X"", ""XX"", ""XXX"", ""XL"", ""L"", ""LX"", ""LXX"", ""LXXX"", ""XC""}
    m2 = []string{"""", ""C"", ""CC"", ""CCC"", ""CD"", ""D"", ""DC"", ""DCC"", ""DCCC"", ""CM""}
    m3 = []string{"""", ""M"", ""MM"", ""MMM"", ""I̅V̅"",
        ""V̅"", ""V̅I̅"", ""V̅I̅I̅"", ""V̅I̅I̅I̅"", ""I̅X̅""}
    m4 = []string{"""", ""X̅"", ""X̅X̅"", ""X̅X̅X̅"", ""X̅L̅"",
        ""L̅"", ""L̅X̅"", ""L̅X̅X̅"", ""L̅X̅X̅X̅"", ""X̅C̅""}
    m5 = []string{"""", ""C̅"", ""C̅C̅"", ""C̅C̅C̅"", ""C̅D̅"",
        ""D̅"", ""D̅C̅"", ""D̅C̅C̅"", ""D̅C̅C̅C̅"", ""C̅M̅""}
    m6 = []string{"""", ""M̅"", ""M̅M̅"", ""M̅M̅M̅""}
)
 
func formatRoman(n int) (string, bool) {
    if n < 1 || n >= 4e6 {
        return """", false
    }
    // this is efficient in Go.  the seven operands are evaluated,
    // then a single allocation is made of the exact size needed for the result.
    return m6[n/1e6] + m5[n%1e6/1e5] + m4[n%1e5/1e4] + m3[n%1e4/1e3] +
        m2[n%1e3/1e2] + m1[n%100/10] + m0[n%10],
        true
}
 
func main() {
    // show three numbers mentioned in task descriptions
    for _, n := range []int{1990, 2008, 1666} {
        r, ok := formatRoman(n)
        if ok {
            fmt.Println(n, ""=="", r)
        } else {
            fmt.Println(n, ""not representable"")
        }
    }
}",1301,39
21741,http://rosettacode.org/wiki/Rhonda_numbers,Rhonda numbers,"A positive integer n is said to be a Rhonda number to base b if the product of the base b digits of n is equal to b times the sum of n's prime factors.


These numbers were named by Kevin Brown after an acquaintance of his whose residence number was 25662, a member of the base 10 numbers with this property.


25662 is a Rhonda number to base-10. The prime factorization is 2 × 3 × 7 × 13 × 47; the product of its base-10 digits is equal to the base times the sum of its prime factors:

2 × 5 × 6 × 6 × 2 = 720 = 10 × (2 + 3 + 7 + 13 + 47)

Rhonda numbers only exist in bases that are not a prime.

Rhonda numbers to base 10 always contain at least 1 digit 5 and always contain at least 1 even digit.



Task
 For the non-prime bases b from 2 through 16 , find and display here, on this page, at least the first 10 Rhonda numbers to base b. Display the found numbers at least in base 10.


Stretch
 Extend out to base 36.


See also
 Wolfram Mathworld - Rhonda numbers
 Numbers Aplenty - Rhonda numbers
 OEIS:A100968 - Integers n that are Rhonda numbers to base 4
 OEIS:A100969 - Integers n that are Rhonda numbers to base 6
 OEIS:A100970 - Integers n that are Rhonda numbers to base 8
 OEIS:A100973 - Integers n that are Rhonda numbers to base 9
 OEIS:A099542 - Rhonda numbers to base 10
 OEIS:A100971 - Integers n that are Rhonda numbers to base 12
 OEIS:A100972 - Integers n that are Rhonda numbers to base 14
 OEIS:A100974 - Integers n that are Rhonda numbers to base 15
 OEIS:A100975 - Integers n that are Rhonda numbers to base 16
 OEIS:A255735 - Integers n that are Rhonda numbers to base 18
 OEIS:A255732 - Rhonda numbers in vigesimal number system (base 20)
 OEIS:A255736 - Integers that are Rhonda numbers to base 30
 Related Task: Smith numbers



",#Go,Go,"package main
 
import (
    ""fmt""
    ""rcu""
    ""strconv""
)
 
func contains(a []int, n int) bool {
    for _, e := range a {
        if e == n {
            return true
        }
    }
    return false
}
 
func main() {
    for b := 2; b <= 36; b++ {
        if rcu.IsPrime(b) {
            continue
        }
        count := 0
        var rhonda []int
        for n := 1; count < 15; n++ {
            digits := rcu.Digits(n, b)
            if !contains(digits, 0) {
                var anyEven = false
                for _, d := range digits {
                    if d%2 == 0 {
                        anyEven = true
                        break
                    }
                }
                if b != 10 || (contains(digits, 5) && anyEven) {
                    calc1 := 1
                    for _, d := range digits {
                        calc1 *= d
                    }
                    calc2 := b * rcu.SumInts(rcu.PrimeFactors(n))
                    if calc1 == calc2 {
                        rhonda = append(rhonda, n)
                        count++
                    }
                }
            }
        }
        if len(rhonda) > 0 {
            fmt.Printf(""\nFirst 15 Rhonda numbers in base %d:\n"", b)
            rhonda2 := make([]string, len(rhonda))
            counts2 := make([]int, len(rhonda))
            for i, r := range rhonda {
                rhonda2[i] = fmt.Sprintf(""%d"", r)
                counts2[i] = len(rhonda2[i])
            }
            rhonda3 := make([]string, len(rhonda))
            counts3 := make([]int, len(rhonda))
            for i, r := range rhonda {
                rhonda3[i] = strconv.FormatInt(int64(r), b)
                counts3[i] = len(rhonda3[i])
            }
            maxLen2 := rcu.MaxInts(counts2)
            maxLen3 := rcu.MaxInts(counts3)
            maxLen := maxLen2
            if maxLen3 > maxLen {
                maxLen = maxLen3
            }
            maxLen++
            fmt.Printf(""In base 10: %*s\n"", maxLen, rhonda2)
            fmt.Printf(""In base %-2d: %*s\n"", b, maxLen, rhonda3)
        }
    }
}",2110,73
21770,http://rosettacode.org/wiki/Retrieve_and_search_chat_history,Retrieve and search chat history,"Task

Summary: Find and print the mentions of a given string in the recent chat logs from a chatroom. Only use your programming language's standard library.

Details:

The Tcl Chatroom is an online chatroom. Its conversations are logged. It's useful to know if someone has mentioned you or your project in the chatroom recently. You can find this out by searching the chat logs. The logs are publicly available at http://tclers.tk/conferences/tcl/. One log file corresponds to the messages from one day in Germany's current time zone. Each chat log file has the name YYYY-MM-DD.tcl where YYYY is the year, MM is the month and DD the day. The logs store one message per line. The messages themselves are human-readable and their internal structure doesn't matter.

Retrieve the chat logs from the last 10 days via HTTP. Find the lines that include a particular substring and print them in the following format:

<log file URL>
------
<matching line 1>
<matching line 2>
...
<matching line N>
------


The substring will be given to your program as a command line argument.

You need to account for the possible time zone difference between the client running your program and the chat log writer on the server to not miss any mentions. (For example, if you generated the log file URLs naively based on the local date, you could miss mentions if it was already April 5th for the logger but only April 4th for the client.) What this means in practice is that you should either generate the URLs in the time zone Europe/Berlin or, if your language can not do that, add an extra day (today + 1) to the range of dates you check, but then make sure to not print parts of a ""not found"" page by accident if a log file doesn't exist yet.

The code should be contained in a single-file script, with no ""project"" or ""dependency"" file (e.g., no requirements.txt for Python). It should only use a given programming language's standard library to accomplish this task and not rely on the user having installed any third-party packages.

If your language does not have an HTTP client in the standard library, you can speak raw HTTP 1.0 to the server. If it can't parse command line arguments in a standalone script, read the string to look for from the standard input.
",#Go,Go,"package main
 
import (
	""fmt""
	""io/ioutil""
	""log""
	""net/http""
	""os""
	""strings""
	""time""
)
 
func get(url string) (res string, err error) {
	resp, err := http.Get(url)
	if err != nil {
		return """", err
	}
	buf, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return """", err
	}
	return string(buf), nil
}
 
func grep(needle string, haystack string) (res []string) {
	for _, line := range strings.Split(haystack, ""\n"") {
		if strings.Contains(line, needle) {
			res = append(res, line)
		}
	}
	return res
}
 
func genUrl(i int, loc *time.Location) string {
	date := time.Now().In(loc).AddDate(0, 0, i)
	return date.Format(""http://tclers.tk/conferences/tcl/2006-01-02.tcl"")
}
 
func main() {
	needle := os.Args[1]
	back := -10
	serverLoc, err := time.LoadLocation(""Europe/Berlin"")
	if err != nil {
		log.Fatal(err)
	}
	for i := back; i <= 0; i++ {
		url := genUrl(i, serverLoc)
		contents, err := get(url)
		if err != nil {
			log.Fatal(err)
		}
		found := grep(needle, contents)
		if len(found) > 0 {
			fmt.Printf(""%v\n------\n"", url)
			for _, line := range found {
				fmt.Printf(""%v\n"", line)
			}
			fmt.Printf(""------\n\n"")
		}
	}
}",1139,61
21867,http://rosettacode.org/wiki/Repunit_primes,Repunit primes,"Repunit is a portmanteau of the words ""repetition"" and ""unit"", with unit being ""unit value""... or in laymans terms, 1. So 1, 11, 111, 1111 & 11111 are all repunits.

Every standard integer base has repunits since every base has the digit 1. This task involves finding the repunits in different bases that are prime.

In base two, the repunits 11, 111, 11111, 1111111, etc. are prime. (These correspond to the Mersenne primes.)

In base three: 111, 1111111, 1111111111111, etc.

Repunit primes, by definition, are also circular primes.

Any repunit in any base having a composite number of digits is necessarily composite. Only repunits (in any base) having a prime number of digits might be prime.



Rather than expanding the repunit out as a giant list of 1s or converting to base 10, it is common to just list the number of 1s in the repunit; effectively the digit count. The base two repunit primes listed above would be represented as: 2, 3, 5, 7, etc.

Many of these sequences exist on OEIS, though they aren't specifically listed as ""repunit prime digits"" sequences.

Some bases have very few repunit primes. Bases 4, 8, and likely 16 have only one. Base 9 has none at all. Bases above 16 may have repunit primes as well... but this task is getting large enough already.



Task
 For bases 2 through 16, Find and show, here on this page, the repunit primes as digit counts, up to a limit of 1000.


Stretch
 Increase the limit to 2700 (or as high as you have patience for.)


See also
 Wikipedia: Repunit primes
 OEIS:A000043 - Mersenne exponents: primes p such that 2^p - 1 is prime. Then 2^p - 1 is called a Mersenne prime (base 2)
 OEIS:A028491 - Numbers k such that (3^k - 1)/2 is prime (base 3)
 OEIS:A004061 - Numbers n such that (5^n - 1)/4 is prime (base 5)
 OEIS:A004062 - Numbers n such that (6^n - 1)/5 is prime (base 6)
 OEIS:A004063 - Numbers k such that (7^k - 1)/6 is prime (base 7)
 OEIS:A004023 - Indices of prime repunits: numbers n such that 11...111 (with n 1's) = (10^n - 1)/9 is prime (base 10)
 OEIS:A005808 - Numbers k such that (11^k - 1)/10 is prime (base 11)
 OEIS:A004064 - Numbers n such that (12^n - 1)/11 is prime (base 12)
 OEIS:A016054 - Numbers n such that (13^n - 1)/12 is prime (base 13)
 OEIS:A006032 - Numbers k such that (14^k - 1)/13 is prime (base 14)
 OEIS:A006033 - Numbers n such that (15^n - 1)/14 is prime (base 15)
 Related task: Circular primes

",#Go,Go,"package main
 
import (
    ""fmt""
    big ""github.com/ncw/gmp""
    ""rcu""
    ""strings""
)
 
func main() {
    limit := 2700
    primes := rcu.Primes(limit)
    s := new(big.Int)
    for b := 2; b <= 36; b++ {
        var rPrimes []int
        for _, p := range primes {
            s.SetString(strings.Repeat(""1"", p), b)
            if s.ProbablyPrime(15) {
                rPrimes = append(rPrimes, p)
            }
        }
        fmt.Printf(""Base %2d: %v\n"", b, rPrimes)
    }
}",482,24
21876,http://rosettacode.org/wiki/RIPEMD-160,RIPEMD-160,"RIPEMD-160 is another hash function; it computes a 160-bit message digest.

There is a RIPEMD-160 home page, with test vectors and pseudocode for RIPEMD-160.
For padding the message, RIPEMD-160 acts like MD4 (RFC 1320).

Find the RIPEMD-160 message digest of a string of octets.
Use the ASCII encoded string “Rosetta Code”.
You may either call an RIPEMD-160 library, or implement RIPEMD-160 in your language.
",#Go,Go,"package main
 
import (
    ""golang.org/x/crypto/ripemd160""
    ""fmt""
)
 
func main() {
    h := ripemd160.New()
    h.Write([]byte(""Rosetta Code""))
    fmt.Printf(""%x\n"", h.Sum(nil))
}",185,12
21905,http://rosettacode.org/wiki/Respond_to_an_unknown_method_call,Respond to an unknown method call,"Task

Demonstrate how to make the object respond (sensibly/usefully) to an invocation of a method on it that it does not support through its class definitions.

Note that this is not the same as just invoking a defined method whose name is given dynamically; the method named at the point of invocation must not be defined.

This task is intended only for object systems that use a dynamic dispatch mechanism without static checking.



Related task

   Send an unknown method call.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""reflect""
)
 
type example struct{}
 
func (example) Foo() int {
    return 42
}
 
// a method to call another method by name
func (e example) CallMethod(n string) int {
    if m := reflect.ValueOf(e).MethodByName(n); m.IsValid() {
        // it's known.  call it.
        return int(m.Call(nil)[0].Int())
    }
    // otherwise it's unknown.  handle as needed.
    fmt.Println(""Unknown method:"", n)
    return 0
}
 
func main() {
    var e example
    fmt.Println(e.CallMethod(""Foo""))
    fmt.Println(e.CallMethod(""Bar""))
}",562,29
22005,http://rosettacode.org/wiki/Resistor_mesh,Resistor mesh,"
Task

Given    10×10    grid nodes   (as shown in the image)   interconnected by    1Ω    resistors as shown,

find the resistance between points   A   and   B.



See also

   (humor, nerd sniping)   xkcd.com cartoon

",#Go,Go,"package main
 
import ""fmt""
 
const (
	S = 10
)
 
type node struct {
	v     float64
	fixed int
}
 
func alloc2(w, h int) [][]node {
	a := make([][]node, h)
 
	for i := range a {
		a[i] = make([]node, w)
	}
	return a
}
 
func set_boundary(m [][]node) {
	m[1][1].fixed = 1
	m[1][1].v = 1
	m[6][7].fixed = -1
	m[6][7].v = -1
}
 
func calc_diff(m [][]node, d [][]node, w, h int) float64 {
	total := 0.0
	for i := 0; i < h; i++ {
		for j := 0; j < w; j++ {
			v := 0.0
			n := 0
			if i != 0 {
				v += m[i-1][j].v
				n++
			}
			if j != 0 {
				v += m[i][j-1].v
				n++
			}
			if i+1 < h {
				v += m[i+1][j].v
				n++
			}
			if j+1 < w {
				v += m[i][j+1].v
				n++
			}
 
			v = m[i][j].v - v/float64(n)
			d[i][j].v = v
			if m[i][j].fixed == 0 {
				total += v * v
			}
		}
	}
	return total
}
 
func iter(m [][]node, w, h int) float64 {
	d := alloc2(w, h)
	diff := 1.0e10
	cur := []float64{0, 0, 0}
 
	for diff > 1e-24 {
		set_boundary(m)
		diff = calc_diff(m, d, w, h)
		for i := 0; i < h; i++ {
			for j := 0; j < w; j++ {
				m[i][j].v -= d[i][j].v
			}
		}
	}
 
	for i := 0; i < h; i++ {
		for j := 0; j < w; j++ {
			t := 0
			if i != 0 {
				t += 1
			}
			if j != 0 {
				t += 1
			}
			if i < h-1 {
				t += 1
			}
			if j < w-1 {
				t += 1
			}
			cur[m[i][j].fixed+1] += d[i][j].v * float64(t)
		}
	}
	return (cur[2] - cur[0]) / 2
}
 
func main() {
	mesh := alloc2(S, S)
	fmt.Printf(""R = %g\n"", 2/iter(mesh, S, S))
}
 ",1433,103
22156,http://rosettacode.org/wiki/Rendezvous,Rendezvous,"Demonstrate the “rendezvous” communications technique by implementing a printer monitor.
",#Go,Go,"package main
 
import (
    ""errors""
    ""fmt""
    ""strings""
    ""sync""
)
 
var hdText = `Humpty Dumpty sat on a wall.
Humpty Dumpty had a great fall.
All the king's horses and all the king's men,
Couldn't put Humpty together again.`
 
var mgText = `Old Mother Goose,
When she wanted to wander,
Would ride through the air,
On a very fine gander.
Jack's mother came in,
And caught the goose soon,
And mounting its back,
Flew up to the moon.`
 
func main() {
    reservePrinter := startMonitor(newPrinter(5), nil)
    mainPrinter := startMonitor(newPrinter(5), reservePrinter)
    var busy sync.WaitGroup
    busy.Add(2)
    go writer(mainPrinter, ""hd"", hdText, &busy)
    go writer(mainPrinter, ""mg"", mgText, &busy)
    busy.Wait()
}
 
// printer is a type representing an abstraction of a physical printer.
// It is a type defintion for a function that takes a string to print
// and returns an error value, (hopefully usually nil, meaning no error.)
type printer func(string) error
 
// newPrinter is a constructor.  The parameter is a quantity of ink.  It
// returns a printer object encapsulating the ink quantity.
// Note that this is not creating the monitor, only the object serving as
// a physical printer by writing to standard output.
func newPrinter(ink int) printer {
    return func(line string) error {
        if ink == 0 {
            return eOutOfInk
        }
        for _, c := range line {
            fmt.Printf(""%c"", c)
        }
        fmt.Println()
        ink--
        return nil
    }
}
 
var eOutOfInk = errors.New(""out of ink"")
 
// For the language task, rSync is a type used to approximate the Ada
// rendezvous mechanism that includes the caller waiting for completion
// of the callee.  For this use case, we signal completion with an error
// value as a response.  Exceptions are not idiomatic in Go and there is
// no attempt here to model the Ada exception mechanism.  Instead, it is
// idomatic in Go to return error values.  Sending an error value on a
// channel works well here to signal completion.  Go unbuffered channels
// provide synchronous rendezvous, but call and response takes two channels,
// which are bundled together here in a struct.  The channel types are chosen
// to mirror the parameter and return types of ""type printer"" defined above.
// The channel types here, string and error are both ""reference types""
// in Go terminology.  That is, they are small things containing pointers
// to the actual data.  Sending one on a channel does not involve copying,
// or much less marshalling string data.
type rSync struct {
    call     chan string
    response chan error
}
 
// ""rendezvous Print"" requested by use case task.
// For the language task though, it is implemented here as a method on
// rSync that sends its argument on rSync.call and returns the result
// received from rSync.response.  Each channel operation is synchronous.
// The two operations back to back approximate the Ada rendezvous.
func (r *rSync) print(data string) error {
    r.call <- data      // blocks until data is accepted on channel
    return <-r.response // blocks until response is received
}
 
// monitor is run as a goroutine.  It encapsulates the printer passed to it.
// Print requests are received through the rSync object ""entry,"" named entry
// here to correspond to the Ada concept of an entry point.
func monitor(hardPrint printer, entry, reserve *rSync) {
    for {
        // The monitor goroutine will block here waiting for a ""call""
        // to its ""entry point.""
        data := <-entry.call
        // Assuming the call came from a goroutine calling rSync.print,
        // that goroutine is now blocked, waiting for this one to send
        // a response.
 
        // attempt output
        switch err := hardPrint(data); {
 
        // consider return value from attempt
        case err == nil:
            entry.response <- nil // no problems
 
        case err == eOutOfInk && reserve != nil:
            // Requeue to ""entry point"" of reserve printer monitor.
            // Caller stays blocked, and now this goroutine blocks until
            // it gets a response from the reserve printer monitor.
            // It then transparently relays the response to the caller. 
            entry.response <- reserve.print(data)
 
        default:
            entry.response <- err // return failure
        }
        // The response is away.  Loop, and so immediately block again.
    }
}
 
// startMonitor can be seen as an rSync constructor.  It also
// of course, starts the monitor for which the rSync serves as entry point.
// Further to the langauge task, note that the channels created here are
// unbuffered.  There is no buffer or message box to hold channel data.
// A sender will block waiting for a receiver to accept data synchronously.
func startMonitor(p printer, reservePrinter *rSync) *rSync {
    entry := &rSync{make(chan string), make(chan error)}
    go monitor(p, entry, reservePrinter)
    return entry
}
 
// Two writer tasks are started as goroutines by main.  They run concurrently
// and compete for printers as resources.  Note the call to ""rendezvous Print""
// as requested in the use case task and compare the syntax,
//    Here:           printMonitor.print(line);
//    Ada solution:   Main.Print (""string literal"");
func writer(printMonitor *rSync, id, text string, busy *sync.WaitGroup) {
    for _, line := range strings.Split(text, ""\n"") {
        if err := printMonitor.print(line); err != nil {
            fmt.Printf(""**** writer task %q terminated: %v ****\n"", id, err)
            break
        }
    }
    busy.Done()
}",5625,145
22178,http://rosettacode.org/wiki/Reflection/Get_source,Reflection/Get source,"Task

The goal is to get the source code or file path and line number where a programming object (e.g. module, class, function, method) is defined.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""path""
    ""reflect""
    ""runtime""
)
 
func someFunc() {
    fmt.Println(""someFunc called"")
}
 
func main() {
    pc := reflect.ValueOf(someFunc).Pointer()
    f := runtime.FuncForPC(pc)
    name := f.Name()
    file, line := f.FileLine(pc)
    fmt.Println(""Name of function :"", name)
    fmt.Println(""Name of file     :"", path.Base(file))
    fmt.Println(""Line number      :"", line)
}",423,22
22224,http://rosettacode.org/wiki/Reflection/List_properties,Reflection/List properties,"Task

The goal is to get the properties of an object, as names, values or both.

Some languages support dynamic properties, which in general can only be inspected if a class' public API includes a way of listing them.
",#Go,Go,"package main
 
import (
	""fmt""
	""image""
	""reflect""
)
 
// A type definition
type t struct {
	X    int
	next *t
}
 
func main() {
	report(t{})
	report(image.Point{})
}
 
func report(x interface{}) {
	t := reflect.TypeOf(x)
	n := t.NumField()
	fmt.Printf(""Type %v has %d fields:\n"", t, n)
	fmt.Println(""Name     Type     Exported"")
	for i := 0; i < n; i++ {
		f := t.Field(i)
		fmt.Printf(""%-8s %-8v %-8t\n"",
			f.Name,
			f.Type,
			f.PkgPath == """",
		)
	}
	fmt.Println()
}",472,34
22313,http://rosettacode.org/wiki/Reflection/List_methods,Reflection/List methods,"Task

The goal is to get the methods of an object, as names, values or both.

Some languages offer dynamic methods, which in general can only be inspected if a class' public API includes a way of listing them.
",#Go,Go,"package main
 
import (
	""fmt""
	""image""
	""reflect""
)
 
type t int // A type definition
 
// Some methods on the type
func (r t) Twice() t       { return r * 2 }
func (r t) Half() t        { return r / 2 }
func (r t) Less(r2 t) bool { return r < r2 }
func (r t) privateMethod() {}
 
func main() {
	report(t(0))
	report(image.Point{})
}
 
func report(x interface{}) {
	v := reflect.ValueOf(x)
	t := reflect.TypeOf(x) // or v.Type()
	n := t.NumMethod()
	fmt.Printf(""Type %v has %d exported methods:\n"", t, n)
	const format = ""%-6s %-46s %s\n""
	fmt.Printf(format, ""Name"", ""Method expression"", ""Method value"")
	for i := 0; i < n; i++ {
		fmt.Printf(format,
			t.Method(i).Name,
			t.Method(i).Func.Type(),
			v.Method(i).Type(),
		)
	}
	fmt.Println()
}",747,37
22383,http://rosettacode.org/wiki/Record_sound,Record sound,"Record a monophonic 16-bit PCM sound into either memory space, a file or array.

(This task neglects to specify the sample rate, and whether to use signed samples.
The programs in this page might use signed 16-bit or unsigned 16-bit samples, at 8000 Hz, 44100 Hz, or any other sample rate.
Therefore, these programs might not record sound in the same format.)
",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""log""
    ""os""
    ""os/exec""
    ""strconv""
)
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func main() {
    scanner := bufio.NewScanner(os.Stdin)
    name := """"
    for name == """" {
        fmt.Print(""Enter output file name (without extension) : "")
        scanner.Scan()
        name = scanner.Text()
        check(scanner.Err())
    }
    name += "".wav""
 
    rate := 0
    for rate < 2000 || rate > 192000 {
        fmt.Print(""Enter sampling rate in Hz (2000 to 192000) : "")
        scanner.Scan()
        input := scanner.Text()
        check(scanner.Err())
        rate, _ = strconv.Atoi(input)
    }
    rateS := strconv.Itoa(rate)
 
    dur := 0.0
    for dur < 5 || dur > 30 {
        fmt.Print(""Enter duration in seconds (5 to 30)        : "")
        scanner.Scan()
        input := scanner.Text()
        check(scanner.Err())
        dur, _ = strconv.ParseFloat(input, 64)
    }
    durS := strconv.FormatFloat(dur, 'f', -1, 64)
 
    fmt.Println(""OK, start speaking now..."")
    // Default arguments: -c 1, -t wav. Note only signed 16 bit format supported.
    args := []string{""-r"", rateS, ""-f"", ""S16_LE"", ""-d"", durS, name}
    cmd := exec.Command(""arecord"", args...)
    err := cmd.Run()
    check(err)
 
    fmt.Printf(""'%s' created on disk and will now be played back...\n"", name)
    cmd = exec.Command(""aplay"", name)
    err = cmd.Run()
    check(err)
    fmt.Println(""Play-back completed."")
}",1494,61
22393,http://rosettacode.org/wiki/Repeat,Repeat,"Task

Write a procedure which accepts as arguments another procedure and a positive integer.

The latter procedure is executed a number of times equal to the accepted integer.



",#Go,Go,"package main
 
import ""fmt""
 
func repeat(n int, f func()) {
  for i := 0; i < n; i++ {
    f()
  }
}
 
func fn() {
  fmt.Println(""Example"")
}
 
func main() {
  repeat(4, fn)
}",176,17
22485,http://rosettacode.org/wiki/Rename_a_file,Rename a file,"Task

Rename:

   a file called     input.txt     into     output.txt     and 
   a directory called     docs     into     mydocs.


This should be done twice:  
once ""here"", i.e. in the current working directory and once in the filesystem root.

It can be assumed that the user has the rights to do so.

(In unix-type systems, only the user root would have
sufficient permissions in the filesystem root.)



",#Go,Go,"package main
import ""os""
 
func main() {
  os.Rename(""input.txt"", ""output.txt"")
  os.Rename(""docs"", ""mydocs"")
  os.Rename(""/input.txt"", ""/output.txt"")
  os.Rename(""/docs"", ""/mydocs"")
}",184,9
22488,http://rosettacode.org/wiki/Reverse_words_in_a_string,Reverse words in a string,"Task

Reverse the order of all tokens in each of a number of strings and display the result;   the order of characters within a token should not be modified.



Example

Hey you, Bub!    would be shown reversed as:    Bub! you, Hey 



Tokens are any non-space characters separated by spaces (formally, white-space);   the visible punctuation form part of the word within which it is located and should not be modified.

You may assume that there are no significant non-visible characters in the input.   Multiple or superfluous spaces may be compressed into a single space.

Some strings have no tokens, so an empty string   (or one just containing spaces)   would be the result.

Display the strings in order   (1st, 2nd, 3rd, ···),   and one string per line.

(You can consider the ten strings as ten lines, and the tokens as words.)



Input data
             (ten lines within the box)
 line
     ╔════════════════════════════════════════╗
   1 ║  ---------- Ice and Fire ------------  ║
   2 ║                                        ║  ◄─── a blank line here.
   3 ║  fire, in end will world the say Some  ║
   4 ║  ice. in say Some                      ║
   5 ║  desire of tasted I've what From       ║
   6 ║  fire. favor who those with hold I     ║
   7 ║                                        ║  ◄─── a blank line here.
   8 ║  ... elided paragraph last ...         ║
   9 ║                                        ║  ◄─── a blank line here.
  10 ║  Frost Robert -----------------------  ║
     ╚════════════════════════════════════════╝

Cf.
 Phrase reversals

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
// a number of strings
var n = []string{
    ""---------- Ice and Fire ------------"",
    ""                                    "",
    ""fire, in end will world the say Some"",
    ""ice. in say Some                    "",
    ""desire of tasted I've what From     "",
    ""fire. favor who those with hold I   "",
    ""                                    "",
    ""... elided paragraph last ...       "",
    ""                                    "",
    ""Frost Robert -----------------------"",
}
 
func main() {
    for i, s := range n {
        t := strings.Fields(s) // tokenize
        // reverse
        last := len(t) - 1
        for j, k := range t[:len(t)/2] {
            t[j], t[last-j] = t[last-j], k
        }
        n[i] = strings.Join(t, "" "")
    }
    // display result
    for _, t := range n {
        fmt.Println(t)
    }
}",880,36
22579,http://rosettacode.org/wiki/Return_multiple_values,Return multiple values,"Task

Show how to return more than one value from a function.



",#Go,Go,"func addsub(x, y int) (int, int) {
  return x + y, x - y
}",58,3
22622,http://rosettacode.org/wiki/Regular_expressions,Regular expressions,"

Task

   match a string against a regular expression
   substitute part of a string using a regular expression

",#Go,Go,"package main
import ""fmt""
import ""regexp""
 
func main() {
  str := ""I am the original string""
 
  // Test
  matched, _ := regexp.MatchString("".*string$"", str)
  if matched { fmt.Println(""ends with 'string'"") }
 
  // Substitute
  pattern := regexp.MustCompile(""original"")
  result := pattern.ReplaceAllString(str, ""modified"")
  fmt.Println(result)
}",349,16
22685,http://rosettacode.org/wiki/Rep-string,Rep-string,"Given a series of ones and zeroes in a string, define a repeated string or rep-string as a string which is created by repeating a substring of the first N characters of the string truncated on the right to the length of the input string, and in which the substring appears repeated at least twice in the original.

For example, the string 10011001100 is a rep-string as the leftmost four characters of 1001 are repeated three times and truncated on the right to give the original string.

Note that the requirement for having the repeat occur two or more times means that the repeating unit is never longer than half the length of the input string.



Task

 Write a function/subroutine/method/... that takes a string and returns an indication of if it is a rep-string and the repeated string.   (Either the string that is repeated, or the number of repeated characters would suffice). 
 There may be multiple sub-strings that make a string a rep-string - in that case an indication of all, or the longest, or the shortest would suffice.
 Use the function to indicate the repeating substring if any, in the following:

1001110011
1110111011
0010010010
1010101010
1111111111
0100101101
0100100
101
11
00
1


 Show your output on this page.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func rep(s string) int {
    for x := len(s) / 2; x > 0; x-- {
        if strings.HasPrefix(s, s[x:]) {
            return x
        }
    }
    return 0
}
 
const m = `
1001110011
1110111011
0010010010
1010101010
1111111111
0100101101
0100100
101
11
00
1`
 
func main() {
    for _, s := range strings.Fields(m) {
        if n := rep(s); n > 0 {
            fmt.Printf(""%q  %d rep-string %q\n"", s, n, s[:n])
        } else {
            fmt.Printf(""%q  not a rep-string\n"", s)
        }
    }
}",547,38
22749,http://rosettacode.org/wiki/Recaman%27s_sequence,Recaman's sequence,"The Recamán's sequence generates Natural numbers.

Starting from a(0)=0, the n'th term a(n), where n>0, is the previous term minus n i.e a(n) = a(n-1) - n but only if this is both positive and has not been previousely generated.


If the conditions don't hold then a(n) = a(n-1) + n.



Task

 Generate and show here the first 15 members of the sequence.
 Find and show here, the first duplicated number in the sequence.
 Optionally: Find and show here, how many terms of the sequence are needed until all the integers 0..1000, inclusive, are generated.


References

 A005132, The On-Line Encyclopedia of Integer Sequences.
 The Slightly Spooky Recamán Sequence, Numberphile video.
 Recamán's sequence, on Wikipedia.

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    a := []int{0}
    used := make(map[int]bool, 1001)
    used[0] = true
    used1000 := make(map[int]bool, 1001)
    used1000[0] = true
    for n, foundDup := 1, false; n <= 15 || !foundDup || len(used1000) < 1001; n++ {
        next := a[n-1] - n
        if next < 1 || used[next] {
            next += 2 * n
        }
        alreadyUsed := used[next]
        a = append(a, next)
 
        if !alreadyUsed {
            used[next] = true
            if next >= 0 && next <= 1000 {
                used1000[next] = true
            }
        }
 
        if n == 14 {
            fmt.Println(""The first 15 terms of the Recaman's sequence are:"", a)
        }
 
        if !foundDup && alreadyUsed {
            fmt.Printf(""The first duplicated term is a[%d] = %d\n"", n, next)
            foundDup = true
        }
 
        if len(used1000) == 1001 {
            fmt.Printf(""Terms up to a[%d] are needed to generate 0 to 1000\n"", n)
        }
    }
}",995,39
22802,http://rosettacode.org/wiki/Remove_lines_from_a_file,Remove lines from a file,"Task

Remove a specific line or a number of lines from a file.

This should be implemented as a routine that takes three parameters (filename, starting line, and the number of lines to be removed).

For the purpose of this task, line numbers and the number of lines start at one, so to remove the first two lines from the file foobar.txt, the parameters should be: foobar.txt, 1, 2

Empty lines are considered and should still be counted, and if the specified line is empty, it should still be removed.

An appropriate message should appear if an attempt is made to remove lines beyond the end of the file.



",#Go,Go,"package main
 
import (
    ""bytes""
    ""errors""
    ""fmt""
    ""io/ioutil""
    ""os""
)
 
func main() {
    if err := removeLines(""foobar.txt"", 1, 2); err != nil {
        fmt.Println(err)
    }
}
 
func removeLines(fn string, start, n int) (err error) {
    if start < 1 {
        return errors.New(""invalid request.  line numbers start at 1."")
    }
    if n < 0 {
        return errors.New(""invalid request.  negative number to remove."")
    }
    var f *os.File
    if f, err = os.OpenFile(fn, os.O_RDWR, 0); err != nil {
        return
    }
    defer func() {
        if cErr := f.Close(); err == nil {
            err = cErr
        }
    }()
    var b []byte
    if b, err = ioutil.ReadAll(f); err != nil {
        return
    }
    cut, ok := skip(b, start-1)
    if !ok {
        return fmt.Errorf(""less than %d lines"", start)
    }
    if n == 0 {
        return nil
    }
    tail, ok := skip(cut, n)
    if !ok {
        return fmt.Errorf(""less than %d lines after line %d"", n, start)
    }
    t := int64(len(b) - len(cut))
    if err = f.Truncate(t); err != nil {
        return
    }
    if len(tail) > 0 {
        _, err = f.WriteAt(tail, t)
    }
    return
}
 
func skip(b []byte, n int) ([]byte, bool) {
    for ; n > 0; n-- {
        if len(b) == 0 {
            return nil, false
        }
        x := bytes.IndexByte(b, '\n')
        if x < 0 {
            x = len(b)
        } else {
            x++
        }
        b = b[x:]
    }
    return b, true
}",1476,72
22960,http://rosettacode.org/wiki/Reduced_row_echelon_form,Reduced row echelon form,"Reduced row echelon form

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Show how to compute the reduced row echelon form
(a.k.a. row canonical form) of a matrix.

The matrix can be stored in any datatype that is convenient
(for most languages, this will probably be a two-dimensional array).

Built-in functions or this pseudocode (from Wikipedia) may be used:

function ToReducedRowEchelonForm(Matrix M) is
    lead := 0
    rowCount := the number of rows in M
    columnCount := the number of columns in M
    for 0 ≤ r < rowCount do
        if columnCount ≤ lead then
            stop
        end if
        i = r
        while M[i, lead] = 0 do
            i = i + 1
            if rowCount = i then
                i = r
                lead = lead + 1
                if columnCount = lead then
                    stop
                end if
            end if
        end while
        Swap rows i and r
        If M[r, lead] is not 0 divide row r by M[r, lead]
        for 0 ≤ i < rowCount do
            if i ≠ r do
                Subtract M[i, lead] multiplied by row r from row i
            end if
        end for
        lead = lead + 1
    end for
end function

For testing purposes, the RREF of this matrix:

 1    2   -1   -4
 2    3   -1   -11
-2    0   -3    22

is:

 1    0    0   -8
 0    1    0    1
 0    0    1   -2


",#Go,Go,"package main
 
import ""fmt""
 
type matrix [][]float64
 
func (m matrix) print() {
    for _, r := range m {
        fmt.Println(r)
    }
    fmt.Println("""")
}
 
func main() {
    m := matrix{
        { 1, 2, -1,  -4},
        { 2, 3, -1, -11},
        {-2, 0, -3,  22},
    }
    m.print()
    rref(m)
    m.print()
}
 
func rref(m matrix) {
    lead := 0
    rowCount := len(m)
    columnCount := len(m[0])
    for r := 0; r < rowCount; r++ {
        if lead >= columnCount {
            return
        }
        i := r
        for m[i][lead] == 0 {
            i++
            if rowCount == i {
                i = r
                lead++
                if columnCount == lead {
                    return
                }
            }
        }
        m[i], m[r] = m[r], m[i]
        f := 1 / m[r][lead]
        for j, _ := range m[r] {
            m[r][j] *= f
        }
        for i = 0; i < rowCount; i++ {
            if i != r {
                f = m[i][lead]
                for j, e := range m[r] {
                    m[i][j] -= e * f
                }
            }
        }
        lead++
    }
}",1117,59
23064,http://rosettacode.org/wiki/Read_entire_file,Read entire file,"Task

Load the entire contents of some text file as a single string variable.

If applicable, discuss: encoding selection, the possibility of memory-mapping.

Of course, in practice one should avoid reading an entire file at once
if the file is large and the task can be accomplished incrementally instead
(in which case check File IO);
this is for those cases where having the entire file is actually what is wanted.



",#Go,Go,"import ""io/ioutil""
 
data, err := ioutil.ReadFile(filename)
sv := string(data)",78,4
23106,http://rosettacode.org/wiki/Repeat_a_string,Repeat a string,"Take a string and repeat it some number of times.

Example: repeat(""ha"", 5)   =>   ""hahahahaha""

If there is a simpler/more efficient way to repeat a single “character” (i.e. creating a string filled with a certain character), you might want to show that as well (i.e. repeat-char(""*"", 5) => ""*****"").




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"fmt.Println(strings.Repeat(""ha"", 5))        // ==> ""hahahahaha""",63,1
23160,http://rosettacode.org/wiki/Real_constants_and_functions,Real constants and functions,"Task

Show how to use the following math constants and functions in your language   (if not available, note it):

   e   (base of the natural logarithm)
   



π


{\displaystyle \pi }


   square root
   logarithm   (any base allowed)
   exponential   (ex )
   absolute value   (a.k.a. ""magnitude"")
   floor   (largest integer less than or equal to this number--not the same as truncate or int)
   ceiling   (smallest integer not less than this number--not the same as round up)
   power   (xy )


Related task

   Trigonometric Functions

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/big""
)
 
func main() {
    // e and pi defined as constants.
    // In Go, that means they are not of a specific data type and can be used
    // as float32 or float64.  Println takes the float64 values.
    fmt.Println(""float64 values:"")
    fmt.Println(""e:"", math.E)
    fmt.Println(""π:"", math.Pi)
 
    // The following functions all take and return the float64 data type.
 
    // square root.  cube root also available (math.Cbrt)
    fmt.Println(""square root(1.44):"", math.Sqrt(1.44))
    // natural logarithm--log base 10, 2 also available (math.Log10, math.Log2)
    // also available is log1p, the log of 1+x.  (using log1p can be more
    // accurate when x is near zero.)
    fmt.Println(""ln(e):"", math.Log(math.E))
    // exponential.  also available are exp base 10, 2 (math.Pow10, math.Exp2)
    fmt.Println(""exponential(1):"", math.Exp(1))
    fmt.Println(""absolute value(-1.2):"", math.Abs(-1.2))
    fmt.Println(""floor(-1.2):"", math.Floor(-1.2))
    fmt.Println(""ceiling(-1.2):"", math.Ceil(-1.2))
    fmt.Println(""power(1.44, .5):"", math.Pow(1.44, .5))
 
    // Equivalent functions for the float32 type are not in the standard
    // library.  Here are the constants e and π as float32s however.
    fmt.Println(""\nfloat32 values:"")
    fmt.Println(""e:"", float32(math.E))
    fmt.Println(""π:"", float32(math.Pi))
 
    // The standard library has an arbitrary precision floating point type but
    // provides only the most basic methods.  Also while the constants math.E
    // and math.Pi are provided to over 80 decimal places, there is no
    // convenient way of loading these numbers (with their full precision)
    // into a big.Float.  A hack is cutting and pasting into a string, but
    // of course if you're going to do that you are free to cut and paste from
    // any other source.  (The documentation cites OEIS as its source.)
    pi := ""3.141592653589793238462643383279502884197169399375105820974944""
    π, _, _ := big.ParseFloat(pi, 10, 200, 0)
    fmt.Println(""\nbig.Float values:"")
    fmt.Println(""π:"", π)
    // Of functions requested by the task, only absolute value is provided.
    x := new(big.Float).Neg(π)
    y := new(big.Float)
    fmt.Println(""x:"", x)
    fmt.Println(""abs(x):"", y.Abs(x))
}",2293,54
23263,http://rosettacode.org/wiki/Remove_duplicate_elements,Remove duplicate elements,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Given an Array, derive a sequence of elements in which all duplicates are removed.

There are basically three approaches seen here:

 Put the elements into a hash table which does not allow duplicates. The complexity is O(n) on average, and O(n2) worst case. This approach requires a hash function for your type (which is compatible with equality), either built-in to your language, or provided by the user.
 Sort the elements and remove consecutive duplicate elements. The complexity of the best sorting algorithms is O(n log n). This approach requires that your type be ""comparable"", i.e., have an ordering. Putting the elements into a self-balancing binary search tree is a special case of sorting.
 Go through the list, and for each element, check the rest of the list to see if it appears again, and discard it if it does. The complexity is O(n2). The up-shot is that this always works on any type (provided that you can test for equality).

",#Go,Go,"package main
 
import ""fmt""
 
func uniq(list []int) []int {
	unique_set := make(map[int]bool, len(list))
	for _, x := range list {
		unique_set[x] = true
	}
	result := make([]int, 0, len(unique_set))
	for x := range unique_set {
		result = append(result, x)
	}
	return result
}
 
func main() {
	fmt.Println(uniq([]int{1, 2, 3, 2, 3, 4})) // prints: [3 4 1 2] (but in a semi-random order)
}",389,19
23737,http://rosettacode.org/wiki/Reverse_a_string,Reverse a string,"Task

Take a string and reverse it.

For example, ""asdf"" becomes ""fdsa"".



Extra credit

Preserve Unicode combining characters.

For example, ""as⃝df̅"" becomes ""f̅ds⃝a"", not ""̅fd⃝sa"".




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""unicode""
    ""unicode/utf8""
)
 
// no encoding
func reverseBytes(s string) string {
    r := make([]byte, len(s))
    for i := 0; i < len(s); i++ {
        r[i] = s[len(s)-1-i]
    }
    return string(r)
}
 
// reverseCodePoints interprets its argument as UTF-8 and ignores bytes
// that do not form valid UTF-8.  return value is UTF-8.
func reverseCodePoints(s string) string {
    r := make([]rune, len(s))
    start := len(s)
    for _, c := range s {
        // quietly skip invalid UTF-8
        if c != utf8.RuneError {
            start--
            r[start] = c
        }
    }
    return string(r[start:])
}
 
// reversePreservingCombiningCharacters interprets its argument as UTF-8
// and ignores bytes that do not form valid UTF-8.  return value is UTF-8.
func reversePreservingCombiningCharacters(s string) string {
    if s == """" {
        return """"
    }
    p := []rune(s)
    r := make([]rune, len(p))
    start := len(r)
    for i := 0; i < len(p); {
        // quietly skip invalid UTF-8
        if p[i] == utf8.RuneError {
            i++
            continue
        }
        j := i + 1
        for j < len(p) && (unicode.Is(unicode.Mn, p[j]) ||
            unicode.Is(unicode.Me, p[j]) || unicode.Is(unicode.Mc, p[j])) {
            j++
        }
        for k := j - 1; k >= i; k-- {
            start--
            r[start] = p[k]
        }
        i = j
    }
    return (string(r[start:]))
}
 
func main() {
    test(""asdf"")
    test(""as⃝df̅"")
}
 
func test(s string) {
    fmt.Println(""\noriginal:      "", []byte(s), s)
    r := reverseBytes(s)
    fmt.Println(""reversed bytes:"", []byte(r), r)
    fmt.Println(""original code points:"", []rune(s), s)
    r = reverseCodePoints(s)
    fmt.Println(""reversed code points:"", []rune(r), r)
    r = reversePreservingCombiningCharacters(s)
    fmt.Println(""combining characters:"", []rune(r), r)
}",1904,76
23825,http://rosettacode.org/wiki/Read_a_file_character_by_character/UTF8,Read a file character by character/UTF8,"Task

Read a file one character at a time, as opposed to reading the entire file at once.

The solution may be implemented as a procedure, which returns the next character in the file on each consecutive call (returning EOF when the end of the file is reached).

The procedure should support the reading of files containing UTF8 encoded wide characters, returning whole characters for each consecutive read.

Related task

   Read a file line by line

",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""io""
    ""os""
)
 
func Runer(r io.RuneReader) func() (rune, error) {
    return func() (r rune, err error) {
        r, _, err = r.ReadRune()
        return
    }
}
 
func main() {
    runes := Runer(bufio.NewReader(os.Stdin))
    for r, err := runes(); err != nil; r,err = runes() {
        fmt.Printf(""%c"", r)
    }
}",369,22
23871,http://rosettacode.org/wiki/Rate_counter,Rate counter,"Of interest is the code that performs the actual measurements. Any other code (such as job implementation or dispatching) that is required to demonstrate the rate tracking is helpful, but not the focus.

Multiple approaches are allowed (even preferable), so long as they can accomplish these goals:

 Run N seconds worth of jobs and/or Y jobs.
 Report at least three distinct times.

Be aware of the precision and accuracy limitations of your timing mechanisms, and document them if you can.

See also: System time, Time a function
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
// representation of time.Time is nanosecond, actual resolution system specific
type rateStateS struct {
    lastFlush time.Time
    period    time.Duration
    tickCount int
}
 
func ticRate(pRate *rateStateS) {
    pRate.tickCount++
    now := time.Now()
    if now.Sub(pRate.lastFlush) >= pRate.period {
        // TPS Report
        tps := 0.
        if pRate.tickCount > 0 {
            tps = float64(pRate.tickCount) / now.Sub(pRate.lastFlush).Seconds()
        }
        fmt.Println(tps, ""tics per second."")
 
        // Reset
        pRate.tickCount = 0
        pRate.lastFlush = now
    }
}
 
func somethingWeDo() {
    time.Sleep(time.Duration(9e7 + rand.Int63n(2e7))) // sleep about .1 second.
}
 
func main() {
    start := time.Now()
 
    rateWatch := rateStateS{
        lastFlush: start,
        period:    5 * time.Second,
    }
 
    // Loop for twenty seconds
    latest := start
    for latest.Sub(start) < 20*time.Second {
        somethingWeDo()
        ticRate(&rateWatch)
        latest = time.Now()
    }
}",1096,52
24006,http://rosettacode.org/wiki/Read_a_specific_line_from_a_file,Read a specific line from a file,"Some languages have special semantics for obtaining a known line number from a file.



Task

Demonstrate how to obtain the contents of a specific line within a file.

For the purpose of this task demonstrate how the contents of the seventh line of a file can be obtained,   and store it in a variable or in memory   (for potential future use within the program if the code were to become embedded).

If the file does not contain seven lines,   or the seventh line is empty,   or too big to be retrieved,   output an appropriate message.

If no special semantics are available for obtaining the required line,   it is permissible to read line by line.

Note that empty lines are considered and should still be counted.

Also note that for functional languages or languages without variables or storage,   it is permissible to output the extracted data to standard output.



",#Go,Go,"package main
 
import (
	""bufio""
	""errors""
	""fmt""
	""io""
	""os""
)
 
func main() {
	if line, err := rsl(""input.txt"", 7); err == nil {
		fmt.Println(""7th line:"")
		fmt.Println(line)
	} else {
		fmt.Println(""rsl:"", err)
	}
}
 
func rsl(fn string, n int) (string, error) {
	if n < 1 {
		return """", fmt.Errorf(""invalid request: line %d"", n)
	}
	f, err := os.Open(fn)
	if err != nil {
		return """", err
	}
	defer f.Close()
	bf := bufio.NewReader(f)
	var line string
	for lnum := 0; lnum < n; lnum++ {
		line, err = bf.ReadString('\n')
		if err == io.EOF {
			switch lnum {
			case 0:
				return """", errors.New(""no lines in file"")
			case 1:
				return """", errors.New(""only 1 line"")
			default:
				return """", fmt.Errorf(""only %d lines"", lnum)
			}
		}
		if err != nil {
			return """", err
		}
	}
	if line == """" {
		return """", fmt.Errorf(""line %d empty"", n)
	}
	return line, nil
}",869,51
24088,http://rosettacode.org/wiki/Ray-casting_algorithm,Ray-casting algorithm,"

 This page uses content from Wikipedia. The original article was at Point_in_polygon. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Given a point and a polygon, check if the point is inside or outside the polygon using the ray-casting algorithm.

A pseudocode can be simply:

 count ← 0
 foreach side in polygon:
   if ray_intersects_segment(P,side) then
     count ← count + 1
 if is_odd(count) then
   return inside
 else
   return outside

Where the function ray_intersects_segment return true if the horizontal ray starting from the point P intersects the side (segment), false otherwise.

An intuitive explanation of why it works is that every time we cross
a border, we change ""country"" (inside-outside, or outside-inside), but
the last ""country"" we land on is surely outside (since the inside of the polygon is finite, while the ray continues towards infinity). So, if we crossed an odd number of borders we were surely inside, otherwise we were outside; we can follow the ray backward to see it better: starting from outside, only an odd number of crossing can give an inside: outside-inside, outside-inside-outside-inside, and so on (the - represents the crossing of a border).

So the main part of the algorithm is how we determine if a ray intersects a segment. The following text explain one of the possible ways.

 
Looking at the image on the right, we can easily be convinced of the fact that rays starting from points in the hatched area (like P1 and P2) surely do not intersect the segment AB. We also can easily see that rays starting from points in the greenish area surely intersect the segment AB (like point P3).

So the problematic points are those inside the white area (the box delimited by the points A and B), like P4.

 
 
Let us take into account a segment AB (the point A having y coordinate always smaller than B's y coordinate, i.e. point A is always below point B) and a point P. Let us use the cumbersome notation PAX to denote the angle between segment AP and AX, where X is always a point on the horizontal line passing by A with x coordinate bigger than the maximum between the x coordinate of A and the x coordinate of B. As explained graphically by the figures on the right, if PAX is greater than the angle BAX, then the ray starting from P intersects the segment AB. (In the images, the ray starting from PA does not intersect the segment, while the ray starting from PB in the second picture, intersects the segment).

Points on the boundary or ""on"" a vertex are someway special and through this approach we do not obtain coherent results. They could be treated apart, but it is not necessary to do so.

An algorithm for the previous speech could be (if P is a point, Px is its x coordinate):

 ray_intersects_segment:
    P : the point from which the ray starts
    A : the end-point of the segment with the smallest y coordinate
        (A must be ""below"" B)
    B : the end-point of the segment with the greatest y coordinate
        (B must be ""above"" A)
 if Py = Ay or Py = By then
   Py ← Py + ε
 end if
 if Py < Ay or Py > By then 
   return false
 else if Px >= max(Ax, Bx) then 
   return false
 else
   if Px < min(Ax, Bx) then
     return true
   else
     if Ax ≠ Bx then
       m_red ← (By - Ay)/(Bx - Ax)
     else
       m_red ← ∞
     end if
     if Ax ≠ Px then
       m_blue ← (Py - Ay)/(Px - Ax)
     else
       m_blue ← ∞
     end if
     if m_blue ≥ m_red then
       return true
     else
       return false
     end if
   end if
 end if

(To avoid the ""ray on vertex"" problem, the point is moved upward of a small quantity   ε.)



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
type xy struct {
    x, y float64
}
 
type seg struct {
    p1, p2 xy
}
 
type poly struct {
    name  string
    sides []seg
}
 
func inside(pt xy, pg poly) (i bool) {
    for _, side := range pg.sides {
        if rayIntersectsSegment(pt, side) {
            i = !i
        }
    }
    return
}
 
func rayIntersectsSegment(p xy, s seg) bool {
    var a, b xy
    if s.p1.y < s.p2.y {
        a, b = s.p1, s.p2
    } else {
        a, b = s.p2, s.p1
    }
    for p.y == a.y || p.y == b.y {
        p.y = math.Nextafter(p.y, math.Inf(1))
    }
    if p.y < a.y || p.y > b.y {
        return false
    }
    if a.x > b.x {
        if p.x > a.x {
            return false
        }
        if p.x < b.x {
            return true
        }
    } else {
        if p.x > b.x {
            return false
        }
        if p.x < a.x {
            return true
        }
    }
    return (p.y-a.y)/(p.x-a.x) >= (b.y-a.y)/(b.x-a.x)
}
 
var (
    p1  = xy{0, 0}
    p2  = xy{10, 0}
    p3  = xy{10, 10}
    p4  = xy{0, 10}
    p5  = xy{2.5, 2.5}
    p6  = xy{7.5, 2.5}
    p7  = xy{7.5, 7.5}
    p8  = xy{2.5, 7.5}
    p9  = xy{0, 5}
    p10 = xy{10, 5}
    p11 = xy{3, 0}
    p12 = xy{7, 0}
    p13 = xy{7, 10}
    p14 = xy{3, 10}
)
 
var tpg = []poly{
    {""square"", []seg{{p1, p2}, {p2, p3}, {p3, p4}, {p4, p1}}},
    {""square hole"", []seg{{p1, p2}, {p2, p3}, {p3, p4}, {p4, p1},
        {p5, p6}, {p6, p7}, {p7, p8}, {p8, p5}}},
    {""strange"", []seg{{p1, p5},
        {p5, p4}, {p4, p8}, {p8, p7}, {p7, p3}, {p3, p2}, {p2, p5}}},
    {""exagon"", []seg{{p11, p12}, {p12, p10}, {p10, p13},
        {p13, p14}, {p14, p9}, {p9, p11}}},
}
 
var tpt = []xy{
    // test points common in other solutions on this page
    {5, 5}, {5, 8}, {-10, 5}, {0, 5}, {10, 5}, {8, 5}, {10, 10},
    // test points that show the problem with ""strange""
    {1, 2}, {2, 1},
}
 
func main() {
    for _, pg := range tpg {
        fmt.Printf(""%s:\n"", pg.name)
        for _, pt := range tpt {
            fmt.Println(pt, inside(pt, pg))
        }
    }
}",2075,102
24130,http://rosettacode.org/wiki/Range_consolidation,Range consolidation,"Define a range of numbers   R,   with bounds   b0   and   b1   covering all numbers between and including both bounds.



That range can be shown as:

 [b0, b1]
    or equally as:
 [b1, b0]


Given two ranges, the act of consolidation between them compares the two ranges:

   If one range covers all of the other then the result is that encompassing range.
   If the ranges touch or intersect then the result is   one   new single range covering the overlapping ranges.
   Otherwise the act of consolidation is to return the two non-touching ranges.


Given   N   ranges where   N > 2   then the result is the same as repeatedly replacing all combinations of two ranges by their consolidation until no further consolidation between range pairs is possible.

If   N < 2   then range consolidation has no strict meaning and the input can be returned.



Example 1

   Given the two ranges   [1, 2.5]   and   [3, 4.2]   then 
   there is no common region between the ranges and the result is the same as the input.


Example 2

   Given the two ranges   [1, 2.5]   and   [1.8, 4.7]   then 
   there is :   an overlap   [2.5, 1.8]   between the ranges and 
   the result is the single range   [1, 4.7]. 
   Note that order of bounds in a range is not (yet) stated.


Example 3

   Given the two ranges   [6.1, 7.2]   and   [7.2, 8.3]   then 
   they touch at   7.2   and 
   the result is the single range   [6.1, 8.3]. 


Example 4

   Given the three ranges   [1, 2]   and   [4, 8]   and   [2, 5] 
   then there is no intersection of the ranges   [1, 2]   and   [4, 8] 
   but the ranges   [1, 2]   and   [2, 5]   overlap and 
   consolidate to produce the range   [1, 5]. 
   This range, in turn, overlaps the other range   [4, 8],   and 
   so consolidates to the final output of the single range   [1, 8].


Task

Let a normalized range display show the smaller bound to the left;   and show the
range with the smaller lower bound to the left of other ranges when showing multiple ranges.

Output the normalized result of applying consolidation to these five sets of ranges: 

           [1.1, 2.2]
           [6.1, 7.2], [7.2, 8.3]
           [4, 3], [2, 1]
           [4, 3], [2, 1], [-1, -2], [3.9, 10]
           [1, 3], [-6, -1], [-4, -5], [8, 2], [-6, -6]  

Show all output here.



See also

 Set consolidation
 Set of real numbers

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""sort""
)
 
type Range struct{ Lower, Upper float64 }
 
func (r Range) Norm() Range {
    if r.Lower > r.Upper {
        return Range{r.Upper, r.Lower}
    }
    return r
}
 
func (r Range) String() string {
    return fmt.Sprintf(""[%g, %g]"", r.Lower, r.Upper)
}
 
func (r1 Range) Union(r2 Range) []Range {
    if r1.Upper < r2.Lower {
        return []Range{r1, r2}
    }
    r := Range{r1.Lower, math.Max(r1.Upper, r2.Upper)}
    return []Range{r}
}
 
func consolidate(rs []Range) []Range {
    for i := range rs {
        rs[i] = rs[i].Norm()
    }
    le := len(rs)
    if le < 2 {
        return rs
    }
    sort.Slice(rs, func(i, j int) bool {
        return rs[i].Lower < rs[j].Lower
    })
    if le == 2 {
        return rs[0].Union(rs[1])
    }
    for i := 0; i < le-1; i++ {
        for j := i + 1; j < le; j++ {
            ru := rs[i].Union(rs[j])
            if len(ru) == 1 {
                rs[i] = ru[0]
                copy(rs[j:], rs[j+1:])
                rs = rs[:le-1]
                le--
                i--
                break
            }
        }
    }
    return rs
}
 
func main() {
    rss := [][]Range{
        {{1.1, 2.2}},
        {{6.1, 7.2}, {7.2, 8.3}},
        {{4, 3}, {2, 1}},
        {{4, 3}, {2, 1}, {-1, -2}, {3.9, 10}},
        {{1, 3}, {-6, -1}, {-4, -5}, {8, 2}, {-6, -6}},
    }
    for _, rs := range rss {
        s := fmt.Sprintf(""%v"", rs)
        fmt.Printf(""%40s => "", s[1:len(s)-1])
        rs2 := consolidate(rs)
        s = fmt.Sprintf(""%v"", rs2)
        fmt.Println(s[1 : len(s)-1])
    }
}",1599,75
24148,http://rosettacode.org/wiki/Ranking_methods,Ranking methods,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


The numerical rank of competitors in a competition shows if one is better than, equal to, or worse than another based on their results in a competition.

The numerical rank of a competitor can be assigned in several different ways.



Task

The following scores are accrued for all competitors of a competition (in best-first order):

44 Solomon
42 Jason
42 Errol
41 Garry
41 Bernard
41 Barry
39 Stephen
For each of the following ranking methods, create a function/method/procedure/subroutine... that applies the ranking method to an ordered list of scores with scorers:

 Standard. (Ties share what would have been their first ordinal number).
 Modified. (Ties share what would have been their last ordinal number).
 Dense. (Ties share the next available integer). 
 Ordinal. ((Competitors take the next available integer. Ties are not treated otherwise).
 Fractional. (Ties share the mean of what would have been their ordinal numbers).


See the wikipedia article for a fuller description.

Show here, on this page, the ranking of the test scores under each of the numbered ranking methods.



",#Go,Go,"package main
 
import (
	""fmt""
	""sort""
)
 
type rankable interface {
	Len() int
	RankEqual(int, int) bool
}
 
func StandardRank(d rankable) []float64 {
	r := make([]float64, d.Len())
	var k int
	for i := range r {
		if i == 0 || !d.RankEqual(i, i-1) {
			k = i + 1
		}
		r[i] = float64(k)
	}
	return r
}
 
func ModifiedRank(d rankable) []float64 {
	r := make([]float64, d.Len())
	for i := range r {
		k := i + 1
		for j := i + 1; j < len(r) && d.RankEqual(i, j); j++ {
			k = j + 1
		}
		r[i] = float64(k)
	}
	return r
}
 
func DenseRank(d rankable) []float64 {
	r := make([]float64, d.Len())
	var k int
	for i := range r {
		if i == 0 || !d.RankEqual(i, i-1) {
			k++
		}
		r[i] = float64(k)
	}
	return r
}
 
func OrdinalRank(d rankable) []float64 {
	r := make([]float64, d.Len())
	for i := range r {
		r[i] = float64(i + 1)
	}
	return r
}
 
func FractionalRank(d rankable) []float64 {
	r := make([]float64, d.Len())
	for i := 0; i < len(r); {
		var j int
		f := float64(i + 1)
		for j = i + 1; j < len(r) && d.RankEqual(i, j); j++ {
			f += float64(j + 1)
		}
		f /= float64(j - i)
		for ; i < j; i++ {
			r[i] = f
		}
	}
	return r
}
 
type scores []struct {
	score int
	name  string
}
 
func (s scores) Len() int                { return len(s) }
func (s scores) RankEqual(i, j int) bool { return s[i].score == s[j].score }
func (s scores) Swap(i, j int)           { s[i], s[j] = s[j], s[i] }
func (s scores) Less(i, j int) bool {
	if s[i].score != s[j].score {
		return s[i].score > s[j].score
	}
	return s[i].name < s[j].name
}
 
var data = scores{
	{44, ""Solomon""},
	{42, ""Jason""},
	{42, ""Errol""},
	{41, ""Garry""},
	{41, ""Bernard""},
	{41, ""Barry""},
	{39, ""Stephen""},
}
 
func main() {
	show := func(name string, fn func(rankable) []float64) {
		fmt.Println(name, ""Ranking:"")
		r := fn(data)
		for i, d := range data {
			fmt.Printf(""%4v - %2d %s\n"", r[i], d.score, d.name)
		}
	}
 
	sort.Sort(data)
	show(""Standard"", StandardRank)
	show(""\nModified"", ModifiedRank)
	show(""\nDense"", DenseRank)
	show(""\nOrdinal"", OrdinalRank)
	show(""\nFractional"", FractionalRank)
}",2068,113
24164,http://rosettacode.org/wiki/Rare_numbers,Rare numbers,"Definitions and restrictions

Rare   numbers are positive integers    n    where:

    n    is expressed in base ten
    r    is the reverse of    n      (decimal digits)
    n    must be non-palindromic   (n ≠ r)
    (n+r)    is the   sum
    (n-r)    is the   difference   and must be positive
   the   sum   and the   difference   must be perfect squares


Task

   find and show the first   5   rare   numbers
   find and show the first   8   rare   numbers       (optional)
   find and show more   rare   numbers                (stretch goal)


Show all output here, on this page.



References

   an   OEIS   entry:   A035519          rare numbers.
   an   OEIS   entry:   A059755   odd rare numbers.
   planetmath entry:   rare numbers.     (some hints)
   author's  website:   rare numbers   by Shyam Sunder Gupta.     (lots of hints and some observations).

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""sort""
    ""time""
)
 
type term struct {
    coeff    uint64
    ix1, ix2 int8
}
 
const maxDigits = 19
 
func toUint64(digits []int8, reverse bool) uint64 {
    sum := uint64(0)
    if !reverse {
        for i := 0; i < len(digits); i++ {
            sum = sum*10 + uint64(digits[i])
        }
    } else {
        for i := len(digits) - 1; i >= 0; i-- {
            sum = sum*10 + uint64(digits[i])
        }
    }
    return sum
}
 
func isSquare(n uint64) bool {
    if 0x202021202030213&(1<<(n&63)) != 0 {
        root := uint64(math.Sqrt(float64(n)))
        return root*root == n
    }
    return false
}
 
func seq(from, to, step int8) []int8 {
    var res []int8
    for i := from; i <= to; i += step {
        res = append(res, i)
    }
    return res
}
 
func commatize(n uint64) string {
    s := fmt.Sprintf(""%d"", n)
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    return s
}
 
func main() {
    start := time.Now()
    pow := uint64(1)
    fmt.Println(""Aggregate timings to process all numbers up to:"")
    // terms of (n-r) expression for number of digits from 2 to maxDigits
    allTerms := make([][]term, maxDigits-1)
    for r := 2; r <= maxDigits; r++ {
        var terms []term
        pow *= 10
        pow1, pow2 := pow, uint64(1)
        for i1, i2 := int8(0), int8(r-1); i1 < i2; i1, i2 = i1+1, i2-1 {
            terms = append(terms, term{pow1 - pow2, i1, i2})
            pow1 /= 10
            pow2 *= 10
        }
        allTerms[r-2] = terms
    }
    //  map of first minus last digits for 'n' to pairs giving this value
    fml := map[int8][][]int8{
        0: {{2, 2}, {8, 8}},
        1: {{6, 5}, {8, 7}},
        4: {{4, 0}},
        6: {{6, 0}, {8, 2}},
    }
    // map of other digit differences for 'n' to pairs giving this value
    dmd := make(map[int8][][]int8)
    for i := int8(0); i < 100; i++ {
        a := []int8{i / 10, i % 10}
        d := a[0] - a[1]
        dmd[d] = append(dmd[d], a)
    }
    fl := []int8{0, 1, 4, 6}
    dl := seq(-9, 9, 1) // all differences
    zl := []int8{0}     // zero differences only
    el := seq(-8, 8, 2) // even differences only
    ol := seq(-9, 9, 2) // odd differences only
    il := seq(0, 9, 1)
    var rares []uint64
    lists := make([][][]int8, 4)
    for i, f := range fl {
        lists[i] = [][]int8{{f}}
    }
    var digits []int8
    count := 0
 
    // Recursive closure to generate (n+r) candidates from (n-r) candidates
    // and hence find Rare numbers with a given number of digits.
    var fnpr func(cand, di []int8, dis [][]int8, indices [][2]int8, nmr uint64, nd, level int)
    fnpr = func(cand, di []int8, dis [][]int8, indices [][2]int8, nmr uint64, nd, level int) {
        if level == len(dis) {
            digits[indices[0][0]] = fml[cand[0]][di[0]][0]
            digits[indices[0][1]] = fml[cand[0]][di[0]][1]
            le := len(di)
            if nd%2 == 1 {
                le--
                digits[nd/2] = di[le]
            }
            for i, d := range di[1:le] {
                digits[indices[i+1][0]] = dmd[cand[i+1]][d][0]
                digits[indices[i+1][1]] = dmd[cand[i+1]][d][1]
            }
            r := toUint64(digits, true)
            npr := nmr + 2*r
            if !isSquare(npr) {
                return
            }
            count++
            fmt.Printf(""     R/N %2d:"", count)
            ms := uint64(time.Since(start).Milliseconds())
            fmt.Printf(""  %9s ms"", commatize(ms))
            n := toUint64(digits, false)
            fmt.Printf(""  (%s)\n"", commatize(n))
            rares = append(rares, n)
        } else {
            for _, num := range dis[level] {
                di[level] = num
                fnpr(cand, di, dis, indices, nmr, nd, level+1)
            }
        }
    }
 
    // Recursive closure to generate (n-r) candidates with a given number of digits.
    var fnmr func(cand []int8, list [][]int8, indices [][2]int8, nd, level int)
    fnmr = func(cand []int8, list [][]int8, indices [][2]int8, nd, level int) {
        if level == len(list) {
            var nmr, nmr2 uint64
            for i, t := range allTerms[nd-2] {
                if cand[i] >= 0 {
                    nmr += t.coeff * uint64(cand[i])
                } else {
                    nmr2 += t.coeff * uint64(-cand[i])
                    if nmr >= nmr2 {
                        nmr -= nmr2
                        nmr2 = 0
                    } else {
                        nmr2 -= nmr
                        nmr = 0
                    }
                }
            }
            if nmr2 >= nmr {
                return
            }
            nmr -= nmr2
            if !isSquare(nmr) {
                return
            }
            var dis [][]int8
            dis = append(dis, seq(0, int8(len(fml[cand[0]]))-1, 1))
            for i := 1; i < len(cand); i++ {
                dis = append(dis, seq(0, int8(len(dmd[cand[i]]))-1, 1))
            }
            if nd%2 == 1 {
                dis = append(dis, il)
            }
            di := make([]int8, len(dis))
            fnpr(cand, di, dis, indices, nmr, nd, 0)
        } else {
            for _, num := range list[level] {
                cand[level] = num
                fnmr(cand, list, indices, nd, level+1)
            }
        }
    }
 
    for nd := 2; nd <= maxDigits; nd++ {
        digits = make([]int8, nd)
        if nd == 4 {
            lists[0] = append(lists[0], zl)
            lists[1] = append(lists[1], ol)
            lists[2] = append(lists[2], el)
            lists[3] = append(lists[3], ol)
        } else if len(allTerms[nd-2]) > len(lists[0]) {
            for i := 0; i < 4; i++ {
                lists[i] = append(lists[i], dl)
            }
        }
        var indices [][2]int8
        for _, t := range allTerms[nd-2] {
            indices = append(indices, [2]int8{t.ix1, t.ix2})
        }
        for _, list := range lists {
            cand := make([]int8, len(list))
            fnmr(cand, list, indices, nd, 0)
        }
        ms := uint64(time.Since(start).Milliseconds())
        fmt.Printf(""  %2d digits:  %9s ms\n"", nd, commatize(ms))
    }
 
    sort.Slice(rares, func(i, j int) bool { return rares[i] < rares[j] })
    fmt.Printf(""\nThe rare numbers with up to %d digits are:\n"", maxDigits)
    for i, rare := range rares {
        fmt.Printf(""  %2d:  %25s\n"", i+1, commatize(rare))
    }
}",6482,210
24201,http://rosettacode.org/wiki/Ramanujan_primes/twins,Ramanujan primes/twins,"In a manner similar to twin primes, twin Ramanujan primes may be explored. The task is to determine how many of the first million Ramanujan primes are twins.

Related Task
 Twin primes",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""rcu""
    ""time""
)
 
var count []int
 
func primeCounter(limit int) {
    count = make([]int, limit)
    for i := 0; i < limit; i++ {
        count[i] = 1
    }
    if limit > 0 {
        count[0] = 0
    }
    if limit > 1 {
        count[1] = 0
    }
    for i := 4; i < limit; i += 2 {
        count[i] = 0
    }
    for p, sq := 3, 9; sq < limit; p += 2 {
        if count[p] != 0 {
            for q := sq; q < limit; q += p << 1 {
                count[q] = 0
            }
        }
        sq += (p + 1) << 2
    }
    sum := 0
    for i := 0; i < limit; i++ {
        sum += count[i]
        count[i] = sum
    }
}
 
func primeCount(n int) int {
    if n < 1 {
        return 0
    }
    return count[n]
}
 
func ramanujanMax(n int) int {
    fn := float64(n)
    return int(math.Ceil(4 * fn * math.Log(4*fn)))
}
 
func ramanujanPrime(n int) int {
    if n == 1 {
        return 2
    }
    for i := ramanujanMax(n); i >= 2*n; i-- {
        if i%2 == 1 {
            continue
        }
        if primeCount(i)-primeCount(i/2) < n {
            return i + 1
        }
    }
    return 0
}
 
func rpc(p int) int { return primeCount(p) - primeCount(p/2) }
 
func main() {
    for _, limit := range []int{1e5, 1e6} {
        start := time.Now()
        primeCounter(1 + ramanujanMax(limit))
        rplim := ramanujanPrime(limit)
        climit := rcu.Commatize(limit)
        fmt.Printf(""The %sth Ramanujan prime is %s\n"", climit, rcu.Commatize(rplim))
        r := rcu.Primes(rplim)
        c := make([]int, len(r))
        for i := 0; i < len(c); i++ {
            c[i] = rpc(r[i])
        }
        ok := c[len(c)-1]
        for i := len(c) - 2; i >= 0; i-- {
            if c[i] < ok {
                ok = c[i]
            } else {
                c[i] = 0
            }
        }
        var fr []int
        for i, r := range r {
            if c[i] != 0 {
                fr = append(fr, r)
            }
        }
        twins := 0
        for i := 0; i < len(fr)-1; i++ {
            if fr[i]+2 == fr[i+1] {
                twins++
            }
        }
        fmt.Printf(""There are %s twins in the first %s Ramanujan primes.\n"", rcu.Commatize(twins), climit)
        fmt.Println(""Took"", time.Since(start))
        fmt.Println()
    }
}",2306,106
24224,http://rosettacode.org/wiki/Ramanujan%27s_constant,Ramanujan's constant,"Calculate Ramanujan's constant (as described on the OEIS site) with at least
32 digits of precision, by the method of your choice. Optionally, if using the 𝑒**(π*√x) approach,
show that when evaluated with the last four Heegner numbers
the result is almost an integer.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""github.com/ALTree/bigfloat""
    ""math/big""
)
 
const (
    prec = 256 // say
    ps   = ""3.1415926535897932384626433832795028841971693993751058209749445923078164""
)
 
func q(d int64) *big.Float {
    pi, _ := new(big.Float).SetPrec(prec).SetString(ps)
    t := new(big.Float).SetPrec(prec).SetInt64(d)
    t.Sqrt(t)
    t.Mul(pi, t)
    return bigfloat.Exp(t)
}
 
func main() {
    fmt.Println(""Ramanujan's constant to 32 decimal places is:"")
    fmt.Printf(""%.32f\n"", q(163))
    heegners := [4][2]int64{
        {19, 96},
        {43, 960},
        {67, 5280},
        {163, 640320},
    }
    fmt.Println(""\nHeegner numbers yielding 'almost' integers:"")
    t := new(big.Float).SetPrec(prec)
    for _, h := range heegners {
        qh := q(h[0])
        c := h[1]*h[1]*h[1] + 744
        t.SetInt64(c)
        t.Sub(t, qh)
        fmt.Printf(""%3d: %51.32f ≈ %18d (diff: %.32f)\n"", h[0], qh, c, t)
    }
}",947,40
24276,http://rosettacode.org/wiki/Quoting_constructs,Quoting constructs,"Pretty much every programming language has some form of quoting construct to allow embedding of data in a program, be it literal strings, numeric data or some combination thereof.

Show examples of the quoting constructs in your language. Explain where they would likely be used, what their primary use is, what limitations they have and why one might be preferred over another. Is one style interpolating and another not? Are there restrictions on the size of the quoted data? The type? The format?

This is intended to be open-ended and free form. If you find yourself writing more than a few thousand words of explanation, summarize and provide links to relevant documentation; but do provide at least a fairly comprehensive summary here, on this page, NOT just a link to [See the language docs].

Note: This is primarily for quoting constructs for data to be ""embedded"" in some way into a program. If there is some special format for external data, it may be mentioned but that isn't the focus of this task.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""os""
    ""regexp""
    ""strconv""
)
 
/* Quoting constructs in Go. */
 
// In Go a Unicode codepoint, expressed as a 32-bit integer, is referred to as a 'rune'
// but the more familiar term 'character' will be used instead here.
 
// Character literal (single quotes).
// Can contain any single character including an escaped character.
var (
    rl1 = 'a'
    rl2 = '\'' // single quote can only be included in escaped form
)
 
// Interpreted string literal (double quotes).
// A sequence of characters including escaped characters.
var (
    is1 = ""abc""
    is2 = ""\""ab\tc\"""" // double quote can only be included in escaped form
)
 
// Raw string literal(single back quotes).
// Can contain any character including a 'physical' new line but excluding back quote.
// Escaped characters are interpreted literally i.e. `\n` is backslash followed by n.
// Raw strings are typically used for hard-coding pieces of text perhaps
// including single and/or double quotes without the need to escape them.
// They are particularly useful for regular expressions.
var (
    rs1 = `
first""
second'
third""
`
    rs2 = `This is one way of including a ` + ""`"" + ` in a raw string literal.`
    rs3 = `\d+` // a sequence of one or more digits in a regular expression
)
 
func main() {
    fmt.Println(rl1, rl2) // prints the code point value not the character itself
    fmt.Println(is1, is2)
    fmt.Println(rs1)
    fmt.Println(rs2)
    re := regexp.MustCompile(rs3)
    fmt.Println(re.FindString(""abcd1234efgh""))
 
    /* None of the above quoting constructs can deal directly with interpolation.
       This is done instead using library functions.
    */
 
    // C-style using %d, %f, %s etc. within a 'printf' type function.
    n := 3
    fmt.Printf(""\nThere are %d quoting constructs in Go.\n"", n)
 
    // Using a function such as fmt.Println which can take a variable
    // number of arguments, of any type, and print then out separated by spaces.
    s := ""constructs""
    fmt.Println(""There are"", n, ""quoting"", s, ""in Go."")
 
    // Using the function os.Expand which requires a mapper function to fill placeholders
    // denoted by ${...} within a string.
    mapper := func(placeholder string) string {
        switch placeholder {
        case ""NUMBER"":
            return strconv.Itoa(n)
        case ""TYPES"":
            return s
        }
        return """"
    }
    fmt.Println(os.Expand(""There are ${NUMBER} quoting ${TYPES} in Go."", mapper))
}",2489,78
24299,http://rosettacode.org/wiki/Random_number_generator_(device),Random number generator (device),"Task

If your system has a means to generate random numbers involving not only a software algorithm   (like the /dev/urandom devices in Unix),   then:

show how to obtain a random 32-bit number from that mechanism.

Related task
 Random_number_generator_(included)

",#Go,Go,"package main
 
import (
    ""crypto/rand""
    ""encoding/binary""
    ""fmt""
    ""io""
    ""os""
)
 
func main() {
    testRandom(""crypto/rand"", rand.Reader)
    testRandom(""dev/random"", newDevRandom())
}
 
func newDevRandom() (f *os.File) {
    var err error
    if f, err = os.Open(""/dev/random""); err != nil {
        panic(err)
    }
    return
}
 
func testRandom(label string, src io.Reader) {
    fmt.Printf(""%s:\n"", label)
    var r int32
    for i := 0; i < 10; i++ {
        if err := binary.Read(src, binary.LittleEndian, &r); err != nil {
            panic(err)
        }
        fmt.Print(r, "" "")
    }
    fmt.Println()
}",630,34
24341,http://rosettacode.org/wiki/Ramer-Douglas-Peucker_line_simplification,Ramer-Douglas-Peucker line simplification,"Ramer-Douglas-Peucker line simplification

You are encouraged to solve this task according to the task description, using any language you may know.
The   Ramer–Douglas–Peucker   algorithm is a line simplification algorithm for reducing the number of points used to define its shape.



Task

Using the   Ramer–Douglas–Peucker   algorithm, simplify the   2D   line defined by the points:

   (0,0)  (1,0.1)  (2,-0.1)  (3,5)  (4,6)  (5,7)  (6,8.1)  (7,9)  (8,9)  (9,9) 

The error threshold to be used is:   1.0.

Display the remaining points here.



Reference

   the Wikipedia article:   Ramer-Douglas-Peucker algorithm.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
type point struct{ x, y float64 }
 
func RDP(l []point, ε float64) []point {
    x := 0
    dMax := -1.
    last := len(l) - 1
    p1 := l[0]
    p2 := l[last]
    x21 := p2.x - p1.x
    y21 := p2.y - p1.y
    for i, p := range l[1:last] {
        if d := math.Abs(y21*p.x - x21*p.y + p2.x*p1.y - p2.y*p1.x); d > dMax {
            x = i + 1
            dMax = d
        }
    }
    if dMax > ε {
        return append(RDP(l[:x+1], ε), RDP(l[x:], ε)[1:]...)
    }
    return []point{l[0], l[len(l)-1]}
}
 
func main() {
    fmt.Println(RDP([]point{{0, 0}, {1, 0.1}, {2, -0.1},
        {3, 5}, {4, 6}, {5, 7}, {6, 8.1}, {7, 9}, {8, 9}, {9, 9}}, 1))
}",698,33
24387,http://rosettacode.org/wiki/Random_Latin_squares,Random Latin squares,"A Latin square of size n is an arrangement of n symbols in an n-by-n square in such a way that each row and column has each symbol appearing exactly once.

A randomised Latin square generates random configurations of the symbols for any given n.

Example n=4 randomised Latin square

0 2 3 1
2 1 0 3
3 0 1 2
1 3 2 0
Task

 Create a function/routine/procedure/method/... that given n generates a randomised Latin square of size n.
 Use the function to generate and show here, two randomly generated squares of size 5.
Note
 
Strict Uniformity in the random generation is a hard problem and not a requirement of the task.

Reference

 Wikipedia: Latin square
 OEIS: A002860

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
type matrix [][]int
 
func shuffle(row []int, n int) {
    rand.Shuffle(n, func(i, j int) {
        row[i], row[j] = row[j], row[i]
    })
}
 
func latinSquare(n int) {
    if n <= 0 {
        fmt.Println(""[]\n"")
        return
    }
    latin := make(matrix, n)
    for i := 0; i < n; i++ {
        latin[i] = make([]int, n)
        if i == n-1 {
            break
        }
        for j := 0; j < n; j++ {
            latin[i][j] = j
        }
    }
    // first row
    shuffle(latin[0], n)
 
    // middle row(s)
    for i := 1; i < n-1; i++ {
        shuffled := false
    shuffling:
        for !shuffled {
            shuffle(latin[i], n)
            for k := 0; k < i; k++ {
                for j := 0; j < n; j++ {
                    if latin[k][j] == latin[i][j] {
                        continue shuffling
                    }
                }
            }
            shuffled = true
        }
    }
 
    // last row
    for j := 0; j < n; j++ {
        used := make([]bool, n)
        for i := 0; i < n-1; i++ {
            used[latin[i][j]] = true
        }
        for k := 0; k < n; k++ {
            if !used[k] {
                latin[n-1][j] = k
                break
            }
        }
    }
    printSquare(latin, n)
}
 
func printSquare(latin matrix, n int) {
    for i := 0; i < n; i++ {
        fmt.Println(latin[i])
    }
    fmt.Println()
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    latinSquare(5)
    latinSquare(5)
    latinSquare(10) // for good measure
}",1576,80
24434,http://rosettacode.org/wiki/Random_number_generator_(included),Random number generator (included),"The task is to:

 State the type of random number generator algorithm used in a language's built-in random number generator. If the language or its immediate libraries don't provide a random number generator, skip this task.
 If possible, give a link to a wider explanation of the algorithm used.
Note: the task is not to create an RNG, but to report on the languages in-built RNG that would be the most likely RNG used.

The main types of pseudo-random number generator (PRNG) that are in use are the Linear Congruential Generator (LCG), and the Generalized Feedback Shift Register (GFSR), (of which the Mersenne twister generator is a subclass). The last main type is where the output of one of the previous ones (typically a Mersenne twister) is fed through a cryptographic hash function to maximize unpredictability of individual bits.

Note that neither LCGs nor GFSRs should be used for the most demanding applications (cryptography) without additional steps.
",#Go,Go,"setrand(3)
random(6)+1
\\ chosen by fair dice roll.
\\ guaranteed to the random.",80,4
24545,http://rosettacode.org/wiki/Read_a_configuration_file,Read a configuration file,"The task is to read a configuration file in standard configuration file format,
and set variables accordingly.

For this task, we have a configuration file as follows:

# This is a configuration file in standard configuration file format
#
# Lines beginning with a hash or a semicolon are ignored by the application
# program. Blank lines are also ignored by the application program.

# This is the fullname parameter
FULLNAME Foo Barber

# This is a favourite fruit
FAVOURITEFRUIT banana

# This is a boolean that should be set
NEEDSPEELING

# This boolean is commented out
; SEEDSREMOVED

# Configuration option names are not case sensitive, but configuration parameter
# data is case sensitive and may be preserved by the application program.

# An optional equals sign can be used to separate configuration parameter data
# from the option name. This is dropped by the parser. 

# A configuration option may take multiple parameters separated by commas.
# Leading and trailing whitespace around parameter names and parameter data fields
# are ignored by the application program.

OTHERFAMILY Rhu Barber, Harry Barber



For the task we need to set four variables according to the configuration entries as follows:

fullname = Foo Barber
favouritefruit = banana
needspeeling = true
seedsremoved = false


We also have an option that contains multiple parameters. These may be stored in an array.

 otherfamily(1) = Rhu Barber
 otherfamily(2) = Harry Barber


Related tasks
 Update a configuration file

",#Go,Go,"package config
 
import (
	""errors""
	""io""
	""fmt""
	""bytes""
	""strings""
	""io/ioutil""
)
 
var (
	ENONE    = errors.New(""Requested value does not exist"")
	EBADTYPE = errors.New(""Requested type and actual type do not match"")
	EBADVAL  = errors.New(""Value and type do not match"")
)
 
type varError struct {
	err error
	n   string
	t   VarType
}
 
func (err *varError) Error() string {
	return fmt.Sprintf(""%v: (%q, %v)"", err.err, err.n, err.t)
}
 
type VarType int
 
const (
	Bool VarType = 1 + iota
	Array
	String
)
 
func (t VarType) String() string {
	switch t {
	case Bool:
		return ""Bool""
	case Array:
		return ""Array""
	case String:
		return ""String""
	}
 
	panic(""Unknown VarType"")
}
 
type confvar struct {
	Type VarType
	Val  interface{}
}
 
type Config struct {
	m map[string]confvar
}
 
func Parse(r io.Reader) (c *Config, err error) {
	c = new(Config)
	c.m = make(map[string]confvar)
 
	buf, err := ioutil.ReadAll(r)
	if err != nil {
		return
	}
 
	lines := bytes.Split(buf, []byte{'\n'})
 
	for _, line := range lines {
		line = bytes.TrimSpace(line)
		if len(line) == 0 {
			continue
		}
		switch line[0] {
		case '#', ';':
			continue
		}
 
		parts := bytes.SplitN(line, []byte{' '}, 2)
		nam := string(bytes.ToLower(parts[0]))
 
		if len(parts) == 1 {
			c.m[nam] = confvar{Bool, true}
			continue
		}
 
		if strings.Contains(string(parts[1]), "","") {
			tmpB := bytes.Split(parts[1], []byte{','})
			for i := range tmpB {
				tmpB[i] = bytes.TrimSpace(tmpB[i])
			}
			tmpS := make([]string, 0, len(tmpB))
			for i := range tmpB {
				tmpS = append(tmpS, string(tmpB[i]))
			}
 
			c.m[nam] = confvar{Array, tmpS}
			continue
		}
 
		c.m[nam] = confvar{String, string(bytes.TrimSpace(parts[1]))}
	}
 
	return
}
 
func (c *Config) Bool(name string) (bool, error) {
	name = strings.ToLower(name)
 
	if _, ok := c.m[name]; !ok {
		return false, nil
	}
 
	if c.m[name].Type != Bool {
		return false, &varError{EBADTYPE, name, Bool}
	}
 
	v, ok := c.m[name].Val.(bool)
	if !ok {
		return false, &varError{EBADVAL, name, Bool}
	}
	return v, nil
}
 
func (c *Config) Array(name string) ([]string, error) {
	name = strings.ToLower(name)
 
	if _, ok := c.m[name]; !ok {
		return nil, &varError{ENONE, name, Array}
	}
 
	if c.m[name].Type != Array {
		return nil, &varError{EBADTYPE, name, Array}
	}
 
	v, ok := c.m[name].Val.([]string)
	if !ok {
		return nil, &varError{EBADVAL, name, Array}
	}
	return v, nil
}
 
func (c *Config) String(name string) (string, error) {
	name = strings.ToLower(name)
 
	if _, ok := c.m[name]; !ok {
		return """", &varError{ENONE, name, String}
	}
 
	if c.m[name].Type != String {
		return """", &varError{EBADTYPE, name, String}
	}
 
	v, ok := c.m[name].Val.(string)
	if !ok {
		return """", &varError{EBADVAL, name, String}
	}
 
	return v, nil
}",2771,160
24706,http://rosettacode.org/wiki/Random_numbers,Random numbers,"Task

Generate a collection filled with   1000   normally distributed random (or pseudo-random) numbers
with a mean of   1.0   and a   standard deviation   of   0.5



Many libraries only generate uniformly distributed random numbers. If so, you may use one of these algorithms.



Related task

   Standard deviation

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/rand""
    ""strings""
    ""time""
)
 
const mean = 1.0
const stdv = .5
const n = 1000
 
func main() {
    var list [n]float64
    rand.Seed(time.Now().UnixNano())
    for i := range list {
        list[i] = mean + stdv*rand.NormFloat64()
    }
    // show computed mean and stdv of list
    var s, sq float64
    for _, v := range list {
        s += v
    }
    cm := s / n
    for _, v := range list {
        d := v - cm
        sq += d * d
    }
    fmt.Printf(""mean %.3f, stdv %.3f\n"", cm, math.Sqrt(sq/(n-1)))
    // show histogram by hdiv divisions per stdv over +/-hrange stdv
    const hdiv = 3
    const hrange = 2
    var h [1 + 2*hrange*hdiv]int
    for _, v := range list {
        bin := hrange*hdiv + int(math.Floor((v-mean)/stdv*hdiv+.5))
        if bin >= 0 && bin < len(h) {
            h[bin]++
        }
    }
    const hscale = 10
    for _, c := range h {
        fmt.Println(strings.Repeat(""*"", (c+hscale/2)/hscale))
    }
}",999,46
24765,http://rosettacode.org/wiki/Range_expansion,Range expansion,"A format for expressing an ordered list of integers is to use a comma separated list of either

 individual integers
 Or a range of integers denoted by the starting integer separated from the end integer in the range by a dash, '-'. (The range includes all integers in the interval including both endpoints)
 The range syntax is to be used only for, and for every range that expands to more than two values.
Example

The list of integers:

 -6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20
Is accurately expressed by the range expression:

 -6,-3-1,3-5,7-11,14,15,17-20
(And vice-versa).



Task

Expand the range description:

  -6,-3--1,3-5,7-11,14,15,17-20 

Note that the second element above,
is the range from minus 3 to minus 1. 



Related task

   Range extraction

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
    ""strings""
)
 
const input = ""-6,-3--1,3-5,7-11,14,15,17-20""
 
func main() {
    fmt.Println(""range:"", input)
    var r []int
    var last int
    for _, part := range strings.Split(input, "","") {
        if i := strings.Index(part[1:], ""-""); i == -1 {
            n, err := strconv.Atoi(part)
            if err != nil {
                fmt.Println(err)
                return
            }
            if len(r) > 0 {
                if last == n {
                    fmt.Println(""duplicate value:"", n)
                    return
                } else if last > n {
                    fmt.Println(""values not ordered:"", last, "">"", n)
                    return
                }
            }
            r = append(r, n)
            last = n
        } else {
            n1, err := strconv.Atoi(part[:i+1])
            if err != nil {
                fmt.Println(err)
                return
            }
            n2, err := strconv.Atoi(part[i+2:])
            if err != nil {
                fmt.Println(err)
                return
            }
            if n2 < n1+2 {
                fmt.Println(""invalid range:"", part)
                return
            }
            if len(r) > 0 {
                if last == n1 {
                    fmt.Println(""duplicate value:"", n1)
                    return
                } else if last > n1 {
                    fmt.Println(""values not ordered:"", last, "">"", n1)
                    return
                }
            }
            for i = n1; i <= n2; i++ {
                r = append(r, i)
            }
            last = n2
        }
    }
    fmt.Println(""expanded:"", r)
}",1690,64
24790,http://rosettacode.org/wiki/Read_a_file_line_by_line,Read a file line by line,"Read a file one line at a time,
as opposed to reading the entire file at once.



Related tasks

 Read a file character by character
 Input loop.

",#Go,Go,"package main
 
import (
	""bufio""
	""fmt""
	""log""
	""os""
)
 
func init() {
	log.SetFlags(log.Lshortfile)
}
 
func main() {
	// Open an input file, exit on error.
	inputFile, err := os.Open(""byline.go"")
	if err != nil {
		log.Fatal(""Error opening input file:"", err)
	}
 
	// Closes the file when we leave the scope of the current function,
	// this makes sure we never forget to close the file if the
	// function can exit in multiple places.
	defer inputFile.Close()
 
	scanner := bufio.NewScanner(inputFile)
 
	// scanner.Scan() advances to the next token returning false if an error was encountered
	for scanner.Scan() {
		fmt.Println(scanner.Text())
	}
 
	// When finished scanning if any error other than io.EOF occured
	// it will be returned by scanner.Err().
	if err := scanner.Err(); err != nil {
		log.Fatal(scanner.Err())
	}
}
 ",834,39
24820,http://rosettacode.org/wiki/Queue/Usage,Queue/Usage,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
 Illustration of FIFO behavior
Task

Create a queue data structure and demonstrate its operations.

(For implementations of queues, see the FIFO task.)



Operations:

   push       (aka enqueue) - add element
   pop         (aka dequeue) - pop first element
   empty     - return truth value when empty


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#Go,Go,"package main
 
import (
    ""fmt""
    ""queue""
)
 
func main() {
    q := new(queue.Queue)
    fmt.Println(""empty?"", q.Empty())
 
    x := ""black""
    fmt.Println(""push"", x)
    q.Push(x)
 
    fmt.Println(""empty?"", q.Empty())
    r, ok := q.Pop()
    if ok {
        fmt.Println(r, ""popped"")
    } else {
        fmt.Println(""pop failed"")
    }
 
    var n int
    for _, x := range []string{""blue"", ""red"", ""green""} {
        fmt.Println(""pushing"", x)
        q.Push(x)
        n++
    }
 
    for i := 0; i < n; i++ {
        r, ok := q.Pop()
        if ok {
            fmt.Println(r, ""popped"")
        } else {
            fmt.Println(""pop failed"")
        }
    }
}",669,39
24843,http://rosettacode.org/wiki/Quickselect_algorithm,Quickselect algorithm,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Use the quickselect algorithm on the vector

 [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]
To show the first, second, third, ... up to the tenth largest member of the vector, in order, here on this page.

 Note: Quicksort has a separate task. 

",#Go,Go,"package main
 
import ""fmt""
 
func quickselect(list []int, k int) int {
    for {
        // partition
        px := len(list) / 2
        pv := list[px]
        last := len(list) - 1
        list[px], list[last] = list[last], list[px]
        i := 0
        for j := 0; j < last; j++ {
            if list[j] < pv {
                list[i], list[j] = list[j], list[i]
                i++
            }
        }
        // select
        if i == k {
            return pv
        }
        if k < i {
            list = list[:i]
        } else {
            list[i], list[last] = list[last], list[i]
            list = list[i+1:]
            k -= i + 1
        }
    }
}
 
func main() {
    for i := 0; ; i++ {
        v := []int{9, 8, 7, 6, 5, 0, 1, 2, 3, 4}
        if i == len(v) {
            return
        }
        fmt.Println(quickselect(v, i))
    }
}",861,41
24933,http://rosettacode.org/wiki/Range_extraction,Range extraction,"A format for expressing an ordered list of integers is to use a comma separated list of either

 individual integers
 Or a range of integers denoted by the starting integer separated from the end integer in the range by a dash, '-'. (The range includes all integers in the interval including both endpoints)
 The range syntax is to be used only for, and for every range that expands to more than two values.
Example

The list of integers:

 -6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20
Is accurately expressed by the range expression:

 -6,-3-1,3-5,7-11,14,15,17-20
(And vice-versa).

Task

 Create a function that takes a list of integers in increasing order and returns a correctly formatted string in the range format. 
 Use the function to compute and print the range formatted version of the following ordered list of integers. (The correct answer is: 0-2,4,6-8,11,12,14-25,27-33,35-39).


    0,  1,  2,  4,  6,  7,  8, 11, 12, 14,
   15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
   25, 27, 28, 29, 30, 31, 32, 33, 35, 36,
   37, 38, 39

 Show the output of your program.


Related task

   Range expansion

",#Go,Go,"package main
 
import (
    ""errors""
    ""fmt""
    ""strconv""
    ""strings""
)
 
func main() {
    rf, err := rangeFormat([]int{
        0, 1, 2, 4, 6, 7, 8, 11, 12, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
        25, 27, 28, 29, 30, 31, 32, 33, 35, 36,
        37, 38, 39,
    })
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(""range format:"", rf)
}
 
func rangeFormat(a []int) (string, error) {
    if len(a) == 0 {
        return """", nil
    }
    var parts []string
    for n1 := 0; ; {
        n2 := n1 + 1
        for n2 < len(a) && a[n2] == a[n2-1]+1 {
            n2++
        }
        s := strconv.Itoa(a[n1])
        if n2 == n1+2 {
            s += "","" + strconv.Itoa(a[n2-1])
        } else if n2 > n1+2 {
            s += ""-"" + strconv.Itoa(a[n2-1])
        }
        parts = append(parts, s)
        if n2 == len(a) {
            break
        }
        if a[n2] == a[n2-1] {
            return """", errors.New(fmt.Sprintf(
                ""sequence repeats value %d"", a[n2]))
        }
        if a[n2] < a[n2-1] {
            return """", errors.New(fmt.Sprintf(
                ""sequence not ordered: %d < %d"", a[n2], a[n2-1]))
        }
        n1 = n2
    }
    return strings.Join(parts, "",""), nil
}",1262,55
25043,http://rosettacode.org/wiki/Quaternion_type,Quaternion type,"Quaternions   are an extension of the idea of   complex numbers.

A complex number has a real and complex part,   sometimes written as     a + bi,  

where     a     and     b     stand for real numbers, and     i     stands for the square root of minus 1.

An example of a complex number might be     -3 + 2i,    

where the real part,     a     is     -3.0     and the complex part,     b     is     +2.0.  

A quaternion has one real part and three imaginary parts,     i,       j,     and     k.  

A quaternion might be written as     a + bi + cj + dk.  

In the quaternion numbering system:

     i∙i = j∙j = k∙k = i∙j∙k = -1,         or more simply,
     ii  = jj  = kk  = ijk   = -1.  
The order of multiplication is important, as, in general, for two quaternions:

     q1     and     q2:         q1q2 ≠ q2q1.  
An example of a quaternion might be     1 +2i +3j +4k  

There is a list form of notation where just the numbers are shown and the imaginary multipliers    i,       j,     and     k     are assumed by position.

So the example above would be written as     (1, 2, 3, 4)  



Task

Given the three quaternions and their components: 

   q  = (1, 2, 3, 4) = (a,  b,  c,  d)
   q1 = (2, 3, 4, 5) = (a1, b1, c1, d1)
   q2 = (3, 4, 5, 6) = (a2, b2, c2, d2) 

And a wholly real number     r = 7.  



Create functions   (or classes)   to perform simple maths with quaternions including computing:

 The norm of a quaternion: 




=



a

2


+

b

2


+

c

2


+

d

2






{\displaystyle ={\sqrt {a^{2}+b^{2}+c^{2}+d^{2}}}}

 
 The negative of a quaternion: 
   = (-a, -b, -c, -d)  
 The conjugate of a quaternion: 
   = ( a, -b, -c, -d)  
 Addition of a real number     r     and a quaternion     q:  
  r + q = q + r = (a+r, b, c, d)  
 Addition of two quaternions: 
   q1 + q2 = (a1+a2, b1+b2, c1+c2, d1+d2)  
 Multiplication of a real number and a quaternion: 
   qr = rq = (ar, br, cr, dr)  
 Multiplication of two quaternions     q1     and   q2     is given by: 
   ( a1a2 − b1b2 − c1c2 − d1d2, 
   a1b2 + b1a2 + c1d2 − d1c2, 
   a1c2 − b1d2 + c1a2 + d1b2, 
   a1d2 + b1c2 − c1b2 + d1a2 )  
 Show that, for the two quaternions     q1     and     q2: 
 q1q2 ≠ q2q1  


If a language has built-in support for quaternions, then use it.



C.f.

   Vector products
   On Quaternions;   or on a new System of Imaginaries in Algebra.   By Sir William Rowan Hamilton LL.D, P.R.I.A., F.R.A.S., Hon. M. R. Soc. Ed. and Dub., Hon. or Corr. M. of the Royal or Imperial Academies of St. Petersburgh, Berlin, Turin and Paris, Member of the American Academy of Arts and Sciences, and of other Scientific Societies at Home and Abroad, Andrews' Prof. of Astronomy in the University of Dublin, and Royal Astronomer of Ireland.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
type qtn struct {
    r, i, j, k float64
}
 
var (
    q  = &qtn{1, 2, 3, 4}
    q1 = &qtn{2, 3, 4, 5}
    q2 = &qtn{3, 4, 5, 6}
 
    r  float64 = 7
)
 
func main() {
    fmt.Println(""Inputs"")
    fmt.Println(""q:"", q)
    fmt.Println(""q1:"", q1)
    fmt.Println(""q2:"", q2)
    fmt.Println(""r:"", r)
 
    var qr qtn
    fmt.Println(""\nFunctions"")
    fmt.Println(""q.norm():"", q.norm())
    fmt.Println(""neg(q):"", qr.neg(q))
    fmt.Println(""conj(q):"", qr.conj(q))
    fmt.Println(""addF(q, r):"", qr.addF(q, r))
    fmt.Println(""addQ(q1, q2):"", qr.addQ(q1, q2))
    fmt.Println(""mulF(q, r):"", qr.mulF(q, r))
    fmt.Println(""mulQ(q1, q2):"", qr.mulQ(q1, q2))
    fmt.Println(""mulQ(q2, q1):"", qr.mulQ(q2, q1))
}
 
func (q *qtn) String() string {
    return fmt.Sprintf(""(%g, %g, %g, %g)"", q.r, q.i, q.j, q.k)
}
 
func (q *qtn) norm() float64 {
    return math.Sqrt(q.r*q.r + q.i*q.i + q.j*q.j + q.k*q.k)
}
 
func (z *qtn) neg(q *qtn) *qtn {
    z.r, z.i, z.j, z.k = -q.r, -q.i, -q.j, -q.k
    return z
}
 
func (z *qtn) conj(q *qtn) *qtn {
    z.r, z.i, z.j, z.k = q.r, -q.i, -q.j, -q.k
    return z
}
 
func (z *qtn) addF(q *qtn, r float64) *qtn {
    z.r, z.i, z.j, z.k = q.r+r, q.i, q.j, q.k
    return z
}
 
func (z *qtn) addQ(q1, q2 *qtn) *qtn {
    z.r, z.i, z.j, z.k = q1.r+q2.r, q1.i+q2.i, q1.j+q2.j, q1.k+q2.k
    return z
}
 
func (z *qtn) mulF(q *qtn, r float64) *qtn {
    z.r, z.i, z.j, z.k = q.r*r, q.i*r, q.j*r, q.k*r
    return z
}
 
func (z *qtn) mulQ(q1, q2 *qtn) *qtn {
    z.r, z.i, z.j, z.k =
        q1.r*q2.r-q1.i*q2.i-q1.j*q2.j-q1.k*q2.k,
        q1.r*q2.i+q1.i*q2.r+q1.j*q2.k-q1.k*q2.j,
        q1.r*q2.j-q1.i*q2.k+q1.j*q2.r+q1.k*q2.i,
        q1.r*q2.k+q1.i*q2.j-q1.j*q2.i+q1.k*q2.r
    return z
}",1767,79
25163,http://rosettacode.org/wiki/Queue/Definition,Queue/Definition,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
 Illustration of FIFO behavior
Task

Implement a FIFO queue.

Elements are added at one side and popped from the other in the order of insertion.



Operations:

   push   (aka enqueue)    - add element
   pop     (aka dequeue)    - pop first element
   empty                             - return truth value when empty


Errors:

   handle the error of trying to pop from an empty queue (behavior depends on the language and platform)


See

   Queue/Usage   for the built-in FIFO or queue of your language or standard library.


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#Go,Go," 
package queue
 
// int queue
// the zero object is a valid queue ready to be used.
// items are pushed at tail, popped at head.
// tail = -1 means queue is full
type Queue struct {
    b []string
    head, tail int
}
 
func (q *Queue) Push(x string) {
    switch {
    // buffer full. reallocate.
    case q.tail < 0:
        next := len(q.b)
        bigger := make([]string, 2*next)
        copy(bigger[copy(bigger, q.b[q.head:]):], q.b[:q.head])
        bigger[next] = x
        q.b, q.head, q.tail = bigger, 0, next+1
    // zero object. make initial allocation.
    case len(q.b) == 0:
        q.b, q.head, q.tail = make([]string, 4), 0 ,1
        q.b[0] = x
    // normal case
    default:
        q.b[q.tail] = x
        q.tail++
        if q.tail == len(q.b) {
            q.tail = 0
        }
        if q.tail == q.head {
            q.tail = -1
        }
    }
}
 
func (q *Queue) Pop() (string, bool) {
    if q.head == q.tail {
        return """", false
    }
    r := q.b[q.head]
    if q.tail == -1 {
        q.tail = q.head
    }
    q.head++
    if q.head == len(q.b) {
        q.head = 0
    }
    return r, true
}
 
func (q *Queue) Empty() bool {
    return q.head == q.tail
}
 ",1197,57
25402,http://rosettacode.org/wiki/Quine,Quine,"A quine is a self-referential program that can,
without any external access, output its own source.



A   quine   (named after Willard Van Orman Quine)   is also known as:

   self-reproducing automata   (1972)
   self-replicating program         or   self-replicating computer program
   self-reproducing program      or   self-reproducing computer program
   self-copying program             or   self-copying computer program


It is named after the philosopher and logician
who studied self-reference and quoting in natural language,
as for example in the paradox ""'Yields falsehood when preceded by its quotation' yields falsehood when preceded by its quotation.""

""Source"" has one of two meanings. It can refer to the text-based program source.
For languages in which program source is represented as a data structure, ""source"" may refer to the data structure: quines in these languages fall into two categories: programs which print a textual representation of themselves, or expressions which evaluate to a data structure which is equivalent to that expression.

The usual way to code a quine works similarly to this paradox: The program consists of two identical parts, once as plain code and once quoted in some way (for example, as a character string, or a literal data structure). The plain code then accesses the quoted code and prints it out twice, once unquoted and once with the proper quotation marks added. Often, the plain code and the quoted code have to be nested.



Task

Write a program that outputs its own source code in this way. If the language allows it, you may add a variant that accesses the code directly. You are not allowed to read any external files with the source code. The program should also contain some sort of self-reference, so constant expressions which return their own value which some top-level interpreter will print out. Empty programs producing no output are not allowed.

There are several difficulties that one runs into when writing a quine, mostly dealing with quoting:

 Part of the code usually needs to be stored as a string or structural literal in the language, which needs to be quoted somehow. However, including quotation marks in the string literal itself would be troublesome because it requires them to be escaped, which then necessitates the escaping character (e.g. a backslash) in the string, which itself usually needs to be escaped, and so on.
 Some languages have a function for getting the ""source code representation"" of a string (i.e. adds quotation marks, etc.); in these languages, this can be used to circumvent the quoting problem.
 Another solution is to construct the quote character from its character code, without having to write the quote character itself. Then the character is inserted into the string at the appropriate places. The ASCII code for double-quote is 34, and for single-quote is 39.
 Newlines in the program may have to be reproduced as newlines in the string, which usually requires some kind of escape sequence (e.g. ""\n""). This causes the same problem as above, where the escaping character needs to itself be escaped, etc.
 If the language has a way of getting the ""source code representation"", it usually handles the escaping of characters, so this is not a problem.
 Some languages allow you to have a string literal that spans multiple lines, which embeds the newlines into the string without escaping.
 Write the entire program on one line, for free-form languages (as you can see for some of the solutions here, they run off the edge of the screen), thus removing the need for newlines. However, this may be unacceptable as some languages require a newline at the end of the file; and otherwise it is still generally good style to have a newline at the end of a file. (The task is not clear on whether a newline is required at the end of the file.) Some languages have a print statement that appends a newline; which solves the newline-at-the-end issue; but others do not.

Next to the Quines presented here, many other versions can be found on the Quine page.



Related task

   print itself.

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
	a := ""package main\n\nimport \""fmt\""\n\nfunc main() {\n\ta := %q\n\tfmt.Printf(a, a)\n}\n""
	fmt.Printf(a, a)
}",155,8
25576,http://rosettacode.org/wiki/Pseudo-random_numbers/Xorshift_star,Pseudo-random numbers/Xorshift star,"Some definitions to help in the explanation

Floor operation

https://en.wikipedia.org/wiki/Floor_and_ceiling_functions

Greatest integer less than or equal to a real number.
Bitwise Logical shift operators (c-inspired)

https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts

Binary bits of value shifted left or right, with zero bits shifted in where appropriate. 
Examples are shown for 8 bit binary numbers; most significant bit to the left.
 << Logical shift left by given number of bits.
E.g Binary 00110101 << 2 == Binary 11010100
 >> Logical shift right by given number of bits.
E.g Binary 00110101 >> 2 == Binary 00001101
^ Bitwise exclusive-or operator
https://en.wikipedia.org/wiki/Exclusive_or
Bitwise comparison for if bits differ
E.g Binary 00110101 ^ Binary 00110011 == Binary 00000110
Xorshift_star Generator (pseudo-code)

   /* Let u64 denote an unsigned 64 bit integer type. */
   /* Let u32 denote an unsigned 32 bit integer type. */



   class Xorshift_star
       u64 state       /* Must be seeded to non-zero initial value */
       u64 const = HEX '2545F4914F6CDD1D'

       method seed(u64 num):
           state =  num
       end method
       
       method next_int():
           u64 x = state
           x = x ^ (x >> 12)
           x = x ^ (x << 25)
           x = x ^ (x >> 27)
           state = x
           u32 answer = ((x * const) >> 32)
           
           return answer
       end method
       
       method next_float():
           return float next_int() / (1 << 32)
       end method
       
   end class
       

Xorshift use

   random_gen = instance Xorshift_star
   random_gen.seed(1234567)
   print(random_gen.next_int())   /* 3540625527 */
   print(random_gen.next_int())   /* 2750739987 */
   print(random_gen.next_int())   /* 4037983143 */
   print(random_gen.next_int())   /* 1993361440 */
   print(random_gen.next_int())   /* 3809424708 */

Task

 Generate a class/set of functions that generates pseudo-random
numbers as shown above.

 Show that the first five integers genrated with the seed 1234567
are as shown above

 Show that for an initial seed of 987654321, the counts of 100_000 repetitions of
   floor(random_gen.next_float() * 5)

Is as follows:
   0: 20103, 1: 19922, 2: 19937, 3: 20031, 4: 20007

 Show your output here, on this page.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
const CONST = 0x2545F4914F6CDD1D
 
type XorshiftStar struct{ state uint64 }
 
func XorshiftStarNew(state uint64) *XorshiftStar { return &XorshiftStar{state} }
 
func (xor *XorshiftStar) seed(state uint64) { xor.state = state }
 
func (xor *XorshiftStar) nextInt() uint32 {
    x := xor.state
    x = x ^ (x >> 12)
    x = x ^ (x << 25)
    x = x ^ (x >> 27)
    xor.state = x
    return uint32((x * CONST) >> 32)
}
 
func (xor *XorshiftStar) nextFloat() float64 {
    return float64(xor.nextInt()) / (1 << 32)
}
 
func main() {
    randomGen := XorshiftStarNew(1234567)
    for i := 0; i < 5; i++ {
        fmt.Println(randomGen.nextInt())
    }
 
    var counts [5]int
    randomGen.seed(987654321)
    for i := 0; i < 1e5; i++ {
        j := int(math.Floor(randomGen.nextFloat() * 5))
        counts[j]++
    }
    fmt.Println(""\nThe counts for 100,000 repetitions are:"")
    for i := 0; i < 5; i++ {
        fmt.Printf(""  %d : %d\n"", i, counts[i])
    }
}",1007,45
25630,http://rosettacode.org/wiki/Pseudo-random_numbers/Middle-square_method,Pseudo-random numbers/Middle-square method,"Middle-square_method Generator 
 The Method

To generate a sequence of n-digit pseudorandom numbers, an n-digit starting value is created and squared, producing a 2n-digit number. If the result has fewer than 2n digits, leading zeroes are added to compensate. The middle n digits of the result would be the next number in the sequence and returned as the result. This process is then repeated to generate more numbers.

 Pseudo code

var seed = 675248
function random()
    var s = str(seed * seed) 'str: turn a number into string
    do while not len(s) = 12
        s = ""0"" + s          'add zeroes before the string
    end do
    seed = val(mid(s, 4, 6)) 'mid: string variable, start, length
                             'val: turn a string into number
    return seed
end function

 Middle-square method use

for i = 1 to 5
    print random()
end for

Task

 Generate a class/set of functions that generates pseudo-random
numbers (6 digits) as shown above.

 Show the first five integers generated with the seed 675248 as shown above.
 Show your output here, on this page.",#Go,Go,"package main
 
import ""fmt""
 
func random(seed int) int {
    return seed * seed / 1e3 % 1e6
}
 
func main() {
    seed := 675248
    for i := 1; i <= 5; i++ {
        seed = random(seed)
        fmt.Println(seed)
    }
}",221,15
25635,http://rosettacode.org/wiki/Pseudo-random_numbers/PCG32,Pseudo-random numbers/PCG32,"Some definitions to help in the explanation

Floor operation

https://en.wikipedia.org/wiki/Floor_and_ceiling_functions

Greatest integer less than or equal to a real number.
Bitwise Logical shift operators (c-inspired)

https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts

Binary bits of value shifted left or right, with zero bits shifted in where appropriate. 
Examples are shown for 8 bit binary numbers; most significant bit to the left.
 << Logical shift left by given number of bits.
E.g Binary 00110101 << 2 == Binary 11010100
 >> Logical shift right by given number of bits.
E.g Binary 00110101 >> 2 == Binary 00001101
^ Bitwise exclusive-or operator
https://en.wikipedia.org/wiki/Exclusive_or
Bitwise comparison for if bits differ
E.g Binary 00110101 ^ Binary 00110011 == Binary 00000110
| Bitwise or operator
https://en.wikipedia.org/wiki/Bitwise_operation#OR
Bitwise comparison gives 1 if any of corresponding bits are 1
E.g Binary 00110101 | Binary 00110011 == Binary 00110111


PCG32 Generator (pseudo-code)

PCG32 has two unsigned 64-bit integers of internal state:

 state: All 2**64 values may be attained.
 sequence: Determines which of 2**63 sequences that state iterates through. (Once set together with state at time of seeding will stay constant for this generators lifetime).
Values of sequence allow 2**63 different sequences of random numbers from the same state.

The algorithm is given 2 U64 inputs called seed_state, and seed_sequence. The algorithm proceeds in accordance with the following pseudocode:-

const N<-U64 6364136223846793005
const inc<-U64 (seed_sequence << 1) | 1
state<-U64 ((inc+seed_state)*N+inc
do forever
  xs<-U32 (((state>>18)^state)>>27)
  rot<-INT (state>>59)
  OUTPUT U32 (xs>>rot)|(xs<<((-rot)&31))
  state<-state*N+inc
end do

Note that this an anamorphism – dual to catamorphism, and encoded in some languages as a general higher-order `unfold` function, dual to `fold` or `reduce`.

Task

 Generate a class/set of functions that generates pseudo-random
numbers using the above.

 Show that the first five integers generated with the seed 42, 54
are: 2707161783 2068313097 3122475824 2211639955 3215226955



 Show that for an initial seed of 987654321, 1 the counts of 100_000 repetitions of
   floor(random_gen.next_float() * 5)

Is as follows:
   0: 20049, 1: 20022, 2: 20115, 3: 19809, 4: 20005

 Show your output here, on this page.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
const CONST = 6364136223846793005
 
type Pcg32 struct{ state, inc uint64 }
 
func Pcg32New() *Pcg32 { return &Pcg32{0x853c49e6748fea9b, 0xda3e39cb94b95bdb} }
 
func (pcg *Pcg32) seed(seedState, seedSequence uint64) {
    pcg.state = 0
    pcg.inc = (seedSequence << 1) | 1
    pcg.nextInt()
    pcg.state = pcg.state + seedState
    pcg.nextInt()
}
 
func (pcg *Pcg32) nextInt() uint32 {
    old := pcg.state
    pcg.state = old*CONST + pcg.inc
    pcgshifted := uint32(((old >> 18) ^ old) >> 27)
    rot := uint32(old >> 59)
    return (pcgshifted >> rot) | (pcgshifted << ((-rot) & 31))
}
 
func (pcg *Pcg32) nextFloat() float64 {
    return float64(pcg.nextInt()) / (1 << 32)
}
 
func main() {
    randomGen := Pcg32New()
    randomGen.seed(42, 54)
    for i := 0; i < 5; i++ {
        fmt.Println(randomGen.nextInt())
    }
 
    var counts [5]int
    randomGen.seed(987654321, 1)
    for i := 0; i < 1e5; i++ {
        j := int(math.Floor(randomGen.nextFloat() * 5))
        counts[j]++
    }
    fmt.Println(""\nThe counts for 100,000 repetitions are:"")
    for i := 0; i < 5; i++ {
        fmt.Printf(""  %d : %d\n"", i, counts[i])
    }
}",1192,51
25639,http://rosettacode.org/wiki/Pseudo-random_numbers/Splitmix64,Pseudo-random numbers/Splitmix64,"Splitmix64 is the default pseudo-random number generator algorithm in Java and is included / available in many other languages. It uses a fairly simple algorithm that, though it is considered to be poor for cryptographic purposes, is very fast to calculate, and is ""good enough"" for many random number needs. It passes several fairly rigorous PRNG ""fitness"" tests that some more complex algorithms fail.

Splitmix64 is not recommended for demanding random number requirements, but is often used to calculate initial states for other more complex pseudo-random number generators.

The ""standard"" splitmix64 maintains one 64 bit state variable and returns 64 bits of random data with each call.

Basic pseudocode algorithm:

    uint64 state                                  /* The state can be seeded with any (upto) 64 bit integer value. */

    next_int() {
        state += 0x9e3779b97f4a7c15               /* increment the state variable */
        uint64 z = state                          /* copy the state to a working variable */
        z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9  /* xor the variable with the variable right bit shifted 30 then multiply by a constant */
        z = (z ^ (z >> 27)) * 0x94d049bb133111eb  /* xor the variable with the variable right bit shifted 27 then multiply by a constant */
        return z ^ (z >> 31)                      /* return the variable xored with itself right bit shifted 31 */
    }

    next_float() {
        return next_int() / (1 << 64)             /* divide by 2^64 to return a value between 0 and 1 */
    }
The returned value should hold 64 bits of numeric data. If your language does not support unsigned 64 bit integers directly you may need to apply appropriate bitmasks during bitwise operations.

In keeping with the general layout of several recent pseudo-random number tasks:



 Task

 Write a class or set of functions that generates pseudo-random numbers using splitmix64.
 Show the first five integers generated using the seed 1234567.
    6457827717110365317
    3203168211198807973
    9817491932198370423
    4593380528125082431
   16408922859458223821
  

 Show that for an initial seed of 987654321, the counts of 100_000 repetitions of floor next_float() * 5 is as follows:
   0: 20027, 1: 19892, 2: 20073, 3: 19978, 4: 20030  

 Show your output here, on this page.


 See also

 Java docs for splitmix64
 Public domain C code used in many PRNG implementations; by Sebastiano Vigna


 Related tasks

 Pseudo-random numbers/Combined recursive generator MRG32k3a‎‎
 Pseudo-random numbers/PCG32‎‎
 Pseudo-random_numbers/Xorshift_star

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
type Splitmix64 struct{ state uint64 }
 
func Splitmix64New(state uint64) *Splitmix64 { return &Splitmix64{state} }
 
func (sm64 *Splitmix64) nextInt() uint64 {
    sm64.state += 0x9e3779b97f4a7c15
    z := sm64.state
    z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9
    z = (z ^ (z >> 27)) * 0x94d049bb133111eb
    return z ^ (z >> 31)
}
 
func (sm64 *Splitmix64) nextFloat() float64 {
    return float64(sm64.nextInt()) / (1 << 64)
}
 
func main() {
    randomGen := Splitmix64New(1234567)
    for i := 0; i < 5; i++ {
        fmt.Println(randomGen.nextInt())
    }
 
    var counts [5]int
    randomGen = Splitmix64New(987654321)
    for i := 0; i < 1e5; i++ {
        j := int(math.Floor(randomGen.nextFloat() * 5))
        counts[j]++
    }
    fmt.Println(""\nThe counts for 100,000 repetitions are:"")
    for i := 0; i < 5; i++ {
        fmt.Printf(""  %d : %d\n"", i, counts[i])
    }
}",936,40
25668,http://rosettacode.org/wiki/Pythagorean_quadruples,Pythagorean quadruples,"

One form of   Pythagorean quadruples   is   (for positive integers   a,   b,   c,   and   d):



    a2   +   b2   +   c2     =     d2 


An example:

    22   +   32   +   62     =     72 
 which is:
    4    +   9    +   36     =     49 


Task

For positive integers up   2,200   (inclusive),   for all values of   a,  
b,   c,   and   d,

find   (and show here)   those values of   d   that   can't   be represented.

Show the values of   d   on one line of output   (optionally with a title).



Related tasks

   Euler's sum of powers conjecture. 
   Pythagorean triples.


Reference

   the Wikipedia article:   Pythagorean quadruple.

",#Go,Go,"package main
 
import ""fmt""
 
const (
    N = 2200
    N2 = N * N * 2
)
 
func main() {
    s  := 3 
    var s1, s2 int    
    var r  [N + 1]bool
    var ab [N2 + 1]bool
 
    for a := 1; a <= N; a++ {
        a2 := a * a
        for b := a; b <= N; b++ {
            ab[a2 + b * b] = true
        }
    }
 
    for c := 1; c <= N; c++ {
        s1 = s
        s += 2
        s2 = s
        for d := c + 1; d <= N; d++ {
            if ab[s1] {
                r[d] = true
            }
            s1 += s2
            s2 += 2
        }
    }
 
    for d := 1; d <= N; d++ {
        if !r[d] {
            fmt.Printf(""%d "", d)
        }       
    }
    fmt.Println()
}",671,42
25669,http://rosettacode.org/wiki/Pythagoras_tree,Pythagoras tree,"
The Pythagoras tree is a fractal tree constructed from squares. It is named after Pythagoras because each triple of touching squares encloses a right triangle, in a configuration traditionally used to represent the Pythagorean theorem.




Task
Construct a Pythagoras tree of order 7 using only vectors (no rotation or trigonometric functions).




Related tasks
 Fractal tree

",#Go,Go,"package main
 
import (
	""image""
	""image/color""
	""image/draw""
	""image/png""
	""log""
	""os""
)
 
const (
	width, height = 800, 600
	maxDepth      = 11                    // how far to recurse, between 1 and 20 is reasonable
	colFactor     = uint8(255 / maxDepth) // adjusts the colour so leaves get greener further out
	fileName      = ""pythagorasTree.png""
)
 
func main() {
	img := image.NewNRGBA(image.Rect(0, 0, width, height)) // create new image
	bg := image.NewUniform(color.RGBA{255, 255, 255, 255}) // prepare white for background
	draw.Draw(img, img.Bounds(), bg, image.ZP, draw.Src)   // fill the background
 
	drawSquares(340, 550, 460, 550, img, 0) // start off near the bottom of the image
 
	imgFile, err := os.Create(fileName)
	if err != nil {
		log.Fatal(err)
	}
	defer imgFile.Close()
	if err := png.Encode(imgFile, img); err != nil {
		imgFile.Close()
		log.Fatal(err)
	}
}
 
func drawSquares(ax, ay, bx, by int, img *image.NRGBA, depth int) {
	if depth > maxDepth {
		return
	}
	dx, dy := bx-ax, ay-by
	x3, y3 := bx-dy, by-dx
	x4, y4 := ax-dy, ay-dx
	x5, y5 := x4+(dx-dy)/2, y4-(dx+dy)/2
	col := color.RGBA{0, uint8(depth) * colFactor, 0, 255}
	drawLine(ax, ay, bx, by, img, col)
	drawLine(bx, by, x3, y3, img, col)
	drawLine(x3, y3, x4, y4, img, col)
	drawLine(x4, y4, ax, ay, img, col)
	drawSquares(x4, y4, x5, y5, img, depth+1)
	drawSquares(x5, y5, x3, y3, img, depth+1)
}
 
func drawLine(x0, y0, x1, y1 int, img *image.NRGBA, col color.RGBA) {
	dx := abs(x1 - x0)
	dy := abs(y1 - y0)
	var sx, sy int = -1, -1
	if x0 < x1 {
		sx = 1
	}
	if y0 < y1 {
		sy = 1
	}
	err := dx - dy
	for {
		img.Set(x0, y0, col)
		if x0 == x1 && y0 == y1 {
			break
		}
		e2 := 2 * err
		if e2 > -dy {
			err -= dy
			x0 += sx
		}
		if e2 < dx {
			err += dx
			y0 += sy
		}
	}
}
func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}",1836,86
25730,http://rosettacode.org/wiki/Pseudo-random_numbers/Combined_recursive_generator_MRG32k3a,Pseudo-random numbers/Combined recursive generator MRG32k3a,"MRG32k3a Combined recursive generator (pseudo-code)

   /* Constants */
   /* First generator */
   a1 = [0, 1403580, -810728]
   m1 = 2**32 - 209
   /* Second Generator */
   a2 = [527612, 0, -1370589]
   m2 = 2**32 - 22853
    
   d = m1 + 1
   
   class MRG32k3a
       x1 = [0, 0, 0]  /* list of three last values of gen #1 */
       x2 = [0, 0, 0]  /* list of three last values of gen #2 */
       
       method seed(u64 seed_state)
           assert seed_state in range >0 and < d 
           x1 = [seed_state, 0, 0]
           x2 = [seed_state, 0, 0]
       end method
           
       method next_int()
           x1i = (a1[0]*x1[0] + a1[1]*x1[1] + a1[2]*x1[2]) mod m1
           x2i = (a2[0]*x2[0] + a2[1]*x2[1] + a2[2]*x2[2]) mod m2
           x1 = [x1i, x1[0], x1[1]]    /* Keep last three */
           x2 = [x2i, x2[0], x2[1]]    /* Keep last three */
           z = (x1i - x2i) % m1
           answer = (z + 1)
           
           return answer
       end method
       
       method next_float():
           return float next_int() / d
       end method
       
   end class


MRG32k3a Use:
   random_gen = instance MRG32k3a
   random_gen.seed(1234567)
   print(random_gen.next_int())   /* 1459213977 */
   print(random_gen.next_int())   /* 2827710106 */
   print(random_gen.next_int())   /* 4245671317 */
   print(random_gen.next_int())   /* 3877608661 */
   print(random_gen.next_int())   /* 2595287583 */
   
       

Task
 Generate a class/set of functions that generates pseudo-random
numbers as shown above.

 Show that the first five integers generated with the seed `1234567`
are as shown above

 Show that for an initial seed of '987654321' the counts of 100_000
repetitions of

   floor(random_gen.next_float() * 5)

Is as follows:

   0: 20002, 1: 20060, 2: 19948, 3: 20059, 4: 19931

 Show your output here, on this page.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math""
)
 
var a1 = []int64{0, 1403580, -810728}
var a2 = []int64{527612, 0, -1370589}
 
const m1 = int64((1 << 32) - 209)
const m2 = int64((1 << 32) - 22853)
const d = m1 + 1
 
// Python style modulus
func mod(x, y int64) int64 {
    m := x % y
    if m < 0 {
        if y < 0 {
            return m - y
        } else {
            return m + y
        }
    }
    return m
}
 
type MRG32k3a struct{ x1, x2 [3]int64 }
 
func MRG32k3aNew() *MRG32k3a { return &MRG32k3a{} }
 
func (mrg *MRG32k3a) seed(seedState int64) {
    if seedState <= 0 || seedState >= d {
        log.Fatalf(""Argument must be in the range [0, %d].\n"", d)
    }
    mrg.x1 = [3]int64{seedState, 0, 0}
    mrg.x2 = [3]int64{seedState, 0, 0}
}
 
func (mrg *MRG32k3a) nextInt() int64 {
    x1i := mod(a1[0]*mrg.x1[0]+a1[1]*mrg.x1[1]+a1[2]*mrg.x1[2], m1)
    x2i := mod(a2[0]*mrg.x2[0]+a2[1]*mrg.x2[1]+a2[2]*mrg.x2[2], m2)
    mrg.x1 = [3]int64{x1i, mrg.x1[0], mrg.x1[1]} /* keep last three */
    mrg.x2 = [3]int64{x2i, mrg.x2[0], mrg.x2[1]} /* keep last three */
    return mod(x1i-x2i, m1) + 1
}
 
func (mrg *MRG32k3a) nextFloat() float64 { return float64(mrg.nextInt()) / float64(d) }
 
func main() {
    randomGen := MRG32k3aNew()
    randomGen.seed(1234567)
    for i := 0; i < 5; i++ {
        fmt.Println(randomGen.nextInt())
    }
 
    var counts [5]int
    randomGen.seed(987654321)
    for i := 0; i < 1e5; i++ {
        j := int(math.Floor(randomGen.nextFloat() * 5))
        counts[j]++
    }
    fmt.Println(""\nThe counts for 100,000 repetitions are:"")
    for i := 0; i < 5; i++ {
        fmt.Printf(""  %d : %d\n"", i, counts[i])
    }
}",1669,68
25873,http://rosettacode.org/wiki/QR_decomposition,QR decomposition,"Any rectangular 



m
×
n


{\displaystyle m\times n}

 matrix 





A




{\displaystyle {\mathit {A}}}

 can be decomposed to a product of an orthogonal matrix 





Q




{\displaystyle {\mathit {Q}}}

 and an upper (right) triangular matrix 





R




{\displaystyle {\mathit {R}}}

, as described in QR decomposition.

Task

Demonstrate the QR decomposition on the example matrix from the Wikipedia article:





A
=


(



12


−
51


4




6


167


−
68




−
4


24


−
41



)




{\displaystyle A={\begin{pmatrix}12&-51&4\\6&167&-68\\-4&24&-41\end{pmatrix}}}


and the usage for linear least squares problems on the example from Polynomial regression. The method of Householder reflections should be used:

Method

Multiplying a given vector 





a




{\displaystyle {\mathit {a}}}

, for example the first column of matrix 





A




{\displaystyle {\mathit {A}}}

, with the Householder matrix 





H




{\displaystyle {\mathit {H}}}

, which is given as





H
=
I
−


2


u

T


u



u

u

T




{\displaystyle H=I-{\frac {2}{u^{T}u}}uu^{T}}


reflects 





a




{\displaystyle {\mathit {a}}}

 about a plane given by its normal vector 





u




{\displaystyle {\mathit {u}}}

. When the normal vector of the plane 





u




{\displaystyle {\mathit {u}}}

 is given as





u
=
a
−
∥
a

∥

2




e

1




{\displaystyle u=a-\|a\|_{2}\;e_{1}}


then the transformation reflects 





a




{\displaystyle {\mathit {a}}}

 onto the first standard basis vector






e

1


=
[
1

0

0

.
.
.

]

T




{\displaystyle e_{1}=[1\;0\;0\;...]^{T}}


which means that all entries but the first become zero. To avoid numerical cancellation errors, we should take the opposite sign of 




a

1




{\displaystyle a_{1}}

:





u
=
a
+


sign


(

a

1


)
∥
a

∥

2




e

1




{\displaystyle u=a+{\textrm {sign}}(a_{1})\|a\|_{2}\;e_{1}}


and normalize with respect to the first element:





v
=


u

u

1






{\displaystyle v={\frac {u}{u_{1}}}}


The equation for 



H


{\displaystyle H}

 thus becomes:





H
=
I
−


2


v

T


v



v

v

T




{\displaystyle H=I-{\frac {2}{v^{T}v}}vv^{T}}


or, in another form





H
=
I
−
β
v

v

T




{\displaystyle H=I-\beta vv^{T}}


with





β
=


2


v

T


v





{\displaystyle \beta ={\frac {2}{v^{T}v}}}


Applying 





H




{\displaystyle {\mathit {H}}}

 on 





a




{\displaystyle {\mathit {a}}}

 then gives





H

a
=
−


sign


(

a

1


)

∥
a

∥

2




e

1




{\displaystyle H\;a=-{\textrm {sign}}(a_{1})\;\|a\|_{2}\;e_{1}}


and applying 





H




{\displaystyle {\mathit {H}}}

 on the matrix 





A




{\displaystyle {\mathit {A}}}

 zeroes all subdiagonal elements of the first column:






H

1



A
=


(




r

11





r

12





r

13






0


∗


∗




0


∗


∗



)




{\displaystyle H_{1}\;A={\begin{pmatrix}r_{11}&r_{12}&r_{13}\\0&*&*\\0&*&*\end{pmatrix}}}


In the second step, the second column of 





A




{\displaystyle {\mathit {A}}}

, we want to zero all elements but the first two, which means that we have to calculate 





H




{\displaystyle {\mathit {H}}}

 with the first column of the submatrix (denoted *), not on the whole second column of 





A




{\displaystyle {\mathit {A}}}

.

To get 




H

2




{\displaystyle H_{2}}

, we then embed the new 





H




{\displaystyle {\mathit {H}}}

 into an 



m
×
n


{\displaystyle m\times n}

 identity:






H

2


=


(



1


0


0




0


H





0





)




{\displaystyle H_{2}={\begin{pmatrix}1&0&0\\0&H&\\0&&\end{pmatrix}}}


This is how we can, column by column, remove all subdiagonal elements of 





A




{\displaystyle {\mathit {A}}}

 and thus transform it into 





R




{\displaystyle {\mathit {R}}}

.






H

n



.
.
.


H

3



H

2



H

1


A
=
R


{\displaystyle H_{n}\;...\;H_{3}H_{2}H_{1}A=R}


The product of all the Householder matrices 





H




{\displaystyle {\mathit {H}}}

, for every column, in reverse order, will then yield the orthogonal matrix 





Q




{\displaystyle {\mathit {Q}}}

.






H

1



H

2



H

3



.
.
.


H

n


=
Q


{\displaystyle H_{1}H_{2}H_{3}\;...\;H_{n}=Q}


The QR decomposition should then be used to solve linear least squares (Multiple regression) problems 





A


x
=
b


{\displaystyle {\mathit {A}}x=b}

 by solving





R

x
=

Q

T



b


{\displaystyle R\;x=Q^{T}\;b}


When 





R




{\displaystyle {\mathit {R}}}

 is not square, i.e. 



m
>
n


{\displaystyle m>n}

 we have to cut off the 





m


−
n


{\displaystyle {\mathit {m}}-n}

 zero padded bottom rows.





R
=


(




R

1






0



)




{\displaystyle R={\begin{pmatrix}R_{1}\\0\end{pmatrix}}}


and the same for the RHS:






Q

T



b
=


(




q

1







q

2





)




{\displaystyle Q^{T}\;b={\begin{pmatrix}q_{1}\\q_{2}\end{pmatrix}}}


Finally, solve the square upper triangular system by back substitution:






R

1



x
=

q

1




{\displaystyle R_{1}\;x=q_{1}}

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
 
    ""github.com/skelterjohn/go.matrix""
)
 
func sign(s float64) float64 {
    if s > 0 {
        return 1
    } else if s < 0 {
        return -1
    }
    return 0
}
 
func unitVector(n int) *matrix.DenseMatrix {
    vec := matrix.Zeros(n, 1)
    vec.Set(0, 0, 1)
    return vec
}
 
func householder(a *matrix.DenseMatrix) *matrix.DenseMatrix {
    m := a.Rows()
    s := sign(a.Get(0, 0))
    e := unitVector(m)
    u := matrix.Sum(a, matrix.Scaled(e, a.TwoNorm()*s))
    v := matrix.Scaled(u, 1/u.Get(0, 0))
    // (error checking skipped in this solution)
    prod, _ := v.Transpose().TimesDense(v)
    β := 2 / prod.Get(0, 0)
 
    prod, _ = v.TimesDense(v.Transpose())
    return matrix.Difference(matrix.Eye(m), matrix.Scaled(prod, β))
}
 
func qr(a *matrix.DenseMatrix) (q, r *matrix.DenseMatrix) {
    m := a.Rows()
    n := a.Cols()
    q = matrix.Eye(m)
 
    last := n - 1
    if m == n {
        last--
    }
    for i := 0; i <= last; i++ {
        // (copy is only for compatibility with an older version of gomatrix)
        b := a.GetMatrix(i, i, m-i, n-i).Copy()
        x := b.GetColVector(0)
        h := matrix.Eye(m)
        h.SetMatrix(i, i, householder(x))
        q, _ = q.TimesDense(h)
        a, _ = h.TimesDense(a)
    }
    return q, a
}
 
func main() {
    // task 1: show qr decomp of wp example
    a := matrix.MakeDenseMatrixStacked([][]float64{
        {12, -51, 4},
        {6, 167, -68},
        {-4, 24, -41}})
    q, r := qr(a)
    fmt.Println(""q:\n"", q)
    fmt.Println(""r:\n"", r)
 
    // task 2: use qr decomp for polynomial regression example
    x := matrix.MakeDenseMatrixStacked([][]float64{
        {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}})
    y := matrix.MakeDenseMatrixStacked([][]float64{
        {1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321}})
    fmt.Println(""\npolyfit:\n"", polyfit(x, y, 2))
}
 
func polyfit(x, y *matrix.DenseMatrix, n int) *matrix.DenseMatrix {
    m := x.Cols()
    a := matrix.Zeros(m, n+1)
    for i := 0; i < m; i++ {
        for j := 0; j <= n; j++ {
            a.Set(i, j, math.Pow(x.Get(0, i), float64(j)))
        }
    }
    return lsqr(a, y.Transpose())
}
 
func lsqr(a, b *matrix.DenseMatrix) *matrix.DenseMatrix {
    q, r := qr(a)
    n := r.Cols()
    prod, _ := q.Transpose().TimesDense(b)
    return solveUT(r.GetMatrix(0, 0, n, n), prod.GetMatrix(0, 0, n, 1))
}
 
func solveUT(r, b *matrix.DenseMatrix) *matrix.DenseMatrix {
    n := r.Cols()
    x := matrix.Zeros(n, 1)
    for k := n - 1; k >= 0; k-- {
        sum := 0.
        for j := k + 1; j < n; j++ {
            sum += r.Get(k, j) * x.Get(j, 0)
        }
        x.Set(k, 0, (b.Get(k, 0)-sum)/r.Get(k, k))
    }
    return x
}",2720,107
25950,http://rosettacode.org/wiki/Pythagorean_triples,Pythagorean triples,"A Pythagorean triple is defined as three positive integers 



(
a
,
b
,
c
)


{\displaystyle (a,b,c)}

 where 



a
<
b
<
c


{\displaystyle a<b<c}

, and 




a

2


+

b

2


=

c

2


.


{\displaystyle a^{2}+b^{2}=c^{2}.}



They are called primitive triples if 



a
,
b
,
c


{\displaystyle a,b,c}

 are co-prime, that is, if their pairwise greatest common divisors 





g
c
d


(
a
,
b
)
=


g
c
d


(
a
,
c
)
=


g
c
d


(
b
,
c
)
=
1


{\displaystyle {\rm {gcd}}(a,b)={\rm {gcd}}(a,c)={\rm {gcd}}(b,c)=1}

.

Because of their relationship through the Pythagorean theorem, a, b, and c are co-prime if a and b are co-prime (





g
c
d


(
a
,
b
)
=
1


{\displaystyle {\rm {gcd}}(a,b)=1}

).  

Each triple forms the length of the sides of a right triangle, whose perimeter is 



P
=
a
+
b
+
c


{\displaystyle P=a+b+c}

.



Task

The task is to determine how many Pythagorean triples there are with a perimeter no larger than 100 and the number of these that are primitive.



Extra credit
 
Deal with large values.   Can your program handle a maximum perimeter of 1,000,000?   What about 10,000,000?   100,000,000?

Note: the extra credit is not for you to demonstrate how fast your language is compared to others;   you need a proper algorithm to solve them in a timely manner.



Related tasks

   Euler's sum of powers conjecture 
   List comprehensions
   Pythagorean quadruples 

",#Go,Go,"package main
 
import ""fmt""
 
var total, prim, maxPeri int64
 
func newTri(s0, s1, s2 int64) {
    if p := s0 + s1 + s2; p <= maxPeri {
        prim++
        total += maxPeri / p
        newTri(+1*s0-2*s1+2*s2, +2*s0-1*s1+2*s2, +2*s0-2*s1+3*s2)
        newTri(+1*s0+2*s1+2*s2, +2*s0+1*s1+2*s2, +2*s0+2*s1+3*s2)
        newTri(-1*s0+2*s1+2*s2, -2*s0+1*s1+2*s2, -2*s0+2*s1+3*s2)
    }
}
 
func main() {
    for maxPeri = 100; maxPeri <= 1e11; maxPeri *= 10 {
        prim = 0
        total = 0
        newTri(3, 4, 5)
        fmt.Printf(""Up to %d:  %d triples, %d primitives\n"",
            maxPeri, total, prim)
    }
}",619,25
25973,http://rosettacode.org/wiki/Program_name,Program name,"The task is to programmatically obtain the name used to invoke the program. (For example determine whether the user ran ""python hello.py"", or ""python hellocaller.py"", a program importing the code from ""hello.py"".)

Sometimes a multiline shebang is necessary in order to provide the script name to a language's internal ARGV.

See also Command-line arguments

Examples from GitHub.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""os""
)
 
func main() {
    fmt.Println(""Program:"", os.Args[0])
}",102,10
25975,http://rosettacode.org/wiki/Primorial_numbers,Primorial numbers,"Primorial numbers are those formed by multiplying successive prime numbers.



The primorial number series is:

   primorial(0) =         1       (by definition)
   primorial(1) =         2       (2)
   primorial(2) =         6       (2×3)
   primorial(3) =       30       (2×3×5)
   primorial(4) =     210       (2×3×5×7)
   primorial(5) =   2310       (2×3×5×7×11)
   primorial(6) = 30030       (2×3×5×7×11×13)
         ∙ ∙ ∙
To express this mathematically,   primorialn   is  
the product of the first   n   (successive) primes:



   



p
r
i
m
o
r
i
a

l

n


=

∏

k
=
1


n


p
r
i
m

e

k




{\displaystyle primorial_{n}=\prod _{k=1}^{n}prime_{k}}




 ─── where   



p
r
i
m

e

k




{\displaystyle prime_{k}}

   is the   kth   prime number.




In some sense, generating primorial numbers is similar to factorials.

As with factorials, primorial numbers get large quickly.



Task

   Show the first ten primorial numbers   (0 ──► 9,   inclusive).
   Show the length of primorial numbers whose index is:   10   100   1,000   10,000   and   100,000.
   Show the length of the one millionth primorial number   (optional). 
   Use exact integers, not approximations. 


By   length   (above), it is meant the number of decimal digits in the numbers. 




Related tasks

   Sequence of primorial primes
   Factorial
   Fortunate_numbers


See also

   the MathWorld webpage:   primorial
   the Wikipedia   webpage:   primorial.
   the   OEIS   webpage:   A002110.

",#Go,Go,"package main
 
import (
	""fmt""
	""math/big""
	""time""
 
	""github.com/jbarham/primegen.go""
)
 
func main() {
	start := time.Now()
	pg := primegen.New()
	var i uint64
	p := big.NewInt(1)
	tmp := new(big.Int)
	for i <= 9 {
		fmt.Printf(""primorial(%v) = %v\n"", i, p)
		i++
		p = p.Mul(p, tmp.SetUint64(pg.Next()))
	}
	for _, j := range []uint64{1e1, 1e2, 1e3, 1e4, 1e5, 1e6} {
		for i < j {
			i++
			p = p.Mul(p, tmp.SetUint64(pg.Next()))
		}
		fmt.Printf(""primorial(%v) has %v digits"", i, len(p.String()))
		fmt.Printf(""\t(after %v)\n"", time.Since(start))
	}
}",555,30
26037,http://rosettacode.org/wiki/Prime_triangle,Prime triangle,"You will require a function f which when given an integer S will return a list of the arrangements of the integers 1 to S such that g1=1 gS=S and generally for n=1 to n=S-1 gn+gn+1 is prime. S=1 is undefined. For S=2 to S=20 print f(S) to form a triangle. Then again for S=2 to S=20 print the number of possible arrangements of 1 to S meeting these requirements.
",#Go,Go,"package main
 
import ""fmt""
 
var canFollow [][]bool
var arrang []int
var bFirst = true
 
var pmap = make(map[int]bool)
 
func init() {
    for _, i := range []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37} {
        pmap[i] = true
    }
}
 
func ptrs(res, n, done int) int {
    ad := arrang[done-1]
    if n-done <= 1 {
        if canFollow[ad-1][n-1] {
            if bFirst {
                for _, e := range arrang {
                    fmt.Printf(""%2d "", e)
                }
                fmt.Println()
                bFirst = false
            }
            res++
        }
    } else {
        done++
        for i := done - 1; i <= n-2; i += 2 {
            ai := arrang[i]
            if canFollow[ad-1][ai-1] {
                arrang[i], arrang[done-1] = arrang[done-1], arrang[i]
                res = ptrs(res, n, done)
                arrang[i], arrang[done-1] = arrang[done-1], arrang[i]
            }
        }
    }
    return res
}
 
func primeTriangle(n int) int {
    canFollow = make([][]bool, n)
    for i := 0; i < n; i++ {
        canFollow[i] = make([]bool, n)
        for j := 0; j < n; j++ {
            _, ok := pmap[i+j+2]
            canFollow[i][j] = ok
        }
    }
    bFirst = true
    arrang = make([]int, n)
    for i := 0; i < n; i++ {
        arrang[i] = i + 1
    }
    return ptrs(0, n, 1)
}
 
func main() {
    counts := make([]int, 19)
    for i := 2; i <= 20; i++ {
        counts[i-2] = primeTriangle(i)
    }
    fmt.Println()
    for i := 0; i < 19; i++ {
        fmt.Printf(""%d "", counts[i])
    }
    fmt.Println()
}",1573,71
26048,http://rosettacode.org/wiki/Program_termination,Program termination,"

Task

Show the syntax for a complete stoppage of a program inside a   conditional.

This includes all threads/processes which are part of your program.

Explain the cleanup (or lack thereof) caused by the termination (allocated memory, database connections, open files, object finalizers/destructors, run-on-exit hooks, etc.).

Unless otherwise described, no special cleanup outside that provided by the operating system is provided.



",#Go,Go,"func main() {
    if problem {
        return
    }
}",53,5
26101,http://rosettacode.org/wiki/Primes_-_allocate_descendants_to_their_ancestors,Primes - allocate descendants to their ancestors,"The concept, is to add the decomposition into prime factors of a number to get its 'ancestors'.



The objective is to demonstrate that the choice of the algorithm can be crucial in term of performance.
This solution could be compared to the solution that would use the decomposition into primes for all the numbers between 1 and 333.



The problem is to list, for a delimited set of ancestors (from 1 to 99) :

- the total of their own ancestors (LEVEL),

- their own ancestors (ANCESTORS),

- the total of the direct descendants (DESCENDANTS),

- all the direct descendants.



You only have to consider the prime factors < 100.

A grand total of the descendants has to be printed at the end of the list.

The task should be accomplished in a reasonable time-frame.



Example :

46 = 2*23 --> 2+23 = 25, is the parent of 46.
25 = 5*5  --> 5+5  = 10, is the parent of 25.
10 = 2*5  --> 2+5  = 7,  is the parent of 10.
7 is a prime factor and, as such, has no parent.

46 has 3 ancestors (7, 10 and 25).
46 has 557 descendants.
The list layout and the output for Parent [46] :

[46] Level: 3
Ancestors: 7, 10, 25
Descendants: 557
129, 205, 246, 493, 518, 529, 740, 806, 888, 999, 1364, 1508, 1748, 2552, 2871, 3128, 3255, 3472, 3519, 3875, 3906, 4263, 4650, 4960, 5075, 5415, 5580, 5776, 5952, 6090, 6279, 6496, 6498, 6696, 6783, 7250, 7308, 7475, 7533, 8075, 8151, 8619, 8700, 8855, 8970, 9280, 9568, 9690, 10115, 10336, 10440, 10626, 10764, 11136, 11495, 11628, 11745, 12103, 12138, 12155, 12528, 12650, 13794, 14094, 14399, 14450, 14586, 15180, 15379, 15778, 16192, 17290, 17303, 17340, 18216, 18496, 20482, 20493, 20570, 20748, 20808, 21658, 21970, 22540, 23409, 24684, 24700, 26026, 26364, 27048, 29260, 29282, 29640, 30429, 30940, 31616, 32200, 33345, 35112, 35568, 36225, 36652, 37128, 37180, 38640, 39501, 40014, 41216, 41769, 41800, 43125, 43470, 44044, 44200, 44616, 46000, 46368, 47025, 49725, 50160, 50193, 51750, 52136, 52164, 52360, 53040, 53504, 55200, 56430, 56576, 58653, 58880, 58905, 59670, 60192, 62100, 62832, 62920, 63648, 66240, 66248, 67716, 69825, 70125, 70656, 70686, 70785, 71604, 74480, 74520, 74529, 74536, 74800, 75504, 79488, 83125, 83790, 83835, 83853, 84150, 84942, 87465, 88725, 89376, 89424, 89760, 93296, 94640, 95744, 99750, 99825, 100548, 100602, 100980, 104125, 104958, 105105, 105625, 106400, 106470, 106480, 107712, 112112, 113568, 118750, 119700, 119790, 121176, 124509, 124950, 125125, 126126, 126750, 127680, 127764, 127776, 133280, 135200, 136192, 136323, 142500, 143640, 143748, 148225, 148750, 149940, 150150, 152000, 152100, 153216, 156065, 159936, 160160, 161595, 162240, 171000, 172368, 173056, 177870, 178500, 178750, 179928, 180180, 182400, 182520, 184877, 187278, 189728, 190400, 192192, 192375, 193914, 194560, 194688, 202419, 205200, 205335, 211750, 212500, 213444, 214200, 214500, 216216, 218880, 219024, 222950, 228480, 228800, 230850, 233472, 240975, 243243, 243712, 246240, 246402, 254100, 255000, 257040, 257400, 262656, 264110, 267540, 271040, 272000, 274176, 274560, 277020, 285376, 286875, 289170, 289575, 292864, 295488, 302500, 304920, 306000, 308448, 308880, 316932, 318500, 321048, 325248, 326400, 329472, 332424, 343035, 344250, 347004, 347490, 348160, 361179, 363000, 365904, 367200, 370656, 373977, 377300, 382200, 387200, 391680, 407680, 408375, 411642, 413100, 416988, 417792, 429975, 435600, 440640, 452760, 455000, 458640, 464640, 470016, 470596, 482944, 489216, 490050, 495616, 495720, 509355, 511875, 515970, 522720, 528768, 539000, 543312, 546000, 550368, 557568, 557685, 582400, 588060, 594864, 606375, 609375, 611226, 614250, 619164, 627264, 646800, 650000, 655200, 669222, 672280, 689920, 698880, 705672, 721875, 727650, 731250, 737100, 745472, 756315, 770000, 776160, 780000, 786240, 793881, 806736, 827904, 832000, 838656, 859375, 866250, 873180, 877500, 884520, 900375, 907578, 924000, 931392, 936000, 943488, 960400, 985600, 995085, 998400, 1031250, 1039500, 1047816, 1053000, 1061424, 1064960, 1071875, 1080450, 1100000, 1108800, 1123200, 1152480, 1178793, 1182720, 1184625, 1194102, 1198080, 1229312, 1237500, 1247400, 1261568, 1263600, 1277952, 1286250, 1296540, 1320000, 1330560, 1347840, 1372000, 1382976, 1403325, 1408000, 1419264, 1421550, 1437696, 1485000, 1496880, 1516320, 1531250, 1543500, 1555848, 1584000, 1596672, 1617408, 1646400, 1670625, 1683990, 1689600, 1705860, 1750329, 1756160, 1782000, 1796256, 1802240, 1819584, 1837500, 1852200, 1900800, 1960000, 1975680, 2004750, 2020788, 2027520, 2047032, 2083725, 2107392, 2138400, 2162688, 2187500, 2205000, 2222640, 2280960, 2302911, 2352000, 2370816, 2405700, 2433024, 2480625, 2500470, 2508800, 2566080, 2625000, 2646000, 2667168, 2737152, 2800000, 2822400, 2886840, 2953125, 2976750, 3000564, 3010560, 3079296, 3125000, 3150000, 3175200, 3211264, 3247695, 3360000, 3386880, 3464208, 3515625, 3543750, 3572100, 3584000, 3612672, 3750000, 3780000, 3810240, 3897234, 4000000, 4032000, 4064256, 4218750, 4252500, 4286520, 4300800, 4500000, 4536000, 4572288, 4587520, 4800000, 4822335, 4838400, 5062500, 5103000, 5120000, 5143824, 5160960, 5400000, 5443200, 5505024, 5740875, 5760000, 5786802, 5806080, 6075000, 6123600, 6144000, 6193152, 6480000, 6531840, 6553600, 6834375, 6889050, 6912000, 6967296, 7290000, 7348320, 7372800, 7776000, 7838208, 7864320, 8201250, 8266860, 8294400, 8388608, 8748000, 8817984, 8847360, 9331200, 9437184, 9841500, 9920232, 9953280, 10497600, 10616832, 11160261, 11197440, 11809800, 11943936, 12597120, 13286025, 13436928, 14171760, 15116544, 15943230, 17006112, 19131876
Some figures :

The biggest descendant number : 3^33 = 5.559.060.566.555.523 (parent 99)

Total Descendants 546.986
",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
func getPrimes(max int) []int {
    if max < 2 {
        return []int{}
    }
    lprimes := []int{2}
outer:
    for x := 3; x <= max; x += 2 {
        for _, p := range lprimes {
            if x%p == 0 {
                continue outer
            }
        }
        lprimes = append(lprimes, x)
    }
    return lprimes
}
 
func main() {
    const maxSum = 99
    descendants := make([][]int64, maxSum+1)
    ancestors := make([][]int, maxSum+1)
    for i := 0; i <= maxSum; i++ {
        descendants[i] = []int64{}
        ancestors[i] = []int{}
    }
    primes := getPrimes(maxSum)
 
    for _, p := range primes {
        descendants[p] = append(descendants[p], int64(p))
        for s := 1; s < len(descendants)-p; s++ {
            temp := make([]int64, len(descendants[s]))
            for i := 0; i < len(descendants[s]); i++ {
                temp[i] = int64(p) * descendants[s][i]
            }
            descendants[s+p] = append(descendants[s+p], temp...)
        }
    }
 
    for _, p := range append(primes, 4) {
        le := len(descendants[p])
        if le == 0 {
            continue
        }
        descendants[p][le-1] = 0
        descendants[p] = descendants[p][:le-1]
    }
    total := 0
 
    for s := 1; s <= maxSum; s++ {
        x := descendants[s]
        sort.Slice(x, func(i, j int) bool {
            return x[i] < x[j]
        })
        total += len(descendants[s])
        index := 0
        for ; index < len(descendants[s]); index++ {
            if descendants[s][index] > int64(maxSum) {
                break
            }
        }
        for _, d := range descendants[s][:index] {
            ancestors[d] = append(ancestors[s], s)
        }
        if (s >= 21 && s <= 45) || (s >= 47 && s <= 73) || (s >= 75 && s < maxSum) {
            continue
        }
        temp := fmt.Sprintf(""%v"", ancestors[s])
        fmt.Printf(""%2d: %d Ancestor(s): %-14s"", s, len(ancestors[s]), temp)
        le := len(descendants[s])
        if le <= 10 {
            fmt.Printf(""%5d Descendant(s): %v\n"", le, descendants[s])
        } else {
            fmt.Printf(""%5d Descendant(s): %v\b ...]\n"", le, descendants[s][:10])
        }
    }
    fmt.Println(""\nTotal descendants"", total)
}",2271,84
26157,http://rosettacode.org/wiki/Pragmatic_directives,Pragmatic directives,"Pragmatic directives cause the language to operate in a specific manner,   allowing support for operational variances within the program code   (possibly by the loading of specific or alternative modules).



Task

List any pragmatic directives supported by the language,   and demonstrate how to activate and deactivate the pragmatic directives and to describe or demonstrate the scope of effect that the pragmatic directives have within a program.



",#Go,Go,// +build <expression>,22,1
26192,http://rosettacode.org/wiki/Problem_of_Apollonius,Problem of Apollonius,"
Task

Implement a solution to the Problem of Apollonius   (description on Wikipedia)   which is the problem of finding the circle that is tangent to three specified circles   (colored black in the diagram below to the right).

There is an   algebraic solution   which is pretty straightforward.



The solutions to the example in the code are shown in the diagram   (below and to the right).

The red circle is ""internally tangent"" to all three black circles,   and the green circle is ""externally tangent"" to all three black circles.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
type circle struct {
    x, y, r float64
}
 
func main() {
    c1 := circle{0, 0, 1}
    c2 := circle{4, 0, 1}
    c3 := circle{2, 4, 2}
    fmt.Println(ap(c1, c2, c3, true))
    fmt.Println(ap(c1, c2, c3, false))
}
 
func ap(c1, c2, c3 circle, s bool) circle {
    x1sq := c1.x * c1.x
    y1sq := c1.y * c1.y
    r1sq := c1.r * c1.r
    x2sq := c2.x * c2.x
    y2sq := c2.y * c2.y
    r2sq := c2.r * c2.r
    x3sq := c3.x * c3.x
    y3sq := c3.y * c3.y
    r3sq := c3.r * c3.r
    v11 := 2 * (c2.x - c1.x)
    v12 := 2 * (c2.y - c1.y)
    v13 := x1sq - x2sq + y1sq - y2sq - r1sq + r2sq
    v14 := 2 * (c2.r - c1.r)
    v21 := 2 * (c3.x - c2.x)
    v22 := 2 * (c3.y - c2.y)
    v23 := x2sq - x3sq + y2sq - y3sq - r2sq + r3sq
    v24 := 2 * (c3.r - c2.r)
    if s {
        v14 = -v14
        v24 = -v24
    }
    w12 := v12 / v11
    w13 := v13 / v11
    w14 := v14 / v11
    w22 := v22/v21 - w12
    w23 := v23/v21 - w13
    w24 := v24/v21 - w14
    p := -w23 / w22
    q := w24 / w22
    m := -w12*p - w13
    n := w14 - w12*q
    a := n*n + q*q - 1
    b := m*n - n*c1.x + p*q - q*c1.y
    if s {
        b -= c1.r
    } else {
        b += c1.r
    }
    b *= 2
    c := x1sq + m*m - 2*m*c1.x + p*p + y1sq - 2*p*c1.y - r1sq
    d := b*b - 4*a*c
    rs := (-b - math.Sqrt(d)) / (2 * a)
    return circle{m + n*rs, p + q*rs, rs}
}",1381,64
26283,http://rosettacode.org/wiki/Prime_conspiracy,Prime conspiracy,"A recent discovery, quoted from   Quantamagazine   (March 13, 2016):

     Two mathematicians have uncovered a simple, previously unnoticed property of 
     prime numbers — those numbers that are divisible only by 1 and themselves.     
     Prime numbers, it seems, have decided preferences about the final digits of    
     the primes that immediately follow them.  

and

     This conspiracy among prime numbers seems, at first glance, to violate a     
     longstanding assumption in number theory:  that prime numbers behave much    
     like random numbers. 

                            ─── (original authors from Stanford University):      
                            ─── Kannan Soundararajan  and  Robert Lemke Oliver    



The task is to check this assertion, modulo 10.

Lets call    i -> j    a transition if    i    is the last decimal digit of a prime, and    j    the last decimal digit of the following prime.



Task

Considering the first one million primes.   Count, for any pair of successive primes, the number of transitions    i -> j    and print them along with their relative frequency, sorted by    i .

You can see that, for a given    i ,   frequencies are not evenly distributed.



Observation

(Modulo 10),   primes whose last digit is   9   ""prefer""   the digit   1   to the digit   9,   as its following prime.



Extra credit

Do the same for one hundred million primes.



Example for 10,000 primes

10000 first primes. Transitions prime % 10 → next-prime % 10.
1 → 1 count:        365 frequency: 3.65 %
1 → 3 count:        833 frequency: 8.33 %
1 → 7 count:        889 frequency: 8.89 %
1 → 9 count:        397 frequency: 3.97 %
2 → 3 count:          1 frequency: 0.01 %
3 → 1 count:        529 frequency: 5.29 %
3 → 3 count:        324 frequency: 3.24 %
3 → 5 count:          1 frequency: 0.01 %
3 → 7 count:        754 frequency: 7.54 %
3 → 9 count:        907 frequency: 9.07 %
5 → 7 count:          1 frequency: 0.01 %
7 → 1 count:        655 frequency: 6.55 %
7 → 3 count:        722 frequency: 7.22 %
7 → 7 count:        323 frequency: 3.23 %
7 → 9 count:        808 frequency: 8.08 %
9 → 1 count:        935 frequency: 9.35 %
9 → 3 count:        635 frequency: 6.35 %
9 → 7 count:        541 frequency: 5.41 %
9 → 9 count:        379 frequency: 3.79 % 


",#Go,Go,"package main
 
import (
	""fmt""
	""sort""
)
 
func sieve(limit uint64) []bool {
	limit++
	// True denotes composite, false denotes prime.
	// We don't bother filling in the even composites.
	c := make([]bool, limit)
	c[0] = true
	c[1] = true
	p := uint64(3) // Start from 3.
	for {
		p2 := p * p
		if p2 >= limit {
			break
		}
		for i := p2; i < limit; i += 2 * p {
			c[i] = true
		}
		for {
			p += 2
			if !c[p] {
				break
			}
		}
	}
	return c
}
 
func main() {
	// sieve up to the 100 millionth prime
	sieved := sieve(2038074743)
 
	transMap := make(map[int]int, 19)
	i := 2            // last digit of first prime
	p := int64(3 - 2) // next prime, -2 since we +=2 first
	n := 1
	for _, num := range [...]int{1e4, 1e6, 1e8} {
		for ; n < num; n++ {
			// Set p to next prime by skipping composites.
			p += 2
			for sieved[p] {
				p += 2
			}
			// Count transition of i -> j.
			j := int(p % 10)
			transMap[i*10+j]++
			i = j
		}
		reportTransitions(transMap, n)
	}
}
 
func reportTransitions(transMap map[int]int, num int) {
	keys := make([]int, 0, len(transMap))
	for k := range transMap {
		keys = append(keys, k)
	}
	sort.Ints(keys)
	fmt.Println(""First"", num, ""primes. Transitions prime % 10 -> next-prime % 10."")
	for _, key := range keys {
		count := transMap[key]
		freq := float64(count) / float64(num) * 100
		fmt.Printf(""%d -> %d  count: %7d"", key/10, key%10, count)
		fmt.Printf(""  frequency: %4.2f%%\n"", freq)
	}
	fmt.Println()
}",1448,72
26397,http://rosettacode.org/wiki/Primality_by_Wilson%27s_theorem,Primality by Wilson's theorem,"Task

Write a boolean function that tells whether a given integer is prime using Wilson's theorem.

By Wilson's theorem, a number p is prime if and only if p divides (p - 1)! + 1.

Remember that 1 and all non-positive integers are not prime.



See also

 Cut-the-knot: Wilson's theorem.
 Wikipedia: Wilson's theorem

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
var (
    zero = big.NewInt(0)
    one  = big.NewInt(1)
    prev = big.NewInt(factorial(20))
)
 
// Only usable for n <= 20.
func factorial(n int64) int64 {
    res := int64(1)
    for k := n; k > 1; k-- {
        res *= k
    }
    return res
}
 
// If memo == true, stores previous sequential
// factorial calculation for odd n > 21.
func wilson(n int64, memo bool) bool {
    if n <= 1 || (n%2 == 0 && n != 2) {
        return false
    }
    if n <= 21 {
        return (factorial(n-1)+1)%n == 0
    }
    b := big.NewInt(n)
    r := big.NewInt(0)
    z := big.NewInt(0)
    if !memo {
        z.MulRange(2, n-1) // computes factorial from scratch
    } else {
        prev.Mul(prev, r.MulRange(n-2, n-1)) // uses previous calculation
        z.Set(prev)
    }
    z.Add(z, one)
    return r.Rem(z, b).Cmp(zero) == 0    
}
 
func main() {
    numbers := []int64{2, 3, 9, 15, 29, 37, 47, 57, 67, 77, 87, 97, 237, 409, 659}
    fmt.Println(""  n  prime"")
    fmt.Println(""---  -----"")
    for _, n := range numbers {
        fmt.Printf(""%3d  %t\n"", n, wilson(n, false))
    }
 
    // sequential memoized calculation
    fmt.Println(""\nThe first 120 prime numbers are:"")
    for i, count := int64(2), 0; count < 1015; i += 2 {
        if wilson(i, true) {
            count++
            if count <= 120 {
                fmt.Printf(""%3d "", i)
                if count%20 == 0 {
                    fmt.Println()
                }
            } else if count >= 1000 {
                if count == 1000 {
                    fmt.Println(""\nThe 1,000th to 1,015th prime numbers are:"") 
                }
                fmt.Printf(""%4d "", i)
            }            
        }
        if i == 2 {
            i--
        }
    }
    fmt.Println()    
}",1805,75
26409,http://rosettacode.org/wiki/Probabilistic_choice,Probabilistic choice,"Given a mapping between items and their required probability of occurrence, generate a million items randomly subject to the given probabilities and compare the target probability of occurrence versus the generated values.

The total of all the probabilities should equal one. (Because floating point arithmetic is involved, this is subject to rounding errors).

aleph   1/5.0
beth    1/6.0
gimel   1/7.0
daleth  1/8.0
he      1/9.0
waw     1/10.0
zayin   1/11.0
heth    1759/27720 # adjusted so that probabilities add to 1
Related task

 Random number generator (device)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
type mapping struct {
    item string
    pr   float64
}
 
func main() {
    // input mapping
    m := []mapping{
        {""aleph"", 1 / 5.},
        {""beth"", 1 / 6.},
        {""gimel"", 1 / 7.},
        {""daleth"", 1 / 8.},
        {""he"", 1 / 9.},
        {""waw"", 1 / 10.},
        {""zayin"", 1 / 11.},
        {""heth"", 1759 / 27720.}} // adjusted so that probabilities add to 1
 
    // cumulative probability
    cpr := make([]float64, len(m)-1)
    var c float64
    for i := 0; i < len(m)-1; i++ {
        c += m[i].pr
        cpr[i] = c
    }
 
    // generate
    const samples = 1e6
    occ := make([]int, len(m))
    rand.Seed(time.Now().UnixNano())
    for i := 0; i < samples; i++ {
        r := rand.Float64()
        for j := 0; ; j++ {
            if r < cpr[j] {
                occ[j]++
                break
            }
            if j == len(cpr)-1 {
                occ[len(cpr)]++
                break
            }
        }
    }
 
    // report
    fmt.Println(""  Item  Target   Generated"")
    var totalTarget, totalGenerated float64
    for i := 0; i < len(m); i++ {
        target := m[i].pr
        generated := float64(occ[i]) / samples
        fmt.Printf(""%6s  %8.6f  %8.6f\n"", m[i].item, target, generated)
        totalTarget += target
        totalGenerated += generated
    }
    fmt.Printf(""Totals  %8.6f  %8.6f\n"", totalTarget, totalGenerated)
}",1445,63
26425,http://rosettacode.org/wiki/Polyspiral,Polyspiral,"A Polyspiral is a spiral made of multiple line segments, whereby each segment is larger (or smaller) than the previous one by a given amount. Each segment also changes direction at a given angle.



Task
Animate a series of polyspirals, by drawing a complete spiral then incrementing the angle, and (after clearing the background) drawing the next, and so on. Every spiral will be a frame of the animation. The animation may stop as it goes full circle or continue indefinitely. The given input values may be varied.

If animation is not practical in your programming environment, you may show a single frame instead.



Pseudo code
    set incr to 0.0

    // animation loop
    WHILE true 

        incr = (incr + 0.05) MOD 360
        x = width / 2
        y = height / 2
        length = 5
        angle = incr

        // spiral loop
        FOR 1 TO 150
            drawline
            change direction by angle
            length = length + 3
            angle = (angle + incr) MOD 360
        ENDFOR
    


",#Go,Go,"  $ convert polyspiral.gif -coalesce polyspiral2.gif
  $ eog polyspiral2.gif
",77,3
26505,http://rosettacode.org/wiki/Priority_queue,Priority queue,"A priority queue is somewhat similar to a queue, with an important distinction: each item is added to a priority queue with a priority level, and will be later removed from the queue with the highest priority element first. That is, the items are (conceptually) stored in the queue in priority order instead of in insertion order.



Task

Create a priority queue.   The queue must support at least two operations:

   Insertion.   An element is added to the queue with a priority (a numeric value).
   Top item removal.   Deletes the element or one of the elements with the current top priority and return it.


Optionally, other operations may be defined, such as peeking (find what current top priority/top element is), merging (combining two priority queues into one), etc.



To test your implementation, insert a number of elements into the queue, each with some random priority.

Then dequeue them sequentially; now the elements should be sorted by priority.

You can use the following task/priority items as input data:

        Priority         Task
       ══════════   ════════════════
           3         Clear drains
           4         Feed cat
           5         Make tea
           1         Solve RC tasks
           2         Tax return



The implementation should try to be efficient.   A typical implementation has   O(log n)   insertion and extraction time,   where   n   is the number of items in the queue.

You may choose to impose certain limits such as small range of allowed priority levels, limited capacity, etc.   If so, discuss the reasons behind it.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""container/heap""
)
 
type Task struct {
    priority int
    name     string
}
 
type TaskPQ []Task
 
func (self TaskPQ) Len() int { return len(self) }
func (self TaskPQ) Less(i, j int) bool {
    return self[i].priority < self[j].priority
}
func (self TaskPQ) Swap(i, j int) { self[i], self[j] = self[j], self[i] }
func (self *TaskPQ) Push(x interface{}) { *self = append(*self, x.(Task)) }
func (self *TaskPQ) Pop() (popped interface{}) {
    popped = (*self)[len(*self)-1]
    *self = (*self)[:len(*self)-1]
    return
}
 
func main() {
    pq := &TaskPQ{{3, ""Clear drains""},
        {4, ""Feed cat""},
        {5, ""Make tea""},
        {1, ""Solve RC tasks""}}
 
    // heapify
    heap.Init(pq)
 
    // enqueue
    heap.Push(pq, Task{2, ""Tax return""})
 
    for pq.Len() != 0 { 
        // dequeue
        fmt.Println(heap.Pop(pq))
    }
}",878,43
26673,http://rosettacode.org/wiki/Polymorphic_copy,Polymorphic copy,"An object is polymorphic when its specific type may vary.
The types a specific value may take, is called class.

It is trivial to copy an object if its type is known:

int x;
int y = x;
Here x is not polymorphic, so y is declared of same type (int) as x.
But if the specific type of x were unknown, then y could not be declared of any specific type.

The task: let a polymorphic object contain an instance of some specific type S derived from a type T.
The type T is known.
The type S is possibly unknown until run time.
The objective is to create an exact copy of such polymorphic object (not to create a reference, nor a pointer to).
Let further the type T have a method overridden by S.
This method is to be called on the copy to demonstrate that the specific type of the copy is indeed S.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""reflect""
)
 
// interface types provide polymorphism, but not inheritance.
type i interface {
    identify() string
}
 
// ""base"" type
type t float64
 
// ""derived"" type.  in Go terminology, it is simply a struct with an
// anonymous field.  fields and methods of anonymous fields however,
// can be accessed without additional qualification and so are
// ""inherited"" in a sense.
type s struct {
    t
    kōan string
}
 
// another type with an ""embedded"" t field.  (t is the *type*, this field
// has no *name*.)
type r struct {
    t
    ch chan int
}
 
// a method on t.  this method makes t satisfy interface i.
// since a t is embedded in types s and r, they automatically ""inherit""
// the method.
func (x t) identify() string {
    return ""I'm a t!""
}
 
// the same method on s.  although s already satisfied i, calls to identify
// will now find this method rather than the one defined on t.  
// in a sense it ""overrides"" the method of the ""base class.""
func (x s) identify() string {
    return ""I'm an s!""
}
 
func main() {
    // three variables with different types, initialized from literals.
    var t1 t = 5
    var s1 s = s{6, ""one""}
    var r1 r = r{t: 7}
 
    // variables declared with the same type.  initial value is nil.
    var i1, i2, i3 i
    fmt.Println(""Initial (zero) values of interface variables:"")
    fmt.Println(""i1:"", i1)
    fmt.Println(""i2:"", i2)
    fmt.Println(""i3:"", i3)
 
    // in the terminology of the Go language reference, i1, i2, and i3
    // still have static type i, but now have different dynamic types.
    i1, i2, i3 = t1, s1, r1
    fmt.Println(""\nPolymorphic:"")
    fmt.Println(""i1:"", i1, ""/"", i1.identify(), ""/"", reflect.TypeOf(i1))
    fmt.Println(""i2:"", i2, ""/"", i2.identify(), ""/"", reflect.TypeOf(i2))
    fmt.Println(""i3:"", i3, ""/"", i3.identify(), ""/"", reflect.TypeOf(i3))
 
    // copy: declare and assign in one step using ""short declaration.""
    i1c, i2c, i3c := i1, i2, i3
 
    // modify first set of polymorphic variables.
    i1, i2, i3 = s{3, ""dog""}, r{t: 1}, t(2)
 
    // demonstrate that copies are distinct from first set
    // and that types are preserved.
    fmt.Println(""\nFirst set now modified:"")
    fmt.Println(""i1:"", i1, ""/"", i1.identify(), ""/"", reflect.TypeOf(i1))
    fmt.Println(""i2:"", i2, ""/"", i2.identify(), ""/"", reflect.TypeOf(i2))
    fmt.Println(""i3:"", i3, ""/"", i3.identify(), ""/"", reflect.TypeOf(i3))
 
    fmt.Println(""\nCopies made before modifications:"")
    fmt.Println(""i1c:"", i1c, ""/"", i1c.identify(), ""/"", reflect.TypeOf(i1c))
    fmt.Println(""i2c:"", i2c, ""/"", i2c.identify(), ""/"", reflect.TypeOf(i2c))
    fmt.Println(""i3c:"", i3c, ""/"", i3c.identify(), ""/"", reflect.TypeOf(i3c))
}",2719,84
26722,http://rosettacode.org/wiki/Pointers_and_references,Pointers and references,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


In this task, the goal is to demonstrate common operations on pointers and references. These examples show pointer operations on the stack, which can be dangerous and is rarely done. Pointers and references are commonly used along with Memory allocation on the heap.
",#Go,Go,"var p *int  // declare p to be a pointer to an int
i = &p      // assign i to be the int value pointed to by p",110,2
26736,http://rosettacode.org/wiki/Proper_divisors,Proper divisors,"The   proper divisors   of a positive integer N are those numbers, other than N itself, that divide N without remainder.

For N > 1 they will always include 1,   but for N == 1 there are no proper divisors.



Examples

The proper divisors of     6     are   1, 2, and 3.

The proper divisors of   100   are   1, 2, 4, 5, 10, 20, 25, and 50.



Task

 Create a routine to generate all the proper divisors of a number.
 use it to show the proper divisors of the numbers 1 to 10 inclusive.
 Find a number in the range 1 to 20,000 with the most proper divisors. Show the number and just the count of how many proper divisors it has.


Show all output here.



Related tasks

   Amicable pairs
   Abundant, deficient and perfect number classifications
   Aliquot sequence classifications
   Factors of an integer
   Prime decomposition

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
func listProperDivisors(limit int) {
    if limit < 1 {
        return
    }
    width := len(strconv.Itoa(limit))
    for i := 1; i <= limit; i++ {
        fmt.Printf(""%*d -> "", width, i)
        if i == 1 {
            fmt.Println(""(None)"")
            continue
        }
        for j := 1; j <= i/2; j++ {
            if i%j == 0 {
                fmt.Printf("" %d"", j)
            }
        }
        fmt.Println()
    }
}
 
func countProperDivisors(n int) int {
    if n < 2 {
        return 0
    }
    count := 0
    for i := 1; i <= n/2; i++ {
        if n%i == 0 {
            count++
        }
    }
    return count
}
 
func main() {
    fmt.Println(""The proper divisors of the following numbers are :\n"")
    listProperDivisors(10)
    fmt.Println()
    maxCount := 0
    most := []int{1}
    for n := 2; n <= 20000; n++ {
        count := countProperDivisors(n)
        if count == maxCount {
            most = append(most, n)
        } else if count > maxCount {
            maxCount = count
            most = most[0:1]
            most[0] = n
        }
    }
    fmt.Print(""The following number(s) <= 20000 have the most proper divisors, "")
    fmt.Println(""namely"", maxCount, ""\b\n"")
    for _, n := range most {
        fmt.Println(n)
    }
}",1313,62
26783,http://rosettacode.org/wiki/Polynomial_regression,Polynomial regression,"Find an approximating polynomial of known degree for a given data.

Example:
For input data:

x = {0,  1,  2,  3,  4,  5,  6,   7,   8,   9,   10};
y = {1,  6,  17, 34, 57, 86, 121, 162, 209, 262, 321};

The approximating polynomial is:

3 x2 + 2 x + 1

Here, the polynomial's coefficients are (3, 2, 1).

This task is intended as a subtask for Measure relative performance of sorting algorithms implementations.
",#Go,Go,"package main
 
import (
	""fmt""
	""log""
 
	""gonum.org/v1/gonum/mat""
)
 
func main() {
	var (
		x = []float64{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
		y = []float64{1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321}
 
		degree = 2
 
		a = Vandermonde(x, degree+1)
		b = mat.NewDense(len(y), 1, y)
		c = mat.NewDense(degree+1, 1, nil)
	)
 
	var qr mat.QR
	qr.Factorize(a)
 
	const trans = false
	err := qr.SolveTo(c, trans, b)
	if err != nil {
		log.Fatalf(""could not solve QR: %+v"", err)
	}
	fmt.Printf(""%.3f\n"", mat.Formatted(c))
}
 
func Vandermonde(a []float64, d int) *mat.Dense {
	x := mat.NewDense(len(a), d, nil)
	for i := range a {
		for j, p := 0, 1.0; j < d; j, p = j+1, p*a[i] {
			x.Set(i, j, p)
		}
	}
	return x
}",714,41
26801,http://rosettacode.org/wiki/Poker_hand_analyser,Poker hand analyser,"Task

Create a program to parse a single five card poker hand and rank it according to this list of poker hands.



A poker hand is specified as a space separated list of five playing cards.

Each input card has two characters indicating face and suit.



Example

2d       (two of diamonds).


Faces are:    a, 2, 3, 4, 5, 6, 7, 8, 9, 10, j, q, k

Suits are:    h (hearts),   d (diamonds),   c (clubs),   and   s (spades),   or

alternatively,   the unicode card-suit characters:     ♥ ♦ ♣ ♠ 



Duplicate cards are illegal.

The program should analyze a single hand and produce one of the following outputs:

 straight-flush
 four-of-a-kind
 full-house
 flush
 straight
 three-of-a-kind
 two-pair
 one-pair
 high-card
 invalid



Examples

   2♥ 2♦ 2♣ k♣ q♦:   three-of-a-kind
   2♥ 5♥ 7♦ 8♣ 9♠:   high-card
   a♥ 2♦ 3♣ 4♣ 5♦:   straight
   2♥ 3♥ 2♦ 3♣ 3♦:   full-house
   2♥ 7♥ 2♦ 3♣ 3♦:   two-pair
   2♥ 7♥ 7♦ 7♣ 7♠:   four-of-a-kind 
   10♥ j♥ q♥ k♥ a♥:  straight-flush
   4♥ 4♠ k♠ 5♦ 10♠:  one-pair
   q♣ 10♣ 7♣ 6♣ q♣:  invalid

The programs output for the above examples should be displayed here on this page.



Extra credit

 use the playing card characters introduced with Unicode 6.0 (U+1F0A1 - U+1F0DE).
 allow two jokers
 use the symbol   joker
 duplicates would be allowed (for jokers only)
 five-of-a-kind would then be the highest hand


More extra credit examples

   joker  2♦  2♠  k♠  q♦:     three-of-a-kind
   joker  5♥  7♦  8♠  9♦:     straight
   joker  2♦  3♠  4♠  5♠:     straight
   joker  3♥  2♦  3♠  3♦:     four-of-a-kind
   joker  7♥  2♦  3♠  3♦:     three-of-a-kind
   joker  7♥  7♦  7♠  7♣:     five-of-a-kind
   joker  j♥  q♥  k♥  A♥:     straight-flush
   joker  4♣  k♣  5♦ 10♠:     one-pair
   joker  k♣  7♣  6♣  4♣:     flush
   joker  2♦  joker  4♠  5♠:  straight
   joker  Q♦  joker  A♠ 10♠:  straight
   joker  Q♦  joker  A♦ 10♦:  straight-flush
   joker  2♦  2♠  joker  q♦:  four-of-a-kind



Related tasks

 Playing cards
 Card shuffles
 Deal cards_for_FreeCell
 War Card_Game
 Go Fish

",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
    ""strings""
)
 
type card struct {
    face byte
    suit byte
}
 
const faces = ""23456789tjqka""
const suits = ""shdc""
 
func isStraight(cards []card) bool {
    sorted := make([]card, 5)
    copy(sorted, cards)
    sort.Slice(sorted, func(i, j int) bool {
        return sorted[i].face < sorted[j].face
    })
    if sorted[0].face+4 == sorted[4].face {
        return true
    }
    if sorted[4].face == 14 && sorted[0].face == 2 && sorted[3].face == 5 {
        return true
    }
    return false
}
 
func isFlush(cards []card) bool {
    suit := cards[0].suit
    for i := 1; i < 5; i++ {
        if cards[i].suit != suit {
            return false
        }
    }
    return true
}
 
func analyzeHand(hand string) string {
    temp := strings.Fields(strings.ToLower(hand))
    splitSet := make(map[string]bool)
    var split []string
    for _, s := range temp {
        if !splitSet[s] {
            splitSet[s] = true
            split = append(split, s)
        }
    }
    if len(split) != 5 {
        return ""invalid""
    }
    var cards []card
 
    for _, s := range split {
        if len(s) != 2 {
            return ""invalid""
        }
        fIndex := strings.IndexByte(faces, s[0])
        if fIndex == -1 {
            return ""invalid""
        }
        sIndex := strings.IndexByte(suits, s[1])
        if sIndex == -1 {
            return ""invalid""
        }
        cards = append(cards, card{byte(fIndex + 2), s[1]})
    }
 
    groups := make(map[byte][]card)
    for _, c := range cards {
        groups[c.face] = append(groups[c.face], c)
    }
 
    switch len(groups) {
    case 2:
        for _, group := range groups {
            if len(group) == 4 {
                return ""four-of-a-kind""
            }
        }
        return ""full-house""
    case 3:
        for _, group := range groups {
            if len(group) == 3 {
                return ""three-of-a-kind""
            }
        }
        return ""two-pair""
    case 4:
        return ""one-pair""
    default:
        flush := isFlush(cards)
        straight := isStraight(cards)
        switch {
        case flush && straight:
            return ""straight-flush""
        case flush:
            return ""flush""
        case straight:
            return ""straight""
        default:
            return ""high-card""
        }
    }
}
 
func main() {
    hands := [...]string{
        ""2h 2d 2c kc qd"",
        ""2h 5h 7d 8c 9s"",
        ""ah 2d 3c 4c 5d"",
        ""2h 3h 2d 3c 3d"",
        ""2h 7h 2d 3c 3d"",
        ""2h 7h 7d 7c 7s"",
        ""th jh qh kh ah"",
        ""4h 4s ks 5d ts"",
        ""qc tc 7c 6c 4c"",
        ""ah ah 7c 6c 4c"",
    }
    for _, hand := range hands {
        fmt.Printf(""%s: %s\n"", hand, analyzeHand(hand))
    }
}",2770,126
26877,http://rosettacode.org/wiki/Polynomial_long_division,Polynomial long division,"

 This page uses content from Wikipedia. The original article was at Polynomial long division. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

In algebra, polynomial long division is an algorithm for dividing a polynomial by another polynomial of the same or lower degree.
Let us suppose a polynomial is represented by a vector, 



x


{\displaystyle x}

 (i.e., an ordered collection of coefficients) so that the 



i


{\displaystyle i}

th element keeps the coefficient of 




x

i




{\displaystyle x^{i}}

, and the multiplication by a monomial is a shift of the vector's elements ""towards right"" (injecting ones from left) followed by a multiplication of each element by the coefficient of the monomial.

Then a pseudocode for the polynomial long division using the conventions described above could be:

degree(P):
  return the index of the last non-zero element of P;
         if all elements are 0, return -∞

polynomial_long_division(N, D) returns (q, r):
  // N, D, q, r are vectors
  if degree(D) < 0 then error
  q ← 0
  while degree(N) ≥ degree(D)
    d ← D shifted right by (degree(N) - degree(D))
    q(degree(N) - degree(D)) ← N(degree(N)) / d(degree(d))
    // by construction, degree(d) = degree(N) of course
    d ← d * q(degree(N) - degree(D))
    N ← N - d
  endwhile
  r ← N
  return (q, r)

Note: vector * scalar multiplies each element of the vector by the scalar; vectorA - vectorB subtracts each element of the vectorB from the element of the vectorA with ""the same index"". The vectors in the pseudocode are zero-based.

 Error handling (for allocations or for wrong inputs) is not mandatory.
 Conventions can be different; in particular, note that if the first coefficient in the vector is the highest power of x for the polynomial represented by the vector, then the algorithm becomes simpler.

Example for clarification


This example is from Wikipedia, but changed to show how the given pseudocode works.

      0    1    2    3
   ----------------------
N:  -42    0  -12    1        degree = 3
D:   -3    1    0    0        degree = 1

   d(N) - d(D) = 2, so let's shift D towards right by 2:

N:  -42    0  -12    1
d:    0    0   -3    1

   N(3)/d(3) = 1, so d is unchanged. Now remember that ""shifting by 2""
   is like multiplying by x2, and the final multiplication
   (here by 1) is the coefficient of this monomial. Let's store this
   into q:
                               0     1     2
                              ---------------
                          q:   0     0     1

   now compute N - d, and let it be the ""new"" N, and let's loop

N:  -42    0   -9    0        degree = 2
D:   -3    1    0    0        degree = 1

   d(N) - d(D) = 1, right shift D by 1 and let it be d

N:  -42    0   -9    0
d:    0   -3    1    0        * -9/1 = -9

                          q:   0    -9     1

d:    0   27   -9    0        

   N ← N - d

N:  -42  -27    0    0        degree = 1
D:   -3    1    0    0        degree = 1

   looping again... d(N)-d(D)=0, so no shift is needed; we
   multiply D by -27 (= -27/1) storing the result in d, then

                          q:  -27   -9     1

   and

N:  -42  -27    0    0        -
d:   81  -27    0    0        =
N: -123    0    0    0        (last N)

    d(N) < d(D), so now r ← N, and the result is:

       0   1  2
   -------------
q:   -27  -9  1   →  x2 - 9x - 27
r:  -123   0  0   →          -123



Related task

   Polynomial derivative

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    n := []float64{-42, 0, -12, 1}
    d := []float64{-3, 1}
    fmt.Println(""N:"", n)
    fmt.Println(""D:"", d)
    q, r, ok := pld(n, d)
    if ok {
        fmt.Println(""Q:"", q)
        fmt.Println(""R:"", r)
    } else {
        fmt.Println(""error"")
    }
}
 
func degree(p []float64) int {
    for d := len(p) - 1; d >= 0; d-- {
        if p[d] != 0 {
            return d
        }
    }
    return -1
}
 
func pld(nn, dd []float64) (q, r []float64, ok bool) {
    if degree(dd) < 0 {
        return
    }
    nn = append(r, nn...)
    if degree(nn) >= degree(dd) {
        q = make([]float64, degree(nn)-degree(dd)+1)
        for degree(nn) >= degree(dd) {
            d := make([]float64, degree(nn)+1)
            copy(d[degree(nn)-degree(dd):], dd)
            q[degree(nn)-degree(dd)] = nn[degree(nn)] / d[degree(d)]
            for i := range d {
                d[i] *= q[degree(nn)-degree(dd)]
                nn[i] -= d[i]
            }
        }
    }
    return q, nn, true
}",1031,46
26905,http://rosettacode.org/wiki/Price_fraction,Price fraction,"A friend of mine runs a pharmacy.   He has a specialized function in his Dispensary application which receives a decimal value of currency and replaces it to a standard value.   This value is regulated by a government department.



Task

Given a floating point value between   0.00   and   1.00,   rescale according to the following table:

>=  0.00  <  0.06  :=  0.10
>=  0.06  <  0.11  :=  0.18
>=  0.11  <  0.16  :=  0.26
>=  0.16  <  0.21  :=  0.32
>=  0.21  <  0.26  :=  0.38
>=  0.26  <  0.31  :=  0.44
>=  0.31  <  0.36  :=  0.50
>=  0.36  <  0.41  :=  0.54
>=  0.41  <  0.46  :=  0.58
>=  0.46  <  0.51  :=  0.62
>=  0.51  <  0.56  :=  0.66
>=  0.56  <  0.61  :=  0.70
>=  0.61  <  0.66  :=  0.74
>=  0.66  <  0.71  :=  0.78
>=  0.71  <  0.76  :=  0.82
>=  0.76  <  0.81  :=  0.86
>=  0.81  <  0.86  :=  0.90
>=  0.86  <  0.91  :=  0.94
>=  0.91  <  0.96  :=  0.98
>=  0.96  <  1.01  :=  1.00


",#Go,Go,"package main
 
import ""fmt""
 
func pf(v float64) float64 {
    switch {
    case v < .06:
        return .10
    case v < .11:
        return .18
    case v < .16:
        return .26
    case v < .21:
        return .32
    case v < .26:
        return .38
    case v < .31:
        return .44
    case v < .36:
        return .50
    case v < .41:
        return .54
    case v < .46:
        return .58
    case v < .51:
        return .62
    case v < .56:
        return .66
    case v < .61:
        return .70
    case v < .66:
        return .74
    case v < .71:
        return .78
    case v < .76:
        return .82
    case v < .81:
        return .86
    case v < .86:
        return .90
    case v < .91:
        return .94
    case v < .96:
        return .98
    }
    return 1
}
 
func main() {
    tests := []float64{0.3793, 0.4425, 0.0746, 0.6918, 0.2993,
        0.5486, 0.7848, 0.9383, 0.2292, 0.9760}
    for _, v := range tests {
        fmt.Printf(""%0.4f -> %0.2f\n"", v, pf(v))
    }
}",1009,55
26916,http://rosettacode.org/wiki/Plot_coordinate_pairs,Plot coordinate pairs,"Task

Plot a function represented as     x,  y     numerical arrays.

Post the resulting image for the following input arrays (taken from Python's Example section on Time a function):

      x = {0,   1,    2,    3,    4,    5,     6,     7,     8,     9};
      y = {2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0};

This task is intended as a subtask for Measure relative performance of sorting algorithms implementations.



",#Go,Go,"package main
 
import (
  ""fmt""
  ""log""
  ""os/exec""
)
 
var (
  x = []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
  y = []float64{2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0}
)
 
func main() {
  g := exec.Command(""gnuplot"", ""-persist"")
  w, err := g.StdinPipe()
  if err != nil {
    log.Fatal(err)
  }
  if err = g.Start(); err != nil {
    log.Fatal(err)
  }
  fmt.Fprintln(w, ""unset key; plot '-'"")
  for i, xi := range x {
    fmt.Fprintf(w, ""%d %f\n"", xi, y[i])
  }
  fmt.Fprintln(w, ""e"")
  w.Close()
  g.Wait()
}",525,30
27007,http://rosettacode.org/wiki/Polymorphism,Polymorphism,"Task

Create two classes   Point(x,y)   and   Circle(x,y,r)   with a polymorphic function print, accessors for (x,y,r), copy constructor, assignment and destructor and every possible default constructors



",#Go,Go,"package main
 
import ""fmt""
 
type point struct {
    x, y float64
}
 
type circle struct {
    x, y, r float64
}
 
type printer interface {
    print()
}
 
func (p *point) print() {
    fmt.Println(p.x, p.y)
}
 
func (c *circle) print() {
    fmt.Println(c.x, c.y, c.r)
}
 
func main() {
    var i printer            // polymorphic variable
    i = newPoint(3, 4)       // assign one type
    i.print()                // call polymorphic function
    i = newCircle(5, 12, 13) // assign different type to same variable
    i.print()                // same call accesses different method now.
}
 
// Above is a sort of polymorphism: both types implement the printer
// interface.  The print function can be called through a variable
// of type printer, without knowing the underlying type.
 
// Below is other stuff the task asks for.  Note that none of it is
// needed for cases as simple as this task, and it is not idomatic
// to write any of these functions in these simple cases.
 
// Accessors are not idiomatic in Go.  Instead, simply access struct
// fields directly.  To allow access from another package, you ""export""
// the field by capitalizing the field name. 
func (p *point) getX() float64  { return p.x }
func (p *point) getY() float64  { return p.y }
func (p *point) setX(v float64) { p.x = v }
func (p *point) setY(v float64) { p.y = v }
 
func (c *circle) getX() float64  { return c.x }
func (c *circle) getY() float64  { return c.y }
func (c *circle) getR() float64  { return c.r }
func (c *circle) setX(v float64) { c.x = v }
func (c *circle) setY(v float64) { c.y = v }
func (c *circle) setR(v float64) { c.r = v }
 
// Copy constructors, not idiomatic.  Structs are assignable so
// you can simply declare and assign them as needed.
func (p *point) clone() *point   { r := *p; return &r }
func (c *circle) clone() *circle { r := *c; return &r }
 
// Assignment methods, not idiomatic.  Just use the assignment operator.
func (p *point) set(q *point)   { *p = *q }
func (c *circle) set(d *circle) { *c = *d }
 
// Constructors are idiomatic only when construction involves something
// more than just assigning initial values.  By default, structs
// are created as ""zero values,"" that is, with all fields zero,
// empty, or nil.  The struct literal synax allows for all fields to
// initialized, or for any subset of fields to be initialized by name.
// These feautures take the place of trivial default constructors.
// When additional initialization is needed, it is conventional to
// name a function New, New<Type>, or within a package, new<Type>
// as shown here.
func newPoint(x, y float64) *point {
    return &point{x, y}
}
func newCircle(x, y, r float64) *circle {
    return &circle{x, y, r}
}
 
// Destructors are never used in Go.  Objects are garbage collected.",2796,81
27096,http://rosettacode.org/wiki/Prime_decomposition,Prime decomposition,"The prime decomposition of a number is defined as a list of prime numbers
which when all multiplied together, are equal to that number.



Example

 12 = 2 × 2 × 3,  so its prime decomposition is  {2, 2, 3}



Task

Write a function which returns an array or collection which contains the prime decomposition of a given number   



n


{\displaystyle n}

   greater than   1.

If your language does not have an isPrime-like function available,
you may assume that you have a function which determines
whether a number is prime (note its name before your code).

If you would like to test code from this task, you may use code from trial division or the Sieve of Eratosthenes.

Note: The program must not be limited by the word size of your computer or some other artificial limit; it should work for any number regardless of size (ignoring the physical limits of RAM etc).



Related tasks

   count in factors
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
var (
    ZERO = big.NewInt(0)
    ONE  = big.NewInt(1)
)
 
func Primes(n *big.Int) []*big.Int {
    res := []*big.Int{}
    mod, div := new(big.Int), new(big.Int)
    for i := big.NewInt(2); i.Cmp(n) != 1; {
        div.DivMod(n, i, mod)
        for mod.Cmp(ZERO) == 0 {
            res = append(res, new(big.Int).Set(i))
            n.Set(div)
            div.DivMod(n, i, mod)
        }
        i.Add(i, ONE)
    }
    return res
}
 
func main() {
    vals := []int64{
        1 << 31,
        1234567,
        333333,
        987653,
        2 * 3 * 5 * 7 * 11 * 13 * 17,
    }
    for _, v := range vals {
        fmt.Println(v, ""->"", Primes(big.NewInt(v)))
    }
}",723,39
27105,http://rosettacode.org/wiki/Power_set,Power set,"A   set   is a collection (container) of certain values,
without any particular order, and no repeated values.

It corresponds with a finite set in mathematics.

A set can be implemented as an associative array (partial mapping)
in which the value of each key-value pair is ignored.

Given a set S, the power set (or powerset) of S, written P(S), or 2S, is the set of all subsets of S.



Task

By using a library or built-in set type, or by defining a set type with necessary operations, write a function with a set S as input that yields the power set 2S of S.



For example, the power set of     {1,2,3,4}     is

 {{}, {1}, {2}, {1,2}, {3}, {1,3}, {2,3}, {1,2,3}, {4}, {1,4}, {2,4}, {1,2,4}, {3,4}, {1,3,4}, {2,3,4}, {1,2,3,4}}.
For a set which contains n elements, the corresponding power set has 2n elements, including the edge cases of empty set.


The power set of the empty set is the set which contains itself (20 = 1):


 





P




{\displaystyle {\mathcal {P}}}

(



∅


{\displaystyle \varnothing }

) = { 



∅


{\displaystyle \varnothing }

 }

And the power set of the set which contains only the empty set, has two subsets, the empty set and the set which contains the empty set (21 = 2):


 





P




{\displaystyle {\mathcal {P}}}

({



∅


{\displaystyle \varnothing }

}) = { 



∅


{\displaystyle \varnothing }

, { 



∅


{\displaystyle \varnothing }

 } }


Extra credit:  Demonstrate that your language supports these last two powersets.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
    ""strings""
)
 
// types needed to implement general purpose sets are element and set
 
// element is an interface, allowing different kinds of elements to be
// implemented and stored in sets.
type elem interface {
    // an element must be distinguishable from other elements to satisfy
    // the mathematical definition of a set.  a.eq(b) must give the same
    // result as b.eq(a).
    Eq(elem) bool
    // String result is used only for printable output.  Given a, b where
    // a.eq(b), it is not required that a.String() == b.String().
    fmt.Stringer
}
 
// integer type satisfying element interface
type Int int
 
func (i Int) Eq(e elem) bool {
    j, ok := e.(Int)
    return ok && i == j
}
 
func (i Int) String() string {
    return strconv.Itoa(int(i))
}
 
// a set is a slice of elem's.  methods are added to implement
// the element interface, to allow nesting.
type set []elem
 
// uniqueness of elements can be ensured by using add method
func (s *set) add(e elem) {
    if !s.has(e) {
        *s = append(*s, e)
    }
}
 
func (s *set) has(e elem) bool {
    for _, ex := range *s {
        if e.Eq(ex) {
            return true
        }
    }
    return false
}
 
func (s set) ok() bool {
    for i, e0 := range s {
        for _, e1 := range s[i+1:] {
            if e0.Eq(e1) {
                return false
            }
        }
    }
    return true
}
 
// elem.Eq
func (s set) Eq(e elem) bool {
    t, ok := e.(set)
    if !ok {
        return false
    }
    if len(s) != len(t) {
        return false
    }
    for _, se := range s {
        if !t.has(se) {
            return false
        }
    }
    return true
}
 
// elem.String
func (s set) String() string {
    if len(s) == 0 {
        return ""∅""
    }
    var buf strings.Builder
    buf.WriteRune('{')
    for i, e := range s {
        if i > 0 {
            buf.WriteRune(',')
        }
        buf.WriteString(e.String())
    }
    buf.WriteRune('}')
    return buf.String()
}
 
// method required for task
func (s set) powerSet() set {
    r := set{set{}}
    for _, es := range s {
        var u set
        for _, er := range r {
            er := er.(set)
            u = append(u, append(er[:len(er):len(er)], es))
        }
        r = append(r, u...)
    }
    return r
}
 
func main() {
    var s set
    for _, i := range []Int{1, 2, 2, 3, 4, 4, 4} {
        s.add(i)
    }
    fmt.Println(""      s:"", s, ""length:"", len(s))
    ps := s.powerSet()
    fmt.Println(""   𝑷(s):"", ps, ""length:"", len(ps))
 
    fmt.Println(""\n(extra credit)"")
    var empty set
    fmt.Println(""  empty:"", empty, ""len:"", len(empty))
    ps = empty.powerSet()
    fmt.Println(""   𝑷(∅):"", ps, ""len:"", len(ps))
    ps = ps.powerSet()
    fmt.Println(""𝑷(𝑷(∅)):"", ps, ""len:"", len(ps))
 
    fmt.Println(""\n(regression test for earlier bug)"")
    s = set{Int(1), Int(2), Int(3), Int(4), Int(5)}
    fmt.Println(""      s:"", s, ""length:"", len(s), ""ok:"", s.ok())
    ps = s.powerSet()
    fmt.Println(""   𝑷(s):"", ""length:"", len(ps), ""ok:"", ps.ok())
    for _, e := range ps {
        if !e.(set).ok() {
            panic(""invalid set in ps"")
        }
    }
}",3180,141
27204,http://rosettacode.org/wiki/Population_count,Population count,"Population count

You are encouraged to solve this task according to the task description, using any language you may know.
The   population count   is the number of   1s   (ones)   in the binary representation of a non-negative integer.

Population count   is also known as:

   pop count
   popcount 
   sideways sum
   bit summation 
   Hamming weight 


For example,   5   (which is   101   in binary)   has a population count of   2.


Evil numbers   are non-negative integers that have an   even   population count.

Odious numbers     are  positive integers that have an    odd   population count.



Task

 write a function (or routine) to return the population count of a non-negative integer.
 all computation of the lists below should start with   0   (zero indexed).
 display the   pop count   of the   1st   thirty powers of   3       (30,   31,   32,   33,   34,   ∙∙∙   329).
 display the   1st   thirty     evil     numbers.
 display the   1st   thirty   odious   numbers.
 display each list of integers on one line   (which may or may not include a title),   each set of integers being shown should be properly identified.


See also
 The On-Line Encyclopedia of Integer Sequences:   A000120 population count.
 The On-Line Encyclopedia of Integer Sequences:   A000069 odious numbers.
 The On-Line Encyclopedia of Integer Sequences:   A001969 evil numbers.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/bits""
)
 
func main() {
    fmt.Println(""Pop counts, powers of 3:"")
    n := uint64(1) // 3^0
    for i := 0; i < 30; i++ {
        fmt.Printf(""%d "", bits.OnesCount64(n))
        n *= 3
    }
    fmt.Println()
    fmt.Println(""Evil numbers:"")
    var od [30]uint64
    var ne, no int
    for n = 0; ne+no < 60; n++ {
        if bits.OnesCount64(n)&1 == 0 {
            if ne < 30 {
                fmt.Printf(""%d "", n)
                ne++
            }
        } else {
            if no < 30 {
                od[no] = n
                no++
            }
        }
    }
    fmt.Println()
    fmt.Println(""Odious numbers:"")
    for _, n := range od {
        fmt.Printf(""%d "", n)
    }
    fmt.Println()
}",752,38
27399,http://rosettacode.org/wiki/Primality_by_trial_division,Primality by trial division,"Task

Write a boolean function that tells whether a given integer is prime.



Remember that   1   and all non-positive numbers are not prime.

Use trial division.

Even numbers greater than   2   may be eliminated right away.

A loop from   3   to   √ n    will suffice,   but other loops are allowed.



Related tasks

   count in factors
   prime decomposition
   AKS test for primes
   factors of an integer
   Sieve of Eratosthenes
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",#Go,Go,"func IsPrime(n int) bool {
	if n < 0 { n = -n }
	switch {
        case n == 2:
		return true
	case n < 2 || n % 2 == 0:
		return false
 
	default:
		for i = 3; i*i <= n; i += 2 {
			if n % i == 0 { return false }
		}
	}
	return true
}",234,15
27560,http://rosettacode.org/wiki/Pinstripe/Printer,Pinstripe/Printer,"The task is to demonstrate the creation of a series of 1 point wide vertical pinstripes with a sufficient number of pinstripes to span the entire width of the printed page (except for the last pinstripe). The pinstripes should alternate one point white, one point black. (Where the printer does not support producing graphics in terms of points, pixels may be substituted in this task.)

After the first inch of printing, we switch to a wider 2 point wide vertical pinstripe pattern. alternating two points white, two points black. We then switch to 3 points wide for the next inch, and then 4 points wide, etc. This trend continues for the entire length of the page (or for 12 inches of run length in the case of a printer using continuous roll stationery). After printing the test pattern the page is ejected (or the test pattern is rolled clear of the printer enclosure, in the case of continuous roll printers).

Note that it is an acceptable solution to use the smallest marks that the language provides, rather than working at native printer resolution, where this is not achievable from within the language.

Optionally, on systems where the printer resolution cannot be determined, it is permissible to prompt the user for printer resolution, and to calculate point size based on user input, enabling fractional point sizes to be used.
",#Go,Go,"package main
 
import (
    ""github.com/fogleman/gg""
    ""log""
    ""os/exec""
    ""runtime""
)
 
var palette = [2]string{
    ""FFFFFF"", // white
    ""000000"", // black    
}
 
func pinstripe(dc *gg.Context) {
    w := dc.Width()
    h := dc.Height() / 7
    for b := 1; b <= 11; b++ {
        for x, ci := 0, 0; x < w; x, ci = x+b, ci+1 {
            dc.SetHexColor(palette[ci%2])
            y := h * (b - 1)
            dc.DrawRectangle(float64(x), float64(y), float64(b), float64(h))
            dc.Fill()
        }
    }
}
 
func main() {
    dc := gg.NewContext(842, 595)
    pinstripe(dc)
    fileName := ""w_pinstripe.png""
    dc.SavePNG(fileName)
    var cmd *exec.Cmd
    if runtime.GOOS == ""windows"" {
        cmd = exec.Command(""mspaint"", ""/pt"", fileName)
    } else {
        cmd = exec.Command(""lp"", fileName)
    }
    if err := cmd.Run(); err != nil {
        log.Fatal(err)
    }
}",894,42
27583,http://rosettacode.org/wiki/Play_recorded_sounds,Play recorded sounds,"Load at least two prerecorded sounds, and demonstrate as many of these features as you can:

 playing them individually and simultaneously
 stopping before the end of the sound
 looping (preferably glitch-free)
 setting the volume of each sound
 stereo or 3D positional mixing
 performing other actions when marked times in the sound arrive
Describe:

 The supported audio formats, briefly.
 Whether it is suitable for game sound effects (low-latency start, resource efficiency, supports many simultaneous sounds, etc.)
 Whether it is suitable for playing music (long duration ).
[Note: If it seems to be a good idea, this task may be revised to specify a particular timeline rather than just 'demonstrate these features'.]

Where applicable, please categorize examples primarily by the audio facility used (library/API/program/platform) rather than the language if the language is incidental (e.g. ""Mac OS X CoreAudio"" or ""mplayer"" rather than ""C"" or ""bash"").
",#Go,Go,"package main
 
import (
    ""log""
    ""os""
    ""os/exec""
)
 
func main() {
    args := []string{
        ""-m"", ""-v"", ""0.75"", ""a.wav"", ""-v"", ""0.25"", ""b.wav"",
        ""-d"",
        ""trim"", ""4"", ""6"",
        ""repeat"", ""5"",
    }
    cmd := exec.Command(""sox"", args...)
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    if err := cmd.Run(); err != nil {
        log.Fatal(err)
    }
}",388,22
27600,http://rosettacode.org/wiki/Pisano_period,Pisano period,"The Fibonacci sequence taken modulo 2 is a periodic sequence of period 3 : 0, 1, 1, 0, 1, 1, ...

For any integer n, the Fibonacci sequence taken modulo n is periodic and the length of the periodic cycle is referred to as the Pisano period.

Prime numbers are straightforward; the Pisano period of a prime number p is simply: pisano(p). The Pisano period of a composite number c may be found in different ways. It may be calculated directly: pisano(c), which works, but may be time consuming to find, especially for larger integers, or, it may be calculated by finding the least common multiple of the Pisano periods of each composite component.



E.G.

Given a Pisano period function: pisano(x), and a least common multiple function lcm(x, y):

   pisano(m × n) is equivalent to lcm(pisano(m), pisano(n)) where  m  and  n  are coprime

A formulae to calculate the pisano period for integer powers   k   of prime numbers   p   is:

   pisano(pk) == p(k-1)pisano(p) 

The equation is conjectured, no exceptions have been seen.

If a positive integer   i   is split into its prime factors,   then the second and first equations above can be applied to generate the pisano period.



Task
Write 2 functions: pisanoPrime(p,k) and pisano(m).

pisanoPrime(p,k) should return the Pisano period of pk where p is prime and k is a positive integer.

pisano(m) should use pisanoPrime to return the Pisano period of m where m is a positive integer.

Print pisanoPrime(p,2) for every prime lower than 15.

Print pisanoPrime(p,1) for every prime lower than 180.

Print pisano(m) for every integer from 1 to 180.



Related tasks
  Fibonacci sequence
  Prime decomposition
  Least common multiple

",#Go,Go,"package main
 
import ""fmt""
 
func gcd(a, b uint) uint {
    if b == 0 {
        return a
    }
    return gcd(b, a%b)
}
 
func lcm(a, b uint) uint {
    return a / gcd(a, b) * b
}
 
func ipow(x, p uint) uint {
    prod := uint(1)
    for p > 0 {
        if p&1 != 0 {
            prod *= x
        }
        p >>= 1
        x *= x
    }
    return prod
}
 
// Gets the prime decomposition of n.
func getPrimes(n uint) []uint {
    var primes []uint
    for i := uint(2); i <= n; i++ {
        div := n / i
        mod := n % i
        for mod == 0 {
            primes = append(primes, i)
            n = div
            div = n / i
            mod = n % i
        }
    }
    return primes
}
 
// OK for 'small' numbers.
func isPrime(n uint) bool {
    switch {
    case n < 2:
        return false
    case n%2 == 0:
        return n == 2
    case n%3 == 0:
        return n == 3
    default:
        d := uint(5)
        for d*d <= n {
            if n%d == 0 {
                return false
            }
            d += 2
            if n%d == 0 {
                return false
            }
            d += 4
        }
        return true
    }
}
 
// Calculates the Pisano period of 'm' from first principles.
func pisanoPeriod(m uint) uint {
    var p, c uint = 0, 1
    for i := uint(0); i < m*m; i++ {
        p, c = c, (p+c)%m
        if p == 0 && c == 1 {
            return i + 1
        }
    }
    return 1
}
 
// Calculates the Pisano period of p^k where 'p' is prime and 'k' is a positive integer.
func pisanoPrime(p uint, k uint) uint {
    if !isPrime(p) || k == 0 {
        return 0 // can't do this one
    }
    return ipow(p, k-1) * pisanoPeriod(p)
}
 
// Calculates the Pisano period of 'm' using pisanoPrime.
func pisano(m uint) uint {
    primes := getPrimes(m)
    primePowers := make(map[uint]uint)
    for _, p := range primes {
        primePowers[p]++
    }
    var pps []uint
    for k, v := range primePowers {
        pps = append(pps, pisanoPrime(k, v))
    }
    if len(pps) == 0 {
        return 1
    }
    if len(pps) == 1 {
        return pps[0]
    }    
    f := pps[0]
    for i := 1; i < len(pps); i++ {
        f = lcm(f, pps[i])
    }
    return f
}
 
func main() {
    for p := uint(2); p < 15; p++ {
        pp := pisanoPrime(p, 2)
        if pp > 0 {
            fmt.Printf(""pisanoPrime(%2d: 2) = %d\n"", p, pp)
        }
    }
    fmt.Println()
    for p := uint(2); p < 180; p++ {
        pp := pisanoPrime(p, 1)
        if pp > 0 {
            fmt.Printf(""pisanoPrime(%3d: 1) = %d\n"", p, pp)
        }
    }
    fmt.Println()
    fmt.Println(""pisano(n) for integers 'n' from 1 to 180 are:"")
    for n := uint(1); n <= 180; n++ {
        fmt.Printf(""%3d "", pisano(n))
        if n != 1 && n%15 == 0 {
            fmt.Println()
        }
    }    
    fmt.Println()
}",2817,136
27667,http://rosettacode.org/wiki/Plasma_effect,Plasma effect,"The plasma effect is a visual effect created by applying various functions, notably sine and cosine, to the color values of screen pixels. When animated (not a task requirement) the effect may give the impression of a colorful flowing liquid.



Task
Create a plasma effect.




See also
 Computer Graphics Tutorial (lodev.org)
 Plasma (bidouille.org)

",#Go,Go,"  $ convert plasma.gif -coalesce plasma2.gif
  $ eog plasma2.gif
",65,3
27668,http://rosettacode.org/wiki/Playfair_cipher,Playfair cipher,"Playfair cipher

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Implement a  Playfair cipher for encryption and decryption.



The user must be able to choose   J  =  I     or   no   Q   in the alphabet.

The output of the encrypted and decrypted message must be in capitalized digraphs, separated by spaces.



Output example

                HI DE TH EG OL DI NT HE TR EX ES TU MP


",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""os""
    ""strings""
)
 
type playfairOption int
 
const (
    noQ playfairOption = iota
    iEqualsJ
)
 
type playfair struct {
    keyword string
    pfo     playfairOption
    table   [5][5]byte
}
 
func (p *playfair) init() {
    // Build table.
    var used [26]bool // all elements false
    if p.pfo == noQ {
        used[16] = true // Q used
    } else {
        used[9] = true // J used
    }
    alphabet := strings.ToUpper(p.keyword) + ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    for i, j, k := 0, 0, 0; k < len(alphabet); k++ {
        c := alphabet[k]
        if c < 'A' || c > 'Z' {
            continue
        }
        d := int(c - 65)
        if !used[d] {
            p.table[i][j] = c
            used[d] = true
            j++
            if j == 5 {
                i++
                if i == 5 {
                    break // table has been filled
                }
                j = 0
            }
        }
    }
}
 
func (p *playfair) getCleanText(plainText string) string {
    // Ensure everything is upper case.
    plainText = strings.ToUpper(plainText)
    // Get rid of any non-letters and insert X between duplicate letters.
    var cleanText strings.Builder
    // Safe to assume null byte won't be present in plainText.
    prevByte := byte('\000')
    for i := 0; i < len(plainText); i++ {
        nextByte := plainText[i]
        // It appears that Q should be omitted altogether if NO_Q option is specified;
        // we assume so anyway.
        if nextByte < 'A' || nextByte > 'Z' || (nextByte == 'Q' && p.pfo == noQ) {
            continue
        }
        // If iEqualsJ option specified, replace J with I.
        if nextByte == 'J' && p.pfo == iEqualsJ {
            nextByte = 'I'
        }
        if nextByte != prevByte {
            cleanText.WriteByte(nextByte)
        } else {
            cleanText.WriteByte('X')
            cleanText.WriteByte(nextByte)
        }
        prevByte = nextByte
    }
    l := cleanText.Len()
    if l%2 == 1 {
        // Dangling letter at end so add another letter to complete digram.
        if cleanText.String()[l-1] != 'X' {
            cleanText.WriteByte('X')
        } else {
            cleanText.WriteByte('Z')
        }
    }
    return cleanText.String()
}
 
func (p *playfair) findByte(c byte) (int, int) {
    for i := 0; i < 5; i++ {
        for j := 0; j < 5; j++ {
            if p.table[i][j] == c {
                return i, j
            }
        }
    }
    return -1, -1
}
 
func (p *playfair) encode(plainText string) string {
    cleanText := p.getCleanText(plainText)
    var cipherText strings.Builder
    l := len(cleanText)
    for i := 0; i < l; i += 2 {
        row1, col1 := p.findByte(cleanText[i])
        row2, col2 := p.findByte(cleanText[i+1])
        switch {
        case row1 == row2:
            cipherText.WriteByte(p.table[row1][(col1+1)%5])
            cipherText.WriteByte(p.table[row2][(col2+1)%5])
        case col1 == col2:
            cipherText.WriteByte(p.table[(row1+1)%5][col1])
            cipherText.WriteByte(p.table[(row2+1)%5][col2])
        default:
            cipherText.WriteByte(p.table[row1][col2])
            cipherText.WriteByte(p.table[row2][col1])
        }
        if i < l-1 {
            cipherText.WriteByte(' ')
        }
    }
    return cipherText.String()
}
 
func (p *playfair) decode(cipherText string) string {
    var decodedText strings.Builder
    l := len(cipherText)
    // cipherText will include spaces so we need to skip them.
    for i := 0; i < l; i += 3 {
        row1, col1 := p.findByte(cipherText[i])
        row2, col2 := p.findByte(cipherText[i+1])
        switch {
        case row1 == row2:
            temp := 4
            if col1 > 0 {
                temp = col1 - 1
            }
            decodedText.WriteByte(p.table[row1][temp])
            temp = 4
            if col2 > 0 {
                temp = col2 - 1
            }
            decodedText.WriteByte(p.table[row2][temp])
        case col1 == col2:
            temp := 4
            if row1 > 0 {
                temp = row1 - 1
            }
            decodedText.WriteByte(p.table[temp][col1])
            temp = 4
            if row2 > 0 {
                temp = row2 - 1
            }
            decodedText.WriteByte(p.table[temp][col2])
        default:
            decodedText.WriteByte(p.table[row1][col2])
            decodedText.WriteByte(p.table[row2][col1])
        }
        if i < l-1 {
            decodedText.WriteByte(' ')
        }
    }
    return decodedText.String()
}
 
func (p *playfair) printTable() {
    fmt.Println(""The table to be used is :\n"")
    for i := 0; i < 5; i++ {
        for j := 0; j < 5; j++ {
            fmt.Printf(""%c "", p.table[i][j])
        }
        fmt.Println()
    }
}
 
func main() {
    scanner := bufio.NewScanner(os.Stdin)
    fmt.Print(""Enter Playfair keyword : "")
    scanner.Scan()
    keyword := scanner.Text()
    var ignoreQ string
    for ignoreQ != ""y"" && ignoreQ != ""n"" {
        fmt.Print(""Ignore Q when building table  y/n : "")
        scanner.Scan()
        ignoreQ = strings.ToLower(scanner.Text())
    }
    pfo := noQ
    if ignoreQ == ""n"" {
        pfo = iEqualsJ
    }
    var table [5][5]byte
    pf := &playfair{keyword, pfo, table}
    pf.init()
    pf.printTable()
    fmt.Print(""\nEnter plain text : "")
    scanner.Scan()
    plainText := scanner.Text()
    if err := scanner.Err(); err != nil {
        fmt.Fprintln(os.Stderr, ""reading standard input:"", err)
        return
    }
    encodedText := pf.encode(plainText)
    fmt.Println(""\nEncoded text is :"", encodedText)
    decodedText := pf.decode(encodedText)
    fmt.Println(""Deccoded text is :"", decodedText)
}",5738,208
27670,http://rosettacode.org/wiki/Pinstripe/Display,Pinstripe/Display," Sample image
The task is to demonstrate the creation of a series of vertical pinstripes across the entire width of the display.

 in the first quarter the pinstripes should alternate one pixel white, one pixel black = 1 pixel wide vertical pinestripes
 Quarter of the way down the display, we can switch to a wider 2 pixel wide vertical pinstripe pattern, alternating two pixels white, two pixels black. 
 Half way down the display, we switch to 3 pixels wide, 
 for the lower quarter of the display we use 4 pixels.


c.f. Colour_pinstripe/Display
",#Go,Go,"package main
 
import ""github.com/fogleman/gg""
 
var palette = [2]string{
    ""FFFFFF"", // white
    ""000000"", // black    
}
 
func pinstripe(dc *gg.Context) {
    w := dc.Width()
    h := dc.Height() / 4
    for b := 1; b <= 4; b++ {
        for x, ci := 0, 0; x < w; x, ci = x+b, ci+1 {
            dc.SetHexColor(palette[ci%2])
            y := h * (b - 1)
            dc.DrawRectangle(float64(x), float64(y), float64(b), float64(h))
            dc.Fill()
        }
    }
}
 
func main() {
    dc := gg.NewContext(900, 600)
    pinstripe(dc)
    dc.SavePNG(""w_pinstripe.png"")
}",581,27
27727,http://rosettacode.org/wiki/Pig_the_dice_game/Player,Pig the dice game/Player,"Pig the dice game/Player

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a dice simulator and scorer of Pig the dice game and add to it the ability to play the game to at least one strategy.

 State here the play strategies involved.
 Show play during a game here.


As a stretch goal:

 Simulate playing the game a number of times with two players of given strategies and report here summary statistics such as, but not restricted to, the influence of going first or which strategy seems stronger.


Game Rules

The game of Pig is a multiplayer game played with a single six-sided die. The
object of the game is to reach 100 points or more.
Play is taken in turns. On each person's turn that person has the option of either

 Rolling the dice: where a roll of two to six is added to their score for that turn and the player's turn continues as the player is given the same choice again; or a roll of 1 loses the player's total points for that turn and their turn finishes with play passing to the next player.
 Holding: The player's score for that round is added to their total and becomes safe from the effects of throwing a one. The player's turn finishes with play passing to the next player.


References
 Pig (dice)
 The Math of Being a Pig and Pigs (extra) - Numberphile videos featuring Ben Sparks.

",#Go,Go,"package pig
 
import (
	""fmt""
	""math/rand""
	""time""
)
 
type (
	PlayerID   int
	MessageID  int
	StrategyID int
 
	PigGameData struct {
		player        PlayerID
		turnCount     int
		turnRollCount int
		turnScore     int
		lastRoll      int
		scores        [2]int
		verbose       bool
	}
)
 
const (
	// Status messages
	gameOver = iota
	piggedOut
	rolls
	pointSpending
	holds
	turn
	gameOverSummary
	// Players
	player1  = PlayerID(0)
	player2  = PlayerID(1)
	noPlayer = PlayerID(-1)
	// Max score
	maxScore = 100
	// Strategies
	scoreChaseStrat = iota
	rollCountStrat
)
 
// Returns ""s"" if n != 1
func pluralS(n int) string {
	if n != 1 {
		return ""s""
	}
	return """"
}
 
// Creates an intializes a new PigGameData structure, returns a *PigGameData
func New() *PigGameData {
	return &PigGameData{0, 0, 0, 0, 0, [2]int{0, 0}, false}
}
 
// Create a status message for a given message ID
func (pg *PigGameData) statusMessage(id MessageID) string {
	var msg string
	switch id {
	case gameOver:
		msg = fmt.Sprintf(""Game is over after %d turns"", pg.turnCount)
	case piggedOut:
		msg = fmt.Sprintf(""    Pigged out after %d roll%s"", pg.turnRollCount, pluralS(pg.turnRollCount))
	case rolls:
		msg = fmt.Sprintf(""    Rolls %d"", pg.lastRoll)
	case pointSpending:
		msg = fmt.Sprintf(""    %d point%s pending"", pg.turnScore, pluralS(pg.turnScore))
	case holds:
		msg = fmt.Sprintf(""    Holds after %d turns, adding %d points for a total of %d"", pg.turnRollCount, pg.turnScore, pg.PlayerScore(noPlayer))
	case turn:
		msg = fmt.Sprintf(""Player %d's turn:"", pg.player+1)
	case gameOverSummary:
		msg = fmt.Sprintf(""Game over after %d turns\n player 1 %d\n player 2 %d\n"", pg.turnCount, pg.PlayerScore(player1), pg.PlayerScore(player2))
	}
	return msg
}
 
// Print a status message, if pg.Verbose is true
func (pg *PigGameData) PrintStatus(id MessageID) {
	if pg.verbose {
		fmt.Println(pg.statusMessage(id))
	}
}
 
// Play a given strategy
func (pg *PigGameData) Play(id StrategyID) (keepPlaying bool) {
	if pg.GameOver() {
		pg.PrintStatus(gameOver)
		return false
	}
 
	if pg.turnCount == 0 {
		pg.player = player2
		pg.NextPlayer()
	}
 
	pg.lastRoll = rand.Intn(6) + 1
	pg.PrintStatus(rolls)
	pg.turnRollCount++
	if pg.lastRoll == 1 {
		pg.PrintStatus(piggedOut)
		pg.NextPlayer()
	} else {
		pg.turnScore += pg.lastRoll
		pg.PrintStatus(pointSpending)
		success := false
		switch id {
		case scoreChaseStrat:
			success = pg.scoreChaseStrategy()
		case rollCountStrat:
			success = pg.rollCountStrategy()
		}
		if success {
			pg.Hold()
			pg.NextPlayer()
		}
	}
	return true
}
 
// Get the score for a given player
func (pg *PigGameData) PlayerScore(id PlayerID) int {
	if id == noPlayer {
		return pg.scores[pg.player]
	}
	return pg.scores[id]
}
 
// Check if the game is over
func (pg *PigGameData) GameOver() bool {
	return pg.scores[player1] >= maxScore || pg.scores[player2] >= maxScore
}
 
// Returns the Player ID if there is a winner, or -1
func (pg *PigGameData) Winner() PlayerID {
	for index, score := range pg.scores {
		if score >= maxScore {
			return PlayerID(index)
		}
	}
	return noPlayer
}
 
// Get the ID of the other player
func (pg *PigGameData) otherPlayer() PlayerID {
	// 0 becomes 1, 1 becomes 0
	return 1 - pg.player
}
 
func (pg *PigGameData) Hold() {
	pg.scores[pg.player] += pg.turnScore
	pg.PrintStatus(holds)
	pg.turnRollCount, pg.turnScore = 0, 0
}
 
func (pg *PigGameData) NextPlayer() {
	pg.turnCount++
	pg.turnRollCount, pg.turnScore = 0, 0
	pg.player = pg.otherPlayer()
	pg.PrintStatus(turn)
}
 
func (pg *PigGameData) rollCountStrategy() bool {
	return pg.turnRollCount >= 3
}
 
func (pg *PigGameData) scoreChaseStrategy() bool {
	myScore := pg.PlayerScore(pg.player)
	otherScore := pg.PlayerScore(pg.otherPlayer())
	myPendingScore := pg.turnScore + myScore
	return myPendingScore >= maxScore || myPendingScore > otherScore || pg.turnRollCount >= 5
}
 
// Run the simulation
func main() {
	// Seed the random number generator
	rand.Seed(time.Now().UnixNano())
 
	// Start a new game
	pg := New()
	pg.verbose = true
	strategies := [2]StrategyID{scoreChaseStrat, rollCountStrat}
 
	// Play until game over
	for !pg.GameOver() {
		pg.Play(strategies[pg.player])
	}
	pg.PrintStatus(gameOverSummary)
}",4224,191
27850,http://rosettacode.org/wiki/Permutations/Rank_of_a_permutation,Permutations/Rank of a permutation,"A particular ranking of a permutation associates an integer with a particular ordering of all the permutations of a set of distinct items.
For our purposes the ranking will assign integers 



0..
(
n
!
−
1
)


{\displaystyle 0..(n!-1)}

 to an ordering of all the permutations of the integers 



0..
(
n
−
1
)


{\displaystyle 0..(n-1)}

.

For example, the permutations of the digits zero to 3 arranged lexicographically have the following rank:

  PERMUTATION      RANK
  (0, 1, 2, 3) ->  0
  (0, 1, 3, 2) ->  1
  (0, 2, 1, 3) ->  2
  (0, 2, 3, 1) ->  3
  (0, 3, 1, 2) ->  4
  (0, 3, 2, 1) ->  5
  (1, 0, 2, 3) ->  6
  (1, 0, 3, 2) ->  7
  (1, 2, 0, 3) ->  8
  (1, 2, 3, 0) ->  9
  (1, 3, 0, 2) -> 10
  (1, 3, 2, 0) -> 11
  (2, 0, 1, 3) -> 12
  (2, 0, 3, 1) -> 13
  (2, 1, 0, 3) -> 14
  (2, 1, 3, 0) -> 15
  (2, 3, 0, 1) -> 16
  (2, 3, 1, 0) -> 17
  (3, 0, 1, 2) -> 18
  (3, 0, 2, 1) -> 19
  (3, 1, 0, 2) -> 20
  (3, 1, 2, 0) -> 21
  (3, 2, 0, 1) -> 22
  (3, 2, 1, 0) -> 23
Algorithms exist that can generate a rank from a permutation for some particular ordering of permutations, and that can generate the same rank from the given individual permutation (i.e. given a rank of 17 produce (2, 3, 1, 0) in the example above).

One use of such algorithms could be in generating a small, random, sample of permutations of 



n


{\displaystyle n}

 items without duplicates when the total number of permutations is large. Remember that the total number of permutations of 



n


{\displaystyle n}

 items is given by 



n
!


{\displaystyle n!}

 which grows large very quickly: A 32 bit integer can only hold 



12
!


{\displaystyle 12!}

, a 64 bit integer only 



20
!


{\displaystyle 20!}

. It becomes difficult to take the straight-forward approach of generating all permutations then taking a random sample of them.

A question on the Stack Overflow site asked how to generate one million random and indivudual permutations of 144 items.



Task

 Create a function to generate a permutation from a rank.
 Create the inverse function that given the permutation generates its rank.
 Show that for 



n
=
3


{\displaystyle n=3}

 the two functions are indeed inverses of each other.
 Compute and show here 4 random, individual, samples of permutations of 12 objects.


Stretch goal

 State how reasonable it would be to use your program to address the limits of the Stack Overflow question.


References

 Ranking and Unranking Permutations in Linear Time by Myrvold & Ruskey. (Also available via Google here).
 Ranks on the DevData site.
 Another answer on Stack Overflow to a different question that explains its algorithm in detail.


Related tasks

Factorial_base_numbers_indexing_permutations_of_a_collection

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
)
 
// returns permutation q of n items, using Myrvold-Ruskey rank.
func MRPerm(q, n int) []int {
    p := ident(n)
    var r int
    for n > 0 {
        q, r = q/n, q%n
        n--
        p[n], p[r] = p[r], p[n]
    }
    return p
}
 
// returns identity permutation of n items.
func ident(n int) []int {
    p := make([]int, n)
    for i := range p {
        p[i] = i
    }
    return p
}
 
// returns Myrvold-Ruskey rank of permutation p
func MRRank(p []int) (r int) {
    p = append([]int{}, p...)
    inv := inverse(p)
    for i := len(p) - 1; i > 0; i-- {
        s := p[i]
        p[inv[i]] = s
        inv[s] = inv[i]
    }
    for i := 1; i < len(p); i++ {
        r = r*(i+1) + p[i]
    }
    return
}
 
// returns inverse of a permutation.
func inverse(p []int) []int {
    r := make([]int, len(p))
    for i, x := range p {
        r[x] = i
    }
    return r
}
 
// returns n!
func fact(n int) (f int) {
    for f = n; n > 2; {
        n--
        f *= n
    }
    return
}
 
func main() {
    n := 3
    fmt.Println(""permutations of"", n, ""items"")
    f := fact(n)
    for i := 0; i < f; i++ {
        p := MRPerm(i, n)
        fmt.Println(i, p, MRRank(p))
    }
    n = 12
    fmt.Println(""permutations of"", n, ""items"")
    f = fact(n)
    m := map[int]bool{}
    for len(m) < 4 {
        r := rand.Intn(f)
        if m[r] {
            continue
        }
        m[r] = true
        fmt.Println(r, MRPerm(r, n))
    }
}",1485,82
27863,http://rosettacode.org/wiki/Pierpont_primes,Pierpont primes,"A Pierpont prime is a prime number of the form: 2u3v + 1 for some non-negative integers  u  and  v .



A Pierpont prime of the second kind is a prime number of the form: 2u3v - 1 for some non-negative integers  u  and  v .


The term ""Pierpont primes"" is generally understood to mean the first definition, but will be called ""Pierpont primes of the first kind"" on this page to distinguish them.



Task

 Write a routine (function, procedure, whatever) to find Pierpont primes of the first & second kinds.
 Use the routine to find and display here, on this page, the first 50 Pierpont primes of the first kind.
 Use the routine to find and display here, on this page, the first 50 Pierpont primes of the second kind
 If your language supports large integers, find and display here, on this page, the 250th Pierpont prime of the first kind and the 250th Pierpont prime of the second kind.


See also

 Wikipedia - Pierpont primes
 OEIS:A005109 - Class 1 -, or Pierpont primes
 OEIS:A005105 - Class 1 +, or Pierpont primes of the second kind

",#Go,Go,"package main
 
import (
    ""fmt""
    big ""github.com/ncw/gmp""
    ""sort""
)
 
var (
    one   = new(big.Int).SetUint64(1)
    two   = new(big.Int).SetUint64(2)
    three = new(big.Int).SetUint64(3)
)
 
func pierpont(ulim, vlim int, first bool) []*big.Int {
    p := new(big.Int)
    p2 := new(big.Int).Set(one)
    p3 := new(big.Int).Set(one)   
    var pp []*big.Int
    for v := 0; v < vlim; v++ {
        for u := 0; u < ulim; u++ {
            p.Mul(p2, p3)
            if first {
                p.Add(p, one)
            } else {
                p.Sub(p, one)
            }
            if p.ProbablyPrime(10) {
                q := new(big.Int)
                q.Set(p)
                pp = append(pp, q)
            }
            p2.Mul(p2, two)
        }
        p3.Mul(p3, three)
        p2.Set(one)
    }
    sort.Slice(pp, func(i, j int) bool {
        return pp[i].Cmp(pp[j]) < 0
    })
    return pp
}
func main() {
    fmt.Println(""First 50 Pierpont primes of the first kind:"")
    pp := pierpont(120, 80, true)
    for i := 0; i < 50; i++ {
        fmt.Printf(""%8d "", pp[i])
        if (i-9)%10 == 0 {
            fmt.Println()
        }
    }
    fmt.Println(""\nFirst 50 Pierpont primes of the second kind:"")
    pp2 := pierpont(120, 80, false)
    for i := 0; i < 50; i++ {
        fmt.Printf(""%8d "", pp2[i])
        if (i-9)%10 == 0 {
            fmt.Println()
        }
    }
    fmt.Println(""\n250th Pierpont prime of the first kind:"", pp[249])
    fmt.Println(""\n250th Pierpont prime of the second kind:"", pp2[249])
}",1538,62
27957,http://rosettacode.org/wiki/Pig_the_dice_game,Pig the dice game,"The   game of Pig   is a multiplayer game played with a single six-sided die.   The
object of the game is to reach   100   points or more.  
Play is taken in turns.   On each person's turn that person has the option of either:

 Rolling the dice:   where a roll of two to six is added to their score for that turn and the player's turn continues as the player is given the same choice again;   or a roll of   1   loses the player's total points   for that turn   and their turn finishes with play passing to the next player.
 Holding:   the player's score for that round is added to their total and becomes safe from the effects of throwing a   1   (one).   The player's turn finishes with play passing to the next player.


Task

Create a program to score for, and simulate dice throws for, a two-person game.



Related task

   Pig the dice game/Player

",#Go,Go,"package main
 
import (
	""fmt""
	""math/rand""
	""strings""
	""time""
)
 
func main() {
	rand.Seed(time.Now().UnixNano()) //Set seed to current time
 
	playerScores := [...]int{0, 0}
	turn := 0
	currentScore := 0
 
	for {
		player := turn % len(playerScores)
 
		fmt.Printf(""Player %v [%v, %v], (H)old, (R)oll or (Q)uit: "", player,
			playerScores[player], currentScore)
 
		var answer string
		fmt.Scanf(""%v"", &answer)
		switch strings.ToLower(answer) {
		case ""h"": //Hold
			playerScores[player] += currentScore
			fmt.Printf(""    Player %v now has a score of %v.\n\n"", player, playerScores[player])
 
			if playerScores[player] >= 100 {
				fmt.Printf(""    Player %v wins!!!\n"", player)
				return
			}
 
			currentScore = 0
			turn += 1
		case ""r"": //Roll
			roll := rand.Intn(6) + 1
 
			if roll == 1 {
				fmt.Printf(""    Rolled a 1. Bust!\n\n"")
				currentScore = 0
				turn += 1
			} else {
				fmt.Printf(""    Rolled a %v.\n"", roll)
				currentScore += roll
			}
		case ""q"": //Quit
			return
		default: //Incorrent input
			fmt.Print(""  Please enter one of the given inputs.\n"")
		}
	}
	fmt.Printf(""Player %v wins!!!\n"", (turn-1)%len(playerScores))
}",1152,55
28007,http://rosettacode.org/wiki/Periodic_table,Periodic table,"Task

Display the row and column in the periodic table of the given atomic number.

The periodic table

Let us consider the following periodic table representation.

     __________________________________________________________________________ 
    |   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18 |
    |                                                                          |
    |1  H                                                                   He |
    |                                                                          |
    |2  Li  Be                                          B   C   N   O   F   Ne |
    |                                                                          |
    |3  Na  Mg                                          Al  Si  P   S   Cl  Ar |
    |                                                                          |
    |4  K   Ca  Sc  Ti  V   Cr  Mn  Fe  Co  Ni  Cu  Zn  Ga  Ge  As  Se  Br  Kr |
    |                                                                          |
    |5  Rb  Sr  Y   Zr  Nb  Mo  Tc  Ru  Rh  Pd  Ag  Cd  In  Sn  Sb  Te  I   Xe |
    |                                                                          |
    |6  Cs  Ba  *   Hf  Ta  W   Re  Os  Ir  Pt  Au  Hg  Tl  Pb  Bi  Po  At  Rn |
    |                                                                          |
    |7  Fr  Ra  °   Rf  Db  Sg  Bh  Hs  Mt  Ds  Rg  Cn  Nh  Fl  Mc  Lv  Ts  Og |
    |__________________________________________________________________________|
    |                                                                          |
    |                                                                          |
    |8  Lantanoidi* La  Ce  Pr  Nd  Pm  Sm  Eu  Gd  Tb  Dy  Ho  Er  Tm  Yb  Lu |
    |                                                                          |
    |9   Aktinoidi° Ak  Th  Pa  U   Np  Pu  Am  Cm  Bk  Cf  Es  Fm  Md  No  Lr |
    |__________________________________________________________________________|

Example test cases;
   1 -> 1 1
   2 -> 1 18
   29 -> 4 11
   42 -> 5 6
   57 -> 8 4
   58 -> 8 5
   72 -> 6 4
   89 -> 9 4
Details;
The representation of the periodic table may be represented in various way. The one presented in this challenge does have the following property : Lantanides and Aktinoides are all in a dedicated row, hence there is no element that is placed at 6, 3 nor 7, 3.

You may take a look at the atomic number repartitions here.

The atomic number is at least 1, at most 118.



See also
 
   the periodic table
   This task was an idea from CompSciFact
   The periodic table in ascii that was used as template

",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
)
 
var limits = [][2]int{
    {3, 10}, {11, 18}, {19, 36}, {37, 54}, {55, 86}, {87, 118},
}
 
func periodicTable(n int) (int, int) {
    if n < 1 || n > 118 {
        log.Fatal(""Atomic number is out of range."")
    }
    if n == 1 {
        return 1, 1
    }
    if n == 2 {
        return 1, 18
    }
    if n >= 57 && n <= 71 {
        return 8, n - 53
    }
    if n >= 89 && n <= 103 {
        return 9, n - 85
    }
    var row, start, end int
    for i := 0; i < len(limits); i++ {
        limit := limits[i]
        if n >= limit[0] && n <= limit[1] {
            row, start, end = i+2, limit[0], limit[1]
            break
        }
    }
    if n < start+2 || row == 4 || row == 5 {
        return row, n - start + 1
    }
    return row, n - end + 18
}
 
func main() {
    for _, n := range []int{1, 2, 29, 42, 57, 58, 59, 71, 72, 89, 90, 103, 113} {
        row, col := periodicTable(n)
        fmt.Printf(""Atomic number %3d -> %d, %-2d\n"", n, row, col)
    }
}",1017,47
28065,http://rosettacode.org/wiki/Permutation_test,Permutation test,"Permutation test

You are encouraged to solve this task according to the task description, using any language you may know.
A new medical treatment was tested on a population of 



n
+
m


{\displaystyle n+m}


volunteers, with each volunteer randomly assigned either to a group of




n


{\displaystyle n}

 treatment subjects, or to a group of 



m


{\displaystyle m}

 control subjects.

Members of the treatment group were given the treatment,
and members of the control group were given a placebo.
The effect of the treatment or placebo on each volunteer
was measured and reported in this table.


 Table of experimental results


 Treatment group 
 Control group


 85 
 68


 88 
 41


 75 
 10


 66 
 49


 25 
 16


 29 
 65


 83 
 32


 39 
 92


 97 
 28


 
 98

Write a program that performs a
permutation test to judge
whether the treatment had a significantly stronger effect than the
placebo.

 Do this by considering every possible alternative assignment from the same pool of volunteers to a treatment group of size 



n


{\displaystyle n}

 and a control group of size 



m


{\displaystyle m}

 (i.e., the same group sizes used in the actual experiment but with the group members chosen differently), while assuming that each volunteer's effect remains constant regardless.
 Note that the number of alternatives will be the binomial coefficient 







(



n
+
m

n


)






{\displaystyle {\tbinom {n+m}{n}}}

.
 Compute the mean effect for each group and the difference in means between the groups in every case by subtracting the mean of the control group from the mean of the treatment group.
 Report the percentage of alternative groupings for which the difference in means is less or equal to the actual experimentally observed difference in means, and the percentage for which it is greater.
 Note that they should sum to 100%.


Extremely dissimilar values are evidence of an effect not entirely due
to chance, but your program need not draw any conclusions.

You may assume the experimental data are known at compile time if
that's easier than loading them at run time. Test your solution on the
data given above.



",#Go,Go,"package main
 
import ""fmt""
 
var tr = []int{85, 88, 75, 66, 25, 29, 83, 39, 97}
var ct = []int{68, 41, 10, 49, 16, 65, 32, 92, 28, 98}
 
func main() {
    // collect all results in a single list
    all := make([]int, len(tr)+len(ct))
    copy(all, tr)
    copy(all[len(tr):], ct)
 
    // compute sum of all data, useful as intermediate result
    var sumAll int
    for _, r := range all {
        sumAll += r
    }
 
    // closure for computing scaled difference.
    // compute results scaled by len(tr)*len(ct).
    // this allows all math to be done in integers.
    sd := func(trc []int) int {
        var sumTr int
        for _, x := range trc {
            sumTr += all[x]
        }
        return sumTr*len(ct) - (sumAll-sumTr)*len(tr)
    }
 
    // compute observed difference, as an intermediate result
    a := make([]int, len(tr))
    for i, _ := range a {
        a[i] = i
    }
    sdObs := sd(a)
 
    // iterate over all combinations.  for each, compute (scaled)
    // difference and tally whether leq or gt observed difference.
    var nLe, nGt int
    comb(len(all), len(tr), func(c []int) {
        if sd(c) > sdObs {
            nGt++
        } else {
            nLe++
        }
    })
 
    // print results as percentage
    pc := 100 / float64(nLe+nGt)
    fmt.Printf(""differences <= observed: %f%%\n"", float64(nLe)*pc)
    fmt.Printf(""differences  > observed: %f%%\n"", float64(nGt)*pc)
}
 
// combination generator, copied from combination task
func comb(n, m int, emit func([]int)) {
    s := make([]int, m)
    last := m - 1
    var rc func(int, int)
    rc = func(i, next int) {
        for j := next; j < n; j++ {
            s[i] = j
            if i == last {
                emit(s)
            } else {
                rc(i+1, j+1)
            }
        }
        return
    }
    rc(0, 0)
}",1831,72
28111,http://rosettacode.org/wiki/Phrase_reversals,Phrase reversals,"Task

Given a string of space separated words containing the following phrase:

 rosetta code phrase reversal

 Reverse the characters of the string.
 Reverse the characters of each individual word in the string, maintaining original word order within the string.
 Reverse the order of each word of the string, maintaining the order of characters in each word.


Show your output here.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
	""fmt""
	""strings""
)
 
const phrase = ""rosetta code phrase reversal""
 
func revStr(s string) string {
	rs := make([]rune, len(s))
	i := len(s)
	for _, r := range s {
		i--
		rs[i] = r
	}
	return string(rs[i:])
}
 
func main() {
	fmt.Println(""Reversed:           "", revStr(phrase))
 
	ws := strings.Fields(phrase)
	for i, w := range ws {
		ws[i] = revStr(w)
	}
	fmt.Println(""Words reversed:     "", strings.Join(ws, "" ""))
 
	ws = strings.Fields(phrase)
	last := len(ws) - 1
	for i, w := range ws[:len(ws)/2] {
		ws[i], ws[last-i] = ws[last-i], w
	}
	fmt.Println(""Word order reversed:"", strings.Join(ws, "" ""))
}",631,35
28136,http://rosettacode.org/wiki/Pick_random_element,Pick random element,"Demonstrate how to pick a random element from a list.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
var list = []string{""bleen"", ""fuligin"", ""garrow"", ""grue"", ""hooloovoo""}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    fmt.Println(list[rand.Intn(len(list))])
}",234,14
28141,http://rosettacode.org/wiki/Permutations_by_swapping,Permutations by swapping,"Task

Generate permutations of n items in which successive permutations differ from each other by the swapping of any two items.

Also generate the sign of the permutation which is +1 when the permutation is generated from an even number of swaps from the initial state, and -1 for odd.

Show the permutations and signs of three items, in order of generation here.

Such data are of use in generating the determinant of a square matrix and any functions created should bear this in mind.

Note: The Steinhaus–Johnson–Trotter algorithm generates successive permutations where adjacent items are swapped, but from this discussion adjacency is not a requirement.



References

 Steinhaus–Johnson–Trotter algorithm
 Johnson-Trotter Algorithm Listing All Permutations
 Heap's algorithm
 [1] Tintinnalogia


Related tasks

   Matrix arithmetic
   Gray code

",#Go,Go,"package permute
 
// Iter takes a slice p and returns an iterator function.  The iterator
// permutes p in place and returns the sign.  After all permutations have
// been generated, the iterator returns 0 and p is left in its initial order.
func Iter(p []int) func() int {
    f := pf(len(p))
    return func() int {
        return f(p)
    }
}
 
// Recursive function used by perm, returns a chain of closures that
// implement a loopless recursive SJT.
func pf(n int) func([]int) int {
    sign := 1
    switch n {
    case 0, 1:
        return func([]int) (s int) {
            s = sign
            sign = 0
            return
        }
    default:
        p0 := pf(n - 1)
        i := n
        var d int
        return func(p []int) int {
            switch {
            case sign == 0:
            case i == n:
                i--
                sign = p0(p[:i])
                d = -1
            case i == 0:
                i++
                sign *= p0(p[1:])
                d = 1
                if sign == 0 {
                    p[0], p[1] = p[1], p[0]
                }
            default:
                p[i], p[i-1] = p[i-1], p[i]
                sign = -sign
                i += d
            }
            return sign
        }
    }
}",1262,50
28151,http://rosettacode.org/wiki/Percolation/Site_percolation,Percolation/Site percolation,"
Percolation Simulation

This is a simulation of aspects of mathematical percolation theory.

For other percolation simulations, see Category:Percolation Simulations, or:
1D finite grid simulation
Mean run density 
2D finite grid simulations
Site percolation | Bond percolation | Mean cluster density

Given an 



M
×
N


{\displaystyle M\times N}

 rectangular array of cells numbered 




c
e
l
l

[
0..
M
−
1
,
0..
N
−
1
]


{\displaystyle \mathrm {cell} [0..M-1,0..N-1]}

assume 



M


{\displaystyle M}

 is horizontal and 



N


{\displaystyle N}

 is downwards.

Assume that the probability of any cell being filled is a constant 



p


{\displaystyle p}

 where

 



0.0
≤
p
≤
1.0


{\displaystyle 0.0\leq p\leq 1.0}


The task

Simulate creating the array of cells with probability 



p


{\displaystyle p}

 and then
testing if there is a route through adjacent filled cells from any on row 



0


{\displaystyle 0}

 to any on row 



N


{\displaystyle N}

, i.e. testing for site percolation.

Given 



p


{\displaystyle p}

 repeat the percolation 



t


{\displaystyle t}

 times to estimate the proportion of times that the fluid can percolate to the bottom for any given 



p


{\displaystyle p}

.

Show how the probability of percolating through the random grid changes with 



p


{\displaystyle p}

 going from 



0.0


{\displaystyle 0.0}

 to 



1.0


{\displaystyle 1.0}

 in 



0.1


{\displaystyle 0.1}

 increments and with the number of repetitions to estimate the fraction at any given 



p


{\displaystyle p}

 as 



t
>=
100


{\displaystyle t>=100}

.

Use an 



M
=
15
,
N
=
15


{\displaystyle M=15,N=15}

 grid of cells for all cases.

Optionally depict a percolation through a cell grid graphically.

Show all output on this page.
",#Go,Go,"package main
 
import (
	""bytes""
	""fmt""
	""math/rand""
	""time""
)
 
func main() {
	const (
		m, n           = 15, 15
		t              = 1e4
		minp, maxp, Δp = 0, 1, 0.1
	)
 
	rand.Seed(2) // Fixed seed for repeatable example grid
	g := NewGrid(.5, m, n)
	g.Percolate()
	fmt.Println(g)
 
	rand.Seed(time.Now().UnixNano()) // could pick a better seed
	for p := float64(minp); p < maxp; p += Δp {
		count := 0
		for i := 0; i < t; i++ {
			g := NewGrid(p, m, n)
			if g.Percolate() {
				count++
			}
		}
		fmt.Printf(""p=%.2f, %.4f\n"", p, float64(count)/t)
	}
}
 
const (
	full  = '.'
	used  = '#'
	empty = ' '
)
 
type grid struct {
	cell [][]byte // row first, i.e. [y][x]
}
 
func NewGrid(p float64, xsize, ysize int) *grid {
	g := &grid{cell: make([][]byte, ysize)}
	for y := range g.cell {
		g.cell[y] = make([]byte, xsize)
		for x := range g.cell[y] {
			if rand.Float64() < p {
				g.cell[y][x] = full
			} else {
				g.cell[y][x] = empty
			}
		}
	}
	return g
}
 
func (g *grid) String() string {
	var buf bytes.Buffer
	// Don't really need to call Grow but it helps avoid multiple
	// reallocations if the size is large.
	buf.Grow((len(g.cell) + 2) * (len(g.cell[0]) + 3))
 
	buf.WriteByte('+')
	for _ = range g.cell[0] {
		buf.WriteByte('-')
	}
	buf.WriteString(""+\n"")
 
	for y := range g.cell {
		buf.WriteByte('|')
		buf.Write(g.cell[y])
		buf.WriteString(""|\n"")
	}
 
	buf.WriteByte('+')
	ly := len(g.cell) - 1
	for x := range g.cell[ly] {
		if g.cell[ly][x] == used {
			buf.WriteByte(used)
		} else {
			buf.WriteByte('-')
		}
	}
	buf.WriteByte('+')
	return buf.String()
}
 
func (g *grid) Percolate() bool {
	for x := range g.cell[0] {
		if g.use(x, 0) {
			return true
		}
	}
	return false
}
 
func (g *grid) use(x, y int) bool {
	if y < 0 || x < 0 || x >= len(g.cell[0]) || g.cell[y][x] != full {
		return false // Off the edges, empty, or used
	}
	g.cell[y][x] = used
	if y+1 == len(g.cell) {
		return true // We're on the bottom
	}
 
	// Try down, right, left, up in that order.
	return g.use(x, y+1) ||
		g.use(x+1, y) ||
		g.use(x-1, y) ||
		g.use(x, y-1)
}",2072,114
28176,http://rosettacode.org/wiki/Percolation/Mean_cluster_density,Percolation/Mean cluster density,"
Percolation Simulation

This is a simulation of aspects of mathematical percolation theory.

For other percolation simulations, see Category:Percolation Simulations, or:
1D finite grid simulation
Mean run density 
2D finite grid simulations
Site percolation | Bond percolation | Mean cluster density

Let 



c


{\displaystyle c}

 be a 2D boolean square matrix of 



n
×
n


{\displaystyle n\times n}

 values of either 1 or 0 where the
probability of any value being 1 is 



p


{\displaystyle p}

, (and of 0 is therefore 



1
−
p


{\displaystyle 1-p}

).
We define a cluster of 1's as being a group of 1's connected vertically or
horizontally (i.e., using the Von Neumann neighborhood rule) and bounded by either 



0


{\displaystyle 0}

 or by the limits of the matrix.
Let the number of such clusters in such a randomly constructed matrix be 




C

n




{\displaystyle C_{n}}

.

Percolation theory states that 



K
(
p
)


{\displaystyle K(p)}

 (the mean cluster density) will satisfy 



K
(
p
)
=

C

n



/


n

2




{\displaystyle K(p)=C_{n}/n^{2}}

 as 



n


{\displaystyle n}

 tends to infinity. For 



p
=
0.5


{\displaystyle p=0.5}

, 



K
(
p
)


{\displaystyle K(p)}

 is found numerically to approximate 



0.065770


{\displaystyle 0.065770}

...

Task
Show the effect of varying 



n


{\displaystyle n}

 on the accuracy of simulated 



K
(
p
)


{\displaystyle K(p)}

 for 



p
=
0.5


{\displaystyle p=0.5}

 and
for values of 



n


{\displaystyle n}

 up to at least 



1000


{\displaystyle 1000}

.
Any calculation of 




C

n




{\displaystyle C_{n}}

 for finite 



n


{\displaystyle n}

 is subject to randomness, so an approximation should be
computed as the average of 



t


{\displaystyle t}

 runs, where 



t


{\displaystyle t}

 ≥ 



5


{\displaystyle 5}

.

For extra credit, graphically show clusters in a 



15
×
15


{\displaystyle 15\times 15}

, 



p
=
0.5


{\displaystyle p=0.5}

 grid.

Show your output here.

See also
 s-Cluster on Wolfram mathworld.",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
var (
    n_range = []int{4, 64, 256, 1024, 4096}
    M       = 15
    N       = 15
)
 
const (
    p             = .5
    t             = 5
    NOT_CLUSTERED = 1
    cell2char     = "" #abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ""
)
 
func newgrid(n int, p float64) [][]int {
    g := make([][]int, n)
    for y := range g {
        gy := make([]int, n)
        for x := range gy {
            if rand.Float64() < p {
                gy[x] = 1
            }
        }
        g[y] = gy
    }
    return g
}
 
func pgrid(cell [][]int) {
    for n := 0; n < N; n++ {
        fmt.Print(n%10, "") "")
        for m := 0; m < M; m++ {
            fmt.Printf("" %c"", cell2char[cell[n][m]])
        }
        fmt.Println()
    }
}
 
func cluster_density(n int, p float64) float64 {
    cc := clustercount(newgrid(n, p))
    return float64(cc) / float64(n) / float64(n)
}
 
func clustercount(cell [][]int) int {
    walk_index := 1
    for n := 0; n < N; n++ {
        for m := 0; m < M; m++ {
            if cell[n][m] == NOT_CLUSTERED {
                walk_index++
                walk_maze(m, n, cell, walk_index)
            }
        }
    }
    return walk_index - 1
}
 
func walk_maze(m, n int, cell [][]int, indx int) {
    cell[n][m] = indx
    if n < N-1 && cell[n+1][m] == NOT_CLUSTERED {
        walk_maze(m, n+1, cell, indx)
    }
    if m < M-1 && cell[n][m+1] == NOT_CLUSTERED {
        walk_maze(m+1, n, cell, indx)
    }
    if m > 0 && cell[n][m-1] == NOT_CLUSTERED {
        walk_maze(m-1, n, cell, indx)
    }
    if n > 0 && cell[n-1][m] == NOT_CLUSTERED {
        walk_maze(m, n-1, cell, indx)
    }
}
 
func main() {
    rand.Seed(time.Now().Unix())
    cell := newgrid(N, .5)
    fmt.Printf(""Found %d clusters in this %d by %d grid\n\n"",
        clustercount(cell), N, N)
    pgrid(cell)
    fmt.Println()
 
    for _, n := range n_range {
        M = n
        N = n
        sum := 0.
        for i := 0; i < t; i++ {
            sum += cluster_density(n, p)
        }
        sim := sum / float64(t)
        fmt.Printf(""t=%3d p=%4.2f n=%5d sim=%7.5f\n"", t, p, n, sim)
    }
}",2165,98
28204,http://rosettacode.org/wiki/Percolation/Bond_percolation,Percolation/Bond percolation,"
Percolation Simulation

This is a simulation of aspects of mathematical percolation theory.

For other percolation simulations, see Category:Percolation Simulations, or:
1D finite grid simulation
Mean run density 
2D finite grid simulations
Site percolation | Bond percolation | Mean cluster density

Given an 



M
×
N


{\displaystyle M\times N}

 rectangular array of cells numbered 




c
e
l
l

[
0..
M
−
1
,
0..
N
−
1
]


{\displaystyle \mathrm {cell} [0..M-1,0..N-1]}

, assume 



M


{\displaystyle M}

 is horizontal and 



N


{\displaystyle N}

 is downwards. Each 




c
e
l
l

[
m
,
n
]


{\displaystyle \mathrm {cell} [m,n]}

 is bounded by (horizontal) walls 




h
w
a
l
l

[
m
,
n
]


{\displaystyle \mathrm {hwall} [m,n]}

 and 




h
w
a
l
l

[
m
+
1
,
n
]


{\displaystyle \mathrm {hwall} [m+1,n]}

; (vertical) walls 




v
w
a
l
l

[
m
,
n
]


{\displaystyle \mathrm {vwall} [m,n]}

 and 




v
w
a
l
l

[
m
,
n
+
1
]


{\displaystyle \mathrm {vwall} [m,n+1]}



Assume that the probability of any wall being present is a constant 



p


{\displaystyle p}

 where

 



0.0
≤
p
≤
1.0


{\displaystyle 0.0\leq p\leq 1.0}


Except for the outer horizontal walls at 



m
=
0


{\displaystyle m=0}

 and 



m
=
M


{\displaystyle m=M}

 which are always present.

The task

Simulate pouring a fluid onto the top surface (



n
=
0


{\displaystyle n=0}

) where the fluid will enter any empty cell it is adjacent to if there is no wall between where it currently is and the cell on the other side of the (missing) wall.

The fluid does not move beyond the horizontal constraints of the grid.

The fluid may move “up” within the confines of the grid of cells. If the fluid reaches a bottom cell that has a missing bottom wall then the fluid can be said to 'drip' out the bottom at that point.

Given 



p


{\displaystyle p}

 repeat the percolation 



t


{\displaystyle t}

 times to estimate the proportion of times that the fluid can percolate to the bottom for any given 



p


{\displaystyle p}

.

Show how the probability of percolating through the random grid changes with 



p


{\displaystyle p}

 going from 



0.0


{\displaystyle 0.0}

 to 



1.0


{\displaystyle 1.0}

 in 



0.1


{\displaystyle 0.1}

 increments and with the number of repetitions to estimate the fraction at any given 



p


{\displaystyle p}

 as 



t
=
100


{\displaystyle t=100}

.

Use an 



M
=
10
,
N
=
10


{\displaystyle M=10,N=10}

 grid of cells for all cases.

Optionally depict fluid successfully percolating through a grid graphically.

Show all output on this page.



",#Go,Go,"package main
 
import (
	""fmt""
	""math/rand""
	""strings""
	""time""
)
 
func main() {
	const (
		m, n           = 10, 10
		t              = 1000
		minp, maxp, Δp = 0.1, 0.99, 0.1
	)
 
	// Purposely don't seed for a repeatable example grid:
	g := NewGrid(.5, m, n)
	g.Percolate()
	fmt.Println(g)
 
	rand.Seed(time.Now().UnixNano()) // could pick a better seed
	for p := float64(minp); p < maxp; p += Δp {
		count := 0
		for i := 0; i < t; i++ {
			g := NewGrid(p, m, n)
			if g.Percolate() {
				count++
			}
		}
		fmt.Printf(""p=%.2f, %.3f\n"", p, float64(count)/t)
	}
}
 
type cell struct {
	full        bool
	right, down bool // true if open to the right (x+1) or down (y+1)
}
 
type grid struct {
	cell [][]cell // row first, i.e. [y][x]
}
 
func NewGrid(p float64, xsize, ysize int) *grid {
	g := &grid{cell: make([][]cell, ysize)}
	for y := range g.cell {
		g.cell[y] = make([]cell, xsize)
		for x := 0; x < xsize-1; x++ {
			if rand.Float64() > p {
				g.cell[y][x].right = true
			}
			if rand.Float64() > p {
				g.cell[y][x].down = true
			}
		}
		if rand.Float64() > p {
			g.cell[y][xsize-1].down = true
		}
	}
	return g
}
 
var (
	full  = map[bool]string{false: ""  "", true: ""**""}
	hopen = map[bool]string{false: ""--"", true: ""  ""}
	vopen = map[bool]string{false: ""|"", true: "" ""}
)
 
func (g *grid) String() string {
	var buf strings.Builder
	// Don't really need to call Grow but it helps avoid multiple
	// reallocations if the size is large.
	buf.Grow((len(g.cell) + 1) * len(g.cell[0]) * 7)
 
	for _ = range g.cell[0] {
		buf.WriteString(""+"")
		buf.WriteString(hopen[false])
	}
	buf.WriteString(""+\n"")
	for y := range g.cell {
		buf.WriteString(vopen[false])
		for x := range g.cell[y] {
			buf.WriteString(full[g.cell[y][x].full])
			buf.WriteString(vopen[g.cell[y][x].right])
		}
		buf.WriteByte('\n')
		for x := range g.cell[y] {
			buf.WriteString(""+"")
			buf.WriteString(hopen[g.cell[y][x].down])
		}
		buf.WriteString(""+\n"")
	}
	ly := len(g.cell) - 1
	for x := range g.cell[ly] {
		buf.WriteByte(' ')
		buf.WriteString(full[g.cell[ly][x].down && g.cell[ly][x].full])
	}
	return buf.String()
}
 
func (g *grid) Percolate() bool {
	for x := range g.cell[0] {
		if g.fill(x, 0) {
			return true
		}
	}
	return false
}
 
func (g *grid) fill(x, y int) bool {
	if y >= len(g.cell) {
		return true // Out the bottom
	}
	if g.cell[y][x].full {
		return false // Allready filled
	}
	g.cell[y][x].full = true
 
	if g.cell[y][x].down && g.fill(x, y+1) {
		return true
	}
	if g.cell[y][x].right && g.fill(x+1, y) {
		return true
	}
	if x > 0 && g.cell[y][x-1].right && g.fill(x-1, y) {
		return true
	}
	if y > 0 && g.cell[y-1][x].down && g.fill(x, y-1) {
		return true
	}
	return false
}",2689,132
28205,http://rosettacode.org/wiki/Percolation/Mean_run_density,Percolation/Mean run density,"
Percolation Simulation

This is a simulation of aspects of mathematical percolation theory.

For other percolation simulations, see Category:Percolation Simulations, or:
1D finite grid simulation
Mean run density 
2D finite grid simulations
Site percolation | Bond percolation | Mean cluster density

Let 



v


{\displaystyle v}

 be a vector of 



n


{\displaystyle n}

 values of either 1 or 0 where the probability of any
value being 1 is 



p


{\displaystyle p}

; the probability of a value being 0 is therefore 



1
−
p


{\displaystyle 1-p}

.
Define a run of 1s as being a group of consecutive 1s in the vector bounded
either by the limits of the vector or by a 0. Let the number of such runs in a given
vector of length 



n


{\displaystyle n}

 be 




R

n




{\displaystyle R_{n}}

.

For example, the following vector has 




R

10


=
3


{\displaystyle R_{10}=3}



[1 1 0 0 0 1 0 1 1 1]
 ^^^       ^   ^^^^^

Percolation theory states that





K
(
p
)
=

lim

n
→
∞



R

n



/

n
=
p
(
1
−
p
)


{\displaystyle K(p)=\lim _{n\to \infty }R_{n}/n=p(1-p)}


Task
Any calculation of 




R

n



/

n


{\displaystyle R_{n}/n}

 for finite 



n


{\displaystyle n}

 is subject to randomness so should be
computed as the average of 



t


{\displaystyle t}

 runs, where 



t
≥
100


{\displaystyle t\geq 100}

.

For values of 



p


{\displaystyle p}

 of 0.1, 0.3, 0.5, 0.7, and 0.9, show the effect of varying 



n


{\displaystyle n}


on the accuracy of simulated 



K
(
p
)


{\displaystyle K(p)}

.

Show your output here.

See also
 s-Run on Wolfram mathworld.",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
)
 
var (
    pList = []float64{.1, .3, .5, .7, .9}
    nList = []int{1e2, 1e3, 1e4, 1e5}
    t     = 100
)
 
func main() {
    for _, p := range pList {
        theory := p * (1 - p)
        fmt.Printf(""\np: %.4f  theory: %.4f  t: %d\n"", p, theory, t)
        fmt.Println(""        n          sim     sim-theory"")
        for _, n := range nList {
            sum := 0
            for i := 0; i < t; i++ {
                run := false
                for j := 0; j < n; j++ {
                    one := rand.Float64() < p
                    if one && !run {
                        sum++
                    }
                    run = one
                }
            }
            K := float64(sum) / float64(t) / float64(n)
            fmt.Printf(""%9d %15.4f %9.6f\n"", n, K, K-theory)
        }
    }
}",857,35
28210,http://rosettacode.org/wiki/Perlin_noise,Perlin noise,"The   Perlin noise   is a kind of   gradient noise   invented by   Ken Perlin   around the end of the twentieth century and still currently heavily used in   computer graphics,   most notably to procedurally generate textures or heightmaps.

The Perlin noise is basically a   pseudo-random   mapping of   





R


d




{\displaystyle \mathbb {R} ^{d}}

   into   




R



{\displaystyle \mathbb {R} }

   with an integer   



d


{\displaystyle d}

   which can be arbitrarily large but which is usually   2,   3,   or   4.

Either by using a dedicated library or by implementing the algorithm, show that the Perlin noise   (as defined in 2002 in the Java implementation below)   of the point in 3D-space with coordinates     3.14,   42,   7     is     0.13691995878400012.


Note: this result assumes 64 bit IEEE-754 floating point calculations. If your language uses a different floating point representation, make a note of it and calculate the value accurate to 15 decimal places, or your languages accuracy threshold if it is less. Trailing zeros need not be displayed.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func main() {
    fmt.Println(noise(3.14, 42, 7))
}
 
func noise(x, y, z float64) float64 {
    X := int(math.Floor(x)) & 255
    Y := int(math.Floor(y)) & 255
    Z := int(math.Floor(z)) & 255
    x -= math.Floor(x)
    y -= math.Floor(y)
    z -= math.Floor(z)
    u := fade(x)
    v := fade(y)
    w := fade(z)
    A := p[X] + Y
    AA := p[A] + Z
    AB := p[A+1] + Z
    B := p[X+1] + Y
    BA := p[B] + Z
    BB := p[B+1] + Z
    return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z),
        grad(p[BA], x-1, y, z)),
        lerp(u, grad(p[AB], x, y-1, z),
            grad(p[BB], x-1, y-1, z))),
        lerp(v, lerp(u, grad(p[AA+1], x, y, z-1),
            grad(p[BA+1], x-1, y, z-1)),
            lerp(u, grad(p[AB+1], x, y-1, z-1),
                grad(p[BB+1], x-1, y-1, z-1))))
}
func fade(t float64) float64       { return t * t * t * (t*(t*6-15) + 10) }
func lerp(t, a, b float64) float64 { return a + t*(b-a) }
func grad(hash int, x, y, z float64) float64 {
    // Go doesn't have a ternary.  Ternaries can be translated directly
    // with if statements, but chains of if statements are often better
    // expressed with switch statements.
    switch hash & 15 {
    case 0, 12:
        return x + y
    case 1, 14:
        return y - x
    case 2:
        return x - y
    case 3:
        return -x - y
    case 4:
        return x + z
    case 5:
        return z - x
    case 6:
        return x - z
    case 7:
        return -x - z
    case 8:
        return y + z
    case 9, 13:
        return z - y
    case 10:
        return y - z
    }
    // case 11, 16:
    return -y - z
}
 
var permutation = []int{
    151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225,
    140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148,
    247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32,
    57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175,
    74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122,
    60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54,
    65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169,
    200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64,
    52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212,
    207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213,
    119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,
    129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104,
    218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241,
    81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157,
    184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93,
    222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
}
var p = append(permutation, permutation...)",2959,89
28212,http://rosettacode.org/wiki/Perfect_totient_numbers,Perfect totient numbers,"Generate and show here, the first twenty Perfect totient numbers.



Related task

   Totient function


Also see

   the OEIS entry for   perfect totient numbers.
   mrob   list of the first 54

",#Go,Go,"package main
 
import ""fmt""
 
func gcd(n, k int) int {
    if n < k || k < 1 {
        panic(""Need n >= k and k >= 1"")
    }
 
    s := 1
    for n&1 == 0 && k&1 == 0 {
        n >>= 1
        k >>= 1
        s <<= 1
    }
 
    t := n
    if n&1 != 0 {
        t = -k
    }
    for t != 0 {
        for t&1 == 0 {
            t >>= 1
        }
        if t > 0 {
            n = t
        } else {
            k = -t
        }
        t = n - k
    }
    return n * s
}
 
func totient(n int) int {
    tot := 0
    for k := 1; k <= n; k++ {
        if gcd(n, k) == 1 {
            tot++
        }
    }
    return tot
}
 
func main() {
    var perfect []int
    for n := 1; len(perfect) < 20; n += 2 {
        tot := n
        sum := 0
        for tot != 1 {
            tot = totient(tot)
            sum += tot
        }
        if sum == n {
            perfect = append(perfect, n)
        }
    }
    fmt.Println(""The first 20 perfect totient numbers are:"")
    fmt.Println(perfect)
}",990,60
28228,http://rosettacode.org/wiki/Pentomino_tiling,Pentomino tiling,"A pentomino is a polyomino that consists of 5 squares. There are 12 pentomino shapes,
if you don't count rotations and reflections. Most pentominoes can form their own mirror image through
rotation, but some of them have to be flipped over.

        I                                                                        
        I     L       N                                                 Y        
 FF     I     L      NN     PP     TTT              V       W     X    YY      ZZ
FF      I     L      N      PP      T     U U       V      WW    XXX    Y      Z 
 F      I     LL     N      P       T     UUU     VVV     WW      X     Y     ZZ


A Pentomino tiling is an example of an exact cover problem and can take on many forms.
A traditional tiling presents an 8 by 8 grid, where 4 cells are left uncovered. The other cells are covered
by the 12 pentomino shapes, without overlaps, with every shape only used once.

The 4 uncovered cells should be chosen at random. Note that not all configurations are solvable.



Task
Create an 8 by 8 tiling and print the result.



Example
F I I I I I L N
F F F L L L L N
W F - X Z Z N N
W W X X X Z N V
T W W X - Z Z V
T T T P P V V V
T Y - P P U U U
Y Y Y Y P U - U


Related tasks
 Free polyominoes enumeration

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
var F = [][]int{
    {1, -1, 1, 0, 1, 1, 2, 1}, {0, 1, 1, -1, 1, 0, 2, 0},
    {1, 0, 1, 1, 1, 2, 2, 1}, {1, 0, 1, 1, 2, -1, 2, 0},
    {1, -2, 1, -1, 1, 0, 2, -1}, {0, 1, 1, 1, 1, 2, 2, 1},
    {1, -1, 1, 0, 1, 1, 2, -1}, {1, -1, 1, 0, 2, 0, 2, 1},
}
 
var I = [][]int{{0, 1, 0, 2, 0, 3, 0, 4}, {1, 0, 2, 0, 3, 0, 4, 0}}
 
var L = [][]int{
    {1, 0, 1, 1, 1, 2, 1, 3}, {1, 0, 2, 0, 3, -1, 3, 0},
    {0, 1, 0, 2, 0, 3, 1, 3}, {0, 1, 1, 0, 2, 0, 3, 0}, {0, 1, 1, 1, 2, 1, 3, 1},
    {0, 1, 0, 2, 0, 3, 1, 0}, {1, 0, 2, 0, 3, 0, 3, 1}, {1, -3, 1, -2, 1, -1, 1, 0},
}
 
var N = [][]int{
    {0, 1, 1, -2, 1, -1, 1, 0}, {1, 0, 1, 1, 2, 1, 3, 1},
    {0, 1, 0, 2, 1, -1, 1, 0}, {1, 0, 2, 0, 2, 1, 3, 1}, {0, 1, 1, 1, 1, 2, 1, 3},
    {1, 0, 2, -1, 2, 0, 3, -1}, {0, 1, 0, 2, 1, 2, 1, 3}, {1, -1, 1, 0, 2, -1, 3, -1},
}
 
var P = [][]int{
    {0, 1, 1, 0, 1, 1, 2, 1}, {0, 1, 0, 2, 1, 0, 1, 1},
    {1, 0, 1, 1, 2, 0, 2, 1}, {0, 1, 1, -1, 1, 0, 1, 1}, {0, 1, 1, 0, 1, 1, 1, 2},
    {1, -1, 1, 0, 2, -1, 2, 0}, {0, 1, 0, 2, 1, 1, 1, 2}, {0, 1, 1, 0, 1, 1, 2, 0},
}
 
var T = [][]int{
    {0, 1, 0, 2, 1, 1, 2, 1}, {1, -2, 1, -1, 1, 0, 2, 0},
    {1, 0, 2, -1, 2, 0, 2, 1}, {1, 0, 1, 1, 1, 2, 2, 0},
}
 
var U = [][]int{
    {0, 1, 0, 2, 1, 0, 1, 2}, {0, 1, 1, 1, 2, 0, 2, 1},
    {0, 2, 1, 0, 1, 1, 1, 2}, {0, 1, 1, 0, 2, 0, 2, 1},
}
 
var V = [][]int{
    {1, 0, 2, 0, 2, 1, 2, 2}, {0, 1, 0, 2, 1, 0, 2, 0},
    {1, 0, 2, -2, 2, -1, 2, 0}, {0, 1, 0, 2, 1, 2, 2, 2},
}
 
var W = [][]int{
    {1, 0, 1, 1, 2, 1, 2, 2}, {1, -1, 1, 0, 2, -2, 2, -1},
    {0, 1, 1, 1, 1, 2, 2, 2}, {0, 1, 1, -1, 1, 0, 2, -1},
}
 
var X = [][]int{{1, -1, 1, 0, 1, 1, 2, 0}}
 
var Y = [][]int{
    {1, -2, 1, -1, 1, 0, 1, 1}, {1, -1, 1, 0, 2, 0, 3, 0},
    {0, 1, 0, 2, 0, 3, 1, 1}, {1, 0, 2, 0, 2, 1, 3, 0}, {0, 1, 0, 2, 0, 3, 1, 2},
    {1, 0, 1, 1, 2, 0, 3, 0}, {1, -1, 1, 0, 1, 1, 1, 2}, {1, 0, 2, -1, 2, 0, 3, 0},
}
 
var Z = [][]int{
    {0, 1, 1, 0, 2, -1, 2, 0}, {1, 0, 1, 1, 1, 2, 2, 2},
    {0, 1, 1, 1, 2, 1, 2, 2}, {1, -2, 1, -1, 1, 0, 2, -2},
}
 
var shapes = [][][]int{F, I, L, N, P, T, U, V, W, X, Y, Z}
 
var symbols = []byte(""FILNPTUVWXYZ-"")
 
const (
    nRows = 8
    nCols = 8
    blank = 12
)
 
var grid [nRows][nCols]int
var placed [12]bool
 
func tryPlaceOrientation(o []int, r, c, shapeIndex int) bool {
    for i := 0; i < len(o); i += 2 {
        x := c + o[i+1]
        y := r + o[i]
        if x < 0 || x >= nCols || y < 0 || y >= nRows || grid[y][x] != -1 {
            return false
        }
    }
    grid[r][c] = shapeIndex
    for i := 0; i < len(o); i += 2 {
        grid[r+o[i]][c+o[i+1]] = shapeIndex
    }
    return true
}
 
func removeOrientation(o []int, r, c int) {
    grid[r][c] = -1
    for i := 0; i < len(o); i += 2 {
        grid[r+o[i]][c+o[i+1]] = -1
    }
}
 
func solve(pos, numPlaced int) bool {
    if numPlaced == len(shapes) {
        return true
    }
    row := pos / nCols
    col := pos % nCols
    if grid[row][col] != -1 {
        return solve(pos+1, numPlaced)
    }
 
    for i := range shapes {
        if !placed[i] {
            for _, orientation := range shapes[i] {
                if !tryPlaceOrientation(orientation, row, col, i) {
                    continue
                }
                placed[i] = true
                if solve(pos+1, numPlaced+1) {
                    return true
                }
                removeOrientation(orientation, row, col)
                placed[i] = false
            }
        }
    }
    return false
}
 
func shuffleShapes() {
    rand.Shuffle(len(shapes), func(i, j int) {
        shapes[i], shapes[j] = shapes[j], shapes[i]
        symbols[i], symbols[j] = symbols[j], symbols[i]
    })
}
 
func printResult() {
    for _, r := range grid {
        for _, i := range r {
            fmt.Printf(""%c "", symbols[i])
        }
        fmt.Println()
    }
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    shuffleShapes()
    for r := 0; r < nRows; r++ {
        for i := range grid[r] {
            grid[r][i] = -1
        }
    }
    for i := 0; i < 4; i++ {
        var randRow, randCol int
        for {
            randRow = rand.Intn(nRows)
            randCol = rand.Intn(nCols)
            if grid[randRow][randCol] != blank {
                break
            }
        }
        grid[randRow][randCol] = blank
    }
    if solve(0, 0) {
        printResult()
    } else {
        fmt.Println(""No solution"")
    }
}",4485,172
28250,http://rosettacode.org/wiki/Permutations/Derangements,Permutations/Derangements,"A derangement is a permutation of the order of distinct items in which no item appears in its original place.

For example, the only two derangements of the three items (0, 1, 2) are (1, 2, 0), and (2, 0, 1).

The number of derangements of n distinct items is known as the subfactorial of n, sometimes written as !n.
There are various ways to calculate !n.



Task

 Create a named function/method/subroutine/... to generate derangements of the integers 0..n-1, (or 1..n if you prefer). 
 Generate and show all the derangements of 4 integers using the above routine.
 Create a function that calculates the subfactorial of n, !n.
 Print and show a table of the counted number of derangements of n vs. the calculated !n for n from 0..9 inclusive.


Optional stretch goal

   Calculate    !20 


Related tasks

   Anagrams/Deranged anagrams
   Best shuffle
   Left_factorials



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
// task 1: function returns list of derangements of n integers
func dList(n int) (r [][]int) {
    a := make([]int, n)
    for i := range a {
        a[i] = i
    }
    // recursive closure permutes a
    var recurse func(last int)
    recurse = func(last int) {
        if last == 0 {
            // bottom of recursion.  you get here once for each permutation.
            // test if permutation is deranged.
            for j, v := range a {
                if j == v {
                    return // no, ignore it
                }
            }
            // yes, save a copy
            r = append(r, append([]int{}, a...))
            return
        }
        for i := last; i >= 0; i-- {
            a[i], a[last] = a[last], a[i]
            recurse(last - 1)
            a[i], a[last] = a[last], a[i]
        }
    }
    recurse(n - 1)
    return
}
 
// task 3: function computes subfactorial of n
func subFact(n int) *big.Int {
    if n == 0 {
        return big.NewInt(1)
    } else if n == 1 {
        return big.NewInt(0)
    }
    d0 := big.NewInt(1)
    d1 := big.NewInt(0)
    f := new(big.Int)
    for i, n64 := int64(1), int64(n); i < n64; i++ {
        d0, d1 = d1, d0.Mul(f.SetInt64(i), d0.Add(d0, d1))
    }
    return d1
}
 
func main() {
    // task 2:
    fmt.Println(""Derangements of 4 integers"")
    for _, d := range dList(4) {
        fmt.Println(d)
    }
 
    // task 4:
    fmt.Println(""\nNumber of derangements"")
    fmt.Println(""N  Counted  Calculated"")
    for n := 0; n <= 9; n++ {
        fmt.Printf(""%d %8d %11s\n"", n, len(dList(n)), subFact(n).String())
    }
 
    // stretch (sic)
    fmt.Println(""\n!20 ="", subFact(20))
}",1715,71
28329,http://rosettacode.org/wiki/Playing_cards,Playing cards,"Task

Create a data structure and the associated methods to define and manipulate a deck of   playing cards.

The deck should contain 52 unique cards.

The methods must include the ability to:

   make a new deck
   shuffle (randomize) the deck
   deal from the deck
   print the current contents of a deck 
Each card must have a pip value and a suit value which constitute the unique value of the card.

Related tasks:

 Card shuffles
 Deal cards_for_FreeCell
 War Card_Game
 Poker hand_analyser
 Go Fish

",#Go,Go,"package cards
 
import (
	""math/rand""
)
 
// A Suit represents one of the four standard suites.
type Suit uint8
 
// The four standard suites.
const (
	Spade   Suit = 3
	Heart   Suit = 2
	Diamond Suit = 1
	Club    Suit = 0
)
 
func (s Suit) String() string {
	const suites = ""CDHS"" // or ""♣♢♡♠""
	return suites[s : s+1]
}
 
// Rank is the rank or pip value of a card from Ace==1 to King==13.
type Rank uint8
 
// The ranks from Ace to King.
const (
	Ace   Rank = 1
	Two   Rank = 2
	Three Rank = 3
	Four  Rank = 4
	Five  Rank = 5
	Six   Rank = 6
	Seven Rank = 7
	Eight Rank = 8
	Nine  Rank = 9
	Ten   Rank = 10
	Jack  Rank = 11
	Queen Rank = 12
	King  Rank = 13
)
 
func (r Rank) String() string {
	const ranks = ""A23456789TJQK""
	return ranks[r-1 : r]
}
 
// A Card represets a specific playing card.
// It's an encoded representation of Rank and Suit
// with a valid range of [0,51].
type Card uint8
 
// NewCard returns the Card representation for the specified rank and suit.
func NewCard(r Rank, s Suit) Card {
	return Card(13*uint8(s) + uint8(r-1))
}
 
// RankSuit returns the rank and suit of the card.
func (c Card) RankSuit() (Rank, Suit) {
	return Rank(c%13 + 1), Suit(c / 13)
}
 
// Rank returns the rank of the card.
func (c Card) Rank() Rank {
	return Rank(c%13 + 1)
}
 
// Suit returns the suit of the card.
func (c Card) Suit() Suit {
	return Suit(c / 13)
}
 
func (c Card) String() string {
	return c.Rank().String() + c.Suit().String()
}
 
// A Deck represents a set of zero or more cards in a specific order.
type Deck []Card
 
// NewDeck returns a regular 52 deck of cards in A-K order.
func NewDeck() Deck {
	d := make(Deck, 52)
	for i := range d {
		d[i] = Card(i)
	}
	return d
}
 
// String returns a string representation of the cards in the deck with
// a newline ('\n') separating the cards into groups of thirteen.
func (d Deck) String() string {
	s := """"
	for i, c := range d {
		switch {
		case i == 0: // do nothing
		case i%13 == 0:
			s += ""\n""
		default:
			s += "" ""
		}
		s += c.String()
	}
	return s
}
 
// Shuffle randomises the order of the cards in the deck.
func (d Deck) Shuffle() {
	for i := range d {
		j := rand.Intn(i + 1)
		d[i], d[j] = d[j], d[i]
	}
}
 
// Contains returns true if the specified card is withing the deck.
func (d Deck) Contains(tc Card) bool {
	for _, c := range d {
		if c == tc {
			return true
		}
	}
	return false
}
 
// AddDeck adds the specified deck(s) to this one at the end/bottom.
func (d *Deck) AddDeck(decks ...Deck) {
	for _, o := range decks {
		*d = append(*d, o...)
	}
}
 
// AddCard adds the specified card to this deck at the end/bottom.
func (d *Deck) AddCard(c Card) {
	*d = append(*d, c)
}
 
// Draw removes the selected number of cards from the top of the deck,
// returning them as a new deck.
func (d *Deck) Draw(n int) Deck {
	old := *d
	*d = old[n:]
	return old[:n:n]
}
 
// DrawCard draws a single card off the top of the deck,
// removing it from the deck.
// It returns false if there are no cards in the deck.
func (d *Deck) DrawCard() (Card, bool) {
	if len(*d) == 0 {
		return 0, false
	}
	old := *d
	*d = old[1:]
	return old[0], true
}
 
// Deal deals out cards from the deck one at a time to multiple players.
// The initial hands (decks) of each player are provided as arguments and the
// modified hands are returned. The initial hands can be empty or nil.
// E.g. Deal(7, nil, nil, nil) deals out seven cards to three players
// each starting with no cards.
// If there are insufficient cards in the deck the hands are partially dealt and
// the boolean return is set to false (true otherwise).
func (d *Deck) Deal(cards int, hands ...Deck) ([]Deck, bool) {
	for i := 0; i < cards; i++ {
		for j := range hands {
			if len(*d) == 0 {
				return hands, false
			}
			hands[j] = append(hands[j], (*d)[0])
			*d = (*d)[1:]
		}
	}
	return hands, true
}",3844,174
28332,http://rosettacode.org/wiki/Pernicious_numbers,Pernicious numbers,"A   pernicious number   is a positive integer whose   population count   is a prime.

The   population count   is the number of   ones   in the binary representation of a non-negative integer.



Example
22   (which is   10110   in binary)   has a population count of   3,   which is prime,   and therefore

22   is a pernicious number.



Task
 display the first   25   pernicious numbers   (in decimal).
 display all pernicious numbers between   888,888,877   and   888,888,888   (inclusive).
 display each list of integers on one line   (which may or may not include a title).


See also
 Sequence   A052294 pernicious numbers on The On-Line Encyclopedia of Integer Sequences.
 Rosetta Code entry   population count, evil numbers, odious numbers.

",#Go,Go,"package main
 
import ""fmt""
 
func pernicious(w uint32) bool {
    const (
        ff    = 1<<32 - 1
        mask1 = ff / 3
        mask3 = ff / 5
        maskf = ff / 17
        maskp = ff / 255
    )
    w -= w >> 1 & mask1
    w = w&mask3 + w>>2&mask3
    w = (w + w>>4) & maskf
    return 0xa08a28ac>>(w*maskp>>24)&1 != 0
}
 
func main() {
    for i, n := 0, uint32(1); i < 25; n++ {
        if pernicious(n) {
            fmt.Printf(""%d "", n)
            i++
        }
    }
    fmt.Println()
    for n := uint32(888888877); n <= 888888888; n++ {
        if pernicious(n) {
            fmt.Printf(""%d "", n)
        }
    }
    fmt.Println()
}",647,33
28371,http://rosettacode.org/wiki/Percentage_difference_between_images,Percentage difference between images,"basic bitmap storage
Useful for comparing two JPEG images saved with a different compression ratios.

You can use these pictures for testing (use the full-size version of each):



50% quality JPEG

100% quality JPEG







link to full size 50% image

link to full size 100% image

The expected difference for these two images is 1.62125%
",#Go,Go,"package main
 
import (
    ""fmt""
    ""image/jpeg""
    ""os""
    ""log""
    ""image""
)
 
func loadJpeg(filename string) (image.Image, error) {
    f, err := os.Open(filename)
    if err != nil {
        return nil, err
    }
    defer f.Close()
 
    img, err := jpeg.Decode(f)
    if err != nil {
        return nil, err
    }
 
    return img, nil
}
 
func diff(a, b uint32) int64 {
    if a > b {
        return int64(a - b)
    }
    return int64(b - a)
}
 
func main() {
    i50, err := loadJpeg(""Lenna50.jpg"")
    if err != nil {
        log.Fatal(err)
    }
 
    i100, err := loadJpeg(""Lenna100.jpg"")
    if err != nil {
        log.Fatal(err)
    }
 
    if i50.ColorModel() != i100.ColorModel() {
        log.Fatal(""different color models"")
    }
 
    b := i50.Bounds()
    if !b.Eq(i100.Bounds()) {
        log.Fatal(""different image sizes"")
    }
 
    var sum int64
    for y := b.Min.Y; y < b.Max.Y; y++ {
        for x := b.Min.X; x < b.Max.X; x++ {
            r1, g1, b1, _ := i50.At(x, y).RGBA()
            r2, g2, b2, _ := i100.At(x, y).RGBA()
            sum += diff(r1, r2)
            sum += diff(g1, g2)
            sum += diff(b1, b2)
        }
    }
 
    nPixels := (b.Max.X - b.Min.X) * (b.Max.Y - b.Min.Y)
    fmt.Printf(""Image difference: %f%%\n"",
        float64(sum*100)/(float64(nPixels)*0xffff*3))
}",1331,67
28412,http://rosettacode.org/wiki/Pi,Pi,"
Create a program to continually calculate and output the next decimal digit of   



π


{\displaystyle \pi }

   (pi).

The program should continue forever (until it is aborted by the user) calculating and outputting each decimal digit in succession.

The output should be a decimal sequence beginning   3.14159265 ...



Note: this task is about   calculating   pi.   For information on built-in pi constants see Real constants and functions.



Related Task Arithmetic-geometric mean/Calculate Pi
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
type lft struct {
    q,r,s,t big.Int
}
 
func (t *lft) extr(x *big.Int) *big.Rat {
    var n, d big.Int
    var r big.Rat
    return r.SetFrac(
        n.Add(n.Mul(&t.q, x), &t.r),
        d.Add(d.Mul(&t.s, x), &t.t))
}
 
var three = big.NewInt(3)
var four = big.NewInt(4)
 
func (t *lft) next() *big.Int {
    r := t.extr(three)
    var f big.Int
    return f.Div(r.Num(), r.Denom())
}
 
func (t *lft) safe(n *big.Int) bool {
    r := t.extr(four)
    var f big.Int
    if n.Cmp(f.Div(r.Num(), r.Denom())) == 0 {
        return true
    }
    return false
}
 
func (t *lft) comp(u *lft) *lft {
    var r lft
    var a, b big.Int
    r.q.Add(a.Mul(&t.q, &u.q), b.Mul(&t.r, &u.s))
    r.r.Add(a.Mul(&t.q, &u.r), b.Mul(&t.r, &u.t))
    r.s.Add(a.Mul(&t.s, &u.q), b.Mul(&t.t, &u.s))
    r.t.Add(a.Mul(&t.s, &u.r), b.Mul(&t.t, &u.t))
    return &r
}
 
func (t *lft) prod(n *big.Int) *lft {
    var r lft
    r.q.SetInt64(10)
    r.r.Mul(r.r.SetInt64(-10), n)
    r.t.SetInt64(1)
    return r.comp(t)
}
 
func main() {
    // init z to unit
    z := new(lft)
    z.q.SetInt64(1)
    z.t.SetInt64(1)
 
    // lfts generator
    var k int64
    lfts := func() *lft {
        k++
        r := new(lft)
        r.q.SetInt64(k)
        r.r.SetInt64(4*k+2)
        r.t.SetInt64(2*k+1)
        return r
    }
 
    // stream
    for {
        y := z.next()
        if z.safe(y) {
            fmt.Print(y)
            z = z.prod(y)
        } else {
            z = z.comp(lfts())
        }
    }
}",1538,83
28431,http://rosettacode.org/wiki/Perfect_shuffle,Perfect shuffle,"A perfect shuffle (or faro/weave shuffle) means splitting a deck of cards into equal halves, and perfectly interleaving them - so that you end up with the first card from the left half, followed by the first card from the right half, and so on:



 7♠ 8♠ 9♠ J♠ Q♠ K♠→7♠  8♠  9♠
  J♠  Q♠  K♠→7♠ J♠ 8♠ Q♠ 9♠ K♠


When you repeatedly perform perfect shuffles on an even-sized deck of unique cards, it will at some point arrive back at its original order. How many shuffles this takes, depends solely on the number of cards in the deck - for example for a deck of eight cards it takes three shuffles:





 original: 

1
2
3
4
5
6
7
8



 after 1st shuffle: 

1
5
2
6
3
7
4
8



 after 2nd shuffle: 

1
3
5
7
2
4
6
8



 after 3rd shuffle: 

1
2
3
4
5
6
7
8




The Task
 Write a function that can perform a perfect shuffle on an even-sized list of values.
 Call this function repeatedly to count how many shuffles are needed to get a deck back to its original order, for each of the deck sizes listed under ""Test Cases"" below.
 You can use a list of numbers (or anything else that's convenient) to represent a deck; just make sure that all ""cards"" are unique within each deck.
 Print out the resulting shuffle counts, to demonstrate that your program passes the test-cases.
Test Cases


 input (deck size) 
 output (number of shuffles required)


 8 
 3


 24 
 11


 52 
 8


 100 
 30


 1020 
 1018


 1024 
 10


 10000 
 300


",#Go,Go,"package main
 
import ""fmt""
 
type Deck struct {
	Cards []int
	length int
}
 
func NewDeck(deckSize int) (res *Deck){
	if deckSize % 2 != 0{
		panic(""Deck size must be even"")
	}
	res = new(Deck)
	res.Cards = make([]int, deckSize)
	res.length = deckSize
	for i,_ := range  res.Cards{
		res.Cards[i] = i
	}
	return
}
func (d *Deck)shuffleDeck(){
	tmp := make([]int,d.length)
	for i := 0;i <d.length/2;i++  {
		tmp[i*2] = d.Cards[i]
		tmp[i*2+1] = d.Cards[d.length / 2 + i]
	}
	d.Cards = tmp
}
func (d *Deck) isEqualTo(c Deck) (res bool) {
	if d.length != c.length {
		panic(""Decks aren't equally sized"")
	}
	res = true
	for i, v := range d.Cards{
		if v != c.Cards[i] {
			res = false
		}
	}
	return
}
 
 
func main(){
	for _,v := range []int{8,24,52,100,1020,1024,10000} {
		fmt.Printf(""Cards count: %d, shuffles required: %d\n"",v,ShufflesRequired(v))
	}
}
 
func ShufflesRequired(deckSize int)(res int){
	deck := NewDeck(deckSize)
	Ref := *deck
	deck.shuffleDeck()
	res++
	for ;!deck.isEqualTo(Ref);deck.shuffleDeck(){
		res++
	}
	return
}",1039,59
28815,http://rosettacode.org/wiki/Perfect_numbers,Perfect numbers,"Write a function which says whether a number is perfect.


A perfect number is a positive integer that is the sum of its proper positive divisors excluding the number itself.

Equivalently, a perfect number is a number that is half the sum of all of its positive divisors (including itself).



Note:   The faster   Lucas-Lehmer test   is used to find primes of the form    2n-1,   all known perfect numbers can be derived from these primes
using the formula    (2n - 1) × 2n - 1.

It is not known if there are any odd perfect numbers (any that exist are larger than 102000).

The number of   known   perfect numbers is   51   (as of December, 2018),   and the largest known perfect number contains  49,724,095  decimal digits.



See also

   Rational Arithmetic
   Perfect numbers on OEIS
   Odd Perfect showing the current status of bounds on odd perfect numbers.

",#Go,Go,"package main
 
import ""fmt""
 
func computePerfect(n int64) bool {
    var sum int64
    for i := int64(1); i < n; i++ {
        if n%i == 0 {
            sum += i
        }
    }
    return sum == n
}
 
// following function satisfies the task, returning true for all
// perfect numbers representable in the argument type
func isPerfect(n int64) bool {
    switch n {
    case 6, 28, 496, 8128, 33550336, 8589869056,
        137438691328, 2305843008139952128:
        return true
    }
    return false
}
 
// validation
func main() {
    for n := int64(1); ; n++ {
        if isPerfect(n) != computePerfect(n) {
            panic(""bug"")
        }
        if n%1e3 == 0 {
            fmt.Println(""tested"", n)
        }
    }
}
 
 ",730,38
28843,http://rosettacode.org/wiki/Permutations,Permutations,"Task

Write a program that generates all   permutations   of   n   different objects.   (Practically numerals!)



Related tasks
 
   Find the missing permutation
   Permutations/Derangements



 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    demoPerm(3)
}
 
func demoPerm(n int) {
    // create a set to permute.  for demo, use the integers 1..n.
    s := make([]int, n)
    for i := range s {
        s[i] = i + 1
    }
    // permute them, calling a function for each permutation.
    // for demo, function just prints the permutation.
    permute(s, func(p []int) { fmt.Println(p) })
}
 
// permute function.  takes a set to permute and a function
// to call for each generated permutation.
func permute(s []int, emit func([]int)) {
    if len(s) == 0 {
        emit(s)
        return
    }
    // Steinhaus, implemented with a recursive closure.
    // arg is number of positions left to permute.
    // pass in len(s) to start generation.
    // on each call, weave element at pp through the elements 0..np-2,
    // then restore array to the way it was.
    var rc func(int)
    rc = func(np int) {
        if np == 1 {
            emit(s)
            return
        }
        np1 := np - 1
        pp := len(s) - np1
        // weave
        rc(np1)
        for i := pp; i > 0; i-- {
            s[i], s[i-1] = s[i-1], s[i]
            rc(np1)
        }
        // restore
        w := s[0]
        copy(s, s[1:pp+1])
        s[pp] = w
    }
    rc(len(s))
}",1271,52
28984,http://rosettacode.org/wiki/Pentagram,Pentagram,"
A pentagram is a star polygon, consisting of a central pentagon of which each side forms the base of an isosceles triangle. The vertex of each triangle, a point of the star, is 36 degrees.




Task

Draw (or print) a regular pentagram, in any orientation. Use a different color (or token) for stroke and fill, and background. For the fill it should be assumed that all points inside the triangles and the pentagon are inside the pentagram.




See also
 Angle sum of a pentagram

",#Go,Go,"package main
 
import (
    ""github.com/fogleman/gg""
    ""math""
)
 
func Pentagram(x, y, r float64) []gg.Point {
    points := make([]gg.Point, 5)
    for i := 0; i < 5; i++ {
        fi := float64(i)
        angle := 2*math.Pi*fi/5 - math.Pi/2
        points[i] = gg.Point{x + r*math.Cos(angle), y + r*math.Sin(angle)}
    }
    return points
}
 
func main() {
    points := Pentagram(320, 320, 250)
    dc := gg.NewContext(640, 640)
    dc.SetRGB(1, 1, 1) // White
    dc.Clear()
    for i := 0; i <= 5; i++ {
        index := (i * 2) % 5
        p := points[index]
        dc.LineTo(p.X, p.Y)
    }
    dc.SetHexColor(""#6495ED"") // Cornflower Blue
    dc.SetFillRule(gg.FillRuleWinding)
    dc.FillPreserve()
    dc.SetRGB(0, 0, 0) // Black
    dc.SetLineWidth(5)
    dc.Stroke()
    dc.SavePNG(""pentagram.png"")
}",816,35
29051,http://rosettacode.org/wiki/Pell%27s_equation,Pell's equation,"Pell's equation   (also called the Pell–Fermat equation)   is a   Diophantine equation   of the form:

   x2   -   ny2   =   1  
with integer solutions for   x   and   y,   where   n   is a given non-square positive integer.



Task requirements

   find the smallest solution in positive integers to Pell's equation for   n = {61, 109, 181, 277}.


See also

   Wikipedia entry: Pell's equation.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
var big1 = new(big.Int).SetUint64(1)
 
func solvePell(nn uint64) (*big.Int, *big.Int) {
    n := new(big.Int).SetUint64(nn)
    x := new(big.Int).Set(n)
    x.Sqrt(x)
    y := new(big.Int).Set(x)
    z := new(big.Int).SetUint64(1)
    r := new(big.Int).Lsh(x, 1)
 
    e1 := new(big.Int).SetUint64(1)
    e2 := new(big.Int)
    f1 := new(big.Int)
    f2 := new(big.Int).SetUint64(1)
 
    t := new(big.Int)
    u := new(big.Int)
    a := new(big.Int)
    b := new(big.Int)
    for {
        t.Mul(r, z)
        y.Sub(t, y)
        t.Mul(y, y)
        t.Sub(n, t)
        z.Quo(t, z)
        t.Add(x, y)
        r.Quo(t, z)
        u.Set(e1)
        e1.Set(e2)
        t.Mul(r, e2)
        e2.Add(t, u)
        u.Set(f1)
        f1.Set(f2)
        t.Mul(r, f2)
        f2.Add(t, u)
        t.Mul(x, f2)
        a.Add(e2, t)
        b.Set(f2)
        t.Mul(a, a)
        u.Mul(n, b)
        u.Mul(u, b)
        t.Sub(t, u)
        if t.Cmp(big1) == 0 {
            return a, b
        }
    }
}
 
func main() {
    ns := []uint64{61, 109, 181, 277}
    for _, n := range ns {
        x, y := solvePell(n)
        fmt.Printf(""x^2 - %3d*y^2 = 1 for x = %-21s and y = %s\n"", n, x, y)
    }
}",1239,62
29097,http://rosettacode.org/wiki/Peano_curve,Peano curve,"

Task
Produce a graphical or ASCII-art representation of a Peano curve of at least order 3.
",#Go,Go,"package main
 
import ""github.com/fogleman/gg""
 
var points []gg.Point
 
const width = 81
 
func peano(x, y, lg, i1, i2 int) {
    if lg == 1 {
        px := float64(width-x) * 10
        py := float64(width-y) * 10
        points = append(points, gg.Point{px, py})
        return
    }
    lg /= 3
    peano(x+2*i1*lg, y+2*i1*lg, lg, i1, i2)
    peano(x+(i1-i2+1)*lg, y+(i1+i2)*lg, lg, i1, 1-i2)
    peano(x+lg, y+lg, lg, i1, 1-i2)
    peano(x+(i1+i2)*lg, y+(i1-i2+1)*lg, lg, 1-i1, 1-i2)
    peano(x+2*i2*lg, y+2*(1-i2)*lg, lg, i1, i2)
    peano(x+(1+i2-i1)*lg, y+(2-i1-i2)*lg, lg, i1, i2)
    peano(x+2*(1-i1)*lg, y+2*(1-i1)*lg, lg, i1, i2)
    peano(x+(2-i1-i2)*lg, y+(1+i2-i1)*lg, lg, 1-i1, i2)
    peano(x+2*(1-i2)*lg, y+2*i2*lg, lg, 1-i1, i2)
}
 
func main() {
    peano(0, 0, width, 0, 0)
    dc := gg.NewContext(820, 820)
    dc.SetRGB(1, 1, 1) // White background
    dc.Clear()
    for _, p := range points {
        dc.LineTo(p.X, p.Y)
    }
    dc.SetRGB(1, 0, 1) // Magenta curve
    dc.SetLineWidth(1)
    dc.Stroke()
    dc.SavePNG(""peano.png"")
}",1061,40
29152,http://rosettacode.org/wiki/Penney%27s_game,Penney's game,"Penney's game is a game where two players bet on being the first to see a particular sequence of heads or tails in consecutive tosses of a fair coin.

It is common to agree on a sequence length of three then one player will openly choose a sequence, for example:

 Heads,  Tails,  Heads, or HTH for short.

The other player on seeing the first players choice will choose his sequence. The coin is tossed and the first player to see his sequence in the sequence of coin tosses wins.



Example

One player might choose the sequence HHT and the other THT.

Successive coin tosses of HTTHT gives the win to the second player as the last three coin tosses are his sequence.



Task
Create a program that tosses the coin, keeps score and plays Penney's game against a human opponent.

 Who chooses and shows their sequence of three should be chosen randomly.
 If going first, the computer should randomly choose its sequence of three.
 If going second, the computer should automatically play the optimum sequence.
 Successive coin tosses should be shown.


Show output of a game where the computer chooses first and a game where the user goes first here on this page.



See also
 The Penney Ante Part 1 (Video).
 The Penney Ante Part 2 (Video).

",#Go,Go," 
package main
import ""fmt""
import ""math/rand""
func main(){
var a1,a2,a3,y,match,j,k int
var inp string
y=1
for y==1{
fmt.Println(""Enter your sequence:"")
fmt.Scanln(&inp)
var Ai [3] int
var user [3] int
for j=0;j<3;j++{
if(inp[j]==104){
user[j]=1
}else{
user[j]=0
}
}
for k=0;k<3;k++{
Ai[k]=rand.Intn(2)
}
for user[0]==Ai[0]&&user[1]==Ai[1]&&user[2]==Ai[2]{
for k=0;k<3;k++{
Ai[k]=rand.Intn(2)
}
}
fmt.Println(""You gave the sequence:"")
printht(user)
fmt.Println()
fmt.Println(""The computer generated sequence is:"")
printht(Ai)
fmt.Println()
a1=rand.Intn(2)
a2=rand.Intn(2)
a3=rand.Intn(2)
fmt.Print(""The generated sequence is:"")
printh(a1)
printh(a2)
printh(a3)
match=0
for match==0{
if(matches(user,a1,a2,a3)==1){
fmt.Println()
fmt.Println(""You have won!!!"")
match=1
}else if(matches(Ai,a1,a2,a3)==1){
fmt.Println()
fmt.Println(""You lost!! Computer wins"")
match=1
}else{
a1=a2
a2=a3
a3=rand.Intn(2)
printh(a3)
}
}
fmt.Println(""Do you want to continue(0/1):"")
fmt.Scanln(&y)
}
}
func printht(a [3] int) int{
var i int
for i=0;i<3;i++{
if(a[i]==1){
fmt.Print(""h"")
}else{
fmt.Print(""t"")
}
}
return 1
}
func printh(a int) int{
if(a==1){
fmt.Print(""h"")
}else{
fmt.Print(""t"")
}
return 1
}
func matches(a [3] int,p int,q int,r int) int{
if(a[0]==p&&a[1]==q&&a[2]==r){
return 1
}else{
return 0
}
}
 ",1292,89
29163,http://rosettacode.org/wiki/Pathological_floating_point_problems,Pathological floating point problems,"Most programmers are familiar with the inexactness of floating point calculations in a binary processor.

The classic example being:

0.1 + 0.2 =  0.30000000000000004

In many situations the amount of error in such calculations is very small and can be overlooked or eliminated with rounding.

There are pathological problems however, where seemingly simple, straight-forward calculations are extremely sensitive to even tiny amounts of imprecision.

This task's purpose is to show how your language deals with such classes of problems.


A sequence that seems to converge to a wrong limit.

Consider the sequence:

  v1 = 2 
  v2 = -4 
  vn = 111   -   1130   /   vn-1   +   3000  /   (vn-1 * vn-2) 


As   n   grows larger, the series should converge to   6   but small amounts of error will cause it to approach   100.



Task 1

Display the values of the sequence where   n =   3, 4, 5, 6, 7, 8, 20, 30, 50 & 100   to at least 16 decimal places.

    n = 3     18.5
    n = 4      9.378378
    n = 5      7.801153
    n = 6      7.154414
    n = 7      6.806785
    n = 8      6.5926328
    n = 20     6.0435521101892689
    n = 30     6.006786093031205758530554
    n = 50     6.0001758466271871889456140207471954695237
    n = 100    6.000000019319477929104086803403585715024350675436952458072592750856521767230266



Task 2

The Chaotic Bank Society   is offering a new investment account to their customers.

You first deposit   $e - 1   where   e   is   2.7182818...   the base of natural logarithms.

After each year, your account balance will be multiplied by the number of years that have passed, and $1 in service charges will be removed.

So ...

 after 1 year, your balance will be multiplied by 1 and $1 will be removed for service charges.
 after 2 years your balance will be doubled and $1 removed.
 after 3 years your balance will be tripled and $1 removed.
  ... 
 after 10 years, multiplied by 10 and $1 removed, and so on. 


What will your balance be after   25   years?

   Starting balance: $e-1
   Balance = (Balance * year) - 1 for 25 years
   Balance after 25 years: $0.0399387296732302



Task 3, extra credit

Siegfried Rump's example.   Consider the following function, designed by Siegfried Rump in 1988.

  f(a,b) = 333.75b6 + a2( 11a2b2 - b6 - 121b4 - 2 ) + 5.5b8 + a/(2b) 
  compute    f(a,b)    where    a=77617.0    and    b=33096.0 
  f(77617.0, 33096.0)   =   -0.827396059946821 


Demonstrate how to solve at least one of the first two problems, or both, and the third if you're feeling particularly jaunty.



See also;
   Floating-Point Arithmetic   Section 1.3.2 Difficult problems.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    sequence()
    bank()
    rump()
}
 
func sequence() {
    // exact computations using big.Rat
    var v, v1 big.Rat
    v1.SetInt64(2)
    v.SetInt64(-4)
    n := 2
    c111 := big.NewRat(111, 1)
    c1130 := big.NewRat(1130, 1)
    c3000 := big.NewRat(3000, 1)
    var t2, t3 big.Rat
    r := func() (vn big.Rat) {
        vn.Add(vn.Sub(c111, t2.Quo(c1130, &v)), t3.Quo(c3000, t3.Mul(&v, &v1)))
        return
    }
    fmt.Println(""  n  sequence value"")
    for _, x := range []int{3, 4, 5, 6, 7, 8, 20, 30, 50, 100} {
        for ; n < x; n++ {
            v1, v = v, r()
        }
        f, _ := v.Float64()
        fmt.Printf(""%3d %19.16f\n"", n, f)
    }
}
 
func bank() {
    // balance as integer multiples of e and whole dollars using big.Int
    var balance struct{ e, d big.Int }
    // initial balance
    balance.e.SetInt64(1)
    balance.d.SetInt64(-1)
    // compute balance over 25 years
    var m, one big.Int
    one.SetInt64(1)
    for y := 1; y <= 25; y++ {
        m.SetInt64(int64(y))
        balance.e.Mul(&m, &balance.e)
        balance.d.Mul(&m, &balance.d)
        balance.d.Sub(&balance.d, &one)
    }
    // sum account components using big.Float
    var e, ef, df, b big.Float
    e.SetPrec(100).SetString(""2.71828182845904523536028747135"")
    ef.SetInt(&balance.e)
    df.SetInt(&balance.d)
    b.Add(b.Mul(&e, &ef), &df)
    fmt.Printf(""Bank balance after 25 years: $%.2f\n"", &b)
}
 
func rump() {
    a, b := 77617., 33096.
    fmt.Printf(""Rump f(%g, %g): %g\n"", a, b, f(a, b))
}
 
func f(a, b float64) float64 {
    // computations done with big.Float with enough precision to give
    // a correct answer.
    fp := func(x float64) *big.Float { return big.NewFloat(x).SetPrec(128) }
    a1 := fp(a)
    b1 := fp(b)
    a2 := new(big.Float).Mul(a1, a1)
    b2 := new(big.Float).Mul(b1, b1)
    b4 := new(big.Float).Mul(b2, b2)
    b6 := new(big.Float).Mul(b2, b4)
    b8 := new(big.Float).Mul(b4, b4)
    two := fp(2)
    t1 := fp(333.75)
    t1.Mul(t1, b6)
    t21 := fp(11)
    t21.Mul(t21.Mul(t21, a2), b2)
    t23 := fp(121)
    t23.Mul(t23, b4)
    t2 := new(big.Float).Sub(t21, b6)
    t2.Mul(a2, t2.Sub(t2.Sub(t2, t23), two))
    t3 := fp(5.5)
    t3.Mul(t3, b8)
    t4 := new(big.Float).Mul(two, b1)
    t4.Quo(a1, t4)
    s := new(big.Float).Add(t1, t2)
    f64, _ := s.Add(s.Add(s, t3), t4).Float64()
    return f64
}",2433,94
29181,http://rosettacode.org/wiki/Peaceful_chess_queen_armies,Peaceful chess queen armies,"In chess, a queen attacks positions from where it is, in straight lines up-down and left-right as well as on both its diagonals. It attacks only pieces not of its own colour.






⇖
⇑
⇗



⇐
⇐
♛
⇒
⇒



⇙
⇓
⇘



⇙

⇓

⇘




⇓






The goal of Peaceful chess queen armies is to arrange m black queens and m white queens on an n-by-n square grid, (the board), so that no queen attacks another of a different colour.



Task

 Create a routine to represent two-colour queens on a 2-D board. (Alternating black/white background colours, Unicode chess pieces and other embellishments are not necessary, but may be used at your discretion).
 Create a routine to generate at least one solution to placing m equal numbers of black and white queens on an n square board.
 Display here results for the m=4, n=5 case.


References

 Peaceably Coexisting Armies of Queens (Pdf) by Robert A. Bosch. Optima, the Mathematical Programming Socity newsletter, issue 62.
 A250000 OEIS

",#Go,Go,"package main
 
import ""fmt""
 
const (
    empty = iota
    black
    white
)
 
const (
    bqueen  = 'B'
    wqueen  = 'W'
    bbullet = '•'
    wbullet = '◦'
)
 
type position struct{ i, j int }
 
func iabs(i int) int {
    if i < 0 {
        return -i
    }
    return i
}
 
func place(m, n int, pBlackQueens, pWhiteQueens *[]position) bool {
    if m == 0 {
        return true
    }
    placingBlack := true
    for i := 0; i < n; i++ {
    inner:
        for j := 0; j < n; j++ {
            pos := position{i, j}
            for _, queen := range *pBlackQueens {
                if queen == pos || !placingBlack && isAttacking(queen, pos) {
                    continue inner
                }
            }
            for _, queen := range *pWhiteQueens {
                if queen == pos || placingBlack && isAttacking(queen, pos) {
                    continue inner
                }
            }
            if placingBlack {
                *pBlackQueens = append(*pBlackQueens, pos)
                placingBlack = false
            } else {
                *pWhiteQueens = append(*pWhiteQueens, pos)
                if place(m-1, n, pBlackQueens, pWhiteQueens) {
                    return true
                }
                *pBlackQueens = (*pBlackQueens)[0 : len(*pBlackQueens)-1]
                *pWhiteQueens = (*pWhiteQueens)[0 : len(*pWhiteQueens)-1]
                placingBlack = true
            }
        }
    }
    if !placingBlack {
        *pBlackQueens = (*pBlackQueens)[0 : len(*pBlackQueens)-1]
    }
    return false
}
 
func isAttacking(queen, pos position) bool {
    if queen.i == pos.i {
        return true
    }
    if queen.j == pos.j {
        return true
    }
    if iabs(queen.i-pos.i) == iabs(queen.j-pos.j) {
        return true
    }
    return false
}
 
func printBoard(n int, blackQueens, whiteQueens []position) {
    board := make([]int, n*n)
    for _, queen := range blackQueens {
        board[queen.i*n+queen.j] = black
    }
    for _, queen := range whiteQueens {
        board[queen.i*n+queen.j] = white
    }
 
    for i, b := range board {
        if i != 0 && i%n == 0 {
            fmt.Println()
        }
        switch b {
        case black:
            fmt.Printf(""%c "", bqueen)
        case white:
            fmt.Printf(""%c "", wqueen)
        case empty:
            if i%2 == 0 {
                fmt.Printf(""%c "", bbullet)
            } else {
                fmt.Printf(""%c "", wbullet)
            }
        }
    }
    fmt.Println(""\n"")
}
 
func main() {
    nms := [][2]int{
        {2, 1}, {3, 1}, {3, 2}, {4, 1}, {4, 2}, {4, 3},
        {5, 1}, {5, 2}, {5, 3}, {5, 4}, {5, 5},
        {6, 1}, {6, 2}, {6, 3}, {6, 4}, {6, 5}, {6, 6},
        {7, 1}, {7, 2}, {7, 3}, {7, 4}, {7, 5}, {7, 6}, {7, 7},
    }
    for _, nm := range nms {
        n, m := nm[0], nm[1]
        fmt.Printf(""%d black and %d white queens on a %d x %d board:\n"", m, m, n, n)
        var blackQueens, whiteQueens []position
        if place(m, n, &blackQueens, &whiteQueens) {
            printBoard(n, blackQueens, whiteQueens)
        } else {
            fmt.Println(""No solution exists.\n"")
        }
    }
}",3159,125
29236,http://rosettacode.org/wiki/Partition_function_P,Partition function P,"

The Partition Function P, often notated P(n) is the number of solutions where n∈ℤ can be expressed as the sum of a set of positive integers.



Example

 P(4) = 5   because   4 = Σ(4) = Σ(3,1) = Σ(2,2) = Σ(2,1,1) = Σ(1,1,1,1)



P(n) can be expressed as the recurrence relation:

 P(n) = P(n-1) +P(n-2) -P(n-5) -P(n-7) +P(n-12) +P(n-15) -P(n-22) -P(n-26) +P(n-35) +P(n-40) ...

The successive numbers in the above equation have the differences:   1, 3, 2, 5, 3, 7, 4, 9, 5, 11, 6, 13, 7, 15, 8 ...

This task may be of popular interest because Mathologer made the video, The hardest ""What comes next?"" (Euler's pentagonal formula), where he asks the programmers among his viewers to calculate P(666). The video has been viewed more than 100,000 times in the first couple of weeks since its release.

In Wolfram Language, this function has been implemented as PartitionsP.



Task

Write a function which returns the value of PartitionsP(n). Solutions can be iterative or recursive.

Bonus task: show how long it takes to compute PartitionsP(6666).



References

 The hardest ""What comes next?"" (Euler's pentagonal formula) The explanatory video by Mathologer that makes this task a popular interest.
 Partition Function P Mathworld entry for the Partition function.
 Partition function (number theory) Wikipedia entry for the Partition function.


Related tasks

 9 billion names of God the integer



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""time""
)
 
var p []*big.Int
var pd []int
 
func partDiffDiff(n int) int {
    if n&1 == 1 {
        return (n + 1) / 2
    }
    return n + 1
}
 
func partDiff(n int) int {
    if n < 2 {
        return 1
    }
    pd[n] = pd[n-1] + partDiffDiff(n-1)
    return pd[n]
}
 
func partitionsP(n int) {
    if n < 2 {
        return
    }
    psum := new(big.Int)
    for i := 1; i <= n; i++ {
        pdi := partDiff(i)
        if pdi > n {
            break
        }
        sign := int64(-1)
        if (i-1)%4 < 2 {
            sign = 1
        }
        t := new(big.Int).Mul(p[n-pdi], big.NewInt(sign))
        psum.Add(psum, t)
    }
    p[n] = psum
}
 
func main() {
    start := time.Now()
    const N = 6666
    p = make([]*big.Int, N+1)
    pd = make([]int, N+1)
    p[0], pd[0] = big.NewInt(1), 1
    p[1], pd[1] = big.NewInt(1), 1
    for n := 2; n <= N; n++ {
        partitionsP(n)
    }
    fmt.Printf(""p[%d)] = %d\n"", N, p[N])
    fmt.Printf(""Took %s\n"", time.Since(start))
}",1041,59
29265,http://rosettacode.org/wiki/Partition_an_integer_x_into_n_primes,Partition an integer x into n primes,"Task

Partition a positive integer   X   into   N   distinct primes.



Or, to put it in another way:

Find   N   unique primes such that they add up to   X.



Show in the output section the sum   X   and the   N   primes in ascending order separated by plus (+) signs:

     •    partition  99809  with   1 prime.
     •    partition    18   with   2 primes.
     •    partition    19   with   3 primes.
     •    partition    20   with   4 primes.
     •    partition   2017  with  24 primes.
     •    partition  22699  with   1,  2,  3,  and  4  primes.
     •    partition  40355  with   3 primes.

The output could/should be shown in a format such as:

    Partitioned  19  with  3  primes:  3+5+11

   Use any spacing that may be appropriate for the display.
   You need not validate the input(s).
   Use the lowest primes possible;   use  18 = 5+13,   not   18 = 7+11.
   You only need to show one solution.
This task is similar to factoring an integer.



Related tasks

   Count in factors
   Prime decomposition
   Factors of an integer
   Sieve of Eratosthenes
   Primality by trial division
   Factors of a Mersenne number
   Factors of a Mersenne number
   Sequence of primes by trial division

",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
)
 
var (
    primes     = sieve(100000)
    foundCombo = false
)
 
func sieve(limit uint) []uint {
    primes := []uint{2}
    c := make([]bool, limit+1) // composite = true
    // no need to process even numbers > 2
    p := uint(3)
    for {
        p2 := p * p
        if p2 > limit {
            break
        }
        for i := p2; i <= limit; i += 2 * p {
            c[i] = true
        }
        for {
            p += 2
            if !c[p] {
                break
            }
        }
    }
    for i := uint(3); i <= limit; i += 2 {
        if !c[i] {
            primes = append(primes, i)
        }
    }
    return primes
}
 
func findCombo(k, x, m, n uint, combo []uint) {
    if k >= m {
        sum := uint(0)
        for _, c := range combo {
            sum += primes[c]
        }
        if sum == x {
            s := ""s""
            if m == 1 {
                s = "" ""
            }
            fmt.Printf(""Partitioned %5d with %2d prime%s: "", x, m, s)
            for i := uint(0); i < m; i++ {
                fmt.Print(primes[combo[i]])
                if i < m-1 {
                    fmt.Print(""+"")
                } else {
                    fmt.Println()
                }
            }
            foundCombo = true
        }
    } else {
        for j := uint(0); j < n; j++ {
            if k == 0 || j > combo[k-1] {
                combo[k] = j
                if !foundCombo {
                    findCombo(k+1, x, m, n, combo)
                }
            }
        }
    }
}
 
func partition(x, m uint) error {
    if !(x >= 2 && m >= 1 && m < x) {
        return fmt.Errorf(""x must be at least 2 and m in [1, x)"")
    }
    n := uint(0)
    for _, prime := range primes {
        if prime <= x {
            n++
        }
    }
    if n < m {
        return fmt.Errorf(""not enough primes"")
    }
    combo := make([]uint, m)
    foundCombo = false
    findCombo(0, x, m, n, combo)
    if !foundCombo {
        s := ""s""
        if m == 1 {
            s = "" ""
        }
        fmt.Printf(""Partitioned %5d with %2d prime%s: (impossible)\n"", x, m, s)
    }
    return nil
}
 
func main() {
    a := [...][2]uint{
        {99809, 1}, {18, 2}, {19, 3}, {20, 4}, {2017, 24},
        {22699, 1}, {22699, 2}, {22699, 3}, {22699, 4}, {40355, 3},
    }
    for _, p := range a {
        err := partition(p[0], p[1])
        if err != nil {
            log.Println(err)
        }
    }
}",2465,112
29267,http://rosettacode.org/wiki/Pascal%27s_triangle/Puzzle,Pascal's triangle/Puzzle,"This puzzle involves a Pascals Triangle, also known as a Pyramid of Numbers.

           [ 151]
          [  ][  ]
        [40][  ][  ]
      [  ][  ][  ][  ]
    [ X][11][ Y][ 4][ Z]

Each brick of the pyramid is the sum of the two bricks situated below it.

Of the three missing numbers at the base of the pyramid,
the middle one is the sum of the other two (that is, Y = X + Z).



Task

Write a program to find a solution to this puzzle.



",#Go,Go,"package main
 
import ""fmt""
 
// representation of an expression in x, y, and z
type expr struct {
    x, y, z float64 // coefficients
    c       float64 // constant term
}
 
// add two expressions 
func addExpr(a, b expr) expr {
    return expr{a.x + b.x, a.y + b.y, a.z + b.z, a.c + b.c}
}   
 
// subtract two expressions
func subExpr(a, b expr) expr {
    return expr{a.x - b.x, a.y - b.y, a.z - b.z, a.c - b.c}
}   
 
// multiply expression by a constant
func mulExpr(a expr, c float64) expr {
    return expr{a.x * c, a.y * c, a.z * c, a.c * c}
}
 
// given a row of expressions, produce the next row up, by the given
// sum relation between blocks 
func addRow(l []expr) []expr {
    if len(l) == 0 {
        panic(""wrong"")
    }
    r := make([]expr, len(l)-1)
    for i := range r {
        r[i] = addExpr(l[i], l[i+1])
    }
    return r
}   
 
// given expression b in a variable, and expression a, 
// take b == 0 and substitute to remove that variable from a.
func substX(a, b expr) expr {
    if b.x == 0 {
        panic(""wrong"")
    }
    return subExpr(a, mulExpr(b, a.x/b.x))
}
 
func substY(a, b expr) expr {
    if b.y == 0 {
        panic(""wrong"")
    }
    return subExpr(a, mulExpr(b, a.y/b.y))
}
 
func substZ(a, b expr) expr {
    if b.z == 0 {
        panic(""wrong"")
    }
    return subExpr(a, mulExpr(b, a.z/b.z))
}
 
// given an expression in a single variable, return value of that variable
func solveX(a expr) float64 {
    if a.x == 0 || a.y != 0 || a.z != 0 {
        panic(""wrong"")
    }
    return -a.c / a.x
}
 
func solveY(a expr) float64 {
    if a.x != 0 || a.y == 0 || a.z != 0 {
        panic(""wrong"")
    }
    return -a.c / a.y
}
 
func solveZ(a expr) float64 {
    if a.x != 0 || a.y != 0 || a.z == 0 {
        panic(""wrong"")
    }
    return -a.c / a.z
}
 
func main() {
    // representation of given information for bottom row
    r5 := []expr{{x: 1}, {c: 11}, {y: 1}, {c: 4}, {z: 1}}
    fmt.Println(""bottom row:"", r5)
 
    // given definition of brick sum relation
    r4 := addRow(r5)
    fmt.Println(""next row up:"", r4)
    r3 := addRow(r4)
    fmt.Println(""middle row:"", r3)
 
    // given relation y = x + z
    xyz := subExpr(expr{y: 1}, expr{x: 1, z: 1})
    fmt.Println(""xyz relation:"", xyz)
    // remove z from third cell using xyz relation
    r3[2] = substZ(r3[2], xyz)
    fmt.Println(""middle row after substituting for z:"", r3)
 
    // given cell = 40,
    b := expr{c: 40}
    // this gives an xy relation
    xy := subExpr(r3[0], b)
    fmt.Println(""xy relation:"", xy)
    // substitute 40 for cell
    r3[0] = b
 
    // remove x from third cell using xy relation
    r3[2] = substX(r3[2], xy)
    fmt.Println(""middle row after substituting for x:"", r3)
 
    // continue applying brick sum relation to get top cell
    r2 := addRow(r3)
    fmt.Println(""next row up:"", r2)
    r1 := addRow(r2)
    fmt.Println(""top row:"", r1)
 
    // given top cell = 151, we have an equation in y
    y := subExpr(r1[0], expr{c: 151})
    fmt.Println(""y relation:"", y)
    // using xy relation, we get an equation in x
    x := substY(xy, y)
    fmt.Println(""x relation:"", x)
    // using xyz relation, we get an equation in z
    z := substX(substY(xyz, y), x)
    fmt.Println(""z relation:"", z)
 
    // show final answers
    fmt.Println(""x ="", solveX(x))
    fmt.Println(""y ="", solveY(y))
    fmt.Println(""z ="", solveZ(z)) 
}",3380,134
29325,http://rosettacode.org/wiki/Password_generator,Password generator,"Create a password generation program which will generate passwords containing random ASCII characters from the following groups:

         lower-case letters:  a ──► z
         upper-case letters:  A ──► Z
                     digits:  0 ──► 9
 other printable characters:  !""#$%&'()*+,-./:;<=>?@[]^_{|}~ 
 (the above character list excludes white-space, backslash and grave) 



The generated password(s) must include   at least one   (of each of the four groups):

   lower-case letter, 
   upper-case letter,
   digit  (numeral),   and 
   one  ""other""  character. 



The user must be able to specify the password length and the number of passwords to generate.

The passwords should be displayed or written to a file, one per line.

The randomness should be from a system source or library.

The program should implement a help option or button which should describe the program and options when invoked.

You may also allow the user to specify a seed value, and give the option of excluding visually similar characters.

For example:            Il1     O0     5S     2Z            where the characters are:

   capital eye, lowercase ell, the digit one
   capital oh, the digit zero 
   the digit five, capital ess
   the digit two, capital zee

",#Go,Go," 
package main
 
import (
	""crypto/rand""
	""math/big""
	""strings""
	""flag""
	""math""
        ""fmt"" 
)
 
var lowercase = ""abcdefghijklmnopqrstuvwxyz""
var uppercase = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
var numbers = ""0123456789""
var signs = ""!\""#$%&'()*+,-./:;<=>?@[]^_{|}~""
var similar = ""Il1O05S2Z""
 
func check(e error){
	if e != nil {
		panic(e)
	}
}
 
func randstr(length int, alphastr string) string{
	alphabet := []byte(alphastr)
	pass := make([]byte,length)
	for i := 0; i < length; i++ {
		bign, err := rand.Int(rand.Reader, big.NewInt(int64(len(alphabet))))
		check(err)
		n := bign.Int64()
		pass[i] = alphabet[n]
	}
	return string(pass)
}
 
func verify(pass string,checkUpper bool,checkLower bool, checkNumber bool, checkSign bool) bool{
	isValid := true
	if(checkUpper){
		isValid = isValid && strings.ContainsAny(pass,uppercase)
	}
	if(checkLower){
		isValid = isValid && strings.ContainsAny(pass,lowercase)
	}
	if(checkNumber){
		isValid = isValid && strings.ContainsAny(pass,numbers)
	}
	if(checkSign){
		isValid = isValid && strings.ContainsAny(pass,signs)
	}
	return isValid
}
 
 
func main() {
	passCount := flag.Int(""pc"", 6, ""Number of passwords"")
	passLength := flag.Int(""pl"", 10, ""Passwordlength"")
	useUpper := flag.Bool(""upper"", true, ""Enables or disables uppercase letters"")
	useLower := flag.Bool(""lower"", true, ""Enables or disables lowercase letters"")
	useSign := flag.Bool(""sign"", true, ""Enables or disables signs"")
	useNumbers := flag.Bool(""number"", true, ""Enables or disables numbers"")
	useSimilar := flag.Bool(""similar"", true,""Enables or disables visually similar characters"")
	flag.Parse()
 
	passAlphabet := """"
	if *useUpper {
		passAlphabet += uppercase
	}
	if *useLower {
		passAlphabet += lowercase
	}
	if *useSign {
		passAlphabet += signs
	}
	if *useNumbers {
		passAlphabet += numbers
	}
	if !*useSimilar {
		for _, r := range similar{
			passAlphabet = strings.Replace(passAlphabet,string(r),"""", 1)
		}
	}
	fmt.Printf(""Generating passwords with an average entropy of %.1f bits \n"", math.Log2(float64(len(passAlphabet))) * float64(*passLength))
	for i := 0; i < *passCount;i++{
		passFound := false
		pass := """"
		for(!passFound){
			pass = randstr(*passLength,passAlphabet)
			passFound = verify(pass,*useUpper,*useLower,*useNumbers,*useSign)
		}
		fmt.Println(pass)
	}
}
 ",2299,94
29385,http://rosettacode.org/wiki/Parse_an_IP_Address,Parse an IP Address,"The purpose of this task is to demonstrate parsing of text-format IP addresses, using IPv4 and IPv6.



Taking the following as inputs:



127.0.0.1

The ""localhost"" IPv4 address


127.0.0.1:80

The ""localhost"" IPv4 address, with a specified port (80)


::1

The ""localhost"" IPv6 address


[::1]:80

The ""localhost"" IPv6 address, with a specified port (80)


2605:2700:0:3::4713:93e3

Rosetta Code's primary server's public IPv6 address


[2605:2700:0:3::4713:93e3]:80

Rosetta Code's primary server's public IPv6 address, with a specified port (80)



Task

Emit each described IP address as a hexadecimal integer representing the address, the address space, and the port number specified, if any.

In languages where variant result types are clumsy, the result should be ipv4 or ipv6 address number, something which says which address space was represented, port number and something that says if the port was specified.



Example

127.0.0.1   has the address number   7F000001   (2130706433 decimal)
in the ipv4 address space.

::ffff:127.0.0.1   represents the same address in the ipv6 address space where it has the
address number   FFFF7F000001   (281472812449793 decimal).

::1   has address number   1   and serves the same purpose in the ipv6 address
space that   127.0.0.1   serves in the ipv4 address space.



",#Go,Go,"package main
 
import (
	""encoding/hex""
	""fmt""
	""io""
	""net""
	""os""
	""strconv""
	""strings""
	""text/tabwriter""
)
 
// parseIPPort parses an IP with an optional port, returning an IP and a port (or nil
// if no port was present in the given address).
func parseIPPort(address string) (net.IP, *uint64, error) {
	ip := net.ParseIP(address)
	if ip != nil {
		return ip, nil, nil
	}
 
	host, portStr, err := net.SplitHostPort(address)
	if err != nil {
		return nil, nil, fmt.Errorf(""splithostport failed: %w"", err)
	}
 
	port, err := strconv.ParseUint(portStr, 10, 16)
	if err != nil {
		return nil, nil, fmt.Errorf(""failed to parse port: %w"", err)
	}
 
	ip = net.ParseIP(host)
	if ip == nil {
		return nil, nil, fmt.Errorf(""failed to parse ip address"")
	}
 
	return ip, &port, nil
}
 
func ipVersion(ip net.IP) int {
	if ip.To4() == nil {
		return 6
	}
 
	return 4
}
 
func main() {
	testCases := []string{
		""127.0.0.1"",
		""127.0.0.1:80"",
		""::1"",
		""[::1]:443"",
		""2605:2700:0:3::4713:93e3"",
		""[2605:2700:0:3::4713:93e3]:80"",
	}
 
	w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
 
	writeTSV := func(w io.Writer, args ...interface{}) {
		fmt.Fprintf(w, strings.Repeat(""%s\t"", len(args)), args...)
		fmt.Fprintf(w, ""\n"")
	}
 
	writeTSV(w, ""Input"", ""Address"", ""Space"", ""Port"")
 
	for _, addr := range testCases {
		ip, port, err := parseIPPort(addr)
		if err != nil {
			panic(err)
		}
 
		portStr := ""n/a""
		if port != nil {
			portStr = fmt.Sprint(*port)
		}
 
		ipVersion := fmt.Sprintf(""IPv%d"", ipVersion(ip))
 
		writeTSV(w, addr, hex.EncodeToString(ip), ipVersion, portStr)
	}
 
	w.Flush()
}
 ",1597,85
29436,http://rosettacode.org/wiki/Parametric_polymorphism,Parametric polymorphism,"Parametric Polymorphism
type variables


Task

Write a small example for a type declaration that is parametric over another type, together with a short bit of code (and its type signature) that uses it.



A good example is a container type, let's say a binary tree, together with some function that traverses the tree, say, a map-function that operates on every element of the tree.

This language feature only applies to statically-typed languages.



",#Go,Go,"package main
 
import ""fmt""
 
func average(c intCollection) float64 {
    var sum, count int
    c.mapElements(func(n int) {
        sum += n
        count++
    })
    return float64(sum) / float64(count)
}
 
func main() {
    t1 := new(binaryTree)
    t2 := new(bTree)
    a1 := average(t1)
    a2 := average(t2)
    fmt.Println(""binary tree average:"", a1)
    fmt.Println(""b-tree average:"", a2)
}
 
type intCollection interface {
    mapElements(func(int))
}
 
type binaryTree struct {
    // dummy representation details
    left, right bool
}
 
func (t *binaryTree) mapElements(visit func(int)) {
    // dummy implementation
    if t.left == t.right {
        visit(3)
        visit(1)
        visit(4)
    }
}
 
type bTree struct {
    // dummy representation details
    buckets int
}
 
func (t *bTree) mapElements(visit func(int)) {
    // dummy implementation
    if t.buckets >= 0 {
        visit(1)
        visit(5)
        visit(9)
    }
}",951,53
29472,http://rosettacode.org/wiki/Partial_function_application,Partial function application,"Partial function application   is the ability to take a function of many
parameters and apply arguments to some of the parameters to create a new
function that needs only the application of the remaining arguments to
produce the equivalent of applying all arguments to the original function.

E.g:

 Given values v1, v2
 Given f(param1, param2)
 Then partial(f, param1=v1) returns f'(param2)
 And f(param1=v1, param2=v2) == f'(param2=v2) (for any value v2)


Note that in the partial application of a parameter, (in the above case param1), other parameters are not explicitly mentioned. This is a recurring feature of partial function application.



Task 
 Create a function fs( f, s ) that takes a function, f( n ), of one value and a sequence of values s.
 Function fs should return an ordered sequence of the result of applying function f to every value of s in turn.
 Create function f1 that takes a value and returns it multiplied by 2.
 Create function f2 that takes a value and returns it squared.
 Partially apply f1 to fs to form function fsf1( s )
 Partially apply f2 to fs to form function fsf2( s )
 Test fsf1 and fsf2 by evaluating them with s being the sequence of integers from 0 to 3 inclusive and then the sequence of even integers from 2 to 8 inclusive.


Notes
 In partially applying the functions f1 or f2 to fs, there should be no explicit mention of any other parameters to fs, although introspection of fs within the partial applicator to find its parameters is allowed.
 This task is more about how results are generated rather than just getting results.

",#Go,Go,"package main
 
import ""fmt""
 
// Using a method bound to a function type:
 
// fn is a simple function taking an integer and returning another.
type fn func(int) int
 
// fs applies fn to each argument returning all results.
func (f fn) fs(s ...int) (r []int) {
	for _, i := range s {
		r = append(r, f(i))
	}
	return r
}
 
// Two simple functions for demonstration.
func f1(i int) int { return i * 2 }
func f2(i int) int { return i * i }
 
// Another way:
 
// addn returns a function that adds n to a sequence of numbers
func addn(n int) func(...int) []int {
	return func(s ...int) []int {
		var r []int
		for _, i := range s {
			r = append(r, n+i)
		}
		return r
	}
}
 
func main() {
	// Turning a method into a function bound to it's reciever:
	fsf1 := fn(f1).fs
	fsf2 := fn(f2).fs
	// Or using a function that returns a function:
	fsf3 := addn(100)
 
	s := []int{0, 1, 2, 3}
	fmt.Println(""For s ="", s)
	fmt.Println(""  fsf1:"", fsf1(s...))       // Called with a slice
	fmt.Println(""  fsf2:"", fsf2(0, 1, 2, 3)) // ... or with individual arguments
	fmt.Println(""  fsf3:"", fsf3(0, 1, 2, 3))
	fmt.Println(""  fsf2(fsf1):"", fsf2(fsf1(s...)...))
 
	s = []int{2, 4, 6, 8}
	fmt.Println(""For s ="", s)
	fmt.Println(""  fsf1:"", fsf1(2, 4, 6, 8))
	fmt.Println(""  fsf2:"", fsf2(s...))
	fmt.Println(""  fsf3:"", fsf3(s...))
	fmt.Println(""  fsf3(fsf1):"", fsf3(fsf1(s...)...))
}",1362,55
29494,http://rosettacode.org/wiki/Parameterized_SQL_statement,Parameterized SQL statement,"SQL injection
Using a SQL update statement like this one (spacing is optional):

UPDATE players
   SET name = 'Smith, Steve', score = 42, active = TRUE
   WHERE jerseyNum = 99
Non-parameterized SQL is the GoTo statement of database programming. Don't do it, and make sure your coworkers don't either.",#Go,Go,"package main
 
import (
    ""database/sql""
    ""fmt""
 
    _ ""github.com/mattn/go-sqlite3""
)
 
func main() {
    db, _ := sql.Open(""sqlite3"", ""rc.db"")
    defer db.Close()
    db.Exec(`create table players (name, score, active, jerseyNum)`)
    db.Exec(`insert into players values ("""",0,0,""99"")`)
    db.Exec(`insert into players values ("""",0,0,""100"")`)
 
    // Parameterized
    db.Exec(`update players set name=?, score=?, active=? where jerseyNum=?`,
        ""Smith, Steve"", 42, true, ""99"")
 
    rows, _ := db.Query(""select * from players"")
    var (
        name      string
        score     int
        active    bool
        jerseyNum string
    )
    for rows.Next() {
        rows.Scan(&name, &score, &active, &jerseyNum)
        fmt.Printf(""%3s %12s %3d %t\n"", jerseyNum, name, score, active)
    }
    rows.Close()
}",829,33
29539,http://rosettacode.org/wiki/Pancake_numbers,Pancake numbers,"Adrian Monk has problems and an assistant, Sharona Fleming. Sharona can deal with most of Adrian's problems except his lack of punctuality paying her remuneration. 2 pay checks down and she prepares him pancakes for breakfast. Knowing that he will be unable to eat them unless they are stacked in ascending order of size she leaves him only a skillet which he can insert at any point in the pile and flip all the above pancakes, repeating until the pile is sorted. Sharona has left the pile of n pancakes such that the maximum number of flips is required. Adrian is determined to do this in as few flips as possible. This sequence n->p(n) is known as the Pancake numbers.

The task is to determine p(n) for n = 1 to 9, and for each show an example requiring p(n) flips.

Sorting_algorithms/Pancake_sort actually performs the sort some giving the number of flips used. How do these compare with p(n)?

Few people know p(20), generously I shall award an extra credit for anyone doing more than p(16).



References
 Bill Gates and the pancake problem
 A058986

",#Go,Go,"package main
 
import ""fmt""
 
func pancake(n int) int {
    gap, sum, adj := 2, 2, -1
    for sum < n {
        adj++
        gap = gap*2 - 1
        sum += gap
    }
    return n + adj
}
 
func main() {
    for i := 0; i < 4; i++ {
        for j := 1; j < 6; j++ {
            n := i*5 + j
            fmt.Printf(""p(%2d) = %2d  "", n, pancake(n))
        }
        fmt.Println()
    }
}",386,23
29554,http://rosettacode.org/wiki/Parsing/RPN_to_infix_conversion,Parsing/RPN to infix conversion,"Parsing/RPN to infix conversion

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a program that takes an RPN representation of an expression formatted as a space separated sequence of tokens and generates the equivalent expression in infix notation.

 Assume an input of a correct, space separated, string of tokens
 Generate a space separated output string representing the same expression in infix notation
 Show how the major datastructure of your algorithm changes with each new token parsed.
 Test with the following input RPN strings then print and display the output here.


 RPN input 
 sample output


 3 4 2 * 1 5 - 2 3 ^ ^ / +
 3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3


 1 2 + 3 4 + ^ 5 6 + ^
 ( ( 1 + 2 ) ^ ( 3 + 4 ) ) ^ ( 5 + 6 )

 Operator precedence and operator associativity is given in this table:


 operator 
 precedence 
 associativity 
 operation


  ^  
 4 
 right 
 exponentiation


  *  
 3 
 left 
 multiplication


  /  
 3 
 left 
 division


  +  
 2 
 left 
 addition


  -  
 2 
 left 
 subtraction



See also

   Parsing/Shunting-yard algorithm   for a method of generating an RPN from an infix expression.
   Parsing/RPN calculator algorithm   for a method of calculating a final value from this output RPN expression.
   Postfix to infix   from the RubyQuiz site.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
var tests = []string{
    ""3 4 2 * 1 5 - 2 3 ^ ^ / +"",
    ""1 2 + 3 4 + ^ 5 6 + ^"",
}
 
var opa = map[string]struct {
    prec   int
    rAssoc bool
}{
    ""^"": {4, true},
    ""*"": {3, false},
    ""/"": {3, false},
    ""+"": {2, false},
    ""-"": {2, false},
}
 
const nPrec = 9
 
func main() {
    for _, t := range tests {
        parseRPN(t)
    }
}
 
func parseRPN(e string) {
    fmt.Println(""\npostfix:"", e)
    type sf struct {
        prec int
        expr string
    }
    var stack []sf
    for _, tok := range strings.Fields(e) {
        fmt.Println(""token:"", tok)
        if op, isOp := opa[tok]; isOp {
            rhs := &stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            lhs := &stack[len(stack)-1]
            if lhs.prec < op.prec || (lhs.prec == op.prec && op.rAssoc) {
                lhs.expr = ""("" + lhs.expr + "")""
            }
            lhs.expr += "" "" + tok + "" ""
            if rhs.prec < op.prec || (rhs.prec == op.prec && !op.rAssoc) {
                lhs.expr += ""("" + rhs.expr + "")""
            } else {
                lhs.expr += rhs.expr
            }
            lhs.prec = op.prec
        } else {
            stack = append(stack, sf{nPrec, tok})
        }
        for _, f := range stack {
            fmt.Printf(""    %d %q\n"", f.prec, f.expr)
        }
    }
    fmt.Println(""infix:"", stack[0].expr)
}",1412,63
29575,http://rosettacode.org/wiki/Paraffins,Paraffins,"
This organic chemistry task is essentially to implement a tree enumeration algorithm.



Task

Enumerate, without repetitions and in order of increasing size, all possible paraffin molecules (also known as alkanes).



Paraffins are built up using only carbon atoms, which has four bonds, and hydrogen, which has one bond.   All bonds for each atom must be used, so it is easiest to think of an alkane as linked carbon atoms forming the ""backbone"" structure, with adding hydrogen atoms linking the remaining unused bonds.

In a paraffin, one is allowed neither double bonds (two bonds between the same pair of atoms), nor cycles of linked carbons.   So all paraffins with   n   carbon atoms share the empirical formula     CnH2n+2

But for all   n ≥ 4   there are several distinct molecules (""isomers"") with the same formula but different structures.

The number of isomers rises rather rapidly when   n   increases.

In counting isomers it should be borne in mind that the four bond positions on a given carbon atom can be freely interchanged and bonds rotated (including 3-D ""out of the paper"" rotations when it's being observed on a flat diagram),   so rotations or re-orientations of parts of the molecule (without breaking bonds) do not give different isomers.   So what seem at first to be different molecules may in fact turn out to be different orientations of the same molecule.



Example

With   n = 3   there is only one way of linking the carbons despite the different orientations the molecule can be drawn;   and with   n = 4   there are two configurations:

   a   straight   chain:     (CH3)(CH2)(CH2)(CH3) 
   a branched chain:       (CH3)(CH(CH3))(CH3)


Due to bond rotations, it doesn't matter which direction the branch points in.

The phenomenon of ""stereo-isomerism"" (a molecule being different from its mirror image due to the actual 3-D arrangement of bonds) is ignored for the purpose of this task.

The input is the number   n   of carbon atoms of a molecule (for instance 17).

The output is how many different different paraffins there are with   n   carbon atoms (for instance   24,894   if   n = 17).

The sequence of those results is visible in the OEIS entry:  

   oeis:A00602 number of n-node unrooted quartic trees; number of n-carbon alkanes C(n)H(2n+2) ignoring stereoisomers. 
The sequence is (the index starts from zero, and represents the number of carbon atoms):

1, 1, 1, 1, 2, 3, 5, 9, 18, 35, 75, 159, 355, 802, 1858, 4347, 10359,
24894, 60523, 148284, 366319, 910726, 2278658, 5731580, 14490245,
36797588, 93839412, 240215803, 617105614, 1590507121, 4111846763,
10660307791, 27711253769, ...



Extra credit

Show the paraffins in some way. 

A flat 1D representation, with arrays or lists is enough, for instance:

*Main> all_paraffins 1
                        [CCP H H H H]
*Main> all_paraffins 2
                        [BCP (C H H H) (C H H H)]
*Main> all_paraffins 3
                        [CCP H H (C H H H) (C H H H)]
*Main> all_paraffins 4
                        [BCP (C H H (C H H H)) (C H H (C H H H)),
                         CCP H (C H H H) (C H H H) (C H H H)]
*Main> all_paraffins 5
                        [CCP H H (C H H (C H H H)) (C H H (C H H H)),
                         CCP H (C H H H) (C H H H) (C H H (C H H H)),
                         CCP (C H H H) (C H H H) (C H H H) (C H H H)]
*Main> all_paraffins 6
                        [BCP (C H H (C H H (C H H H))) (C H H (C H H (C H H H))),
                         BCP (C H H (C H H (C H H H))) (C H (C H H H) (C H H H)),
                         BCP (C H (C H H H) (C H H H)) (C H (C H H H) (C H H H)),
                         CCP H (C H H H) (C H H (C H H H)) (C H H (C H H H)),
                         CCP (C H H H) (C H H H) (C H H H) (C H H (C H H H))]
Showing a basic 2D ASCII-art representation of the paraffins is better; for instance (molecule names aren't necessary):

       methane          ethane               propane               isobutane
 
          H              H   H              H   H   H              H   H   H
          │              │   │              │   │   │              │   │   │
      H ─ C ─ H      H ─ C ─ C ─ H      H ─ C ─ C ─ C ─ H      H ─ C ─ C ─ C ─ H
          │              │   │              │   │   │              │   │   │
          H              H   H              H   H   H              H   │   H
                                                                       │
                                                                   H ─ C ─ H
                                                                       │
                                                                       H
Links

   A paper that explains the problem and its solution in a functional language:
http://www.cs.wright.edu/~tkprasad/courses/cs776/paraffins-turner.pdf

   A Haskell implementation:
https://github.com/ghc/nofib/blob/master/imaginary/paraffins/Main.hs

   A Scheme implementation:
http://www.ccs.neu.edu/home/will/Twobit/src/paraffins.scm

   A Fortress implementation:         (this site has been closed)
http://java.net/projects/projectfortress/sources/sources/content/ProjectFortress/demos/turnersParaffins0.fss?rev=3005
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
const branches = 4
const nMax = 500
 
var rooted, unrooted [nMax + 1]big.Int
var c [branches]big.Int
var tmp = new(big.Int)
var one = big.NewInt(1)
 
func tree(br, n, l, sum int, cnt *big.Int) {
    for b := br + 1; b <= branches; b++ {
        sum += n
        if sum > nMax {
            return
        }
        if l*2 >= sum && b >= branches {
            return
        }
        if b == br+1 {
            c[br].Mul(&rooted[n], cnt)
        } else {
            tmp.Add(&rooted[n], tmp.SetInt64(int64(b-br-1)))
            c[br].Mul(&c[br], tmp)
            c[br].Div(&c[br], tmp.SetInt64(int64(b-br)))
        }
        if l*2 < sum {
            unrooted[sum].Add(&unrooted[sum], &c[br])
        }
        if b < branches {
            rooted[sum].Add(&rooted[sum], &c[br])
        }
        for m := n - 1; m > 0; m-- {
            tree(b, m, l, sum, &c[br])
        }
    }
}
 
func bicenter(s int) {
    if s&1 == 0 {
        tmp.Rsh(tmp.Mul(&rooted[s/2], tmp.Add(&rooted[s/2], one)), 1)
        unrooted[s].Add(&unrooted[s], tmp)
    }
}
 
func main() {
    rooted[0].SetInt64(1)
    rooted[1].SetInt64(1)
    unrooted[0].SetInt64(1)
    unrooted[1].SetInt64(1)
    for n := 1; n <= nMax; n++ {
        tree(0, n, n, 1, big.NewInt(1))
        bicenter(n)
        fmt.Printf(""%d: %d\n"", n, &unrooted[n])
    }
}",1375,61
29600,http://rosettacode.org/wiki/Parsing/Shunting-yard_algorithm,Parsing/Shunting-yard algorithm,"Task

Given the operator characteristics and input from the Shunting-yard algorithm page and tables, use the algorithm to show the changes in the operator stack and RPN output
as each individual token is processed.

 Assume an input of a correct, space separated, string of tokens representing an infix expression
 Generate a space separated output string representing the RPN
 Test with the input string:
  3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3  
 print and display the output here.
 Operator precedence is given in this table:


 operator 
 precedence 
 associativity 
 operation


  ^  
 4 
 right 
 exponentiation


  *  
 3 
 left 
 multiplication


  /  
 3 
 left 
 division


  +  
 2 
 left 
 addition


  -  
 2 
 left 
 subtraction



Extra credit
Add extra text explaining the actions and an optional comment for the action on receipt of each token.



Note
The handling of functions and arguments is not required.



See also

 Parsing/RPN calculator algorithm for a method of calculating a final value from this output RPN expression.
 Parsing/RPN to infix conversion.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
var input = ""3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3""
 
var opa = map[string]struct {
    prec   int
    rAssoc bool
}{
    ""^"": {4, true},
    ""*"": {3, false},
    ""/"": {3, false},
    ""+"": {2, false},
    ""-"": {2, false},
}
 
func main() {
    fmt.Println(""infix:  "", input)
    fmt.Println(""postfix:"", parseInfix(input))
}
 
func parseInfix(e string) (rpn string) {
    var stack []string // holds operators and left parenthesis
    for _, tok := range strings.Fields(e) {
        switch tok {
        case ""("":
            stack = append(stack, tok) // push ""("" to stack
        case "")"":
            var op string
            for {
                // pop item (""("" or operator) from stack
                op, stack = stack[len(stack)-1], stack[:len(stack)-1]
                if op == ""("" {
                    break // discard ""(""
                }
                rpn += "" "" + op // add operator to result
            }
        default:
            if o1, isOp := opa[tok]; isOp {
                // token is an operator
                for len(stack) > 0 {
                    // consider top item on stack
                    op := stack[len(stack)-1]
                    if o2, isOp := opa[op]; !isOp || o1.prec > o2.prec ||
                        o1.prec == o2.prec && o1.rAssoc {
                        break
                    }
                    // top item is an operator that needs to come off
                    stack = stack[:len(stack)-1] // pop it
                    rpn += "" "" + op              // add it to result
                }
                // push operator (the new one) to stack
                stack = append(stack, tok)
            } else { // token is an operand
                if rpn > """" {
                    rpn += "" ""
                }
                rpn += tok // add operand to result
            }
        }
    }
    // drain stack to result
    for len(stack) > 0 {
        rpn += "" "" + stack[len(stack)-1]
        stack = stack[:len(stack)-1]
    }
    return
}",2056,72
29622,http://rosettacode.org/wiki/Parallel_calculations,Parallel calculations,"Many programming languages allow you to specify computations to be run in parallel.
While Concurrent computing is focused on concurrency,
the purpose of this task is to distribute time-consuming calculations
on as many CPUs as possible.

Assume we have a collection of numbers, and want to find the one
with the largest minimal prime factor
(that is, the one that contains relatively large factors).
To speed up the search, the factorization should be done
in parallel using separate threads or processes,
to take advantage of multi-core CPUs.

Show how this can be formulated in your language.
Parallelize the factorization of those numbers,
then search the returned list of numbers and factors
for the largest minimal factor,
and return that number and its prime factors.

For the prime number decomposition
you may use the solution of the Prime decomposition task.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
// collection of numbers.  A slice is used for the collection.
// The elements are big integers, since that's what the function Primes
// uses (as was specified by the Prime decomposition task.)
var numbers = []*big.Int{
    big.NewInt(12757923),
    big.NewInt(12878611),
    big.NewInt(12878893),
    big.NewInt(12757923),
    big.NewInt(15808973),
    big.NewInt(15780709),
}
 
// main just calls the function specified by the task description and
// prints results.  note it allows for multiple numbers with the largest
// minimal factor.  the task didn't specify to handle this, but obviously
// it's possible.
func main() {
    rs := lmf(numbers)
    fmt.Println(""largest minimal factor:"", rs[0].decomp[0])
    for _, r := range rs {
        fmt.Println(r.number, ""->"", r.decomp)
    }
}
 
// this type associates a number with it's prime decomposition.
// the type is neccessary so that they can be sent together over
// a Go channel, but it turns out to be convenient as well for
// the return type of lmf.
type result struct {
    number *big.Int
    decomp []*big.Int
}
 
// the function specified by the task description, ""largest minimal factor.""
func lmf([]*big.Int) []result {
    // construct result channel and start a goroutine to decompose each number.
    // goroutines run in parallel as CPU cores are available.
    rCh := make(chan result)
    for _, n := range numbers {
        go decomp(n, rCh)
    }
 
    // collect results.  <-rCh returns a single result from the result channel.
    // we know how many results to expect so code here collects exactly that
    // many results, and accumulates a list of those with the largest
    // minimal factor.
    rs := []result{<-rCh}
    for i := 1; i < len(numbers); i++ {
        switch r := <-rCh; r.decomp[0].Cmp(rs[0].decomp[0]) {
        case 1:
            rs = rs[:1]
            rs[0] = r
        case 0:
            rs = append(rs, r)
        }
    }
    return rs
}
 
// decomp is the function run as a goroutine.  multiple instances of this
// function will run concurrently, one for each number being decomposed.
// it acts as a driver for Primes, calling Primes as needed, packaging
// the result, and sending the packaged result on the channel.
// ""as needed"" turns out to mean sending Primes a copy of n, as Primes
// as written is destructive on its argument.
func decomp(n *big.Int, rCh chan result) {
    rCh <- result{n, Primes(new(big.Int).Set(n))}
}
 
// code below copied from Prime decomposition task
var (
    ZERO = big.NewInt(0)
    ONE  = big.NewInt(1)
)
 
func Primes(n *big.Int) []*big.Int {
    res := []*big.Int{}
    mod, div := new(big.Int), new(big.Int)
    for i := big.NewInt(2); i.Cmp(n) != 1; {
        div.DivMod(n, i, mod)
        for mod.Cmp(ZERO) == 0 {
            res = append(res, new(big.Int).Set(i))
            n.Set(div)
            div.DivMod(n, i, mod)
        }
        i.Add(i, ONE)
    }
    return res
}",2982,96
29673,http://rosettacode.org/wiki/Parallel_brute_force,Parallel brute force,"Task

Find, through brute force, the five-letter passwords corresponding with the following SHA-256 hashes:

1. 1115dd800feaacefdf481f1f9070374a2a81e27880f187396db67958b207cbad
2. 3a7bd3e2360a3d29eea436fcfb7e44c735d117c42d1c1835420b6b9942dd4f1b
3. 74e1bb62f8dabb8125a58852b63bdf6eaef667cb56ac7f7cdba6d7305c50a22f

Your program should naively iterate through all possible passwords consisting only of five lower-case ASCII English letters. It should use concurrent or parallel processing, if your language supports that feature. You may calculate SHA-256 hashes by calling a library or through a custom implementation. Print each matching password, along with its SHA-256 hash.

Related task: SHA-256
",#Go,Go,"package main
 
import (
    ""crypto/sha256""
    ""encoding/hex""
    ""log""
    ""sync""
)
 
var hh = []string{
    ""1115dd800feaacefdf481f1f9070374a2a81e27880f187396db67958b207cbad"",
    ""3a7bd3e2360a3d29eea436fcfb7e44c735d117c42d1c1835420b6b9942dd4f1b"",
    ""74e1bb62f8dabb8125a58852b63bdf6eaef667cb56ac7f7cdba6d7305c50a22f"",
}
 
func main() {
    log.SetFlags(0)
    hd := make([][sha256.Size]byte, len(hh))
    for i, h := range hh {
        hex.Decode(hd[i][:], []byte(h))
    }
    var wg sync.WaitGroup
    wg.Add(26)
    for c := byte('a'); c <= 'z'; c++ {
        go bf4(c, hd, &wg)
    }
    wg.Wait()
}
 
func bf4(c byte, hd [][sha256.Size]byte, wg *sync.WaitGroup) {
    p := []byte(""aaaaa"")
    p[0] = c
    p1 := p[1:]
p:
    for {
        ph := sha256.Sum256(p)
        for i, h := range hd {
            if h == ph {
                log.Println(string(p), hh[i])
            }
        }
        for i, v := range p1 {
            if v < 'z' {
                p1[i]++
                continue p
            }
            p1[i] = 'a'
        }
        wg.Done()
        return
    }
}",1093,52
29750,http://rosettacode.org/wiki/Pascal_matrix_generation,Pascal matrix generation,"A pascal matrix is a two-dimensional square matrix holding numbers from   Pascal's triangle,   also known as   binomial coefficients   and which can be shown as   nCr.

Shown below are truncated   5-by-5   matrices   M[i, j]   for   i,j   in range   0..4. 


A Pascal upper-triangular matrix that is populated with   jCi:

[[1, 1, 1, 1, 1],
 [0, 1, 2, 3, 4],
 [0, 0, 1, 3, 6],
 [0, 0, 0, 1, 4],
 [0, 0, 0, 0, 1]]

A Pascal lower-triangular matrix that is populated with   iCj   (the transpose of the upper-triangular matrix):

[[1, 0, 0, 0, 0],
 [1, 1, 0, 0, 0],
 [1, 2, 1, 0, 0],
 [1, 3, 3, 1, 0],
 [1, 4, 6, 4, 1]]

A Pascal symmetric matrix that is populated with   i+jCi:

[[1, 1, 1, 1, 1],
 [1, 2, 3, 4, 5],
 [1, 3, 6, 10, 15],
 [1, 4, 10, 20, 35],
 [1, 5, 15, 35, 70]]



Task

Write functions capable of generating each of the three forms of   n-by-n   matrices.

Use those functions to display upper, lower, and symmetric Pascal   5-by-5   matrices on this page.

The output should distinguish between different matrices and the rows of each matrix   (no showing a list of 25 numbers assuming the reader should split it into rows).



Note
 
The   Cholesky decomposition   of a Pascal symmetric matrix is the Pascal lower-triangle matrix of the same size.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func binomial(n, k int) int {
    if n < k {
        return 0
    }
    if n == 0 || k == 0 {
        return 1
    }
    num := 1
    for i := k + 1; i <= n; i++ {
        num *= i
    }
    den := 1
    for i := 2; i <= n-k; i++ {
        den *= i
    }
    return num / den
}
 
func pascalUpperTriangular(n int) [][]int {
    m := make([][]int, n)
    for i := 0; i < n; i++ {
        m[i] = make([]int, n)
        for j := 0; j < n; j++ {
            m[i][j] = binomial(j, i)
        }
    }
    return m
}
 
func pascalLowerTriangular(n int) [][]int {
    m := make([][]int, n)
    for i := 0; i < n; i++ {
        m[i] = make([]int, n)
        for j := 0; j < n; j++ {
            m[i][j] = binomial(i, j)
        }
    }
    return m
}
 
func pascalSymmetric(n int) [][]int {
    m := make([][]int, n)
    for i := 0; i < n; i++ {
        m[i] = make([]int, n)
        for j := 0; j < n; j++ {
            m[i][j] = binomial(i+j, i)
        }
    }
    return m
}
 
func printMatrix(title string, m [][]int) {
    n := len(m)
    fmt.Println(title)
    fmt.Print(""["")
    for i := 0; i < n; i++ {
        if i > 0 {
            fmt.Print("" "")
        }
        mi := strings.Replace(fmt.Sprint(m[i]), "" "", "", "", -1)
        fmt.Print(mi)
        if i < n-1 {
            fmt.Println("","")
        } else {
            fmt.Println(""]\n"")
        }
    }
}
 
func main() {
    printMatrix(""Pascal upper-triangular matrix"", pascalUpperTriangular(5))
    printMatrix(""Pascal lower-triangular matrix"", pascalLowerTriangular(5))
    printMatrix(""Pascal symmetric matrix"", pascalSymmetric(5))
}",1644,81
29767,http://rosettacode.org/wiki/Palindromic_gapful_numbers,Palindromic gapful numbers,"Palindromic gapful numbers

You are encouraged to solve this task according to the task description, using any language you may know.
Numbers   (positive integers expressed in base ten)   that are (evenly) divisible by the number formed by the
first and last digit are known as   gapful numbers.


Evenly divisible   means divisible with   no   remainder.



All   one─   and two─digit   numbers have this property and are trivially excluded.   Only
numbers    ≥  100   will be considered for this Rosetta Code task.



Example

1037   is a   gapful   number because it is evenly divisible by the
number   17   which is formed by the first and last decimal digits
of    1037. 



A palindromic number is   (for this task, a positive integer expressed in base ten),   when the number is
reversed,   is the same as the original number.



Task

   Show   (nine sets)   the first   20   palindromic gapful numbers that   end   with:
   the digit   1
   the digit   2
   the digit   3
   the digit   4
   the digit   5
   the digit   6
   the digit   7
   the digit   8
   the digit   9
   Show   (nine sets, like above)   of palindromic gapful numbers:
   the last   15   palindromic gapful numbers   (out of      100)
   the last   10   palindromic gapful numbers   (out of   1,000)       {optional}


For other ways of expressing the (above) requirements, see the   discussion   page.



Note

All palindromic gapful numbers are divisible by eleven.



Related tasks

   palindrome detection.
   gapful numbers.


Also see

   The OEIS entry:   A108343 gapful numbers.

",#Go,Go,"package main
 
import ""fmt""
 
func reverse(s uint64) uint64 {
    e := uint64(0)
    for s > 0 {
        e = e*10 + (s % 10)
        s /= 10
    }
    return e
}
 
func commatize(n uint) string {
    s := fmt.Sprintf(""%d"", n)
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    return s
}
 
func ord(n uint) string {
    var suffix string
    if n > 10 && ((n-11)%100 == 0 || (n-12)%100 == 0 || (n-13)%100 == 0) {
        suffix = ""th""
    } else {
        switch n % 10 {
        case 1:
            suffix = ""st""
        case 2:
            suffix = ""nd""
        case 3:
            suffix = ""rd""
        default:
            suffix = ""th""
        }
    }
    return fmt.Sprintf(""%s%s"", commatize(n), suffix)
}
 
func main() {
    const max = 10_000_000
    data := [][3]uint{{1, 20, 7}, {86, 100, 8}, {991, 1000, 10}, {9995, 10000, 12}, {1e5, 1e5, 14},
        {1e6, 1e6, 16}, {1e7, 1e7, 18}}
    results := make(map[uint][]uint64)
    for _, d := range data {
        for i := d[0]; i <= d[1]; i++ {
            results[i] = make([]uint64, 9)
        }
    }
    var p uint64
outer:
    for d := uint64(1); d < 10; d++ {
        count := uint(0)
        pow := uint64(1)
        fl := d * 11
        for nd := 3; nd < 20; nd++ {
            slim := (d + 1) * pow
            for s := d * pow; s < slim; s++ {
                e := reverse(s)
                mlim := uint64(1)
                if nd%2 == 1 {
                    mlim = 10
                }
                for m := uint64(0); m < mlim; m++ {
                    if nd%2 == 0 {
                        p = s*pow*10 + e
                    } else {
                        p = s*pow*100 + m*pow*10 + e
                    }
                    if p%fl == 0 {
                        count++
                        if _, ok := results[count]; ok {
                            results[count][d-1] = p
                        }
                        if count == max {
                            continue outer
                        }
                    }
                }
            }
            if nd%2 == 1 {
                pow *= 10
            }
        }
    }
 
    for _, d := range data {
        if d[0] != d[1] {
            fmt.Printf(""%s to %s palindromic gapful numbers (> 100) ending with:\n"", ord(d[0]), ord(d[1]))
        } else {
            fmt.Printf(""%s palindromic gapful number (> 100) ending with:\n"", ord(d[0]))
        }
        for i := 1; i <= 9; i++ {
            fmt.Printf(""%d: "", i)
            for j := d[0]; j <= d[1]; j++ {
                fmt.Printf(""%*d "", d[2], results[j][i-1])
            }
            fmt.Println()
        }
        fmt.Println()
    }
}",2715,104
29848,http://rosettacode.org/wiki/Parsing/RPN_calculator_algorithm,Parsing/RPN calculator algorithm,"Task

Create a stack-based evaluator for an expression in   reverse Polish notation (RPN)   that also shows the changes in the stack as each individual token is processed as a table.



 Assume an input of a correct, space separated, string of tokens of an RPN expression
 Test with the RPN expression generated from the   Parsing/Shunting-yard algorithm   task: 

         3 4 2 * 1 5 - 2 3 ^ ^ / + 

 Print or display the output here


Notes

    ^    means exponentiation in the expression above.
    /    means division.


See also

   Parsing/Shunting-yard algorithm for a method of generating an RPN from an infix expression.
   Several solutions to 24 game/Solve make use of RPN evaluators (although tracing how they work is not a part of that task).
   Parsing/RPN to infix conversion.
   Arithmetic evaluation.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""strconv""
    ""strings""
)
 
var input = ""3 4 2 * 1 5 - 2 3 ^ ^ / +""
 
func main() {
    fmt.Printf(""For postfix %q\n"", input)
    fmt.Println(""\nToken            Action            Stack"")
    var stack []float64
    for _, tok := range strings.Fields(input) {
        action := ""Apply op to top of stack""
        switch tok {
        case ""+"":
            stack[len(stack)-2] += stack[len(stack)-1]
            stack = stack[:len(stack)-1]
        case ""-"":
            stack[len(stack)-2] -= stack[len(stack)-1]
            stack = stack[:len(stack)-1]
        case ""*"":
            stack[len(stack)-2] *= stack[len(stack)-1]
            stack = stack[:len(stack)-1]
        case ""/"":
            stack[len(stack)-2] /= stack[len(stack)-1]
            stack = stack[:len(stack)-1]
        case ""^"":
            stack[len(stack)-2] =
                math.Pow(stack[len(stack)-2], stack[len(stack)-1])
            stack = stack[:len(stack)-1]
        default:
            action = ""Push num onto top of stack""
            f, _ := strconv.ParseFloat(tok, 64)
            stack = append(stack, f)
        }
        fmt.Printf(""%3s    %-26s  %v\n"", tok, action, stack)
    }
    fmt.Println(""\nThe final value is"", stack[0])
}",1271,43
30045,http://rosettacode.org/wiki/Pangram_checker,Pangram checker,"Pangram checker

You are encouraged to solve this task according to the task description, using any language you may know.
A pangram is a sentence that contains all the letters of the English alphabet at least once.

For example:   The quick brown fox jumps over the lazy dog.



Task

Write a function or method to check a sentence to see if it is a   pangram   (or not)   and show its use.



Related tasks

   determine if a string has all the same characters
   determine if a string has all unique characters

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    for _, s := range []string{
        ""The quick brown fox jumps over the lazy dog."",
        `Watch ""Jeopardy!"", Alex Trebek's fun TV quiz game.`,
        ""Not a pangram."",
    } {
        if pangram(s) {
            fmt.Println(""Yes:"", s)
        } else {
            fmt.Println(""No: "", s)
        }
    }
}
 
func pangram(s string) bool {
	var missing uint32 = (1 << 26) - 1
	for _, c := range s {
		var index uint32
		if 'a' <= c && c <= 'z' {
			index = uint32(c - 'a')
		} else if 'A' <= c && c <= 'Z' {
			index = uint32(c - 'A')
		} else {
			continue
		}
 
		missing &^= 1 << index
		if missing == 0 {
			return true
		}
	}
	return false
}",695,37
30100,http://rosettacode.org/wiki/Pascal%27s_triangle,Pascal's triangle,"Pascal's triangle is an arithmetic and geometric figure often associated with the name of Blaise Pascal, but also studied centuries earlier in India, Persia, China and elsewhere.

Its first few rows look like this: 

    1
   1 1
  1 2 1
 1 3 3 1 

where each element of each row is either 1 or the sum of the two elements right above it.

For example, the next row of the triangle would be:

   1   (since the first element of each row doesn't have two elements above it)
   4   (1 + 3)
   6   (3 + 3)
   4   (3 + 1)
   1   (since the last element of each row doesn't have two elements above it) 
So the triangle now looks like this: 

    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1 

Each row    n    (starting with row   0   at the top) shows the coefficients of the binomial expansion of    (x + y)n. 



Task

Write a function that prints out the first    n    rows of the triangle   (with    f(1)    yielding the row consisting of only the element 1).

This can be done either by summing elements from the previous rows or using a binary coefficient or combination function.

Behavior for    n ≤ 0    does not need to be uniform, but should be noted.



See also

 Evaluate binomial coefficients

",#Go,Go," 
package main
 
import ""fmt""
 
func printTriangle(n int) {
    // degenerate cases
    if n <= 0 {
        return
    }
    fmt.Println(1)
    if n == 1 {
        return
    }
    // iterate over rows, zero based
    a := make([]int, (n+1)/2)
    a[0] = 1
    for row, middle := 1, 0; row < n; row++ {
        // generate new row
        even := row&1 == 0
        if even {
            a[middle+1] = a[middle] * 2
        }
        for i := middle; i > 0; i-- {
            a[i] += a[i-1]
        }
        // print row
        for i := 0; i <= middle; i++ {
            fmt.Print(a[i], "" "")
        }
        if even {
            middle++
        }
        for i := middle; i >= 0; i-- {
            fmt.Print(a[i], "" "")
        }
        fmt.Println("""")
    }
}
 
func main() {
    printTriangle(4)
}
 ",807,44
30235,"http://rosettacode.org/wiki/P-Adic_numbers,_basic","P-Adic numbers, basic","Conversion and addition of p-adic Numbers.


Task.
Convert two rationals to p-adic numbers and add them up.
Rational reconstruction is needed to interpret the result.

p-Adic numbers were introduced around 1900 by Hensel. p-Adic expansions
(a series of digits 0 ≤ d < p times p-power weights)
are finite-tailed and tend to zero in the direction of higher positive
powers of p (to the left in the notation used here).
For example, the number 4 (100.0) has smaller 2-adic norm than 1/4 (0.01).

If we convert a natural number, the familiar p-ary expansion is obtained:
10 decimal is 1010 both binary and 2-adic. To convert a rational number a/b
we perform p-adic long division. If p is actually prime, this is always possible
if first the 'p-part' is removed from b (and the p-adic point shifted accordingly).
The inverse of b modulo p is then used in the conversion.

Recipe: at each step the most significant digit of the partial remainder
(initially a) is zeroed by subtracting a proper multiple of the divisor b.
Shift out the zero digit (divide by p) and repeat until the remainder is zero
or the precision limit is reached. Because p-adic division starts from the right,
the 'proper multiplier' is simply
d = partial remainder * 1/b (mod p).
The d's are the successive p-adic digits to find.

Addition proceeds as usual, with carry from the right to the leftmost term,
where it has least magnitude and just drops off. We can work with approximate rationals
and obtain exact results. The routine for rational reconstruction demonstrates this:
repeatedly add a p-adic to itself (keeping count to determine the denominator),
until an integer is reached (the numerator then equals the weighted digit sum).
But even p-adic arithmetic fails if the precision is too low. The examples mostly
set the shortest prime-exponent combinations that allow valid reconstruction.



Related task.
p-Adic square roots



Reference.
[1] p-Adic expansions


",#Go,Go,"package main
 
import ""fmt""
 
// constants
const EMX = 64      // exponent maximum (if indexing starts at -EMX)
const DMX = 100000  // approximation loop maximum
const AMX = 1048576 // argument maximum
const PMAX = 32749  // prime maximum
 
// global variables
var p1 = 0
var p = 7  // default prime
var k = 11 // precision
 
func abs(a int) int {
    if a >= 0 {
        return a
    }
    return -a
}
 
func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
 
type Ratio struct {
    a, b int
}
 
type Padic struct {
    v int
    d [2 * EMX]int // add EMX to index to be consistent wih FB
}
 
// (re)initialize receiver from Ratio, set 'sw' to print
func (pa *Padic) r2pa(q Ratio, sw int) int {
    a := q.a
    b := q.b
    if b == 0 {
        return 1
    }
    if b < 0 {
        b = -b
        a = -a
    }
    if abs(a) > AMX || b > AMX {
        return -1
    }
    if p < 2 || k < 1 {
        return 1
    }
    p = min(p, PMAX)  // maximum short prime
    k = min(k, EMX-1) // maxumum array length
    if sw != 0 {
        fmt.Printf(""%d/%d + "", a, b)   // numerator, denominator
        fmt.Printf(""0(%d^%d)\n"", p, k) // prime, precision
    }
 
    // (re)initialize
    pa.v = 0
    p1 = p - 1
    pa.d = [2 * EMX]int{}
    if a == 0 {
        return 0
    }
    i := 0
 
    // find -exponent of p in b
    for b%p == 0 {
        b = b / p
        i--
    }
    s := 0
    r := b % p
 
    // modular inverse for small p
    b1 := 1
    for b1 <= p1 {
        s += r
        if s > p1 {
            s -= p
        }
        if s == 1 {
            break
        }
        b1++
    }
    if b1 == p {
        fmt.Println(""r2pa: impossible inverse mod"")
        return -1
    }
    pa.v = EMX
    for {
        // find exponent of P in a
        for a%p == 0 {
            a = a / p
            i++
        }
 
        // valuation
        if pa.v == EMX {
            pa.v = i
        }
 
        // upper bound
        if i >= EMX {
            break
        }
 
        // check precision
        if (i - pa.v) > k {
            break
        }
 
        // next digit
        pa.d[i+EMX] = a * b1 % p
        if pa.d[i+EMX] < 0 {
            pa.d[i+EMX] += p
        }
 
        // remainder - digit * divisor
        a -= pa.d[i+EMX] * b
        if a == 0 {
            break
        }
    }
    return 0
}
 
// Horner's rule
func (pa *Padic) dsum() int {
    t := min(pa.v, 0)
    s := 0
    for i := k - 1 + t; i >= t; i-- {
        r := s
        s *= p
        if r != 0 && (s/r-p != 0) {
            // overflow
            s = -1
            break
        }
        s += pa.d[i+EMX]
    }
    return s
}
 
// add b to receiver
func (pa *Padic) add(b Padic) *Padic {
    c := 0
    r := Padic{}
    r.v = min(pa.v, b.v)
    for i := r.v; i <= k+r.v; i++ {
        c += pa.d[i+EMX] + b.d[i+EMX]
        if c > p1 {
            r.d[i+EMX] = c - p
            c = 1
        } else {
            r.d[i+EMX] = c
            c = 0
        }
    }
    return &r
}
 
// complement of receiver
func (pa *Padic) cmpt() *Padic {
    c := 1
    r := Padic{}
    r.v = pa.v
    for i := pa.v; i <= k+pa.v; i++ {
        c += p1 - pa.d[i+EMX]
        if c > p1 {
            r.d[i+EMX] = c - p
            c = 1
        } else {
            r.d[i+EMX] = c
            c = 0
        }
    }
    return &r
}
 
// rational reconstruction
func (pa *Padic) crat() {
    fl := false
    s := pa
    j := 0
    i := 1
 
    // denominator count
    for i <= DMX {
        // check for integer
        j = k - 1 + pa.v
        for j >= pa.v {
            if s.d[j+EMX] != 0 {
                break
            }
            j--
        }
        fl = ((j - pa.v) * 2) < k
        if fl {
            fl = false
            break
        }
 
        // check negative integer
        j = k - 1 + pa.v
        for j >= pa.v {
            if p1-s.d[j+EMX] != 0 {
                break
            }
            j--
        }
        fl = ((j - pa.v) * 2) < k
        if fl {
            break
        }
 
        // repeatedly add self to s
        s = s.add(*pa)
        i++
    }
    if fl {
        s = s.cmpt()
    }
 
    // numerator: weighted digit sum
    x := s.dsum()
    y := i
    if x < 0 || y > DMX {
        fmt.Println(x, y)
        fmt.Println(""crat: fail"")
    } else {
        // negative powers
        i = pa.v
        for i <= -1 {
            y *= p
            i++
        }
 
        // negative rational
        if fl {
            x = -x
        }
        fmt.Print(x)
        if y > 1 {
            fmt.Printf(""/%d"", y)
        }
        fmt.Println()
    }
}
 
// print expansion
func (pa *Padic) printf(sw int) {
    t := min(pa.v, 0)
    for i := k - 1 + t; i >= t; i-- {
        fmt.Print(pa.d[i+EMX])
        if i == 0 && pa.v < 0 {
            fmt.Print(""."")
        }
        fmt.Print("" "")
    }
    fmt.Println()
    // rational approximation
    if sw != 0 {
        pa.crat()
    }
}
 
func main() {
    data := [][]int{
        /* rational reconstruction depends on the precision
           until the dsum-loop overflows */
        {2, 1, 2, 4, 1, 1},
        {4, 1, 2, 4, 3, 1},
        {4, 1, 2, 5, 3, 1},
        {4, 9, 5, 4, 8, 9},
        {26, 25, 5, 4, -109, 125},
        {49, 2, 7, 6, -4851, 2},
        {-9, 5, 3, 8, 27, 7},
        {5, 19, 2, 12, -101, 384},
        /* two decadic pairs */
        {2, 7, 10, 7, -1, 7},
        {34, 21, 10, 9, -39034, 791},
        /* familiar digits */
        {11, 4, 2, 43, 679001, 207},
        {-8, 9, 23, 9, 302113, 92},
        {-22, 7, 3, 23, 46071, 379},
        {-22, 7, 32749, 3, 46071, 379},
        {35, 61, 5, 20, 9400, 109},
        {-101, 109, 61, 7, 583376, 6649},
        {-25, 26, 7, 13, 5571, 137},
        {1, 4, 7, 11, 9263, 2837},
        {122, 407, 7, 11, -517, 1477},
        /* more subtle */
        {5, 8, 7, 11, 353, 30809},
    }
 
    sw := 0
    a := Padic{}
    b := Padic{}
 
    for _, d := range data {
        q := Ratio{d[0], d[1]}
        p = d[2]
        k = d[3]
        sw = a.r2pa(q, 1)
        if sw == 1 {
            break
        }
        a.printf(0)
        q.a = d[4]
        q.b = d[5]
        sw = sw | b.r2pa(q, 1)
        if sw == 1 {
            break
        }
        if sw == 0 {
            b.printf(0)
            c := a.add(b)
            fmt.Println(""+ ="")
            c.printf(1)
        }
        fmt.Println()
    }
}",6388,330
30254,http://rosettacode.org/wiki/Padovan_n-step_number_sequences,Padovan n-step number sequences,"As the Fibonacci sequence expands to the Fibonacci n-step number sequences; We similarly expand the Padovan sequence to form these Padovan n-step number sequences.

The Fibonacci-like sequences can be defined like this:

   For n == 2:
       start:      1, 1
       Recurrence: R(n, x) = R(n, x-1) + R(n, x-2); for n == 2
   For n == N:
       start:      First N terms of R(N-1, x)
       Recurrence: R(N, x) = sum(R(N, x-1) + R(N, x-2) + ... R(N, x-N))

For this task we similarly define terms of the first 2..n-step Padovan sequences as:

   For n == 2:
       start:      1, 1, 1
       Recurrence: R(n, x) = R(n, x-2) + R(n, x-3); for n == 2
   For n == N:
       start:      First N + 1 terms of R(N-1, x)
       Recurrence: R(N, x) = sum(R(N, x-2) + R(N, x-3) + ... R(N, x-N-1))

The initial values of the sequences are:


 Padovan 



n


{\displaystyle n}

-step sequences


 



n


{\displaystyle n}

 
 Values 
 OEIS Entry


 2 
 1,1,1,2,2,3,4,5,7,9,12,16,21,28,37, ... 
 A134816: 'Padovan's spiral numbers'


 3 
 1,1,1,2,3,4,6,9,13,19,28,41,60,88,129, ... 
 A000930: 'Narayana's cows sequence'


 4 
 1,1,1,2,3,5,7,11,17,26,40,61,94,144,221, ... 
 A072465: 'A Fibonacci-like model in which each pair of rabbits dies after the birth of their 4th litter'


 5 
 1,1,1,2,3,5,8,12,19,30,47,74,116,182,286, ... 
 A060961: 'Number of compositions (ordered partitions) of n into 1's, 3's and 5's'


 6 
 1,1,1,2,3,5,8,13,20,32,51,81,129,205,326, ... 
 <not found>


 7 
 1,1,1,2,3,5,8,13,21,33,53,85,136,218,349, ... 
 A117760: 'Expansion of 1/(1 - x - x^3 - x^5 - x^7)'


 8 
 1,1,1,2,3,5,8,13,21,34,54,87,140,225,362, ... 
 <not found>




Task

 Write a function to generate the first 



t


{\displaystyle t}

 terms, of the first 2..max_n Padovan 



n


{\displaystyle n}

-step number sequences as defined above.
 Use this to print and show here at least the first t=15 values of the first 2..8 



n


{\displaystyle n}

-step sequences.
 (The OEIS column in the table above should be omitted).

",#Go,Go,"package main
 
import ""fmt""
 
func padovanN(n, t int) []int {
    if n < 2 || t < 3 {
        ones := make([]int, t)
        for i := 0; i < t; i++ {
            ones[i] = 1
        }
        return ones
    }
    p := padovanN(n-1, t)
    for i := n + 1; i < t; i++ {
        p[i] = 0
        for j := i - 2; j >= i-n-1; j-- {
            p[i] += p[j]
        }
    }
    return p
}
 
func main() {
    t := 15
    fmt.Println(""First"", t, ""terms of the Padovan n-step number sequences:"")
    for n := 2; n <= 8; n++ {
        fmt.Printf(""%d: %3d\n"", n, padovanN(n, t))
    }
}",577,29
30275,http://rosettacode.org/wiki/Palindrome_detection,Palindrome detection,"A palindrome is a phrase which reads the same backward and forward.

Task[edit]
Write a function or program that checks whether a given sequence of characters (or, if you prefer, bytes)
is a palindrome.

For extra credit:

 Support Unicode characters.
 Write a second function (possibly as a wrapper to the first) which detects inexact palindromes, i.e. phrases that are palindromes if white-space and punctuation is ignored and case-insensitive comparison is used.
Hints
 It might be useful for this task to know how to reverse a string.
 This task's entries might also form the subjects of the task Test a function.
Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package pal
 
func IsPal(s string) bool {
    mid := len(s) / 2
    last := len(s) - 1
    for i := 0; i < mid; i++ {
        if s[i] != s[last-i] {
            return false
        }
    }
    return true
}",207,12
30322,http://rosettacode.org/wiki/Ordered_partitions,Ordered partitions,"In this task we want to find the ordered partitions into fixed-size blocks.

This task is related to Combinations in that it has to do with discrete mathematics and moreover a helper function to compute combinations is (probably) needed to solve this task.





p
a
r
t
i
t
i
o
n
s
(



a
r
g



1


,



a
r
g



2


,
.
.
.
,



a
r
g



n


)


{\displaystyle partitions({\mathit {arg}}_{1},{\mathit {arg}}_{2},...,{\mathit {arg}}_{n})}

 should generate all distributions of the elements in 



{
1
,
.
.
.
,

Σ

i
=
1


n





a
r
g



i


}


{\displaystyle \{1,...,\Sigma _{i=1}^{n}{\mathit {arg}}_{i}\}}

 into 



n


{\displaystyle n}

 blocks of respective size 






a
r
g



1


,



a
r
g



2


,
.
.
.
,



a
r
g



n




{\displaystyle {\mathit {arg}}_{1},{\mathit {arg}}_{2},...,{\mathit {arg}}_{n}}

.

Example 1: 



p
a
r
t
i
t
i
o
n
s
(
2
,
0
,
2
)


{\displaystyle partitions(2,0,2)}

 would create:

{({1, 2}, {}, {3, 4}), 
 ({1, 3}, {}, {2, 4}), 
 ({1, 4}, {}, {2, 3}), 
 ({2, 3}, {}, {1, 4}), 
 ({2, 4}, {}, {1, 3}), 
 ({3, 4}, {}, {1, 2})}

Example 2: 



p
a
r
t
i
t
i
o
n
s
(
1
,
1
,
1
)


{\displaystyle partitions(1,1,1)}

 would create:

{({1}, {2}, {3}), 
 ({1}, {3}, {2}), 
 ({2}, {1}, {3}), 
 ({2}, {3}, {1}), 
 ({3}, {1}, {2}), 
 ({3}, {2}, {1})}

Note that the number of elements in the list is








(






a
r
g



1


+



a
r
g



2


+
.
.
.
+



a
r
g



n






a
r
g



1




)



⋅



(






a
r
g



2


+



a
r
g



3


+
.
.
.
+



a
r
g



n






a
r
g



2




)



⋅
…
⋅



(





a
r
g



n





a
r
g



n




)





{\displaystyle {{\mathit {arg}}_{1}+{\mathit {arg}}_{2}+...+{\mathit {arg}}_{n} \choose {\mathit {arg}}_{1}}\cdot {{\mathit {arg}}_{2}+{\mathit {arg}}_{3}+...+{\mathit {arg}}_{n} \choose {\mathit {arg}}_{2}}\cdot \ldots \cdot {{\mathit {arg}}_{n} \choose {\mathit {arg}}_{n}}}


(see the definition of the binomial coefficient if you are not familiar with this notation) and the number of elements remains the same regardless of how the argument is permuted
(i.e. the multinomial coefficient).

Also, 



p
a
r
t
i
t
i
o
n
s
(
1
,
1
,
1
)


{\displaystyle partitions(1,1,1)}

 creates the permutations of 



{
1
,
2
,
3
}


{\displaystyle \{1,2,3\}}

 and thus there would be 



3
!
=
6


{\displaystyle 3!=6}

 elements in the list.

Note: Do not use functions that are not in the standard library of the programming language you use. Your file should be written so that it can be executed on the command line and by default outputs the result of 



p
a
r
t
i
t
i
o
n
s
(
2
,
0
,
2
)


{\displaystyle partitions(2,0,2)}

. If the programming language does not support polyvariadic functions pass a list as an argument.

Notation

Here are some explanatory remarks on the notation used in the task description:





{
1
,
…
,
n
}


{\displaystyle \{1,\ldots ,n\}}

 denotes the set of consecutive numbers from 



1


{\displaystyle 1}

 to 



n


{\displaystyle n}

, e.g. 



{
1
,
2
,
3
}


{\displaystyle \{1,2,3\}}

 if 



n
=
3


{\displaystyle n=3}

.





Σ


{\displaystyle \Sigma }

 is the mathematical notation for summation, e.g. 




Σ

i
=
1


3


i
=
6


{\displaystyle \Sigma _{i=1}^{3}i=6}

 (see also [1]).








a
r
g



1


,



a
r
g



2


,
.
.
.
,



a
r
g



n




{\displaystyle {\mathit {arg}}_{1},{\mathit {arg}}_{2},...,{\mathit {arg}}_{n}}

 are the arguments — natural numbers — that the sought function receives.



",#Go,Go,"package main
 
import (
	""fmt""
	""os""
	""strconv""
)
 
func gen_part(n, res []int, pos int) {
	if pos == len(res) {
		x := make([][]int, len(n))
		for i, c := range res {
			x[c] = append(x[c], i+1)
		}
 
		fmt.Println(x)
		return
	}
 
	for i := range n {
		if n[i] == 0 {
			continue
		}
		n[i], res[pos] = n[i]-1, i
		gen_part(n, res, pos+1)
		n[i]++
	}
}
 
func ordered_part(n_parts []int) {
	fmt.Println(""Ordered"", n_parts)
 
	sum := 0
	for _, c := range n_parts {
		sum += c
	}
 
	gen_part(n_parts, make([]int, sum), 0)
}
 
func main() {
	if len(os.Args) < 2 {
		ordered_part([]int{2, 0, 2})
		return
	}
	n := make([]int, len(os.Args)-1)
	var err error
	for i, a := range os.Args[1:] {
		n[i], err = strconv.Atoi(a)
		if err != nil {
			fmt.Println(err)
			return
		}
		if n[i] < 0 {
			fmt.Println(""negative partition size not meaningful"")
			return
		}
	}
	ordered_part(n)
}",878,60
30344,http://rosettacode.org/wiki/Palindrome_dates,Palindrome dates,"Today   (2020-02-02,   at the time of this writing)   happens to be a palindrome,   without the hyphens,   not only for those countries which express their dates in the   yyyy-mm-dd   format but,   unusually,   also for countries which use the   dd-mm-yyyy   format.



Task
Write a program which calculates and shows the next 15 palindromic dates for those countries which express their dates in the   yyyy-mm-dd   format.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""time""
)
 
func reverse(s string) string {
    chars := []rune(s)
    for i, j := 0, len(chars)-1; i < j; i, j = i+1, j-1 {
        chars[i], chars[j] = chars[j], chars[i]
    }
    return string(chars)
}
 
func main() {
    const (
        layout  = ""20060102""
        layout2 = ""2006-01-02""
    )
    fmt.Println(""The next 15 palindromic dates in yyyymmdd format after 20200202 are:"")
    date := time.Date(2020, 2, 2, 0, 0, 0, 0, time.UTC)
    count := 0
    for count < 15 {
        date = date.AddDate(0, 0, 1)
        s := date.Format(layout)
        r := reverse(s)
        if r == s {
            fmt.Println(date.Format(layout2))
            count++
        }
    }
}",714,33
30350,http://rosettacode.org/wiki/Padovan_sequence,Padovan sequence,"

The Padovan sequence is similar to the Fibonacci sequence in several ways.
Some are given in the table below, and the referenced video shows some of the geometric
similarities.



 Comment 
 Padovan 
 Fibonacci


 
 



 Named after. 
 Richard Padovan 
 Leonardo of Pisa: Fibonacci


 
 



 Recurrence initial values. 
 P(0)=P(1)=P(2)=1 
 F(0)=0, F(1)=1


 Recurrence relation. 
 P(n)=P(n-2)+P(n-3) 
 F(n)=F(n-1)+F(n-2)


 
 



 First 10 terms. 
 1,1,1,2,2,3,4,5,7,9 
 0,1,1,2,3,5,8,13,21,34


 
 



 Ratio of successive terms... 
 Plastic ratio, p 
 Golden ratio, g


 
 1.324717957244746025960908854… 
 1.6180339887498948482...


 Exact formula of ratios p and q. 
 ((9+69**.5)/18)**(1/3) + ((9-69**.5)/18)**(1/3) 
 (1+5**0.5)/2


 Ratio is real root of polynomial. 
 p: x**3-x-1 
 g: x**2-x-1


 
 



 Spirally tiling the plane using. 
 Equilateral triangles 
 Squares


 
 



 Constants for ... 
 s= 1.0453567932525329623 
 a=5**0.5


 ... Computing by truncation. 
 P(n)=floor(p**(n-1) / s + .5) 
 F(n)=floor(g**n / a + .5)


 
 



 L-System Variables. 
 A,B,C 
 A,B


 L-System Start/Axiom. 
 A 
 A


 L-System Rules. 
 A->B,B->C,C->AB 
 A->B,B->AB

Task

 Write a function/method/subroutine to compute successive members of the Padovan series using the recurrence relation.
 Write a function/method/subroutine to compute successive members of the Padovan series using the floor function.
 Show the first twenty terms of the sequence.
 Confirm that the recurrence and floor based functions give the same results for 64 terms,
 Write a function/method/... using the L-system to generate successive strings.
 Show the first 10 strings produced from the L-system
 Confirm that the length of the first 32 strings produced is the Padovan sequence.
Show output here, on this page.

Ref

 The Plastic Ratio - Numberphile video.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/big""
    ""strings""
)
 
func padovanRecur(n int) []int {
    p := make([]int, n)
    p[0], p[1], p[2] = 1, 1, 1
    for i := 3; i < n; i++ {
        p[i] = p[i-2] + p[i-3]
    }
    return p
}
 
func padovanFloor(n int) []int {
    var p, s, t, u = new(big.Rat), new(big.Rat), new(big.Rat), new(big.Rat)
    p, _ = p.SetString(""1.324717957244746025960908854"")
    s, _ = s.SetString(""1.0453567932525329623"")
    f := make([]int, n)
    pow := new(big.Rat).SetInt64(1)
    u = u.SetFrac64(1, 2)
    t.Quo(pow, p)
    t.Quo(t, s)
    t.Add(t, u)
    v, _ := t.Float64()
    f[0] = int(math.Floor(v))
    for i := 1; i < n; i++ {
        t.Quo(pow, s)
        t.Add(t, u)
        v, _ = t.Float64()
        f[i] = int(math.Floor(v))
        pow.Mul(pow, p)
    }
    return f
}
 
type LSystem struct {
    rules         map[string]string
    init, current string
}
 
func step(lsys *LSystem) string {
    var sb strings.Builder
    if lsys.current == """" {
        lsys.current = lsys.init
    } else {
        for _, c := range lsys.current {
            sb.WriteString(lsys.rules[string(c)])
        }
        lsys.current = sb.String()
    }
    return lsys.current
}
 
func padovanLSys(n int) []string {
    rules := map[string]string{""A"": ""B"", ""B"": ""C"", ""C"": ""AB""}
    lsys := &LSystem{rules, ""A"", """"}
    p := make([]string, n)
    for i := 0; i < n; i++ {
        p[i] = step(lsys)
    }
    return p
}
 
// assumes lists are same length
func areSame(l1, l2 []int) bool {
    for i := 0; i < len(l1); i++ {
        if l1[i] != l2[i] {
            return false
        }
    }
    return true
}
 
func main() {
    fmt.Println(""First 20 members of the Padovan sequence:"")
    fmt.Println(padovanRecur(20))
    recur := padovanRecur(64)
    floor := padovanFloor(64)
    same := areSame(recur, floor)
    s := ""give""
    if !same {
        s = ""do not give""
    }
    fmt.Println(""\nThe recurrence and floor based functions"", s, ""the same results for 64 terms."")
 
    p := padovanLSys(32)
    lsyst := make([]int, 32)
    for i := 0; i < 32; i++ {
        lsyst[i] = len(p[i])
    }
    fmt.Println(""\nFirst 10 members of the Padovan L-System:"")
    fmt.Println(p[:10])
    fmt.Println(""\nand their lengths:"")
    fmt.Println(lsyst[:10])
 
    same = areSame(recur[:32], lsyst)
    s = ""give""
    if !same {
        s = ""do not give""
    }
    fmt.Println(""\nThe recurrence and L-system based functions"", s, ""the same results for 32 terms."")
 ",2499,107
30455,http://rosettacode.org/wiki/Order_by_pair_comparisons,Order by pair comparisons,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Assume we have a set of items that can be sorted into an order by the user.

The user is presented with pairs of items from the set in no order,
the user states which item
is less than, equal to, or greater than the other (with respect to their
relative positions if fully ordered).

Write a function that given items that the user can order, asks the user to
give the result of comparing two items at a time and uses the comparison results
to eventually return the items in order.

Try and minimise the comparisons the user is asked for.

Show on this page, the function ordering the colours of the rainbow:

   violet red green indigo blue yellow orange

The correct ordering being:

   red orange yellow green blue indigo violet

Note:

 Asking for/receiving user comparisons is a part of the task.
 Code inputs should not assume an ordering.
 The seven colours can form twenty-one different pairs.
 A routine that does not ask the user ""too many"" comparison questions should be used.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
    ""strings""
)
 
var count int = 0
 
func interactiveCompare(s1, s2 string) bool {
    count++
    fmt.Printf(""(%d) Is %s < %s? "", count, s1, s2)
    var response string
    _, err := fmt.Scanln(&response)
    return err == nil && strings.HasPrefix(response, ""y"")
}
 
func main() {
    items := []string{""violet"", ""red"", ""green"", ""indigo"", ""blue"", ""yellow"", ""orange""}
 
    var sortedItems []string
 
    // Use a binary insertion sort to order the items.  It should ask for
    // close to the minimum number of questions required
    for _, item := range items {
        fmt.Printf(""Inserting '%s' into %s\n"", item, sortedItems)
        // sort.Search performs the binary search using interactiveCompare to
        // rank the items
        spotToInsert := sort.Search(len(sortedItems), func(i int) bool {
            return interactiveCompare(item, sortedItems[i])
        })
        sortedItems = append(sortedItems[:spotToInsert],
                             append([]string{item}, sortedItems[spotToInsert:]...)...)
    }
    fmt.Println(sortedItems)
}",1105,37
30538,http://rosettacode.org/wiki/P-value_correction,P-value correction,"Given a list of p-values, adjust the p-values for multiple comparisons. This is done in order to control the false positive, or Type 1 error rate.

This is also known as the ""false discovery rate"" (FDR). After adjustment, the p-values will be higher but still inside [0,1].

The adjusted p-values are sometimes called ""q-values"".



Task

Given one list of p-values, return the p-values correcting for multiple comparisons

   p = {4.533744e-01, 7.296024e-01, 9.936026e-02, 9.079658e-02, 1.801962e-01,
        8.752257e-01, 2.922222e-01, 9.115421e-01, 4.355806e-01, 5.324867e-01,
        4.926798e-01, 5.802978e-01, 3.485442e-01, 7.883130e-01, 2.729308e-01,
        8.502518e-01, 4.268138e-01, 6.442008e-01, 3.030266e-01, 5.001555e-02,
        3.194810e-01, 7.892933e-01, 9.991834e-01, 1.745691e-01, 9.037516e-01,
        1.198578e-01, 3.966083e-01, 1.403837e-02, 7.328671e-01, 6.793476e-02,
        4.040730e-03, 3.033349e-04, 1.125147e-02, 2.375072e-02, 5.818542e-04,
        3.075482e-04, 8.251272e-03, 1.356534e-03, 1.360696e-02, 3.764588e-04,
        1.801145e-05, 2.504456e-07, 3.310253e-02, 9.427839e-03, 8.791153e-04,
        2.177831e-04, 9.693054e-04, 6.610250e-05, 2.900813e-02, 5.735490e-03}



There are several methods to do this, see:

 Yoav Benjamini, Yosef Hochberg ""Controlling the False Discovery Rate: A Practical and Powerful Approach to Multiple Testing"", Journal of the Royal Statistical Society. Series B, Vol. 57, No. 1 (1995), pp. 289-300, JSTOR:2346101
 Yoav Benjamini, Daniel Yekutieli, ""The control of the false discovery rate in multiple testing under dependency"", Ann. Statist., Vol. 29, No. 4 (2001), pp. 1165-1188, DOI:10.1214/aos/1013699998 JSTOR:2674075
 Sture Holm, ""A Simple Sequentially Rejective Multiple Test Procedure"", Scandinavian Journal of Statistics, Vol. 6, No. 2 (1979), pp. 65-70, JSTOR:4615733
 Yosef Hochberg, ""A sharper Bonferroni procedure for multiple tests of significance"", Biometrika, Vol. 75, No. 4 (1988), pp 800–802, DOI:10.1093/biomet/75.4.800 JSTOR:2336325
 Gerhard Hommel, ""A stagewise rejective multiple test procedure based on a modified Bonferroni test"", Biometrika, Vol. 75, No. 2 (1988), pp 383–386, DOI:10.1093/biomet/75.2.383 JSTOR:2336190


Each method has its own advantages and disadvantages.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math""
    ""os""
    ""sort""
    ""strconv""
    ""strings""
)
 
type pvalues = []float64
 
type iv1 struct {
    index int
    value float64
}
type iv2 struct{ index, value int }
 
type direction int
 
const (
    up direction = iota
    down
)
 
// Test also for 'Unknown' correction type.
var ctypes = []string{
    ""Benjamini-Hochberg"", ""Benjamini-Yekutieli"", ""Bonferroni"", ""Hochberg"",
    ""Holm"", ""Hommel"", ""Šidák"", ""Unknown"",
}
 
func minimum(p pvalues) float64 {
    m := p[0]
    for i := 1; i < len(p); i++ {
        if p[i] < m {
            m = p[i]
        }
    }
    return m
}
 
func maximum(p pvalues) float64 {
    m := p[0]
    for i := 1; i < len(p); i++ {
        if p[i] > m {
            m = p[i]
        }
    }
    return m
}
 
func adjusted(p pvalues, ctype string) (string, error) {
    err := check(p)
    if err != nil {
        return """", err
    }
    temp := pformat(adjust(p, ctype), 5)
    return fmt.Sprintf(""\n%s\n%s"", ctype, temp), nil
}
 
func pformat(p pvalues, cols int) string {
    var lines []string
    for i := 0; i < len(p); i += cols {
        fchunk := p[i : i+cols]
        schunk := make([]string, cols)
        for j := 0; j < cols; j++ {
            schunk[j] = strconv.FormatFloat(fchunk[j], 'f', 10, 64)
        }
        lines = append(lines, fmt.Sprintf(""[%2d]  %s"", i, strings.Join(schunk, "" "")))
    }
    return strings.Join(lines, ""\n"")
}
 
func check(p []float64) error {
    cond := len(p) > 0 && minimum(p) >= 0 && maximum(p) <= 1
    if !cond {
        return fmt.Errorf(""p-values must be in range 0.0 to 1.0"")
    }
    return nil
}
 
func ratchet(p pvalues, dir direction) {
    size := len(p)
    m := p[0]
    if dir == up {
        for i := 1; i < size; i++ {
            if p[i] > m {
                p[i] = m
            }
            m = p[i]
        }
    } else {
        for i := 1; i < size; i++ {
            if p[i] < m {
                p[i] = m
            }
            m = p[i]
        }
    }
    for i := 0; i < size; i++ {
        if p[i] > 1.0 {
            p[i] = 1.0
        }
    }
}
 
func schwartzian(p pvalues, mult pvalues, dir direction) pvalues {
    size := len(p)
    order := make([]int, size)
    iv1s := make([]iv1, size)
    for i := 0; i < size; i++ {
        iv1s[i] = iv1{i, p[i]}
    }
    if dir == up {
        sort.Slice(iv1s, func(i, j int) bool {
            return iv1s[i].value > iv1s[j].value
        })
    } else {
        sort.Slice(iv1s, func(i, j int) bool {
            return iv1s[i].value < iv1s[j].value
        })
    }
    for i := 0; i < size; i++ {
        order[i] = iv1s[i].index
    }
    pa := make(pvalues, size)
    for i := 0; i < size; i++ {
        pa[i] = mult[i] * p[order[i]]
    }
    ratchet(pa, dir)
    order2 := make([]int, size)
    iv2s := make([]iv2, size)
    for i := 0; i < size; i++ {
        iv2s[i] = iv2{i, order[i]}
    }
    sort.Slice(iv2s, func(i, j int) bool {
        return iv2s[i].value < iv2s[j].value
    })
    for i := 0; i < size; i++ {
        order2[i] = iv2s[i].index
    }
    pa2 := make(pvalues, size)
    for i := 0; i < size; i++ {
        pa2[i] = pa[order2[i]]
    }
    return pa2
}
 
func adjust(p pvalues, ctype string) pvalues {
    size := len(p)
    if size == 0 {
        return p
    }
    fsize := float64(size)
    switch ctype {
    case ""Benjamini-Hochberg"":
        mult := make(pvalues, size)
        for i := 0; i < size; i++ {
            mult[i] = fsize / float64(size-i)
        }
        return schwartzian(p, mult, up)
    case ""Benjamini-Yekutieli"":
        q := 0.0
        for i := 1; i <= size; i++ {
            q += 1.0 / float64(i)
        }
        mult := make(pvalues, size)
        for i := 0; i < size; i++ {
            mult[i] = q * fsize / (fsize - float64(i))
        }
        return schwartzian(p, mult, up)
    case ""Bonferroni"":
        p2 := make(pvalues, size)
        for i := 0; i < size; i++ {
            p2[i] = math.Min(p[i]*fsize, 1.0)
        }
        return p2
    case ""Hochberg"":
        mult := make(pvalues, size)
        for i := 0; i < size; i++ {
            mult[i] = float64(i) + 1
        }
        return schwartzian(p, mult, up)
    case ""Holm"":
        mult := make(pvalues, size)
        for i := 0; i < size; i++ {
            mult[i] = fsize - float64(i)
        }
        return schwartzian(p, mult, down)
    case ""Hommel"":
        order := make([]int, size)
        iv1s := make([]iv1, size)
        for i := 0; i < size; i++ {
            iv1s[i] = iv1{i, p[i]}
        }
        sort.Slice(iv1s, func(i, j int) bool {
            return iv1s[i].value < iv1s[j].value
        })
        for i := 0; i < size; i++ {
            order[i] = iv1s[i].index
        }
        s := make(pvalues, size)
        for i := 0; i < size; i++ {
            s[i] = p[order[i]]
        }
        m := make(pvalues, size)
        for i := 0; i < size; i++ {
            m[i] = s[i] * fsize / (float64(i) + 1)
        }
        min := minimum(m)
        q := make(pvalues, size)
        for i := 0; i < size; i++ {
            q[i] = min
        }
        pa := make(pvalues, size)
        for i := 0; i < size; i++ {
            pa[i] = min
        }
        for j := size - 1; j >= 2; j-- {
            lower := make([]int, size-j+1) // lower indices
            for i := 0; i < len(lower); i++ {
                lower[i] = i
            }
            upper := make([]int, j-1) // upper indices
            for i := 0; i < len(upper); i++ {
                upper[i] = size - j + 1 + i
            }
            qmin := float64(j) * s[upper[0]] / 2.0
            for i := 1; i < len(upper); i++ {
                temp := s[upper[i]] * float64(j) / (2.0 + float64(i))
                if temp < qmin {
                    qmin = temp
                }
            }
            for i := 0; i < len(lower); i++ {
                q[lower[i]] = math.Min(s[lower[i]]*float64(j), qmin)
            }
            for i := 0; i < len(upper); i++ {
                q[upper[i]] = q[size-j]
            }
            for i := 0; i < size; i++ {
                if pa[i] < q[i] {
                    pa[i] = q[i]
                }
            }
        }
        order2 := make([]int, size)
        iv2s := make([]iv2, size)
        for i := 0; i < size; i++ {
            iv2s[i] = iv2{i, order[i]}
        }
        sort.Slice(iv2s, func(i, j int) bool {
            return iv2s[i].value < iv2s[j].value
        })
        for i := 0; i < size; i++ {
            order2[i] = iv2s[i].index
        }
        pa2 := make(pvalues, size)
        for i := 0; i < size; i++ {
            pa2[i] = pa[order2[i]]
        }
        return pa2
    case ""Šidák"":
        p2 := make(pvalues, size)
        for i := 0; i < size; i++ {
            p2[i] = 1.0 - math.Pow(1.0-float64(p[i]), fsize)
        }
        return p2
    default:
        fmt.Printf(""\nSorry, do not know how to do '%s' correction.\n"", ctype)
        fmt.Println(""Perhaps you want one of these?:"")
        temp := make([]string, len(ctypes)-1)
        for i := 0; i < len(temp); i++ {
            temp[i] = fmt.Sprintf(""  %s"", ctypes[i])
        }
        fmt.Println(strings.Join(temp, ""\n""))
        os.Exit(1)
    }
    return p
}
 
func main() {
    p := pvalues{
        4.533744e-01, 7.296024e-01, 9.936026e-02, 9.079658e-02, 1.801962e-01,
        8.752257e-01, 2.922222e-01, 9.115421e-01, 4.355806e-01, 5.324867e-01,
        4.926798e-01, 5.802978e-01, 3.485442e-01, 7.883130e-01, 2.729308e-01,
        8.502518e-01, 4.268138e-01, 6.442008e-01, 3.030266e-01, 5.001555e-02,
        3.194810e-01, 7.892933e-01, 9.991834e-01, 1.745691e-01, 9.037516e-01,
        1.198578e-01, 3.966083e-01, 1.403837e-02, 7.328671e-01, 6.793476e-02,
        4.040730e-03, 3.033349e-04, 1.125147e-02, 2.375072e-02, 5.818542e-04,
        3.075482e-04, 8.251272e-03, 1.356534e-03, 1.360696e-02, 3.764588e-04,
        1.801145e-05, 2.504456e-07, 3.310253e-02, 9.427839e-03, 8.791153e-04,
        2.177831e-04, 9.693054e-04, 6.610250e-05, 2.900813e-02, 5.735490e-03,
    }
    for _, ctype := range ctypes {
        s, err := adjusted(p, ctype)
        if err != nil {
            log.Fatal(err)
        }
        fmt.Println(s)
    }
}",8238,304
30564,http://rosettacode.org/wiki/OpenWebNet_password,OpenWebNet password,"Calculate the password requested by ethernet gateways from the Legrand / Bticino MyHome OpenWebNet home automation system when the user's ip address is not in the gateway's whitelist

Note: Factory default password is '12345'. Changing it is highly recommended !

conversation goes as follows

← *#*1##
→ *99*0##
← *#603356072##
at which point a password should be sent back, calculated from the ""password open"" that is set in the gateway, and the nonce that was just sent

→ *#25280520##
← *#*1##",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
func ownCalcPass(password, nonce string) uint32 {
    start := true
    num1 := uint32(0)
    num2 := num1
    i, _ := strconv.Atoi(password)
    pwd := uint32(i)
    for _, c := range nonce {
        if c != '0' {
            if start {
                num2 = pwd
            }
            start = false
        }
        switch c {
        case '1':
            num1 = (num2 & 0xFFFFFF80) >> 7
            num2 = num2 << 25
        case '2':
            num1 = (num2 & 0xFFFFFFF0) >> 4
            num2 = num2 << 28
        case '3':
            num1 = (num2 & 0xFFFFFFF8) >> 3
            num2 = num2 << 29
        case '4':
            num1 = num2 << 1
            num2 = num2 >> 31
        case '5':
            num1 = num2 << 5
            num2 = num2 >> 27
        case '6':
            num1 = num2 << 12
            num2 = num2 >> 20
        case '7':
            num3 := num2 & 0x0000FF00
            num4 := ((num2 & 0x000000FF) << 24) | ((num2 & 0x00FF0000) >> 16)
            num1 = num3 | num4
            num2 = (num2 & 0xFF000000) >> 8
        case '8':
            num1 = (num2&0x0000FFFF)<<16 | (num2 >> 24)
            num2 = (num2 & 0x00FF0000) >> 8
        case '9':
            num1 = ^num2
        default:
            num1 = num2
        }
 
        num1 &= 0xFFFFFFFF
        num2 &= 0xFFFFFFFF
        if c != '0' && c != '9' {
            num1 |= num2
        }
        num2 = num1
    }
    return num1
}
 
func testPasswordCalc(password, nonce string, expected uint32) {
    res := ownCalcPass(password, nonce)
    m := fmt.Sprintf(""%s  %s  %-10d  %-10d"", password, nonce, res, expected)
    if res == expected {
        fmt.Println(""PASS"", m)
    } else {
        fmt.Println(""FAIL"", m)
    }
}
 
func main() {
    testPasswordCalc(""12345"", ""603356072"", 25280520)
    testPasswordCalc(""12345"", ""410501656"", 119537670)
    testPasswordCalc(""12345"", ""630292165"", 4269684735)
}",1955,78
30566,http://rosettacode.org/wiki/OLE_automation,OLE automation,"OLE Automation   is an inter-process communication mechanism based on   Component Object Model   (COM) on Microsoft Windows.



Task

Provide an automation server implementing objects that can be accessed by a client running in a separate process.

The client gets a proxy-object that can call methods on the object.

The communication should be able to handle conversions of variants to and from the native value types.



",#Go,Go,"package main
 
import (
    ""time""
    ole ""github.com/go-ole/go-ole""
    ""github.com/go-ole/go-ole/oleutil""
)
 
func main() {
    ole.CoInitialize(0)
    unknown, _ := oleutil.CreateObject(""Word.Application"")
    word, _ := unknown.QueryInterface(ole.IID_IDispatch)
    oleutil.PutProperty(word, ""Visible"", true)
    documents := oleutil.MustGetProperty(word, ""Documents"").ToIDispatch()
    document := oleutil.MustCallMethod(documents, ""Add"").ToIDispatch()
    content := oleutil.MustGetProperty(document, ""Content"").ToIDispatch()
    paragraphs := oleutil.MustGetProperty(content, ""Paragraphs"").ToIDispatch()
    paragraph := oleutil.MustCallMethod(paragraphs, ""Add"").ToIDispatch()
    rnge := oleutil.MustGetProperty(paragraph, ""Range"").ToIDispatch()
    oleutil.PutProperty(rnge, ""Text"", ""This is a Rosetta Code test document."")
 
    time.Sleep(10 * time.Second)
 
    oleutil.PutProperty(document, ""Saved"", true)
    oleutil.CallMethod(document, ""Close"", false)
    oleutil.CallMethod(word, ""Quit"")
    word.Release()
 
    ole.CoUninitialize()
}",1053,30
30579,http://rosettacode.org/wiki/One-time_pad,One-time pad,"Implement a One-time pad, for encrypting and decrypting messages.

To keep it simple, we will be using letters only.

Sub-Tasks

 Generate the data for a One-time pad (user needs to specify a filename and length)
 The important part is to get ""true random"" numbers, e.g. from /dev/random
 encryption / decryption ( basically the same operation, much like Rot-13 )
 For this step, much of Vigenère cipher could be reused,
with the key to be read from the file containing the One-time pad.
 optional: management of One-time pads: list, mark as used, delete, etc.
 Somehow, the users needs to keep track which pad to use for which partner.
To support the management of pad-files:

 Such files have a file-extension "".1tp""
 Lines starting with ""#"" may contain arbitary meta-data (i.e. comments)
 Lines starting with ""-"" count as ""used""
 Whitespace within the otp-data is ignored


For example, here is the data from Wikipedia:

# Example data - Wikipedia - 2014-11-13
-ZDXWWW EJKAWO FECIFE WSNZIP PXPKIY URMZHI JZTLBC YLGDYJ 
-HTSVTV RRYYEG EXNCGA GGQVRF FHZCIB EWLGGR BZXQDQ DGGIAK 
 YHJYEQ TDLCQT HZBSIZ IRZDYS RBYJFZ AIRCWI UCVXTW YKPQMK 
 CKHVEX VXYVCS WOGAAZ OUVVON GCNEVR LMBLYB SBDCDC PCGVJX 
 QXAUIP PXZQIJ JIUWYH COVWMJ UZOJHL DWHPER UBSRUJ HGAAPR 
 CRWVHI FRNTQW AJVWRT ACAKRD OZKIIB VIQGBK IJCWHF GTTSSE 
 EXFIPJ KICASQ IOUQTP ZSGXGH YTYCTI BAZSTN JKMFXI RERYWE 



See also
 one time pad encryption in Python
 snapfractalpop - One-Time-Pad Command-Line-Utility (C).
 Crypt-OTP-2.00 on CPAN (Perl)

",#Go,Go,"package main
 
import (
    ""bufio""
    ""crypto/rand""
    ""fmt""
    ""io/ioutil""
    ""log""
    ""math/big""
    ""os""
    ""strconv""
    ""strings""
    ""unicode""
)
 
const (
    charsPerLine = 48
    chunkSize    = 6
    cols         = 8
    demo         = true // would normally be set to false
)
 
type fileType int
 
const (
    otp fileType = iota
    enc
    dec
)
 
var scnr = bufio.NewScanner(os.Stdin)
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func toAlpha(s string) string {
    var filtered []rune
    for _, r := range s {
        if unicode.IsUpper(r) {
            filtered = append(filtered, r)
        }
    }
    return string(filtered)
}
 
func isOtpRelated(s string) bool {
    return strings.HasSuffix(s, "".1tp"") || strings.HasSuffix(s, ""1tp_cpy"") ||
        strings.HasSuffix(s, "".1tp_enc"") || strings.HasSuffix(s, ""1tp_dec"")
}
 
func makePad(nLines int) string {
    nChars := nLines * charsPerLine
    bytes := make([]byte, nChars)
    /* generate random upper case letters */
    max := big.NewInt(26)
    for i := 0; i < nChars; i++ {
        n, err := rand.Int(rand.Reader, max)
        check(err)
        bytes[i] = byte(65 + n.Uint64())
    }
    return inChunks(string(bytes), nLines, otp)
}
 
func vigenere(text, key string, encrypt bool) string {
    bytes := make([]byte, len(text))
    var ci byte
    for i, c := range text {
        if encrypt {
            ci = (byte(c) + key[i] - 130) % 26
        } else {
            ci = (byte(c) + 26 - key[i]) % 26
        }
        bytes[i] = ci + 65
    }
    temp := len(bytes) % charsPerLine
    if temp > 0 { // pad with random characters so each line is a full one
        max := big.NewInt(26)
        for i := temp; i < charsPerLine; i++ {
            n, err := rand.Int(rand.Reader, max)
            check(err)
            bytes = append(bytes, byte(65+n.Uint64()))
        }
    }
    ft := enc
    if !encrypt {
        ft = dec
    }
    return inChunks(string(bytes), len(bytes)/charsPerLine, ft)
}
 
func inChunks(s string, nLines int, ft fileType) string {
    nChunks := len(s) / chunkSize
    remainder := len(s) % chunkSize
    chunks := make([]string, nChunks)
    for i := 0; i < nChunks; i++ {
        chunks[i] = s[i*chunkSize : (i+1)*chunkSize]
    }
    if remainder > 0 {
        chunks = append(chunks, s[nChunks*chunkSize:])
    }
    var sb strings.Builder
    for i := 0; i < nLines; i++ {
        j := i * cols
        sb.WriteString("" "" + strings.Join(chunks[j:j+cols], "" "") + ""\n"")
    }
    ss := "" file\n"" + sb.String()
    switch ft {
    case otp:
        return ""# OTP"" + ss
    case enc:
        return ""# Encrypted"" + ss
    default: // case dec:
        return ""# Decrypted"" + ss
    }
}
 
func menu() int {
    fmt.Println(`
1. Create one time pad file.
 
2. Delete one time pad file.
 
3. List one time pad files.
 
4. Encrypt plain text.
 
5. Decrypt cipher text.
 
6. Quit program.
`)
    choice := 0
    for choice < 1 || choice > 6 {
        fmt.Print(""Your choice (1 to 6) : "")
        scnr.Scan()
        choice, _ = strconv.Atoi(scnr.Text())
        check(scnr.Err())
    }
    return choice
}
 
func main() {
    for {
        choice := menu()
        fmt.Println()
        switch choice {
        case 1: // Create OTP
            fmt.Println(""Note that encrypted lines always contain 48 characters.\n"")
            fmt.Print(""OTP file name to create (without extension) : "")
            scnr.Scan()
            fileName := scnr.Text() + "".1tp""
            nLines := 0
            for nLines < 1 || nLines > 1000 {
                fmt.Print(""Number of lines in OTP (max 1000) : "")
                scnr.Scan()
                nLines, _ = strconv.Atoi(scnr.Text())
            }
            check(scnr.Err())
            key := makePad(nLines)
            file, err := os.Create(fileName)
            check(err)
            _, err = file.WriteString(key)
            check(err)
            file.Close()
            fmt.Printf(""\n'%s' has been created in the current directory.\n"", fileName)
            if demo {
                // a copy of the OTP file would normally be on a different machine
                fileName2 := fileName + ""_cpy"" // copy for decryption
                file, err := os.Create(fileName2)
                check(err)
                _, err = file.WriteString(key)
                check(err)
                file.Close()
                fmt.Printf(""'%s' has been created in the current directory.\n"", fileName2)
                fmt.Println(""\nThe contents of these files are :\n"")
                fmt.Println(key)
            }
        case 2: // Delete OTP
            fmt.Println(""Note that this will also delete ALL associated files.\n"")
            fmt.Print(""OTP file name to delete (without extension) : "")
            scnr.Scan()
            toDelete1 := scnr.Text() + "".1tp""
            check(scnr.Err())
            toDelete2 := toDelete1 + ""_cpy""
            toDelete3 := toDelete1 + ""_enc""
            toDelete4 := toDelete1 + ""_dec""
            allToDelete := []string{toDelete1, toDelete2, toDelete3, toDelete4}
            deleted := 0
            fmt.Println()
            for _, name := range allToDelete {
                if _, err := os.Stat(name); !os.IsNotExist(err) {
                    err = os.Remove(name)
                    check(err)
                    deleted++
                    fmt.Printf(""'%s' has been deleted from the current directory.\n"", name)
                }
            }
            if deleted == 0 {
                fmt.Println(""There are no files to delete."")
            }
        case 3: // List OTPs
            fmt.Println(""The OTP (and related) files in the current directory are:\n"")
            files, err := ioutil.ReadDir(""."") // already sorted by file name
            check(err)
            for _, fi := range files {
                name := fi.Name()
                if !fi.IsDir() && isOtpRelated(name) {
                    fmt.Println(name)
                }
            }
        case 4: // Encrypt
            fmt.Print(""OTP file name to use (without extension) : "")
            scnr.Scan()
            keyFile := scnr.Text() + "".1tp""
            if _, err := os.Stat(keyFile); !os.IsNotExist(err) {
                file, err := os.Open(keyFile)
                check(err)
                bytes, err := ioutil.ReadAll(file)
                check(err)
                file.Close()
                lines := strings.Split(string(bytes), ""\n"")
                le := len(lines)
                first := le
                for i := 0; i < le; i++ {
                    if strings.HasPrefix(lines[i], "" "") {
                        first = i
                        break
                    }
                }
                if first == le {
                    fmt.Println(""\nThat file has no unused lines."")
                    continue
                }
                lines2 := lines[first:] // get rid of comments and used lines
 
                fmt.Println(""Text to encrypt :-\n"")
                scnr.Scan()
                text := toAlpha(strings.ToUpper(scnr.Text()))
                check(scnr.Err())
                tl := len(text)
                nLines := tl / charsPerLine
                if tl%charsPerLine > 0 {
                    nLines++
                }
                if len(lines2) >= nLines {
                    key := toAlpha(strings.Join(lines2[0:nLines], """"))
                    encrypted := vigenere(text, key, true)
                    encFile := keyFile + ""_enc""
                    file2, err := os.Create(encFile)
                    check(err)
                    _, err = file2.WriteString(encrypted)
                    check(err)
                    file2.Close()
                    fmt.Printf(""\n'%s' has been created in the current directory.\n"", encFile)
                    for i := first; i < first+nLines; i++ {
                        lines[i] = ""-"" + lines[i][1:]
                    }
                    file3, err := os.Create(keyFile)
                    check(err)
                    _, err = file3.WriteString(strings.Join(lines, ""\n""))
                    check(err)
                    file3.Close()
                    if demo {
                        fmt.Println(""\nThe contents of the encrypted file are :\n"")
                        fmt.Println(encrypted)
                    }
                } else {
                    fmt.Println(""Not enough lines left in that file to do encryption."")
                }
            } else {
                fmt.Println(""\nThat file does not exist."")
            }
        case 5: // Decrypt
            fmt.Print(""OTP file name to use (without extension) : "")
            scnr.Scan()
            keyFile := scnr.Text() + "".1tp_cpy""
            check(scnr.Err())
            if _, err := os.Stat(keyFile); !os.IsNotExist(err) {
                file, err := os.Open(keyFile)
                check(err)
                bytes, err := ioutil.ReadAll(file)
                check(err)
                file.Close()
                keyLines := strings.Split(string(bytes), ""\n"")
                le := len(keyLines)
                first := le
                for i := 0; i < le; i++ {
                    if strings.HasPrefix(keyLines[i], "" "") {
                        first = i
                        break
                    }
                }
                if first == le {
                    fmt.Println(""\nThat file has no unused lines."")
                    continue
                }
                keyLines2 := keyLines[first:] // get rid of comments and used lines
 
                encFile := keyFile[0:len(keyFile)-3] + ""enc""
                if _, err := os.Stat(encFile); !os.IsNotExist(err) {
                    file2, err := os.Open(encFile)
                    check(err)
                    bytes, err := ioutil.ReadAll(file2)
                    check(err)
                    file2.Close()
                    encLines := strings.Split(string(bytes), ""\n"")[1:] // exclude comment line
                    nLines := len(encLines)
                    if len(keyLines2) >= nLines {
                        encrypted := toAlpha(strings.Join(encLines, """"))
                        key := toAlpha(strings.Join(keyLines2[0:nLines], """"))
                        decrypted := vigenere(encrypted, key, false)
                        decFile := keyFile[0:len(keyFile)-3] + ""dec""
                        file3, err := os.Create(decFile)
                        check(err)
                        _, err = file3.WriteString(decrypted)
                        check(err)
                        file3.Close()
                        fmt.Printf(""\n'%s' has been created in the current directory.\n"", decFile)
                        for i := first; i < first+nLines; i++ {
                            keyLines[i] = ""-"" + keyLines[i][1:]
                        }
                        file4, err := os.Create(keyFile)
                        check(err)
                        _, err = file4.WriteString(strings.Join(keyLines, ""\n""))
                        check(err)
                        file4.Close()
                        if demo {
                            fmt.Println(""\nThe contents of the decrypted file are :\n"")
                            fmt.Println(decrypted)
                        }
                    }
                } else {
                    fmt.Println(""Not enough lines left in that file to do decryption."")
                }
            } else {
                fmt.Println(""\nThat file does not exist."")
            }
        case 6: // Quit program
            return
        }
    }
}",11669,344
30602,http://rosettacode.org/wiki/Order_disjoint_list_items,Order disjoint list items,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Given   M   as a list of items and another list   N   of items chosen from   M,   create   M'   as a list with the first occurrences of items from   N   sorted to be in one of the set of indices of their original occurrence in   M   but in the order given by their order in   N.

That is, items in   N   are taken from   M   without replacement, then the corresponding positions in   M'   are filled by successive items from   N.



For example

if   M   is   'the cat sat on the mat'
And   N   is   'mat cat' 
Then the result   M'   is   'the mat sat on the cat'. 
The words not in   N   are left in their original positions.



If there are duplications then only the first instances in   M   up to as many as are mentioned in   N   are potentially re-ordered.



For example

  M = 'A B C A B C A B C' 
  N = 'C A C A' 
Is ordered as:

 M' = 'C B A C B A A B C' 


Show the output, here, for at least the following inputs:

Data M: 'the cat sat on the mat' Order N: 'mat cat'
Data M: 'the cat sat on the mat' Order N: 'cat mat'
Data M: 'A B C A B C A B C'      Order N: 'C A C A'
Data M: 'A B C A B D A B E'      Order N: 'E A D A'
Data M: 'A B'                    Order N: 'B'      
Data M: 'A B'                    Order N: 'B A'    
Data M: 'A B B A'                Order N: 'B A'



Cf

 Sort disjoint sublist

",#Go,Go,"package main
 
import (
	""fmt""
	""sort""
	""strings""
)
 
type indexSort struct {
	val sort.Interface
	ind []int
}
 
func (s indexSort) Len() int           { return len(s.ind) }
func (s indexSort) Less(i, j int) bool { return s.ind[i] < s.ind[j] }
func (s indexSort) Swap(i, j int) {
	s.val.Swap(s.ind[i], s.ind[j])
	s.ind[i], s.ind[j] = s.ind[j], s.ind[i]
}
 
func disjointSliceSort(m, n []string) []string {
	s := indexSort{sort.StringSlice(m), make([]int, 0, len(n))}
	used := make(map[int]bool)
	for _, nw := range n {
		for i, mw := range m {
			if used[i] || mw != nw {
				continue
			}
			used[i] = true
			s.ind = append(s.ind, i)
			break
		}
	}
	sort.Sort(s)
	return s.val.(sort.StringSlice)
}
 
func disjointStringSort(m, n string) string {
	return strings.Join(
		disjointSliceSort(strings.Fields(m), strings.Fields(n)), "" "")
}
 
func main() {
	for _, data := range []struct{ m, n string }{
		{""the cat sat on the mat"", ""mat cat""},
		{""the cat sat on the mat"", ""cat mat""},
		{""A B C A B C A B C"", ""C A C A""},
		{""A B C A B D A B E"", ""E A D A""},
		{""A B"", ""B""},
		{""A B"", ""B A""},
		{""A B B A"", ""B A""},
	} {
		mp := disjointStringSort(data.m, data.n)
		fmt.Printf(""%s → %s » %s\n"", data.m, data.n, mp)
	}
 
}",1215,57
30622,http://rosettacode.org/wiki/Operator_precedence,Operator precedence,"

 This page uses content from Wikipedia. The original article was at Operators in C and C++. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Provide a list of   precedence   and   associativity   of all the operators and constructs that the language utilizes in descending order of precedence such that an operator which is listed on some row will be evaluated prior to any operator that is listed on a row further below it.

Operators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same level of precedence, in the given direction.

State whether arguments are passed by value or by reference.



",#Go,Go,"        (expr)                          # grouping
        {expr1;expr2;...}               # compound
        x(expr1,expr2,...)              # process argument list
        x{expr1,expr2,...}              # process co-expression list
        [expr1,expr2,...]               # list
        expr.F                          # field reference
        expr1[expr2]                    # subscript
        expr1[expr2,expr3,...]          # multiple subscript
        expr1[expr2:expr3]              # section
        expr1[expr2+:expr3]             # section
        expr1[expr2-:expr3]             # section

        not expr                        # success/failure reversal
        | expr                          # repeated alternation
        ! expr                          # element generation
        * expr                          # size
        + expr                          # numeric value
        - expr                          # negative
        . expr                          # value (dereference)
        / expr                          # null
        \ expr                          # non-null
        = expr                          # match and tab
        ? expr                          # random value
        ~ expr                          # cset complement
        @ expr                          # activation
        ^ expr                          # refresh

        expr1 \ expr2                   # limitation
        expr1 @ expr2                   # transmission
        expr1 ! expr2                   # invocation

        expr1 ^ expr2                   # power

        expr1 * expr2                   # product
        expr1 / expr2                   # quotient
        expr1 % expr2                   # remainder
        expr1 ** expr2                  # intersection

        expr1 + expr2                   # sum
        expr1 - expr2                   # numeric difference
        expr1 ++ expr2                  # union
        expr1 -- expr2                  # cset or set difference

        expr1 || expr2                  # string concatenation
        expr1 ||| expr2                 # list concatenation

        expr1 < expr2                   # numeric comparison
        expr1 <= expr2                  # numeric comparison
        expr1 = expr2                   # numeric comparison
        expr1 >= expr2                  # numeric comparison
        expr1 > expr2                   # numeric comparison
        expr1 ~= expr2                  # numeric comparison
        expr1 << expr2                  # string comparison
        expr1 <<= expr2                 # string comparison
        expr1 == expr2                  # string comparison
        expr1 >>= expr2                 # string comparison
        expr1 >> expr2                  # string comparison
        expr1 ~== expr2                 # string comparison
        expr1 === expr2                 # value comparison
        expr1 ~=== expr2                # value comparison

        expr1 | expr2                   # alternation

        expr1 to expr2 by expr3         # integer generation

        expr1 := expr2                  # assignment
        expr1 <- expr2                  # reversible assignment
        expr1 :=: expr2                 # exchange
        expr1 <-> expr2                 # reversible exchange
        expr1 op:= expr2                # (augmented assignments)

        expr1 ? expr2                   # string scanning

        expr1 & expr2                   # conjunction

Low Precedence Expressions

        break [expr]                    # break from loop
        case expr0 of {                 # case selection
           expr1:expr2
           ...
           [default:exprn]
           }
        create expr                     # co-expression creation
        every expr1 [do expr2]          # iterate over generated values
        fail                            # failure of procedure
        if expr1 then exp2 [else exp3]  # if-then-else
        next                            # go to top of loop
        repeat expr                     # loop
        return expr                     # return from procedure
        suspend expr1 [do expr2]        # suspension of procedure
        until expr1 [do expr2]          # until-loop
        while expr1 [do expr2]          # while-loop
",4340,94
30725,http://rosettacode.org/wiki/Optional_parameters,Optional parameters,"Task

Define a function/method/subroutine which sorts a sequence (""table"") of sequences (""rows"") of strings (""cells""), by one of the strings. Besides the input to be sorted, it shall have the following optional parameters:





 ordering
 A function specifying the ordering of strings; lexicographic by default.
 column
 An integer specifying which string of each row to compare; the first by default.
 reverse
 Reverses the ordering.


This task should be considered to include both positional and named optional parameters, as well as overloading on argument count as in Java or selector name as in Smalltalk, or, in the extreme, using different function names. Provide these variations of sorting in whatever way is most natural to your language. If the language supports both methods naturally, you are encouraged to describe both.

Do not implement a sorting algorithm; this task is about the interface. If you can't use a built-in sort routine, just omit the implementation (with a comment).

See also:

 Named Arguments

",#Go,Go,"type cell string
 
type spec struct {
    less     func(cell, cell) bool
    column   int
    reverse  bool
}
 
func newSpec() (s spec) {
    // initialize any defaults
    return
}
 
// sort with all defaults
t.sort(newSpec())
 
// reverse sort
s := newSpec
s.reverse = true
t.sort(s)",285,20
30739,http://rosettacode.org/wiki/Numerical_and_alphabetical_suffixes,Numerical and alphabetical suffixes,"This task is about expressing numbers with an attached (abutted) suffix multiplier(s),   the suffix(es) could be:

   an alphabetic (named) multiplier which could be abbreviated
    metric  multiplier(s) which can be specified multiple times
   ""binary"" multiplier(s) which can be specified multiple times
   explanation marks (!) which indicate a factorial or multifactorial


The (decimal) numbers can be expressed generally as:

             {±}   {digits}   {.}   {digits}
                                 ────── or ──────
             {±}   {digits}   {.}   {digits}   {E or e}   {±}   {digits}

where:

   numbers won't have embedded blanks   (contrary to the expaciated examples above where whitespace was used for readability)
   this task will only be dealing with decimal numbers,   both in the   mantissa   and   exponent
   ±   indicates an optional plus or minus sign   (+   or   -)
   digits are the decimal digits   (0 ──► 9)
   the digits can have comma(s) interjected to separate the   periods   (thousands)   such as:   12,467,000
   .   is the decimal point, sometimes also called a   dot
   e   or   E   denotes the use of decimal exponentiation   (a number multiplied by raising ten to some power)


This isn't a pure or perfect definition of the way we express decimal numbers,   but it should convey the intent for this task.

The use of the word   periods   (thousands) is not meant to confuse, that word (as used above) is what the comma separates;

the groups of decimal digits are called periods,   and in almost all cases, are groups of three decimal digits.

If an   e   or   E   is specified, there must be a legal number expressed before it,   and there must be a legal (exponent) expressed after it.

Also, there must be some digits expressed in all cases,   not just a sign and/or decimal point.

Superfluous signs, decimal points, exponent numbers, and zeros   need not be preserved.

I.E.:      
+7   007   7.00   7E-0   7E000   70e-1     could all be expressed as 7

All numbers to be ""expanded"" can be assumed to be valid and there won't be a requirement to verify their validity.



Abbreviated alphabetic suffixes to be supported   (where the capital letters signify the minimum abbreation that can be used)

     PAIRs         multiply the number by  2         (as in pairs of shoes or pants)
     SCOres        multiply the number by  20        (as 3score would be 60)
     DOZens        multiply the number by  12
     GRoss         multiply the number by  144       (twelve dozen)
     GREATGRoss    multiply the number by  1,728     (a dozen gross)
     GOOGOLs       multiply the number by  10^100    (ten raised to the 100&sup>th</sup> power)



Note that the plurals are supported, even though they're usually used when expressing exact numbers   (She has 2 dozen eggs, and dozens of quavas)



Metric suffixes to be supported   (whether or not they're officially sanctioned)

     K     multiply the number by  10^3              kilo      (1,000)
     M     multiply the number by  10^6              mega      (1,000,000)
     G     multiply the number by  10^9              giga      (1,000,000,000)
     T     multiply the number by  10^12             tera      (1,000,000,000,000)
     P     multiply the number by  10^15             peta      (1,000,000,000,000,000)
     E     multiply the number by  10^18             exa       (1,000,000,000,000,000,000)
     Z     multiply the number by  10^21             zetta     (1,000,000,000,000,000,000,000)
     Y     multiply the number by  10^24             yotta     (1,000,000,000,000,000,000,000,000)
     X     multiply the number by  10^27             xenta     (1,000,000,000,000,000,000,000,000,000)
     W     multiply the number by  10^30             wekta     (1,000,000,000,000,000,000,000,000,000,000)
     V     multiply the number by  10^33             vendeka   (1,000,000,000,000,000,000,000,000,000,000,000)
     U     multiply the number by  10^36             udekta    (1,000,000,000,000,000,000,000,000,000,000,000,000)



Binary suffixes to be supported   (whether or not they're officially sanctioned)

     Ki    multiply the number by  2^10              kibi      (1,024)
     Mi    multiply the number by  2^20              mebi      (1,048,576)
     Gi    multiply the number by  2^30              gibi      (1,073,741,824)
     Ti    multiply the number by  2^40              tebi      (1,099,571,627,776)
     Pi    multiply the number by  2^50              pebi      (1,125,899,906,884,629)
     Ei    multiply the number by  2^60              exbi      (1,152,921,504,606,846,976)
     Zi    multiply the number by  2^70              zeb1      (1,180,591,620,717,411,303,424)
     Yi    multiply the number by  2^80              yobi      (1,208,925,819,614,629,174,706,176)
     Xi    multiply the number by  2^90              xebi      (1,237,940,039,285,380,274,899,124,224)
     Wi    multiply the number by  2^100             webi      (1,267,650,600,228,229,401,496,703,205,376)
     Vi    multiply the number by  2^110             vebi      (1,298,074,214,633,706,907,132,624,082,305,024)
     Ui    multiply the number by  2^120             uebi      (1,329,227,995,784,915,872,903,807,060,280,344,576)



All of the metric and binary suffixes can be expressed in   lowercase,   uppercase,   or   mixed case.

All of the metric and binary suffixes can be   stacked   (expressed multiple times),   and also be intermixed:

I.E.:       123k   123K   123GKi   12.3GiGG   12.3e-7T   .78E100e



Factorial suffixes to be supported

     !      compute the (regular) factorial product:   5!   is  5 × 4 × 3 × 2 × 1  =  120
     !!     compute the  double   factorial product:   8!   is  8 × 6 × 4 × 2      =  384
     !!!    compute the  triple   factorial product:   8!   is  8 × 5 × 2          =   80
     !!!!   compute the quadruple factorial product:   8!   is  8 × 4              =   32
     !!!!!  compute the quintuple factorial product:   8!   is  8 × 3              =   24
     ··· the number of factorial symbols that can be specified is to be unlimited   (as per what can be entered/typed) ···



Factorial suffixes aren't, of course, the usual type of multipliers, but are used here in a similar vein.



Multifactorials aren't to be confused with   super─factorials     where   (4!)!   would be   (24)!.



Task

   Using the test cases (below),   show the ""expanded"" numbers here, on this page.
   For each list, show the input on one line,   and also show the output on one line.
   When showing the input line, keep the spaces (whitespace) and case (capitalizations) as is.
   For each result (list) displayed on one line, separate each number with two blanks.
   Add commas to the output numbers were appropriate.


Test cases

    2greatGRo   24Gros  288Doz  1,728pairs  172.8SCOre
    1,567      +1.567k    0.1567e-2m
    25.123kK    25.123m   2.5123e-00002G
    25.123kiKI  25.123Mi  2.5123e-00002Gi  +.25123E-7Ei
    -.25123e-34Vikki      2e-77gooGols
    9!   9!!   9!!!   9!!!!   9!!!!!   9!!!!!!   9!!!!!!!   9!!!!!!!!   9!!!!!!!!!

where the last number for the factorials has nine factorial symbols   (!)   after the   9



Related tasks

   Multifactorial                 (which has a clearer and more succinct definition of multifactorials.)
   Factorial



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/big""
    ""strconv""
    ""strings""
)
 
type minmult struct {
    min  int
    mult float64
}
 
var abbrevs = map[string]minmult{
    ""PAIRs"": {4, 2}, ""SCOres"": {3, 20}, ""DOZens"": {3, 12},
    ""GRoss"": {2, 144}, ""GREATGRoss"": {7, 1728}, ""GOOGOLs"": {6, 1e100},
}
 
var metric = map[string]float64{
    ""K"": 1e3, ""M"": 1e6, ""G"": 1e9, ""T"": 1e12, ""P"": 1e15, ""E"": 1e18,
    ""Z"": 1e21, ""Y"": 1e24, ""X"": 1e27, ""W"": 1e30, ""V"": 1e33, ""U"": 1e36,
}
 
var binary = map[string]float64{
    ""Ki"": b(10), ""Mi"": b(20), ""Gi"": b(30), ""Ti"": b(40), ""Pi"": b(50), ""Ei"": b(60),
    ""Zi"": b(70), ""Yi"": b(80), ""Xi"": b(90), ""Wi"": b(100), ""Vi"": b(110), ""Ui"": b(120),
}
 
func b(e float64) float64 {
    return math.Pow(2, e)
}
 
func googol() *big.Float {
    g1 := new(big.Float).SetPrec(500)
    g1.SetInt64(10000000000)
    g := new(big.Float)
    g.Set(g1)
    for i := 2; i <= 10; i++ {
        g.Mul(g, g1)
    }
    return g
}
 
func fact(num string, d int) int {
    prod := 1
    n, _ := strconv.Atoi(num)
    for i := n; i > 0; i -= d {
        prod *= i
    }
    return prod
}
 
func parse(number string) *big.Float {
    bf := new(big.Float).SetPrec(500)
    t1 := new(big.Float).SetPrec(500)
    t2 := new(big.Float).SetPrec(500)
    // find index of last digit
    var i int
    for i = len(number) - 1; i >= 0; i-- {
        if '0' <= number[i] && number[i] <= '9' {
            break
        }
    }
    num := number[:i+1]
    num = strings.Replace(num, "","", """", -1) // get rid of any commas
    suf := strings.ToUpper(number[i+1:])
    if suf == """" {
        bf.SetString(num)
        return bf
    }
    if suf[0] == '!' {
        prod := fact(num, len(suf))
        bf.SetInt64(int64(prod))
        return bf
    }
    for k, v := range abbrevs {
        kk := strings.ToUpper(k)
        if strings.HasPrefix(kk, suf) && len(suf) >= v.min {
            t1.SetString(num)
            if k != ""GOOGOLs"" {
                t2.SetFloat64(v.mult)
            } else {
                t2 = googol() // for greater accuracy
            }
            bf.Mul(t1, t2)
            return bf
        }
    }
    bf.SetString(num)
    for k, v := range metric {
        for j := 0; j < len(suf); j++ {
            if k == suf[j:j+1] {
                if j < len(suf)-1 && suf[j+1] == 'I' {
                    t1.SetFloat64(binary[k+""i""])
                    bf.Mul(bf, t1)
                    j++
                } else {
                    t1.SetFloat64(v)
                    bf.Mul(bf, t1)
                }
            }
        }
    }
    return bf
}
 
func commatize(s string) string {
    if len(s) == 0 {
        return """"
    }
    neg := s[0] == '-'
    if neg {
        s = s[1:]
    }
    frac := """"
    if ix := strings.Index(s, "".""); ix >= 0 {
        frac = s[ix:]
        s = s[:ix]
    }
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    if !neg {
        return s + frac
    }
    return ""-"" + s + frac
}
 
func process(numbers []string) {
    fmt.Print(""numbers =  "")
    for _, number := range numbers {
        fmt.Printf(""%s  "", number)
    }
    fmt.Print(""\nresults =  "")
    for _, number := range numbers {
        res := parse(number)
        t := res.Text('g', 50)
        fmt.Printf(""%s  "", commatize(t))
    }
    fmt.Println(""\n"")
}
 
func main() {
    numbers := []string{""2greatGRo"", ""24Gros"", ""288Doz"", ""1,728pairs"", ""172.8SCOre""}
    process(numbers)
 
    numbers = []string{""1,567"", ""+1.567k"", ""0.1567e-2m""}
    process(numbers)
 
    numbers = []string{""25.123kK"", ""25.123m"", ""2.5123e-00002G""}
    process(numbers)
 
    numbers = []string{""25.123kiKI"", ""25.123Mi"", ""2.5123e-00002Gi"", ""+.25123E-7Ei""}
    process(numbers)
 
    numbers = []string{""-.25123e-34Vikki"", ""2e-77gooGols""}
    process(numbers)
 
    numbers = []string{""9!"", ""9!!"", ""9!!!"", ""9!!!!"", ""9!!!!!"", ""9!!!!!!"",
        ""9!!!!!!!"", ""9!!!!!!!!"", ""9!!!!!!!!!""}
    process(numbers)
}",3968,165
30809,http://rosettacode.org/wiki/OpenGL,OpenGL,"

Task

Display a smooth shaded triangle with OpenGL.

 Triangle created using C example compiled with GCC 4.1.2 and freeglut3.

",#Go,Go,"package main
 
import (
    gl ""github.com/chsc/gogl/gl21""
    ""github.com/go-gl/glfw/v3.2/glfw""
    ""log""
    ""runtime""
)
 
// Window dimensions.
const (
    Width  = 640
    Height = 480
)
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func main() {
    // OpenGL requires a dedicated OS thread.
    runtime.LockOSThread()
    defer runtime.UnlockOSThread()
 
    err := glfw.Init()
    check(err)
    defer glfw.Terminate()
 
    // Open window with the specified dimensions.
    window, err := glfw.CreateWindow(Width, Height, ""Triangle"", nil, nil)
    check(err)
 
    window.MakeContextCurrent()
 
    err = gl.Init()
    check(err) /* may need to comment out this line for this program to work on Windows 10 */
 
    // Initiate viewport.
    resize(Width, Height)
 
    // Register that we are interested in receiving close and resize events.
    window.SetCloseCallback(func(w *glfw.Window) {
        return
    })
    window.SetSizeCallback(func(w *glfw.Window, width, height int) {
        resize(width, height)
    })
 
    for !window.ShouldClose() {
        draw()
        window.SwapBuffers()
        glfw.PollEvents()
    }
}
 
// resize resizes the window to the specified dimensions.
func resize(width, height int) {
    gl.Viewport(0, 0, gl.Sizei(width), gl.Sizei(height))
    gl.MatrixMode(gl.PROJECTION)
    gl.LoadIdentity()
    gl.Ortho(-30.0, 30.0, -30.0, 30.0, -30.0, 30.0)
    gl.MatrixMode(gl.MODELVIEW)
}
 
// draw draws the triangle.
func draw() {
    gl.ClearColor(0.3, 0.3, 0.3, 0.0)
    gl.Clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
 
    gl.ShadeModel(gl.SMOOTH)
 
    gl.LoadIdentity()
    gl.Translatef(-15.0, -15.0, 0.0)
 
    gl.Begin(gl.TRIANGLES)
 
    gl.Color3f(1.0, 0.0, 0.0)
    gl.Vertex2f(0.0, 0.0)
 
    gl.Color3f(0.0, 1.0, 0.0)
    gl.Vertex2f(30.0, 0.0)
 
    gl.Color3f(0.0, 0.0, 1.0)
    gl.Vertex2f(0.0, 30.0)
 
    gl.End()
 
    gl.Flush()
}",1933,91
30838,http://rosettacode.org/wiki/Order_two_numerical_lists,Order two numerical lists,"sorting

Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Write a function that orders two lists or arrays filled with numbers.
The function should accept two lists as arguments and return true if the first list should be ordered before the second, and false otherwise.

The order is determined by lexicographic order: Comparing the first element of each list.
If the first elements are equal, then the second elements should be compared, and so on, until one of the list has no more elements.
If the first list runs out of elements the result is true.
If the second list or both run out of elements the result is false.

Note: further clarification of lexicographical ordering is expounded on the talk page here and here.
",#Go,Go,"package main
 
import ""fmt""
 
// If your numbers happen to be in the range of Unicode code points (0 to 0x10ffff), this function
// satisfies the task:
func lessRune(a, b []rune) bool {
    return string(a) < string(b) // see also bytes.Compare
}
 
// Otherwise, the following function satisfies the task for all integer
// and floating point types, by changing the type definition appropriately.
type numericType int
 
func lessNT(a, b []numericType) bool {
    l := len(a)
    if len(b) < l {
        l = len(b)
    }
    for i := 0; i < l; i++ {
        if a[i] != b[i] {
            return a[i] < b[i]
        }
    }
    return l < len(b)
}
 
var testCases = [][][]numericType{
    {{0}, {}},
    {{}, {}},
    {{}, {0}},
 
    {{-1}, {0}},
    {{0}, {0}},
    {{0}, {-1}},
 
    {{0}, {0, -1}},
    {{0}, {0, 0}},
    {{0}, {0, 1}},
    {{0, -1}, {0}},
    {{0, 0}, {0}},
    {{0, 0}, {1}},
}
 
func main() {
    // demonstrate the general function
    for _, tc := range testCases {
        fmt.Printf(""order %6s before %6s : %t\n"",
            fmt.Sprintf(""%v"", tc[0]),
            fmt.Sprintf(""%v"", tc[1]),
            lessNT(tc[0], tc[1]))
    }
    fmt.Println()
 
    // demonstrate that the byte specific function gives identical results
    // by offsetting test data to a printable range of characters.
    for _, tc := range testCases {
        a := toByte(tc[0])
        b := toByte(tc[1])
        fmt.Printf(""order %6q before %6q : %t\n"",
            string(a),
            string(b),
            lessByte(a, b))
    }
}
 
func toByte(a []numericType) []byte {
    b := make([]byte, len(a))
    for i, n := range a {
        b[i] = 'b' + byte(n)
    }
    return b
}",1684,73
30843,http://rosettacode.org/wiki/Ordered_words,Ordered words,"An   ordered word   is a word in which the letters appear in alphabetic order.

Examples include   abbey   and   dirt.

Task[edit]
Find and display all the ordered words in the dictionary   unixdict.txt   that have the longest word length.

(Examples that access the dictionary file locally assume that you have downloaded this file yourself.)

The display needs to be shown on this page.

Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""bytes""
    ""fmt""
    ""io/ioutil""
)
 
func main() {
    // read into memory in one chunk
    b, err := ioutil.ReadFile(""unixdict.txt"")
    if err != nil {
        fmt.Println(err)
        return
    }
    // split at line ends
    bss := bytes.Split(b, []byte{'\n'})
 
    // accumulate result
    var longest int
    var list [][]byte
    for _, bs := range bss {
        // don't bother with words shorter than
        // our current longest ordered word
        if len(bs) < longest {
            continue
        }
        // check for ordered property
        var lastLetter byte
        for i := 0; ; i++ {
            if i == len(bs) {
                // end of word.  it's an ordered word.
                // save it and break from loop
                if len(bs) > longest {
                    longest = len(bs)
                    list = list[:0]
                }
                list = append(list, bs)
                break
            }
            // check next letter
            b := bs[i]
            if b < 'a' || b > 'z' {
                continue // not a letter.  ignore.
            }
            if b < lastLetter {
                break // word not ordered.
            }
            // letter passes test
            lastLetter = b
        }
    }
    // print result
    for _, bs := range list {
        fmt.Println(string(bs))
    }
}",1392,57
30846,http://rosettacode.org/wiki/Numbers_which_are_not_the_sum_of_distinct_squares,Numbers which are not the sum of distinct squares,"

Integer squares are the set of integers multiplied by themselves: 1 x 1 = 1, 2 × 2 = 4, 3 × 3 = 9, etc. ( 1, 4, 9, 16 ... )

Most positive integers can be generated as the sum of 1 or more distinct integer squares.

     1 == 1
     5 == 4 + 1
    25 == 16 + 9
    77 == 36 + 25 + 16
   103 == 49 + 25 + 16 + 9 + 4

Many can be generated in multiple ways:

    90 == 36 + 25 + 16 + 9 + 4 == 64 + 16 + 9 + 1 == 49 + 25 + 16 == 64 + 25 + 1 == 81 + 9
   130 == 64 + 36 + 16 + 9 + 4 + 1 == 49 + 36 + 25 + 16 + 4 == 100 + 16 + 9 + 4 + 1 == 81 + 36 + 9 + 4 == 64 + 49 + 16 + 1 == 100 + 25 + 4 + 1 == 81 + 49 == 121 + 9    

The number of positive integers that cannot be generated by any combination of distinct squares is in fact finite:

   2, 3, 6, 7, etc.



Task
Find and show here, on this page, every positive integer than cannot be generated as the sum of distinct squares.

Do not use magic numbers or pre-determined limits. Justify your answer mathematically.



See also
 OEIS: A001422 Numbers which are not the sum of distinct squares

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""rcu""
)
 
func contains(a []int, n int) bool {
    for _, e := range a {
        if e == n {
            return true
        }
    }
    return false
}
 
// recursively permutates the list of squares to seek a matching sum
func soms(n int, f []int) bool {
    if n <= 0 {
        return false
    }
    if contains(f, n) {
        return true
    }
    sum := rcu.SumInts(f)
    if n > sum {
        return false
    }
    if n == sum {
        return true
    }
    rf := make([]int, len(f))
    copy(rf, f)
    for i, j := 0, len(rf)-1; i < j; i, j = i+1, j-1 {
        rf[i], rf[j] = rf[j], rf[i]
    }
    rf = rf[1:]
    return soms(n-f[len(f)-1], rf) || soms(n, rf)
}
 
func main() {
    var s, a []int
    sf := ""\nStopped checking after finding %d sequential non-gaps after the final gap of %d\n""
    i, g := 1, 1
    for g >= (i >> 1) {
        r := int(math.Sqrt(float64(i)))
        if r*r == i {
            s = append(s, i)
        }
        if !soms(i, s) {
            g = i
            a = append(a, g)
        }
        i++
    }
    fmt.Println(""Numbers which are not the sum of distinct squares:"")
    fmt.Println(a)
    fmt.Printf(sf, i-g, g)
    fmt.Printf(""Found %d in total\n"", len(a))
}
 
var r int",1271,63
30888,http://rosettacode.org/wiki/Old_Russian_measure_of_length,Old Russian measure of length,"Task

Write a program to perform a conversion of the old Russian measures of length to the metric system   (and vice versa).



It is an example of a linear transformation of several variables.



The program should accept a single value in a selected unit of measurement, and convert and return it to the other units:

vershoks, arshins, sazhens, versts, meters, centimeters and kilometers.



Also see

   Old Russian measure of length

",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""os""
    ""strconv""
    ""strings""
)
 
func main() {
    units := []string{
        ""tochka"", ""liniya"", ""dyuim"", ""vershok"", ""piad"", ""fut"",
        ""arshin"", ""sazhen"", ""versta"", ""milia"",
        ""centimeter"", ""meter"", ""kilometer"",
    }
 
    convs := []float32{
        0.0254, 0.254, 2.54, 4.445, 17.78, 30.48,
        71.12, 213.36, 10668, 74676,
        1, 100, 10000,
    }
 
    scanner := bufio.NewScanner(os.Stdin)
    for {
        for i, u := range units {
            fmt.Printf(""%2d %s\n"", i+1, u)
        }
        fmt.Println()
        var unit int
        var err error
        for {
            fmt.Print(""Please choose a unit 1 to 13 : "")
            scanner.Scan()
            unit, err = strconv.Atoi(scanner.Text())
            if err == nil && unit >= 1 && unit <= 13 {
                break
            }
        }
        unit--
        var value float64
        for {
            fmt.Print(""Now enter a value in that unit : "")
            scanner.Scan()
            value, err = strconv.ParseFloat(scanner.Text(), 32)
            if err == nil && value >= 0 {
                break
            }
        }
        fmt.Println(""\nThe equivalent in the remaining units is:\n"")
        for i, u := range units {
            if i == unit {
                continue
            }
            fmt.Printf("" %10s : %g\n"", u, float32(value)*convs[unit]/convs[i])
        }
        fmt.Println()
        yn := """"
        for yn != ""y"" && yn != ""n"" {
            fmt.Print(""Do another one y/n : "")
            scanner.Scan()
            yn = strings.ToLower(scanner.Text())
        }
        if yn == ""n"" {
            return
        }
    }
}",1703,68
30913,http://rosettacode.org/wiki/Object_serialization,Object serialization,"Create a set of data types based upon inheritance. Each data type or class should have a print command that displays the contents of an instance of that class to standard output. Create instances of each class in your inheritance hierarchy and display them to standard output. Write each of the objects to a file named objects.dat in binary form using serialization or marshalling. Read the file objects.dat and print the contents of each serialized object.
",#Go,Go,"package main
 
import (
    ""encoding/gob""
    ""fmt""
    ""os""
)
 
type printable interface {
    print()
}
 
func main() {
    // create instances
    animals := []printable{
        &Animal{Alive: true},
        &Cat{},
        &Lab{
            Dog:   Dog{Animal: Animal{Alive: true}},
            Color: ""yellow"",
        },
        &Collie{Dog: Dog{
            Animal:           Animal{Alive: true},
            ObedienceTrained: true,
        }},
    }
 
    // display
    fmt.Println(""created:"")
    for _, a := range animals {
        a.print()
    }
 
    // serialize
    f, err := os.Create(""objects.dat"")
    if err != nil {
        fmt.Println(err)
        return
    }
    for _, a := range animals {
        gob.Register(a)
    }
    err = gob.NewEncoder(f).Encode(animals)
    if err != nil {
        fmt.Println(err)
        return
    }
    f.Close()
 
    // read
    f, err = os.Open(""objects.dat"")
    if err != nil {
        fmt.Println(err)
        return
    }
    var clones []printable
    gob.NewDecoder(f).Decode(&clones)
    if err != nil {
        fmt.Println(err)
        return
    }
 
    // display
    fmt.Println(""\nloaded from objects.dat:"")
    for _, c := range clones {
        c.print()
    }
}
 
type Animal struct {
    Alive bool
}
 
func (a *Animal) print() {
    if a.Alive {
        fmt.Println(""   live animal, unspecified type"")
    } else {
        fmt.Println(""   dead animal, unspecified type"")
    }
}
 
type Dog struct {
    Animal
    ObedienceTrained bool
}
 
func (d *Dog) print() {
    switch {
    case !d.Alive:
        fmt.Println(""   dead dog"")
    case d.ObedienceTrained:
        fmt.Println(""   trained dog"")
    default:
        fmt.Println(""   dog, not trained"")
    }
}
 
type Cat struct {
    Animal
    LitterBoxTrained bool
}
 
func (c *Cat) print() {
    switch {
    case !c.Alive:
        fmt.Println(""   dead cat"")
    case c.LitterBoxTrained:
        fmt.Println(""   litter box trained cat"")
    default:
        fmt.Println(""   cat, not litter box trained"")
    }
}
 
type Lab struct {
    Dog 
    Color string
}   
 
func (l *Lab) print() {
    var r string
    if l.Color == """" {
        r = ""lab, color unspecified""
    } else {
        r = l.Color + "" lab""
    }
    switch {
    case !l.Alive:
        fmt.Println(""   dead"", r)
    case l.ObedienceTrained:
        fmt.Println(""   trained"", r)
    default:
        fmt.Printf(""   %s, not trained\n"", r)
    }
}   
 
type Collie struct {
    Dog 
    CatchesFrisbee bool
}   
 
func (c *Collie) print() {
    switch {
    case !c.Alive:
        fmt.Println(""   dead collie"")
    case c.ObedienceTrained && c.CatchesFrisbee:
        fmt.Println(""   trained collie, catches frisbee"")
    case c.ObedienceTrained && !c.CatchesFrisbee:
        fmt.Println(""   trained collie, but doesn't catch frisbee"")
    case !c.ObedienceTrained && c.CatchesFrisbee:
        fmt.Println(""   collie, not trained, but catches frisbee"")
    case !c.ObedienceTrained && !c.CatchesFrisbee:
        fmt.Println(""   collie, not trained, doesn't catch frisbee"")
    }
}",3077,154
31026,http://rosettacode.org/wiki/Numerical_integration/Gauss-Legendre_Quadrature,Numerical integration/Gauss-Legendre Quadrature,"

In a general Gaussian quadrature rule, an definite integral of 



f
(
x
)


{\displaystyle f(x)}

 is first approximated over the interval 



[
−
1
,
1
]


{\displaystyle [-1,1]}

 by a polynomial approximable function 



g
(
x
)


{\displaystyle g(x)}

 and a known weighting function 



W
(
x
)


{\displaystyle W(x)}

.






∫

−
1


1


f
(
x
)

d
x
=

∫

−
1


1


W
(
x
)
g
(
x
)

d
x


{\displaystyle \int _{-1}^{1}f(x)\,dx=\int _{-1}^{1}W(x)g(x)\,dx}




Those are then approximated by a sum of function values at specified points 




x

i




{\displaystyle x_{i}}

 multiplied by some weights 




w

i




{\displaystyle w_{i}}

:






∫

−
1


1


W
(
x
)
g
(
x
)

d
x
≈

∑

i
=
1


n



w

i


g
(

x

i


)


{\displaystyle \int _{-1}^{1}W(x)g(x)\,dx\approx \sum _{i=1}^{n}w_{i}g(x_{i})}




In the case of Gauss-Legendre quadrature, the weighting function 



W
(
x
)
=
1


{\displaystyle W(x)=1}

, so we can approximate an integral of 



f
(
x
)


{\displaystyle f(x)}

 with:






∫

−
1


1


f
(
x
)

d
x
≈

∑

i
=
1


n



w

i


f
(

x

i


)


{\displaystyle \int _{-1}^{1}f(x)\,dx\approx \sum _{i=1}^{n}w_{i}f(x_{i})}





For this, we first need to calculate the nodes and the weights, but after we have them, we can reuse them for numerious integral evaluations, which greatly speeds up the calculation compared to more simple numerical integration methods.



The 



n


{\displaystyle n}

 evaluation points 




x

i




{\displaystyle x_{i}}

 for a n-point rule, also called ""nodes"", are roots of n-th order Legendre Polynomials 




P

n


(
x
)


{\displaystyle P_{n}(x)}

. Legendre polynomials are defined by the following recursive rule:






P

0


(
x
)
=
1


{\displaystyle P_{0}(x)=1}







P

1


(
x
)
=
x


{\displaystyle P_{1}(x)=x}






n

P

n


(
x
)
=
(
2
n
−
1
)
x

P

n
−
1


(
x
)
−
(
n
−
1
)

P

n
−
2


(
x
)


{\displaystyle nP_{n}(x)=(2n-1)xP_{n-1}(x)-(n-1)P_{n-2}(x)}





There is also a recursive equation for their derivative:






P

n

′

(
x
)
=


n


x

2


−
1




(
x

P

n


(
x
)
−

P

n
−
1


(
x
)
)



{\displaystyle P_{n}'(x)={\frac {n}{x^{2}-1}}\left(xP_{n}(x)-P_{n-1}(x)\right)}




The roots of those polynomials are in general not analytically solvable, so they have to be approximated numerically, for example by Newton-Raphson iteration:






x

n
+
1


=

x

n


−



f
(

x

n


)



f
′

(

x

n


)





{\displaystyle x_{n+1}=x_{n}-{\frac {f(x_{n})}{f'(x_{n})}}}




The first guess 




x

0




{\displaystyle x_{0}}

 for the 



i


{\displaystyle i}

-th root of a 



n


{\displaystyle n}

-order polynomial 




P

n




{\displaystyle P_{n}}

 can be given by






x

0


=
cos
⁡

(
π




i
−


1
4




n
+


1
2





)



{\displaystyle x_{0}=\cos \left(\pi \,{\frac {i-{\frac {1}{4}}}{n+{\frac {1}{2}}}}\right)}




After we get the nodes 




x

i




{\displaystyle x_{i}}

, we compute the appropriate weights by:






w

i


=


2


(
1
−

x

i


2


)

[

P

n

′

(

x

i


)

]

2







{\displaystyle w_{i}={\frac {2}{\left(1-x_{i}^{2}\right)[P'_{n}(x_{i})]^{2}}}}




After we have the nodes and the weights for a n-point quadrature rule, we can approximate an integral over any interval 



[
a
,
b
]


{\displaystyle [a,b]}

 by






∫

a


b


f
(
x
)

d
x
≈



b
−
a

2



∑

i
=
1


n



w

i


f

(



b
−
a

2



x

i


+



a
+
b

2


)



{\displaystyle \int _{a}^{b}f(x)\,dx\approx {\frac {b-a}{2}}\sum _{i=1}^{n}w_{i}f\left({\frac {b-a}{2}}x_{i}+{\frac {a+b}{2}}\right)}




Task description

Similar to the task Numerical Integration, the task here is to calculate the definite integral of a function 



f
(
x
)


{\displaystyle f(x)}

, but by applying an n-point Gauss-Legendre quadrature rule, as described here, for example. The input values should be an function f to integrate, the bounds of the integration interval a and b, and the number of gaussian evaluation points n. An reference implementation in Common Lisp is provided for comparison.

To demonstrate the calculation, compute the weights and nodes for an 5-point quadrature rule and then use them to compute:

         
  
    
      
        
          ∫
          
            −
            3
          
          
            3
          
        
        exp
        ⁡
        (
        x
        )
        
        d
        x
        ≈
        
          ∑
          
            i
            =
            1
          
          
            5
          
        
        
          w
          
            i
          
        
        
        exp
        ⁡
        (
        
          x
          
            i
          
        
        )
        ≈
        20.036
      
    
    {\displaystyle \int _{-3}^{3}\exp(x)\,dx\approx \sum _{i=1}^{5}w_{i}\;\exp(x_{i})\approx 20.036}
  



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
// cFunc for continuous function.  A type definition for convenience.
type cFunc func(float64) float64
 
func main() {
    fmt.Println(""integral:"", glq(math.Exp, -3, 3, 5))
}
 
// glq integrates f from a to b by Guass-Legendre quadrature using n nodes.
// For the task, it also shows the intermediate values determining the nodes:
// the n roots of the order n Legendre polynomal and the corresponding n
// weights used for the integration.
func glq(f cFunc, a, b float64, n int) float64 {
    x, w := glqNodes(n, f)
    show := func(label string, vs []float64) {
        fmt.Printf(""%8s: "", label)
        for _, v := range vs {
            fmt.Printf(""%8.5f "", v)
        }
        fmt.Println()
    }
    show(""nodes"", x)
    show(""weights"", w)
    var sum float64
    bma2 := (b - a) * .5
    bpa2 := (b + a) * .5
    for i, xi := range x {
        sum += w[i] * f(bma2*xi+bpa2)
    }
    return bma2 * sum
}
 
// glqNodes computes both nodes and weights for a Gauss-Legendre
// Quadrature integration.  Parameters are n, the number of nodes
// to compute and f, a continuous function to integrate.  Return
// values have len n.
func glqNodes(n int, f cFunc) (node []float64, weight []float64) {
    p := legendrePoly(n)
    pn := p[n]
    n64 := float64(n)
    dn := func(x float64) float64 {
        return (x*pn(x) - p[n-1](x)) * n64 / (x*x - 1)
    }
    node = make([]float64, n)
    for i := range node {
        x0 := math.Cos(math.Pi * (float64(i+1) - .25) / (n64 + .5))
        node[i] = newtonRaphson(pn, dn, x0)
    }
    weight = make([]float64, n)
    for i, x := range node {
        dnx := dn(x)
        weight[i] = 2 / ((1 - x*x) * dnx * dnx)
    }
    return
}
 
// legendrePoly constructs functions that implement Lengendre polynomials.
// This is done by function composition by recurrence relation (Bonnet's.)
// For given n, n+1 functions are returned, computing P0 through Pn.
func legendrePoly(n int) []cFunc {
    r := make([]cFunc, n+1)
    r[0] = func(float64) float64 { return 1 }
    r[1] = func(x float64) float64 { return x }
    for i := 2; i <= n; i++ {
        i2m1 := float64(i*2 - 1)
        im1 := float64(i - 1)
        rm1 := r[i-1]
        rm2 := r[i-2]
        invi := 1 / float64(i)
        r[i] = func(x float64) float64 {
            return (i2m1*x*rm1(x) - im1*rm2(x)) * invi
        }
    }
    return r
}
 
// newtonRaphson is general purpose, although totally primitive, simply
// panicking after a fixed number of iterations without convergence to
// a fixed error.  Parameter f must be a continuous function,
// df its derivative, x0 an initial guess.
func newtonRaphson(f, df cFunc, x0 float64) float64 {
    for i := 0; i < 30; i++ {
        x1 := x0 - f(x0)/df(x0)
        if math.Abs(x1-x0) <= math.Abs(x0*1e-15) {
            return x1
        }
        x0 = x1
    }
    panic(""no convergence"")
}",2904,96
31057,http://rosettacode.org/wiki/One_of_n_lines_in_a_file,One of n lines in a file,"A method of choosing a line randomly from a file:

 Without reading the file more than once
 When substantial parts of the file cannot be held in memory
 Without knowing how many lines are in the file
Is to:

 keep the first line of the file as a possible choice, then
 Read the second line of the file if possible and make it the possible choice if a uniform random value between zero and one is less than 1/2.
 Read the third line of the file if possible and make it the possible choice if a uniform random value between zero and one is less than 1/3.
 ...
 Read the Nth line of the file if possible and make it the possible choice if a uniform random value between zero and one is less than 1/N
 Return the computed possible choice when no further lines exist in the file.


Task

 Create a function/method/routine called one_of_n that given n, the number of actual lines in a file, follows the algorithm above to return an integer - the line number of the line chosen from the file. 
The number returned can vary, randomly, in each run.
 Use one_of_n in a simulation to find what woud be the chosen line of a 10 line file simulated 1,000,000 times.
 Print and show how many times each of the 10 lines is chosen as a rough measure of how well the algorithm works.


Note: You may choose a smaller number of repetitions if necessary, but mention this up-front.

Note: This is a specific version of a Reservoir Sampling algorithm: https://en.wikipedia.org/wiki/Reservoir_sampling
",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""io""
    ""math/rand""
    ""time""
)
 
// choseLineRandomly implements the method described in the task.
// input is a an io.Reader, which could be an os.File, for example.
// Or, to implement a simulation, it could be anything else that implements
// io.Reader.  The method as described suggests saving and returning
// lines, but the rest of the task requires line numbers.  This function
// thus returns both.
func choseLineRandomly(r io.Reader) (s string, ln int, err error) {
    br := bufio.NewReader(r)
    s, err = br.ReadString('\n')
    if err != nil {
        return
    }
    ln = 1
    lnLast := 1.
    var sLast string
    for {
        // note bufio.ReadString used here.  This effectively defines a
        // line of the file as zero or more bytes followed by a newline.
        sLast, err = br.ReadString('\n')
        if err == io.EOF {
            return s, ln, nil // normal return
        }
        if err != nil {
            break
        }
        lnLast++
        if rand.Float64() < 1/lnLast {
            s = sLast
            ln = int(lnLast)
        }
    }
    return // error return
}
 
// oneOfN function required for task item 1.  Specified to take a number
// n, the number of lines in a file, but the method (above) specified to
// to be used does not need n, but rather the file itself.  This function
// thus takes both, ignoring n and passing the file to choseLineRandomly.
func oneOfN(n int, file io.Reader) int {
    _, ln, err := choseLineRandomly(file)
    if err != nil {
        panic(err)
    }
    return ln
}
 
// simulated file reader for task item 2
type simReader int
 
func (r *simReader) Read(b []byte) (int, error) {
    if *r <= 0 {
        return 0, io.EOF
    }
    b[0] = '\n'
    *r--
    return 1, nil
}
 
func main() {
    // task item 2 simulation consists of accumulating frequency statistic
    // on 1,000,000 calls of oneOfN on simulated file.
    n := 10
    freq := make([]int, n)
    rand.Seed(time.Now().UnixNano())
    for times := 0; times < 1e6; times++ {
        sr := simReader(n)
        freq[oneOfN(n, &sr)-1]++
    }
 
    // task item 3.  show frequencies.
    fmt.Println(freq)
}",2206,82
31062,http://rosettacode.org/wiki/Numeric_error_propagation,Numeric error propagation,"If   f,   a,   and   b   are values with uncertainties   σf,   σa,   and   σb,   and   c   is a constant;

then if   f   is derived from   a,   b,   and   c   in the following ways,

then   σf   can be calculated as follows:

Addition/Subtraction
 If   f = a ± c,   or   f = c ± a   then   σf = σa
 If   f = a ± b   then   σf2 = σa2 + σb2
Multiplication/Division
 If   f = ca   or   f = ac       then   σf = |cσa|
 If   f = ab   or   f = a / b   then   σf2 = f2( (σa / a)2 + (σb / b)2)
Exponentiation
 If   f = ac   then   σf = |fc(σa / a)|


Caution:

This implementation of error propagation does not address issues of dependent and independent values.   It is assumed that   a   and   b   are independent and so the formula for multiplication should not be applied to   a*a   for example.   See   the talk page   for some of the implications of this issue.


Task details

 Add an uncertain number type to your language that can support addition, subtraction, multiplication, division, and exponentiation between numbers with an associated error term together with 'normal' floating point numbers without an associated error term. 
Implement enough functionality to perform the following calculations.
 Given coordinates and their errors:
x1 = 100 ± 1.1
y1 = 50 ± 1.2
x2 = 200 ± 2.2
y2 = 100 ± 2.3
 if point p1 is located at (x1, y1) and p2 is at (x2, y2); calculate the distance between the two points using the classic Pythagorean formula: 
  d = √   (x1 - x2)²   +   (y1 - y2)²    
 Print and display both    d    and its error.


References

 A Guide to Error Propagation B. Keeney, 2005.
 Propagation of uncertainty Wikipedia.


Related task

   Quaternion type

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
// ""uncertain number type""
// a little optimization is to represent the error term with its square.
// this saves some taking of square roots in various places.
type unc struct {
    n float64 // the number
    s float64 // *square* of one sigma error term
}
 
// constructor, nice to have so it can handle squaring of error term
func newUnc(n, s float64) *unc {
    return &unc{n, s * s}
}
 
// error term accessor method, nice to have so it can handle recovering
// (non-squared) error term from internal (squared) representation
func (z *unc) errorTerm() float64 {
    return math.Sqrt(z.s)
}
 
// Arithmetic methods are modeled on the Go big number package.
// The basic scheme is to pass all operands as method arguments, compute
// the result into the method receiver, and then return the receiver as
// the result of the method.  This has an advantage of letting the programer
// determine allocation and use of temporary objects, reducing garbage;
// and has the convenience and efficiency of allowing operations to be chained.
 
// addition/subtraction
func (z *unc) addC(a *unc, c float64) *unc {
    *z = *a
    z.n += c
    return z
}
 
func (z *unc) subC(a *unc, c float64) *unc {
    *z = *a
    z.n -= c
    return z
}
 
func (z *unc) addU(a, b *unc) *unc {
    z.n = a.n + b.n
    z.s = a.s + b.s
    return z
}
func (z *unc) subU(a, b *unc) *unc {
    z.n = a.n - b.n
    z.s = a.s + b.s
    return z
}
 
// multiplication/division
func (z *unc) mulC(a *unc, c float64) *unc {
    z.n = a.n * c
    z.s = a.s * c * c
    return z
}
 
func (z *unc) divC(a *unc, c float64) *unc {
    z.n = a.n / c
    z.s = a.s / (c * c)
    return z
}
 
func (z *unc) mulU(a, b *unc) *unc {
    prod := a.n * b.n
    z.n, z.s = prod, prod*prod*(a.s/(a.n*a.n)+b.s/(b.n*b.n))
    return z
}
 
func (z *unc) divU(a, b *unc) *unc {
    quot := a.n / b.n
    z.n, z.s = quot, quot*quot*(a.s/(a.n*a.n)+b.s/(b.n*b.n))
    return z
}
 
// exponentiation
func (z *unc) expC(a *unc, c float64) *unc {
    f := math.Pow(a.n, c)
    g := f * c / a.n
    z.n = f
    z.s = a.s * g * g
    return z
}
 
func main() {
    x1 := newUnc(100, 1.1)
    x2 := newUnc(200, 2.2)
    y1 := newUnc(50, 1.2)
    y2 := newUnc(100, 2.3)
    var d, d2 unc
    d.expC(d.addU(d.expC(d.subU(x1, x2), 2), d2.expC(d2.subU(y1, y2), 2)), .5)
    fmt.Println(""d:    "", d.n)
    fmt.Println(""error:"", d.errorTerm())
}",2430,101
31071,http://rosettacode.org/wiki/Numbers_with_equal_rises_and_falls,Numbers with equal rises and falls,"When a number is written in base 10,   adjacent digits may ""rise"" or ""fall"" as the number is read   (usually from left to right).



Definition

Given the decimal digits of the number are written as a series   d:

   A   rise   is an index   i   such that    d(i)  <  d(i+1)
   A   fall    is an index   i   such that    d(i)  >  d(i+1)


Examples

   The number   726,169   has   3   rises and   2   falls,   so it isn't in the sequence.
   The number     83,548   has   2   rises and   2   falls,   so it   is   in the sequence.


Task

   Print the first   200   numbers in the sequence 
   Show that the   10 millionth   (10,000,000th)   number in the sequence is   41,909,002


See also

   OEIS Sequence  A296712   describes numbers whose digit sequence in base 10 have equal ""rises"" and ""falls"".


Related tasks

   Esthetic numbers

",#Go,Go,"package main
 
import ""fmt""
 
func risesEqualsFalls(n int) bool {
    if n < 10 {
        return true
    }
    rises := 0
    falls := 0
    prev := -1
    for n > 0 {
        d := n % 10
        if prev >= 0 {
            if d < prev {
                rises = rises + 1
            } else if d > prev {
                falls = falls + 1
            }
        }
        prev = d
        n /= 10   
    }
    return rises == falls
}
 
func main() {
    fmt.Println(""The first 200 numbers in the sequence are:"")
    count := 0
    n := 1
    for {
        if risesEqualsFalls(n) {
            count++
            if count <= 200 {
                fmt.Printf(""%3d "", n)
                if count%20 == 0 {
                    fmt.Println()
                }
            }
            if count == 1e7 {
                fmt.Println(""\nThe 10 millionth number in the sequence is "", n)
                break
            }
        }
        n++
    }
}",944,47
31088,http://rosettacode.org/wiki/Odd_word_problem,Odd word problem,"Task

Write a program that solves the odd word problem with the restrictions given below.



Description

You are promised an input stream consisting of English letters and punctuations.

It is guaranteed that:

 the words (sequence of consecutive letters) are delimited by one and only one punctuation,
 the stream will begin with a word,
 the words will be at least one letter long,   and 
 a full stop (a period, [.]) appears after, and only after, the last word.


Example

A stream with six words:

 what,is,the;meaning,of:life. 


The task is to reverse the letters in every other word while leaving punctuations intact, producing:

 what,si,the;gninaem,of:efil. 
while observing the following restrictions:

 Only I/O allowed is reading or writing one character at a time, which means: no reading in a string, no peeking ahead, no pushing characters back into the stream, and no storing characters in a global variable for later use;
 You are not to explicitly save characters in a collection data structure, such as arrays, strings, hash tables, etc, for later reversal;
 You are allowed to use recursions, closures, continuations, threads, co-routines, etc., even if their use implies the storage of multiple characters.


Test cases

Work on both the   ""life""   example given above, and also the text:

 we,are;not,in,kansas;any,more.

",#Go,Go,"package main
 
import (
    ""bytes""
    ""fmt""
    ""io""
    ""os""
    ""unicode""
)
 
func main() {
    owp(os.Stdout, bytes.NewBufferString(""what,is,the;meaning,of:life.""))
    fmt.Println()
    owp(os.Stdout, bytes.NewBufferString(""we,are;not,in,kansas;any,more.""))
    fmt.Println()
}
 
func owp(dst io.Writer, src io.Reader) {
    byte_in := func () byte {
        bs := make([]byte, 1)
        src.Read(bs)
        return bs[0]
    }
    byte_out := func (b byte) { dst.Write([]byte{b}) }    
    var odd func() byte
    odd = func() byte {
        s := byte_in()
        if unicode.IsPunct(rune(s)) {
            return s
        }
        b := odd()
        byte_out(s)
        return b
    }
    for {
        for {
            b := byte_in()
            byte_out(b)
            if b == '.' {
                return
            }
            if unicode.IsPunct(rune(b)) {
                break
            }
        }
        b := odd()
        byte_out(b)
        if b == '.' {
            return
        }
    }
}",1019,52
31257,http://rosettacode.org/wiki/Old_lady_swallowed_a_fly,Old lady swallowed a fly,"Task

Present a program which emits the lyrics to the song   I Knew an Old Lady Who Swallowed a Fly,   taking advantage of the repetitive structure of the song's lyrics. 

This song has multiple versions with slightly different lyrics, so all these programs might not emit identical output.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import ""fmt""
 
var name, lyric, animals = 0, 1, [][]string{
	{""fly"", ""I don't know why she swallowed a fly. Perhaps she'll die.""},
	{""spider"", ""That wiggled and jiggled and tickled inside her.""},
	{""bird"", ""How absurd, to swallow a bird.""},
	{""cat"", ""Imagine that, she swallowed a cat.""},
	{""dog"", ""What a hog, to swallow a dog.""},
	{""goat"", ""She just opened her throat and swallowed that goat.""},
	{""cow"", ""I don't know how she swallowed that cow.""},
	{""horse"", ""She's dead, of course.""},
}
 
func main() {
	for i, animal := range animals {
		fmt.Printf(""There was an old lady who swallowed a %s,\n"",
			animal[name])
 
		if i > 0 {
			fmt.Println(animal[lyric])
		}
 
		// Swallowing the last animal signals her death, cutting the
		//  lyrics short.
		if i+1 == len(animals) {
			break
		}
 
		for ; i > 0; i-- {
			fmt.Printf(""She swallowed the %s to catch the %s,\n"",
				animals[i][name], animals[i-1][name])
		}
 
		fmt.Println(animals[0][lyric] + ""\n"")
	}
}",980,38
31457,http://rosettacode.org/wiki/Numerical_integration,Numerical integration,"Write functions to calculate the definite integral of a function  ƒ(x)  using all five of the following methods:

 rectangular
 left
 right
 midpoint
 trapezium
 Simpson's
 composite
Your functions should take in the upper and lower bounds (a and b), and the number of approximations to make in that range (n).

Assume that your example already has a function that gives values for  ƒ(x) .

Simpson's method is defined by the following pseudo-code:


 Pseudocode: Simpson's method, composite



procedure quad_simpson_composite(f, a, b, n)
    h := (b - a) / n
    sum1 := f(a + h/2)
    sum2 := 0

    loop on i from 1 to (n - 1)
        sum1 := sum1 + f(a + h * i + h/2)
        sum2 := sum2 + f(a + h * i)
                                            
    answer := (h / 6) * (f(a) + f(b) + 4*sum1 + 2*sum2)




Demonstrate your function by showing the results for:

   ƒ(x) = x3,       where   x   is     [0,1],       with           100 approximations.   The exact result is     0.25               (or 1/4)
   ƒ(x) = 1/x,     where   x   is   [1,100],     with        1,000 approximations.   The exact result is     4.605170+     (natural log of 100)
   ƒ(x) = x,         where   x   is   [0,5000],   with 5,000,000 approximations.   The exact result is   12,500,000
   ƒ(x) = x,         where   x   is   [0,6000],   with 6,000,000 approximations.   The exact result is   18,000,000


See also

   Active object for integrating a function of real time.
   Special:PrefixIndex/Numerical integration for other integration methods.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
// specification for an integration
type spec struct {
    lower, upper float64               // bounds for integration
    n            int                   // number of parts
    exact        float64               // expected answer
    fs           string                // mathematical description of function
    f            func(float64) float64 // function to integrate
}
 
// test cases per task description
var data = []spec{
    spec{0, 1, 100, .25, ""x^3"", func(x float64) float64 { return x * x * x }},
    spec{1, 100, 1000, float64(math.Log(100)), ""1/x"",
        func(x float64) float64 { return 1 / x }},
    spec{0, 5000, 5e5, 12.5e6, ""x"", func(x float64) float64 { return x }},
    spec{0, 6000, 6e6, 18e6, ""x"", func(x float64) float64 { return x }},
}
 
// object for associating a printable function name with an integration method
type method struct {
    name      string
    integrate func(spec) float64
}
 
// integration methods implemented per task description
var methods = []method{
    method{""Rectangular (left)    "", rectLeft},
    method{""Rectangular (right)   "", rectRight},
    method{""Rectangular (midpoint)"", rectMid},
    method{""Trapezium             "", trap},
    method{""Simpson's             "", simpson},
}
 
func rectLeft(t spec) float64 {
    var a adder
    r := t.upper - t.lower
    nf := float64(t.n)
    x0 := t.lower
    for i := 0; i < t.n; i++ {
        x1 := t.lower + float64(i+1)*r/nf
        // x1-x0 better than r/nf.
        // (with r/nf, the represenation error accumulates)
        a.add(t.f(x0) * (x1 - x0))
        x0 = x1
    }
    return a.total()
}
 
func rectRight(t spec) float64 {
    var a adder
    r := t.upper - t.lower
    nf := float64(t.n)
    x0 := t.lower
    for i := 0; i < t.n; i++ {
        x1 := t.lower + float64(i+1)*r/nf
        a.add(t.f(x1) * (x1 - x0))
        x0 = x1
    }
    return a.total()
}
 
func rectMid(t spec) float64 {
    var a adder
    r := t.upper - t.lower
    nf := float64(t.n)
    // there's a tiny gloss in the x1-x0 trick here.  the correct way
    // would be to compute x's at division boundaries, but we don't need
    // those x's for anything else.  (the function is evaluated on x's
    // at division midpoints rather than division boundaries.)  so, we
    // reuse the midpoint x's, knowing that they will average out just
    // as well.  we just need one extra point, so we use lower-.5.
    x0 := t.lower - .5*r/nf
    for i := 0; i < t.n; i++ {
        x1 := t.lower + (float64(i)+.5)*r/nf
        a.add(t.f(x1) * (x1 - x0))
        x0 = x1
    }
    return a.total()
}
 
func trap(t spec) float64 {
    var a adder
    r := t.upper - t.lower
    nf := float64(t.n)
    x0 := t.lower
    f0 := t.f(x0)
    for i := 0; i < t.n; i++ {
        x1 := t.lower + float64(i+1)*r/nf
        f1 := t.f(x1)
        a.add((f0 + f1) * .5 * (x1 - x0))
        x0, f0 = x1, f1
    }
    return a.total()
}
 
func simpson(t spec) float64 {
    var a adder
    r := t.upper - t.lower
    nf := float64(t.n)
    // similar to the rectangle midpoint logic explained above,
    // we play a little loose with the values used for dx and dx0.
    dx0 := r / nf
    a.add(t.f(t.lower) * dx0)
    a.add(t.f(t.lower+dx0*.5) * dx0 * 4)
    x0 := t.lower + dx0
    for i := 1; i < t.n; i++ {
        x1 := t.lower + float64(i+1)*r/nf
        xmid := (x0 + x1) * .5
        dx := x1 - x0
        a.add(t.f(x0) * dx * 2)
        a.add(t.f(xmid) * dx * 4)
        x0 = x1
    }
    a.add(t.f(t.upper) * dx0)
    return a.total() / 6
}
 
func sum(v []float64) float64 {
    var a adder
    for _, e := range v {
        a.add(e)
    }
    return a.total()
}
 
type adder struct {
    sum, e float64
}
 
func (a *adder) total() float64 {
    return a.sum + a.e
}
 
func (a *adder) add(x float64) {
    sum := a.sum + x
    e := sum - a.sum
    a.e += a.sum - (sum - e) + (x - e)
    a.sum = sum
}
 
func main() {
    for _, t := range data {
        fmt.Println(""Test case: f(x) ="", t.fs)
        fmt.Println(""Integration from"", t.lower, ""to"", t.upper,
            ""in"", t.n, ""parts"")
        fmt.Printf(""Exact result            %.7e     Error\n"", t.exact)
        for _, m := range methods {
            a := m.integrate(t)
            e := a - t.exact
            if e < 0 {
                e = -e
            }
            fmt.Printf(""%s  %.7e  %.7e\n"", m.name, a, e)
        }
        fmt.Println("""")
    }
}",4452,164
31487,http://rosettacode.org/wiki/Null_object,Null object,"
Null (or nil) is the computer science concept of an undefined or unbound object.
Some languages have an explicit way to access the null object, and some don't.
Some languages distinguish the null object from undefined values, and some don't.



Task

Show how to access null in your language by checking to see if an object is equivalent to the null object.


This task is not about whether a variable is defined. The task is about ""null""-like values in various languages, which may or may not be related to the defined-ness of variables in your language.
",#Go,Go," 
package main
 
import ""fmt""
 
var (
    s []int       // slice type
    p *int        // pointer type
    f func()      // function type
    i interface{} // interface type
    m map[int]int // map type
    c chan int    // channel type
)
 
func main() {
    fmt.Println(s == nil)
    fmt.Println(p == nil)
    fmt.Println(f == nil)
    fmt.Println(i == nil)
    fmt.Println(m == nil)
    fmt.Println(c == nil)
}
 ",416,23
31519,http://rosettacode.org/wiki/One-dimensional_cellular_automata,One-dimensional cellular automata,"Assume an array of cells with an initial distribution of live and dead cells,
and imaginary cells off the end of the array having fixed values.

Cells in the next generation of the array are calculated based on the value of the cell and its left and right nearest neighbours in the current generation.

If, in the following table, a live cell is represented by 1 and a dead cell by 0 then to generate the value of the cell at a particular index in the array of cellular values you use the following table:

000 -> 0  # 
001 -> 0  #
010 -> 0  # Dies without enough neighbours
011 -> 1  # Needs one neighbour to survive
100 -> 0  #
101 -> 1  # Two neighbours giving birth
110 -> 1  # Needs one neighbour to survive
111 -> 0  # Starved to death.
",#Go,Go,"package main
 
import ""fmt""
 
const (
    start    = ""_###_##_#_#_#_#__#__""
    offLeft  = '_'
    offRight = '_'
    dead     = '_'
)
 
func main() {
    fmt.Println(start)
    g := newGenerator(start, offLeft, offRight, dead)
    for i := 0; i < 10; i++ {
        fmt.Println(g())
    }
}
 
func newGenerator(start string, offLeft, offRight, dead byte) func() string {
    g0 := string(offLeft) + start + string(offRight)
    g1 := []byte(g0)
    last := len(g0) - 1
    return func() string {
        for i := 1; i < last; i++ {
            switch l := g0[i-1]; {
            case l != g0[i+1]:
                g1[i] = g0[i]
            case g0[i] == dead:
                g1[i] = l
            default:
                g1[i] = dead
            }
        }
        g0 = string(g1)
        return g0[1:last]
    }
}",817,38
31623,http://rosettacode.org/wiki/Number_names,Number names,"Task

Show how to spell out a number in English.

You can use a preexisting implementation or roll your own, but you should support inputs up to at least one million (or the maximum value of your language's default bounded integer type, if that's less).

Support for inputs other than positive integers (like zero, negative integers, and floating-point numbers) is optional.



Related task

   Spelling of ordinal numbers.

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
	for _, n := range []int64{12, 1048576, 9e18, -2, 0} {
		fmt.Println(say(n))
	}
}
 
var small = [...]string{""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"",
	""seven"", ""eight"", ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"",
	""fourteen"", ""fifteen"", ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen""}
var tens = [...]string{"""", """", ""twenty"", ""thirty"", ""forty"",
	""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""}
var illions = [...]string{"""", "" thousand"", "" million"", "" billion"",
	"" trillion"", "" quadrillion"", "" quintillion""}
 
func say(n int64) string {
	var t string
	if n < 0 {
		t = ""negative ""
		// Note, for math.MinInt64 this leaves n negative.
		n = -n
	}
	switch {
	case n < 20:
		t += small[n]
	case n < 100:
		t += tens[n/10]
		s := n % 10
		if s > 0 {
			t += ""-"" + small[s]
		}
	case n < 1000:
		t += small[n/100] + "" hundred""
		s := n % 100
		if s > 0 {
			t += "" "" + say(s)
		}
	default:
		// work right-to-left
		sx := """"
		for i := 0; n > 0; i++ {
			p := n % 1000
			n /= 1000
			if p > 0 {
				ix := say(p) + illions[i]
				if sx != """" {
					ix += "" "" + sx
				}
				sx = ix
			}
		}
		t += sx
	}
	return t
}",1169,58
31635,http://rosettacode.org/wiki/Number_reversal_game,Number reversal game,"Task

Given a jumbled list of the numbers   1   to   9   that are definitely   not   in
ascending order.

Show the list,   and then ask the player how many digits from the
left to reverse.

Reverse those digits,   then ask again,   until all the digits end up in ascending order.



The score is the count of the reversals needed to attain the ascending order.



Note: Assume the player's input does not need extra validation.



Related tasks

   Sorting algorithms/Pancake sort
   Pancake sorting.
   Topswops

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""sort""
    ""time""
)
 
func main() {
    rand.Seed(time.Now().UnixNano())
    var k []int
    for {
        k = rand.Perm(9)
        for i, r := range k {
            if r == 0 {
                k[i] = 9
            }
        }
        if !sort.IntsAreSorted(k) {
            break
        }
    }
    fmt.Println(""Sort digits by reversing a number of digits on the left."")
    var n, score int
    for {
        fmt.Print(""Digits: "", k, "". How many to reverse? "")
        i, _ := fmt.Scanln(&n)
        score++
        if i == 0 || n < 2 || n > 9 {
            fmt.Println(""\n(Enter a number from 2 to 9)"")
            continue
        }
        for l, r := 0, n-1; l < r; l, r = l+1, r-1 {
            k[l], k[r] = k[r], k[l]
        }
        if sort.IntsAreSorted(k) {
            fmt.Print(""Digits: "", k, "".\n"")
            fmt.Print(""Your score: "", score, "".  Good job.\n"")
            return
        }
    }
}",969,43
31876,http://rosettacode.org/wiki/Nonoblock,Nonoblock,"Nonoblock is a chip off the old Nonogram puzzle.



Given

 The number of cells in a row.
 The size of each, (space separated), connected block of cells to fit in the row, in left-to right order.


Task
 
 show all possible positions. 
 show the number of positions of the blocks for the following cases within the row. 
 show all output on this page. 
 use a ""neat"" diagram of the block positions.


Enumerate the following configurations

   5   cells   and   [2, 1]   blocks
   5   cells   and   []   blocks   (no blocks)
   10   cells   and   [8]   blocks
   15   cells   and   [2, 3, 2, 3]   blocks
   5   cells   and   [2, 3]   blocks   (should give some indication of this not being possible)


Example

Given a row of five cells and a block of two cells followed by a block of one cell - in that order, the example could be shown as:

   |_|_|_|_|_| # 5 cells and [2, 1] blocks

And would expand to the following 3 possible rows of block positions:

   |A|A|_|B|_|
   |A|A|_|_|B|
   |_|A|A|_|B|



Note how the sets of blocks are always separated by a space.

Note also that it is not necessary for each block to have a separate letter.
Output approximating

This:

                       |#|#|_|#|_|
                       |#|#|_|_|#|
                       |_|#|#|_|#|

This would also work:

                       ##.#.
                       ##..#
                      .##.#



An algorithm

 Find the minimum space to the right that is needed to legally hold all but the leftmost block of cells (with a space between blocks remember).
 The leftmost cell can legitimately be placed in all positions from the LHS up to a RH position that allows enough room for the rest of the blocks.
 for each position of the LH block recursively compute the position of the rest of the blocks in the remaining space to the right of the current placement of the LH block.
(This is the algorithm used in the Nonoblock#Python solution).



Reference

 The blog post Nonogram puzzle solver (part 1) Inspired this task and donated its Nonoblock#Python solution.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func printBlock(data string, le int) {
    a := []byte(data)
    sumBytes := 0
    for _, b := range a {
        sumBytes += int(b - 48)
    }
    fmt.Printf(""\nblocks %c, cells %d\n"", a, le)
    if le-sumBytes <= 0 {
        fmt.Println(""No solution"")
        return
    }
    prep := make([]string, len(a))
    for i, b := range a {
        prep[i] = strings.Repeat(""1"", int(b-48))
    }
    for _, r := range genSequence(prep, le-sumBytes+1) {
        fmt.Println(r[1:])
    }
}
 
func genSequence(ones []string, numZeros int) []string {
    if len(ones) == 0 {
        return []string{strings.Repeat(""0"", numZeros)}
    }
    var result []string
    for x := 1; x < numZeros-len(ones)+2; x++ {
        skipOne := ones[1:]
        for _, tail := range genSequence(skipOne, numZeros-x) {
            result = append(result, strings.Repeat(""0"", x)+ones[0]+tail)
        }
    }
    return result
}
 
func main() {
    printBlock(""21"", 5)
    printBlock("""", 5)
    printBlock(""8"", 10)
    printBlock(""2323"", 15)
    printBlock(""23"", 5)
}",1089,48
31888,http://rosettacode.org/wiki/Non-transitive_dice,Non-transitive dice,"Let our dice select numbers on their faces with equal probability, i.e. fair dice.
Dice may have more or less than six faces. (The possibility of there being a
3D physical shape that has that many ""faces"" that allow them to be fair dice,
is ignored for this task - a die with 3 or 33 defined sides is defined by the
number of faces and the numbers on each face).

Throwing dice will randomly select a face on each die with equal probability.
To show which die of dice thrown multiple times is more likely to win over the
others:

 calculate all possible combinations of different faces from each die
 Count how many times each die wins a combination
 Each combination is equally likely so the die with more winning face combinations is statistically more likely to win against the other dice.


If two dice X and Y are thrown against each other then X likely to: win, lose, or break-even against Y can be shown as: X > Y, X < Y, or X = Y respectively.

Example 1

If X is the three sided die with 1, 3, 6 on its faces and Y has 2, 3, 4 on its
faces then the equal possibility outcomes from throwing both, and the winners
is:

   X   Y   Winner
   =   =   ======
   1   2   Y
   1   3   Y
   1   4   Y
   3   2   X
   3   3   -
   3   4   Y
   6   2   X
   6   3   X
   6   4   X
   
   TOTAL WINS: X=4, Y=4

Both die will have the same statistical probability of winning, i.e.their comparison can be written as X = Y

Transitivity

In mathematics transitivity are rules like:

   if a op b and b op c then a op c

If, for example, the op, (for operator), is the familiar less than, <, and it's applied to integers
we get the familiar if a < b and b < c then a < c

Non-transitive dice
These are an ordered list of dice where the '>' operation between successive
dice pairs applies but a comparison between the first and last of the list
yields the opposite result, '<'.

(Similarly '<' successive list comparisons with a final '>' between first and last is also non-transitive).

Three dice S, T, U with appropriate face values could satisfy

   S < T, T < U and yet S > U

To be non-transitive.

Notes

 The order of numbers on the faces of a die is not relevant. For example, three faced die described with face numbers of 1, 2, 3 or 2, 1, 3 or any other permutation are equivalent. For the purposes of the task show only the permutation in lowest-first sorted order i.e. 1, 2, 3 (and remove any of its perms).
 A die can have more than one instance of the same number on its faces, e.g. 2, 3, 3, 4
 Rotations: Any rotation of non-transitive dice from an answer is also an answer. You may optionally compute and show only one of each such rotation sets, ideally the first when sorted in a natural way. If this option is used then prominently state in the output that rotations of results are also solutions.


Task

====
Find all the ordered lists of three non-transitive dice S, T, U of the form
S < T, T < U and yet S > U; where the dice are selected from all four-faced die
, (unique w.r.t the notes), possible by having selections from the integers
one to four on any dies face.

Solution can be found by generating all possble individual die then testing all
possible permutations, (permutations are ordered), of three dice for
non-transitivity.

Optional stretch goal

Find lists of four non-transitive dice selected from the same possible dice from the non-stretch goal.




Show the results here, on this page.



References

 The Most Powerful Dice - Numberphile Video.
 Nontransitive dice - Wikipedia.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
func fourFaceCombs() (res [][4]int) {
    found := make([]bool, 256)
    for i := 1; i <= 4; i++ {
        for j := 1; j <= 4; j++ {
            for k := 1; k <= 4; k++ {
                for l := 1; l <= 4; l++ {
                    c := [4]int{i, j, k, l}
                    sort.Ints(c[:])
                    key := 64*(c[0]-1) + 16*(c[1]-1) + 4*(c[2]-1) + (c[3] - 1)
                    if !found[key] {
                        found[key] = true
                        res = append(res, c)
                    }
                }
            }
        }
    }
    return
}
 
func cmp(x, y [4]int) int {
    xw := 0
    yw := 0
    for i := 0; i < 4; i++ {
        for j := 0; j < 4; j++ {
            if x[i] > y[j] {
                xw++
            } else if y[j] > x[i] {
                yw++
            }
        }
    }
    if xw < yw {
        return -1
    } else if xw > yw {
        return 1
    }
    return 0
}
 
func findIntransitive3(cs [][4]int) (res [][3][4]int) {
    var c = len(cs)
    for i := 0; i < c; i++ {
        for j := 0; j < c; j++ {
            for k := 0; k < c; k++ {
                first := cmp(cs[i], cs[j])
                if first == -1 {
                    second := cmp(cs[j], cs[k])
                    if second == -1 {
                        third := cmp(cs[i], cs[k])
                        if third == 1 {
                            res = append(res, [3][4]int{cs[i], cs[j], cs[k]})
                        }
                    }
                }
            }
        }
    }
    return
}
 
func findIntransitive4(cs [][4]int) (res [][4][4]int) {
    c := len(cs)
    for i := 0; i < c; i++ {
        for j := 0; j < c; j++ {
            for k := 0; k < c; k++ {
                for l := 0; l < c; l++ {
                    first := cmp(cs[i], cs[j])
                    if first == -1 {
                        second := cmp(cs[j], cs[k])
                        if second == -1 {
                            third := cmp(cs[k], cs[l])
                            if third == -1 {
                                fourth := cmp(cs[i], cs[l])
                                if fourth == 1 {
                                    res = append(res, [4][4]int{cs[i], cs[j], cs[k], cs[l]})
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return
}
 
func main() {
    combs := fourFaceCombs()
    fmt.Println(""Number of eligible 4-faced dice"", len(combs))
    it3 := findIntransitive3(combs)
    fmt.Printf(""\n%d ordered lists of 3 non-transitive dice found, namely:\n"", len(it3))
    for _, a := range it3 {
        fmt.Println(a)
    }
    it4 := findIntransitive4(combs)
    fmt.Printf(""\n%d ordered lists of 4 non-transitive dice found, namely:\n"", len(it4))
    for _, a := range it4 {
        fmt.Println(a)
    }
}",2936,108
31978,http://rosettacode.org/wiki/Non-decimal_radices/Input,Non-decimal radices/Input,"It is common to have a string containing a number written in some format, with the most common ones being decimal, hexadecimal, octal and binary. Such strings are found in many places (user interfaces, configuration files, XML data, network protocols, etc.)

This task requires parsing of such a string (which may be assumed to contain nothing else) using the language's built-in facilities if possible. Parsing of decimal strings is required, parsing of other formats is optional but should be shown (i.e., if the language can parse in base-19 then that should be illustrated).

The solutions may assume that the base of the number in the string is known. In particular, if your language has a facility to guess the base of a number by looking at a prefix (e.g. ""0x"" for hexadecimal) or other distinguishing syntax as it parses it, please show that.

The reverse operation is in task Non-decimal radices/Output

For general number base conversion, see Non-decimal radices/Convert.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""strconv""
)
 
func main() {
    // package strconv:  the most common string to int conversion,
    // base 10 only.
    x, _ := strconv.Atoi(""13"")
    fmt.Println(x)
 
    // ParseInt handles arbitrary bases from 2 to 36, and returns
    // a result of the requested size (64 bits shown here.)
    // If the base argument is zero the base is determined by prefix
    // as with math/big below.
    x64, _ := strconv.ParseInt(""3c2"", 19, 64)
    fmt.Println(x64)
 
    // package fmt:  allows direct conversion from strings, standard
    // input, or from an io.Reader (file, buffer, etc) to integer types
    // for bases 2, 8, 10, and 16 or to any type that implements the
    // fmt.Scanner interface (e.g. a big.Int).
    // (Fscanf and Scanf are more common for reading from
    // an io.Reader or stdin than Sscanf for reading from strings.)
    fmt.Sscanf(""1101"", ""%b"", &x)
    fmt.Println(x)
 
    fmt.Sscanf(""15"", ""%o"", &x)
    fmt.Println(x)
 
    fmt.Sscanf(""13"", ""%d"", &x)
    fmt.Println(x)
 
    fmt.Sscanf(""d"", ""%x"", &x)
    fmt.Println(x)
 
    // package math/big:  allows conversion from string to big integer.
    // any base from 2 to 36 can be specified as second parameter.
    var z big.Int
    z.SetString(""111"", 3)
    fmt.Println(&z)
 
    // if second parameter is 0, base is determined by prefix, if any
    z.SetString(""0b1101"", 0) // 0b -> base 2
    fmt.Println(&z)
 
    z.SetString(""015"", 0) // 0 -> base 8
    fmt.Println(&z)
 
    z.SetString(""13"", 0) // no prefix -> base 10
    fmt.Println(&z)
 
    z.SetString(""0xd"", 0) // 0x -> base 16
    fmt.Println(&z)
 
    // As mentioned, a big.Int (or any type implementing fmt.Scanner)
    // can also be use with any of the fmt scanning functions.
    fmt.Sscanf(""15"", ""%o"", &z)
    fmt.Println(&z)
}",1834,63
32022,http://rosettacode.org/wiki/Nonogram_solver,Nonogram solver,"A nonogram is a puzzle that provides
numeric clues used to fill in a grid of cells,
establishing for each cell whether it is filled or not.
The puzzle solution is typically a picture of some kind.

Each row and column of a rectangular grid is annotated with the lengths
of its distinct runs of occupied cells.
Using only these lengths you should find one valid configuration
of empty and occupied cells, or show a failure message.

Example
Problem:                 Solution:

. . . . . . . .  3       . # # # . . . .  3
. . . . . . . .  2 1     # # . # . . . .  2 1
. . . . . . . .  3 2     . # # # . . # #  3 2
. . . . . . . .  2 2     . . # # . . # #  2 2
. . . . . . . .  6       . . # # # # # #  6
. . . . . . . .  1 5     # . # # # # # .  1 5
. . . . . . . .  6       # # # # # # . .  6
. . . . . . . .  1       . . . . # . . .  1
. . . . . . . .  2       . . . # # . . .  2
1 3 1 7 5 3 4 3          1 3 1 7 5 3 4 3
2 1 5 1                  2 1 5 1
The problem above could be represented by two lists of lists:

x = [[3], [2,1], [3,2], [2,2], [6], [1,5], [6], [1], [2]]
y = [[1,2], [3,1], [1,5], [7,1], [5], [3], [4], [3]]
A more compact representation of the same problem uses strings,
where the letters represent the numbers, A=1, B=2, etc:

x = ""C BA CB BB F AE F A B""
y = ""AB CA AE GA E C D C""
Task
For this task, try to solve the 4 problems below, read from a “nonogram_problems.txt” file that has this content
(the blank lines are separators):

C BA CB BB F AE F A B
AB CA AE GA E C D C

F CAC ACAC CN AAA AABB EBB EAA ECCC HCCC
D D AE CD AE A DA BBB CC AAB BAA AAB DA AAB AAA BAB AAA CD BBA DA

CA BDA ACC BD CCAC CBBAC BBBBB BAABAA ABAD AABB BBH BBBD ABBAAA CCEA AACAAB BCACC ACBH DCH ADBE ADBB DBE ECE DAA DB CC
BC CAC CBAB BDD CDBDE BEBDF ADCDFA DCCFB DBCFC ABDBA BBF AAF BADB DBF AAAAD BDG CEF CBDB BBB FC

E BCB BEA BH BEK AABAF ABAC BAA BFB OD JH BADCF Q Q R AN AAN EI H G
E CB BAB AAA AAA AC BB ACC ACCA AGB AIA AJ AJ ACE AH BAF CAG DAG FAH FJ GJ ADK ABK BL CM
Extra credit: generate nonograms with unique solutions, of desired height and width.



This task is the problem n.98 of the ""99 Prolog Problems"" by Werner Hett (also thanks to Paul Singleton for the idea and the examples).




 Related tasks
 Nonoblock.


See also
 Arc Consistency Algorithm
 http://www.haskell.org/haskellwiki/99_questions/Solutions/98 (Haskell)
 http://twanvl.nl/blog/haskell/Nonograms (Haskell)
 http://picolisp.com/5000/!wiki?99p98 (PicoLisp)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
type BitSet []bool
 
func (bs BitSet) and(other BitSet) {
    for i := range bs {
        if bs[i] && other[i] {
            bs[i] = true
        } else {
            bs[i] = false
        }
    }
}
 
func (bs BitSet) or(other BitSet) {
    for i := range bs {
        if bs[i] || other[i] {
            bs[i] = true
        } else {
            bs[i] = false
        }
    }
}
 
func iff(cond bool, s1, s2 string) string {
    if cond {
        return s1
    }
    return s2
}
 
func newPuzzle(data [2]string) {
    rowData := strings.Fields(data[0])
    colData := strings.Fields(data[1])
    rows := getCandidates(rowData, len(colData))
    cols := getCandidates(colData, len(rowData))
 
    for {
        numChanged := reduceMutual(cols, rows)
        if numChanged == -1 {
            fmt.Println(""No solution"")
            return
        }
        if numChanged == 0 {
            break
        }
    }
 
    for _, row := range rows {
        for i := 0; i < len(cols); i++ {
            fmt.Printf(iff(row[0][i], ""# "", "". ""))
        }
        fmt.Println()
    }
    fmt.Println()
}
 
// collect all possible solutions for the given clues
func getCandidates(data []string, le int) [][]BitSet {
    var result [][]BitSet
    for _, s := range data {
        var lst []BitSet
        a := []byte(s)
        sumBytes := 0
        for _, b := range a {
            sumBytes += int(b - 'A' + 1)
        }
        prep := make([]string, len(a))
        for i, b := range a {
            prep[i] = strings.Repeat(""1"", int(b-'A'+1))
        }
        for _, r := range genSequence(prep, le-sumBytes+1) {
            bits := []byte(r[1:])
            bitset := make(BitSet, len(bits))
            for i, b := range bits {
                bitset[i] = b == '1'
            }
            lst = append(lst, bitset)
        }
        result = append(result, lst)
    }
    return result
}
 
func genSequence(ones []string, numZeros int) []string {
    le := len(ones)
    if le == 0 {
        return []string{strings.Repeat(""0"", numZeros)}
    }
    var result []string
    for x := 1; x < numZeros-le+2; x++ {
        skipOne := ones[1:]
        for _, tail := range genSequence(skipOne, numZeros-x) {
            result = append(result, strings.Repeat(""0"", x)+ones[0]+tail)
        }
    }
    return result
}
 
/* If all the candidates for a row have a value in common for a certain cell,
   then it's the only possible outcome, and all the candidates from the
   corresponding column need to have that value for that cell too. The ones
   that don't, are removed. The same for all columns. It goes back and forth,
   until no more candidates can be removed or a list is empty (failure).
*/
 
func reduceMutual(cols, rows [][]BitSet) int {
    countRemoved1 := reduce(cols, rows)
    if countRemoved1 == -1 {
        return -1
    }
    countRemoved2 := reduce(rows, cols)
    if countRemoved2 == -1 {
        return -1
    }
    return countRemoved1 + countRemoved2
}
 
func reduce(a, b [][]BitSet) int {
    countRemoved := 0
    for i := 0; i < len(a); i++ {
        commonOn := make(BitSet, len(b))
        for j := 0; j < len(b); j++ {
            commonOn[j] = true
        }
        commonOff := make(BitSet, len(b))
 
        // determine which values all candidates of a[i] have in common
        for _, candidate := range a[i] {
            commonOn.and(candidate)
            commonOff.or(candidate)
        }
 
        // remove from b[j] all candidates that don't share the forced values
        for j := 0; j < len(b); j++ {
            fi, fj := i, j
            for k := len(b[j]) - 1; k >= 0; k-- {
                cnd := b[j][k]
                if (commonOn[fj] && !cnd[fi]) || (!commonOff[fj] && cnd[fi]) {
                    lb := len(b[j])
                    copy(b[j][k:], b[j][k+1:])
                    b[j][lb-1] = nil
                    b[j] = b[j][:lb-1]
                    countRemoved++
                }
            }
            if len(b[j]) == 0 {
                return -1
            }
        }
    }
    return countRemoved
}
 
func main() {
    p1 := [2]string{""C BA CB BB F AE F A B"", ""AB CA AE GA E C D C""}
 
    p2 := [2]string{
        ""F CAC ACAC CN AAA AABB EBB EAA ECCC HCCC"",
        ""D D AE CD AE A DA BBB CC AAB BAA AAB DA AAB AAA BAB AAA CD BBA DA"",
    }
 
    p3 := [2]string{
        ""CA BDA ACC BD CCAC CBBAC BBBBB BAABAA ABAD AABB BBH "" +
            ""BBBD ABBAAA CCEA AACAAB BCACC ACBH DCH ADBE ADBB DBE ECE DAA DB CC"",
        ""BC CAC CBAB BDD CDBDE BEBDF ADCDFA DCCFB DBCFC ABDBA BBF AAF BADB DBF "" +
            ""AAAAD BDG CEF CBDB BBB FC"",
    }
 
    p4 := [2]string{
        ""E BCB BEA BH BEK AABAF ABAC BAA BFB OD JH BADCF Q Q R AN AAN EI H G"",
        ""E CB BAB AAA AAA AC BB ACC ACCA AGB AIA AJ AJ "" +
            ""ACE AH BAF CAG DAG FAH FJ GJ ADK ABK BL CM"",
    }
 
    for _, puzzleData := range [][2]string{p1, p2, p3, p4} {
        newPuzzle(puzzleData)
    }
}",4983,184
32030,http://rosettacode.org/wiki/Non-decimal_radices/Output,Non-decimal radices/Output,"Programming languages often have built-in routines to convert a non-negative integer for printing in different number bases. Such common number bases might include binary, Octal and Hexadecimal.



Task

Print a small range of integers in some different bases, as supported by standard routines of your programming language.



Note

This is distinct from Number base conversion as a user-defined conversion function is not asked for.)

The reverse operation is Common number base parsing.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""strconv""
)
 
func main() {
    // fmt.Print formats integer types directly as bases 2, 8, 10, and 16.
    fmt.Printf(""%b\n"", 13)
    fmt.Printf(""%o\n"", 13)
    fmt.Printf(""%d\n"", 13)
    fmt.Printf(""%x\n"", 13)
    // big ints work with fmt as well.
    d := big.NewInt(13)
    fmt.Printf(""%b\n"", d)
    fmt.Printf(""%o\n"", d)
    fmt.Printf(""%d\n"", d)
    fmt.Printf(""%x\n"", d)
    // strconv.FormatInt handles arbitrary bases from 2 to 36 for the
    // int64 type.  There is also strconv.FormatUInt for the uint64 type.
    // There no equivalent for big ints.
    fmt.Println(strconv.FormatInt(1313, 19))
}",662,25
32039,http://rosettacode.org/wiki/Nested_templated_data,Nested templated data,"A template for data is an arbitrarily nested tree of integer indices.

Data payloads are given as a separate mapping, array or other simpler, flat,
association of indices to individual items of data, and are strings.

The idea is to create a data structure with the templates' nesting, and the
payload corresponding to each index appearing at the position of each index.

Answers using simple string replacement or regexp are to be avoided. The idea is
to use the native, or usual implementation of lists/tuples etc of the language
and to hierarchically traverse the template to generate the output.

Task Detail

Given the following input template t and list of payloads p:

# Square brackets are used here to denote nesting but may be changed for other,
# clear, visual representations of nested data appropriate to ones programming 
# language.
t = [
    [[1, 2],
     [3, 4, 1], 
     5]]
 
p = 'Payload#0' ... 'Payload#6'
The correct output should have the following structure, (although spacing and
linefeeds may differ, the nesting and order should follow):

[[['Payload#1', 'Payload#2'],
  ['Payload#3', 'Payload#4', 'Payload#1'],
  'Payload#5']]
1. Generate the output for the above template, t.


Optional Extended tasks

2. Show which payloads remain unused.

3. Give some indication/handling of indices without a payload.


Show output on this page.
",#Go,Go,{{index .P n}},14,1
32133,http://rosettacode.org/wiki/Next_highest_int_from_digits,Next highest int from digits,"Given a zero or positive integer, the task is to generate the next largest
integer using only the given digits*1.

   Numbers will not be padded to the left with zeroes.
   Use all given digits, with their given multiplicity. (If a digit appears twice in the input number, it should appear twice in the result).
   If there is no next highest integer return zero.


*1   Alternatively phrased as:   ""Find the smallest integer larger than the (positive or zero) integer   N
 which can be obtained by reordering the (base ten) digits of   N"".


Algorithm 1

   Generate all the permutations of the digits and sort into numeric order.
   Find the number in the list.
   Return the next highest number from the list.


The above could prove slow and memory hungry for numbers with large numbers of
digits, but should be easy to reason about its correctness.



Algorithm 2

   Scan right-to-left through the digits of the number until you find a digit with a larger digit somewhere to the right of it.
   Exchange that digit with the digit on the right that is both more than it, and closest to it.
   Order the digits to the right of this position, after the swap; lowest-to-highest, left-to-right. (I.e. so they form the lowest numerical representation)

E.g.:

    n = 12453
<scan>
    12_4_53
<swap>
    12_5_43
<order-right>
    12_5_34

    return: 12534

This second algorithm is faster and more memory efficient, but implementations
may be harder to test.

One method of testing, (as used in developing the task),   is to compare results from both
algorithms for random numbers generated from a range that the first algorithm can handle.



Task requirements

Calculate the next highest int from the digits of the following numbers:

   0
   9
   12
   21
   12453
   738440
   45072010
   95322020


Optional stretch goal

   9589776899767587796600

",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
func permute(s string) []string {
    var res []string
    if len(s) == 0 {
        return res
    }
    b := []byte(s)
    var rc func(int) // recursive closure
    rc = func(np int) {
        if np == 1 {
            res = append(res, string(b))
            return
        }
        np1 := np - 1
        pp := len(b) - np1
        rc(np1)
        for i := pp; i > 0; i-- {
            b[i], b[i-1] = b[i-1], b[i]
            rc(np1)
        }
        w := b[0]
        copy(b, b[1:pp+1])
        b[pp] = w
    }
    rc(len(b))
    return res
}
 
func algorithm1(nums []string) {
    fmt.Println(""Algorithm 1"")
    fmt.Println(""-----------"")
    for _, num := range nums {
        perms := permute(num)
        le := len(perms)
        if le == 0 { // ignore blanks
            continue
        }
        sort.Strings(perms)
        ix := sort.SearchStrings(perms, num)
        next := """"
        if ix < le-1 {
            for i := ix + 1; i < le; i++ {
                if perms[i] > num {
                    next = perms[i]
                    break
                }
            }
        }
        if len(next) > 0 {
            fmt.Printf(""%29s -> %s\n"", commatize(num), commatize(next))
        } else {
            fmt.Printf(""%29s -> 0\n"", commatize(num))
        }
    }
    fmt.Println()
}
 
func algorithm2(nums []string) {
    fmt.Println(""Algorithm 2"")
    fmt.Println(""-----------"")
outer:
    for _, num := range nums {
        b := []byte(num)
        le := len(b)
        if le == 0 { // ignore blanks
            continue
        }
        max := num[le-1]
        mi := le - 1
        for i := le - 2; i >= 0; i-- {
            if b[i] < max {
                min := max - b[i]
                for j := mi + 1; j < le; j++ {
                    min2 := b[j] - b[i]
                    if min2 > 0 && min2 < min {
                        min = min2
                        mi = j
                    }
                }
                b[i], b[mi] = b[mi], b[i]
                c := (b[i+1:])
                sort.Slice(c, func(i, j int) bool {
                    return c[i] < c[j]
                })
                next := string(b[0:i+1]) + string(c)
                fmt.Printf(""%29s -> %s\n"", commatize(num), commatize(next))
                continue outer
            } else if b[i] > max {
                max = num[i]
                mi = i
            }
        }
        fmt.Printf(""%29s -> 0\n"", commatize(num))
    }
}
 
func commatize(s string) string {
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    return s
}
 
func main() {
    nums := []string{""0"", ""9"", ""12"", ""21"", ""12453"", ""738440"", ""45072010"", ""95322020"", ""9589776899767587796600""}
    algorithm1(nums[:len(nums)-1]) // exclude the last one
    algorithm2(nums)               // include the last one
}",2894,115
32161,http://rosettacode.org/wiki/Non-continuous_subsequences,Non-continuous subsequences,"Consider some sequence of elements. (It differs from a mere set of elements by having an ordering among members.)

A subsequence contains some subset of the elements of this sequence, in the same order.

A continuous subsequence is one in which no elements are missing between the first and last elements of the subsequence.

Note: Subsequences are defined structurally, not by their contents.
So a sequence a,b,c,d will always have the same subsequences and continuous subsequences, no matter which values are substituted; it may even be the same value.


Task: Find all non-continuous subsequences for a given sequence.



Example

For the sequence   1,2,3,4,   there are five non-continuous subsequences, namely:

   1,3
   1,4
   2,4
   1,3,4
   1,2,4


Goal

There are different ways to calculate those subsequences.

Demonstrate algorithm(s) that are natural for the language.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import ""fmt""
 
const ( // state:
    m   = iota // missing:  all elements missing so far
    c          // continuous:  all elements included so far are continuous
    cm         // one or more continuous followed by one or more missing
    cmc        // non-continuous subsequence
)
 
func ncs(s []int) [][]int {
    if len(s) < 3 {
        return nil
    }
    return append(n2(nil, s[1:], m), n2([]int{s[0]}, s[1:], c)...)
}
 
var skip = []int{m, cm, cm, cmc}
var incl = []int{c, c, cmc, cmc}
 
func n2(ss, tail []int, seq int) [][]int {
    if len(tail) == 0 {
        if seq != cmc {
            return nil
        }
        return [][]int{ss}
    }
    return append(n2(append([]int{}, ss...), tail[1:], skip[seq]),
        n2(append(ss, tail[0]), tail[1:], incl[seq])...)
}
 
func main() {
    ss := ncs([]int{1, 2, 3, 4})
    fmt.Println(len(ss), ""non-continuous subsequences:"")
    for _, s := range ss {
        fmt.Println(""  "", s)
    }
}",965,39
32191,http://rosettacode.org/wiki/Nim_game,Nim game,"Nim game

You are encouraged to solve this task according to the task description, using any language you may know.
Nim is a simple game where the second player ─── if they know the trick ─── will always win.



The game has only 3 rules:

   start with   12   tokens
   each player takes   1,  2,  or  3   tokens in turn
  the player who takes the last token wins.


To win every time,   the second player simply takes 4 minus the number the first player took.   So if the first player takes 1,   the second takes 3 ─── if the first player takes 2,   the second should take 2 ─── and if the first player takes 3,   the second player will take 1.



Task

Design a simple Nim game where the human player goes first, and the computer always wins. The game should enforce the rules.



",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""os""
    ""strconv""
)
 
func showTokens(tokens int) {
    fmt.Println(""Tokens remaining"", tokens, ""\n"")    
}
 
func main() {
    tokens := 12
    scanner := bufio.NewScanner(os.Stdin)
    for {
        showTokens(tokens)
        fmt.Print(""  How many tokens 1, 2 or 3? "")
        scanner.Scan()
        if scerr := scanner.Err(); scerr != nil {
            fmt.Println(""Error reading standard input:"", scerr)
            return
        }
        t, err := strconv.Atoi(scanner.Text())
        if err != nil || t < 1 || t > 3 {
            fmt.Println(""\nMust be a number between 1 and 3, try again.\n"")
        } else {
            ct := 4 - t
            s := ""s""
            if ct == 1 {
                s = """"
            }
            fmt.Print(""  Computer takes "", ct, "" token"", s, ""\n\n"")
            tokens -= 4
        }
        if tokens == 0 {
            showTokens(0)
            fmt.Println(""  Computer wins!"")
            return
        }
    }
}",1010,43
32200,http://rosettacode.org/wiki/Nautical_bell,Nautical bell,"
Task
Write a small program that emulates a nautical bell producing a ringing bell pattern at certain times throughout the day.

The bell timing should be in accordance with Greenwich Mean Time, unless locale dictates otherwise.

It is permissible for the program to daemonize, or to slave off a scheduler, and it is permissible to use alternative notification methods (such as producing a written notice ""Two Bells Gone""), if these are more usual for the system type.



Related task

 Sleep

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
    ""time""
)
 
func main() {
    watches := []string{
        ""First"", ""Middle"", ""Morning"", ""Forenoon"",
        ""Afternoon"", ""Dog"", ""First"",
    }
    for {
        t := time.Now()
        h := t.Hour()
        m := t.Minute()
        s := t.Second()
        if (m == 0 || m == 30) && s == 0 {
            bell := 0
            if m == 30 {
                bell = 1
            }
            bells := (h*2 + bell) % 8
            watch := h/4 + 1
            if bells == 0 {
                bells = 8
                watch--
            }
            sound := strings.Repeat(""\a"", bells)
            pl := ""s""
            if bells == 1 {
                pl = "" ""
            }
            w := watches[watch] + "" watch""
            if watch == 5 {
                if bells < 5 {
                    w = ""First "" + w
                } else {
                    w = ""Last "" + w
                }
            }
            fmt.Printf(""%s%02d:%02d = %d bell%s : %s\n"", sound, h, m, bells, pl, w)
        }
        time.Sleep(1 * time.Second)
    }
}",1094,47
32247,http://rosettacode.org/wiki/Nested_function,Nested function,"In many languages, functions can be nested, resulting in outer functions and inner functions. The inner function can access variables from the outer function. In most languages, the inner function can also modify variables in the outer function.



Task
 
Write a program consisting of two nested functions that prints the following text.

1. first
2. second
3. third

The outer function (called MakeList or equivalent) is responsible for creating the list as a whole and is given the separator "". "" as argument. It also defines a counter variable to keep track of the item number. This demonstrates how the inner function can influence the variables in the outer function.

The inner function (called MakeItem or equivalent) is responsible for creating a list item. It accesses the separator from the outer function and modifies the counter.



References

 Nested function

",#Go,Go,"package main
import ""fmt""
 
func makeList(separator string) string {
    counter := 1
 
    makeItem := func(item string) string {
        result := fmt.Sprintf(""%d%s%s\n"", counter, separator, item)
        counter += 1
        return result
    }
 
    return makeItem(""first"") + makeItem(""second"") + makeItem(""third"")
}
 
func main() {
    fmt.Print(makeList("". ""))
}",369,18
32258,http://rosettacode.org/wiki/Negative_base_numbers,Negative base numbers,"Negative base numbers are an alternate way to encode numbers without the need for a minus sign. Various negative bases may be used including negadecimal (base -10), negabinary (-2) and negaternary (-3).[1][2]



Task

Encode the decimal number 10 as negabinary (expect 11110)
Encode the decimal number 146 as negaternary (expect 21102)
Encode the decimal number 15 as negadecimal (expect 195)
In each of the above cases, convert the encoded number back to decimal.


extra credit

 supply an integer, that when encoded to base   -62   (or something ""higher""),   expresses the 
name of the language being used   (with correct capitalization).   If the computer language has 
non-alphanumeric characters,   try to encode them into the negatory numerals,   or use other 
characters instead.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""strings""
)
 
const digits = ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz""
 
func reverse(bs []byte) []byte {
    for i, j := 0, len(bs)-1; i < len(bs)/2; i, j = i+1, j-1 {
        bs[i], bs[j] = bs[j], bs[i]
    }
    return bs
}
 
func encodeNegBase(n, b int64) (string, error) {
    if b < -62 || b > -1 {
        return """", fmt.Errorf(""base must be between -62 and -1 inclusive"")
    }
    if n == 0 {
        return ""0"", nil
    }
    var out []byte
    for n != 0 {
        rem := n % b
        n /= b
        if rem < 0 {
            n++
            rem -= b
        }
        out = append(out, digits[int(rem)])
    }
    reverse(out)
    return string(out), nil
}
 
func decodeNegBase(ns string, b int64) (int64, error) {
    if b < -62 || b > -1 {
        return 0, fmt.Errorf(""base must be between -62 and -1 inclusive"")
    }
    if ns == ""0"" {
        return 0, nil
    }
    total := int64(0)
    bb := int64(1)
    bs := []byte(ns)
    reverse(bs)
    for _, c := range bs {
        total += int64(strings.IndexByte(digits, c)) * bb
        bb *= b
    }
    return total, nil
}
 
func main() {
    numbers := []int64{10, 146, 15, -942, 1488588316238}
    bases := []int64{-2, -3, -10, -62, -62}
    for i := 0; i < len(numbers); i++ {
        n := numbers[i]
        b := bases[i]
        ns, err := encodeNegBase(n, b)
        if err != nil {
            log.Fatal(err)
        }
        fmt.Printf(""%13d encoded in base %-3d = %s\n"", n, b, ns)
        n, err = decodeNegBase(ns, b)
        if err != nil {
            log.Fatal(err)
        }
        fmt.Printf(""%13s decoded in base %-3d = %d\n\n"", ns, b, n)
    }
}",1702,74
32265,http://rosettacode.org/wiki/Narcissist,Narcissist,"Quoting from the Esolangs wiki page:


A narcissist (or Narcissus program) is the decision-problem version of a quine.



A quine, when run, takes no input, but produces a copy of its own source code at its output. In contrast, a narcissist reads a string of symbols from its input, and produces no output except a ""1"" or ""accept"" if that string matches its own source code, or a ""0"" or ""reject"" if it does not.


For concreteness, in this task we shall assume that symbol = character.

The narcissist should be able to cope with any finite input, whatever its length.

Any form of output is allowed, as long as the program always halts, and ""accept"", ""reject"" and ""not yet finished"" are distinguishable.



",#Go,Go,"package main; import ""os""; import ""fmt""; import ""bytes""; import ""io/ioutil""; func main() {ios := ""os""; ifmt := ""fmt""; ibytes := ""bytes""; iioutil := ""io/ioutil""; zero := ""Reject""; one := ""Accept""; x := ""package main; import %q; import %q; import %q; import %q; func main() {ios := %q; ifmt := %q; ibytes := %q; iioutil := %q; zero := %q; one := %q; x := %q; s := fmt.Sprintf(x, ios, ifmt, ibytes, iioutil, ios, ifmt, ibytes, iioutil, zero, one, x); in, _ := ioutil.ReadAll(os.Stdin); if bytes.Equal(in, []byte(s)) {fmt.Println(one);} else {fmt.Println(zero);};}\n""; s := fmt.Sprintf(x, ios, ifmt, ibytes, iioutil, ios, ifmt, ibytes, iioutil, zero, one, x); in, _ := ioutil.ReadAll(os.Stdin); if bytes.Equal(in, []byte(s)) {fmt.Println(one);} else {fmt.Println(zero);};}",768,1
32454,http://rosettacode.org/wiki/Natural_sorting,Natural sorting,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Natural sorting is the sorting of text that does more than rely on the
order of individual characters codes to make the finding of
individual strings easier for a human reader.

There is no ""one true way"" to do this, but for the purpose of this task 'natural' orderings might include:

1. Ignore leading, trailing and multiple adjacent spaces
2. Make all whitespace characters equivalent.
3. Sorting without regard to case.
4. Sorting numeric portions of strings in numeric order.
 That is split the string into fields on numeric boundaries, then sort on each field, with the rightmost fields being the most significant, and numeric fields of integers treated as numbers.
 foo9.txt before foo10.txt
 As well as ... x9y99 before x9y100, before x10y0
 ... (for any number of groups of integers in a string).
5. Title sorts: without regard to a leading, very common, word such
 as 'The' in ""The thirty-nine steps"".
6. Sort letters without regard to accents.
7. Sort ligatures as separate letters.
8. Replacements:
 Sort German eszett or scharfes S (ß)       as   ss
 Sort ſ, LATIN SMALL LETTER LONG S     as   s
 Sort ʒ, LATIN SMALL LETTER EZH           as   s
  ∙∙∙ 
Task Description
 Implement the first four of the eight given features in a natural sorting routine/function/method...
 Test each feature implemented separately with an ordered list of test strings from the   Sample inputs   section below,   and make sure your naturally sorted output is in the same order as other language outputs such as    Python. 
 Print and display your output.
 For extra credit implement more than the first four.


Note:   it is not necessary to have individual control of which features are active in the natural sorting routine at any time.



Sample input

• Ignoring leading spaces.                       Text strings:   ['ignore leading spaces:  2-2',
                                                                  'ignore leading spaces:  2-1', 
                                                                  'ignore leading spaces:  2+0',
                                                                  'ignore leading spaces:  2+1']

• Ignoring multiple adjacent spaces (MAS).       Text strings:   ['ignore MAS spaces:  2-2', 
                                                                  'ignore MAS spaces:  2-1', 
                                                                  'ignore MAS spaces:  2+0', 
                                                                  'ignore MAS spaces:  2+1']

• Equivalent whitespace characters.              Text strings:   ['Equiv.  spaces:     3-3', 
                                                                  'Equiv. \rspaces:    3-2', 
                                                                  'Equiv. \x0cspaces:  3-1', 
                                                                  'Equiv. \x0bspaces:  3+0', 
                                                                  'Equiv. \nspaces:    3+1', 
                                                                  'Equiv. \tspaces:    3+2']

• Case Independent sort.                         Text strings:   ['cASE INDEPENDENT:  3-2', 
                                                                  'caSE INDEPENDENT:  3-1', 
                                                                  'casE INDEPENDENT:  3+0', 
                                                                  'case INDEPENDENT:  3+1']
  
• Numeric fields as numerics.                    Text strings:   ['foo100bar99baz0.txt', 
                                                                  'foo100bar10baz0.txt', 
                                                                  'foo1000bar99baz10.txt', 
                                                                  'foo1000bar99baz9.txt']

• Title sorts.                                   Text strings:   ['The Wind in the Willows', 
                                                                  'The 40th step more', 
                                                                  'The 39 steps', 
                                                                  'Wanda']

• Equivalent accented characters (and case).     Text strings:   [u'Equiv. \xfd accents:  2-2', 
                                                                  u'Equiv. \xdd accents:  2-1', 
                                                                  u'Equiv.  y accents:    2+0', 
                                                                  u'Equiv.  Y accents:    2+1']

• Separated ligatures.                           Text strings:   [u'\u0132 ligatured ij', 
                                                                   'no ligature']

• Character replacements.                        Text strings:   [u'Start with an \u0292:  2-2', 
                                                                  u'Start with an \u017f:  2-1', 
                                                                  u'Start with an \xdf:    2+0', 
                                                                  u'Start with an  s:      2+1']




",#Go,Go,"package main
 
import (
    ""fmt""
    ""regexp""
    ""sort""
    ""strconv""
    ""strings""
)
 
var tests = []struct {
    descr string
    list  []string
}{
    {""Ignoring leading spaces"", []string{
        ""ignore leading spaces: 2-2"",
        "" ignore leading spaces: 2-1"",
        ""  ignore leading spaces: 2+0"",
        ""   ignore leading spaces: 2+1"",
    }},
    {""Ignoring multiple adjacent spaces"", []string{
        ""ignore m.a.s spaces: 2-2"",
        ""ignore m.a.s  spaces: 2-1"",
        ""ignore m.a.s   spaces: 2+0"",
        ""ignore m.a.s    spaces: 2+1"",
    }},
    {""Equivalent whitespace characters"", []string{
        ""Equiv. spaces: 3-3"",
        ""Equiv.\rspaces: 3-2"",
        ""Equiv.\fspaces: 3-1"",
        ""Equiv.\bspaces: 3+0"",
        ""Equiv.\nspaces: 3+1"",
        ""Equiv.\tspaces: 3+2"",
    }},
    {""Case Indepenent sort"", []string{
        ""cASE INDEPENENT: 3-2"",
        ""caSE INDEPENENT: 3-1"",
        ""casE INDEPENENT: 3+0"",
        ""case INDEPENENT: 3+1"",
    }},
    {""Numeric fields as numerics"", []string{
        ""foo100bar99baz0.txt"",
        ""foo100bar10baz0.txt"",
        ""foo1000bar99baz10.txt"",
        ""foo1000bar99baz9.txt"",
    }},
}
 
func main() {
    for _, test := range tests {
        fmt.Println(test.descr)
        fmt.Println(""Input order:"")
        for _, s := range test.list {
            fmt.Printf(""   %q\n"", s)
        }
        fmt.Println(""Natural order:"")
        l := make(list, len(test.list))
        for i, s := range test.list {
            l[i] = newNatStr(s)
        }
        sort.Sort(l)
        for _, s := range l {
            fmt.Printf(""   %q\n"", s.s)
        }
        fmt.Println()
    }
}
 
// natStr associates a string with a preprocessed form
type natStr struct {
    s string // original
    t []tok  // preprocessed ""sub-fields""
}
 
func newNatStr(s string) (t natStr) {
    t.s = s
    s = strings.ToLower(strings.Join(strings.Fields(s), "" ""))
    x := dx.FindAllString(s, -1)
    t.t = make([]tok, len(x))
    for i, s := range x {
        if n, err := strconv.Atoi(s); err == nil {
            t.t[i].n = n
        } else {
            t.t[i].s = s
        }
    }
    return t
}
 
var dx = regexp.MustCompile(`\d+|\D+`)
 
// rule is to use s unless it is empty, then use n
type tok struct {
    s string
    n int
}
 
// rule 2 of ""numeric sub-fields"" from talk page
func (f1 tok) Cmp(f2 tok) int {
    switch {
    case f1.s == """":
        switch {
        case f2.s > """" || f1.n < f2.n:
            return -1
        case f1.n > f2.n:
            return 1
        }
    case f2.s == """" || f1.s > f2.s:
        return 1
    case f1.s < f2.s:
        return -1
    }
    return 0
}
 
type list []natStr
 
func (l list) Len() int      { return len(l) }
func (l list) Swap(i, j int) { l[i], l[j] = l[j], l[i] }
func (l list) Less(i, j int) bool {
    ti := l[i].t
    for k, t := range l[j].t {
        if k == len(ti) {
            return true
        }
        switch ti[k].Cmp(t) {
        case -1:
            return true
        case 1:
            return false
        }
    }
    return false
}",3080,134
32459,http://rosettacode.org/wiki/Naming_conventions,Naming conventions,"Many languages have naming conventions regarding the identifiers used in the language, its libraries, and programs written in the language. Such conventions, which may be classified as de facto or de jure depending on how they are enforced,
often take the form of rules regarding prefixes, suffixes, and the use of upper-case and lower-case characters.

The naming conventions are sometimes a bit haphazard, especially if the language and/or library has gone through periods of evolution. (In this case: give a brief example and description.)

Document (with simple examples where possible) the evolution and current status of these naming conventions.
For example, name conventions for:

 Procedure and operator names. (Intrinsic or external)
 Class, Subclass and instance names.
 Built-in versus libraries names.


If possible, indicate where the naming conventions are implicit, explicit, mandatory or discretionary.
Any tools that enforced the the naming conventions.
Any cases where the naming convention as commonly violated.

If possible, indicate where the convention is used to hint at other issues. For example the C standard library uses a prefix of ""_"" to ""hide"" raw Operating System calls from the non systems-programmer, whereas Python embeds member functions in between ""__"" to make a member function ""private"".

See also

 Wikipedia: Naming convention (programming)

",#Go,Go,"// version 1.0.6
 
const val SOLAR_DIAMETER = 864938
 
enum class Planet { MERCURY, VENUS, EARTH, MARS, JUPITER, SATURN, URANUS, NEPTUNE, PLUTO } // Yeah, Pluto!
 
class Star(val name: String) {
    fun showDiameter() {
        println(""The diameter of the $name is ${""%,d"".format(SOLAR_DIAMETER)} miles"")
    }
}
 
class SolarSystem(val star: Star) { 
    private val planets = mutableListOf<Planet>()  // some people might prefer _planets
 
    init {
       for (planet in Planet.values()) planets.add(planet)
    }
 
    fun listPlanets() {
       println(planets)
    }
}
 
fun main(args: Array<String>) {
    val sun = Star(""sun"")
    val ss = SolarSystem(sun)
    sun.showDiameter()
    println(""\nIts planetary system comprises : "")
    ss.listPlanets()
}",763,31
32521,http://rosettacode.org/wiki/Non-decimal_radices/Convert,Non-decimal radices/Convert,"Number base conversion is when you express a stored integer in an integer base, such as in octal (base 8) or binary (base 2). It also is involved when you take a string representing a number in a given base and convert it to the stored integer form. Normally, a stored integer is in binary, but that's typically invisible to the user, who normally enters or sees stored integers as decimal.



Task

Write a function (or identify the built-in function) which is passed a non-negative integer to convert, and another integer representing the base.

It should return a string containing the digits of the resulting number, without leading zeros except for the number   0   itself.

For the digits beyond 9, one should use the lowercase English alphabet, where the digit   a = 9+1,   b = a+1,   etc.

For example:   the decimal number   26   expressed in base   16   would be   1a.

Write a second function which is passed a string and an integer base, and it returns an integer representing that string interpreted in that base.

The programs may be limited by the word size or other such constraint of a given language. There is no need to do error checking for negatives, bases less than 2, or inappropriate digits.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""strconv""
)
 
func main () {
    s := strconv.FormatInt(26, 16) // returns the string ""1a""
    fmt.Println(s)
 
    i, err := strconv.ParseInt(""1a"", 16, 64) // returns the integer (int64) 26
    if err == nil {
        fmt.Println(i)
    }
    b, ok := new(big.Int).SetString(""1a"", 16) // returns the big integer 26
    if ok {
        fmt.Println(b)
    }
}",411,21
32646,http://rosettacode.org/wiki/M%C3%B6bius_function,Möbius function,"The classical Möbius function: μ(n) is an important multiplicative function in number theory and combinatorics.

There are several ways to implement a Möbius function.

A fairly straightforward method is to find the prime factors of a positive integer n, then define μ(n) based on the sum of the primitive factors. It has the values {−1, 0, 1} depending on the factorization of n:

 μ(1) is defined to be 1.
 μ(n) = 1 if n is a square-free positive integer with an even number of prime factors.
 μ(n) = −1 if n is a square-free positive integer with an odd number of prime factors.
 μ(n) = 0 if n has a squared prime factor.


Task

 Write a routine (function, procedure, whatever) μ(n) to find the Möbius number for a positive integer n.
 Use that routine to find and display here, on this page, at least the first 99 terms in a grid layout. (Not just one long line or column of numbers.)


See also

 Wikipedia: Möbius function


Related Tasks

 Mertens function

",#Go,Go,"package main
 
import ""fmt""
 
func möbius(to int) []int {
    if to < 1 {
        to = 1
    }
    mobs := make([]int, to+1) // all zero by default
    primes := []int{2}
    for i := 1; i <= to; i++ {
        j := i
        cp := 0      // counts prime factors
        spf := false // true if there is a square prime factor
        for _, p := range primes {
            if p > j {
                break
            }
            if j%p == 0 {
                j /= p
                cp++
            }
            if j%p == 0 {
                spf = true
                break
            }
        }
        if cp == 0 && i > 2 {
            cp = 1
            primes = append(primes, i)
        }
        if !spf {
            if cp%2 == 0 {
                mobs[i] = 1
            } else {
                mobs[i] = -1
            }
        }
    }
    return mobs
}
 
func main() {
    mobs := möbius(199)
    fmt.Println(""Möbius sequence - First 199 terms:"")
    for i := 0; i < 200; i++ {
        if i == 0 {
            fmt.Print(""    "")
            continue
        }
        if i%20 == 0 {
            fmt.Println()
        }
        fmt.Printf(""  % d"", mobs[i])
    }
}",1180,56
32673,http://rosettacode.org/wiki/N-smooth_numbers,N-smooth numbers,"n-smooth   numbers are positive integers which have no prime factors  >  n.

The   n   (when using it in the expression)   n-smooth   is always prime,

there are   no   9-smooth numbers.

1   (unity)   is always included in n-smooth numbers.




2-smooth   numbers are non-negative powers of two.

5-smooth   numbers are also called   Hamming numbers.

7-smooth   numbers are also called    humble   numbers.



A way to express   11-smooth   numbers is:

  11-smooth  =  2i × 3j × 5k × 7m × 11p

           where     i, j, k, m, p ≥ 0  



Task

   calculate and show the first   25   n-smooth numbers   for   n=2   ───►   n=29
   calculate and show   three numbers starting with   3,000   n-smooth numbers   for   n=3   ───►   n=29
   calculate and show twenty numbers starting with  30,000   n-smooth numbers   for   n=503   ───►   n=521   (optional)


All ranges   (for   n)   are to be inclusive, and only prime numbers are to be used.

The (optional) n-smooth numbers for the third range are:   503,   509,   and   521.

Show all n-smooth numbers for any particular   n   in a horizontal list.

Show all output here on this page.



Related tasks

   Hamming numbers
   humble numbers


References

   Wikipedia entry:   Hamming numbers     (this link is re-directed to   Regular number).
   Wikipedia entry:   Smooth number
   OEIS entry:   A000079    2-smooth numbers or non-negative powers of two
   OEIS entry:   A003586    3-smooth numbers
   OEIS entry:   A051037    5-smooth numbers or Hamming numbers
   OEIS entry:   A002473    7-smooth numbers or humble numbers
   OEIS entry:   A051038   11-smooth numbers
   OEIS entry:   A080197   13-smooth numbers
   OEIS entry:   A080681   17-smooth numbers
   OEIS entry:   A080682   19-smooth numbers
   OEIS entry:   A080683   23-smooth numbers

",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math/big""
)
 
var (
    primes      []*big.Int
    smallPrimes []int
)
 
// cache all primes up to 521
func init() {
    two := big.NewInt(2)
    three := big.NewInt(3)
    p521 := big.NewInt(521)
    p29 := big.NewInt(29)
    primes = append(primes, two)
    smallPrimes = append(smallPrimes, 2)
    for i := three; i.Cmp(p521) <= 0; i.Add(i, two) {
        if i.ProbablyPrime(0) {
            primes = append(primes, new(big.Int).Set(i))
            if i.Cmp(p29) <= 0 {
                smallPrimes = append(smallPrimes, int(i.Int64()))
            }
        }
    }
}
 
func min(bs []*big.Int) *big.Int {
    if len(bs) == 0 {
        log.Fatal(""slice must have at least one element"")
    }
    res := bs[0]
    for _, i := range bs[1:] {
        if i.Cmp(res) < 0 {
            res = i
        }
    }
    return res
}
 
func nSmooth(n, size int) []*big.Int {
    if n < 2 || n > 521 {
        log.Fatal(""n must be between 2 and 521"")
    }
    if size < 1 {
        log.Fatal(""size must be at least 1"")
    }
    bn := big.NewInt(int64(n))
    ok := false
    for _, prime := range primes {
        if bn.Cmp(prime) == 0 {
            ok = true
            break
        }
    }
    if !ok {
        log.Fatal(""n must be a prime number"")
    }
 
    ns := make([]*big.Int, size)
    ns[0] = big.NewInt(1)
    var next []*big.Int
    for i := 0; i < len(primes); i++ {
        if primes[i].Cmp(bn) > 0 {
            break
        }
        next = append(next, new(big.Int).Set(primes[i]))
    }
    indices := make([]int, len(next))
    for m := 1; m < size; m++ {
        ns[m] = new(big.Int).Set(min(next))
        for i := 0; i < len(indices); i++ {
            if ns[m].Cmp(next[i]) == 0 {
                indices[i]++
                next[i].Mul(primes[i], ns[indices[i]])
            }
        }
    }
    return ns
}
 
func main() {
    for _, i := range smallPrimes {
        fmt.Printf(""The first 25 %d-smooth numbers are:\n"", i)
        fmt.Println(nSmooth(i, 25), ""\n"")
    }
    for _, i := range smallPrimes[1:] {
        fmt.Printf(""The 3,000th to 3,202nd %d-smooth numbers are:\n"", i)
        fmt.Println(nSmooth(i, 3002)[2999:], ""\n"")
    }
    for _, i := range []int{503, 509, 521} {
        fmt.Printf(""The 30,000th to 30,019th %d-smooth numbers are:\n"", i)
        fmt.Println(nSmooth(i, 30019)[29999:], ""\n"")
    }
}",2390,99
32719,http://rosettacode.org/wiki/Named_parameters,Named parameters,"Create a function which takes in a number of arguments which are specified by name rather than (necessarily) position, and show how to call the function. If the language supports reordering the arguments or optionally omitting some of them, note this.

Note:

 Named parameters relies on being able to use the names given to function parameters when the function is defined, when assigning arguments when the function is called.
 For example, if a function were to be defined as define func1( paramname1, paramname2); then it could be called normally as func1(argument1, argument2) and in the called function paramname1 would be associated with argument1 and paramname2 with argument2.
 func1 must also be able to be called in a way that visually binds each parameter to its respective argument, irrespective of argument order, for example: func1(paramname2=argument2, paramname1=argument1) which explicitly makes the same parameter/argument bindings as before.
 Named parameters are often a feature of languages used in safety critical areas such as Verilog and VHDL.
See also:

 Varargs
 Optional parameters
 Wikipedia: Named parameter

",#Go,Go,"package main
 
import (
   ""fmt""
)
 
type params struct {x, y, z int}
 
func myFunc(p params) int {
    return p.x + p.y + p.z
}
 
func main() {
    r := myFunc(params{x: 1, y: 2, z: 3}) // all fields, same order
    fmt.Println(""r ="", r)
    s := myFunc(params{z: 3, y: 2, x: 1}) // all fields, different order
    fmt.Println(""s ="", s)
    t := myFunc(params{y: 2})             // only one field, others set to zero
    fmt.Println(""t ="", t)
}",445,20
32792,http://rosettacode.org/wiki/Musical_scale,Musical scale,"Task

Output the 8 notes of the C major diatonic scale to the default musical sound device on the system. Specifically, pitch must be tuned to 12-tone equal temperament (12TET) with the modern standard A=440Hz.

These are the notes ""C, D, E, F, G, A, B, C(1 octave higher)"", or ""Do, Re, Mi, Fa, Sol, La, Si/Ti, Do(1 octave higher)"" on Fixed do Solfège.

For the purpose of this task, Middle C (in the case of the above tuning, around 261.63 Hz) should be used as the starting note, and any note duration is allowed.

For languages that cannot utilize a sound device, it is permissible to output to a musical score sheet (or midi file), or the task can be omitted.
",#Go,Go,"package main
 
import (
    ""encoding/binary""
    ""log""
    ""math""
    ""os""
    ""strings""
)
 
func main() {
    const (
        sampleRate = 44100
        duration   = 8
        dataLength = sampleRate * duration
        hdrSize    = 44
        fileLen    = dataLength + hdrSize - 8
    )
 
    // buffers
    buf1 := make([]byte, 1)
    buf2 := make([]byte, 2)
    buf4 := make([]byte, 4)
 
    // WAV header
    var sb strings.Builder
    sb.WriteString(""RIFF"")
    binary.LittleEndian.PutUint32(buf4, fileLen)
    sb.Write(buf4) // file size - 8
    sb.WriteString(""WAVE"")
    sb.WriteString(""fmt "")
    binary.LittleEndian.PutUint32(buf4, 16)
    sb.Write(buf4) // length of format data (= 16)
    binary.LittleEndian.PutUint16(buf2, 1)
    sb.Write(buf2) // type of format (= 1 (PCM))
    sb.Write(buf2) // number of channels (= 1)
    binary.LittleEndian.PutUint32(buf4, sampleRate)
    sb.Write(buf4) // sample rate
    sb.Write(buf4) // sample rate * bps(8) * channels(1) / 8 (= sample rate)
    sb.Write(buf2) // bps(8) * channels(1) / 8  (= 1)
    binary.LittleEndian.PutUint16(buf2, 8)
    sb.Write(buf2) // bits per sample (bps) (= 8)
    sb.WriteString(""data"")
    binary.LittleEndian.PutUint32(buf4, dataLength)
    sb.Write(buf4) // size of data section
    wavhdr := []byte(sb.String())
 
    // write WAV header
    f, err := os.Create(""notes.wav"")
    if err != nil {
        log.Fatal(err)
    }
    defer f.Close()
    f.Write(wavhdr)
 
    // compute and write actual data
    freqs := [8]float64{261.6, 293.6, 329.6, 349.2, 392.0, 440.0, 493.9, 523.3}
    for j := 0; j < duration; j++ {
        freq := freqs[j]
        omega := 2 * math.Pi * freq
        for i := 0; i < dataLength/duration; i++ {
            y := 32 * math.Sin(omega*float64(i)/float64(sampleRate))
            buf1[0] = byte(math.Round(y))
            f.Write(buf1)
        }
    }
}",1876,67
32815,http://rosettacode.org/wiki/Nth_root,Nth root,"Task

Implement the algorithm to compute the principal   nth   root   





A

n





{\displaystyle {\sqrt[{n}]{A}}}

   of a positive real number   A,   as explained at the   Wikipedia page.


",#Go,Go,"func root(a float64, n int) float64 {
    n1 := n - 1
    n1f, rn := float64(n1), 1/float64(n)
    x, x0 := 1., 0.
    for {
        potx, t2 := 1/x, a
        for b := n1; b > 0; b >>= 1 {
            if b&1 == 1 {
                t2 *= potx
            }
            potx *= potx
        }
        x0, x = x, rn*(n1f*x+t2)
        if math.Abs(x-x0)*1e15 < x {
            break
        }
    }
    return x
}",410,19
32839,http://rosettacode.org/wiki/Munching_squares,Munching squares,"Render a graphical pattern where each pixel is colored by the value of 'x xor y' from an arbitrary color table.
",#Go,Go,"package main
 
import (
    ""image""
    ""image/png""
    ""os""
)
 
func main() {
    g := image.NewGray(image.Rect(0, 0, 256, 256))
    for i := range g.Pix {
        g.Pix[i] = uint8(i>>8 ^ i)
    }
    f, _ := os.Create(""xor.png"")
    png.Encode(f, g)
    f.Close()
}",267,17
32911,http://rosettacode.org/wiki/Narcissistic_decimal_number,Narcissistic decimal number,"A   Narcissistic decimal number   is a non-negative integer,   



n


{\displaystyle n}

,   that is equal to the sum of the   



m


{\displaystyle m}

-th   powers of each of the digits in the decimal representation of   



n


{\displaystyle n}

,   where   



m


{\displaystyle m}

   is the number of digits in the decimal representation of   



n


{\displaystyle n}

.



Narcissistic (decimal) numbers are sometimes called   Armstrong   numbers, named after Michael F. Armstrong.

They are also known as   Plus Perfect   numbers.



An example

   if   



n


{\displaystyle n}

   is   153 
   then   



m


{\displaystyle m}

,   (the number of decimal digits)   is   3 
   we have    13 + 53 + 33   =   1 + 125 + 27   =   153  
   and so   153   is a narcissistic decimal number


Task

Generate and show here the first   25   narcissistic decimal numbers.



Note:   




0

1


=
0


{\displaystyle 0^{1}=0}

,   the first in the series.



See also

   the  OEIS entry:     Armstrong (or Plus Perfect, or narcissistic) numbers.
   MathWorld entry:   Narcissistic Number.
   Wikipedia entry:     Narcissistic number.

",#Go,Go,"package main
 
import ""fmt""
 
func narc(n int) []int {
	power := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	limit := 10
	result := make([]int, 0, n)
	for x := 0; len(result) < n; x++ {
		if x >= limit {
			for i := range power {
				power[i] *= i // i^m
			}
			limit *= 10
		}
		sum := 0
		for xx := x; xx > 0; xx /= 10 {
			sum += power[xx%10]
		}
		if sum == x {
			result = append(result, x)
		}
	}
	return result
}
 
func main() {
	fmt.Println(narc(25))
}",457,29
32969,http://rosettacode.org/wiki/Multisplit,Multisplit,"It is often necessary to split a string into pieces
based on several different (potentially multi-character) separator strings,
while still retaining the information about which separators were present in the input.

This is particularly useful when doing small parsing tasks. 

The task is to write code to demonstrate this.

The function (or procedure or method, as appropriate) should
take an input string and an ordered collection of separators.

The order of the separators is significant: 

The delimiter order represents priority in matching, with the first defined delimiter having the highest priority.
In cases where there would be an ambiguity as to
which separator to use at a particular point
(e.g., because one separator is a prefix of another)
the separator with the highest priority should be used.
Delimiters can be reused and the output from the function should be an ordered sequence of substrings.

Test your code using the input string “a!===b=!=c” and the separators “==”, “!=” and “=”.

For these inputs the string should be parsed as ""a"" (!=) """" (==) ""b"" (=) """" (!=) ""c"", where matched delimiters are shown in parentheses, and separated strings are quoted, so our resulting output is ""a"", empty string, ""b"", empty string, ""c"".
Note that the quotation marks are shown for clarity and do not form part of the output.

Extra Credit: provide information that indicates which separator was matched at each separation point and where in the input string that separator was matched.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func ms(txt string, sep []string) (ans []string) {
    for txt > """" {
        sepMatch := """"
        posMatch := len(txt)
        for _, s := range sep {
            if p := strings.Index(txt, s); p >= 0 && p < posMatch {
                sepMatch = s
                posMatch = p
            }
        }
        ans = append(ans, txt[:posMatch])
        txt = txt[posMatch+len(sepMatch):]
    }
    return
}
 
func main() {
    fmt.Printf(""%q\n"", ms(""a!===b=!=c"", []string{""=="", ""!="", ""=""}))
}",545,26
33184,http://rosettacode.org/wiki/N%27th,N'th,"Write a function/method/subroutine/... that when given an integer greater than or equal to zero returns a string of the number followed by an apostrophe then the ordinal suffix.



Example

Returns would include 1'st 2'nd 3'rd 11'th 111'th 1001'st 1012'th



Task

Use your routine to show here the output for at least the following (inclusive) ranges of integer inputs:
0..25, 250..265, 1000..1025


Note: apostrophes are now optional to allow correct apostrophe-less English.



",#Go,Go,"package main
 
import ""fmt""
 
func ord(n int) string {
    s := ""th""
    switch c := n % 10; c {
    case 1, 2, 3:
        if n%100/10 == 1 {
            break
        }
        switch c {
        case 1:
            s = ""st""
        case 2:
            s = ""nd""
        case 3:
            s = ""rd""
        }
    }
    return fmt.Sprintf(""%d%s"", n, s)
}
 
func main() {
    for n := 0; n <= 25; n++ {
        fmt.Printf(""%s "", ord(n))
    }
    fmt.Println()
    for n := 250; n <= 265; n++ {
        fmt.Printf(""%s "", ord(n))
    }
    fmt.Println()
    for n := 1000; n <= 1025; n++ {
        fmt.Printf(""%s "", ord(n))
    }
    fmt.Println()
}",647,37
33231,http://rosettacode.org/wiki/Multiplicative_order,Multiplicative order,"The multiplicative order of a relative to m is the least positive integer n such that a^n is 1 (modulo m).



Example

The multiplicative order of 37 relative to 1000 is 100 because 37^100 is 1 (modulo 1000), and no number smaller than 100 would do.



One possible algorithm that is efficient also for large numbers is the following: By the Chinese Remainder Theorem, it's enough to calculate the multiplicative order for each prime exponent p^k of m, and
combine the results with the least common multiple operation.

Now the order of a with regard to p^k must divide Φ(p^k). Call this number t, and determine it's factors q^e. Since each multiple of the order will also yield 1 when used as exponent for a, it's enough to find the least d such that (q^d)*(t/(q^e)) yields 1 when used as exponent.



Task

Implement a routine to calculate the multiplicative order along these lines. You may assume that routines to determine the factorization into prime powers are available in some library.


An algorithm for the multiplicative order can be found in Bach & Shallit, Algorithmic Number Theory, Volume I: Efficient Algorithms, The MIT Press, 1996:

Exercise 5.8, page 115:
Suppose you are given a prime p and a complete factorization
of p-1.   Show how to compute the order of an
element a in (Z/(p))* using O((lg p)4/(lg lg p)) bit
operations.
Solution, page 337:
Let the prime factorization of p-1  be q1e1q2e2...qkek . We use the following observation:
if x^((p-1)/qifi) = 1 (mod p) , 
and fi=ei or x^((p-1)/qifi+1) != 1 (mod p) , then qiei-fi||ordp x.   (This follows by combining Exercises 5.1 and 2.10.)
Hence it suffices to find, for each i , the exponent fi  such that the condition above holds.
This can be done as follows: first compute q1e1, q2e2, ... ,
qkek .  This can be done using O((lg p)2) bit operations. Next, compute y1=(p-1)/q1e1, ... , yk=(p-1)/qkek . 
This can be done using O((lg p)2) bit operations. Now, using the binary method,
compute x1=ay1(mod p), ... , xk=ayk(mod p) . 
This can be done using O(k(lg p)3) bit operations, and k=O((lg p)/(lg lg p)) by Theorem 8.8.10.
Finally, for each i , repeatedly raise xi to the qi-th power (mod p) (as many as ei-1  times), checking to see when 1 is obtained.
This can be done using O((lg p)3) steps.
The total cost is dominated by O(k(lg p)3) , which is O((lg p)4/(lg lg p)).



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    moTest(big.NewInt(37), big.NewInt(3343))
    b := big.NewInt(100)
    moTest(b.Add(b.Exp(ten, b, nil), one), big.NewInt(7919))
    moTest(b.Add(b.Exp(ten, b.SetInt64(1000), nil), one), big.NewInt(15485863))
    moTest(b.Sub(b.Exp(ten, b.SetInt64(10000), nil), one),
        big.NewInt(22801763489))
 
    moTest(big.NewInt(1511678068), big.NewInt(7379191741))
    moTest(big.NewInt(3047753288), big.NewInt(2257683301))
}
 
func moTest(a, n *big.Int) {
    if a.BitLen() < 100 {
        fmt.Printf(""ord(%v)"", a)
    } else {
        fmt.Print(""ord([big])"")
    }
    if n.BitLen() < 100 {
        fmt.Printf("" mod %v "", n)
    } else {
        fmt.Print("" mod [big] "")
    }
    if !n.ProbablyPrime(20) {
        fmt.Println(""not computed.  modulus must be prime for this algorithm."")
        return
    }
    fmt.Println(""="", moBachShallit58(a, n, factor(new(big.Int).Sub(n, one))))
}
 
var one = big.NewInt(1)
var two = big.NewInt(2)
var ten = big.NewInt(10)
 
func moBachShallit58(a, n *big.Int, pf []pExp) *big.Int {
    n1 := new(big.Int).Sub(n, one)
    var x, y, o1, g big.Int
    mo := big.NewInt(1)
    for _, pe := range pf {
        y.Quo(n1, y.Exp(pe.prime, big.NewInt(pe.exp), nil))
        var o int64
        for x.Exp(a, &y, n); x.Cmp(one) > 0; o++ {
            x.Exp(&x, pe.prime, n)
        }
        o1.Exp(pe.prime, o1.SetInt64(o), nil)
        mo.Mul(mo, o1.Quo(&o1, g.GCD(nil, nil, mo, &o1)))
    }
    return mo
}
 
type pExp struct {
    prime *big.Int
    exp   int64
}
 
func factor(n *big.Int) (pf []pExp) {
    var e int64
    for ; n.Bit(int(e)) == 0; e++ {
    }
    if e > 0 {
        n.Rsh(n, uint(e))
        pf = []pExp{{big.NewInt(2), e}}
    }
    s := sqrt(n)
    q, r := new(big.Int), new(big.Int)
    for d := big.NewInt(3); n.Cmp(one) > 0; d.Add(d, two) {
        if d.Cmp(s) > 0 {
            d.Set(n)
        }
        for e = 0; ; e++ {
            q.QuoRem(n, d, r)
            if r.BitLen() > 0 {
                break
            }
            n.Set(q)
        }
        if e > 0 {
            pf = append(pf, pExp{new(big.Int).Set(d), e})
            s = sqrt(n)
        }
    }
    return
}
 
func sqrt(n *big.Int) *big.Int {
    a := new(big.Int)
    for b := new(big.Int).Set(n); ; {
        a.Set(b)
        b.Rsh(b.Add(b.Quo(n, a), a), 1)
        if b.Cmp(a) >= 0 {
            return a
        }
    }
    return a.SetInt64(0)
}",2452,102
33238,http://rosettacode.org/wiki/Munchausen_numbers,Munchausen numbers,"A Munchausen number is a natural number n the sum of whose digits (in base 10), each raised to the power of itself, equals n.

(Munchausen is also spelled: Münchhausen.)

For instance:    3435 = 33 + 44 + 33 + 55 



Task
Find all Munchausen numbers between   1   and   5000.



Also see

 The OEIS entry:  A046253
 The Wikipedia entry:  Perfect digit-to-digit invariant, redirected from Munchausen Number

",#Go,Go,"package main
 
import(
    ""fmt""
    ""math""
)
 
var powers [10]int
 
func isMunchausen(n int) bool {
    if n < 0 { return false }
    n64 := int64(n)
    nn  := n64
    var sum int64 = 0
    for nn > 0 {
        sum += int64(powers[nn % 10])
        if sum > n64 { return false }
        nn /= 10
    }
    return sum == n64
}
 
func main() {
    // cache n ^ n for n in 0..9, defining 0 ^ 0 = 0 for this purpose
    for i := 1; i <= 9; i++ {
        d := float64(i)  
        powers[i] = int(math.Pow(d, d))
    }
 
    // check numbers 0 to 500 million
    fmt.Println(""The Munchausen numbers between 0 and 500 million are:"")
    for i := 0; i <= 500000000; i++ {
        if isMunchausen(i) { fmt.Printf(""%d "", i) }
    }
    fmt.Println()
}",744,36
33265,http://rosettacode.org/wiki/Multi-base_primes,Multi-base primes,"Prime numbers are prime no matter what base they are represented in.

A prime number in a base other than 10 may not look prime at first glance.

For instance: 19 base 10 is 25 in base 7.



Several different prime numbers may be expressed as the ""same"" string when converted to a different base.

 107 base 10 converted to base 6 == 255
 173 base 10 converted to base 8 == 255
 353 base 10 converted to base 12 == 255
 467 base 10 converted to base 14 == 255
 743 base 10 converted to base 18 == 255
 1277 base 10 converted to base 24 == 255
 1487 base 10 converted to base 26 == 255
 2213 base 10 converted to base 32 == 255


Task
Restricted to bases 2 through 36; find the strings that have the most different bases that evaluate to that string when converting prime numbers to a base.

Find the conversion string, the amount of bases that evaluate a prime to that string and the enumeration of bases that evaluate a prime to that string.

Display here, on this page, the string, the count and the list for all of the: 1 character, 2 character, 3 character, and 4 character strings that have the maximum base count that evaluate to that string.

Should be no surprise, the string '2' has the largest base count for single character strings.



Stretch goal
Do the same for the maximum 5 character string.


",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""rcu""
)
 
var maxDepth = 6
var maxBase = 36
var c = rcu.PrimeSieve(int(math.Pow(float64(maxBase), float64(maxDepth))), true)
var digits = ""0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ""
var maxStrings [][][]int
var mostBases = -1
 
func maxSlice(a []int) int {
    max := 0
    for _, e := range a {
        if e > max {
            max = e
        }
    }
    return max
}
 
func maxInt(a, b int) int {
    if a > b {
        return a
    }
    return b
}
 
func process(indices []int) {
    minBase := maxInt(2, maxSlice(indices)+1)
    if maxBase - minBase + 1 < mostBases {
        return  // can't affect results so return
    }
    var bases []int
    for b := minBase; b <= maxBase; b++ {
        n := 0
        for _, i := range indices {
            n = n*b + i
        }
        if !c[n] {
            bases = append(bases, b)
        }
    }
    count := len(bases)
    if count > mostBases {
        mostBases = count
        indices2 := make([]int, len(indices))
        copy(indices2, indices)
        maxStrings = [][][]int{[][]int{indices2, bases}}
    } else if count == mostBases {
        indices2 := make([]int, len(indices))
        copy(indices2, indices)
        maxStrings = append(maxStrings, [][]int{indices2, bases})
    }
}
 
func printResults() {
    fmt.Printf(""%d\n"", len(maxStrings[0][1]))
    for _, m := range maxStrings {
        s := """"
        for _, i := range m[0] {
            s = s + string(digits[i])
        }
        fmt.Printf(""%s -> %v\n"", s, m[1])
    }
}
 
func nestedFor(indices []int, length, level int) {
    if level == len(indices) {
        process(indices)
    } else {
        indices[level] = 0
        if level == 0 {
            indices[level] = 1
        }
        for indices[level] < length {
            nestedFor(indices, length, level+1)
            indices[level]++
        }
    }
}
 
func main() {
    for depth := 1; depth <= maxDepth; depth++ {
        fmt.Print(depth, "" character strings which are prime in most bases: "")
        maxStrings = maxStrings[:0]
        mostBases = -1
        indices := make([]int, depth)
        nestedFor(indices, maxBase, 0)
        printResults()
        fmt.Println()
    }
}",2249,97
33328,http://rosettacode.org/wiki/Multiple_distinct_objects,Multiple distinct objects,"Create a sequence (array, list, whatever) consisting of n distinct, initialized items of the same type. n should be determined at runtime.

By distinct we mean that if they are mutable, changes to one do not affect all others; if there is an appropriate equality operator they are considered unequal; etc. The code need not specify a particular kind of distinction, but do not use e.g. a numeric-range generator which does not generalize.

By initialized we mean that each item must be in a well-defined state appropriate for its type, rather than e.g. arbitrary previous memory contents in an array allocation. Do not show only an initialization technique which initializes only to ""zero"" values (e.g. calloc() or int a[n] = {}; in C), unless user-defined types can provide definitions of ""zero"" for that type.

This task was inspired by the common error of intending to do this, but instead creating a sequence of n references to the same mutable object; it might be informative to show the way to do that as well, both as a negative example and as how to do it when that's all that's actually necessary.

This task is most relevant to languages operating in the pass-references-by-value style (most object-oriented, garbage-collected, and/or 'dynamic' languages).

See also: Closures/Value capture
",#Go,Go,"func nxm(n, m int) [][]int {
    d2 := make([][]int, n)
    for i := range d2 {
        d2[i] = make([]int, m)
    }
    return d2
}",132,7
33436,http://rosettacode.org/wiki/Multi-dimensional_array,Multi-dimensional array,"For the purposes of this task, the actual memory layout or access method of this data structure is not mandated.

It is enough to:

 State the number and extent of each index to the array.
 Provide specific, ordered, integer indices for all dimensions of the array together with a new value to update the indexed value.
 Provide specific, ordered, numeric indices for all dimensions of the array to obtain the arrays value at that indexed position.


Task

 State if the language supports multi-dimensional arrays in its syntax and usual implementation.
 State whether the language uses row-major or column major order for multi-dimensional array storage, or any other relevant kind of storage.
 Show how to create a four dimensional array in your language and set, access, set to another value; and access the new value of an integer-indexed item of the array.
 The idiomatic method for the language is preferred.
 The array should allow a range of five, four, three and two (or two three four five if convenient), in each of the indices, in order. (For example, if indexing starts at zero for the first index then a range of 0..4 inclusive would suffice).
 State if memory allocation is optimised for the array - especially if contiguous memory is likely to be allocated.
 If the language has exceptional native multi-dimensional array support such as optional bounds checking, reshaping, or being able to state both the lower and upper bounds of index ranges, then this is the task to mention them.


Show all output here, (but you may judiciously use ellipses to shorten repetitive output text).



",#Go,Go,"package main
 
import ""fmt""
 
type md struct {
    dim []int
    ele []float64
}
 
func newMD(dim ...int) *md {
    n := 1
    for _, d := range dim {
        n *= d
    }
    return &md{append([]int{}, dim...), make([]float64, n)}
}
 
func (m *md) index(i ...int) (x int) {
    for d, dx := range m.dim {
        x = x*dx + i[d]
    }
    return
}
 
func (m *md) at(i ...int) float64 {
    return m.ele[m.index(i...)]
}
 
func (m *md) set(x float64, i ...int) {
    m.ele[m.index(i...)] = x
}
 
func (m *md) show(i ...int) {
    fmt.Printf(""m%d = %g\n"", i, m.at(i...))
}
 
func main() {
    m := newMD(5, 4, 3, 2)
    m.show(4, 3, 2, 1)
    m.set(87, 4, 3, 2, 1)
    m.show(4, 3, 2, 1)
 
    for i := 0; i < m.dim[0]; i++ {
        for j := 0; j < m.dim[1]; j++ {
            for k := 0; k < m.dim[2]; k++ {
                for l := 0; l < m.dim[3]; l++ {
                    x := m.index(i, j, k, l)
                    m.set(float64(x)+.1, i, j, k, l)
                }
            }
        }
    }
    fmt.Println(m.ele[:10])
    fmt.Println(m.ele[len(m.ele)-10:])
    m.show(4, 3, 2, 1)
}",1094,56
33456,http://rosettacode.org/wiki/Motzkin_numbers,Motzkin numbers,"Definition
The nth Motzkin number (denoted by M[n]) is the number of different ways of drawing non-intersecting chords between n points on a circle (not necessarily touching every point by a chord).

By convention M[0] = 1.



Task
Compute and show on this page the first 42 Motzkin numbers or, if your language does not support 64 bit integers, as many such numbers as you can. Indicate which of these numbers are prime.



See also
 oeis:A001006 Motzkin numbers 

",#Go,Go,"package main
 
import (
    ""fmt""
    ""rcu""
)
 
func motzkin(n int) []int {
    m := make([]int, n+1)
    m[0] = 1
    m[1] = 1
    for i := 2; i <= n; i++ {
        m[i] = (m[i-1]*(2*i+1) + m[i-2]*(3*i-3)) / (i + 2)
    }
    return m
}
 
func main() {
    fmt.Println("" n          M[n]             Prime?"")
    fmt.Println(""-----------------------------------"")
    m := motzkin(41)
    for i, e := range m {
        fmt.Printf(""%2d  %23s  %t\n"", i, rcu.Commatize(e), rcu.IsPrime(e))
    }
}",493,25
33462,http://rosettacode.org/wiki/Multiple_regression,Multiple regression,"Task

Given a set of data vectors in the following format:

   
  
    
      
        y
        =
        {
        
          y
          
            1
          
        
        ,
        
          y
          
            2
          
        
        ,
        .
        .
        .
        ,
        
          y
          
            n
          
        
        }
        
      
    
    {\displaystyle y=\{y_{1},y_{2},...,y_{n}\}\,}
  


   
  
    
      
        
          X
          
            i
          
        
        =
        {
        
          x
          
            i
            1
          
        
        ,
        
          x
          
            i
            2
          
        
        ,
        .
        .
        .
        ,
        
          x
          
            i
            n
          
        
        }
        ,
        i
        ∈
        1..
        k
        
      
    
    {\displaystyle X_{i}=\{x_{i1},x_{i2},...,x_{in}\},i\in 1..k\,}
  


Compute the vector 



β
=
{

β

1


,

β

2


,
.
.
.
,

β

k


}


{\displaystyle \beta =\{\beta _{1},\beta _{2},...,\beta _{k}\}}

 using ordinary least squares regression using the following equation:

   
  
    
      
        
          y
          
            j
          
        
        =
        
          Σ
          
            i
          
        
        
          β
          
            i
          
        
        ⋅
        
          x
          
            i
            j
          
        
        ,
        j
        ∈
        1..
        n
      
    
    {\displaystyle y_{j}=\Sigma _{i}\beta _{i}\cdot x_{ij},j\in 1..n}
  


You can assume  y  is given to you as a vector (a one-dimensional array), and  X  is given to you as a two-dimensional array (i.e. matrix).



",#Go,Go,"package main
 
import (
    ""fmt""
 
    ""github.com/gonum/matrix/mat64""
)
 
func givens() (x, y *mat64.Dense) {
    height := []float64{1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63,
        1.65, 1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83}
    weight := []float64{52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93,
        61.29, 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46}
    degree := 2
    x = Vandermonde(height, degree)
    y = mat64.NewDense(len(weight), 1, weight)
    return
}
 
func Vandermonde(a []float64, degree int) *mat64.Dense {
    x := mat64.NewDense(len(a), degree+1, nil)
    for i := range a {
        for j, p := 0, 1.; j <= degree; j, p = j+1, p*a[i] {
            x.Set(i, j, p)
        }
    }
    return x
}
 
func main() {
    x, y := givens()
    fmt.Printf(""%.4f\n"", mat64.Formatted(mat64.QR(x).Solve(y)))
}",833,33
33521,http://rosettacode.org/wiki/Mutual_recursion,Mutual recursion,"Two functions are said to be mutually recursive if the first calls the second,
and in turn the second calls the first.

Write two mutually recursive functions that compute members of the Hofstadter Female and Male sequences defined as:










F
(
0
)



=
1
 
;
 
M
(
0
)
=
0




F
(
n
)



=
n
−
M
(
F
(
n
−
1
)
)
,

n
>
0




M
(
n
)



=
n
−
F
(
M
(
n
−
1
)
)
,

n
>
0.






{\displaystyle {\begin{aligned}F(0)&=1\ ;\ M(0)=0\\F(n)&=n-M(F(n-1)),\quad n>0\\M(n)&=n-F(M(n-1)),\quad n>0.\end{aligned}}}





(If a language does not allow for a solution using mutually recursive functions
then state this rather than give a solution by other means).



",#Go,Go,"package main
import ""fmt""
 
func F(n int) int {
  if n == 0 { return 1 }
  return n - M(F(n-1))
}
 
func M(n int) int {
  if n == 0 { return 0 }
  return n - F(M(n-1))
}
 
func main() {
  for i := 0; i < 20; i++ {
    fmt.Printf(""%2d "", F(i))
  }
  fmt.Println()
  for i := 0; i < 20; i++ {
    fmt.Printf(""%2d "", M(i))
  }
  fmt.Println()
}",341,23
33556,http://rosettacode.org/wiki/Monads/Writer_monad,Monads/Writer monad,"The Writer monad is a programming design pattern which makes it possible to compose functions which return their result values paired with a log string. The final result of a composed function yields both a value, and a concatenation of the logs from each component function application.

Demonstrate in your programming language the following:

 Construct a Writer monad by writing the 'bind' function and the 'unit' (sometimes known as 'return') function for that monad (or just use what the language already provides)
 Write three simple functions: root, addOne, and half
 Derive Writer monad versions of each of these functions
 Apply a composition of the Writer versions of root, addOne, and half to the integer 5, deriving both a value for the Golden Ratio φ, and a concatenated log of the function applications (starting with the initial value, and followed by the application of root, etc.)",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
type mwriter struct {
    value float64
    log   string
}
 
func (m mwriter) bind(f func(v float64) mwriter) mwriter {
    n := f(m.value)
    n.log = m.log + n.log
    return n
}
 
func unit(v float64, s string) mwriter {
    return mwriter{v, fmt.Sprintf(""  %-17s: %g\n"", s, v)}
}
 
func root(v float64) mwriter {
    return unit(math.Sqrt(v), ""Took square root"")
}
 
func addOne(v float64) mwriter {
    return unit(v+1, ""Added one"")
}
 
func half(v float64) mwriter {
    return unit(v/2, ""Divided by two"")
}
 
func main() {
    mw1 := unit(5, ""Initial value"")
    mw2 := mw1.bind(root).bind(addOne).bind(half)
    fmt.Println(""The Golden Ratio is"", mw2.value)
    fmt.Println(""\nThis was derived as follows:-"")
    fmt.Println(mw2.log)
}",792,41
33564,http://rosettacode.org/wiki/Mouse_position,Mouse position,"Task

Get the current location of the mouse cursor relative to the active window.

Please specify if the window may be externally created.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""github.com/go-vgo/robotgo""
)
 
func isInside(x, y, w, h, mx, my int) bool {
    rx := x + w - 1
    ry := y + h - 1
    return mx >= x && mx <= rx && my >= y && my <= ry
}
 
func main() {
    name := ""gedit"" // say
    fpid, err := robotgo.FindIds(name)
    if err == nil && len(fpid) > 0 {
        pid := fpid[0]
        robotgo.ActivePID(pid) // make gedit active window
        x, y, w, h := robotgo.GetBounds(pid)
        fmt.Printf(""The active window's top left corner is at (%d, %d)\n"", x, y)
        fmt.Printf(""Its width is %d and its height is %d\n"", w, h)
        mx, my := robotgo.GetMousePos()
        fmt.Printf(""The screen location of the mouse cursor is (%d, %d)\n"", mx, my)
        if !isInside(x, y, w, h, mx, my) {
            fmt.Println(""The mouse cursor is outside the active window"")
        } else {
            wx := mx - x
            wy := my - y
            fmt.Printf(""The window location of the mouse cursor is (%d, %d)\n"", wx, wy)
        }
    } else {
        fmt.Println(""Problem when finding PID(s) of"", name)
    }
}",1090,35
33578,http://rosettacode.org/wiki/Move-to-front_algorithm,Move-to-front algorithm,"Given a symbol table of a zero-indexed array of all possible input symbols
this algorithm reversibly transforms a sequence
of input symbols into an array of output numbers (indices).

The transform in many cases acts to give frequently repeated input symbols
lower indices which is  useful in some compression algorithms.



Encoding algorithm

    for each symbol of the input sequence:
        output the index of the symbol in the symbol table
        move that symbol to the front of the symbol table



Decoding algorithm

    # Using the same starting symbol table
    for each index of the input sequence:
        output the symbol at that index of the symbol table
        move that symbol to the front of the symbol table



Example

Encoding the string of character symbols 'broood' using a symbol table of the lowercase characters   a-to-z



 Input

 Output

 SymbolTable


 broood

 1

 'abcdefghijklmnopqrstuvwxyz'


 broood

 1 17

 'bacdefghijklmnopqrstuvwxyz'


 broood

 1 17 15

 'rbacdefghijklmnopqstuvwxyz'


 broood

 1 17 15 0

 'orbacdefghijklmnpqstuvwxyz'


 broood

 1 17 15 0 0

 'orbacdefghijklmnpqstuvwxyz'


 broood

 1 17 15 0 0 5

 'orbacdefghijklmnpqstuvwxyz'



Decoding the indices back to the original symbol order:



 Input

 Output

 SymbolTable


 1 17 15 0 0 5

 b

 'abcdefghijklmnopqrstuvwxyz'


 1 17 15 0 0 5

 br

 'bacdefghijklmnopqrstuvwxyz'


 1 17 15 0 0 5

 bro

 'rbacdefghijklmnopqstuvwxyz'


 1 17 15 0 0 5

 broo

 'orbacdefghijklmnpqstuvwxyz'


 1 17 15 0 0 5

 brooo

 'orbacdefghijklmnpqstuvwxyz'


 1 17 15 0 0 5

 broood

 'orbacdefghijklmnpqstuvwxyz'



Task

   Encode and decode the following three strings of characters using the symbol table of the lowercase characters   a-to-z   as above. 
   Show the strings and their encoding here.
   Add a check to ensure that the decoded string is the same as the original.


The strings are:

   broood          
   bananaaa     
   hiphophiphop  


(Note the misspellings in the above strings.)
",#Go,Go,"package main
 
import (
	""bytes""
	""fmt""
)
 
type symbolTable string
 
func (symbols symbolTable) encode(s string) []byte {
	seq := make([]byte, len(s))
	pad := []byte(symbols)
	for i, c := range []byte(s) {
		x := bytes.IndexByte(pad, c)
		seq[i] = byte(x)
		copy(pad[1:], pad[:x])
		pad[0] = c
	}
	return seq
}
 
func (symbols symbolTable) decode(seq []byte) string {
	chars := make([]byte, len(seq))
	pad := []byte(symbols)
	for i, x := range seq {
		c := pad[x]
		chars[i] = c
		copy(pad[1:], pad[:x])
		pad[0] = c
	}
	return string(chars)
}
 
func main() {
	m := symbolTable(""abcdefghijklmnopqrstuvwxyz"")
	for _, s := range []string{""broood"", ""bananaaa"", ""hiphophiphop""} {
		enc := m.encode(s)
		dec := m.decode(enc)
		fmt.Println(s, enc, dec)
		if dec != s {
			panic(""Whoops!"")
		}
	}
}",792,44
33611,http://rosettacode.org/wiki/Monads/List_monad,Monads/List monad,"A Monad is a combination of a data-type with two helper functions written for that type.

The data-type can be of any kind which can contain values of some other type – common examples are lists, records, sum-types, even functions or IO streams. The two special functions, mathematically known as eta and mu, but usually given more expressive names like 'pure', 'return', or 'yield' and 'bind', abstract away some boilerplate needed for pipe-lining or enchaining sequences of computations on values held in the containing data-type.

The bind operator in the List monad enchains computations which return their values wrapped in lists. One application of this is the representation of indeterminacy, with returned lists representing a set of possible values. An empty list can be returned to express incomputability, or computational failure.

A sequence of two list monad computations (enchained with the use of bind) can be understood as the computation of a cartesian product.

The natural implementation of bind for the List monad is a composition of concat and map, which, used with a function which returns its value as a (possibly empty) list, provides for filtering in addition to transformation or mapping.



Demonstrate in your programming language the following:

Construct a List Monad by writing the 'bind' function and the 'pure' (sometimes known as 'return') function for that Monad (or just use what the language already has implemented)
Make two functions, each which take a number and return a monadic number, e.g. Int -> List Int and Int -> List String
Compose the two functions with bind",#Go,Go,"package main
 
import ""fmt""
 
type mlist struct{ value []int }
 
func (m mlist) bind(f func(lst []int) mlist) mlist {
    return f(m.value)
}
 
func unit(lst []int) mlist {
    return mlist{lst}
}
 
func increment(lst []int) mlist {
    lst2 := make([]int, len(lst))
    for i, v := range lst {
        lst2[i] = v + 1
    }
    return unit(lst2)
}
 
func double(lst []int) mlist {
    lst2 := make([]int, len(lst))
    for i, v := range lst {
        lst2[i] = 2 * v
    }
    return unit(lst2)
}
 
func main() {
    ml1 := unit([]int{3, 4, 5})
    ml2 := ml1.bind(increment).bind(double)
    fmt.Printf(""%v -> %v\n"", ml1.value, ml2.value)
}",642,35
33680,http://rosettacode.org/wiki/N-queens_problem,N-queens problem,"

Solve the eight queens puzzle.



You can extend the problem to solve the puzzle with a board of size   NxN.

For the number of solutions for small values of   N,   see   OEIS: A000170.



Related tasks

 A* search algorithm
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Knight's tour
 Peaceful chess queen armies
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle

",#Go,Go,"// A fairly literal translation of the example program on the referenced
// WP page.  Well, it happened to be the example program the day I completed
// the task.  It seems from the WP history that there has been some churn
// in the posted example program.  The example program of the day was in
// Pascal and was credited to Niklaus Wirth, from his ""Algorithms +
// Data Structures = Programs.""
package main
 
import ""fmt""
 
var (
    i int
    q bool
    a [9]bool
    b [17]bool
    c [15]bool // offset by 7 relative to the Pascal version
    x [9]int
)
 
func try(i int) {
    for j := 1; ; j++ {
        q = false
        if a[j] && b[i+j] && c[i-j+7] {
            x[i] = j
            a[j] = false
            b[i+j] = false
            c[i-j+7] = false
            if i < 8 {
                try(i + 1)
                if !q {
                    a[j] = true
                    b[i+j] = true
                    c[i-j+7] = true
                }
            } else {
                q = true
            }
        }
        if q || j == 8 {
            break
        }
    }
}
 
func main() {
    for i := 1; i <= 8; i++ {
        a[i] = true
    }
    for i := 2; i <= 16; i++ {
        b[i] = true
    }
    for i := 0; i <= 14; i++ {
        c[i] = true
    }
    try(1)
    if q {
        for i := 1; i <= 8; i++ {
            fmt.Println(i, x[i])
        }
    }
}",1380,61
33735,http://rosettacode.org/wiki/Monads/Maybe_monad,Monads/Maybe monad,"Demonstrate in your programming language the following:

Construct a Maybe Monad by writing the 'bind' function and the 'unit' (sometimes known as 'return') function for that Monad (or just use what the language already has implemented)
Make two functions, each which take a number and return a monadic number, e.g. Int -> Maybe Int and Int -> Maybe String
Compose the two functions with bind


A Monad is a single type which encapsulates several other types, eliminating boilerplate code. In practice it acts like a dynamically typed computational sequence, though in many cases the type issues can be resolved at compile time.

A Maybe Monad is a monad which specifically encapsulates the type of an undefined value.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
type maybe struct{ value *int }
 
func (m maybe) bind(f func(p *int) maybe) maybe {
    return f(m.value)
}
 
func unit(p *int) maybe {
    return maybe{p}
}
 
func decrement(p *int) maybe {
    if p == nil {
        return unit(nil)
    } else {
        q := *p - 1
        return unit(&q)
    }
}
 
func triple(p *int) maybe {
    if p == nil {
        return unit(nil)
    } else {
        q := (*p) * 3
        return unit(&q)
    }
}
 
func main() {
    i, j, k := 3, 4, 5
    for _, p := range []*int{&i, &j, nil, &k} {
        m1 := unit(p)
        m2 := m1.bind(decrement).bind(triple)
        var s1, s2 string = ""none"", ""none""
        if m1.value != nil {
            s1 = strconv.Itoa(*m1.value)
        }
        if m2.value != nil {
            s2 = strconv.Itoa(*m2.value)
        }
        fmt.Printf(""%4s -> %s\n"", s1, s2)
    }
}",898,50
33799,http://rosettacode.org/wiki/Multifactorial,Multifactorial,"The factorial of a number, written as 



n
!


{\displaystyle n!}

, is defined as 



n
!
=
n
(
n
−
1
)
(
n
−
2
)
.
.
.
(
2
)
(
1
)


{\displaystyle n!=n(n-1)(n-2)...(2)(1)}

.

Multifactorials generalize factorials as follows:

 



n
!
=
n
(
n
−
1
)
(
n
−
2
)
.
.
.
(
2
)
(
1
)


{\displaystyle n!=n(n-1)(n-2)...(2)(1)}


 



n
!
!
=
n
(
n
−
2
)
(
n
−
4
)
.
.
.


{\displaystyle n!!=n(n-2)(n-4)...}


 



n
!
!
!
=
n
(
n
−
3
)
(
n
−
6
)
.
.
.


{\displaystyle n!!!=n(n-3)(n-6)...}


 



n
!
!
!
!
=
n
(
n
−
4
)
(
n
−
8
)
.
.
.


{\displaystyle n!!!!=n(n-4)(n-8)...}


 



n
!
!
!
!
!
=
n
(
n
−
5
)
(
n
−
10
)
.
.
.


{\displaystyle n!!!!!=n(n-5)(n-10)...}


In all cases, the terms in the products are positive integers.

If we define the degree of the multifactorial as the difference in successive terms that are multiplied together for a multifactorial (the number of exclamation marks), then the task is twofold:

 Write a function that given n and the degree, calculates the multifactorial.
 Use the function to generate and display here a table of the first ten members (1 to 10) of the first five degrees of multifactorial.

Note: The wikipedia entry on multifactorials gives a different formula. This task uses the Wolfram mathworld definition.
",#Go,Go,"package main
 
import ""fmt""
 
func multiFactorial(n, k int) int {
    r := 1
    for ; n > 1; n -= k {
        r *= n
    }
    return r
}
 
func main() {
    for k := 1; k <= 5; k++ {
        fmt.Print(""degree "", k, "":"")
        for n := 1; n <= 10; n++ {
            fmt.Print("" "", multiFactorial(n, k))
        }
        fmt.Println()
    }
}",345,21
34025,http://rosettacode.org/wiki/Modular_inverse,Modular inverse,"From Wikipedia:

In modular arithmetic,   the modular multiplicative inverse of an integer    a    modulo    m    is an integer    x    such that





a

x
≡
1


(
mod

m
)

.


{\displaystyle a\,x\equiv 1{\pmod {m}}.}


Or in other words, such that:





∃
k
∈

Z

,

a

x
=
1
+
k

m


{\displaystyle \exists k\in \mathbb {Z} ,\qquad a\,x=1+k\,m}


It can be shown that such an inverse exists   if and only if    a    and    m    are coprime,   but we will ignore this for this task.



Task

Either by implementing the algorithm, by using a dedicated library or by using a built-in function in
your language,   compute the modular inverse of   42 modulo 2017.



",#Go,Go,"package main
 
import (
	""fmt""
	""math/big""
)
 
func main() {
	a := big.NewInt(42)
	m := big.NewInt(2017)
	k := new(big.Int).ModInverse(a, m)
	fmt.Println(k)
}",158,13
34033,http://rosettacode.org/wiki/Monte_Carlo_methods,Monte Carlo methods,"A Monte Carlo Simulation is a way of approximating the value of a function
where calculating the actual value is difficult or impossible. 

It uses random sampling to define constraints on the value
and then makes a sort of ""best guess.""

A simple Monte Carlo Simulation can be used to calculate the value for 



π


{\displaystyle \pi }

.

If you had a circle and a square where the length of a side of the square
was the same as the diameter of the circle, the ratio of the area of the circle
to the area of the square would be 



π

/

4


{\displaystyle \pi /4}

.

So, if you put this circle inside the square and select many random points
inside the square, the number of points inside the circle
divided by the number of points inside the square and the circle
would be approximately 



π

/

4


{\displaystyle \pi /4}

.



Task

Write a function to run a simulation like this, with a variable number of random points to select.

Also, show the results of a few different sample sizes.

For software where the number 



π


{\displaystyle \pi }

 is not built-in,
we give 



π


{\displaystyle \pi }

 as a number of digits:

            3.141592653589793238462643383280


",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/rand""
    ""time""
)
 
func getPi(numThrows int) float64 {
    inCircle := 0
    for i := 0; i < numThrows; i++ {
        //a square with a side of length 2 centered at 0 has 
        //x and y range of -1 to 1
        randX := rand.Float64()*2 - 1 //range -1 to 1
        randY := rand.Float64()*2 - 1 //range -1 to 1
        //distance from (0,0) = sqrt((x-0)^2+(y-0)^2)
        dist := math.Hypot(randX, randY)
        if dist < 1 { //circle with diameter of 2 has radius of 1
            inCircle++
        }
    }
    return 4 * float64(inCircle) / float64(numThrows)
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    fmt.Println(getPi(10000))
    fmt.Println(getPi(100000))
    fmt.Println(getPi(1000000))
    fmt.Println(getPi(10000000))
    fmt.Println(getPi(100000000))
}",842,33
34118,http://rosettacode.org/wiki/Morse_code,Morse code,"Morse code
It has been in use for more than 175 years — longer than any other electronic encoding system.



Task

Send a string as audible Morse code to an audio device   (e.g., the PC speaker).



As the standard Morse code does not contain all possible characters,
you may either ignore unknown characters in the file,
or indicate them somehow   (e.g. with a different pitch).



",#Go,Go,"// Command morse translates an input string into morse code,
// showing the output on the console, and playing it as sound.
// Only works on ubuntu.
package main
 
import (
	""flag""
	""fmt""
	""log""
	""regexp""
	""strings""
	""syscall""
	""time""
	""unicode""
)
 
// A key represents an action on the morse key.
// It's either on or off, for the given duration.
type key struct {
	duration int
	on       bool
	sym      string // for debug output
}
 
var (
	runeToKeys   = map[rune][]key{}
	interCharGap = []key{{1, false, """"}}
	punctGap     = []key{{7, false, "" / ""}}
	charGap      = []key{{3, false, "" ""}}
	wordGap      = []key{{7, false, "" / ""}}
)
 
const rawMorse = `
A:.-    J:.---  S:...    1:.----  .:.-.-.-  ::---...
B:-...  K:-.-   T:-      2:..---  ,:--..--  ;:-.-.-.
C:-.-.  L:.-..  U:..-    3:...--  ?:..--..  =:-...-
D:-..   M:--    V:...-   4:....-  ':.----.  +:.-.-.
E:.     N:-.    W:.--    5:.....  !:-.-.--  -:-....-
F:..-.  O:---   X:-..-   6:-....  /:-..-.   _:..--.-
G:--.   P:.--.  Y:-.--   7:--...  (:-.--.   "":.-..-.
H:....  Q:--.-  Z:--..   8:---..  ):-.--.-  $:...-..-
I:..    R:.-.   0:-----  9:----.  &:.-...   @:.--.-.
`
 
func init() {
	// Convert the rawMorse table into a map of morse key actions.
	r := regexp.MustCompile(""([^ ]):([.-]+)"")
	for _, m := range r.FindAllStringSubmatch(rawMorse, -1) {
		c := m[1][0]
		keys := []key{}
		for i, dd := range m[2] {
			if i > 0 {
				keys = append(keys, interCharGap...)
			}
			if dd == '.' {
				keys = append(keys, key{1, true, "".""})
			} else if dd == '-' {
				keys = append(keys, key{3, true, ""-""})
			} else {
				log.Fatalf(""found %c in morse for %c"", dd, c)
			}
			runeToKeys[rune(c)] = keys
			runeToKeys[unicode.ToLower(rune(c))] = keys
		}
	}
}
 
// MorseKeys translates an input string into a series of keys.
func MorseKeys(in string) ([]key, error) {
	afterWord := false
	afterChar := false
	result := []key{}
	for _, c := range in {
		if unicode.IsSpace(c) {
			afterWord = true
			continue
		}
		morse, ok := runeToKeys[c]
		if !ok {
			return nil, fmt.Errorf(""can't translate %c to morse"", c)
		}
		if unicode.IsPunct(c) && afterChar {
			result = append(result, punctGap...)
		} else if afterWord {
			result = append(result, wordGap...)
		} else if afterChar {
			result = append(result, charGap...)
		}
		result = append(result, morse...)
		afterChar = true
		afterWord = false
	}
	return result, nil
}
 
func main() {
	var ditDuration time.Duration
	flag.DurationVar(&ditDuration, ""d"", 40*time.Millisecond, ""length of dit"")
	flag.Parse()
	in := ""hello world.""
	if len(flag.Args()) > 1 {
		in = strings.Join(flag.Args(), "" "")
	}
	keys, err := MorseKeys(in)
	if err != nil {
		log.Fatalf(""failed to translate: %s"", err)
	}
	for _, k := range keys {
		if k.on {
			if err := note(true); err != nil {
				log.Fatalf(""failed to play note: %s"", err)
			}
		}
		fmt.Print(k.sym)
		time.Sleep(ditDuration * time.Duration(k.duration))
		if k.on {
			if err := note(false); err != nil {
				log.Fatalf(""failed to stop note: %s"", err)
			}
		}
	}
	fmt.Println()
}
 
// Implement sound on ubuntu. Needs permission to access /dev/console.
 
var consoleFD uintptr
 
func init() {
	fd, err := syscall.Open(""/dev/console"", syscall.O_WRONLY, 0)
	if err != nil {
		log.Fatalf(""failed to get console device: %s"", err)
	}
	consoleFD = uintptr(fd)
}
 
const KIOCSOUND = 0x4B2F
const clockTickRate = 1193180
const freqHz = 600
 
// note either starts or stops a note.
func note(on bool) error {
	arg := uintptr(0)
	if on {
		arg = clockTickRate / freqHz
	}
	_, _, errno := syscall.Syscall(syscall.SYS_IOCTL, consoleFD, KIOCSOUND, arg)
	if errno != 0 {
		return errno
	}
	return nil
 
}
 ",3649,154
34158,http://rosettacode.org/wiki/Monty_Hall_problem,Monty Hall problem,"
Suppose you're on a game show and you're given the choice of three doors.

Behind one door is a car; behind the others, goats.

The car and the goats were placed randomly behind the doors before the show.



Rules of the game

After you have chosen a door, the door remains closed for the time being.

The game show host, Monty Hall, who knows what is behind the doors, now has to open one of the two remaining doors, and the door he opens must have a goat behind it.

If both remaining doors have goats behind them, he chooses one randomly.

After Monty Hall opens a door with a goat, he will ask you to decide whether you want to stay with your first choice or to switch to the last remaining door.

Imagine that you chose Door 1 and the host opens Door 3, which has a goat.

He then asks you ""Do you want to switch to Door Number 2?""



The question

Is it to your advantage to change your choice?



Note

The player may initially choose any of the three doors (not just Door 1), that the host opens a different door revealing a goat (not necessarily Door 3), and that he gives the player a second choice between the two remaining unopened doors.



Task

Run random simulations of the Monty Hall game. Show the effects of a strategy of the contestant always keeping his first guess so it can be contrasted with the strategy of the contestant always switching his guess.

Simulate at least a thousand games using three doors for each strategy and show the results in such a way as to make it easy to compare the effects of each strategy.



References

 Stefan Krauss, X. T. Wang, ""The psychology of the Monty Hall problem: Discovering psychological mechanisms for solving a tenacious brain teaser."", Journal of Experimental Psychology: General, Vol 132(1), Mar 2003, 3-22 DOI: 10.1037/0096-3445.132.1.3
 A YouTube video:   Monty Hall Problem - Numberphile. 

",#Go,Go,"package main
 
import (
	""fmt""
	""math/rand""
	""time""
)
 
func main() {
	games := 100000
	r := rand.New(rand.NewSource(time.Now().UnixNano()))
 
	var switcherWins, keeperWins, shown int
	for i := 0; i < games; i++ {
		doors := []int{0, 0, 0}
		doors[r.Intn(3)] = 1 // Set which one has the car
		choice := r.Intn(3) // Choose a door
		for shown = r.Intn(3); shown == choice || doors[shown] == 1; shown = r.Intn(3) {}
		switcherWins += doors[3 - choice - shown]
		keeperWins += doors[choice]
	}
	floatGames := float32(games)
	fmt.Printf(""Switcher Wins: %d (%3.2f%%)\n"",
		switcherWins, (float32(switcherWins) / floatGames * 100))
	fmt.Printf(""Keeper Wins: %d (%3.2f%%)"",
		keeperWins, (float32(keeperWins) / floatGames * 100))
}",725,27
34351,http://rosettacode.org/wiki/Multiplication_tables,Multiplication tables,"Task

Produce a formatted   12×12   multiplication table of the kind memorized by rote when in primary (or elementary) school.



Only print the top half triangle of products.



",#Go,Go," 
package main
 
import (
    ""fmt""
)
 
func main() {
    fmt.Print("" x |"")
    for i := 1; i <= 12; i++ {
        fmt.Printf(""%4d"", i)
    }
    fmt.Print(""\n---+"")
    for i := 1; i <= 12; i++ {
        fmt.Print(""----"")
    }
    for j := 1; j <= 12; j++ {
        fmt.Printf(""\n%2d |"", j)
        for i := 1; i <= 12; i++ {
            if i >= j {
                fmt.Printf(""%4d"", i*j)
            } else {
                fmt.Print(""    "")
            }
        }
    }
    fmt.Println("""")
}
 ",499,29
34473,http://rosettacode.org/wiki/Minkowski_question-mark_function,Minkowski question-mark function,"The Minkowski question-mark function converts the continued fraction representation [a0; a1, a2, a3, ...] of a number into a binary decimal representation in which the integer part a0 is unchanged and the a1, a2, ... become alternating runs of binary zeroes and ones of those lengths. The decimal point takes the place of the first zero.

Thus, ?(31/7) = 71/16 because 31/7 has the continued fraction representation [4;2,3] giving the binary expansion 4 + 0.01112.

Among its interesting properties is that it maps roots of quadratic equations, which have repeating continued fractions, to rational numbers, which have repeating binary digits.

The question-mark function is continuous and monotonically increasing, so it has an inverse.

 Produce a function for ?(x).   Be careful: rational numbers have two possible continued fraction representations:
   [a0;a1,... an−1,an]     and 
   [a0;a1,... an−1,an−1,1] 
 Choose one of the above that will give a binary expansion ending with a   1.
 Produce the inverse function ?-1(x)
 Verify that ?(φ) = 5/3, where φ is the Greek golden ratio.
 Verify that ?-1(-5/9) = (√13 - 7)/6
 Verify that the two functions are inverses of each other by showing that ?-1(?(x))=x and ?(?-1(y))=y for x, y of your choice 


Don't worry about precision error in the last few digits.



See also

 Wikipedia entry: Minkowski's question-mark function

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
const MAXITER = 151
 
func minkowski(x float64) float64 {
    if x > 1 || x < 0 {
        return math.Floor(x) + minkowski(x-math.Floor(x))
    }
    p := uint64(x)
    q := uint64(1)
    r := p + 1
    s := uint64(1)
    d := 1.0
    y := float64(p)
    for {
        d = d / 2
        if y+d == y {
            break
        }
        m := p + r
        if m < 0 || p < 0 {
            break
        }
        n := q + s
        if n < 0 {
            break
        }
        if x < float64(m)/float64(n) {
            r = m
            s = n
        } else {
            y = y + d
            p = m
            q = n
        }
    }
    return y + d
}
 
func minkowskiInv(x float64) float64 {
    if x > 1 || x < 0 {
        return math.Floor(x) + minkowskiInv(x-math.Floor(x))
    }
    if x == 1 || x == 0 {
        return x
    }
    contFrac := []uint32{0}
    curr := uint32(0)
    count := uint32(1)
    i := 0
    for {
        x *= 2
        if curr == 0 {
            if x < 1 {
                count++
            } else {
                i++
                t := contFrac
                contFrac = make([]uint32, i+1)
                copy(contFrac, t)
                contFrac[i-1] = count
                count = 1
                curr = 1
                x--
            }
        } else {
            if x > 1 {
                count++
                x--
            } else {
                i++
                t := contFrac
                contFrac = make([]uint32, i+1)
                copy(contFrac, t)
                contFrac[i-1] = count
                count = 1
                curr = 0
            }
        }
        if x == math.Floor(x) {
            contFrac[i] = count
            break
        }
        if i == MAXITER {
            break
        }
    }
    ret := 1.0 / float64(contFrac[i])
    for j := i - 1; j >= 0; j-- {
        ret = float64(contFrac[j]) + 1.0/ret
    }
    return 1.0 / ret
}
 
func main() {
    fmt.Printf(""%19.16f %19.16f\n"", minkowski(0.5*(1+math.Sqrt(5))), 5.0/3.0)
    fmt.Printf(""%19.16f %19.16f\n"", minkowskiInv(-5.0/9.0), (math.Sqrt(13)-7)/6)
    fmt.Printf(""%19.16f %19.16f\n"", minkowski(minkowskiInv(0.718281828)),
        minkowskiInv(minkowski(0.1213141516171819)))
}",2289,105
34488,http://rosettacode.org/wiki/Modified_random_distribution,Modified random distribution,"Given a random number generator, (rng), generating numbers in the range 0.0 .. 1.0 called rgen, for example; and a function modifier(x)
taking an number in the same range and generating the probability that the input should be generated, in the same range 0..1; then implement the following algorithm for generating random numbers to the probability given by function modifier:

while True:
    random1 = rgen()
    random2 = rgen()
    if random2 < modifier(random1):
        answer = random1
        break
    endif
endwhile
Task

 Create a modifier function that generates a 'V' shaped probability of number generation using something like, for example:
                      modifier(x)  =  2*(0.5 - x)  if x < 0.5  else 2*(x - 0.5) 

 Create a generator of random numbers with probabilities modified by the above function.
 Generate >= 10,000 random numbers subject to the probability modification.
 Output a textual histogram with from 11 to 21 bins showing the distribution of the random numbers generated.


Show your output here, on this page.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/rand""
    ""strings""
    ""time""
)
 
func rng(modifier func(x float64) float64) float64 {
    for {
        r1 := rand.Float64()
        r2 := rand.Float64()
        if r2 < modifier(r1) {
            return r1
        }
    }
}
 
func commatize(n int) string {
    s := fmt.Sprintf(""%d"", n)
    if n < 0 {
        s = s[1:]
    }
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    if n >= 0 {
        return s
    }
    return ""-"" + s
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    modifier := func(x float64) float64 {
        if x < 0.5 {
            return 2 * (0.5 - x)
        }
        return 2 * (x - 0.5)
    }
    const (
        N              = 100000
        NUM_BINS       = 20
        HIST_CHAR      = ""■""
        HIST_CHAR_SIZE = 125
    )
    bins := make([]int, NUM_BINS) // all zero by default
    binSize := 1.0 / NUM_BINS
    for i := 0; i < N; i++ {
        rn := rng(modifier)
        bn := int(math.Floor(rn / binSize))
        bins[bn]++
    }
 
    fmt.Println(""Modified random distribution with"", commatize(N), ""samples in range [0, 1):\n"")
    fmt.Println(""    Range           Number of samples within that range"")
    for i := 0; i < NUM_BINS; i++ {
        hist := strings.Repeat(HIST_CHAR, int(math.Round(float64(bins[i])/HIST_CHAR_SIZE)))
        fi := float64(i)
        fmt.Printf(""%4.2f ..< %4.2f  %s %s\n"", binSize*fi, binSize*(fi+1), hist, commatize(bins[i]))
    }
}",1516,65
34530,http://rosettacode.org/wiki/Minimal_steps_down_to_1,Minimal steps down to 1,"

Given:

 A starting, positive integer (greater than one), N.
 A selection of possible integer perfect divisors, D.
 And a selection of possible subtractors, S.
The goal is find the minimum number of steps necessary to reduce N down to one.

At any step, the number may be:

 Divided by any member of D if it is perfectly divided by D, (remainder zero).
 OR have one of S subtracted from it, if N is greater than the member of S.


There may be many ways to reduce the initial N down to 1. Your program needs to:

 Find the minimum number of steps to reach 1.
 Show one way of getting fron N to 1 in those minimum steps.


Examples

No divisors, D. a single subtractor of 1.

Obviousely N will take N-1 subtractions of 1 to reach 1
Single divisor of 2; single subtractor of 1:

N = 7 Takes 4 steps N -1=> 6, /2=> 3, -1=> 2, /2=> 1
N = 23 Takes 7 steps N -1=>22, /2=>11, -1=>10, /2=> 5, -1=> 4, /2=> 2, /2=> 1
Divisors 2 and 3; subtractor 1:

N = 11 Takes 4 steps N -1=>10, -1=> 9, /3=> 3, /3=> 1
Task

Using the possible divisors D, of 2 and 3; together with a possible subtractor S, of 1:

1. Show the number of steps and possible way of diminishing the numbers 1 to 10 down to 1.
2. Show a count of, and the numbers that: have the maximum minimal_steps_to_1, in the range 1 to 2,000.
Using the possible divisors D, of 2 and 3; together with a possible subtractor S, of 2:

3. Show the number of steps and possible way of diminishing the numbers 1 to 10 down to 1.
4. Show a count of, and the numbers that: have the maximum minimal_steps_to_1, in the range 1 to 2,000.


Optional stretch goal

2a, and 4a: As in 2 and 4 above, but for N in the range 1 to 20_000


Reference

 Learn Dynamic Programming (Memoization & Tabulation) Video of similar task.",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
const limit = 50000
 
var (
    divs, subs []int
    mins       [][]string
)
 
// Assumes the numbers are presented in order up to 'limit'.
func minsteps(n int) {
    if n == 1 {
        mins[1] = []string{}
        return
    }
    min := limit
    var p, q int
    var op byte
    for _, div := range divs {
        if n%div == 0 {
            d := n / div
            steps := len(mins[d]) + 1
            if steps < min {
                min = steps
                p, q, op = d, div, '/'
            }
        }
    }
    for _, sub := range subs {
        if d := n - sub; d >= 1 {
            steps := len(mins[d]) + 1
            if steps < min {
                min = steps
                p, q, op = d, sub, '-'
            }
        }
    }
    mins[n] = append(mins[n], fmt.Sprintf(""%c%d -> %d"", op, q, p))
    mins[n] = append(mins[n], mins[p]...)
}
 
func main() {
    for r := 0; r < 2; r++ {
        divs = []int{2, 3}
        if r == 0 {
            subs = []int{1}
        } else {
            subs = []int{2}
        }
        mins = make([][]string, limit+1)
        fmt.Printf(""With: Divisors: %v, Subtractors: %v =>\n"", divs, subs)
        fmt.Println(""  Minimum number of steps to diminish the following numbers down to 1 is:"")
        for i := 1; i <= limit; i++ {
            minsteps(i)
            if i <= 10 {
                steps := len(mins[i])
                plural := ""s""
                if steps == 1 {
                    plural = "" ""
                }
                fmt.Printf(""    %2d: %d step%s: %s\n"", i, steps, plural, strings.Join(mins[i], "", ""))
            }
        }
        for _, lim := range []int{2000, 20000, 50000} {
            max := 0
            for _, min := range mins[0 : lim+1] {
                m := len(min)
                if m > max {
                    max = m
                }
            }
            var maxs []int
            for i, min := range mins[0 : lim+1] {
                if len(min) == max {
                    maxs = append(maxs, i)
                }
            }
            nums := len(maxs)
            verb, verb2, plural := ""are"", ""have"", ""s""
            if nums == 1 {
                verb, verb2, plural = ""is"", ""has"", """"
            }
            fmt.Printf(""  There %s %d number%s in the range 1-%d "", verb, nums, plural, lim)
            fmt.Printf(""that %s maximum 'minimal steps' of %d:\n"", verb2, max)
            fmt.Println(""   "", maxs)
        }
        fmt.Println()
    }
}",2529,94
34557,http://rosettacode.org/wiki/Minimum_multiple_of_m_where_digital_sum_equals_m,Minimum multiple of m where digital sum equals m,"Generate the sequence a(n) when each element is the minimum integer multiple m such that the digit sum of n times m is equal to n.



Task
 Find the first 40 elements of the sequence.


Stretch
 Find the next 30 elements of the sequence.


See also
 OEIS:A131382 - Minimal number m such that Sum_digits(n*m)=n



",#Go,Go,"package main
 
import ""rcu""
 
func main() {
    var res []int
    for n := 1; n <= 70; n++ {
        m := 1
        for rcu.DigitSum(m*n, 10) != n {
            m++
        }
        res = append(res, m)
    }
    rcu.PrintTable(res, 7, 10, true)
}",248,15
34571,http://rosettacode.org/wiki/Modular_arithmetic,Modular arithmetic,"Modular arithmetic is a form of arithmetic (a calculation technique involving the concepts of addition and multiplication) which is done on numbers with a defined equivalence relation called congruence.

For any positive integer 



p


{\displaystyle p}

 called the congruence modulus,
two numbers 



a


{\displaystyle a}

 and 



b


{\displaystyle b}

 are said to be congruent modulo p whenever there exists an integer 



k


{\displaystyle k}

 such that:





a
=
b
+
k

p


{\displaystyle a=b+k\,p}


The corresponding set of equivalence classes forms a ring denoted 






Z


p

Z






{\displaystyle {\frac {\mathbb {Z} }{p\mathbb {Z} }}}

.

Addition and multiplication on this ring have the same algebraic structure as in usual arithmetics, so that a function such as a polynomial expression could receive a ring element as argument and give a consistent result.

The purpose of this task is to show, if your programming language allows it,
how to redefine operators so that they can be used transparently on modular integers.
You can do it either by using a dedicated library, or by implementing your own class.

You will use the following function for demonstration:





f
(
x
)
=

x

100


+
x
+
1


{\displaystyle f(x)=x^{100}+x+1}


You will use 



13


{\displaystyle 13}

 as the congruence modulus and you will compute 



f
(
10
)


{\displaystyle f(10)}

.

It is important that the function 



f


{\displaystyle f}

 is agnostic about whether or not its argument is modular; it should behave the same way with normal and modular integers.
In other words, the function is an algebraic expression that could be used with any ring, not just integers.



",#Go,Go,"package main
 
import ""fmt""
 
// Define enough of a ring to meet the needs of the task.  Addition and
// multiplication are mentioned in the task; multiplicative identity is not
// mentioned but is useful for the power function.
 
type ring interface {
    add(ringElement, ringElement) ringElement
    mul(ringElement, ringElement) ringElement
    mulIdent() ringElement
}
 
type ringElement interface{}
 
// Define a power function that works for any ring.
 
func ringPow(r ring, a ringElement, p uint) (pow ringElement) {
    for pow = r.mulIdent(); p > 0; p-- {
        pow = r.mul(pow, a)
    }
    return
}
 
// The task function f has that constant 1 in it.
// Define a special kind of ring that has this element.
 
type oneRing interface {
    ring
    one() ringElement // return ring element corresponding to '1'
}
 
// Now define the required function f.
// It works for any ring (that has a ""one."")
 
func f(r oneRing, x ringElement) ringElement {
    return r.add(r.add(ringPow(r, x, 100), x), r.one())
}
 
// With rings and the function f defined in a general way, now define
// the specific ring of integers modulo n.
 
type modRing uint // value is congruence modulus n
 
func (m modRing) add(a, b ringElement) ringElement {
    return (a.(uint) + b.(uint)) % uint(m)
}
 
func (m modRing) mul(a, b ringElement) ringElement {
    return (a.(uint) * b.(uint)) % uint(m)
}
 
func (modRing) mulIdent() ringElement { return uint(1) }
 
func (modRing) one() ringElement { return uint(1) }
 
// Demonstrate the general function f on the specific ring with the
// specific values.
 
func main() {
    fmt.Println(f(modRing(13), uint(10)))
}",1648,63
34669,http://rosettacode.org/wiki/Minimum_positive_multiple_in_base_10_using_only_0_and_1,Minimum positive multiple in base 10 using only 0 and 1,"Every positive integer has infinitely many base-10 multiples that only use the digits 0 and 1. The goal of this task is to find and display the minimum multiple that has this property.

This is simple to do, but can be challenging to do efficiently.

To avoid repeating long, unwieldy phrases, the operation ""minimum positive multiple of a positive integer n in base 10 that only uses the digits 0 and 1"" will hereafter be referred to as ""B10"".

Task

Write a routine to find the B10 of a given integer.

E.G.

      n                  B10      n  × multiplier
      1                    1    ( 1  × 1         )
      2                   10    ( 2  × 5         )
      7                 1001    ( 7  x 143       )
      9            111111111    ( 9  x 12345679  )
     10                   10    ( 10 x 1         )

and so on.

Use the routine to find and display here, on this page, the B10 value for:

   1 through 10, 95 through 105, 297, 576, 594, 891, 909, 999

Optionally find B10 for:

   1998, 2079, 2251, 2277

Stretch goal; find B10 for:

   2439, 2997, 4878

There are many opportunities for optimizations, but avoid using magic numbers as much as possible. If you do use magic numbers, explain briefly why and what they do for your implementation.



See also

 OEIS:A004290 Least positive multiple of n that when written in base 10 uses only 0's and 1's.
 How to find Minimum Positive Multiple in base 10 using only 0 and 1",#Go,Go,"package main
 
import (
    ""fmt""
    ""github.com/shabbyrobe/go-num""
    ""strings""
    ""time""
)
 
func b10(n int64) {
    if n == 1 {
        fmt.Printf(""%4d: %28s  %-24d\n"", 1, ""1"", 1)
        return
    }
    n1 := n + 1
    pow := make([]int64, n1)
    val := make([]int64, n1)
    var count, ten, x int64 = 0, 1, 1
    for ; x < n1; x++ {
        val[x] = ten
        for j := int64(0); j < n1; j++ {
            if pow[j] != 0 && pow[(j+ten)%n] == 0 && pow[j] != x {
                pow[(j+ten)%n] = x
            }
        }
        if pow[ten] == 0 {
            pow[ten] = x
        }
        ten = (10 * ten) % n
        if pow[0] != 0 {
            break
        }
    }
    x = n
    if pow[0] != 0 {
        s := """"
        for x != 0 {
            p := pow[x%n]
            if count > p {
                s += strings.Repeat(""0"", int(count-p))
            }
            count = p - 1
            s += ""1""
            x = (n + x - val[p]) % n
        }
        if count > 0 {
            s += strings.Repeat(""0"", int(count))
        }
        mpm := num.MustI128FromString(s)
        mul := mpm.Quo64(n)
        fmt.Printf(""%4d: %28s  %-24d\n"", n, s, mul)
    } else {
        fmt.Println(""Can't do it!"")
    }
}
 
func main() {
    start := time.Now()
    tests := [][]int64{{1, 10}, {95, 105}, {297}, {576}, {594}, {891}, {909}, {999},
        {1998}, {2079}, {2251}, {2277}, {2439}, {2997}, {4878}}
    fmt.Println(""   n                           B10  multiplier"")
    fmt.Println(""----------------------------------------------"")
    for _, test := range tests {
        from := test[0]
        to := from
        if len(test) == 2 {
            to = test[1]
        }
        for n := from; n <= to; n++ {
            b10(n)
        }
    }
    fmt.Printf(""\nTook %s\n"", time.Since(start))
}",1808,74
34685,http://rosettacode.org/wiki/Modular_exponentiation,Modular exponentiation,"Find the last   40   decimal digits of   




a

b




{\displaystyle a^{b}}

,   where

   



a
=
2988348162058574136915891421498819466320163312926952423791023078876139


{\displaystyle a=2988348162058574136915891421498819466320163312926952423791023078876139}


   



b
=
2351399303373464486466122544523690094744975233415544072992656881240319


{\displaystyle b=2351399303373464486466122544523690094744975233415544072992656881240319}




A computer is too slow to find the entire value of   




a

b




{\displaystyle a^{b}}

.

Instead, the program must use a fast algorithm for modular exponentiation:   




a

b



mod


m


{\displaystyle a^{b}\mod m}

.

The algorithm must work for any integers   



a
,
b
,
m


{\displaystyle a,b,m}

,     where   



b
≥
0


{\displaystyle b\geq 0}

   and   



m
>
0


{\displaystyle m>0}

.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    a, _ := new(big.Int).SetString(
        ""2988348162058574136915891421498819466320163312926952423791023078876139"", 10)
    b, _ := new(big.Int).SetString(
        ""2351399303373464486466122544523690094744975233415544072992656881240319"", 10)
    m := big.NewInt(10)
    r := big.NewInt(40)
    m.Exp(m, r, nil)
 
    r.Exp(a, b, m)
    fmt.Println(r)
}",421,19
34725,http://rosettacode.org/wiki/Mind_boggling_card_trick,Mind boggling card trick,"Mind boggling card trick

You are encouraged to solve this task according to the task description, using any language you may know.
Matt Parker of the ""Stand Up Maths channel"" has a   YouTube video   of a card trick that creates a semblance of order from chaos.

The task is to simulate the trick in a way that mimics the steps shown in the video.

 1. Cards.
 Create a common deck of cards of 52 cards   (which are half red, half black).
 Give the pack a good shuffle.
 2. Deal from the shuffled deck, you'll be creating three piles.
 Assemble the cards face down.
 Turn up the   top card   and hold it in your hand.
 if the card is   black,   then add the   next   card (unseen) to the ""black"" pile. 
 If the card is     red,    then add the   next   card (unseen) to the   ""red""  pile.
 Add the   top card   that you're holding to the discard pile.   (You might optionally show these discarded cards to get an idea of the randomness).
 Repeat the above for the rest of the shuffled deck.
 3. Choose a random number   (call it X)   that will be used to swap cards from the ""red"" and ""black"" piles.
 Randomly choose   X   cards from the   ""red""  pile (unseen), let's call this the   ""red""  bunch. 
 Randomly choose   X   cards from the ""black"" pile (unseen), let's call this the ""black"" bunch.
 Put the     ""red""    bunch into the   ""black"" pile.
 Put the   ""black""   bunch into the     ""red""  pile.
 (The above two steps complete the swap of   X   cards of the ""red"" and ""black"" piles. 
 (Without knowing what those cards are --- they could be red or black, nobody knows).
 4. Order from randomness?
 Verify (or not) the mathematician's assertion that: 
     The number of black cards in the ""black"" pile equals the number of red cards in the ""red"" pile. 



(Optionally, run this simulation a number of times, gathering more evidence of the truthfulness of the assertion.)

Show output on this page.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
func main() {
    // Create pack, half red, half black and shuffle it.
    var pack [52]byte
    for i := 0; i < 26; i++ {
        pack[i] = 'R'
        pack[26+i] = 'B'
    }
    rand.Seed(time.Now().UnixNano())
    rand.Shuffle(52, func(i, j int) {
        pack[i], pack[j] = pack[j], pack[i]
    })
 
    // Deal from pack into 3 stacks.
    var red, black, discard []byte
    for i := 0; i < 51; i += 2 {
        switch pack[i] {
        case 'B':
            black = append(black, pack[i+1])
        case 'R':
            red = append(red, pack[i+1])
        }
        discard = append(discard, pack[i])
    }
    lr, lb, ld := len(red), len(black), len(discard)
    fmt.Println(""After dealing the cards the state of the stacks is:"")
    fmt.Printf(""  Red    : %2d cards -> %c\n"", lr, red)
    fmt.Printf(""  Black  : %2d cards -> %c\n"", lb, black)
    fmt.Printf(""  Discard: %2d cards -> %c\n"", ld, discard)
 
    // Swap the same, random, number of cards between the red and black stacks.
    min := lr
    if lb < min {
        min = lb
    }
    n := 1 + rand.Intn(min)
    rp := rand.Perm(lr)[:n]
    bp := rand.Perm(lb)[:n]
    fmt.Printf(""\n%d card(s) are to be swapped.\n\n"", n)
    fmt.Println(""The respective zero-based indices of the cards(s) to be swapped are:"")
    fmt.Printf(""  Red    : %2d\n"", rp)
    fmt.Printf(""  Black  : %2d\n"", bp)
    for i := 0; i < n; i++ {
        red[rp[i]], black[bp[i]] = black[bp[i]], red[rp[i]]
    }
    fmt.Println(""\nAfter swapping, the state of the red and black stacks is:"")
    fmt.Printf(""  Red    : %c\n"", red)
    fmt.Printf(""  Black  : %c\n"", black)
 
    // Check that the number of black cards in the black stack equals
    // the number of red cards in the red stack.
    rcount, bcount := 0, 0
    for _, c := range red {
        if c == 'R' {
            rcount++
        }
    }
    for _, c := range black {
        if c == 'B' {
            bcount++
        }
    }
 
    fmt.Println(""\nThe number of red cards in the red stack     ="", rcount)
    fmt.Println(""The number of black cards in the black stack ="", bcount)
    if rcount == bcount {
        fmt.Println(""So the asssertion is correct!"")
    } else {
        fmt.Println(""So the asssertion is incorrect!"")
    }
}",2306,78
34747,http://rosettacode.org/wiki/Metallic_ratios,Metallic ratios,"Many people have heard of the Golden ratio, phi (φ). Phi is just one of a series
of related ratios that are referred to as the ""Metallic ratios"".

The Golden ratio was discovered and named by ancient civilizations as it was
thought to be the most pure and beautiful (like Gold). The Silver ratio was was
also known to the early Greeks, though was not named so until later as a nod to
the Golden ratio to which it is closely related. The series has been extended to
encompass all of the related ratios and was given the general name Metallic ratios (or Metallic means).
Somewhat incongruously as the original Golden ratio referred to the adjective ""golden"" rather than the metal ""gold"".

Metallic ratios are the real roots of the general form equation:

         x2 - bx - 1 = 0 

where the integer b determines which specific one it is.

Using the quadratic equation:

         ( -b ± √(b2 - 4ac) ) / 2a = x 

Substitute in (from the top equation) 1 for a, -1 for c, and recognising that -b is negated we get:

         ( b ± √(b2 + 4) ) ) / 2 = x 

We only want the real root:

         ( b + √(b2 + 4) ) ) / 2 = x 

When we set b to 1, we get an irrational number: the Golden ratio.

         ( 1 + √(12 + 4) ) / 2  =  (1 + √5) / 2 = ~1.618033989... 

With b set to 2, we get a different irrational number: the Silver ratio.

         ( 2 + √(22 + 4) ) / 2  =  (2 + √8) / 2 = ~2.414213562... 

When the ratio b is 3, it is commonly referred to as the Bronze ratio, 4 and 5
are sometimes called the Copper and Nickel ratios, though they aren't as
standard. After that there isn't really any attempt at standardized names. They
are given names here on this page, but consider the names fanciful rather than
canonical.

Note that technically, b can be 0 for a ""smaller"" ratio than the Golden ratio.
We will refer to it here as the Platinum ratio, though it is kind-of a
degenerate case.

Metallic ratios where b > 0 are also defined by the irrational continued fractions:

         [b;b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b...] 



So, The first ten Metallic ratios are:


 Metallic ratios


Name
b
Equation
Value
Continued fraction
OEIS link


Platinum
0
(0 + √4) / 2
 1
-
-


Golden
1
(1 + √5) / 2
 1.618033988749895...
[1;1,1,1,1,1,1,1,1,1,1...]
OEIS:A001622


Silver
2
(2 + √8) / 2
 2.414213562373095...
[2;2,2,2,2,2,2,2,2,2,2...]
OEIS:A014176


Bronze
3
(3 + √13) / 2
 3.302775637731995...
[3;3,3,3,3,3,3,3,3,3,3...]
OEIS:A098316


Copper
4
(4 + √20) / 2
 4.23606797749979...
[4;4,4,4,4,4,4,4,4,4,4...]
OEIS:A098317


Nickel
5
(5 + √29) / 2
 5.192582403567252...
[5;5,5,5,5,5,5,5,5,5,5...]
OEIS:A098318


Aluminum
6
(6 + √40) / 2
 6.16227766016838...
[6;6,6,6,6,6,6,6,6,6,6...]
OEIS:A176398


Iron
7
(7 + √53) / 2
 7.140054944640259...
[7;7,7,7,7,7,7,7,7,7,7...]
OEIS:A176439


Tin
8
(8 + √68) / 2
 8.123105625617661...
[8;8,8,8,8,8,8,8,8,8,8...]
OEIS:A176458


Lead
9
(9 + √85) / 2
 9.109772228646444...
[9;9,9,9,9,9,9,9,9,9,9...]
OEIS:A176522




There are other ways to find the Metallic ratios; one, (the focus of this task)
is through successive approximations of Lucas sequences.

A traditional Lucas sequence is of the form:

   xn = P * xn-1 - Q * xn-2

and starts with the first 2 values 0, 1.

For our purposes in this task, to find the metallic ratios we'll use the form:

   xn = b * xn-1 + xn-2

( P is set to b and Q is set to -1. ) To avoid ""divide by zero"" issues we'll start the sequence with the first two terms 1, 1. The initial starting value has very little effect on the final ratio or convergence rate. Perhaps it would be more accurate to call it a Lucas-like sequence.

At any rate, when b = 1 we get:

   xn = xn-1 + xn-2

   1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144...

more commonly known as the Fibonacci sequence.

When b = 2:

   xn = 2 * xn-1 + xn-2

   1, 1, 3, 7, 17, 41, 99, 239, 577, 1393...



And so on.



To find the ratio by successive approximations, divide the (n+1)th term by the
nth. As n grows larger, the ratio will approach the b metallic ratio.

For b = 1 (Fibonacci sequence):

   1/1   = 1
   2/1   = 2
   3/2   = 1.5
   5/3   = 1.666667
   8/5   = 1.6
   13/8  = 1.625
   21/13 = 1.615385
   34/21 = 1.619048
   55/34 = 1.617647
   89/55 = 1.618182
   etc.

It converges, but pretty slowly. In fact, the Golden ratio has the slowest
possible convergence for any irrational number.



Task
For each of the first 10 Metallic ratios; b = 0 through 9:

 Generate the corresponding ""Lucas"" sequence.
 Show here, on this page, at least the first 15 elements of the ""Lucas"" sequence.
 Using successive approximations, calculate the value of the ratio accurate to 32 decimal places.
 Show the value of the approximation at the required accuracy.
 Show the value of n when the approximation reaches the required accuracy (How many iterations did it take?).
Optional, stretch goal - Show the value and number of iterations n, to approximate the Golden ratio to 256 decimal places.

You may assume that the approximation has been reached when the next iteration does not cause the value (to the desired places) to change.

See also
 Wikipedia: Metallic mean
 Wikipedia: Lucas sequence",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
var names = [10]string{""Platinum"", ""Golden"", ""Silver"", ""Bronze"", ""Copper"",
    ""Nickel"", ""Aluminium"", ""Iron"", ""Tin"", ""Lead""}
 
func lucas(b int64) {
    fmt.Printf(""Lucas sequence for %s ratio, where b = %d:\n"", names[b], b)
    fmt.Print(""First 15 elements: "")
    var x0, x1 int64 = 1, 1
    fmt.Printf(""%d, %d"", x0, x1)
    for i := 1; i <= 13; i++ {
        x2 := b*x1 + x0
        fmt.Printf("", %d"", x2)
        x0, x1 = x1, x2
    }
    fmt.Println()
}
 
func metallic(b int64, dp int) {
    x0, x1, x2, bb := big.NewInt(1), big.NewInt(1), big.NewInt(0), big.NewInt(b)
    ratio := big.NewRat(1, 1)
    iters := 0
    prev := ratio.FloatString(dp)
    for {
        iters++
        x2.Mul(bb, x1)
        x2.Add(x2, x0)
        this := ratio.SetFrac(x2, x1).FloatString(dp)
        if prev == this {
            plural := ""s""
            if iters == 1 {
                plural = "" ""
            }
            fmt.Printf(""Value to %d dp after %2d iteration%s: %s\n\n"", dp, iters, plural, this)
            return
        }
        prev = this
        x0.Set(x1)
        x1.Set(x2)
    }
}
 
func main() {
    for b := int64(0); b < 10; b++ {
        lucas(b)
        metallic(b, 32)
    }
    fmt.Println(""Golden ratio, where b = 1:"")
    metallic(1, 256)
}",1315,55
34776,http://rosettacode.org/wiki/Mian-Chowla_sequence,Mian-Chowla sequence,"The Mian–Chowla sequence is an integer sequence defined recursively.



Mian–Chowla is an infinite instance of a Sidon sequence, and belongs to the class known as B₂ sequences.



The sequence starts with:

a1 = 1
then for n > 1, an is the smallest positive integer such that every pairwise sum

ai + aj 
is distinct, for all i and j less than or equal to n.

The Task

 Find and display, here, on this page the first 30 terms of the Mian–Chowla sequence.
 Find and display, here, on this page the 91st through 100th terms of the Mian–Chowla sequence.


Demonstrating working through the first few terms longhand:

a1 = 1
1 + 1 = 2
Speculatively try a2 = 2

1 + 1 = 2
1 + 2 = 3
2 + 2 = 4
There are no repeated sums so 2 is the next number in the sequence.

Speculatively try a3 = 3

1 + 1 = 2
1 + 2 = 3 
1 + 3 = 4
2 + 2 = 4
2 + 3 = 5
3 + 3 = 6
Sum of 4 is repeated so 3 is rejected.

Speculatively try a3 = 4

1 + 1 = 2
1 + 2 = 3
1 + 4 = 5
2 + 2 = 4
2 + 4 = 6
4 + 4 = 8
There are no repeated sums so 4 is the next number in the sequence.

And so on...

See also

 OEIS:A005282 Mian-Chowla sequence",#Go,Go,"package main
 
import ""fmt""
 
func contains(is []int, s int) bool {
    for _, i := range is {
        if s == i {
            return true
        }
    }
    return false
}
 
func mianChowla(n int) []int {
    mc := make([]int, n)
    mc[0] = 1
    is := []int{2}
    var sum int
    for i := 1; i < n; i++ {
        le := len(is)
    jloop:
        for j := mc[i-1] + 1; ; j++ {
            mc[i] = j
            for k := 0; k <= i; k++ {
                sum = mc[k] + j
                if contains(is, sum) {
                    is = is[0:le]
                    continue jloop
                }
                is = append(is, sum)
            }
            break
        }
    }
    return mc
}
 
func main() {
    mc := mianChowla(100)
    fmt.Println(""The first 30 terms of the Mian-Chowla sequence are:"")
    fmt.Println(mc[0:30])
    fmt.Println(""\nTerms 91 to 100 of the Mian-Chowla sequence are:"")
    fmt.Println(mc[90:100])
}",938,44
34796,http://rosettacode.org/wiki/Metaprogramming,Metaprogramming,"Name and briefly demonstrate any support your language has for metaprogramming. Your demonstration may take the form of cross-references to other tasks on Rosetta Code. When possible, provide links to relevant documentation.

For the purposes of this task, ""support for metaprogramming"" means any way the user can effectively modify the language's syntax that's built into the language (like Lisp macros) or that's conventionally used with the language (like the C preprocessor). Such facilities need not be very powerful: even user-defined infix operators count. On the other hand, in general, neither operator overloading nor eval count. The task author acknowledges that what qualifies as metaprogramming is largely a judgment call.
",#Go,Go,"package main
 
import ""fmt""
 
type person struct{
    name string
    age int
}
 
func copy(p person) person {
    return person{p.name, p.age}
}
 
func main() {
    p := person{""Dave"", 40}
    fmt.Println(p)
    q := copy(p)
    fmt.Println(q)
    /*
    is := []int{1, 2, 3}
    it := make([]int, 3)
    copy(it, is)
    */ 
}",328,24
34802,http://rosettacode.org/wiki/Minesweeper_game,Minesweeper game,"There is an n by m grid that has a random number (between 10% to 20% of the total number of tiles, though older implementations may use 20%..60% instead) of randomly placed mines that need to be found.

Positions in the grid are modified by entering their coordinates where the first coordinate is horizontal in the grid and the second vertical. The top left of the grid is position 1,1; the bottom right is at n,m.

 The total number of mines to be found is shown at the beginning of the game.
 Each mine occupies a single grid point, and its position is initially unknown to the player
 The grid is shown as a rectangle of characters between moves.
 You are initially shown all grids as obscured, by a single dot '.'
 You may mark what you think is the position of a mine which will show as a '?'
 You can mark what you think is free space by entering its coordinates.
 If the point is free space then it is cleared, as are any adjacent points that are also free space- this is repeated recursively for subsequent adjacent free points unless that point is marked as a mine or is a mine.
 Points marked as a mine show as a '?'.
 Other free points show as an integer count of the number of adjacent true mines in its immediate neighborhood, or as a single space ' ' if the free point is not adjacent to any true mines.
 Of course you lose if you try to clear space that has a hidden mine.
 You win when you have correctly identified all mines.
The Task is to create a program that allows you to play minesweeper on a 6 by 4 grid, and that assumes all user input is formatted correctly and so checking inputs for correct form may be omitted.
You may also omit all GUI parts of the task and work using text input and output.

Note: Changes may be made to the method of clearing mines to more closely follow a particular implementation of the game so long as such differences and the implementation that they more accurately follow are described.


C.F: wp:Minesweeper (computer game)
",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""math""
    ""math/rand""
    ""os""
    ""strconv""
    ""strings""
    ""time""
)
 
type cell struct {
    isMine  bool
    display byte // display character for cell
}
 
const lMargin = 4
 
var (
    grid        [][]cell
    mineCount   int
    minesMarked int
    isGameOver  bool
)
 
var scanner = bufio.NewScanner(os.Stdin)
 
func makeGrid(n, m int) {
    if n <= 0 || m <= 0 {
        panic(""Grid dimensions must be positive."")
    }
    grid = make([][]cell, n)
    for i := 0; i < n; i++ {
        grid[i] = make([]cell, m)
        for j := 0; j < m; j++ {
            grid[i][j].display = '.'
        }
    }
    min := int(math.Round(float64(n*m) * 0.1)) // 10% of tiles
    max := int(math.Round(float64(n*m) * 0.2)) // 20% of tiles
    mineCount = min + rand.Intn(max-min+1)
    rm := mineCount
    for rm > 0 {
        x, y := rand.Intn(n), rand.Intn(m)
        if !grid[x][y].isMine {
            rm--
            grid[x][y].isMine = true
        }
    }
    minesMarked = 0
    isGameOver = false
}
 
func displayGrid(isEndOfGame bool) {
    if !isEndOfGame {
        fmt.Println(""Grid has"", mineCount, ""mine(s),"", minesMarked, ""mine(s) marked."")
    }
    margin := strings.Repeat("" "", lMargin)
    fmt.Print(margin, "" "")
    for i := 1; i <= len(grid); i++ {
        fmt.Print(i)
    }
    fmt.Println()
    fmt.Println(margin, strings.Repeat(""-"", len(grid)))
    for y := 0; y < len(grid[0]); y++ {
        fmt.Printf(""%*d:"", lMargin, y+1)
        for x := 0; x < len(grid); x++ {
            fmt.Printf(""%c"", grid[x][y].display)
        }
        fmt.Println()
    }
}
 
func endGame(msg string) {
    isGameOver = true
    fmt.Println(msg)
    ans := """"
    for ans != ""y"" && ans != ""n"" {
        fmt.Print(""Another game (y/n)? : "")
        scanner.Scan()
        ans = strings.ToLower(scanner.Text())
    }
    if scanner.Err() != nil || ans == ""n"" {
        return
    }
    makeGrid(6, 4)
    displayGrid(false)
}
 
func resign() {
    found := 0
    for y := 0; y < len(grid[0]); y++ {
        for x := 0; x < len(grid); x++ {
            if grid[x][y].isMine {
                if grid[x][y].display == '?' {
                    grid[x][y].display = 'Y'
                    found++
                } else if grid[x][y].display != 'x' {
                    grid[x][y].display = 'N'
                }
            }
        }
    }
    displayGrid(true)
    msg := fmt.Sprint(""You found "", found, "" out of "", mineCount, "" mine(s)."")
    endGame(msg)
}
 
func usage() {
    fmt.Println(""h or ? - this help,"")
    fmt.Println(""c x y  - clear cell (x,y),"")
    fmt.Println(""m x y  - marks (toggles) cell (x,y),"")
    fmt.Println(""n      - start a new game,"")
    fmt.Println(""q      - quit/resign the game,"")
    fmt.Println(""where x is the (horizontal) column number and y is the (vertical) row number.\n"")
}
 
func markCell(x, y int) {
    if grid[x][y].display == '?' {
        minesMarked--
        grid[x][y].display = '.'
    } else if grid[x][y].display == '.' {
        minesMarked++
        grid[x][y].display = '?'
    }
}
 
func countAdjMines(x, y int) int {
    count := 0
    for j := y - 1; j <= y+1; j++ {
        if j >= 0 && j < len(grid[0]) {
            for i := x - 1; i <= x+1; i++ {
                if i >= 0 && i < len(grid) {
                    if grid[i][j].isMine {
                        count++
                    }
                }
            }
        }
    }
    return count
}
 
func clearCell(x, y int) bool {
    if x >= 0 && x < len(grid) && y >= 0 && y < len(grid[0]) {
        if grid[x][y].display == '.' {
            if !grid[x][y].isMine {
                count := countAdjMines(x, y)
                if count > 0 {
                    grid[x][y].display = string(48 + count)[0]
                } else {
                    grid[x][y].display = ' '
                    clearCell(x+1, y)
                    clearCell(x+1, y+1)
                    clearCell(x, y+1)
                    clearCell(x-1, y+1)
                    clearCell(x-1, y)
                    clearCell(x-1, y-1)
                    clearCell(x, y-1)
                    clearCell(x+1, y-1)
                }
            } else {
                grid[x][y].display = 'x'
                fmt.Println(""Kaboom! You lost!"")
                return false
            }
        }
    }
    return true
}
 
func testForWin() bool {
    isCleared := false
    if minesMarked == mineCount {
        isCleared = true
        for x := 0; x < len(grid); x++ {
            for y := 0; y < len(grid[0]); y++ {
                if grid[x][y].display == '.' {
                    isCleared = false
                }
            }
        }
    }
    if isCleared {
        fmt.Println(""You won!"")
    }
    return isCleared
}
 
func splitAction(action string) (int, int, bool) {
    fields := strings.Fields(action)
    if len(fields) != 3 {
        return 0, 0, false
    }
    x, err := strconv.Atoi(fields[1])
    if err != nil || x < 1 || x > len(grid) {
        return 0, 0, false
    }
    y, err := strconv.Atoi(fields[2])
    if err != nil || y < 1 || y > len(grid[0]) {
        return 0, 0, false
    }
    return x, y, true
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    usage()
    makeGrid(6, 4)
    displayGrid(false)
    for !isGameOver {
        fmt.Print(""\n>"")
        scanner.Scan()
        action := strings.ToLower(scanner.Text())
        if scanner.Err() != nil || len(action) == 0 {
            continue
        }
        switch action[0] {
        case 'h', '?':
            usage()
        case 'n':
            makeGrid(6, 4)
            displayGrid(false)
        case 'c':
            x, y, ok := splitAction(action)
            if !ok {
                continue
            }
            if clearCell(x-1, y-1) {
                displayGrid(false)
                if testForWin() {
                    resign()
                }
            } else {
                resign()
            }
        case 'm':
            x, y, ok := splitAction(action)
            if !ok {
                continue
            }
            markCell(x-1, y-1)
            displayGrid(false)
            if testForWin() {
                resign()
            }
        case 'q':
            resign()
        }
    }
}",6294,253
34808,http://rosettacode.org/wiki/Metered_concurrency,Metered concurrency,"The goal of this task is to create a counting semaphore used to control the execution of a set of concurrent units. This task intends to demonstrate coordination of active concurrent units through the use of a passive concurrent unit. The operations for a counting semaphore are acquire, release, and count. Each active concurrent unit should attempt to acquire the counting semaphore before executing its assigned duties. In this case the active concurrent unit should report that it has acquired the semaphore. It should sleep for 2 seconds and then release the semaphore.
",#Go,Go,"package main
 
import (
    ""log""
    ""os""
    ""sync""
    ""time""
)
 
// counting semaphore implemented with a buffered channel
type sem chan struct{}
 
func (s sem) acquire()   { s <- struct{}{} }
func (s sem) release()   { <-s }
func (s sem) count() int { return cap(s) - len(s) }
 
// log package serializes output
var fmt = log.New(os.Stdout, """", 0)
 
// library analogy per WP article
const nRooms = 10
const nStudents = 20
 
func main() {
    rooms := make(sem, nRooms)
    // WaitGroup used to wait for all students to have studied
    // before terminating program
    var studied sync.WaitGroup
    studied.Add(nStudents)
    // nStudents run concurrently
    for i := 0; i < nStudents; i++ {
        go student(rooms, &studied)
    }
    studied.Wait()
}
 
func student(rooms sem, studied *sync.WaitGroup) {
    rooms.acquire()
    // report per task descrption.  also exercise count operation
    fmt.Printf(""Room entered.  Count is %d.  Studying...\n"",
        rooms.count())
    time.Sleep(2 * time.Second) // sleep per task description
    rooms.release()
    studied.Done() // signal that student is done
}",1120,45
34828,http://rosettacode.org/wiki/Metronome,Metronome,"
The task is to implement a   metronome.

The metronome should be capable of producing high and low audio beats, accompanied by a visual beat indicator, and the beat pattern and tempo should be configurable.

For the purpose of this task, it is acceptable to play sound files for production of the beat notes, and an external player may be used.

However, the playing of the sounds should not interfere with the timing of the metronome.

The visual indicator can simply be a blinking red or green area of the screen (depending on whether a high or low beat is being produced), and the metronome can be implemented using a terminal display, or optionally, a graphical display, depending on the language capabilities.

If the language has no facility to output sound, then it is permissible for this to implemented using just the visual indicator.



",#Go,Go,"package main
 
import (
	""fmt""
	""time""
)
 
func main() {
	var bpm = 72.0 // Beats Per Minute
	var bpb = 4    // Beats Per Bar
 
	d := time.Duration(float64(time.Minute) / bpm)
	fmt.Println(""Delay:"", d)
	t := time.NewTicker(d)
	i := 1
	for _ = range t.C {
		i--
		if i == 0 {
			i = bpb
			fmt.Printf(""\nTICK "")
		} else {
			fmt.Printf(""tick "")
		}
	}
}",353,25
34913,http://rosettacode.org/wiki/Median_filter,Median filter,"The median filter takes in the neighbourhood the median color (see Median filter)

(to test the function below, you can use these input and output solutions)
",#Go,Go,"package main
 
// Files required to build supporting package raster are found in:
// * Bitmap
// * Grayscale image
// * Read a PPM file
// * Write a PPM file
 
import (
    ""fmt""
    ""raster""
)
 
var g0, g1 *raster.Grmap
var ko [][]int
var kc []uint16
var mid int
 
func init() {
    // hard code box of 9 pixels
    ko = [][]int{
        {-1, -1}, {0, -1}, {1, -1},
        {-1,  0}, {0,  0}, {1,  0},
        {-1,  1}, {0,  1}, {1,  1}}
    kc = make([]uint16, len(ko))
    mid = len(ko) / 2
}
 
func main() {
    // Example file used here is Lenna50.jpg from the task ""Percentage
    // difference between images"" converted with with the command
    // convert Lenna50.jpg -colorspace gray Lenna50.ppm
    // It shows very obvious compression artifacts when viewed at higher
    // zoom factors.
    b, err := raster.ReadPpmFile(""Lenna50.ppm"")
    if err != nil {
        fmt.Println(err)
        return
    }
    g0 = b.Grmap()
    w, h := g0.Extent()
    g1 = raster.NewGrmap(w, h)
    for y := 0; y < h; y++ {
        for x := 0; x < w; x++ {
            g1.SetPx(x, y, median(x, y))
        }
    }
    // side by side comparison with input file shows compression artifacts
    // greatly smoothed over, although at some loss of contrast.
    err = g1.Bitmap().WritePpmFile(""median.ppm"")
    if err != nil {
        fmt.Println(err)
    }
}
 
func median(x, y int) uint16 {
    var n int
    // construct sorted list as pixels are read.  insertion sort can't be
    // beat for a small number of items, plus there would be lots of overhead
    // just to get numbers in and out of a library sort routine.
    for _, o := range ko {
        // read a pixel of the kernel
        c, ok := g0.GetPx(x+o[0], y+o[1])
        if !ok {
            continue
        }
        // insert it in sorted order
        var i int
        for ; i < n; i++ {
            if c < kc[i] {
                for j := n; j > i; j-- {
                    kc[j] = kc[j-1]
                }
                break
            }
        }
        kc[i] = c
        n++
    }
    // compute median from sorted list
    switch {
    case n == len(kc): // the usual case, pixel with complete neighborhood
        return kc[mid]
    case n%2 == 1: // edge case, odd number of pixels
        return kc[n/2]
    }
    // else edge case, even number of pixels
    m := n / 2
    return (kc[m-1] + kc[m]) / 2
}",2380,90
34936,http://rosettacode.org/wiki/Memory_layout_of_a_data_structure,Memory layout of a data structure,"It is often useful to control the memory layout of fields in a data structure to match an interface control definition, or to interface with hardware. Define a data structure matching the RS-232 Plug Definition. Use the 9-pin definition for brevity.

Pin Settings for Plug
(Reverse order for socket.)
__________________________________________
1  2  3  4  5  6  7  8  9  10 11 12 13
 14 15 16 17 18 19 20 21 22 23 24 25
_________________
1  2  3  4  5
6  7  8  9
25 pin                        9 pin
1 - PG   Protective ground
2 - TD   Transmitted data     3
3 - RD   Received data        2
4 - RTS  Request to send      7
5 - CTS  Clear to send        8
6 - DSR  Data set ready       6
7 - SG   Signal ground        5
8 - CD   Carrier detect       1
9 - + voltage (testing)
10 - - voltage (testing)
11 -
12 - SCD  Secondary CD
13 - SCS  Secondary CTS
14 - STD  Secondary TD
15 - TC   Transmit clock
16 - SRD  Secondary RD
17 - RC   Receiver clock
18 -
19 - SRS  Secondary RTS            
20 - DTR  Data terminal ready      4
21 - SQD  Signal quality detector
22 - RI   Ring indicator           9
23 - DRS  Data rate select
24 - XTC  External clock
25 -
",#Go,Go,"package main
 
import ""fmt""
 
type rs232p9 uint16
 
const (
	CD9  rs232p9 = 1 << iota // Carrier detect
	RD9                      // Received data
	TD9                      // Transmitted data
	DTR9                     // Data terminal ready
	SG9                      // signal ground
	DSR9                     // Data set ready
	RTS9                     // Request to send
	CTS9                     // Clear to send
	RI9                      // Ring indicator
)
 
func main() {
	// set some nonsense bits just for example
	p := RI9 | TD9 | CD9
	fmt.Printf(""Type=%T value=%#04x\n"", p, p)
}",589,23
34984,http://rosettacode.org/wiki/Merge_and_aggregate_datasets,Merge and aggregate datasets,"Merge and aggregate datasets



Task

Merge and aggregate two datasets as provided in   .csv   files into a new resulting dataset.

Use the appropriate methods and data structures depending on the programming language.

Use the most common libraries only when built-in functionality is not sufficient.



Note

Either load the data from the   .csv   files or create the required data structures hard-coded.


patients.csv   file contents:

PATIENT_ID,LASTNAME
1001,Hopper
4004,Wirth
3003,Kemeny
2002,Gosling
5005,Kurtz


visits.csv   file contents:

PATIENT_ID,VISIT_DATE,SCORE
2002,2020-09-10,6.8
1001,2020-09-17,5.5
4004,2020-09-24,8.4
2002,2020-10-08,
1001,,6.6
3003,2020-11-12,
4004,2020-11-05,7.0
1001,2020-11-19,5.3



Create a resulting dataset in-memory or output it to screen or file, whichever is appropriate for the programming language at hand.

Merge and group per patient id and last name,   get the maximum visit date,   and get the sum and average of the scores per patient to get the resulting dataset.



Note that the visit date is purposefully provided as ISO format,   so that it could also be processed as text and sorted alphabetically to determine the maximum date.

| PATIENT_ID | LASTNAME | LAST_VISIT |  SCORE_SUM | SCORE_AVG |
| 1001       |  Hopper  | 2020-11-19 |  17.4      | 5.80      |
| 2002       |  Gosling | 2020-10-08 |   6.8      | 6.80      |
| 3003       |  Kemeny  | 2020-11-12 |            |           |
| 4004       |  Wirth   | 2020-11-05 |  15.4      | 7.70      |
| 5005       |  Kurtz   |            |            |           |



Note

This task is aimed in particular at programming languages that are used in data science and data processing, such as F#, Python, R, SPSS, MATLAB etc.



Related tasks

 CSV data manipulation
 CSV to HTML translation
 Read entire file
 Read a file line by line

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""sort""
)
 
type Patient struct {
    id       int
    lastName string
}
 
// maps an id to a lastname
var patientDir = make(map[int]string)
 
// maintains a sorted list of ids
var patientIds []int
 
func patientNew(id int, lastName string) Patient {
    patientDir[id] = lastName
    patientIds = append(patientIds, id)
    sort.Ints(patientIds)
    return Patient{id, lastName}
}
 
type DS struct {
    dates  []string
    scores []float64
}
 
type Visit struct {
    id    int
    date  string
    score float64
}
 
// maps an id to lists of dates and scores
var visitDir = make(map[int]DS)
 
func visitNew(id int, date string, score float64) Visit {
    if date == """" {
        date = ""0000-00-00""
    }
    v, ok := visitDir[id]
    if ok {
        v.dates = append(v.dates, date)
        v.scores = append(v.scores, score)
        visitDir[id] = DS{v.dates, v.scores}
    } else {
        visitDir[id] = DS{[]string{date}, []float64{score}}
    }
    return Visit{id, date, score}
}
 
type Merge struct{ id int }
 
func (m Merge) lastName() string  { return patientDir[m.id] }
func (m Merge) dates() []string   { return visitDir[m.id].dates }
func (m Merge) scores() []float64 { return visitDir[m.id].scores }
 
func (m Merge) lastVisit() string {
    dates := m.dates()
    dates2 := make([]string, len(dates))
    copy(dates2, dates)
    sort.Strings(dates2)
    return dates2[len(dates2)-1]
}
 
func (m Merge) scoreSum() float64 {
    sum := 0.0
    for _, score := range m.scores() {
        if score != -1 {
            sum += score
        }
    }
    return sum
}
 
func (m Merge) scoreAvg() float64 {
    count := 0
    for _, score := range m.scores() {
        if score != -1 {
            count++
        }
    }
    return m.scoreSum() / float64(count)
}
 
func mergePrint(merges []Merge) {
    fmt.Println(""| PATIENT_ID | LASTNAME | LAST_VISIT | SCORE_SUM | SCORE_AVG |"")
    f := ""| %d       | %-7s  | %s | %4s      | %4s      |\n""
    for _, m := range merges {
        _, ok := visitDir[m.id]
        if ok {
            lv := m.lastVisit()
            if lv == ""0000-00-00"" {
                lv = ""          ""
            }
            scoreSum := m.scoreSum()
            ss := fmt.Sprintf(""%4.1f"", scoreSum)
            if scoreSum == 0 {
                ss = ""    ""
            }
            scoreAvg := m.scoreAvg()
            sa := ""    ""
            if !math.IsNaN(scoreAvg) {
                sa = fmt.Sprintf(""%4.2f"", scoreAvg)
            }
            fmt.Printf(f, m.id, m.lastName(), lv, ss, sa)
        } else {
            fmt.Printf(f, m.id, m.lastName(), ""          "", ""    "", ""    "")
        }
    }
}
 
func main() {
    patientNew(1001, ""Hopper"")
    patientNew(4004, ""Wirth"")
    patientNew(3003, ""Kemeny"")
    patientNew(2002, ""Gosling"")
    patientNew(5005, ""Kurtz"")
 
    visitNew(2002, ""2020-09-10"", 6.8)
    visitNew(1001, ""2020-09-17"", 5.5)
    visitNew(4004, ""2020-09-24"", 8.4)
    visitNew(2002, ""2020-10-08"", -1) // -1 signifies no score
    visitNew(1001, """", 6.6)          // """" signifies no date
    visitNew(3003, ""2020-11-12"", -1)
    visitNew(4004, ""2020-11-05"", 7.0)
    visitNew(1001, ""2020-11-19"", 5.3)
 
    merges := make([]Merge, len(patientIds))
    for i, id := range patientIds {
        merges[i] = Merge{id}
    }
    mergePrint(merges)
}",3355,138
35168,http://rosettacode.org/wiki/Memory_allocation,Memory allocation,"Task

Show how to explicitly allocate and deallocate blocks of memory in your language.

Show access to different types of memory (i.e., heap, stack, shared, foreign) if applicable.



",#Go,Go,"func inc(n int) {
    x := n + 1
    println(x)
}",49,4
35231,http://rosettacode.org/wiki/Miller%E2%80%93Rabin_primality_test,Miller–Rabin primality test,"

 This page uses content from Wikipedia. The original article was at Miller–Rabin primality test. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The Miller–Rabin primality test or Rabin–Miller primality test is a primality test: an algorithm which determines whether a given number is prime or not.

The algorithm, as modified by Michael O. Rabin to avoid the generalized Riemann hypothesis, is a probabilistic algorithm.

The pseudocode, from Wikipedia is:

Input: n > 2, an odd integer to be tested for primality;
       k, a parameter that determines the accuracy of the test
Output: composite if n is composite, otherwise probably prime
write n − 1 as 2s·d with d odd by factoring powers of 2 from n − 1
LOOP: repeat k times:
   pick a randomly in the range [2, n − 1]
   x ← ad mod n
   if x = 1 or x = n − 1 then do next LOOP
   repeat s − 1 times:
      x ← x2 mod n
      if x = 1 then return composite
      if x = n − 1 then do next LOOP
   return composite
return probably prime

 The nature of the test involves big numbers, so the use of ""big numbers"" libraries (or similar features of the language of your choice) are suggested, but not mandatory.
 Deterministic variants of the test exist and can be implemented as extra (not mandatory to complete the task)

",#Go,Go,"package main
 
import ""log""
 
func main() {
    // max uint32 is not prime
    c := uint32(1<<32 - 1)
    // a few primes near the top of the range.  source: prime pages.
    for _, p := range []uint32{1<<32 - 5, 1<<32 - 17, 1<<32 - 65, 1<<32 - 99} {
        for ; c > p; c-- {
            if prime(c) {
                log.Fatalf(""prime(%d) returned true"", c)
            }
        }
        if !prime(p) {
            log.Fatalf(""prime(%d) returned false"", p)
        }
        c--
    }
}
 
func prime(n uint32) bool {
    // bases of 2, 7, 61 are sufficient to cover 2^32
    switch n {
    case 0, 1:
        return false
    case 2, 7, 61:
        return true
    }
    // compute s, d where 2^s * d = n-1
    nm1 := n - 1
    d := nm1
    s := 0
    for d&1 == 0 {
        d >>= 1
        s++
    }
    n64 := uint64(n)
    for _, a := range []uint32{2, 7, 61} {
        // compute x := a^d % n
        x := uint64(1)
        p := uint64(a)
        for dr := d; dr > 0; dr >>= 1 {
            if dr&1 != 0 {
                x = x * p % n64
            }
            p = p * p % n64
        }
        if x == 1 || uint32(x) == nm1 {
            continue
        }
        for r := 1; ; r++ {
            if r >= s {
                return false
            }
            x = x * x % n64
            if x == 1 {
                return false
            }
            if uint32(x) == nm1 {
                break
            }
        }
    }
    return true
}",1463,66
35242,http://rosettacode.org/wiki/Mertens_function,Mertens function,"The Mertens function M(x) is the count of square-free integers up to x that have an even number of prime factors, minus the count of those that have an odd number.

It is an extension of the Möbius function. Given the Möbius function μ(n), the Mertens function M(x) is the sum of the Möbius numbers from n == 1 through n == x.



Task

 Write a routine (function, procedure, whatever) to find the Mertens number for any positive integer x.
 Use that routine to find and display here, on this page, at least the first 99 terms in a grid layout. (Not just one long line or column of numbers.)
 Use that routine to find and display here, on this page, the number of times the Mertens function sequence is equal to zero in the range M(1) through M(1000).
 Use that routine to find and display here, on this page, the number of times the Mertens function sequence crosses zero in the range M(1) through M(1000). (Crossing defined as this term equal to zero but preceding term not.)


See also

 Wikipedia: Mertens function
 Wikipedia: Möbius function
 OEIS: A002321 - Mertens's function
 OEIS: A028442 - Numbers n such that Mertens's function M(n) is zero
 Numberphile - Mertens Conjecture
 Stackexchange: compute the mertens function

This is not code golf.   The stackexchange link is provided as an algorithm reference, not as a guide.



Related tasks

 Möbius function

",#Go,Go,"package main
 
import ""fmt""
 
func mertens(to int) ([]int, int, int) {
    if to < 1 {
        to = 1
    }
    merts := make([]int, to+1)
    primes := []int{2}
    var sum, zeros, crosses int
    for i := 1; i <= to; i++ {
        j := i
        cp := 0      // counts prime factors
        spf := false // true if there is a square prime factor
        for _, p := range primes {
            if p > j {
                break
            }
            if j%p == 0 {
                j /= p
                cp++
            }
            if j%p == 0 {
                spf = true
                break
            }
        }
        if cp == 0 && i > 2 {
            cp = 1
            primes = append(primes, i)
        }
        if !spf {
            if cp%2 == 0 {
                sum++
            } else {
                sum--
            }
        }
        merts[i] = sum
        if sum == 0 {
            zeros++
            if i > 1 && merts[i-1] != 0 {
                crosses++
            }
        }
    }
    return merts, zeros, crosses
}
 
func main() {
    merts, zeros, crosses := mertens(1000)
    fmt.Println(""Mertens sequence - First 199 terms:"")
    for i := 0; i < 200; i++ {
        if i == 0 {
            fmt.Print(""    "")
            continue
        }
        if i%20 == 0 {
            fmt.Println()
        }
        fmt.Printf(""  % d"", merts[i])
    }
    fmt.Println(""\n\nEquals zero"", zeros, ""times between 1 and 1000"")
    fmt.Println(""\nCrosses zero"", crosses, ""times between 1 and 1000"")
}",1526,66
35266,http://rosettacode.org/wiki/MD5/Implementation,MD5/Implementation,"The purpose of this task to code and validate an implementation of the MD5 Message Digest Algorithm by coding the algorithm directly (not using a call to a built-in or external hashing library). For details of the algorithm refer to MD5 on Wikipedia or the MD5 definition in IETF RFC (1321).

 The implementation needs to implement the key functionality namely producing a correct message digest for an input string. It is not necessary to mimic all of the calling modes such as adding to a digest one block at a time over subsequent calls. 
 In addition to coding and verifying your implementation, note any challenges your language presented implementing the solution, implementation choices made, or limitations of your solution. 
 Solutions on this page should implement MD5 directly and NOT use built in (MD5) functions, call outs to operating system calls or library routines written in other languages as is common in the original MD5 task.
 The following are acceptable:
 An original implementation from the specification, reference implementation, or pseudo-code
 A translation of a correct implementation from another language
 A library routine in the same language; however, the source must be included here.


The solutions shown here will provide practical illustrations of bit manipulation, unsigned integers, working with little-endian data. Additionally, the task requires an attention to details such as boundary conditions since being out by even 1 bit will produce dramatically different results. Subtle implementation bugs can result in some hashes being correct while others are wrong. Not only is it critical to get the individual sub functions working correctly, even small errors in padding, endianness, or data layout will result in failure.

RFC 1321
                            hash code <== string 
   0xd41d8cd98f00b204e9800998ecf8427e <== """"  
   0x0cc175b9c0f1b6a831c399e269772661 <== ""a""
   0x900150983cd24fb0d6963f7d28e17f72 <== ""abc""
   0xf96b697d7cb7938d525a2f31aaf161d0 <== ""message digest""
   0xc3fcd3d76192e4007dfb496cca67e13b <== ""abcdefghijklmnopqrstuvwxyz""
   0xd174ab98d277d9f5a5611c2c9f419d9f <== ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789""
   0x57edf4a22be3c955ac49da2e2107b67a <== ""12345678901234567890123456789012345678901234567890123456789012345678901234567890""
In addition, intermediate outputs to aid in developing an implementation can be found here.

The MD5 Message-Digest Algorithm was developed by RSA Data Security, Inc. in 1991.



 Warning
Rosetta Code is not a place you should rely on for examples of code in critical roles, including security.
Also, note that MD5 has been broken and should not be used in applications requiring security. For these consider SHA2 or the upcoming SHA3.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""bytes""
    ""encoding/binary""
)
 
type testCase struct {
    hashCode string
    string
}
 
var testCases = []testCase{
    {""d41d8cd98f00b204e9800998ecf8427e"", """"},
    {""0cc175b9c0f1b6a831c399e269772661"", ""a""},
    {""900150983cd24fb0d6963f7d28e17f72"", ""abc""},
    {""f96b697d7cb7938d525a2f31aaf161d0"", ""message digest""},
    {""c3fcd3d76192e4007dfb496cca67e13b"", ""abcdefghijklmnopqrstuvwxyz""},
    {""d174ab98d277d9f5a5611c2c9f419d9f"",
        ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789""},
    {""57edf4a22be3c955ac49da2e2107b67a"", ""12345678901234567890"" +
        ""123456789012345678901234567890123456789012345678901234567890""},
}
 
func main() {
    for _, tc := range testCases {
        fmt.Printf(""%s\n%x\n\n"", tc.hashCode, md5(tc.string))
    }
}
 
var shift = [...]uint{7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21}
var table [64]uint32
 
func init() {
    for i := range table {
        table[i] = uint32((1 << 32) * math.Abs(math.Sin(float64(i + 1))))
    }
}
 
func md5(s string) (r [16]byte) {
    padded := bytes.NewBuffer([]byte(s))
    padded.WriteByte(0x80)
    for padded.Len() % 64 != 56 {
        padded.WriteByte(0)
    }
    messageLenBits := uint64(len(s)) * 8
    binary.Write(padded, binary.LittleEndian, messageLenBits)
 
    var a, b, c, d uint32 = 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476
    var buffer [16]uint32
    for binary.Read(padded, binary.LittleEndian, buffer[:]) == nil { // read every 64 bytes
        a1, b1, c1, d1 := a, b, c, d
        for j := 0; j < 64; j++ {
            var f uint32
            bufferIndex := j
            round := j >> 4
            switch round {
            case 0:
                f = (b1 & c1) | (^b1 & d1)
            case 1:
                f = (b1 & d1) | (c1 & ^d1)
                bufferIndex = (bufferIndex*5 + 1) & 0x0F
            case 2:
                f = b1 ^ c1 ^ d1
                bufferIndex = (bufferIndex*3 + 5) & 0x0F
            case 3:
                f = c1 ^ (b1 | ^d1)
                bufferIndex = (bufferIndex * 7) & 0x0F
            }
            sa := shift[(round<<2)|(j&3)]
            a1 += f + buffer[bufferIndex] + table[j]
            a1, d1, c1, b1 = d1, c1, b1, a1<<sa|a1>>(32-sa)+b1
        }
        a, b, c, d = a+a1, b+b1, c+c1, d+d1
    }
 
    binary.Write(bytes.NewBuffer(r[:0]), binary.LittleEndian, []uint32{a, b, c, d})
    return
}",2434,81
35336,http://rosettacode.org/wiki/Middle_three_digits,Middle three digits,"Task

Write a function/procedure/subroutine that is called with an integer value and returns the middle three digits of the integer if possible or a clear indication of an error if this is not possible.

Note: The order of the middle digits should be preserved.

Your function should be tested with the following values; the first line should return valid answers, those of the second line should return clear indications of an error:

123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345
1, 2, -1, -10, 2002, -2002, 0

Show your output on this page.



",#Go,Go,"package m3
 
import (
    ""errors""
    ""strconv""
)
 
var (
    ErrorLT3  = errors.New(""N of at least three digits required."")
    ErrorEven = errors.New(""N with odd number of digits required."")
)
 
func Digits(i int) (string, error) {
    if i < 0 {
        i = -i
    }
    if i < 100 {
        return """", ErrorLT3
    }
    s := strconv.Itoa(i)
    if len(s)%2 == 0 {
        return """", ErrorEven
    }
    m := len(s) / 2
    return s[m-1 : m+2], nil
}",455,26
35339,http://rosettacode.org/wiki/Menu,Menu,"Task

Given a prompt and a list containing a number of strings of which one is to be selected, create a function that:

 prints a textual menu formatted as an index value followed by its corresponding string for each item in the list;
 prompts the user to enter a number;
 returns the string corresponding to the selected index number.


The function should reject input that is not an integer or is out of range by redisplaying the whole menu before asking again for a number. The function should return an empty string if called with an empty list.

For test purposes use the following four phrases in a list:

   fee fie
   huff and puff
   mirror mirror
   tick tock

Note

This task is fashioned after the action of the Bash select statement.
",#Go,Go,"package main
 
import ""fmt""
 
func menu(choices []string, prompt string) string {
    if len(choices) == 0 {
        return """"
    }
    var c int
    for {
        fmt.Println("""")
        for i, s := range choices {
            fmt.Printf(""%d.  %s\n"", i+1, s)
        }
        fmt.Print(prompt)
        _, err := fmt.Scanln(&c)
 
        if err == nil && c > 0 && c <= len(choices) {
            break
        }
    }
    return choices[c-1]
}
 
func main() {
    pick := menu(nil, ""No prompt"")
    fmt.Printf(""No choices, result = %q\n"", pick)
 
    choices := []string{
        ""fee fie"",
        ""huff and puff"",
        ""mirror mirror"",
        ""tick tock"",
    }
    pick = menu(choices, ""Enter number: "")
    fmt.Printf(""You picked %q\n"", pick)
}",754,37
35468,http://rosettacode.org/wiki/Mayan_calendar,Mayan calendar,"The ancient Maya people had two somewhat distinct calendar systems.

In somewhat simplified terms, one is a cyclical calendar known as The Calendar Round,
that meshes several sacred and civil cycles; the other is an offset calendar
known as The Long Count, similar in many ways to the Gregorian calendar.

The Calendar Round

The Calendar Round has several intermeshing sacred and civil cycles that uniquely identify a specific date in an approximately 52 year cycle.

The Tzolk’in

The sacred cycle in the Mayan calendar round was called the Tzolk’in. The Tzolk'in has a cycle of 20 day names:

   Imix’
   Ik’
   Ak’bal
   K’an
   Chikchan
   Kimi
   Manik’
   Lamat
   Muluk
   Ok
   Chuwen
   Eb
   Ben
   Hix
   Men
   K’ib’
   Kaban
   Etz’nab’
   Kawak
   Ajaw

Intermeshed with the named days, the Tzolk’in has a cycle of 13 numbered days; 1
through 13. Every day has both a number and a name that repeat in a 260 day cycle.

For example:

   1 Imix’
   2 Ik’
   3 Ak’bal
   ...
   11 Chuwen
   12 Eb
   13 Ben
   1 Hix
   2 Men
   3 K’ib’
   ... and so on.

The Haab’

The Mayan civil calendar is called the Haab’. This calendar has 365 days per
year, and is sometimes called the ‘vague year.’ It is substantially the same as
our year, but does not make leap year adjustments, so over long periods of time,
gets out of synchronization with the seasons. It consists of 18 months with 20 days each,
and the end of the year, a special month of only 5 days, giving a total of 365.
The 5 days of the month of Wayeb’ (the last month), are usually considered to be
a time of bad luck.

Each month in the Haab’ has a name. The Mayan names for the civil months are:

   Pop
   Wo’
   Sip
   Sotz’
   Sek
   Xul
   Yaxk’in
   Mol
   Ch’en
   Yax
   Sak’
   Keh
   Mak
   K’ank’in
   Muwan
   Pax
   K’ayab
   Kumk’u
   Wayeb’ (Short, ""unlucky"" month)

The months function very much like ours do. That is, for any given month we
count through all the days of that month, and then move on to the next month.

Normally, the day 1 Pop is considered the first day of the civil year, just as 1 January
is the first day of our year. In 2019, 1 Pop falls on April 2nd. But,
because of the leap year in 2020, 1 Pop falls on April 1st in the years 2020-2023.

The only really unusual aspect of the Haab’ calendar is that, although there are
20 (or 5) days in each month, the last day of the month is not called
the 20th (5th). Instead, the last day of the month is referred to as the
‘seating,’ or ‘putting in place,’ of the next month. (Much like how in our
culture, December 24th is Christmas Eve and December 31st is 'New-Years Eve'.) In
the language of the ancient Maya, the word for seating was chum, So you might
have:

   ...
   18 Pop (18th day of the first month)
   19 Pop (19th day of the first month)
   Chum Wo’ (20th day of the first month)
   1 Wo’ (1st day of the second month)
   ... and so on.

Dates for any particular day are a combination of the Tzolk’in sacred date,
and Haab’ civil date. When put together we get the “Calendar Round.”

Calendar Round dates always have two numbers and two names, and they are
always written in the same order:

   (1) the day number in the Tzolk’in
   (2) the day name in the  Tzolk’in
   (3) the day of the month in the Haab’
   (4) the month name in the Haab’

A calendar round is a repeating cycle with a period of just short of 52
Gregorian calendar years. To be precise: it is 52 x 365 days. (No leap days)

Lords of the Night

A third cycle of nine days honored the nine Lords of the Night; nine deities
that were associated with each day in turn. The names of the nine deities are
lost; they are now commonly referred to as G1 through G9. The Lord of the Night
may or may not be included in a Mayan date, if it is, it is typically
just the appropriate G(x) at the end.

The Long Count

Mayans had a separate independent way of measuring time that did not run in
cycles. (At least, not on normal human scales.) Instead, much like our yearly
calendar, each day just gets a little further from the starting point. For the
ancient Maya, the starting point was the ‘creation date’ of the current world.
This date corresponds to our date of August 11, 3114 B.C. Dates are calculated
by measuring how many days have transpired since this starting date; This is
called “The Long Count.” Rather than just an absolute count of days, the long
count is broken up into unit blocks, much like our calendar has months, years,
decades and centuries.

   The basic unit is a k’in - one day.
   A 20 day month is a winal.
   18 winal (360 days) is a tun - sometimes referred to as a short year.
   20 short years (tun) is a k’atun
   20 k’atun is a bak’tun

There are longer units too:

   Piktun == 20 Bak’tun (8,000 short years)
   Kalabtun  == 20 Piktun (160,000 short years)
   Kinchiltun  == 20 Kalabtun (3,200,000 short years)

For the most part, the Maya only used the blocks of time up to the bak’tun. One
bak’tun is around 394 years, much more than a human life span, so that was all
they usually needed to describe dates in this era, or this world. It is worth
noting, the two calendars working together allow much more accurate and reliable
notation for dates than is available in many other calendar systems; mostly due
to the pragmatic choice to make the calendar simply track days, rather than
trying to make it align with seasons and/or try to conflate it with the notion
of time.

Mayan Date correlations

There is some controversy over finding a correlation point between the Gregorian
and Mayan calendars. The Gregorian calendar is full of jumps and skips to keep
the calendar aligned with the seasons so is much more difficult to work with.
The most commonly used correlation
factor is The GMT: 584283. Julian 584283 is a day count corresponding Mon, Aug 11, 3114 BCE
in the Gregorian calendar, and the final day in the last Mayan long count
cycle: 13.0.0.0.0 which is referred to as ""the day of creation"" in the Mayan
calendar. There is nothing in known Mayan writing or history that suggests that
a long count ""cycle"" resets every 13 bak’tun. Judging by their other practices,
it would make much more sense for it to reset at 20, if at all.

The reason there was much interest at all, outside historical scholars, in
the Mayan calendar is that the long count recently (relatively speaking) rolled over to 13.0.0.0.0 (the same as the historic day of creation Long Count date) on Fri,
Dec 21, 2012 (using the most common GMT correlation factor), prompting conspiracy
theorists to predict a cataclysmic ""end-of-the-world"" scenario.

Excerpts taken from, and recommended reading:

From the website of the Foundation for the Advancement of Meso-America Studies, Inc. 
Pitts, Mark. The complete Writing in Maya Glyphs Book 2 – Maya Numbers and the Maya Calendar. 2009. Accessed 2019-01-19. 
http://www.famsi.org/research/pitts/MayaGlyphsBook2.pdf
wikipedia: Maya calendar
wikipedia: Mesoamerican Long Count calendar

The Task:

Write a reusable routine that takes a Gregorian date and returns the equivalent date in Mayan in the Calendar Round and the Long Count. At a minimum, use the GMT correlation. If desired, support other correlations.

Using the GMT correlation, the following Gregorian and Mayan dates are equivalent:

  Dec 21, 2012 (Gregorian)
  4 Ajaw 3 K’ank’in G9 (Calendar round)
  13.0.0.0.0 (Long count)

Support looking up dates for at least 50 years before and after the Mayan Long Count 13 bak’tun rollover: Dec 21, 2012. (Will require taking into account Gregorian leap days.)

Show the output here, on this page, for at least the following dates:

(Note that these are in ISO-8601 format: YYYY-MM-DD. There is no requirement to use ISO-8601 format in your program, but if you differ, make a note of the expected format.)

   2004-06-19
   2012-12-18
   2012-12-21
   2019-01-19
   2019-03-27
   2020-02-29
   2020-03-01
",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
    ""strings""
    ""time""
)
 
var sacred = strings.Fields(""Imix’ Ik’ Ak’bal K’an Chikchan Kimi Manik’ Lamat Muluk Ok Chuwen Eb Ben Hix Men K’ib’ Kaban Etz’nab’ Kawak Ajaw"")
 
var civil = strings.Fields(""Pop Wo’ Sip Sotz’ Sek Xul Yaxk’in Mol Ch’en Yax Sak’ Keh Mak K’ank’in Muwan’ Pax K’ayab Kumk’u Wayeb’"")
 
var (
    date1 = time.Date(2012, time.December, 21, 0, 0, 0, 0, time.UTC)
    date2 = time.Date(2019, time.April, 2, 0, 0, 0, 0, time.UTC)
)
 
func tzolkin(date time.Time) (int, string) {
    diff := int(date.Sub(date1).Hours()) / 24
    rem := diff % 13
    if rem < 0 {
        rem = 13 + rem
    }
    var num int
    if rem <= 9 {
        num = rem + 4
    } else {
        num = rem - 9
    }
    rem = diff % 20
    if rem <= 0 {
        rem = 20 + rem
    }
    return num, sacred[rem-1]
}
 
func haab(date time.Time) (string, string) {
    diff := int(date.Sub(date2).Hours()) / 24
    rem := diff % 365
    if rem < 0 {
        rem = 365 + rem
    }
    month := civil[(rem+1)/20]
    last := 20
    if month == ""Wayeb’"" {
        last = 5
    }
    d := rem%20 + 1
    if d < last {
        return strconv.Itoa(d), month
    }
    return ""Chum"", month
}
 
func longCount(date time.Time) string {
    diff := int(date.Sub(date1).Hours()) / 24
    diff += 13 * 400 * 360
    baktun := diff / (400 * 360)
    diff %= 400 * 360
    katun := diff / (20 * 360)
    diff %= 20 * 360
    tun := diff / 360
    diff %= 360
    winal := diff / 20
    kin := diff % 20
    return fmt.Sprintf(""%d.%d.%d.%d.%d"", baktun, katun, tun, winal, kin)    
}
 
func lord(date time.Time) string {
    diff := int(date.Sub(date1).Hours()) / 24
    rem := diff % 9
    if rem <= 0 {
        rem = 9 + rem
    }
    return fmt.Sprintf(""G%d"", rem)
}
 
func main() {
    const shortForm = ""2006-01-02""
    dates := []string{
        ""2004-06-19"",
        ""2012-12-18"",
        ""2012-12-21"",
        ""2019-01-19"",
        ""2019-03-27"",
        ""2020-02-29"",
        ""2020-03-01"",
        ""2071-05-16"",
    }
    fmt.Println("" Gregorian   Tzolk’in        Haab’              Long           Lord of"")
    fmt.Println(""   Date       # Name       Day Month            Count         the Night"")
    fmt.Println(""----------   --------    -------------        --------------  ---------"")
    for _, dt := range dates {
        date, _ := time.Parse(shortForm, dt)
        n, s := tzolkin(date)
        d, m := haab(date)
        lc := longCount(date)
        l := lord(date)
        fmt.Printf(""%s   %2d %-8s %4s %-9s       %-14s     %s\n"", dt, n, s, d, m, lc, l)
    }
}",2601,102
35578,http://rosettacode.org/wiki/MD4,MD4,"Find the MD4 message digest of a string of octets.
Use the ASCII encoded string “Rosetta Code” (without quotes).
You may either call an MD4 library, or implement MD4 in your language.

MD4 is an obsolete hash function that computes a 128-bit message digest that sometimes appears in obsolete protocols.

RFC 1320 specifies the MD4 algorithm. RFC 6150 declares that MD4 is obsolete.
",#Go,Go,"package main
 
import (
    ""golang.org/x/crypto/md4""
    ""fmt""
)
 
func main() {
    h := md4.New()
    h.Write([]byte(""Rosetta Code""))
    fmt.Printf(""%x\n"", h.Sum(nil))
}",173,12
35582,http://rosettacode.org/wiki/McNuggets_problem,McNuggets problem,"Wikipedia
The McNuggets version of the coin problem was introduced by Henri Picciotto,
who included it in his algebra textbook co-authored with Anita Wah. Picciotto
thought of the application in the 1980s while dining with his son at
McDonald's, working the problem out on a napkin. A McNugget number is
the total number of McDonald's Chicken McNuggets in any number of boxes.
In the United Kingdom, the original boxes (prior to the introduction of
the Happy Meal-sized nugget boxes) were of 6, 9, and 20 nuggets.

Task

Calculate (from 0 up to a limit of 100) the largest non-McNuggets
number (a number n which cannot be expressed with 6x + 9y + 20z = n
where x, y and z are natural numbers).



",#Go,Go,"package main
 
import ""fmt""
 
func mcnugget(limit int) {
    sv := make([]bool, limit+1) // all false by default
    for s := 0; s <= limit; s += 6 {
        for n := s; n <= limit; n += 9 {
            for t := n; t <= limit; t += 20 {
                sv[t] = true
            }
        }
    }
    for i := limit; i >= 0; i-- {
        if !sv[i] {
            fmt.Println(""Maximum non-McNuggets number is"", i)
            return
        }
    }
}
 
func main() {
    mcnugget(100)
}",484,24
35648,http://rosettacode.org/wiki/Mayan_numerals,Mayan numerals,"Task

Present numbers using the Mayan numbering system   (displaying the Mayan numerals in a cartouche).



Mayan numbers

Normally, Mayan numbers are written vertically   (top─to─bottom)   with the most significant
numeral at the top   (in the sense that decimal numbers are written left─to─right with the most significant
digit at the left).   This task will be using a left─to─right (horizontal) format,   mostly for familiarity and
readability,   and to conserve screen space (when showing the output) on this task page.



Mayan numerals

Mayan numerals   (a base─20 ""digit"" or glyph)   are written in two orientations,   this
task will be using the ""vertical"" format   (as displayed below).   Using the vertical format makes
it much easier to draw/construct the Mayan numerals (glyphs) with simple dots (.)
and hyphen (-);     (however, round bullets (•) and long dashes (─)
make a better presentation on Rosetta Code).



Furthermore, each Mayan numeral   (for this task)   is to be displayed as a
cartouche   (enclosed in a box)   to make it easier to parse (read);   the box may be
drawn with any suitable (ASCII or Unicode) characters that are presentable/visible in all web browsers.



Mayan numerals added to Unicode
Mayan numerals (glyphs) were added to the Unicode Standard in June of 2018   (this corresponds with
version 11.0).   But since most web browsers don't support them at this time,   this Rosetta Code
task will be constructing the glyphs with ""simple"" characters and/or ASCII art.



The ""zero"" glyph

The Mayan numbering system has the concept of   zero,   and should be shown by a glyph that represents
an upside─down (sea) shell,   or an egg.   The Greek letter theta   (Θ)   can be
used   (which more─or─less, looks like an
egg).   A   commercial at   symbol   (@)   could make a poor substitute.



Mayan glyphs (constructed)

The Mayan numbering system is
a   [vigesimal (base 20)]   positional numeral system.



The Mayan numerals   (and some random numbers)   shown in the   vertical   format would be shown as

      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║    ║                            ║    ║    ║
      ║    ║                      ║ ∙  ║                            ║    ║    ║
 1──► ║    ║                11──► ║────║                      21──► ║    ║    ║
      ║ ∙  ║                      ║────║                            ║ ∙  ║ ∙  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║    ║                            ║    ║    ║
      ║    ║                      ║ ∙∙ ║                            ║    ║    ║
 2──► ║    ║                12──► ║────║                      22──► ║    ║    ║
      ║ ∙∙ ║                      ║────║                            ║ ∙  ║ ∙∙ ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║    ║                            ║    ║    ║
      ║    ║                      ║∙∙∙ ║                            ║    ║    ║
 3──► ║    ║                13──► ║────║                      40──► ║    ║    ║
      ║∙∙∙ ║                      ║────║                            ║ ∙∙ ║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║    ║                            ║    ║    ║
      ║    ║                      ║∙∙∙∙║                            ║    ║    ║
 4──► ║    ║                14──► ║────║                      80──► ║    ║    ║
      ║∙∙∙∙║                      ║────║                            ║∙∙∙∙║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║    ║                            ║    ║    ║
      ║    ║                      ║────║                            ║    ║    ║
 5──► ║    ║                15──► ║────║                      90──► ║    ║────║
      ║────║                      ║────║                            ║∙∙∙∙║────║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║ ∙  ║                            ║    ║    ║
      ║    ║                      ║────║                            ║    ║    ║
 6──► ║ ∙  ║                16──► ║────║                     100──► ║    ║    ║
      ║────║                      ║────║                            ║────║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║ ∙∙ ║                            ║    ║    ║
      ║    ║                      ║────║                            ║    ║    ║
 7──► ║ ∙∙ ║                17──► ║────║                     200──► ║────║    ║
      ║────║                      ║────║                            ║────║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║∙∙∙ ║                            ║    ║    ║
      ║    ║                      ║────║                     300──► ║────║    ║
 8──► ║∙∙∙ ║                18──► ║────║                            ║────║    ║
      ║────║                      ║────║                            ║────║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╦════╗
      ║    ║                      ║∙∙∙∙║                            ║    ║    ║    ║
      ║    ║                      ║────║                     400──► ║    ║    ║    ║
 9──► ║∙∙∙∙║                19──► ║────║                            ║    ║    ║    ║
      ║────║                      ║────║                            ║ ∙  ║ Θ  ║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╩════╝
      ╔════╗                      ╔════╦════╗                       ╔════╦════╦════╦════╗
      ║    ║                      ║    ║    ║                       ║    ║    ║    ║    ║
      ║    ║                      ║    ║    ║                       ║    ║    ║    ║    ║
10──► ║────║                20──► ║    ║    ║             16,000──► ║    ║    ║    ║    ║
      ║────║                      ║ ∙  ║ Θ  ║                       ║ ∙∙ ║ Θ  ║ Θ  ║ Θ  ║
      ╚════╝                      ╚════╩════╝                       ╚════╩════╩════╩════╝



Note that the Mayan numeral   13   in   horizontal   format would be shown as:

                                  ╔════╗
                                  ║  ││║
                                  ║ ∙││║
                            13──► ║ ∙││║        ◄─── this glyph form won't be used in this Rosetta Code task.
                                  ║ ∙││║
                                  ╚════╝



Other forms of cartouches (boxes) can be used for this task.



Task requirements

   convert the following decimal numbers to Mayan numbers:
       4,005
       8,017
   326,205
   886,205
   show a   unique   interesting/pretty/unusual/intriguing/odd/amusing/weird   Mayan number
   show all output here


Related tasks

   Roman numerals/Encode   ─── convert numeric values into Roman numerals
   Roman numerals/Decode   ─── convert Roman numerals into Arabic numbers


See also

   The Wikipedia entry:   [Mayan numerals]

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
const (
    ul = ""╔""
    uc = ""╦""
    ur = ""╗""
    ll = ""╚""
    lc = ""╩""
    lr = ""╝""
    hb = ""═""
    vb = ""║""
)
 
var mayan = [5]string{
    ""    "",
    "" ∙  "",
    "" ∙∙ "",
    ""∙∙∙ "",
    ""∙∙∙∙"",
}
 
const (
    m0 = "" Θ  ""
    m5 = ""────""
)
 
func dec2vig(n uint64) []uint64 {
    vig := strconv.FormatUint(n, 20)
    res := make([]uint64, len(vig))
    for i, d := range vig {
        res[i], _ = strconv.ParseUint(string(d), 20, 64)
    }
    return res
}
 
func vig2quin(n uint64) [4]string {
    if n >= 20 {
        panic(""Cant't convert a number >= 20"")
    }
    res := [4]string{mayan[0], mayan[0], mayan[0], mayan[0]}
    if n == 0 {
        res[3] = m0
        return res
    }
    fives := n / 5
    rem := n % 5
    res[3-fives] = mayan[rem]
    for i := 3; i > 3-int(fives); i-- {
        res[i] = m5
    }
    return res
}
 
func draw(mayans [][4]string) {
    lm := len(mayans)
    fmt.Print(ul)
    for i := 0; i < lm; i++ {
        for j := 0; j < 4; j++ {
            fmt.Print(hb)
        }
        if i < lm-1 {
            fmt.Print(uc)
        } else {
            fmt.Println(ur)
        }
    }
    for i := 1; i < 5; i++ {
        fmt.Print(vb)
        for j := 0; j < lm; j++ {
            fmt.Print(mayans[j][i-1])
            fmt.Print(vb)
        }
        fmt.Println()
    }
    fmt.Print(ll)
    for i := 0; i < lm; i++ {
        for j := 0; j < 4; j++ {
            fmt.Print(hb)
        }
        if i < lm-1 {
            fmt.Print(lc)
        } else {
            fmt.Println(lr)
        }
    }
}
 
func main() {
    numbers := []uint64{4005, 8017, 326205, 886205, 1081439556}
    for _, n := range numbers {
        fmt.Printf(""Converting %d to Mayan:\n"", n)
        vigs := dec2vig(n)
        lv := len(vigs)
        mayans := make([][4]string, lv)
        for i, vig := range vigs {
            mayans[i] = vig2quin(vig)
        }
        draw(mayans)
        fmt.Println()
    }
}",1977,106
35676,http://rosettacode.org/wiki/Maze_solving,Maze solving,"Task

For a maze generated by this task, write a function
that finds (and displays) the shortest path between two cells.



Note that because these mazes are generated by the Depth-first search algorithm, they contain no circular paths,
and a simple depth-first tree search can be used.



",#Go,Go,"package main
 
import (
    ""bytes""
    ""fmt"" 
    ""math/rand""
    ""time""
)
 
type maze struct { 
    c2 [][]byte // cells by row
    h2 [][]byte // horizontal walls by row (ignore first row)
    v2 [][]byte // vertical walls by row (ignore first of each column)
}
 
func newMaze(rows, cols int) *maze {
    c := make([]byte, rows*cols)              // all cells
    h := bytes.Repeat([]byte{'-'}, rows*cols) // all horizontal walls
    v := bytes.Repeat([]byte{'|'}, rows*cols) // all vertical walls
    c2 := make([][]byte, rows)                // cells by row
    h2 := make([][]byte, rows)                // horizontal walls by row
    v2 := make([][]byte, rows)                // vertical walls by row
    for i := range h2 {
        c2[i] = c[i*cols : (i+1)*cols]
        h2[i] = h[i*cols : (i+1)*cols]
        v2[i] = v[i*cols : (i+1)*cols]
    }
    return &maze{c2, h2, v2}
}   
 
func (m *maze) String() string {
    hWall := []byte(""+---"")
    hOpen := []byte(""+   "")
    vWall := []byte(""|   "")
    vOpen := []byte(""    "")
    rightCorner := []byte(""+\n"")
    rightWall := []byte(""|\n"")
    var b []byte
    for r, hw := range m.h2 {
        for _, h := range hw {
            if h == '-' || r == 0 {
                b = append(b, hWall...)
            } else {
                b = append(b, hOpen...)
                if h != '-' && h != 0 {
                    b[len(b)-2] = h
                }
            }
        }
        b = append(b, rightCorner...)
        for c, vw := range m.v2[r] {
            if vw == '|' || c == 0 {
                b = append(b, vWall...)
            } else {
                b = append(b, vOpen...)
                if vw != '|' && vw != 0 {
                    b[len(b)-4] = vw
                }
            }
            if m.c2[r][c] != 0 {
                b[len(b)-2] = m.c2[r][c]
            }
        }
        b = append(b, rightWall...)
    }
    for _ = range m.h2[0] {
        b = append(b, hWall...)
    }
    b = append(b, rightCorner...)
    return string(b)
}
 
func (m *maze) gen() {
    m.g2(rand.Intn(len(m.c2)), rand.Intn(len(m.c2[0])))
}
 
const (
    up = iota
    dn
    rt
    lf
)
 
func (m *maze) g2(r, c int) {
    m.c2[r][c] = ' '
    for _, dir := range rand.Perm(4) {
        switch dir {
        case up:
            if r > 0 && m.c2[r-1][c] == 0 {
                m.h2[r][c] = 0
                m.g2(r-1, c)
            }
        case lf:
            if c > 0 && m.c2[r][c-1] == 0 {
                m.v2[r][c] = 0
                m.g2(r, c-1)
            }
        case dn:
            if r < len(m.c2)-1 && m.c2[r+1][c] == 0 {
                m.h2[r+1][c] = 0
                m.g2(r+1, c)
            }
        case rt:
            if c < len(m.c2[0])-1 && m.c2[r][c+1] == 0 {
                m.v2[r][c+1] = 0
                m.g2(r, c+1)
            } 
        }
    }
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    const height = 4
    const width = 7
    m := newMaze(height, width)
    m.gen() 
    m.solve(
        rand.Intn(height), rand.Intn(width),
        rand.Intn(height), rand.Intn(width))
    fmt.Print(m)
}   
 
func (m *maze) solve(ra, ca, rz, cz int) {
    var rSolve func(ra, ca, dir int) bool
    rSolve = func(r, c, dir int) bool {
        if r == rz && c == cz {
            m.c2[r][c] = 'F'
            return true
        }
        if dir != dn && m.h2[r][c] == 0 {
            if rSolve(r-1, c, up) {
                m.c2[r][c] = '^'
                m.h2[r][c] = '^'
                return true
            }
        }
        if dir != up && r+1 < len(m.h2) && m.h2[r+1][c] == 0 {
            if rSolve(r+1, c, dn) {
                m.c2[r][c] = 'v'
                m.h2[r+1][c] = 'v'
                return true
            }
        }
        if dir != lf && c+1 < len(m.v2[0]) && m.v2[r][c+1] == 0 {
            if rSolve(r, c+1, rt) {
                m.c2[r][c] = '>'
                m.v2[r][c+1] = '>'
                return true
            }
        }
        if dir != rt && m.v2[r][c] == 0 {
            if rSolve(r, c-1, lf) {
                m.c2[r][c] = '<'
                m.v2[r][c] = '<'
                return true
            }
        }
        return false
    }
    rSolve(ra, ca, -1)
    m.c2[ra][ca] = 'S'
}",4241,163
35716,http://rosettacode.org/wiki/Matrix_chain_multiplication,Matrix chain multiplication,"Problem
Using the most straightfoward algorithm (which we assume here), computing the product of two matrices of dimensions (n1,n2) and (n2,n3) requires n1*n2*n3 FMA operations. The number of operations required to compute the product of matrices A1, A2... An depends on the order of matrix multiplications, hence on where parens are put. Remember that the matrix product is associative, but not commutative, hence only the parens can be moved.

For instance, with four matrices, one can compute A(B(CD)), A((BC)D), (AB)(CD), (A(BC))D, (AB)C)D. The number of different ways to put the parens is a Catalan number, and grows exponentially with the number of factors.

Here is an example of computation of the total cost, for matrices A(5,6), B(6,3), C(3,1):

 AB costs 5*6*3=90 and produces a matrix of dimensions (5,3), then (AB)C costs 5*3*1=15. The total cost is 105.
 BC costs 6*3*1=18 and produces a matrix of dimensions (6,1), then A(BC) costs 5*6*1=30. The total cost is 48.
In this case, computing (AB)C requires more than twice as many operations as A(BC). The difference can be much more dramatic in real cases.

Task
Write a function which, given a list of the successive dimensions of matrices A1, A2... An, of arbitrary length, returns the optimal way to compute the matrix product, and the total cost. Any sensible way to describe the optimal solution is accepted. The input list does not duplicate shared dimensions: for the previous example of matrices A,B,C, one will only pass the list [5,6,3,1] (and not [5,6,6,3,3,1]) to mean the matrix dimensions are respectively (5,6), (6,3) and (3,1). Hence, a product of n matrices is represented by a list of n+1 dimensions.

Try this function on the following two lists:

 [1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2]
 [1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10]
To solve the task, it's possible, but not required, to write a function that enumerates all possible ways to parenthesize the product. This is not optimal because of the many duplicated computations, and this task is a classic application of dynamic programming.

See also Matrix chain multiplication on Wikipedia.
",#Go,Go,"package main
 
import ""fmt""
 
// PrintMatrixChainOrder prints the optimal order for chain
// multiplying matrices.
// Matrix A[i] has dimensions dims[i-1]×dims[i].
func PrintMatrixChainOrder(dims []int) {
	n := len(dims) - 1
	m, s := newSquareMatrices(n)
 
	// m[i,j] will be minimum number of scalar multiplactions
	// needed to compute the matrix A[i]A[i+1]…A[j] = A[i…j].
	// Note, m[i,i] = zero (no cost).
	// s[i,j] will be the index of the subsequence split that
	// achieved minimal cost.
	for lenMinusOne := 1; lenMinusOne < n; lenMinusOne++ {
		for i := 0; i < n-lenMinusOne; i++ {
			j := i + lenMinusOne
			m[i][j] = -1
			for k := i; k < j; k++ {
				cost := m[i][k] + m[k+1][j] + dims[i]*dims[k+1]*dims[j+1]
				if m[i][j] < 0 || cost < m[i][j] {
					m[i][j] = cost
					s[i][j] = k
				}
			}
		}
	}
 
	// Format and print result.
	const MatrixNames = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
	var subprint func(int, int)
	subprint = func(i, j int) {
		if i == j {
			return
		}
		k := s[i][j]
		subprint(i, k)
		subprint(k+1, j)
		fmt.Printf(""%*s -> %s × %s%*scost=%d\n"",
			n, MatrixNames[i:j+1],
			MatrixNames[i:k+1],
			MatrixNames[k+1:j+1],
			n+i-j, """", m[i][j],
		)
	}
	subprint(0, n-1)
}
 
func newSquareMatrices(n int) (m, s [][]int) {
	// Allocates two n×n matrices as slices of slices but
	// using only one [2n][]int and one [2n²]int backing array.
	m = make([][]int, 2*n)
	m, s = m[:n:n], m[n:]
	tmp := make([]int, 2*n*n)
	for i := range m {
		m[i], tmp = tmp[:n:n], tmp[n:]
	}
	for i := range s {
		s[i], tmp = tmp[:n:n], tmp[n:]
	}
	return m, s
}
 
func main() {
	cases := [...][]int{
		{1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2},
		{1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10},
	}
	for _, tc := range cases {
		fmt.Println(""Dimensions:"", tc)
		PrintMatrixChainOrder(tc)
		fmt.Println()
	}
}",1824,76
35744,http://rosettacode.org/wiki/Matrix_digital_rain,Matrix digital rain,"Implement the Matrix Digital Rain visual effect from the movie ""The Matrix"" as described in Wikipedia.

Provided is a reference implementation in Common Lisp to be run in a terminal.



",#Go,Go,"package main
 
import (
    gc ""github.com/rthornton128/goncurses""
    ""log""
    ""math/rand""
    ""time""
)
 
// Time between row updates in microseconds.
// Controls the speed of the digital rain effect.
const rowDelay = 40000
 
func main() {
    start := time.Now()
    rand.Seed(time.Now().UnixNano())
 
    // Characters to randomly appear in the rain sequence.
    chars := []byte(""0123456789"")
    totalChars := len(chars)
 
    // Set up ncurses screen and colors.
    stdscr, err := gc.Init()
    if err != nil {
        log.Fatal(""init"", err)
    }
    defer gc.End()
 
    gc.Echo(false)
    gc.Cursor(0)
 
    if !gc.HasColors() {
        log.Fatal(""Program requires a colour capable terminal"")
    }
 
    if err := gc.StartColor(); err != nil {
        log.Fatal(err)
    }
 
    if err := gc.InitPair(1, gc.C_GREEN, gc.C_BLACK); err != nil {
        log.Fatal(""InitPair failed: "", err)
    }
    stdscr.ColorOn(1)
    maxY, maxX := stdscr.MaxYX()
 
    /* Create slices of columns based on screen width. */
 
    // Slice containing the current row of each column.
    columnsRow := make([]int, maxX)
 
    // Slice containing the active status of each column.
    // A column draws characters on a row when active.
    columnsActive := make([]int, maxX)
 
    // Set top row as current row for all columns.
    for i := 0; i < maxX; i++ {
        columnsRow[i] = -1
        columnsActive[i] = 0
    }
 
    for {
        for i := 0; i < maxX; i++ {
            if columnsRow[i] == -1 {
                // If a column is at the top row, pick a
                // random starting row and active status.
                columnsRow[i] = rand.Intn(maxY + 1)
                columnsActive[i] = rand.Intn(2)
            }
        }
 
        // Loop through columns and draw characters on rows.
        for i := 0; i < maxX; i++ {
            if columnsActive[i] == 1 {
                // Draw a random character at this column's current row.
                charIndex := rand.Intn(totalChars)
                stdscr.MovePrintf(columnsRow[i], i, ""%c"", chars[charIndex])
            } else {
                // Draw an empty character if the column is inactive.
                stdscr.MovePrintf(columnsRow[i], i, ""%c"", ' ')
            }
 
            columnsRow[i]++
 
            // When a column reaches the bottom row, reset to top.
            if columnsRow[i] >= maxY {
                columnsRow[i] = -1
            }
 
            // Randomly alternate the column's active status.
            if rand.Intn(1001) == 0 {
                if columnsActive[i] == 0 {
                    columnsActive[i] = 1
                } else {
                    columnsActive[i] = 0
                }
            }
        }
        time.Sleep(rowDelay * time.Microsecond)
        stdscr.Refresh()
        elapsed := time.Since(start)
        // Stop after 1 minute.
        if elapsed.Minutes() >= 1 {
            break
        }
    }
}",2938,106
35771,http://rosettacode.org/wiki/Maximum_triangle_path_sum,Maximum triangle path sum,"Starting from the top of a pyramid of numbers like this, you can walk down going one step on the right or on the left, until you reach the bottom row:

                          55
                        94 48
                       95 30 96
                     77 71 26 67

One of such walks is 55 - 94 - 30 - 26.
You can compute the total of the numbers you have seen in such walk,
in this case it's 205.

Your problem is to find the maximum total among all possible paths from the top to the bottom row of the triangle. In the little example above it's 321.



Task

Find the maximum total in the triangle below:

                          55
                        94 48
                       95 30 96
                     77 71 26 67
                    97 13 76 38 45
                  07 36 79 16 37 68
                 48 07 09 18 70 26 06
               18 72 79 46 59 79 29 90
              20 76 87 11 32 07 07 49 18
            27 83 58 35 71 11 25 57 29 85
           14 64 36 96 27 11 58 56 92 18 55
         02 90 03 60 48 49 41 46 33 36 47 23
        92 50 48 02 36 59 42 79 72 20 82 77 42
      56 78 38 80 39 75 02 71 66 66 01 03 55 72
     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36
   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52
  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15
27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93

Such numbers can be included in the solution code, or read from a ""triangle.txt"" file.

This task is derived from the Euler Problem #18.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
    ""strings""
)
 
const t = `               55
                        94 48
                       95 30 96
                     77 71 26 67
                    97 13 76 38 45
                  07 36 79 16 37 68
                 48 07 09 18 70 26 06
               18 72 79 46 59 79 29 90
              20 76 87 11 32 07 07 49 18
            27 83 58 35 71 11 25 57 29 85
           14 64 36 96 27 11 58 56 92 18 55
         02 90 03 60 48 49 41 46 33 36 47 23
        92 50 48 02 36 59 42 79 72 20 82 77 42
      56 78 38 80 39 75 02 71 66 66 01 03 55 72
     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36
   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52
  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15
27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93`
 
func main() {
    lines := strings.Split(t, ""\n"")
    f := strings.Fields(lines[len(lines)-1])
    d := make([]int, len(f))
    var err error
    for i, s := range f {
        if d[i], err = strconv.Atoi(s); err != nil {
            panic(err)
        }
    }
    d1 := d[1:]
    var l, r, u int
    for row := len(lines) - 2; row >= 0; row-- {
        l = d[0]
        for i, s := range strings.Fields(lines[row]) {
            if u, err = strconv.Atoi(s); err != nil {
                panic(err)
            }
            if r = d1[i]; l > r {
                d[i] = u + l
            } else {
                d[i] = u + r
            }
            l = r
        }
    }
    fmt.Println(d[0])
}",1512,55
35789,http://rosettacode.org/wiki/Mastermind,Mastermind,"Create a simple version of the board game:   Mastermind.

It must be possible to:

   choose the number of colors will be used in the game (2 - 20)
   choose the color code length (4 - 10)
   choose the maximum number of guesses the player has (7 - 20)
   choose whether or not colors may be repeated in the code


The (computer program) game should display all the player guesses and the results of that guess.

Display (just an idea):



 Feature 
 Graphic Version 
 Text Version


 Player guess

 Colored circles

 Alphabet letters


Correct color & position

Black circle

X


Correct color

White circle

O


None

Gray circle

 -




A text version example:        1.   ADEF   -   XXO- 

Translates to:

the first guess;

the four colors (ADEF);

result:

 two correct colors and spot, 
 one correct color/wrong spot, one color isn't in the code.
Happy coding!



Related tasks

   Bulls and cows
   Bulls and cows/Player
   Guess the number
   Guess the number/With Feedback

",#Go,Go,"package main
 
import (
	""errors""
	""flag""
	""fmt""
	""log""
	""math/rand""
	""strings""
	""time""
)
 
func main() {
	log.SetPrefix(""mastermind: "")
	log.SetFlags(0)
	colours := flag.Int(""colours"", 6, ""number of colours to use (2-20)"")
	flag.IntVar(colours, ""colors"", 6, ""alias for colours"")
	holes := flag.Int(""holes"", 4, ""number of holes (the code length, 4-10)"")
	guesses := flag.Int(""guesses"", 12, ""number of guesses allowed (7-20)"")
	unique := flag.Bool(""unique"", false, ""disallow duplicate colours in the code"")
	flag.Parse()
 
	rand.Seed(time.Now().UnixNano())
	m, err := NewMastermind(*colours, *holes, *guesses, *unique)
	if err != nil {
		log.Fatal(err)
	}
	err = m.Play()
	if err != nil {
		log.Fatal(err)
	}
}
 
type mastermind struct {
	colours int
	holes   int
	guesses int
	unique  bool
 
	code   string
	past   []string // history of guesses
	scores []string // history of scores
}
 
func NewMastermind(colours, holes, guesses int, unique bool) (*mastermind, error) {
	if colours < 2 || colours > 20 {
		return nil, errors.New(""colours must be between 2 and 20 inclusive"")
	}
	if holes < 4 || holes > 10 {
		return nil, errors.New(""holes must be between 4 and 10 inclusive"")
	}
	if guesses < 7 || guesses > 20 {
		return nil, errors.New(""guesses must be between 7 and 20 inclusive"")
	}
	if unique && holes > colours {
		return nil, errors.New(""holes must be > colours when using unique"")
	}
 
	return &mastermind{
		colours: colours,
		holes:   holes,
		guesses: guesses,
		unique:  unique,
		past:    make([]string, 0, guesses),
		scores:  make([]string, 0, guesses),
	}, nil
}
 
func (m *mastermind) Play() error {
	m.generateCode()
	fmt.Printf(""A set of %s has been selected as the code.\n"", m.describeCode(m.unique))
	fmt.Printf(""You have %d guesses.\n"", m.guesses)
	for len(m.past) < m.guesses {
		guess, err := m.inputGuess()
		if err != nil {
			return err
		}
		fmt.Println()
		m.past = append(m.past, guess)
		str, won := m.scoreString(m.score(guess))
		if won {
			plural := ""es""
			if len(m.past) == 1 {
				plural = """"
			}
			fmt.Printf(""You found the code in %d guess%s.\n"", len(m.past), plural)
			return nil
		}
		m.scores = append(m.scores, str)
		m.printHistory()
		fmt.Println()
	}
	fmt.Printf(""You are out of guesses. The code was %s.\n"", m.code)
	return nil
}
 
const charset = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
const blacks = ""XXXXXXXXXX""
const whites = ""OOOOOOOOOO""
const nones = ""----------""
 
func (m *mastermind) describeCode(unique bool) string {
	ustr := """"
	if unique {
		ustr = "" unique""
	}
	return fmt.Sprintf(""%d%s letters (from 'A' to %q)"",
		m.holes, ustr, charset[m.colours-1],
	)
}
 
func (m *mastermind) printHistory() {
	for i, g := range m.past {
		fmt.Printf(""-----%s---%[1]s--\n"", nones[:m.holes])
		fmt.Printf(""%2d:  %s : %s\n"", i+1, g, m.scores[i])
	}
}
 
func (m *mastermind) generateCode() {
	code := make([]byte, m.holes)
	if m.unique {
		p := rand.Perm(m.colours)
		for i := range code {
			code[i] = charset[p[i]]
		}
	} else {
		for i := range code {
			code[i] = charset[rand.Intn(m.colours)]
		}
	}
	m.code = string(code)
	//log.Printf(""code is %q"", m.code)
}
 
func (m *mastermind) inputGuess() (string, error) {
	var input string
	for {
		fmt.Printf(""Enter guess #%d: "", len(m.past)+1)
		if _, err := fmt.Scanln(&input); err != nil {
			return """", err
		}
		input = strings.ToUpper(strings.TrimSpace(input))
		if m.validGuess(input) {
			return input, nil
		}
		fmt.Printf(""A guess must consist of %s.\n"", m.describeCode(false))
	}
}
 
func (m *mastermind) validGuess(input string) bool {
	if len(input) != m.holes {
		return false
	}
	for i := 0; i < len(input); i++ {
		c := input[i]
		if c < 'A' || c > charset[m.colours-1] {
			return false
		}
	}
	return true
}
 
func (m *mastermind) score(guess string) (black, white int) {
	scored := make([]bool, m.holes)
	for i := 0; i < len(guess); i++ {
		if guess[i] == m.code[i] {
			black++
			scored[i] = true
		}
	}
	for i := 0; i < len(guess); i++ {
		if guess[i] == m.code[i] {
			continue
		}
		for j := 0; j < len(m.code); j++ {
			if i != j && !scored[j] && guess[i] == m.code[j] {
				white++
				scored[j] = true
			}
		}
	}
	return
}
 
func (m *mastermind) scoreString(black, white int) (string, bool) {
	none := m.holes - black - white
	return blacks[:black] + whites[:white] + nones[:none], black == m.holes
}",4321,188
35835,http://rosettacode.org/wiki/Matrix-exponentiation_operator,Matrix-exponentiation operator,"Most programming languages have a built-in implementation of exponentiation for integers and reals only.



Task

Demonstrate how to implement matrix exponentiation as an operator.



",#Go,Go,"package main
 
import ""fmt""
 
type vector = []float64
type matrix []vector
 
func (m1 matrix) mul(m2 matrix) matrix {
    rows1, cols1 := len(m1), len(m1[0])
    rows2, cols2 := len(m2), len(m2[0])
    if cols1 != rows2 {
        panic(""Matrices cannot be multiplied."")
    }
    result := make(matrix, rows1)
    for i := 0; i < rows1; i++ {
        result[i] = make(vector, cols2)
        for j := 0; j < cols2; j++ {
            for k := 0; k < rows2; k++ {
                result[i][j] += m1[i][k] * m2[k][j]
            }
        }
    }
    return result
}
 
func identityMatrix(n int) matrix {
    if n < 1 {
        panic(""Size of identity matrix can't be less than 1"")
    }
    ident := make(matrix, n)
    for i := 0; i < n; i++ {
        ident[i] = make(vector, n)
        ident[i][i] = 1
    }
    return ident
}
 
func (m matrix) pow(n int) matrix {
    le := len(m)
    if le != len(m[0]) {
        panic(""Not a square matrix"")
    }
    switch {
    case n < 0:
        panic(""Negative exponents not supported"")
    case n == 0:
        return identityMatrix(le)
    case n == 1:
        return m
    }
    pow := identityMatrix(le)
    base := m
    e := n
    for e > 0 {
        if (e & 1) == 1 {
            pow = pow.mul(base)
        }
        e >>= 1
        base = base.mul(base)
    }
    return pow
}
 
func main() {
    m := matrix{{3, 2}, {2, 1}}
    for i := 0; i <= 10; i++ {
        fmt.Println(""** Power of"", i, ""**"")
        fmt.Println(m.pow(i))
        fmt.Println()
    }
}",1509,71
35911,http://rosettacode.org/wiki/Make_directory_path,Make directory path,"Task

Create a directory and any missing parents.

This task is named after the posix mkdir -p command, and several libraries which implement the same behavior.

Please implement a function of a single path string (for example ./path/to/dir) which has the above side-effect.
If the directory already exists, return successfully.
Ideally implementations will work equally well cross-platform (on windows, linux, and OS X).

It's likely that your language implements such a function as part of its standard library. If so, please also show how such a function would be implemented.



",#Go,Go,"	os.MkdirAll(""/tmp/some/path/to/dir"", 0770)",43,1
35936,http://rosettacode.org/wiki/Magic_constant,Magic constant,"A magic square is a square grid containing consecutive integers from 1 to N², arranged so that every row, column and diagonal adds up to the same number. That number is a constant. There is no way to create a valid N x N magic square that does not sum to the associated constant.

EG
A 3 x 3 magic square always sums to 15.

    ┌───┬───┬───┐
    │ 2 │ 7 │ 6 │
    ├───┼───┼───┤
    │ 9 │ 5 │ 1 │
    ├───┼───┼───┤
    │ 4 │ 3 │ 8 │
    └───┴───┴───┘
A 4 x 4 magic square always sums to 34.

Traditionally, the sequence leaves off terms for n = 0 and n = 1 as the magic squares of order 0 and 1 are trivial; and a term for n = 2 because it is impossible to form a magic square of order 2.



Task
 Starting at order 3, show the first 20 magic constants.
 Show the 1000th magic constant. (Order 1003)
 Find and show the order of the smallest N x N magic square whose constant is greater than 10¹ through 10¹⁰.


Stretch
 Find and show the order of the smallest N x N magic square whose constant is greater than 10¹¹ through 10²⁰.


See also
 Wikipedia: Magic constant
 OEIS: A006003 (Similar sequence, though it includes terms for 0, 1 & 2.)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""rcu""
)
 
func magicConstant(n int) int {
    return (n*n + 1) * n / 2
}
 
var ss = []string{
    ""\u2070"", ""\u00b9"", ""\u00b2"", ""\u00b3"", ""\u2074"",
    ""\u2075"", ""\u2076"", ""\u2077"", ""\u2078"", ""\u2079"",
}
 
func superscript(n int) string {
    if n < 10 {
        return ss[n]
    }
    if n < 20 {
        return ss[1] + ss[n-10]
    }
    return ss[2] + ss[0]
}
 
func main() {
    fmt.Println(""First 20 magic constants:"")
    for n := 3; n <= 22; n++ {
        fmt.Printf(""%5d "", magicConstant(n))
        if (n-2)%10 == 0 {
            fmt.Println()
        }
    }
 
    fmt.Println(""\n1,000th magic constant:"", rcu.Commatize(magicConstant(1002)))
 
    fmt.Println(""\nSmallest order magic square with a constant greater than:"")
    for i := 1; i <= 20; i++ {
        goal := math.Pow(10, float64(i))
        order := int(math.Cbrt(goal*2)) + 1
        fmt.Printf(""10%-2s : %9s\n"", superscript(i), rcu.Commatize(order))
    }
}",980,45
35945,http://rosettacode.org/wiki/Main_step_of_GOST_28147-89,Main step of GOST 28147-89,"GOST 28147-89 is a standard symmetric encryption based on a Feistel network.



The structure of the algorithm consists of three levels:

   encryption modes - simple replacement, application range, imposing a range of feedback and authentication code generation;
   cycles - 32-З, 32-Р and 16-З, is a repetition of the main step;
   main step, a function that takes a 64-bit block of text and one of the eight 32-bit encryption key elements, and uses the replacement table (8x16 matrix of 4-bit values), and returns encrypted block.


Task

Implement the main step of this encryption algorithm.



",#Go,Go,"package main
 
import ""fmt""
 
type sBox [8][16]byte
 
type gost struct {
    k87, k65, k43, k21 [256]byte
    enc                []byte
}
 
func newGost(s *sBox) *gost {
    var g gost
    for i := range g.k87 {
        g.k87[i] = s[7][i>>4]<<4 | s[6][i&15]
        g.k65[i] = s[5][i>>4]<<4 | s[4][i&15]
        g.k43[i] = s[3][i>>4]<<4 | s[2][i&15]
        g.k21[i] = s[1][i>>4]<<4 | s[0][i&15]
    }
    g.enc = make([]byte, 8)
    return &g
}
 
func (g *gost) f(x uint32) uint32 {
    x = uint32(g.k87[x>>24&255])<<24 | uint32(g.k65[x>>16&255])<<16 |
        uint32(g.k43[x>>8&255])<<8 | uint32(g.k21[x&255])
    return x<<11 | x>>(32-11)
}
 
// code above adapted from posted C code
 
// validation code below follows example on talk page
 
// cbrf from WP
var cbrf = sBox{
    {4, 10, 9, 2, 13, 8, 0, 14, 6, 11, 1, 12, 7, 15, 5, 3},
    {14, 11, 4, 12, 6, 13, 15, 10, 2, 3, 8, 1, 0, 7, 5, 9},
    {5, 8, 1, 13, 10, 3, 4, 2, 14, 15, 12, 7, 6, 0, 9, 11},
    {7, 13, 10, 1, 0, 8, 9, 15, 14, 4, 6, 12, 11, 2, 5, 3},
    {6, 12, 7, 1, 5, 15, 13, 8, 4, 10, 9, 14, 0, 3, 11, 2},
    {4, 11, 10, 0, 7, 2, 1, 13, 3, 6, 8, 5, 9, 12, 15, 14},
    {13, 11, 4, 1, 3, 15, 5, 9, 0, 10, 14, 7, 6, 8, 2, 12},
    {1, 15, 13, 0, 5, 7, 10, 4, 9, 2, 3, 14, 6, 11, 8, 12},
}
 
func u32(b []byte) uint32 {
    return uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24
}
 
func b4(u uint32, b []byte) {
    b[0] = byte(u)
    b[1] = byte(u >> 8)
    b[2] = byte(u >> 16)
    b[3] = byte(u >> 24)
}
 
func (g *gost) mainStep(input []byte, key []byte) {
    key32 := u32(key)
    input1 := u32(input[:4])
    input2 := u32(input[4:])
    b4(g.f(key32+input1)^input2, g.enc[:4])
    copy(g.enc[4:], input[:4])
}
 
func main() {
    input := []byte{0x21, 0x04, 0x3B, 0x04, 0x30, 0x04, 0x32, 0x04}
    key := []byte{0xF9, 0x04, 0xC1, 0xE2}
 
    g := newGost(&cbrf)
    g.mainStep(input, key)
    for _, b := range g.enc {
        fmt.Printf(""[%02x]"", b)
    }
    fmt.Println()
}",1976,75
35979,http://rosettacode.org/wiki/Magnanimous_numbers,Magnanimous numbers,"A magnanimous number is an integer where there is no place in the number where a + (plus sign) could be added between any two digits to give a non-prime sum.



E.G.
 6425 is a magnanimous number. 6 + 425 == 431 which is prime; 64 + 25 == 89 which is prime; 642 + 5 == 647 which is prime.
 3538 is not a magnanimous number. 3 + 538 == 541 which is prime; 35 + 38 == 73 which is prime; but 353 + 8 == 361 which is not prime.


Traditionally the single digit numbers 0 through 9 are included as magnanimous numbers as there is no place in the number where you can add a plus between two digits at all. (Kind of weaselly but there you are...) Except for the actual value 0, leading zeros are not permitted. Internal zeros are fine though, 1001 -> 1 + 001 (prime), 10 + 01 (prime) 100 + 1 (prime).

There are only 571 known magnanimous numbers. It is strongly suspected, though not rigorously proved, that there are no magnanimous numbers above 97393713331910, the largest one known.



Task
 Write a routine (procedure, function, whatever) to find magnanimous numbers. 
 Use that function to find and display, here on this page the first 45 magnanimous numbers.
 Use that function to find and display, here on this page the 241st through 250th magnanimous numbers.
 Stretch: Use that function to find and display, here on this page the 391st through 400th magnanimous numbers


See also
 OEIS:A252996 - Magnanimous numbers: numbers such that the sum obtained by inserting a ""+"" anywhere between two digits gives a prime.

",#Go,Go,"package main
 
import ""fmt""
 
// OK for 'small' numbers.
func isPrime(n uint64) bool {
    switch {
    case n < 2:
        return false
    case n%2 == 0:
        return n == 2
    case n%3 == 0:
        return n == 3
    default:
        d := uint64(5)
        for d*d <= n {
            if n%d == 0 {
                return false
            }
            d += 2
            if n%d == 0 {
                return false
            }
            d += 4
        }
        return true
    }
}
 
func ord(n int) string {
    m := n % 100
    if m >= 4 && m <= 20 {
        return fmt.Sprintf(""%dth"", n)
    }
    m %= 10
    suffix := ""th""
    if m < 4 {
        switch m {
        case 1:
            suffix = ""st""
        case 2:
            suffix = ""nd""
        case 3:
            suffix = ""rd""
        }
    }
    return fmt.Sprintf(""%d%s"", n, suffix)
}
 
func isMagnanimous(n uint64) bool {
    if n < 10 {
        return true
    }
    for p := uint64(10); ; p *= 10 {
        q := n / p
        r := n % p
        if !isPrime(q + r) {
            return false
        }
        if q < 10 {
            break
        }
    }
    return true
}
 
func listMags(from, thru, digs, perLine int) {
    if from < 2 {
        fmt.Println(""\nFirst"", thru, ""magnanimous numbers:"")
    } else {
        fmt.Printf(""\n%s through %s magnanimous numbers:\n"", ord(from), ord(thru))
    }
    for i, c := uint64(0), 0; c < thru; i++ {
        if isMagnanimous(i) {
            c++
            if c >= from {
                fmt.Printf(""%*d "", digs, i)
                if c%perLine == 0 {
                    fmt.Println()
                }
            }
        }
    }
}
 
func main() {
    listMags(1, 45, 3, 15)
    listMags(241, 250, 1, 10)
    listMags(391, 400, 1, 10)
}",1766,90
36020,http://rosettacode.org/wiki/MD5,MD5,"Task

Encode a string using an MD5 algorithm.   The algorithm can be found on   Wikipedia.



Optionally, validate your implementation by running all of the test values in   IETF RFC (1321)   for MD5.

Additionally,   RFC 1321   provides more precise information on the algorithm than the Wikipedia article.



 Warning:   MD5 has known weaknesses, including collisions and forged signatures.   Users may consider a stronger alternative when doing production-grade cryptography, such as SHA-256 (from the SHA-2 family), or the upcoming SHA-3.

If the solution on this page is a library solution, see   MD5/Implementation   for an implementation from scratch.



",#Go,Go,"package main
 
import (
    ""crypto/md5""
    ""fmt""
)
 
func main() {
    for _, p := range [][2]string{
        // RFC 1321 test cases
        {""d41d8cd98f00b204e9800998ecf8427e"", """"},
        {""0cc175b9c0f1b6a831c399e269772661"", ""a""},
        {""900150983cd24fb0d6963f7d28e17f72"", ""abc""},
        {""f96b697d7cb7938d525a2f31aaf161d0"", ""message digest""},
        {""c3fcd3d76192e4007dfb496cca67e13b"", ""abcdefghijklmnopqrstuvwxyz""},
        {""d174ab98d277d9f5a5611c2c9f419d9f"",
            ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789""},
        {""57edf4a22be3c955ac49da2e2107b67a"", ""12345678901234567890"" +
            ""123456789012345678901234567890123456789012345678901234567890""},
        // test case popular with other RC solutions
        {""e38ca1d920c4b8b8d3946b2c72f01680"",
            ""The quick brown fox jumped over the lazy dog's back""},
    } {
        validate(p[0], p[1])
    }
}
 
var h = md5.New()
 
func validate(check, s string) {
    h.Reset()
    h.Write([]byte(s))
    sum := fmt.Sprintf(""%x"", h.Sum(nil))
    if sum != check {
        fmt.Println(""MD5 fail"")
        fmt.Println(""  for string,"", s)
        fmt.Println(""  expected:  "", check)
        fmt.Println(""  got:       "", sum)
    }
}",1231,40
36051,http://rosettacode.org/wiki/Magic_squares_of_singly_even_order,Magic squares of singly even order,"A magic square is an NxN square matrix whose numbers consist of consecutive numbers arranged so that the sum of each row and column, and both diagonals are equal to the same sum (which is called the magic number or magic constant).

A magic square of singly even order has a size that is a multiple of 4, plus 2 (e.g. 6, 10, 14). This means that the subsquares have an odd size, which plays a role in the construction.




Task
Create a magic square of 6 x 6.




 Related tasks
 Magic squares of odd order
 Magic squares of doubly even order

 See also
 Singly Even Magic Squares (1728.org)


",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
)
 
func magicSquareOdd(n int) ([][]int, error) {
    if n < 3 || n%2 == 0 {
        return nil, fmt.Errorf(""base must be odd and > 2"")
    }
    value := 1
    gridSize := n * n
    c, r := n/2, 0
    result := make([][]int, n)
 
    for i := 0; i < n; i++ {
        result[i] = make([]int, n)
    }
 
    for value <= gridSize {
        result[r][c] = value
        if r == 0 {
            if c == n-1 {
                r++
            } else {
                r = n - 1
                c++
            }
        } else if c == n-1 {
            r--
            c = 0
        } else if result[r-1][c+1] == 0 {
            r--
            c++
        } else {
            r++
        }
        value++
    }
    return result, nil
}
 
func magicSquareSinglyEven(n int) ([][]int, error) {
    if n < 6 || (n-2)%4 != 0 {
        return nil, fmt.Errorf(""base must be a positive multiple of 4 plus 2"")
    }
    size := n * n
    halfN := n / 2
    subSquareSize := size / 4
    subSquare, err := magicSquareOdd(halfN)
    if err != nil {
        return nil, err
    }
    quadrantFactors := [4]int{0, 2, 3, 1}
    result := make([][]int, n)
 
    for i := 0; i < n; i++ {
        result[i] = make([]int, n)
    }
 
    for r := 0; r < n; r++ {
        for c := 0; c < n; c++ {
            quadrant := r/halfN*2 + c/halfN
            result[r][c] = subSquare[r%halfN][c%halfN]
            result[r][c] += quadrantFactors[quadrant] * subSquareSize
        }
    }
 
    nColsLeft := halfN / 2
    nColsRight := nColsLeft - 1
 
    for r := 0; r < halfN; r++ {
        for c := 0; c < n; c++ {
            if c < nColsLeft || c >= n-nColsRight ||
                (c == nColsLeft && r == nColsLeft) {
                if c == 0 && r == nColsLeft {
                    continue
                }
                tmp := result[r][c]
                result[r][c] = result[r+halfN][c]
                result[r+halfN][c] = tmp
            }
        }
    }
    return result, nil
}
 
func main() {
    const n = 6
    msse, err := magicSquareSinglyEven(n)
    if err != nil {
        log.Fatal(err)
    }
    for _, row := range msse {
        for _, x := range row {
            fmt.Printf(""%2d "", x)
        }
        fmt.Println()
    }
    fmt.Printf(""\nMagic constant: %d\n"", (n*n+1)*n/2)
}",2327,102
36205,http://rosettacode.org/wiki/Magic_squares_of_doubly_even_order,Magic squares of doubly even order,"A magic square is an   N×N  square matrix whose numbers consist of consecutive numbers arranged so that the sum of each row and column,   and   both diagonals are equal to the same sum   (which is called the magic number or magic constant).

A magic square of doubly even order has a size that is a multiple of four   (e.g.     4, 8, 12).

This means that the subsquares also have an even size, which plays a role in the construction.



1
2
62
61
60
59
7
8


9
10
54
53
52
51
15
16


48
47
19
20
21
22
42
41


40
39
27
28
29
30
34
33


32
31
35
36
37
38
26
25


24
23
43
44
45
46
18
17


49
50
14
13
12
11
55
56


57
58
6
5
4
3
63
64



Task
Create a magic square of   8 × 8.



Related tasks
 Magic squares of odd order
 Magic squares of singly even order



See also

 Doubly Even Magic Squares (1728.org)

",#Go,Go,"package main
 
import (
	""fmt""
	""log""
	""strings""
)
 
const dimensions int = 8
 
func setupMagicSquareData(d int) ([][]int, error) {
	var output [][]int
	if d < 4 || d%4 != 0 {
		return [][]int{}, fmt.Errorf(""Square dimension must be a positive number which is divisible by 4"")
	}
	var bits uint = 0x9669 // 0b1001011001101001
	size := d * d
	mult := d / 4
	for i, r := 0, 0; r < d; r++ {
		output = append(output, []int{})
		for c := 0; c < d; i, c = i+1, c+1 {
			bitPos := c/mult + (r/mult)*4
			if (bits & (1 << uint(bitPos))) != 0 {
				output[r] = append(output[r], i+1)
			} else {
				output[r] = append(output[r], size-i)
			}
		}
	}
	return output, nil
}
 
func arrayItoa(input []int) []string {
	var output []string
	for _, i := range input {
		output = append(output, fmt.Sprintf(""%4d"", i))
	}
	return output
}
 
func main() {
	data, err := setupMagicSquareData(dimensions)
	if err != nil {
		log.Fatal(err)
	}
	magicConstant := (dimensions * (dimensions*dimensions + 1)) / 2
	for _, row := range data {
		fmt.Println(strings.Join(arrayItoa(row), "" ""))
	}
	fmt.Printf(""\nMagic Constant: %d\n"", magicConstant)
}
 ",1123,52
36281,http://rosettacode.org/wiki/Maze_generation,Maze generation,"

 This page uses content from Wikipedia. The original article was at Maze generation algorithm. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)




Task

Generate and show a maze, using the simple Depth-first search algorithm.

Start at a random cell.
Mark the current cell as visited, and get a list of its neighbors. For each neighbor, starting with a randomly selected neighbor:
If that neighbor hasn't been visited, remove the wall between this cell and that neighbor, and then recurse with that neighbor as the current cell.


 Related tasks
 Maze solving.

",#Go,Go,"package main
 
import (
    ""bytes""
    ""fmt""
    ""math/rand""
    ""time""
)   
 
type maze struct { 
    c  []byte   // cell contents
    h  []byte   // horizontal walls above cells
    v  []byte   // vertical walls to the left of cells
    c2 [][]byte // cells by row
    h2 [][]byte // horizontal walls by row (ignore first row)
    v2 [][]byte // vertical walls by row (ignore first of each column)
}
 
func newMaze(rows, cols int) *maze {
    c := make([]byte, rows*cols)              // all cells
    h := bytes.Repeat([]byte{'-'}, rows*cols) // all horizontal walls
    v := bytes.Repeat([]byte{'|'}, rows*cols) // all vertical walls
    c2 := make([][]byte, rows)                // cells by row
    h2 := make([][]byte, rows)                // horizontal walls by row
    v2 := make([][]byte, rows)                // vertical walls by row
    for i := range h2 {
        c2[i] = c[i*cols : (i+1)*cols]
        h2[i] = h[i*cols : (i+1)*cols]
        v2[i] = v[i*cols : (i+1)*cols]
    }
    return &maze{c, h, v, c2, h2, v2}
}
 
func (m *maze) String() string {
    hWall := []byte(""+---"")
    hOpen := []byte(""+   "")
    vWall := []byte(""|   "")
    vOpen := []byte(""    "")
    rightCorner := []byte(""+\n"") 
    rightWall := []byte(""|\n"")
    var b []byte
    // for all rows 
    for r, hw := range m.h2 {
        // draw h walls
        for _, h := range hw { 
            if h == '-' || r == 0 {
                b = append(b, hWall...)
            } else {
                b = append(b, hOpen...)
            }
        }
        b = append(b, rightCorner...)
        // draw v walls
        for c, vw := range m.v2[r] {
            if vw == '|' || c == 0 {
                b = append(b, vWall...)
            } else {
                b = append(b, vOpen...)
            }
            // draw cell contents
            if m.c2[r][c] != 0 {
                b[len(b)-2] = m.c2[r][c]
            }
        }
        b = append(b, rightWall...)
    }
    // draw bottom edge of maze
    for _ = range m.h2[0] {
        b = append(b, hWall...)
    }
    b = append(b, rightCorner...)
    return string(b)
}
 
func (m *maze) gen() {
    m.g2(rand.Intn(len(m.c2)), rand.Intn(len(m.c2[0])))
}
 
const (
    up = iota
    dn
    rt
    lf
)
 
func (m *maze) g2(r, c int) {
    m.c2[r][c] = ' '
    for _, dir := range rand.Perm(4) {
        switch dir {
        case up:
            if r > 0 && m.c2[r-1][c] == 0 {
                m.h2[r][c] = 0
                m.g2(r-1, c)
            }
        case lf:
            if c > 0 && m.c2[r][c-1] == 0 {
                m.v2[r][c] = 0
                m.g2(r, c-1)
            }
        case dn:
            if r < len(m.c2)-1 && m.c2[r+1][c] == 0 {
                m.h2[r+1][c] = 0
                m.g2(r+1, c)
            }
        case rt:
            if c < len(m.c2[0])-1 && m.c2[r][c+1] == 0 {
                m.v2[r][c+1] = 0
                m.g2(r, c+1)
            }
        }
    }
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    m := newMaze(4, 6)
    m.gen()
    fmt.Print(m)
}",3043,119
36293,http://rosettacode.org/wiki/Man_or_boy_test,Man or boy test,"Man or boy test

You are encouraged to solve this task according to the task description, using any language you may know.

Background: The man or boy test was proposed by computer scientist Donald Knuth as a means of evaluating implementations of the ALGOL 60 programming language. The aim of the test was to distinguish compilers that correctly implemented ""recursion and non-local references"" from those that did not.


I have written the following simple routine, which may separate the 'man-compilers' from the 'boy-compilers'
 — Donald Knuth
Task: Imitate Knuth's example in Algol 60 in another language, as far as possible.

Details: Local variables of routines are often kept in activation records (also call frames). In many languages, these records are kept on a call stack. In Algol (and e.g. in Smalltalk), they are allocated on a heap instead. Hence it is possible to pass references to routines that still can use and update variables from their call environment, even if the routine where those variables are declared already returned. This difference in implementations is sometimes called the Funarg Problem.

In Knuth's example, each call to A allocates an activation record for the variable A. When B is called from A, any access to k now refers to this activation record. Now B in turn calls A, but passes itself as an argument. This argument remains bound to the activation record. This call to A also ""shifts"" the variables xi by one place, so eventually the argument B (still bound to its particular
activation record) will appear as x4 or x5 in a call to A. If this happens when the expression x4 + x5 is evaluated, then this will again call B, which in turn will update k in the activation record it was originally bound to. As this activation record is shared with other instances of calls to A and B, it will influence the whole computation.

So all the example does is to set up a convoluted calling structure, where updates to k can influence the behavior
in completely different parts of the call tree.

Knuth used this to test the correctness of the compiler, but one can of course also use it to test that other languages can emulate the Algol behavior correctly. If the handling of activation records is correct, the computed value will be −67.

Performance and Memory: Man or Boy is intense and can be pushed to challenge any machine. Memory (both stack and heap) not CPU time is the constraining resource as the recursion creates a proliferation activation records which will quickly exhaust memory and present itself through a stack error. Each language may have ways of adjusting the amount of memory or increasing the recursion depth. Optionally, show how you would make such adjustments.

The table below shows the result, call depths, and total calls for a range of k:



 k

 0

 1

 2

 3

 4

 5

 6

 7

 8

 9

 10

 11

 12

 13

 14

 15

 16

 17

 18

 19

 20

 21

 22

 23

 24

 25

 26

 27

 28

 29

 30


 A

 1

 0

 -2

 0

 1

 0

 1

 -1

 -10

 -30

 -67

 -138

 -291

 -642

 -1,446

 -3,250

 -7,244

 -16,065

 -35,601

 -78,985

 -175,416

 -389,695

 -865,609

 -1,922,362

 -4,268,854

 -9,479,595

 -21,051,458

 -46,750,171

 -103,821,058

 -230,560,902

 -512,016,658


 A called

 1

 2

 3

 4

 8

 18

 38

 80

 167

 347

 722

 1,509

 3,168

 6,673

 14,091

 29,825

 63,287

 134,652

 287,264

 614,442

 1,317,533

 2,831,900

 6,100,852

 13,172,239

 28,499,827

 61,786,266

 134,202,509

 292,011,464

 

 

 


 A depth

 1

 2

 3

 4

 8

 16

 32

 64

 128

 256

 512

 1,024

 2,048

 4,096

 8,192

 16,384

 32,768

 65,536

 131,072

 262,144

 524,288

 1,048,576

 2,097,152

 4,194,304

 8,388,608

 

 

 

 

 

 


 B called

 0

 1

 2

 3

 7

 17

 37

 79

 166

 346

 721

 1,508

 3,167

 6,672

 14,090

 29,824

 63,286

 134,651

 287,263

 614,441

 1,317,532

 2,831,899

 6,100,851

 13,172,238

 28,499,826

 

 

 

 

 

 


 B depth

 0

 1

 2

 3

 7

 15

 31

 63

 127

 255

 511

 1,023

 2,047

 4,095

 8,191

 16,383

 32,767

 65,535

 131,071

 262,143

 524,287

 1,048,575

 2,097,151

 4,194,303

 8,388,607

 

 

 

 

 

 



Related tasks

   Jensen's Device

",#Go,Go,"package main
import ""fmt""
 
func a(k int, x1, x2, x3, x4, x5 func() int) int {
	var b func() int
	b = func() int {
		k--
		return a(k, b, x1, x2, x3, x4)
	}
	if k <= 0 {
		return x4() + x5()
	}
	return b()
}
 
func main() {
	x := func(i int) func() int { return func() int { return i } }
	fmt.Println(a(10, x(1), x(-1), x(-1), x(1), x(0)))
}",341,19
36298,http://rosettacode.org/wiki/Map_range,Map range,"Given two ranges:

   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}

   and 
   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}

; 
   then a value   



s


{\displaystyle s}

   in range   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}


   is linearly mapped to a value   



t


{\displaystyle t}

   in range   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}


   where:



   



t
=

b

1


+



(
s
−

a

1


)
(

b

2


−

b

1


)


(

a

2


−

a

1


)





{\displaystyle t=b_{1}+{(s-a_{1})(b_{2}-b_{1}) \over (a_{2}-a_{1})}}




Task

Write a function/subroutine/... that takes two ranges and a real number, and returns the mapping of the real number from the first to the second range.

Use this function to map values from the range    [0, 10]    to the range    [-1, 0]. 



Extra credit

Show additional idiomatic ways of performing the mapping, using tools available to the language.



",#Go,Go," 
include ""NSLog.incl""
 
local fn MapRange( s as double, a1 as double, a2 as double, b1 as double, b2 as double ) as double
end fn = b1+(s-a1)*(b2-b1)/(a2-a1)
 
NSInteger i
 
for i = 0 to 10
NSLog( @""%2d maps to %5.1f"", i, fn MapRange( i, 0, 10, -1, 0 ) )
next
 
HandleEvents
 ",277,14
36299,http://rosettacode.org/wiki/Map_range,Map range,"Given two ranges:

   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}

   and 
   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}

; 
   then a value   



s


{\displaystyle s}

   in range   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}


   is linearly mapped to a value   



t


{\displaystyle t}

   in range   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}


   where:



   



t
=

b

1


+



(
s
−

a

1


)
(

b

2


−

b

1


)


(

a

2


−

a

1


)





{\displaystyle t=b_{1}+{(s-a_{1})(b_{2}-b_{1}) \over (a_{2}-a_{1})}}




Task

Write a function/subroutine/... that takes two ranges and a real number, and returns the mapping of the real number from the first to the second range.

Use this function to map values from the range    [0, 10]    to the range    [-1, 0]. 



Extra credit

Show additional idiomatic ways of performing the mapping, using tools available to the language.



",#Go_2,Go,"package main
 
import ""fmt""
 
type rangeBounds struct {
    b1, b2 float64
}
 
func mapRange(x, y rangeBounds, n float64) float64 {
    return y.b1 + (n - x.b1) * (y.b2 - y.b1) / (x.b2 - x.b1)
}
 
func main() {
    r1 := rangeBounds{0, 10}
    r2 := rangeBounds{-1, 0}
    for n := float64(0); n <= 10; n += 2 {
        fmt.Println(n, ""maps to"", mapRange(r1, r2, n))
    }
}",374,19
36384,http://rosettacode.org/wiki/Magic_squares_of_odd_order,Magic squares of odd order,"A magic square is an   NxN   square matrix whose numbers (usually integers) consist of consecutive numbers arranged so that the sum of each row and column,   and   both long (main) diagonals are equal to the same sum (which is called the   magic number   or   magic constant).

The numbers are usually (but not always) the first   N2   positive integers.

A magic square whose rows and columns add up to a magic number but whose main diagonals do not, is known as a semimagic square.



 8 
 1 
 6


 3 
 5 
 7


 4 
 9 
 2



Task
For any odd   N,   generate a magic square with the integers    1 ──► N,   and show the results here.

Optionally, show the magic number.

You should demonstrate the generator by showing at least a magic square for   N = 5.



 Related tasks
 Magic squares of singly even order
 Magic squares of doubly even order



 See also

 MathWorld™ entry: Magic_square 
 Odd Magic Squares (1728.org)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
)
 
func ms(n int) (int, []int) {
    M := func(x int) int { return (x + n - 1) % n }
    if n <= 0 || n&1 == 0 {
        n = 5
        log.Println(""forcing size"", n)
    }
    m := make([]int, n*n)
    i, j := 0, n/2
    for k := 1; k <= n*n; k++ {
        m[i*n+j] = k
        if m[M(i)*n+M(j)] != 0 {
            i = (i + 1) % n
        } else {
            i, j = M(i), M(j)
        }
    }
    return n, m
}
 
func main() {
    n, m := ms(5)
    i := 2
    for j := 1; j <= n*n; j *= 10 {
        i++
    }
    f := fmt.Sprintf(""%%%dd"", i)
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            fmt.Printf(f, m[i*n+j])
        }
        fmt.Println()
    }
}",726,40
36519,http://rosettacode.org/wiki/Matrix_transposition,Matrix transposition,"Transpose an arbitrarily sized rectangular Matrix.



",#Go,Go,"package main
 
import (
    ""fmt""
 
    ""gonum.org/v1/gonum/mat""
)
 
func main() {
    m := mat.NewDense(2, 3, []float64{
        1, 2, 3,
        4, 5, 6,
    })
    fmt.Println(mat.Formatted(m))
    fmt.Println()
    fmt.Println(mat.Formatted(m.T()))
}",254,17
36526,http://rosettacode.org/wiki/Matrix_multiplication,Matrix multiplication,"Task

Multiply two matrices together.

They can be of any dimensions, so long as the number of columns of the first matrix is equal to the number of rows of the second matrix.



",#Go,Go,"package main
 
import (
    ""fmt""
 
    ""gonum.org/v1/gonum/mat""
)
 
func main() {
    a := mat.NewDense(2, 4, []float64{
        1, 2, 3, 4,
        5, 6, 7, 8,
    })
    b := mat.NewDense(4, 3, []float64{
        1, 2, 3,
        4, 5, 6,
        7, 8, 9,
        10, 11, 12,
    })
    var m mat.Dense
    m.Mul(a, b)
    fmt.Println(mat.Formatted(&m))
}",358,23
36662,http://rosettacode.org/wiki/Mandelbrot_set,Mandelbrot set,"Mandelbrot set

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Generate and draw the Mandelbrot set.



Note that there are many algorithms to draw Mandelbrot set and there are many functions which generate it .



",#Go,Go,"package main
 
import ""fmt""
import ""math/cmplx""
 
func mandelbrot(a complex128) (z complex128) {
    for i := 0; i < 50; i++ {
        z = z*z + a
    }
    return
}
 
func main() {
    for y := 1.0; y >= -1.0; y -= 0.05 {
        for x := -2.0; x <= 0.5; x += 0.0315 {
            if cmplx.Abs(mandelbrot(complex(x, y))) < 2 {
                fmt.Print(""*"")
            } else {
                fmt.Print("" "")
            }
        }
        fmt.Println("""")
    }
}",466,24
36835,http://rosettacode.org/wiki/MAC_Vendor_Lookup,MAC Vendor Lookup,"Every connected device around the world comes with a unique Media Access Control address, or a   MAC address.

A common task a network administrator may come across is being able to identify a network device's manufacturer when given only a MAC address.



Task

Interface with one (or numerous) APIs that exist on the internet and retrieve the device manufacturer based on a supplied MAC address.

A MAC address that does not return a valid result should return the String ""N/A"".   An error related to the network connectivity or the API should return a null result.

Many implementations on this page use http://api.macvendors.com/ which, as of 19th September 2021, is throttling requests. After only 2 calls, the following response is returned for all subsequent requests. If you are planning to use the same provider or going to run the examples on this page, consider building in a delay between two calls.

{""errors"":{""detail"":""Too Many Requests"",""message"":""Please slow down your requests or upgrade your plan at https://macvendors.com""}}
",#Go,Go,"package main
 
import (
	""net/http""
	""fmt""
	""io/ioutil""
)
 
func macLookUp(mac string) (res string){
	resp, _ := http.Get(""http://api.macvendors.com/"" + mac)
	body, _ := ioutil.ReadAll(resp.Body)
	res = string(body)
	return
}
 
func main()  {
	fmt.Println(macLookUp(""FC-A1-3E""))
	fmt.Println(macLookUp(""FC:FB:FB:01:FA:21""))
	fmt.Println(macLookUp(""BC:5F:F4""))
}
 ",363,21
36900,http://rosettacode.org/wiki/Machine_code,Machine code,"The task requires poking machine code directly into memory and executing it. The machine code is the architecture-specific opcodes which have the simple task of adding two unsigned bytes together and making the result available to the high-level language.

For example, the following assembly language program is given for x86 (32 bit) architectures:

mov EAX, [ESP+4]
add EAX, [ESP+8]
ret
This would translate into the following opcode bytes:

139 68 36 4 3 68 36 8 195
Or in hexadecimal:

8B 44 24 04 03 44 24 08 C3
Task

If different than 32-bit x86, specify the target architecture of the machine code for your example. It may be helpful to also include an assembly version of the machine code for others to reference and understand what is being executed. Then, implement the following in your favorite programming language:

 Poke the necessary opcodes into a memory location.
 Provide a means to pass two values to the machine code.
 Execute the machine code with the following arguments: unsigned-byte argument of value 7; unsigned-byte argument of value 12; The result would be 19.
 Perform any clean up actions that are appropriate for your chosen language (free the pointer or memory allocations, etc.)

",#Go,Go,"package main
 
import ""fmt""
 
/*
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <string.h>
 
typedef unsigned char byte;
typedef byte (*mcfunc) (byte, byte);
 
void runMachineCode(void *buf, byte a, byte b) {
    mcfunc fp = (mcfunc)buf;
    printf(""%d\n"", fp(a, b));
}
*/
import ""C""
 
func main() {
    code := []byte{
        0x55, 0x48, 0x89, 0xe5, 0x89, 0x7d,
        0xfc, 0x89, 0x75, 0xf8, 0x8b, 0x75,
        0xfc, 0x03, 0x75, 0xf8, 0x89, 0x75,
        0xf4, 0x8b, 0x45, 0xf4, 0x5d, 0xc3,
    }
    le := len(code)
    buf := C.mmap(nil, C.size_t(le), C.PROT_READ|C.PROT_WRITE|C.PROT_EXEC,
        C.MAP_PRIVATE|C.MAP_ANON, -1, 0)
    codePtr := C.CBytes(code)
    C.memcpy(buf, codePtr, C.size_t(le))
    var a, b byte = 7, 12
    fmt.Printf(""%d + %d = "", a, b)
    C.runMachineCode(buf, C.byte(a), C.byte(b))
    C.munmap(buf, C.size_t(le))
    C.free(codePtr)
}",894,38
36975,http://rosettacode.org/wiki/Magic_8-ball,Magic 8-ball,"Task

Create Magic 8-Ball.



See details at:   Magic 8-Ball.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
	""bufio""
	""bytes""
	""fmt""
	""log""
	""math/rand""
	""os""
	""time""
)
 
func main() {
	rand.Seed(time.Now().UnixNano())
	answers := [...]string{
		""It is certain"", ""It is decidedly so"", ""Without a doubt"",
		""Yes, definitely"", ""You may rely on it"", ""As I see it, yes"",
		""Most likely"", ""Outlook good"", ""Signs point to yes"", ""Yes"",
		""Reply hazy, try again"", ""Ask again later"",
		""Better not tell you now"", ""Cannot predict now"",
		""Concentrate and ask again"", ""Don't bet on it"",
		""My reply is no"", ""My sources say no"", ""Outlook not so good"",
		""Very doubtful"",
	}
	const prompt = ""\n? : ""
	fmt.Print(""Please enter your question or a blank line to quit.\n"" + prompt)
	sc := bufio.NewScanner(os.Stdin)
	for sc.Scan() {
		question := sc.Bytes()
		question = bytes.TrimSpace(question)
		if len(question) == 0 {
			break
		}
		answer := answers[rand.Intn(len(answers))]
		fmt.Printf(""\n%s\n""+prompt, answer)
	}
	if err := sc.Err(); err != nil {
		log.Fatal(err)
	}
}",975,40
37106,http://rosettacode.org/wiki/Lychrel_numbers,Lychrel numbers,"   Take an integer n, greater than zero.
   Form the next n of its series by reversing the digits of the current n and adding the result to the current n.
   Stop when n becomes palindromic - i.e. the digits of n in reverse order == n.


The above recurrence relation when applied to most starting numbers n = 1, 2, ... terminates in a palindrome quite quickly.



Example

If n0 = 12 we get

       12
       12 +  21 =  33,   a palindrome!

And if n0 = 55 we get

       55
       55 +  55 = 110
      110 + 011 = 121,   a palindrome!

Notice that the check for a palindrome happens   after   an addition.



Some starting numbers seem to go on forever; the recurrence relation for 196 has been calculated for millions of repetitions forming numbers with millions of digits, without forming a palindrome.

These numbers that do not end in a palindrome are called Lychrel numbers.

For the purposes of this task a Lychrel number is any starting number that does not form a palindrome within 500 (or more) iterations.



Seed and related Lychrel numbers

Any integer produced in the sequence of a Lychrel number is also a Lychrel number.

In general, any sequence from one Lychrel number might converge to join the sequence from a prior Lychrel number candidate; for example the sequences for the numbers 196 and then 689 begin:

        196
        196 +    691 =   887
        887 +    788 =  1675
       1675 +   5761 =  7436
       7436 +   6347 = 13783
      13783 +  38731 = 52514
      52514 +  41525 = 94039
       ...


        689
        689 +    986 =  1675
       1675 +   5761 =  7436
       ...

So we see that the sequence starting with 689 converges to, and continues with the same numbers as that for 196.

Because of this we can further split the Lychrel numbers into true Seed Lychrel number candidates, and Related numbers that produce no palindromes but have integers in their sequence seen as part of the sequence generated from a lower Lychrel number.



Task

   Find the number of seed Lychrel number candidates and related numbers for n in the range 1..10000 inclusive. (With that iteration limit of 500).
   Print the number of seed Lychrels found; the actual seed Lychrels; and just the number of relateds found.
   Print any seed Lychrel or related number that is itself a palindrome.


Show all output here.



References

   What's special about 196? Numberphile video.
   A023108 Positive integers which apparently never result in a palindrome under repeated applications of the function f(x) = x + (x with digits reversed).
   Status of the 196 conjecture? Mathoverflow.

",#Go,Go,"package main
 
import (
	""flag""
	""fmt""
	""math""
	""math/big""
	""os""
)
 
var maxRev = big.NewInt(math.MaxUint64 / 10) // approximate
var ten = big.NewInt(10)
 
// Reverse sets `result` to the value of the base ten digits of `v` in
// reverse order and returns `result`.
// Only handles positive integers.
func reverseInt(v *big.Int, result *big.Int) *big.Int {
	if v.Cmp(maxRev) <= 0 {
		// optimize small values that fit within uint64
		result.SetUint64(reverseUint64(v.Uint64()))
	} else {
		if true {
			// Reverse the string representation
			s := reverseString(v.String())
			result.SetString(s, 10)
		} else {
			// This has fewer allocations but is slower:
			// Use a copy of `v` since we mutate it.
			v := new(big.Int).Set(v)
			digit := new(big.Int)
			result.SetUint64(0)
			for v.BitLen() > 0 {
				v.QuoRem(v, ten, digit)
				result.Mul(result, ten)
				result.Add(result, digit)
			}
		}
	}
	return result
}
 
func reverseUint64(v uint64) uint64 {
	var r uint64
	for v > 0 {
		r *= 10
		r += v % 10
		v /= 10
	}
	return r
}
 
func reverseString(s string) string {
	b := make([]byte, len(s))
	for i, j := 0, len(s)-1; j >= 0; i, j = i+1, j-1 {
		b[i] = s[j]
	}
	return string(b)
}
 
var known = make(map[string]bool)
 
func Lychrel(n uint64, iter uint) (isLychrel, isSeed bool) {
	v, r := new(big.Int).SetUint64(n), new(big.Int)
	reverseInt(v, r)
	seen := make(map[string]bool)
	isLychrel = true
	isSeed = true
	for i := iter; i > 0; i-- {
		str := v.String()
		if seen[str] {
			//log.Println(""found a loop with"", n, ""at"", str)
			isLychrel = true
			break
		}
		if ans, ok := known[str]; ok {
			//log.Println(""already know:"", str, ans)
			isLychrel = ans
			isSeed = false
			break
		}
		seen[str] = true
 
		v = v.Add(v, r)
		//log.Printf(""%v + %v = %v\n"", str, r, v)
		reverseInt(v, r)
		if v.Cmp(r) == 0 {
			//log.Println(v, ""is a palindrome,"", n, ""is not a Lychrel number"")
			isLychrel = false
			isSeed = false
			break
		}
	}
	for k := range seen {
		known[k] = isLychrel
	}
	//if isLychrel { log.Printf(""%v may be a Lychrel number\n"", n) }
	return isLychrel, isSeed
}
 
func main() {
	max := flag.Uint64(""max"", 10000, ""search in the range 1..`N` inclusive"")
	iter := flag.Uint(""iter"", 500, ""limit palindrome search to `N` iterations"")
	flag.Parse()
	if flag.NArg() != 0 {
		flag.Usage()
		os.Exit(2)
	}
 
	fmt.Printf(""Calculating using n = 1..%v and %v iterations:\n"", *max, *iter)
	var seeds []uint64
	var related int
	var pals []uint64
	for i := uint64(1); i <= *max; i++ {
		if l, s := Lychrel(i, *iter); l {
			if s {
				seeds = append(seeds, i)
			} else {
				related++
			}
			if i == reverseUint64(i) {
				pals = append(pals, i)
			}
		}
	}
 
	fmt.Println(""      Number of Lychrel seeds:"", len(seeds))
	fmt.Println(""                Lychrel seeds:"", seeds)
	fmt.Println(""            Number of related:"", related)
	fmt.Println(""Number of Lychrel palindromes:"", len(pals))
	fmt.Println(""          Lychrel palindromes:"", pals)
}",2956,131
37117,http://rosettacode.org/wiki/Lucky_and_even_lucky_numbers,Lucky and even lucky numbers,"Note that in the following explanation list indices are assumed to start at one.

Definition of lucky numbers
Lucky numbers are positive integers that are formed by:

 Form a list of all the positive odd integers > 0




1
,
3
,
5
,
7
,
9
,
11
,
13
,
15
,
17
,
19
,
21
,
23
,
25
,
27
,
29
,
31
,
33
,
35
,
37
,
39...


{\displaystyle 1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39...}


 Return the first number from the list (which is 1).
 (Loop begins here)
 Note then return the second number from the list (which is 3).
 Discard every third, (as noted), number from the list to form the new list




1
,
3
,
7
,
9
,
13
,
15
,
19
,
21
,
25
,
27
,
31
,
33
,
37
,
39
,
43
,
45
,
49
,
51
,
55
,
57...


{\displaystyle 1,3,7,9,13,15,19,21,25,27,31,33,37,39,43,45,49,51,55,57...}


 (Expanding the loop a few more times...)
 Note then return the third number from the list (which is 7).
 Discard every 7th, (as noted), number from the list to form the new list




1
,
3
,
7
,
9
,
13
,
15
,
21
,
25
,
27
,
31
,
33
,
37
,
43
,
45
,
49
,
51
,
55
,
57
,
63
,
67...


{\displaystyle 1,3,7,9,13,15,21,25,27,31,33,37,43,45,49,51,55,57,63,67...}


 Note then return the 4th number from the list (which is 9).
 Discard every 9th, (as noted), number from the list to form the new list




1
,
3
,
7
,
9
,
13
,
15
,
21
,
25
,
31
,
33
,
37
,
43
,
45
,
49
,
51
,
55
,
63
,
67
,
69
,
73...


{\displaystyle 1,3,7,9,13,15,21,25,31,33,37,43,45,49,51,55,63,67,69,73...}


 Take the 5th, i.e. 13. Remove every 13th.
 Take the 6th, i.e. 15. Remove every 15th.
 Take the 7th, i.e. 21. Remove every 21th.
 Take the 8th, i.e. 25. Remove every 25th.
 (Rule for the loop)
 Note the 



n


{\displaystyle n}

th, which is 



m


{\displaystyle m}

.
 Remove every 



m


{\displaystyle m}

th.
 Increment 



n


{\displaystyle n}

.
Definition of even lucky numbers
This follows the same rules as the definition of lucky numbers above except for the very first step:

 Form a list of all the positive even integers > 0




2
,
4
,
6
,
8
,
10
,
12
,
14
,
16
,
18
,
20
,
22
,
24
,
26
,
28
,
30
,
32
,
34
,
36
,
38
,
40...


{\displaystyle 2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40...}


 Return the first number from the list (which is 2).
 (Loop begins here)
 Note then return the second number from the list (which is 4).
 Discard every 4th, (as noted), number from the list to form the new list




2
,
4
,
6
,
10
,
12
,
14
,
18
,
20
,
22
,
26
,
28
,
30
,
34
,
36
,
38
,
42
,
44
,
46
,
50
,
52...


{\displaystyle 2,4,6,10,12,14,18,20,22,26,28,30,34,36,38,42,44,46,50,52...}


 (Expanding the loop a few more times...)
 Note then return the third number from the list (which is 6).
 Discard every 6th, (as noted), number from the list to form the new list




2
,
4
,
6
,
10
,
12
,
18
,
20
,
22
,
26
,
28
,
34
,
36
,
38
,
42
,
44
,
50
,
52
,
54
,
58
,
60...


{\displaystyle 2,4,6,10,12,18,20,22,26,28,34,36,38,42,44,50,52,54,58,60...}


 Take the 4th, i.e. 10. Remove every 10th.
 Take the 5th, i.e. 12. Remove every 12th.
 (Rule for the loop)
 Note the 



n


{\displaystyle n}

th, which is 



m


{\displaystyle m}

.
 Remove every 



m


{\displaystyle m}

th.
 Increment 



n


{\displaystyle n}

.
Task requirements
 Write one or two subroutines (functions) to generate lucky numbers and even lucky numbers 
 Write a command-line interface to allow selection of which kind of numbers and which number(s). Since input is from the command line, tests should be made for the common errors:
 missing arguments
 too many arguments
 number (or numbers) aren't legal
 misspelled argument (lucky or evenLucky)
 The command line handling should:
 support mixed case handling of the (non-numeric) arguments
 support printing a particular number
 support printing a range of numbers by their index
 support printing a range of numbers by their values
 The resulting list of numbers should be printed on a single line.

The program should support the arguments:

                             what is displayed  (on a single line)
       argument(s)              (optional verbiage is encouraged)
  ╔═══════════════════╦════════════════════════════════════════════════════╗
  ║  j                ║  Jth       lucky number                            ║
  ║  j  ,      lucky  ║  Jth       lucky number                            ║
  ║  j  ,  evenLucky  ║  Jth  even lucky number                            ║
  ║                   ║                                                    ║
  ║  j  k             ║  Jth  through  Kth (inclusive)       lucky numbers ║
  ║  j  k      lucky  ║  Jth  through  Kth (inclusive)       lucky numbers ║
  ║  j  k  evenLucky  ║  Jth  through  Kth (inclusive)  even lucky numbers ║
  ║                   ║                                                    ║
  ║  j -k             ║  all       lucky numbers in the range  j ──► |k|   ║
  ║  j -k      lucky  ║  all       lucky numbers in the range  j ──► |k|   ║
  ║  j -k  evenLucky  ║  all  even lucky numbers in the range  j ──► |k|   ║
  ╚═══════════════════╩════════════════════════════════════════════════════╝
                           where    |k|    is the absolute value of   k

Demonstrate the program by:

 showing the first twenty lucky numbers
 showing the first twenty even lucky numbers
 showing all lucky numbers between 6,000 and 6,100 (inclusive)
 showing all even lucky numbers in the same range as above
 showing the 10,000th lucky number (extra credit)
 showing the 10,000th even lucky number (extra credit)
See also

 This task is related to the Sieve of Eratosthenes task.
 OEIS Wiki Lucky numbers.
 Sequence A000959 lucky numbers on The On-Line Encyclopedia of Integer Sequences.
 Sequence A045954 even lucky numbers or ELN on The On-Line Encyclopedia of Integer Sequences.
 Entry lucky numbers on The Eric Weisstein's World of Mathematics.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""os""
    ""strconv""
    ""strings""
)
 
const luckySize = 60000
 
var luckyOdd = make([]int, luckySize)
var luckyEven = make([]int, luckySize)
 
func init() {
    for i := 0; i < luckySize; i++ {
        luckyOdd[i] = i*2 + 1
        luckyEven[i] = i*2 + 2
    }
}
 
func filterLuckyOdd() {
    for n := 2; n < len(luckyOdd); n++ {
        m := luckyOdd[n-1]
        end := (len(luckyOdd)/m)*m - 1
        for j := end; j >= m-1; j -= m {
            copy(luckyOdd[j:], luckyOdd[j+1:])
            luckyOdd = luckyOdd[:len(luckyOdd)-1]
        }
    }
}
 
func filterLuckyEven() {
    for n := 2; n < len(luckyEven); n++ {
        m := luckyEven[n-1]
        end := (len(luckyEven)/m)*m - 1
        for j := end; j >= m-1; j -= m {
            copy(luckyEven[j:], luckyEven[j+1:])
            luckyEven = luckyEven[:len(luckyEven)-1]
        }
    }
}
 
func printSingle(j int, odd bool) error {
    if odd {
        if j >= len(luckyOdd) {
            return fmt.Errorf(""the argument, %d, is too big"", j)
        }
        fmt.Println(""Lucky number"", j, ""="", luckyOdd[j-1])
    } else {
        if j >= len(luckyEven) {
            return fmt.Errorf(""the argument, %d, is too big"", j)
        }
        fmt.Println(""Lucky even number"", j, ""="", luckyEven[j-1])
    }
    return nil
}
 
func printRange(j, k int, odd bool) error {
    if odd {
        if k >= len(luckyOdd) {
            return fmt.Errorf(""the argument, %d, is too big"", k)
        }
        fmt.Println(""Lucky numbers"", j, ""to"", k, ""are:"")
        fmt.Println(luckyOdd[j-1 : k])
    } else {
        if k >= len(luckyEven) {
            return fmt.Errorf(""the argument, %d, is too big"", k)
        }
        fmt.Println(""Lucky even numbers"", j, ""to"", k, ""are:"")
        fmt.Println(luckyEven[j-1 : k])
    }
    return nil
}
 
func printBetween(j, k int, odd bool) error {
    var r []int
    if odd {
        max := luckyOdd[len(luckyOdd)-1]
        if j > max || k > max {
            return fmt.Errorf(""at least one argument, %d or %d, is too big"", j, k)
        }
        for _, num := range luckyOdd {
            if num < j {
                continue
            }
            if num > k {
                break
            }
            r = append(r, num)
        }
        fmt.Println(""Lucky numbers between"", j, ""and"", k, ""are:"")
        fmt.Println(r)
    } else {
        max := luckyEven[len(luckyEven)-1]
        if j > max || k > max {
            return fmt.Errorf(""at least one argument, %d or %d, is too big"", j, k)
        }
        for _, num := range luckyEven {
            if num < j {
                continue
            }
            if num > k {
                break
            }
            r = append(r, num)
        }
        fmt.Println(""Lucky even numbers between"", j, ""and"", k, ""are:"")
        fmt.Println(r)
    }
    return nil
}
 
func main() {
    nargs := len(os.Args)
    if nargs < 2 || nargs > 4 {
        log.Fatal(""there must be between 1 and 3 command line arguments"")
    }
    filterLuckyOdd()
    filterLuckyEven()
    j, err := strconv.Atoi(os.Args[1])
    if err != nil || j < 1 {
        log.Fatalf(""first argument, %s, must be a positive integer"", os.Args[1])
    }
    if nargs == 2 {
        if err := printSingle(j, true); err != nil {
            log.Fatal(err)
        }
        return
    }
 
    if nargs == 3 {
        k, err := strconv.Atoi(os.Args[2])
        if err != nil {
            log.Fatalf(""second argument, %s, must be an integer"", os.Args[2])
        }
        if k >= 0 {
            if j > k {
                log.Fatalf(""second argument, %d, can't be less than first, %d"", k, j)
            }
            if err := printRange(j, k, true); err != nil {
                log.Fatal(err)
            }
        } else {
            l := -k
            if j > l {
                log.Fatalf(""second argument, %d, can't be less in absolute value than first, %d"", k, j)
            }
            if err := printBetween(j, l, true); err != nil {
                log.Fatal(err)
            }
        }
        return
    }
 
    var odd bool
    switch lucky := strings.ToLower(os.Args[3]); lucky {
    case ""lucky"":
        odd = true
    case ""evenlucky"":
        odd = false
    default:
        log.Fatalf(""third argument, %s, is invalid"", os.Args[3])
    }
    if os.Args[2] == "","" {
        if err := printSingle(j, odd); err != nil {
            log.Fatal(err)
        }
        return
    }
 
    k, err := strconv.Atoi(os.Args[2])
    if err != nil {
        log.Fatal(""second argument must be an integer or a comma"")
    }
    if k >= 0 {
        if j > k {
            log.Fatalf(""second argument, %d, can't be less than first, %d"", k, j)
        }
        if err := printRange(j, k, odd); err != nil {
            log.Fatal(err)
        }
    } else {
        l := -k
        if j > l {
            log.Fatalf(""second argument, %d, can't be less in absolute value than first, %d"", k, j)
        }
        if err := printBetween(j, l, odd); err != nil {
            log.Fatal(err)
        }
    }
}",5086,193
37127,http://rosettacode.org/wiki/Ludic_numbers,Ludic numbers,"Ludic numbers   are related to prime numbers as they are generated by a sieve quite like the Sieve of Eratosthenes is used to generate prime numbers.

The first ludic number is   1.

To generate succeeding ludic numbers create an array of increasing integers starting from   2.

2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ...
(Loop)

 Take the first member of the resultant array as the next ludic number   2.
 Remove every   2nd   indexed item from the array (including the first).
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ...
 (Unrolling a few loops...)
 Take the first member of the resultant array as the next ludic number   3.
 Remove every   3rd   indexed item from the array (including the first).
3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 ...
 Take the first member of the resultant array as the next ludic number   5.
 Remove every   5th   indexed item from the array (including the first).
5 7 11 13 17 19 23 25 29 31 35 37 41 43 47 49 53 55 59 61 65 67 71 73 77 ...
 Take the first member of the resultant array as the next ludic number   7.
 Remove every   7th   indexed item from the array (including the first).
7 11 13 17 23 25 29 31 37 41 43 47 53 55 59 61 67 71 73 77 83 85 89 91 97 ...
  ... 
 Take the first member of the current array as the next ludic number   L.
 Remove every   Lth   indexed item from the array (including the first).
  ... 


Task

 Generate and show here the first 25 ludic numbers.
 How many ludic numbers are there less than or equal to 1000?
 Show the 2000..2005th ludic numbers.


Stretch goal

Show all triplets of ludic numbers < 250.

 A triplet is any three numbers     



x
,


{\displaystyle x,}

   



x
+
2
,


{\displaystyle x+2,}

   



x
+
6


{\displaystyle x+6}

      where all three numbers are also ludic numbers. 

",#Go,Go,"package main
 
import ""fmt""
 
// Ludic returns a slice of Ludic numbers stopping after
// either n entries or when max is exceeded.
// Either argument may be <=0 to disable that limit.
func Ludic(n int, max int) []uint32 {
	const maxInt32 = 1<<31 - 1 // i.e. math.MaxInt32
	if max > 0 && n < 0 {
		n = maxInt32
	}
	if n < 1 {
		return nil
	}
	if max < 0 {
		max = maxInt32
	}
	sieve := make([]uint32, 10760) // XXX big enough for 2005 Ludics
	sieve[0] = 1
	sieve[1] = 2
	if n > 2 {
		// We start with even numbers already removed
		for i, j := 2, uint32(3); i < len(sieve); i, j = i+1, j+2 {
			sieve[i] = j
		}
		// We leave the Ludic numbers in place,
		// k is the index of the next Ludic
		for k := 2; k < n; k++ {
			l := int(sieve[k])
			if l >= max {
				n = k
				break
			}
			i := l
			l--
			// last is the last valid index
			last := k + i - 1
			for j := k + i + 1; j < len(sieve); i, j = i+1, j+1 {
				last = k + i
				sieve[last] = sieve[j]
				if i%l == 0 {
					j++
				}
			}
			// Truncate down to only the valid entries
			if last < len(sieve)-1 {
				sieve = sieve[:last+1]
			}
		}
	}
	if n > len(sieve) {
		panic(""program error"") // should never happen
	}
	return sieve[:n]
}
 
func has(x []uint32, v uint32) bool {
	for i := 0; i < len(x) && x[i] <= v; i++ {
		if x[i] == v {
			return true
		}
	}
	return false
}
 
func main() {
	// Ludic() is so quick we just call it repeatedly
	fmt.Println(""First 25:"", Ludic(25, -1))
	fmt.Println(""Numner of Ludics below 1000:"", len(Ludic(-1, 1000)))
	fmt.Println(""Ludic 2000 to 2005:"", Ludic(2005, -1)[1999:])
 
	fmt.Print(""Tripples below 250:"")
	x := Ludic(-1, 250)
	for i, v := range x[:len(x)-2] {
		if has(x[i+1:], v+2) && has(x[i+2:], v+6) {
			fmt.Printf("", (%d %d %d)"", v, v+2, v+6)
		}
	}
	fmt.Println()
}",1777,81
37164,http://rosettacode.org/wiki/Mad_Libs,Mad Libs,"

 This page uses content from Wikipedia. The original article was at Mad Libs. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Mad Libs is a phrasal template word game where one player prompts another for a list of words to substitute for blanks in a story, usually with funny results.



Task;
Write a program to create a Mad Libs like story.

The program should read an arbitrary multiline story from input.

The story will be terminated with a blank line.

Then, find each replacement to be made within the story, ask the user for a word to replace it with, and make all the replacements.

Stop when there are none left and print the final story.



The input should be an arbitrary story in the form:

<name> went for a walk in the park. <he or she>
found a <noun>. <name> decided to take it home.

Given this example, it should then ask for a name, a he or she and a noun (<name> gets replaced both times with the same value).




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""io/ioutil""
    ""log""
    ""os""
    ""regexp""
    ""strings""
)
 
func main() {
    pat := regexp.MustCompile(""<.+?>"")
    if len(os.Args) != 2 {
        fmt.Println(""usage: madlib <story template file>"")
        return
    }
    b, err := ioutil.ReadFile(os.Args[1])
    if err != nil {
        log.Fatal(err)
    }
    tmpl := string(b)
    s := []string{}          // patterns in order of appearance
    m := map[string]string{} // mapping from patterns to replacements
    for _, p := range pat.FindAllString(tmpl, -1) {
        if _, ok := m[p]; !ok {
            m[p] = """"
            s = append(s, p)
        }
    }
    fmt.Println(""Enter replacements:"")
    br := bufio.NewReader(os.Stdin)
    for _, p := range s {
        for {
            fmt.Printf(""%s: "", p[1:len(p)-1])
            r, isPre, err := br.ReadLine()
            if err != nil {
                log.Fatal(err)
            }
            if isPre {
                log.Fatal(""you're not playing right. :P"")
            }
            s := strings.TrimSpace(string(r))
            if s == """" {
                fmt.Println(""  hmm?"")
                continue
            }
            m[p] = s
            break
        }
    }
    fmt.Println(""\nYour story:\n"")
    fmt.Println(pat.ReplaceAllStringFunc(tmpl, func(p string) string {
        return m[p]
    }))
}",1380,57
37186,http://rosettacode.org/wiki/LU_decomposition,LU decomposition,"Every square matrix 



A


{\displaystyle A}

 can be decomposed into a product of a lower triangular matrix 



L


{\displaystyle L}

 and a upper triangular matrix 



U


{\displaystyle U}

,
as described in LU decomposition.





A
=
L
U


{\displaystyle A=LU}


It is a modified form of Gaussian elimination.
While the Cholesky decomposition only works for symmetric,
positive definite matrices, the more general LU decomposition
works for any square matrix.

There are several algorithms for calculating L and U.
To derive Crout's algorithm for a 3x3 example,
we have to solve the following system:





A
=


(




a

11





a

12





a

13







a

21





a

22





a

23







a

31





a

32





a

33





)


=


(




l

11




0


0





l

21





l

22




0





l

31





l

32





l

33





)




(




u

11





u

12





u

13






0



u

22





u

23






0


0



u

33





)


=
L
U


{\displaystyle A={\begin{pmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\\\end{pmatrix}}={\begin{pmatrix}l_{11}&0&0\\l_{21}&l_{22}&0\\l_{31}&l_{32}&l_{33}\\\end{pmatrix}}{\begin{pmatrix}u_{11}&u_{12}&u_{13}\\0&u_{22}&u_{23}\\0&0&u_{33}\end{pmatrix}}=LU}


We now would have to solve 9 equations with 12 unknowns. To make the system uniquely solvable, usually the diagonal elements of 



L


{\displaystyle L}

 are set to 1






l

11


=
1


{\displaystyle l_{11}=1}







l

22


=
1


{\displaystyle l_{22}=1}







l

33


=
1


{\displaystyle l_{33}=1}


so we get a solvable system of 9 unknowns and 9 equations.





A
=


(




a

11





a

12





a

13







a

21





a

22





a

23







a

31





a

32





a

33





)


=


(



1


0


0





l

21




1


0





l

31





l

32




1



)




(




u

11





u

12





u

13






0



u

22





u

23






0


0



u

33





)


=


(




u

11





u

12





u

13







u

11



l

21





u

12



l

21


+

u

22





u

13



l

21


+

u

23







u

11



l

31





u

12



l

31


+

u

22



l

32





u

13



l

31


+

u

23



l

32


+

u

33





)


=
L
U


{\displaystyle A={\begin{pmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\\\end{pmatrix}}={\begin{pmatrix}1&0&0\\l_{21}&1&0\\l_{31}&l_{32}&1\\\end{pmatrix}}{\begin{pmatrix}u_{11}&u_{12}&u_{13}\\0&u_{22}&u_{23}\\0&0&u_{33}\end{pmatrix}}={\begin{pmatrix}u_{11}&u_{12}&u_{13}\\u_{11}l_{21}&u_{12}l_{21}+u_{22}&u_{13}l_{21}+u_{23}\\u_{11}l_{31}&u_{12}l_{31}+u_{22}l_{32}&u_{13}l_{31}+u_{23}l_{32}+u_{33}\end{pmatrix}}=LU}


Solving for the other 



l


{\displaystyle l}

 and 



u


{\displaystyle u}

, we get the following equations:






u

11


=

a

11




{\displaystyle u_{11}=a_{11}}







u

12


=

a

12




{\displaystyle u_{12}=a_{12}}







u

13


=

a

13




{\displaystyle u_{13}=a_{13}}







u

22


=

a

22


−

u

12



l

21




{\displaystyle u_{22}=a_{22}-u_{12}l_{21}}







u

23


=

a

23


−

u

13



l

21




{\displaystyle u_{23}=a_{23}-u_{13}l_{21}}







u

33


=

a

33


−
(

u

13



l

31


+

u

23



l

32


)


{\displaystyle u_{33}=a_{33}-(u_{13}l_{31}+u_{23}l_{32})}


and for 



l


{\displaystyle l}

:






l

21


=


1

u

11





a

21




{\displaystyle l_{21}={\frac {1}{u_{11}}}a_{21}}







l

31


=


1

u

11





a

31




{\displaystyle l_{31}={\frac {1}{u_{11}}}a_{31}}







l

32


=


1

u

22




(

a

32


−

u

12



l

31


)


{\displaystyle l_{32}={\frac {1}{u_{22}}}(a_{32}-u_{12}l_{31})}


We see that there is a calculation pattern, which can be expressed as the following formulas, first for 



U


{\displaystyle U}








u

i
j


=

a

i
j


−

∑

k
=
1


i
−
1



u

k
j



l

i
k




{\displaystyle u_{ij}=a_{ij}-\sum _{k=1}^{i-1}u_{kj}l_{ik}}


and then for 



L


{\displaystyle L}








l

i
j


=


1

u

j
j




(

a

i
j


−

∑

k
=
1


j
−
1



u

k
j



l

i
k


)


{\displaystyle l_{ij}={\frac {1}{u_{jj}}}(a_{ij}-\sum _{k=1}^{j-1}u_{kj}l_{ik})}


We see in the second formula that to get the 




l

i
j




{\displaystyle l_{ij}}

 below the diagonal, we have to divide by the diagonal element (pivot) 




u

j
j




{\displaystyle u_{jj}}

, so we get problems when 




u

j
j




{\displaystyle u_{jj}}

 is either 0 or very small, which leads to numerical instability.

The solution to this problem is pivoting 



A


{\displaystyle A}

, which means rearranging the rows of 



A


{\displaystyle A}

, prior to the 



L
U


{\displaystyle LU}

 decomposition, in a way that the largest element of each column gets onto the diagonal of 



A


{\displaystyle A}

. Rearranging the rows means to multiply 



A


{\displaystyle A}

 by a permutation matrix 



P


{\displaystyle P}

:





P
A
⇒

A
′



{\displaystyle PA\Rightarrow A'}


Example:







(



0


1




1


0



)




(



1


4




2


3



)


⇒


(



2


3




1


4



)




{\displaystyle {\begin{pmatrix}0&1\\1&0\end{pmatrix}}{\begin{pmatrix}1&4\\2&3\end{pmatrix}}\Rightarrow {\begin{pmatrix}2&3\\1&4\end{pmatrix}}}


The decomposition algorithm is then applied on the rearranged matrix so that





P
A
=
L
U


{\displaystyle PA=LU}




Task description

The task is to implement a routine which will take a square nxn matrix 



A


{\displaystyle A}

 and return a lower triangular matrix 



L


{\displaystyle L}

, a upper triangular matrix 



U


{\displaystyle U}

 and a permutation matrix 



P


{\displaystyle P}

,
so that the above equation is fulfilled.

You should then test it on the following two examples and include your output.



Example 1

A

1   3   5
2   4   7
1   1   0

L

1.00000   0.00000   0.00000
0.50000   1.00000   0.00000
0.50000  -1.00000   1.00000

U

2.00000   4.00000   7.00000
0.00000   1.00000   1.50000
0.00000   0.00000  -2.00000

P

0   1   0
1   0   0
0   0   1

Example 2

A

11    9   24    2
 1    5    2    6
 3   17   18    1
 2    5    7    1

L

1.00000   0.00000   0.00000   0.00000
0.27273   1.00000   0.00000   0.00000
0.09091   0.28750   1.00000   0.00000
0.18182   0.23125   0.00360   1.00000

U

11.00000    9.00000   24.00000    2.00000
 0.00000   14.54545   11.45455    0.45455
 0.00000    0.00000   -3.47500    5.68750
 0.00000    0.00000    0.00000    0.51079

P

1   0   0   0
0   0   1   0
0   1   0   0
0   0   0   1


",#Go,Go,"package main
 
import ""fmt""
 
type matrix [][]float64
 
func zero(n int) matrix {
    r := make([][]float64, n)
    a := make([]float64, n*n)
    for i := range r {
        r[i] = a[n*i : n*(i+1)]
    } 
    return r 
}
 
func eye(n int) matrix {
    r := zero(n)
    for i := range r {
        r[i][i] = 1
    }
    return r
}   
 
func (m matrix) print(label string) {
    if label > """" {
        fmt.Printf(""%s:\n"", label)
    }
    for _, r := range m {
        for _, e := range r {
            fmt.Printf("" %9.5f"", e)
        }
        fmt.Println()
    }
}
 
func (a matrix) pivotize() matrix { 
    p := eye(len(a))
    for j, r := range a {
        max := r[j] 
        row := j
        for i := j; i < len(a); i++ {
            if a[i][j] > max {
                max = a[i][j]
                row = i
            }
        }
        if j != row {
            // swap rows
            p[j], p[row] = p[row], p[j]
        }
    } 
    return p
}
 
func (m1 matrix) mul(m2 matrix) matrix {
    r := zero(len(m1))
    for i, r1 := range m1 {
        for j := range m2 {
            for k := range m1 {
                r[i][j] += r1[k] * m2[k][j]
            }
        }
    }
    return r
}
 
func (a matrix) lu() (l, u, p matrix) {
    l = zero(len(a))
    u = zero(len(a))
    p = a.pivotize()
    a = p.mul(a)
    for j := range a {
        l[j][j] = 1
        for i := 0; i <= j; i++ {
            sum := 0.
            for k := 0; k < i; k++ {
                sum += u[k][j] * l[i][k]
            }
            u[i][j] = a[i][j] - sum
        }
        for i := j; i < len(a); i++ {
            sum := 0.
            for k := 0; k < j; k++ {
                sum += u[k][j] * l[i][k]
            }
            l[i][j] = (a[i][j] - sum) / u[j][j]
        }
    }
    return
}
 
func main() {
    showLU(matrix{
        {1, 3, 5},
        {2, 4, 7},
        {1, 1, 0}})
    showLU(matrix{
        {11, 9, 24, 2},
        {1, 5, 2, 6},
        {3, 17, 18, 1},
        {2, 5, 7, 1}})
}
 
func showLU(a matrix) {
    a.print(""\na"")
    l, u, p := a.lu()
    l.print(""l"")
    u.print(""u"") 
    p.print(""p"") 
}",2113,110
37234,http://rosettacode.org/wiki/Loops/Wrong_ranges,Loops/Wrong ranges,"Loops/Wrong ranges

You are encouraged to solve this task according to the task description, using any language you may know.
Some languages have syntax or function(s) to generate a range of numeric values from a start value, a stop value, and an increment.

The purpose of this task is to select the range syntax/function that would generate at least two increasing numbers when given a stop value more than the start value and a positive increment of less than half the difference.   You are then to use that same syntax/function but with different parameters; and show, here, what would happen.

Use these values if possible:



start 
stop 
increment 
Comment


 -2
2
1
Normal


 -2
2
0
Zero increment


 -2
2
-1
Increments away from stop value


 -2
2
10
First increment is beyond stop value


2
-2
1
Start more than stop: positive increment


2
2
1
Start equal stop: positive increment


2
2
-1
Start equal stop: negative increment


2
2
0
Start equal stop: zero increment


0
0
0
Start equal stop equal zero: zero increment

Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#Go,Go,"package main
 
import ""fmt""
 
type S struct {
    start, stop, incr int
    comment          string
}
 
var examples = []S{
    {-2, 2, 1, ""Normal""},
    {-2, 2, 0, ""Zero increment""},
    {-2, 2, -1, ""Increments away from stop value""},
    {-2, 2, 10, ""First increment is beyond stop value""},
    {2, -2, 1, ""Start more than stop: positive increment""},
    {2, 2, 1, ""Start equal stop: positive increment""},
    {2, 2, -1, ""Start equal stop: negative increment""},
    {2, 2, 0, ""Start equal stop: zero increment""},
    {0, 0, 0, ""Start equal stop equal zero: zero increment""},
}
 
func sequence(s S, limit int) []int {
    var seq []int
    for i, c := s.start, 0; i <= s.stop && c < limit; i, c = i+s.incr, c+1 {
        seq = append(seq, i)
    }
    return seq
}
 
func main() {
    const limit = 10
    for _, ex := range examples {
        fmt.Println(ex.comment)
        fmt.Printf(""Range(%d, %d, %d) -> "", ex.start, ex.stop, ex.incr)
        fmt.Println(sequence(ex, limit))
        fmt.Println()
    }
}",1011,38
37376,http://rosettacode.org/wiki/LZW_compression,LZW compression,"The Lempel-Ziv-Welch (LZW) algorithm provides loss-less data compression.

You can read a complete description of it in the   Wikipedia article   on the subject.   It was patented, but it entered the public domain in 2004.



",#Go,Go,"package main
 
import (
	""fmt""
	""log""
	""strings""
)
 
// Compress a string to a list of output symbols.
func compress(uncompressed string) []int {
	// Build the dictionary.
	dictSize := 256
	// We actually want a map of []byte -> int but
	// slices are not acceptable map key types.
	dictionary := make(map[string]int, dictSize)
	for i := 0; i < dictSize; i++ {
		// Ugly mess to work around not having a []byte key type.
		// Using `string(i)` would do utf8 encoding for i>127.
		dictionary[string([]byte{byte(i)})] = i
	}
 
	var result []int
	var w []byte
	for i := 0; i < len(uncompressed); i++ {
		c := uncompressed[i]
		wc := append(w, c)
		if _, ok := dictionary[string(wc)]; ok {
			w = wc
		} else {
			result = append(result, dictionary[string(w)])
			// Add wc to the dictionary.
			dictionary[string(wc)] = dictSize
			dictSize++
			//w = []byte{c}, but re-using wc
			wc[0] = c
			w = wc[:1]
		}
	}
 
	if len(w) > 0 {
		// Output the code for w.
		result = append(result, dictionary[string(w)])
	}
	return result
}
 
type BadSymbolError int
 
func (e BadSymbolError) Error() string {
	return fmt.Sprint(""Bad compressed symbol "", int(e))
}
 
// Decompress a list of output symbols to a string.
func decompress(compressed []int) (string, error) {
	// Build the dictionary.
	dictSize := 256
	dictionary := make(map[int][]byte, dictSize)
	for i := 0; i < dictSize; i++ {
		dictionary[i] = []byte{byte(i)}
	}
 
	var result strings.Builder
	var w []byte
	for _, k := range compressed {
		var entry []byte
		if x, ok := dictionary[k]; ok {
			//entry = x, but ensuring any append will make a copy
			entry = x[:len(x):len(x)]
		} else if k == dictSize && len(w) > 0 {
			entry = append(w, w[0])
		} else {
			return result.String(), BadSymbolError(k)
		}
		result.Write(entry)
 
		if len(w) > 0 {
			// Add w+entry[0] to the dictionary.
			w = append(w, entry[0])
			dictionary[dictSize] = w
			dictSize++
		}
		w = entry
	}
	return result.String(), nil
}
 
func main() {
	compressed := compress(""TOBEORNOTTOBEORTOBEORNOT"")
	fmt.Println(compressed)
	decompressed, err := decompress(compressed)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(decompressed)
}",2163,95
37408,http://rosettacode.org/wiki/Loops/With_multiple_ranges,Loops/With multiple ranges,"Loops/With multiple ranges

You are encouraged to solve this task according to the task description, using any language you may know.
Some languages allow multiple loop ranges, such as the PL/I example (snippet) below.

                                       /* all variables are DECLARED as integers. */
          prod=  1;                    /*start with a product of unity.           */
           sum=  0;                    /*  ""     ""  ""   sum    "" zero.            */
             x= +5;
             y= -5;
             z= -2;
           one=  1;
         three=  3;
         seven=  7;
                                       /*(below)  **  is exponentiation:  4**3=64 */
           do j=   -three  to     3**3        by three   ,
                   -seven  to   +seven        by   x     ,
                      555  to      550 - y               ,
                       22  to      -28        by -three  ,
                     1927  to     1939                   ,
                        x  to        y        by   z     ,
                    11**x  to    11**x + one;
                                                        /* ABS(n) = absolute value*/
           sum= sum + abs(j);                           /*add absolute value of J.*/
           if abs(prod)<2**27 & j¬=0  then prod=prod*j; /*PROD is small enough & J*/
           end;                                         /*not 0, then multiply it.*/
                     /*SUM and PROD are used for verification of J incrementation.*/
         display (' sum= ' ||  sum);                    /*display strings to term.*/
         display ('prod= ' || prod);                    /*   ""       ""     ""   ""  */


Task

Simulate/translate the above PL/I program snippet as best as possible in your
language,   with particular emphasis on the   do   loop construct.

The   do   index must be incremented/decremented in the same order shown.

If feasible, add commas to the two output numbers (being displayed).

Show all output here.

      A simple PL/I   DO  loop  (incrementing or decrementing)  has the construct of:
 
            DO variable = start_expression    {TO ending_expression]       {BY increment_expression} ;
                 ---or---
            DO variable = start_expression    {BY increment_expression}    {TO ending_expression]    ;  
 
      where it is understood that all expressions will have a value.  The  variable  is normally a 
      scaler variable,  but need not be  (but for this task, all variables and expressions are declared
      to be scaler integers).   If the   BY   expression is omitted,  a   BY   value of unity is used.
      All expressions are evaluated before the   DO   loop is executed,  and those values are used
      throughout the   DO   loop execution   (even though, for instance,  the value of   Z   may be
      changed within the   DO   loop.    This isn't the case here for this task.  
 
      A multiple-range   DO   loop can be constructed by using a comma (,) to separate additional ranges
      (the use of multiple   TO   and/or   BY   keywords).     This is the construct used in this task.
 
      There are other forms of   DO   loops in PL/I involving the  WHILE  clause,  but those won't be 
      needed here.    DO  loops without a   TO   clause might need a   WHILE   clause  or some other 
      means of exiting the loop  (such as  LEAVE,  RETURN,  SIGNAL,  GOTO,  or  STOP),  or some other 
      (possible error) condition that causes transfer of control outside the  DO  loop.
 
      Also, in PL/I, the check if the   DO   loop index value is outside the range is made at the 
      ""head""  (start)  of the   DO  loop,  so it's possible that the   DO   loop isn't executed,  but 
      that isn't the case for any of the ranges used in this task. 
 
      In the example above, the clause:                    x    to y       by z     
      will cause the variable   J   to have to following values  (in this order):  5  3  1  -1  -3  -5
 
      In the example above, the clause:                 -seven  to +seven  by x  
      will cause the variable   J   to have to following values  (in this order):  -7  -2   3  


Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#Go,Go,"package main
 
import ""fmt""
 
func pow(n int, e uint) int {
    if e == 0 {
        return 1
    }
    prod := n
    for i := uint(2); i <= e; i++ {
        prod *= n
    }
    return prod
}
 
func abs(n int) int {
    if n >= 0 {
        return n
    }
    return -n
}
 
func commatize(n int) string {
    s := fmt.Sprintf(""%d"", n)
    if n < 0 {
        s = s[1:]
    }
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    if n >= 0 {
        return "" "" + s
    }
    return ""-"" + s
}
 
func main() {
    prod := 1
    sum := 0
    const (
        x     = 5
        y     = -5
        z     = -2
        one   = 1
        three = 3
        seven = 7
    )
    p := pow(11, x)
    var j int
 
    process := func() {
        sum += abs(j)
        if abs(prod) < (1<<27) && j != 0 {
            prod *= j
        }
    }
 
    for j = -three; j <= pow(3, 3); j += three {
        process()
    }
    for j = -seven; j <= seven; j += x {
        process()
    }
    for j = 555; j <= 550-y; j++ {
        process()
    }
    for j = 22; j >= -28; j -= three {
        process()
    }
    for j = 1927; j <= 1939; j++ {
        process()
    }
    for j = x; j >= y; j -= -z {
        process()
    }
    for j = p; j <= p+one; j++ {
        process()
    }
    fmt.Println(""sum  = "", commatize(sum))
    fmt.Println(""prod = "", commatize(prod))
}",1389,82
37555,http://rosettacode.org/wiki/Loops/Increment_loop_index_within_loop_body,Loops/Increment loop index within loop body,"Sometimes, one may need   (or want)   a loop which
its   iterator   (the index
variable)   is modified within the

loop body    in addition to the normal incrementation by the   (do)   loop structure index.



Goal

Demonstrate the best way to accomplish this.



Task

Write a loop which:

   starts the index (variable) at   42
   (at iteration time)   increments the index by unity
   if the index is prime:
   displays the count of primes found (so far) and the prime   (to the terminal)
   increments the index such that the new index is now the (old) index plus that prime
   terminates the loop when   42   primes are shown


Extra credit:   because of the primes get rather large, use commas
within the displayed primes to ease comprehension.



Show all output here.



Note

Not all programming languages allow the modification of a
loop's index.   If that is the case, then use whatever method that
is appropriate or idiomatic for that language.   Please add a note
if the loop's index isn't modifiable.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#Go,Go,"package main
 
import(
    ""golang.org/x/text/language""
    ""golang.org/x/text/message""
)
 
func isPrime(n uint64) bool {
    if n % 2 == 0 {
        return n == 2
    }
    if n % 3 == 0 {
        return n == 3
    }
    d := uint64(5)
    for d * d <= n {
        if n % d == 0 {
            return false
        }
        d += 2
        if n % d == 0 {
            return false
        } 
        d += 4
    }
    return true
}
 
const limit = 42
 
func main() {
    p := message.NewPrinter(language.English)
    for i, n := uint64(limit), 0; n < limit; i++ {
        if isPrime(i) {
            n++
            p.Printf(""n = %-2d  %19d\n"", n, i)
            i += i - 1
        }
    }
}",690,40
37722,http://rosettacode.org/wiki/Lucas-Lehmer_test,Lucas-Lehmer test,"Lucas-Lehmer Test:

for 



p


{\displaystyle p}

 an odd prime, the Mersenne number 




2

p


−
1


{\displaystyle 2^{p}-1}

 is prime if and only if 




2

p


−
1


{\displaystyle 2^{p}-1}

 divides 



S
(
p
−
1
)


{\displaystyle S(p-1)}

 where 



S
(
n
+
1
)
=
(
S
(
n
)

)

2


−
2


{\displaystyle S(n+1)=(S(n))^{2}-2}

, and 



S
(
1
)
=
4


{\displaystyle S(1)=4}

.



Task

Calculate all Mersenne primes up to the implementation's
maximum precision, or the 47th Mersenne prime   (whichever comes first).



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
var primes = []uint{3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,
    53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127}
 
var mersennes = []uint{521, 607, 1279, 2203, 2281, 3217, 4253, 4423, 9689,
    9941, 11213, 19937, 21701, 23209, 44497, 86243, 110503, 132049, 216091,
    756839, 859433, 1257787, 1398269, 2976221, 3021377, 6972593, 13466917,
    20996011, 24036583}
 
func main() {
    llTest(primes)
    fmt.Println()
    llTest(mersennes)
}
 
func llTest(ps []uint) {
    var s, m big.Int
    one := big.NewInt(1)
    two := big.NewInt(2)
    for _, p := range ps {
        m.Sub(m.Lsh(one, p), one)
        s.SetInt64(4)
        for i := uint(2); i < p; i++ {
            s.Mod(s.Sub(s.Mul(&s, &s), two), &m)
        }
        if s.BitLen() == 0 {
            fmt.Printf(""M%d "", p)
        }
    }
}",888,36
37905,http://rosettacode.org/wiki/Loops/Foreach,Loops/Foreach,"Loop through and print each element in a collection in order.

Use your language's ""for each"" loop if it has one, otherwise iterate through the collection in order with some other loop.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#Go,Go,"func printAll(values []int) {
   for i, x := range values {
      fmt.Printf(""Item %d = %d\n"", i, x)
   }
}",107,5
37985,http://rosettacode.org/wiki/Loops/N_plus_one_half,Loops/N plus one half,"Quite often one needs loops which, in the last iteration, execute only part of the loop body.



Goal

Demonstrate the best way to do this.



Task

Write a loop which writes the comma-separated list

1, 2, 3, 4, 5, 6, 7, 8, 9, 10

using separate output statements for the number
and the comma from within the body of the loop.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    for i := 1; ; i++ {
        fmt.Print(i)
        if i == 10 {
            fmt.Println()
            break
        }
        fmt.Print("", "")
    }
}",195,14
38005,http://rosettacode.org/wiki/Loops/Nested,Loops/Nested,"Show a nested loop which searches a two-dimensional array filled with random numbers uniformly distributed over 



[
1
,
…
,
20
]


{\displaystyle [1,\ldots ,20]}

.

The loops iterate rows and columns of the array printing the elements until the value 



20


{\displaystyle 20}

 is met.

Specifically, this task also shows how to break out of nested loops.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
func main() {
    rand.Seed(time.Now().UnixNano())
 
    values := make([][]int, 10)
    for i := range values {
        values[i] = make([]int, 10)
        for j := range values[i] {
            values[i][j] = rand.Intn(20) + 1
        }
    }
 
outerLoop:
    for i, row := range values {
        fmt.Printf(""%3d)"", i)
        for _, value := range row {
            fmt.Printf("" %3d"", value)
            if value == 20 {
                break outerLoop
            }
        }
        fmt.Printf(""\n"")
    }
    fmt.Printf(""\n"")
}",598,32
38166,http://rosettacode.org/wiki/Loops/Infinite,Loops/Infinite,"Task

Print out        SPAM        followed by a   newline   in an infinite loop.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
	for {
		fmt.Printf(""SPAM\n"")
	}
}",78,9
38211,http://rosettacode.org/wiki/Loops/While,Loops/While,"Task

Start an integer value at   1024.

Loop while it is greater than zero.

Print the value (with a newline) and divide it by two each time through the loop.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreachbas
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#Go,Go,"i := 1024
for i > 0 {
  fmt.Printf(""%d\n"", i)
  i /= 2
}",56,5
38221,http://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers,Luhn test of credit card numbers,"The Luhn test is used by some credit card companies to distinguish valid credit card numbers from what could be a random selection of digits.

Those companies using credit card numbers that can be validated by the Luhn test have numbers that pass the following test:

 Reverse the order of the digits in the number.
 Take the first, third, ... and every other odd digit in the reversed digits and sum them to form the partial sum s1
 Taking the second, fourth ... and every other even digit in the reversed digits:
 Multiply each digit by two and sum the digits if the answer is greater than nine to form partial sums for the even digits
 Sum the partial sums of the even digits to form s2
 If s1 + s2 ends in zero then the original number is in the form of a valid credit card number as verified by the Luhn test.


For example, if the trial number is 49927398716:

Reverse the digits:
  61789372994
Sum the odd digits:
  6 + 7 + 9 + 7 + 9 + 4 = 42 = s1
The even digits:
    1,  8,  3,  2,  9
  Two times each even digit:
    2, 16,  6,  4, 18
  Sum the digits of each multiplication:
    2,  7,  6,  4,  9
  Sum the last:
    2 + 7 + 6 + 4 + 9 = 28 = s2

s1 + s2 = 70 which ends in zero which means that 49927398716 passes the Luhn test


Task

Write a function/method/procedure/subroutine that will validate a number with the Luhn test, and

use it to validate the following numbers:

   49927398716
   49927398717
   1234567812345678
   1234567812345670



Related tasks

   SEDOL
   ISIN

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
const input = `49927398716
49927398717
1234567812345678
1234567812345670`
 
var t = [...]int{0, 2, 4, 6, 8, 1, 3, 5, 7, 9}
 
func luhn(s string) bool {
    odd := len(s) & 1
    var sum int
    for i, c := range s {
        if c < '0' || c > '9' {
            return false
        }
        if i&1 == odd {
            sum += t[c-'0']
        } else {
            sum += int(c - '0')
        }
    }
    return sum%10 == 0
}
 
func main() {
    for _, s := range strings.Split(input, ""\n"") {
        fmt.Println(s, luhn(s))
    }
}",583,35
38246,http://rosettacode.org/wiki/Loops/Downward_for,Loops/Downward for,"Task

Write a    for    loop which writes a countdown from   10   to   0.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#Go,Go,"for i := 10; i >= 0; i-- {
  fmt.Println(i)
}",45,3
38462,http://rosettacode.org/wiki/Loops/For_with_a_specified_step,Loops/For with a specified step,"

Task

Demonstrate a   for-loop   where the step-value is greater than one.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#Go,Go,"for i := 1; i < 10; i += 2 {
  fmt.Printf(""%d\n"", i)
}",54,3
38477,http://rosettacode.org/wiki/Loops/Do-while,Loops/Do-while,"Start with a value at 0. Loop while value mod 6 is not equal to 0.
Each time through the loop, add 1 to the value then print it.
The loop must execute at least once.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges


Reference

 Do while loop Wikipedia.

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
	var value int
	for {
		value++
		fmt.Println(value)
                if value%6 != 0 {
                        break
                }
	}
}",183,14
38746,http://rosettacode.org/wiki/Longest_string_challenge,Longest string challenge,"Background

This ""longest string challenge"" is inspired by a problem that used to be given to students learning Icon. Students were expected to try to solve the problem in Icon and another language with which the student was already familiar. The basic problem is quite simple; the challenge and fun part came through the introduction of restrictions. Experience has shown that the original restrictions required some adjustment to bring out the intent of the challenge and make it suitable for Rosetta Code.



Basic problem statement
Write a program that reads lines from standard input and, upon end of file, writes the longest line to standard output.
If there are ties for the longest line, the program writes out all the lines that tie.
If there is no input, the program should produce no output.



Task 
Implement a solution to the basic problem that adheres to the spirit of the restrictions (see below).

Describe how you circumvented or got around these 'restrictions' and met the 'spirit' of the challenge. Your supporting description may need to describe any challenges to interpreting the restrictions and how you made this interpretation. You should state any assumptions, warnings, or other relevant points. The central idea here is to make the task a bit more interesting by thinking outside of the box and perhaps by showing off the capabilities of your language in a creative way. Because there is potential for considerable variation between solutions, the description is key to helping others see what you've done.

This task is likely to encourage a variety of different types of solutions. They should be substantially different approaches.

Given the input:

a
bb
ccc
ddd
ee
f
ggg

the output should be (possibly rearranged):

ccc
ddd
ggg



Original list of restrictions
 No comparison operators may be used.
 No arithmetic operations, such as addition and subtraction, may be used.
 The only datatypes you may use are integer and string. In particular, you may not use lists.
 Do not re-read the input file. Avoid using files as a replacement for lists (this restriction became apparent in the discussion).


Intent of restrictions

Because of the variety of languages on Rosetta Code and the wide variety of concepts used in them, there needs to be a bit of clarification and guidance here to get to the spirit of the challenge and the intent of the restrictions.

The basic problem can be solved very conventionally, but that's boring and pedestrian. The original intent here wasn't to unduly frustrate people with interpreting the restrictions, it was to get people to think outside of their particular box and have a bit of fun doing it.

The guiding principle here should be to be creative in demonstrating some of the capabilities of the programming language being used. If you need to bend the restrictions a bit, explain why and try to follow the intent. If you think you've implemented a 'cheat', call out the fragment yourself and ask readers if they can spot why. If you absolutely can't get around one of the restrictions, explain why in your description.

Now having said that, the restrictions require some elaboration.

 In general, the restrictions are meant to avoid the explicit use of these features.
 ""No comparison operators may be used"" - At some level there must be some test that allows the solution to get at the length and determine if one string is longer. Comparison operators, in particular any less/greater comparison should be avoided. Representing the length of any string as a number should also be avoided. Various approaches allow for detecting the end of a string. Some of these involve implicitly using equal/not-equal; however, explicitly using equal/not-equal should be acceptable.
 ""No arithmetic operations"" - Again, at some level something may have to advance through the string. Often there are ways a language can do this implicitly advance a cursor or pointer without explicitly using a +, - , ++, --, add, subtract, etc.
 The datatype restrictions are amongst the most difficult to reinterpret. In the language of the original challenge strings are atomic datatypes and structured datatypes like lists are quite distinct and have many different operations that apply to them. This becomes a bit fuzzier with languages with a different programming paradigm. The intent would be to avoid using an easy structure to accumulate the longest strings and spit them out. There will be some natural reinterpretation here.


To make this a bit more concrete, here are a couple of specific examples:
In C, a string is an array of chars, so using a couple of arrays as strings is in the spirit while using a second array in a non-string like fashion would violate the intent.
In APL or J, arrays are the core of the language so ruling them out is unfair. Meeting the spirit will come down to how they are used.

Please keep in mind these are just examples and you may hit new territory finding a solution. There will be other cases like these. Explain your reasoning. You may want to open a discussion on the talk page as well.

 The added ""No rereading"" restriction is for practical reasons, re-reading stdin should be broken. I haven't outright banned the use of other files but I've discouraged them as it is basically another form of a list. Somewhere there may be a language that just sings when doing file manipulation and where that makes sense; however, for most there should be a way to accomplish without resorting to an externality.


At the end of the day for the implementer this should be a bit of fun. As an implementer you represent the expertise in your language, the reader may have no knowledge of your language. For the reader it should give them insight into how people think outside the box in other languages. Comments, especially for non-obvious (to the reader) bits will be extremely helpful. While the implementations may be a bit artificial in the context of this task, the general techniques may be useful elsewhere.



",#Go,Go,"package main
 
import (
    ""bufio""
    ""os""
)
 
func main() {
    in := bufio.NewReader(os.Stdin)
    var blankLine = ""\n""
    var printLongest func(string) string
    printLongest = func(candidate string) (longest string) {
        longest = candidate
        s, err := in.ReadString('\n')
        defer func() {
            recover()
            defer func() {
                recover()
            }()
            _ = blankLine[0]
            func() {
                defer func() {
                    recover()
                }()
                _ = s[len(longest)]
                longest = s
            }()
            longest = printLongest(longest)
            func() {
                defer func() {
                    recover()
                    os.Stdout.WriteString(s)
                }()
                _ = longest[len(s)]
                s = """"
            }()
        }()
        _ = err.(error)
        os.Stdout.WriteString(blankLine)
        blankLine = """"
        return
    }
    printLongest("""")
}",1026,44
38803,http://rosettacode.org/wiki/Longest_increasing_subsequence,Longest increasing subsequence,"Calculate and show here a longest increasing subsequence of the list:





{
3
,
2
,
6
,
4
,
5
,
1
}


{\displaystyle \{3,2,6,4,5,1\}}


And of the list:





{
0
,
8
,
4
,
12
,
2
,
10
,
6
,
14
,
1
,
9
,
5
,
13
,
3
,
11
,
7
,
15
}


{\displaystyle \{0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15\}}


Note that a list may have more than one subsequence that is of the maximum length.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




Ref

 Dynamic Programming #1: Longest Increasing Subsequence on YouTube
 An efficient solution can be based on Patience sorting.

",#Go,Go,"package main
 
import (
  ""fmt""
  ""sort""
)
 
type Node struct {
    val int
    back *Node
}
 
func lis (n []int) (result []int) {
  var pileTops []*Node
  // sort into piles
  for _, x := range n {
    j := sort.Search(len(pileTops), func (i int) bool { return pileTops[i].val >= x })
    node := &Node{ x, nil }
    if j != 0 { node.back = pileTops[j-1] }
    if j != len(pileTops) {
      pileTops[j] = node
    } else {
      pileTops = append(pileTops, node)
    }
  }
 
  if len(pileTops) == 0 { return []int{} }
  for node := pileTops[len(pileTops)-1]; node != nil; node = node.back {
    result = append(result, node.val)
  }
  // reverse
  for i := 0; i < len(result)/2; i++ {
    result[i], result[len(result)-i-1] = result[len(result)-i-1], result[i]
  }
  return
}
 
func main() {
    for _, d := range [][]int{{3, 2, 6, 4, 5, 1},
            {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}} {
        fmt.Printf(""an L.I.S. of %v is %v\n"", d, lis(d))
    }
}",977,43
39026,http://rosettacode.org/wiki/Longest_common_substring,Longest common substring,"Task

Write a function that returns the longest common substring of two strings.

Use it within a program that demonstrates sample output from the function, which will consist of the longest common substring between ""thisisatest"" and ""testing123testing"".

Note that substrings are consecutive characters within a string.   This distinguishes them from subsequences, which is any sequence of characters within a string, even if there are extraneous characters in between them.

Hence, the longest common subsequence between ""thisisatest"" and ""testing123testing"" is ""tsitest"", whereas the longest common substring is just ""test"".




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




References

Generalize Suffix Tree
Ukkonen’s Suffix Tree Construction

",#Go,Go,"package main
 
import ""fmt""
 
func lcs(a, b string) (output string) {
    lengths := make([]int, len(a)*len(b))
    greatestLength := 0
    for i, x := range a {
        for j, y := range b {
            if x == y {
                if i == 0 || j == 0 {
                    lengths[i*len(b)+j] = 1
                } else {
                    lengths[i*len(b)+j] = lengths[(i-1)*len(b)+j-1] + 1
                }
                if lengths[i*len(b)+j] > greatestLength {
                    greatestLength = lengths[i*len(b)+j]
                    output = a[i-greatestLength+1 : i+1]
                }
            }
        }
    }
    return
}
 
func main() {
    fmt.Println(lcs(""thisisatest"", ""testing123testing""))
}",720,28
39088,"http://rosettacode.org/wiki/Long_literals,_with_continuations","Long literals, with continuations","This task is about writing a computer program that has long literals   (character
literals that may require specifying the words/tokens on more than one (source)
line,   either with continuations or some other method, such as abutments or
concatenations   (or some other mechanisms).



The literal is to be in the form of a ""list"",   a literal that contains many
words (tokens) separated by a blank (space),   in this case   (so as to have a
common list),   the (English) names of the chemical elements of the periodic table.



The list is to be in (ascending) order of the (chemical) element's atomic number:

hydrogen helium lithium beryllium boron carbon nitrogen oxygen fluorine neon sodium aluminum silicon ...

... up to the last known (named) chemical element   (at this time).



Do not include any of the   ""unnamed""   chemical element names such as:

ununennium unquadnilium triunhexium penthextrium penthexpentium septhexunium octenntrium ennennbium



To make computer programming languages comparable,   the statement widths should be
restricted to less than   81   bytes (characters),   or less
if a computer programming language has more restrictive limitations or standards.

Also mention what column the programming statements can start in if   not  
in column one.



The list   may   have leading/embedded/trailing blanks during the
declaration   (the actual program statements),   this is allow the list to be
more readable.   The ""final"" list shouldn't have any leading/trailing or superfluous
blanks   (when stored in the program's ""memory"").

This list should be written with the idea in mind that the
program   will   be updated,   most likely someone other than the
original author,   as there will be newer (discovered) elements of the periodic
table being added   (possibly in the near future).   These future updates
should be one of the primary concerns in writing these programs and it should be ""easy""
for someone else to add chemical elements to the list   (within the computer
program).

Attention should be paid so as to not exceed the   clause length   of
continued or specified statements,   if there is such a restriction.   If the
limit is greater than (say) 4,000 bytes or so,   it needn't be mentioned here.



Task

   Write a computer program (by whatever name) to contain a list of the known elements.
   The program should eventually contain a long literal of words   (the elements).
   The literal should show how one could create a long list of blank-delineated words.
   The ""final"" (stored) list should only have a single blank between elements.
   Try to use the most idiomatic approach(es) in creating the final list.
   Use continuation if possible, and/or show alternatives   (possibly using concatenation).
   Use a program comment to explain what the continuation character is if it isn't obvious.
   The program should contain a variable that has the date of the last update/revision.
   The program, when run, should display with verbiage:
   The last update/revision date   (and should be unambiguous).
   The number of chemical elements in the list.
   The name of the highest (last) element name.


Show all output here, on this page.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""regexp""
    ""strings""
)
 
// Uses a 'raw string literal' which is a character sequence enclosed in back quotes.
// Within the quotes any character (including new line) may appear except
// back quotes themselves.
var elements = `
    hydrogen     helium        lithium      beryllium
    boron        carbon        nitrogen     oxygen
    fluorine     neon          sodium       magnesium
    aluminum     silicon       phosphorous  sulfur
    chlorine     argon         potassium    calcium
    scandium     titanium      vanadium     chromium
    manganese    iron          cobalt       nickel
    copper       zinc          gallium      germanium
    arsenic      selenium      bromine      krypton
    rubidium     strontium     yttrium      zirconium
    niobium      molybdenum    technetium   ruthenium
    rhodium      palladium     silver       cadmium
    indium       tin           antimony     tellurium
    iodine       xenon         cesium       barium
    lanthanum    cerium        praseodymium neodymium
    promethium   samarium      europium     gadolinium
    terbium      dysprosium    holmium      erbium
    thulium      ytterbium     lutetium     hafnium
    tantalum     tungsten      rhenium      osmium
    iridium      platinum      gold         mercury
    thallium     lead          bismuth      polonium
    astatine     radon         francium     radium
    actinium     thorium       protactinium uranium
    neptunium    plutonium     americium    curium
    berkelium    californium   einsteinium  fermium
    mendelevium  nobelium      lawrencium   rutherfordium
    dubnium      seaborgium    bohrium      hassium
    meitnerium   darmstadtium  roentgenium  copernicium
    nihonium     flerovium     moscovium    livermorium
    tennessine   oganesson
`
 
func main() {
    lastRevDate := ""March 24th, 2020""
    re := regexp.MustCompile(`\s+`) // split on one or more whitespace characters
    els := re.Split(strings.TrimSpace(elements), -1)
    numEls := len(els)
    // Recombine as a single string with elements separated by a single space.
    elements2 := strings.Join(els, "" "")
    // Required output.
    fmt.Println(""Last revision Date: "", lastRevDate)
    fmt.Println(""Number of elements: "", numEls)
    // The compiler complains that 'elements2' is unused if we don't use
    // something like this to get the last element rather than just els[numEls-1].
    lix := strings.LastIndex(elements2, "" "") // get index of last space
    fmt.Println(""Last element      : "", elements2[lix+1:])
}",2575,59
39090,http://rosettacode.org/wiki/List_rooted_trees,List rooted trees,"You came back from grocery shopping.   After putting away all the goods, you are left with a pile of plastic bags, which you want to save for later use, so you take one bag and stuff all the others into it, and throw it under the sink.   In doing so, you realize that there are various ways of nesting the bags, with all bags viewed as identical.

If we use a matching pair of parentheses to represent a bag, the ways are:

For 1 bag, there's one way:

 ()	<- a bag

for 2 bags, there's one way:

 (())	<- one bag in another

for 3 bags, there are two:

 ((())) <- 3 bags nested Russian doll style
 (()()) <- 2 bags side by side, inside the third

for 4 bags, four:

 (()()())
 ((())())
 ((()()))
 (((())))

Note that because all bags are identical, the two 4-bag strings ((())()) and (()(())) represent the same configuration.

It's easy to see that each configuration for n bags represents a n-node rooted tree, where a bag is a tree node, and a bag with its content forms a subtree. The outermost bag is the tree root. Number of configurations for given n is given by OEIS A81.



Task
 
Write a program that, when given n, enumerates all ways of nesting n bags.   You can use the parentheses notation above, or any tree representation that's unambiguous and preferably intuitive.

This task asks for enumeration of trees only; for counting solutions without enumeration, that OEIS page lists various formulas, but that's not encouraged by this task, especially if implementing it would significantly increase code size.

As an example output, run 5 bags.   There should be 9 ways.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""os""
    ""strconv""
)
 
type tree uint64
 
var (
    list   []tree
    offset = [32]uint{1: 1}
)
 
func add(t tree) {
    list = append(list, 1|t<<1)
}
 
func show(t tree, l uint) {
    for ; l > 0; t >>= 1 {
        l--
        var paren byte
        if (t & 1) != 0 {
            paren = '('
        } else {
            paren = ')'
        }
        fmt.Printf(""%c"", paren)
    }
}
 
func listTrees(n uint) {
    for i := offset[n]; i < offset[n+1]; i++ {
        show(list[i], n*2)
        fmt.Println()
    }
}
 
/* assemble tree from subtrees
n:   length of tree we want to make
t:   assembled parts so far
sl:  length of subtree we are looking at
pos: offset of subtree we are looking at
rem: remaining length to be put together
*/
 
func assemble(n uint, t tree, sl, pos, rem uint) {
    if rem == 0 {
        add(t)
        return
    }
 
    if sl > rem { // need smaller sub-trees
        sl = rem
        pos = offset[sl]
    } else if pos >= offset[sl+1] {
        // used up sl-trees, try smaller ones
        sl--
        if sl == 0 {
            return
        }
        pos = offset[sl]
    }
 
    assemble(n, t<<(2*sl)|list[pos], sl, pos, rem-sl)
    assemble(n, t, sl, pos+1, rem)
}
 
func mktrees(n uint) {
    if offset[n+1] > 0 {
        return
    }
    if n > 0 {
        mktrees(n - 1)
    }
 
    assemble(n, 0, n-1, offset[n-1], n-1)
    offset[n+1] = uint(len(list))
}
 
func main() {
    if len(os.Args) != 2 {
        log.Fatal(""There must be exactly 1 command line argument"")
    }
    n, err := strconv.Atoi(os.Args[1])
    if err != nil {
        log.Fatal(""Argument is not a valid number"")
    }
    if n <= 0 || n > 19 { // stack overflow for n == 20
        n = 5
    }
    // init 1-tree
    add(0)
 
    mktrees(uint(n))
    fmt.Fprintf(os.Stderr, ""Number of %d-trees: %d\n"", n, offset[n+1]-offset[n])
    listTrees(uint(n))
}",1912,100
39148,http://rosettacode.org/wiki/Long_year,Long year,"Most years have 52 weeks, some have 53, according to ISO8601.



Task

Write a function which determines if a given year is long (53 weeks) or not, and demonstrate it.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""time""
)
 
func main() {
    centuries := []string{""20th"", ""21st"", ""22nd""}
    starts := []int{1900, 2000, 2100} 
    for i := 0; i < len(centuries); i++ {
        var longYears []int
        fmt.Printf(""\nLong years in the %s century:\n"", centuries[i])
        for j := starts[i]; j < starts[i] + 100; j++ {
            t := time.Date(j, time.December, 28, 0, 0, 0, 0, time.UTC)
            if _, week := t.ISOWeek(); week == 53 {
                longYears = append(longYears, j)
            }
        }
        fmt.Println(longYears)
    }
}",581,22
39194,http://rosettacode.org/wiki/Long_primes,Long primes,"

A   long prime   (as defined here)   is a prime number whose reciprocal   (in decimal)   has
a   period length   of one less than the prime number.


Long primes   are also known as:

   base ten cyclic numbers
   full reptend primes
   golden primes
   long period primes
   maximal period primes
   proper primes


Another definition:   primes   p   such that the decimal expansion of   1/p   has period   p-1,   which is the greatest period possible for any integer.



Example

7   is the first long prime,   the reciprocal of seven
is   1/7,   which
is equal to the repeating decimal fraction   0.142857142857···

The length of the   repeating   part of the decimal fraction
is six,   (the underlined part)   which is one less
than the (decimal) prime number   7.

Thus   7   is a long prime.



There are other (more) general definitions of a   long prime   which
include wording/verbiage for bases other than ten.



Task

   Show all long primes up to   500   (preferably on one line).
   Show the   number   of long primes up to         500
   Show the   number   of long primes up to      1,000
   Show the   number   of long primes up to      2,000
   Show the   number   of long primes up to      4,000
   Show the   number   of long primes up to      8,000
   Show the   number   of long primes up to   16,000
   Show the   number   of long primes up to   32,000
   Show the   number   of long primes up to   64,000   (optional)
   Show all output here.


Also see

   Wikipedia: full reptend prime
   MathWorld: full reptend prime
   OEIS: A001913

",#Go,Go,"package main
 
import ""fmt""
 
func sieve(limit int) []int {
    var primes []int
    c := make([]bool, limit + 1) // composite = true
    // no need to process even numbers
    p := 3
    p2 := p * p
    for p2 <= limit {
        for i := p2; i <= limit; i += 2 * p {
            c[i] = true
        }
        for ok := true; ok; ok = c[p] {
            p += 2
        }
        p2 = p * p
    }
    for i := 3; i <= limit; i += 2 {
        if !c[i] {
            primes = append(primes, i)
        }
    }
    return primes
}
 
// finds the period of the reciprocal of n
func findPeriod(n int) int {
    r := 1
    for i := 1; i <= n + 1; i++ {
        r = (10 * r) % n
    }
    rr := r
    period := 0
    for ok := true; ok; ok = r != rr {
        r = (10 * r) % n
        period++
    }
    return period
}
 
func main() {
    primes := sieve(64000)
    var longPrimes []int
    for _, prime := range primes {
        if findPeriod(prime) == prime - 1 {
            longPrimes = append(longPrimes, prime)
        }
    }
    numbers := []int{500, 1000, 2000, 4000, 8000, 16000, 32000, 64000}
    index := 0
    count := 0
    totals := make([]int, len(numbers))
    for _, longPrime := range longPrimes {
        if longPrime > numbers[index] {
            totals[index] = count
            index++
        }
        count++
    }
    totals[len(numbers)-1] = count
    fmt.Println(""The long primes up to"", numbers[0], ""are: "")
    fmt.Println(longPrimes[:totals[0]])
 
    fmt.Println(""\nThe number of long primes up to: "")
    for i, total := range totals {
        fmt.Printf(""  %5d is %d\n"", numbers[i], total)
    }
}",1627,70
39323,http://rosettacode.org/wiki/Literals/Floating_point,Literals/Floating point,"Programming languages have different ways of expressing floating-point literals.



Task

Show how floating-point literals can be expressed in your language: decimal or other bases, exponential notation, and any other special features.

You may want to include a regular expression or BNF/ABNF/EBNF defining allowable formats for your language.



Related tasks

   Literals/Integer
   Extreme floating point values

",#Go,Go,"0.
0.0
.0
1e3
1e-300
6.02E+23",29,6
39460,http://rosettacode.org/wiki/Loops/Continue,Loops/Continue,"Task

Show the following output using one loop.

1, 2, 3, 4, 5
6, 7, 8, 9, 10



Try to achieve the result by forcing the next iteration within the loop
upon a specific condition, if your language allows it.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    for i := 1; i <= 10; i++ {
        fmt.Printf(""%d"", i)
        if i%5 == 0 {
            fmt.Printf(""\n"")
            continue
        }
        fmt.Printf("", "")
    }
}",217,14
39475,http://rosettacode.org/wiki/Loops/For,Loops/For,"“For”   loops are used to make some block of code be iterated a number of times, setting a variable or parameter to a monotonically increasing integer value for each execution of the block of code.

Common extensions of this allow other counting patterns or iterating over abstract structures other than the integers.



Task

Show how two loops may be nested within each other, with the number of iterations performed by the inner for loop being controlled by the outer for loop.

Specifically print out the following pattern by using one for loop nested in another:

*
**
***
****
*****


Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges




Reference

 For loop Wikipedia.

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    for i := 1; i <= 5; i++ {
        for j := 1; j <= i; j++ {
            fmt.Printf(""*"")
        }
        fmt.Printf(""\n"")
    }
}",178,12
39571,http://rosettacode.org/wiki/Longest_common_subsequence,Longest common subsequence,"Introduction

Define a subsequence to be any output string obtained by deleting zero or more symbols from an input string.

The Longest Common Subsequence (LCS) is a subsequence of maximum length common to two or more strings.

Let A ≡ A[0]… A[m - 1] and B ≡ B[0]… B[n - 1], m < n be strings drawn from an alphabet Σ of size s, containing every distinct symbol in A + B.

An ordered pair (i, j) will be referred to as a match if A[i] = B[j], where 0 < i ≤ m and 0 < j ≤ n.

Define a non-strict product-order (≤) over ordered pairs, such that (i1, j1) ≤ (i2, j2) ⇔ i1 ≤ i2 and j1 ≤ j2. We define (≥) similarly.

We say m1, m2 are comparable if either m1 ≤ m2 or m1 ≥ m2 holds. If i1 < i2 and j2 < j1 (or i2 < i1 and j1 < j2) then neither m1 ≤ m2 nor m1 ≥ m2 are possible; and we say m1, m2 are incomparable.

We also define the strict product-order (<) over ordered pairs, such that (i1, j1) < (i2, j2) ⇔ i1 < i2 and j1 < j2. We define (>) similarly.

Given a set of matches M, a chain C is a subset of M consisting of at least one element m; and where either m1 < m2 or m1 > m2 for every pair of distinct elements m1 and m2. An antichain D is any subset of M in which every pair of distinct elements m1 and m2 are incomparable.

The set M represents a relation over match pairs: M[i, j] ⇔ (i, j) ∈ M. A chain C can be visualized as a curve which strictly increases as it passes through each match pair in the m*n coordinate space.

Finding an LCS can be restated as the problem of finding a chain of maximum cardinality p over the set of matches M.

According to [Dilworth 1950], this cardinality p equals the minimum number of disjoint antichains into which M can be decomposed. Note that such a decomposition into the minimal number p of disjoint antichains may not be unique.

Contours

Forward Contours FC[k] of class k are defined inductively, as follows:

FC[0] consists of those elements m1 for which there exists no element m2 such that m2 < m1.

FC[k] consists of those elements m1 for which there exists no element m2 such that m2 < m1; and where neither m1 nor m2 are contained in FC[l] for any class l < k.

Reverse Contours RC[k] of class k are defined similarly.

Members of the Meet (∧), or Infimum of a Forward Contour are referred to as its Dominant Matches: those m1 for which there exists no m2 such that m2 < m1.

Members of the Join (∨), or Supremum of a Reverse Contour are referred to as its Dominant Matches: those m1 for which there exists no m2 such that m2 > m1.

Where multiple Dominant Matches exist within a Meet (or within a Join, respectively) the Dominant Matches will be incomparable to each other.

Background

Where the number of symbols appearing in matches is small relative to the length of the input strings, reuse of the symbols increases; and the number of matches will tend towards quadratic, O(m*n) growth. This occurs, for example, in the Bioinformatics application of nucleotide and protein sequencing.

The divide-and-conquer approach of [Hirschberg 1975] limits the space required to O(n). However, this approach requires O(m*n) time even in the best case.

This quadratic time dependency may become prohibitive, given very long input strings. Thus, heuristics are often favored over optimal Dynamic Programming solutions.

In the application of comparing file revisions, records from the input files form a large symbol space; and the number of symbols approaches the length of the LCS. In this case the number of matches reduces to linear, O(n) growth.

A binary search optimization due to [Hunt and Szymanski 1977] can be applied to the basic Dynamic Programming approach, resulting in an expected performance of O(n log m). Performance can degrade to O(m*n log m) time in the worst case, as the number of matches grows to O(m*n).

Note

[Rick 2000] describes a linear-space algorithm with a time bound of O(n*s + p*min(m, n - p)).

Legend

A, B are input strings of lengths m, n respectively
p is the length of the LCS
M is the set of match pairs (i, j) such that A[i] = B[j]
r is the magnitude of M
s is the magnitude of the alphabet Σ of distinct symbols in A + B

References

[Dilworth 1950] ""A decomposition theorem for partially ordered sets""
by Robert P. Dilworth, published January 1950,
Annals of Mathematics [Volume 51, Number 1, pp. 161-166]

[Goeman and Clausen 2002] ""A New Practical Linear Space Algorithm for the Longest Common
Subsequence Problem"" by Heiko Goeman and Michael Clausen,
published 2002, Kybernetika [Volume 38, Issue 1, pp. 45-66]

[Hirschberg 1975] ""A linear space algorithm for computing maximal common subsequences""
by Daniel S. Hirschberg, published June 1975
Communications of the ACM [Volume 18, Number 6, pp. 341-343]

[Hunt and McIlroy 1976] ""An Algorithm for Differential File Comparison""
by James W. Hunt and M. Douglas McIlroy, June 1976
Computing Science Technical Report, Bell Laboratories 41

[Hunt and Szymanski 1977] ""A Fast Algorithm for Computing Longest Common Subsequences""
by James W. Hunt and Thomas G. Szymanski, published May 1977
Communications of the ACM [Volume 20, Number 5, pp. 350-353]

[Rick 2000] ""Simple and fast linear space computation of longest common subsequences""
by Claus Rick, received 17 March 2000, Information Processing Letters,
Elsevier Science [Volume 75, pp. 275–281]



Examples

The sequences ""1234"" and ""1224533324"" have an LCS of ""1234"":

1234
1224533324

For a string example, consider the sequences ""thisisatest"" and ""testing123testing"". An LCS would be ""tsitest"":

thisisatest
testing123testing

In this puzzle, your code only needs to deal with strings. Write a function which returns an LCS of two strings (case-sensitive). You don't need to show multiple LCS's.

For more information on this problem please see Wikipedia.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"func lcs(a, b string) string {
    aLen := len(a)
    bLen := len(b)
    if aLen == 0 || bLen == 0 {
        return """"
    } else if a[aLen-1] == b[bLen-1] {
        return lcs(a[:aLen-1], b[:bLen-1]) + string(a[aLen-1])
    }
    x := lcs(a, b[:bLen-1])
    y := lcs(a[:aLen-1], b)
    if len(x) > len(y) {
        return x
    }
    return y
}",345,15
39817,http://rosettacode.org/wiki/Loops/Break,Loops/Break,"Task

Show a loop which prints random numbers (each number newly generated each loop) from 0 to 19 (inclusive).

If a number is 10, stop the loop after printing it, and do not generate any further numbers.

Otherwise, generate and print a second random number before restarting the loop.

If the number 10 is never generated as the first number in a loop, loop forever.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges

",#Go,Go,"package main
 
import ""fmt""
import ""math/rand""
import ""time""
 
func main() {
    rand.Seed(time.Now().UnixNano())
    for {
        a := rand.Intn(20)
        fmt.Println(a)
        if a == 10 {
            break
        }
        b := rand.Intn(20)
        fmt.Println(b)
    }
}",280,18
39838,http://rosettacode.org/wiki/Literals/String,Literals/String,"Task

Show literal specification of characters and strings.

If supported, show how the following work:

   verbatim strings   (quotes where escape sequences are quoted literally)
   here-strings   


Also, discuss which quotes expand variables.



Related tasks
 
   Special characters
   Here document



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"ch := 'z'
ch = 122          // or 0x7a or 0172 or any other integer literal
ch = '\x7a'       // \x{2*hex}
ch = '\u007a'     // \u{4*hex}
ch = '\U0000007a' // \U{8*hex}
ch = '\172'       // \{3*octal}",200,6
39906,http://rosettacode.org/wiki/Literals/Integer,Literals/Integer,"Some programming languages have ways of expressing integer literals in bases other than the normal base ten.



Task

Show how integer literals can be expressed in as many bases as your language allows.



Note:   this should not involve the calling of any functions/methods, but should be interpreted by the compiler or interpreter as an integer written to a given base.

Also show any other ways of expressing literals, e.g. for different types of integers.



Related task

   Literals/Floating point

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
	fmt.Println(727 == 0x2d7)         // prints true
	fmt.Println(727 == 01327)         // prints true
	fmt.Println(727 == 0b10110_10111) // prints true
	fmt.Println(727 == '˗')           // prints true
}
 ",247,11
40023,http://rosettacode.org/wiki/Long_multiplication,Long multiplication,"Task

Explicitly implement   long multiplication.

This is one possible approach to arbitrary-precision integer algebra.



For output, display the result of    264 * 264.

Optionally, verify your result against builtin arbitrary precision support.

The decimal representation of    264    is:

18,446,744,073,709,551,616

The output of    264 * 264    is    2128,    and is:

340,282,366,920,938,463,463,374,607,431,768,211,456


",#Go,Go,"// Long multiplication per WP article referenced by task description.
// That is, multiplicand is multiplied by single digits of multiplier
// to form intermediate results.  Intermediate results are accumulated
// for the product.  Used here is the abacus method mentioned by the
// article, of summing intermediate results as they are produced,
// rather than all at once at the end.
//
// Limitations:  Negative numbers not supported, superfluous leading zeros
// not generally removed.
package main
 
import ""fmt""
 
// argument validation
func d(b byte) byte {
    if b < '0' || b > '9' {
        panic(""digit 0-9 expected"")
    }
    return b - '0'
}
 
// add two numbers as strings
func add(x, y string) string {
    if len(y) > len(x) {
        x, y = y, x
    }
    b := make([]byte, len(x)+1)
    var c byte
    for i := 1; i <= len(x); i++ {
        if i <= len(y) {
            c += d(y[len(y)-i])
        }
        s := d(x[len(x)-i]) + c
        c = s / 10
        b[len(b)-i] = (s % 10) + '0'
    }
    if c == 0 {
        return string(b[1:])
    }
    b[0] = c + '0'
    return string(b)
}
 
// multipy a number by a single digit
func mulDigit(x string, y byte) string {
    if y == '0' {
        return ""0""
    }
    y = d(y)
    b := make([]byte, len(x)+1)
    var c byte
    for i := 1; i <= len(x); i++ {
        s := d(x[len(x)-i])*y + c
        c = s / 10
        b[len(b)-i] = (s % 10) + '0'
    }
    if c == 0 {
        return string(b[1:])
    }
    b[0] = c + '0'
    return string(b)
}
 
// multiply two numbers as strings
func mul(x, y string) string {
    result := mulDigit(x, y[len(y)-1])
    for i, zeros := 2, """"; i <= len(y); i++ {
        zeros += ""0""
        result = add(result, mulDigit(x, y[len(y)-i])+zeros)
    }
    return result
}
 
// requested output
const n = ""18446744073709551616""
 
func main() {
    fmt.Println(mul(n, n))
}",1873,79
40160,http://rosettacode.org/wiki/Logical_operations,Logical operations,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Write a function that takes two logical (boolean) values, and outputs the result of ""and"" and ""or"" on both arguments as well as ""not"" on the first arguments.

If the programming language doesn't provide a separate type for logical values, use the type most commonly used for that purpose.

If the language supports additional logical operations on booleans such as XOR, list them as well.



",#Go,Go,"func printLogic(a, b bool) {
    fmt.Println(""a and b is"", a && b)
    fmt.Println(""a or b is"", a || b)
    fmt.Println(""not a is"", !a)
}",137,5
40165,http://rosettacode.org/wiki/Look-and-say_sequence,Look-and-say sequence,"The   Look and say sequence   is a recursively defined sequence of numbers studied most notably by   John Conway.



The   look-and-say sequence   is also known as the   Morris Number Sequence,   after cryptographer Robert Morris,   and the puzzle   What is the next number in the sequence 1,   11,   21,   1211,   111221?   is sometimes referred to as the Cuckoo's Egg,   from a description of Morris in Clifford Stoll's book   The Cuckoo's Egg.


Sequence Definition

 Take a decimal number
 Look at the number, visually grouping consecutive runs of the same digit.
 Say the number, from left to right, group by group; as how many of that digit there are - followed by the digit grouped.
 This becomes the next number of the sequence.

An example:

 Starting with the number 1,   you have one 1 which produces 11
 Starting with 11,   you have two 1's.   I.E.:   21
 Starting with 21,   you have one 2, then one 1.   I.E.:   (12)(11) which becomes 1211
 Starting with 1211,   you have one 1, one 2, then two 1's.   I.E.:   (11)(12)(21) which becomes 111221


Task

Write a program to generate successive members of the look-and-say sequence.



Related tasks

   Fours is the number of letters in the ...
   Number names
   Self-describing numbers
   Self-referential sequence
   Spelling of ordinal numbers


See also

   Look-and-Say Numbers (feat John Conway), A Numberphile Video.
   This task is related to, and an application of, the Run-length encoding task.
   Sequence A005150 on The On-Line Encyclopedia of Integer Sequences.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
func lss(s string) (r string) {
    c := s[0]
    nc := 1
    for i := 1; i < len(s); i++ {
        d := s[i]
        if d == c {
            nc++
            continue
        }
        r += strconv.Itoa(nc) + string(c)
        c = d
        nc = 1
    }
    return r + strconv.Itoa(nc) + string(c)
}
 
func main() {
    s := ""1""
    fmt.Println(s)
    for i := 0; i < 8; i++ {
        s = lss(s)
        fmt.Println(s)
    }
}",479,31
40272,http://rosettacode.org/wiki/Loop_over_multiple_arrays_simultaneously,Loop over multiple arrays simultaneously,"Task

Loop over multiple arrays   (or lists or tuples or whatever they're called in
your language)   and display the    i th    element of each.

Use your language's   ""for each""   loop if it has one, otherwise iterate
through the collection in order with some other loop.



For this example, loop over the arrays:

    (a,b,c)
    (A,B,C) 
    (1,2,3) 

to produce the output:

    aA1
    bB2
    cC3



If possible, also describe what happens when the arrays are of different lengths.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",#Go,Go,"package main
 
import ""fmt""
 
var a1 = []string{""a"", ""b"", ""c""}
var a2 = []byte{'A', 'B', 'C'}
var a3 = []int{1, 2, 3}
 
func main() {
	for i := range a1 {
		fmt.Printf(""%v%c%v\n"", a1[i], a2[i], a3[i])
	}
}",205,13
40897,http://rosettacode.org/wiki/Levenshtein_distance/Alignment,Levenshtein distance/Alignment,"The Levenshtein distance algorithm returns the number of atomic operations (insertion, deletion or edition) that must be performed on a string in order to obtain an other one, but it does not say anything about the actual operations used or their order.

An alignment is a notation used to describe the operations used to turn a string into an other. At some point in the strings, the minus character ('-') is placed in order to signify that a character must be added at this very place. For instance, an alignment between the words 'place' and 'palace' is:

P-LACE
PALACE



Task

Write a function that shows the alignment of two strings for the corresponding levenshtein distance.

As an example, use the words ""rosettacode"" and ""raisethysword"".

You can either implement an algorithm, or use a dedicated library (thus showing us how it is named in your language).



",#Go,Go,"package main
 
import (
    ""fmt""
 
    ""github.com/biogo/biogo/align""
    ab ""github.com/biogo/biogo/alphabet""
    ""github.com/biogo/biogo/feat""
    ""github.com/biogo/biogo/seq/linear""
)
 
func main() {
    // Alphabets for things like DNA are predefined in biogo, but we
    // define our own here.
    lc := ab.Must(ab.NewAlphabet(""-abcdefghijklmnopqrstuvwxyz"",
        feat.Undefined, '-', 0, true))
    // Construct scoring matrix for Needleman-Wunch algorithm.
    // We leave zeros on the diagonal for the Levenshtein distance of an
    // exact match and put -1s everywhere else for the Levenshtein distance
    // of an edit.
    nw := make(align.NW, lc.Len())
    for i := range nw {
        r := make([]int, lc.Len())
        nw[i] = r
        for j := range r {
            if j != i {
                r[j] = -1
            }
        }
    }
    // define input sequences
    a := &linear.Seq{Seq: ab.BytesToLetters([]byte(""rosettacode""))}
    a.Alpha = lc
    b := &linear.Seq{Seq: ab.BytesToLetters([]byte(""raisethysword""))}
    b.Alpha = lc
    // perform alignment
    aln, err := nw.Align(a, b)
    // format and display result
    if err != nil {
        fmt.Println(err)
        return
    }
    fa := align.Format(a, b, aln, '-')
    fmt.Printf(""%s\n%s\n"", fa[0], fa[1])
    aa := fmt.Sprint(fa[0])
    ba := fmt.Sprint(fa[1])
    ma := make([]byte, len(aa))
    for i := range ma {
        if aa[i] == ba[i] {
            ma[i] = ' '
        } else {
            ma[i] = '|'
        }
    }
    fmt.Println(string(ma))
}",1541,56
40901,http://rosettacode.org/wiki/Legendre_prime_counting_function,Legendre prime counting function,"The prime-counting function π(n) computes the number of primes not greater than n. Legendre was the first mathematician to create a formula to compute π(n) based on the inclusion/exclusion principle.

To calculate:

Define

φ(x, 0) = x
φ(x, a) = φ(x, a−1) − φ(⌊x/pa⌋, a−1), where pa is the ath prime number.

then

π(n) = 0 when n < 2
π(n) = φ(n, a) + a - 1, where a = π(√n), n ≥ 2

The Legendre formula still requires the use of a sieve to enumerate primes; however it's only required to sieve up to the √n, and for counting primes, the Legendre method is generally much faster than sieving up to n.

Task

Calculate π(n) for values up to 1 billion. Show π(n) for n = 1, 10, 100, ... 109.

For this task, you may refer to a prime number sieve (such as the Sieve of Eratosthenes or the extensible sieve) in an external library to enumerate the primes required by the formula. Also note that it will be necessary to memoize the results of φ(x, a) in order to have reasonable performance, since the recurrence relation would otherwise take exponential time.




",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math""
    ""rcu""
)
 
var limit = int(math.Sqrt(1e9))
var primes = rcu.Primes(limit)
var memoPhi = make(map[int]int)
 
func cantorPair(x, y int) int {
    if x < 0 || y < 0 {
        log.Fatal(""Arguments must be non-negative integers."")
    }
    return (x*x + 3*x + 2*x*y + y + y*y) / 2
}
 
func phi(x, a int) int {
    if a == 0 {
        return x
    }
    key := cantorPair(x, a)
    if v, ok := memoPhi[key]; ok {
        return v
    }
    pa := primes[a-1]
    memoPhi[key] = phi(x, a-1) - phi(x/pa, a-1)
    return memoPhi[key]
}
 
func pi(n int) int {
    if n < 2 {
        return 0
    }
    a := pi(int(math.Sqrt(float64(n))))
    return phi(n, a) + a - 1
}
 
func main() {
    for i, n := 0, 1; i <= 9; i, n = i+1, n*10 {
        fmt.Printf(""10^%d  %d\n"", i, pi(n))
    }
}",833,46
41050,http://rosettacode.org/wiki/List_comprehensions,List comprehensions,"A list comprehension is a special syntax in some programming languages to describe lists. It is similar to the way mathematicians describe sets, with a set comprehension, hence the name.

Some attributes of a list comprehension are:

 They should be distinct from (nested) for loops and the use of map and filter functions within the syntax of the language.
 They should return either a list or an iterator (something that returns successive members of a collection, in order).
 The syntax has parts corresponding to that of set-builder notation. 


Task

Write a list comprehension that builds the list of all Pythagorean triples with elements between   1   and   n.

If the language has multiple ways for expressing such a construct (for example, direct list comprehensions and generators), write one example for each.



",#Go,Go,"package main
 
import ""fmt""
 
type (
    seq  []int
    sofs []seq
)
 
func newSeq(start, end int) seq {
    if end < start {
        end = start
    }
    s := make(seq, end-start+1)
    for i := 0; i < len(s); i++ {
        s[i] = start + i
    }
    return s
}
 
func newSofs() sofs {
    return sofs{seq{}}
}
 
func (s sofs) listComp(in seq, expr func(sofs, seq) sofs, pred func(seq) bool) sofs {
    var s2 sofs
    for _, t := range expr(s, in) {
        if pred(t) {
            s2 = append(s2, t)
        }
    }
    return s2
}
 
func (s sofs) build(t seq) sofs {
    var u sofs
    for _, ss := range s {
        for _, tt := range t {
            uu := make(seq, len(ss))
            copy(uu, ss)
            uu = append(uu, tt)
            u = append(u, uu)
        }
    }
    return u
}
 
func main() {
    pt := newSofs()
    in := newSeq(1, 20)
    expr := func(s sofs, t seq) sofs {
        return s.build(t).build(t).build(t)
    }
    pred := func(t seq) bool {
        if len(t) != 3 {
            return false
        }
        return t[0]*t[0]+t[1]*t[1] == t[2]*t[2] && t[0] < t[1] && t[1] < t[2]
    }
    pt = pt.listComp(in, expr, pred)
    fmt.Println(pt)
}",1183,62
41080,http://rosettacode.org/wiki/Leonardo_numbers,Leonardo numbers,"
Leonardo numbers   are also known as the   Leonardo series.



The   Leonardo numbers   are a sequence of numbers defined by:

       L(0) = 1                                          [1st equation]  
       L(1) = 1                                          [2nd equation]  
       L(n) = L(n-1)  +    L(n-2)   +  1                 [3rd equation]  
                    ─── also ───
       L(n) =      2  *  Fib(n+1)   -  1                 [4th equation]  

   where the   + 1   will herein be known as the   add   number.
   where the   FIB   is the   Fibonacci numbers.


This task will be using the 3rd equation (above) to calculate the Leonardo numbers.


Edsger W. Dijkstra   used   Leonardo numbers   as an integral part of
his   smoothsort   algorithm.



The first few Leonardo numbers are:

    1   1   3   5   9   15   25   41   67   109   177   287   465   753   1219   1973   3193   5167   8361  ··· 



Task

   show the 1st   25   Leonardo numbers, starting at L(0).
   allow the first two Leonardo numbers to be specified   [for L(0) and L(1)].
   allow the   add   number to be specified   (1 is the default).
   show the 1st   25   Leonardo numbers, specifying 0 and 1 for L(0) and L(1), and 0 for the add number.
(The last task requirement will produce the Fibonacci numbers.)



Show all output here on this page.



Related tasks

   Fibonacci number
   Fibonacci n-step number sequences 


See also

   Wikipedia, Leonardo numbers
   Wikipedia, Fibonacci numbers
   OEIS Leonardo numbers

",#Go,Go,"package main
 
import ""fmt""
 
func leonardo(n, l0, l1, add int) []int {
    leo := make([]int, n)
    leo[0] = l0
    leo[1] = l1
    for i := 2; i < n; i++ {
        leo[i] = leo[i - 1] + leo[i - 2] + add
    }
    return leo
}
 
func main() {
    fmt.Println(""The first 25 Leonardo numbers with L[0] = 1, L[1] = 1 and add number = 1 are:"")
    fmt.Println(leonardo(25, 1, 1, 1))
    fmt.Println(""\nThe first 25 Leonardo numbers with L[0] = 0, L[1] = 1 and add number = 0 are:"")
    fmt.Println(leonardo(25, 0, 1, 0))
}",520,20
41179,http://rosettacode.org/wiki/Latin_Squares_in_reduced_form/Randomizing_using_Jacobson_and_Matthews%E2%80%99_Technique,Latin Squares in reduced form/Randomizing using Jacobson and Matthews’ Technique,"Section 3.3 of [Generalised 2-designs with Block Size 3(Andy L. Drizen)] describes a method of generating Latin Squares of order n attributed to Jacobson and Matthews. The purpose of this task is to produce a function which given a valid Latin Square transforms it to another using this method.

part 1
Use one of the 4 Latin Squares in reduced form of order 4 as X0 to generate 10000 Latin Squares using X(n-1) to generate X(n). Convert the resulting Latin Squares to their reduced form, display them and the number of times each is produced.

part 2
As above for order 5, but do not display the squares. Generate the 56 Latin Squares in reduced form of order 5, confirm that all 56 are produced by the Jacobson and Matthews technique and display the number of each produced.

part 3
Generate 750 Latin Squares of order 42 and display the 750th.

part 4
Generate 1000 Latin Squares of order 256. Don't display anything but confirm the approximate time taken and anything else you may find interesting
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
type (
    vector []int
    matrix []vector
    cube   []matrix
)
 
func toReduced(m matrix) matrix {
    n := len(m)
    r := make(matrix, n)
    for i := 0; i < n; i++ {
        r[i] = make(vector, n)
        copy(r[i], m[i])
    }
    for j := 0; j < n-1; j++ {
        if r[0][j] != j {
            for k := j + 1; k < n; k++ {
                if r[0][k] == j {
                    for i := 0; i < n; i++ {
                        r[i][j], r[i][k] = r[i][k], r[i][j]
                    }
                    break
                }
            }
        }
    }
    for i := 1; i < n-1; i++ {
        if r[i][0] != i {
            for k := i + 1; k < n; k++ {
                if r[k][0] == i {
                    for j := 0; j < n; j++ {
                        r[i][j], r[k][j] = r[k][j], r[i][j]
                    }
                    break
                }
            }
        }
    }
    return r
}
 
// 'm' is assumed to be 0 based
func printMatrix(m matrix) {
    n := len(m)
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            fmt.Printf(""%2d "", m[i][j]+1) // back to 1 based
        }
        fmt.Println()
    }
    fmt.Println()
}
 
// converts 4 x 4 matrix to 'flat' array
func asArray16(m matrix) [16]int {
    var a [16]int
    k := 0
    for i := 0; i < 4; i++ {
        for j := 0; j < 4; j++ {
            a[k] = m[i][j]
            k++
        }
    }
    return a
}
 
// converts 5 x 5 matrix to 'flat' array
func asArray25(m matrix) [25]int {
    var a [25]int
    k := 0
    for i := 0; i < 5; i++ {
        for j := 0; j < 5; j++ {
            a[k] = m[i][j]
            k++
        }
    }
    return a
}
 
// 'a' is assumed to be 0 based
func printArray16(a [16]int) {
    for i := 0; i < 4; i++ {
        for j := 0; j < 4; j++ {
            k := i*4 + j
            fmt.Printf(""%2d "", a[k]+1) // back to 1 based
        }
        fmt.Println()
    }
    fmt.Println()
}
 
func shuffleCube(c cube) {
    n := len(c[0])
    proper := true
    var rx, ry, rz int
    for {
        rx = rand.Intn(n)
        ry = rand.Intn(n)
        rz = rand.Intn(n)
        if c[rx][ry][rz] == 0 {
            break
        }
    }
    for {
        var ox, oy, oz int
        for ; ox < n; ox++ {
            if c[ox][ry][rz] == 1 {
                break
            }
        }
        if !proper && rand.Intn(2) == 0 {
            for ox++; ox < n; ox++ {
                if c[ox][ry][rz] == 1 {
                    break
                }
            }
        }
 
        for ; oy < n; oy++ {
            if c[rx][oy][rz] == 1 {
                break
            }
        }
        if !proper && rand.Intn(2) == 0 {
            for oy++; oy < n; oy++ {
                if c[rx][oy][rz] == 1 {
                    break
                }
            }
        }
 
        for ; oz < n; oz++ {
            if c[rx][ry][oz] == 1 {
                break
            }
        }
        if !proper && rand.Intn(2) == 0 {
            for oz++; oz < n; oz++ {
                if c[rx][ry][oz] == 1 {
                    break
                }
            }
        }
 
        c[rx][ry][rz]++
        c[rx][oy][oz]++
        c[ox][ry][oz]++
        c[ox][oy][rz]++
 
        c[rx][ry][oz]--
        c[rx][oy][rz]--
        c[ox][ry][rz]--
        c[ox][oy][oz]--
 
        if c[ox][oy][oz] < 0 {
            rx, ry, rz = ox, oy, oz
            proper = false
        } else {
            proper = true
            break
        }
    }
}
 
func toMatrix(c cube) matrix {
    n := len(c[0])
    m := make(matrix, n)
    for i := 0; i < n; i++ {
        m[i] = make(vector, n)
    }
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            for k := 0; k < n; k++ {
                if c[i][j][k] != 0 {
                    m[i][j] = k
                    break
                }
            }
        }
    }
    return m
}
 
// 'from' matrix is assumed to be 1 based
func makeCube(from matrix, n int) cube {
    c := make(cube, n)
    for i := 0; i < n; i++ {
        c[i] = make(matrix, n)
        for j := 0; j < n; j++ {
            c[i][j] = make(vector, n)
            var k int
            if from == nil {
                k = (i + j) % n
            } else {
                k = from[i][j] - 1
            }
            c[i][j][k] = 1
        }
    }
    return c
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
 
    // part 1
    fmt.Println(""PART 1: 10,000 latin Squares of order 4 in reduced form:\n"")
    from := matrix{{1, 2, 3, 4}, {2, 1, 4, 3}, {3, 4, 1, 2}, {4, 3, 2, 1}}
    freqs4 := make(map[[16]int]int, 10000)
    c := makeCube(from, 4)
    for i := 1; i <= 10000; i++ {
        shuffleCube(c)
        m := toMatrix(c)
        rm := toReduced(m)
        a16 := asArray16(rm)
        freqs4[a16]++
    }
    for a, freq := range freqs4 {
        printArray16(a)
        fmt.Printf(""Occurs %d times\n\n"", freq)
    }
 
    // part 2
    fmt.Println(""\nPART 2: 10,000 latin squares of order 5 in reduced form:"")
    from = matrix{{1, 2, 3, 4, 5}, {2, 3, 4, 5, 1}, {3, 4, 5, 1, 2},
        {4, 5, 1, 2, 3}, {5, 1, 2, 3, 4}}
    freqs5 := make(map[[25]int]int, 10000)
    c = makeCube(from, 5)
    for i := 1; i <= 10000; i++ {
        shuffleCube(c)
        m := toMatrix(c)
        rm := toReduced(m)
        a25 := asArray25(rm)
        freqs5[a25]++
    }
    count := 0
    for _, freq := range freqs5 {
        count++
        if count > 1 {
            fmt.Print("", "")
        }
        if (count-1)%8 == 0 {
            fmt.Println()
        }
        fmt.Printf(""%2d(%3d)"", count, freq)
    }
    fmt.Println(""\n"")
 
    // part 3
    fmt.Println(""\nPART 3: 750 latin squares of order 42, showing the last one:\n"")
    var m42 matrix
    c = makeCube(nil, 42)
    for i := 1; i <= 750; i++ {
        shuffleCube(c)
        if i == 750 {
            m42 = toMatrix(c)
        }
    }
    printMatrix(m42)
 
    // part 4
    fmt.Println(""\nPART 4: 1000 latin squares of order 256:\n"")
    start := time.Now()
    c = makeCube(nil, 256)
    for i := 1; i <= 1000; i++ {
        shuffleCube(c)
    }
    elapsed := time.Since(start)
    fmt.Printf(""Generated in %s\n"", elapsed)
}",6229,277
41251,http://rosettacode.org/wiki/Left_factorials,Left factorials,"Left factorials,   !n,   may refer to either   subfactorials   or to   factorial sums;

the same notation can be confusingly seen being used for the two different definitions.

Sometimes,   subfactorials   (also known as derangements)   may use any of the notations:

     !n`   
     !n  
     n¡  


(It may not be visually obvious, but the last example uses an upside-down exclamation mark.)



This Rosetta Code task will be using this formula   (factorial sums)   for   left factorial:


   



!
n
=

∑

k
=
0


n
−
1


k
!


{\displaystyle !n=\sum _{k=0}^{n-1}k!}




 where


   



!
0
=
0


{\displaystyle !0=0}






Task
Display the left factorials for:

   zero through ten     (inclusive)
   20   through   110   (inclusive)   by tens


Display the length (in decimal digits) of the left factorials for:

   1,000   through   10,000   (inclusive), by thousands.


Also see

   The OEIS entry: A003422 left factorials
   The MathWorld entry: left factorial
   The MathWorld entry: factorial sums
   The MathWorld entry: subfactorial


Related task

   permutations/derangements (subfactorials)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    fmt.Print(""!0 through !10: 0"")
    one := big.NewInt(1)
    n := big.NewInt(1)
    f := big.NewInt(1)
    l := big.NewInt(1)
    next := func() { f.Mul(f, n); l.Add(l, f); n.Add(n, one) }
    for ; ; next() {
        fmt.Print("" "", l)
        if n.Int64() == 10 {
            break
        }
    }
    fmt.Println()
    for {
        for i := 0; i < 10; i++ {
            next()
        }
        fmt.Printf(""!%d: %d\n"", n, l)
        if n.Int64() == 110 {
            break
        }
    }
    fmt.Println(""Lengths of !1000 through !10000 by thousands:"")
    for i := 110; i < 1000; i++ {
        next()
    }
    for {
        fmt.Print("" "", len(l.String()))
        if n.Int64() == 10000 {
            break
        }
        for i := 0; i < 1000; i++ {
            next()
        }
    }
    fmt.Println()
}",882,45
41295,http://rosettacode.org/wiki/Law_of_cosines_-_triples,Law of cosines - triples,"The Law of cosines states that for an angle γ, (gamma) of any triangle, if the sides adjacent to the angle are A and B and the side opposite is C; then the lengths of the sides are related by this formula:

           A2 + B2 - 2ABcos(γ) = C2 

Specific angles

For an angle of of   90º   this becomes the more familiar ""Pythagoras equation"":

           A2 + B2  =  C2           

For an angle of   60º   this becomes the less familiar equation:

           A2 + B2 - AB  =  C2       

And finally for an angle of   120º   this becomes the equation:

           A2 + B2 + AB  =  C2      



Task

   Find all integer solutions (in order) to the three specific cases, distinguishing between each angle being considered.
   Restrain all sides to the integers   1..13   inclusive.
   Show how many results there are for each of the three angles mentioned above.
   Display results on this page.


Note: Triangles with the same length sides but different order are to be treated as the same.

Optional Extra credit

 How many 60° integer triples are there for sides in the range 1..10_000 where the sides are not all of the same length.


Related Task
 Pythagorean triples


See also

 Visualising Pythagoras: ultimate proofs and crazy contortions Mathlogger Video

",#Go,Go,"package main
 
import ""fmt""
 
type triple struct{ a, b, c int }
 
var squares13 = make(map[int]int, 13)
var squares10000 = make(map[int]int, 10000)
 
func init() {
    for i := 1; i <= 13; i++ {
        squares13[i*i] = i
    }
    for i := 1; i <= 10000; i++ {
        squares10000[i*i] = i
    }
}
 
func solve(angle, maxLen int, allowSame bool) []triple {
    var solutions []triple
    for a := 1; a <= maxLen; a++ {
        for b := a; b <= maxLen; b++ {
            lhs := a*a + b*b
            if angle != 90 {
                switch angle {
                case 60:
                    lhs -= a * b
                case 120:
                    lhs += a * b
                default:
                    panic(""Angle must be 60, 90 or 120 degrees"")
                }
            }
            switch maxLen {
            case 13:
                if c, ok := squares13[lhs]; ok {
                    if !allowSame && a == b && b == c {
                        continue
                    }
                    solutions = append(solutions, triple{a, b, c})
                }
            case 10000:
                if c, ok := squares10000[lhs]; ok {
                    if !allowSame && a == b && b == c {
                        continue
                    }
                    solutions = append(solutions, triple{a, b, c})
                }
            default:
                panic(""Maximum length must be either 13 or 10000"")
            }
        }
    }
    return solutions
}
 
func main() {
    fmt.Print(""For sides in the range [1, 13] "")
    fmt.Println(""where they can all be of the same length:-\n"")
    angles := []int{90, 60, 120}
    var solutions []triple
    for _, angle := range angles {
        solutions = solve(angle, 13, true)
        fmt.Printf(""  For an angle of %d degrees"", angle)
        fmt.Println("" there are"", len(solutions), ""solutions, namely:"")
        fmt.Printf(""  %v\n"", solutions)
        fmt.Println()
    }
    fmt.Print(""For sides in the range [1, 10000] "")
    fmt.Println(""where they cannot ALL be of the same length:-\n"")
    solutions = solve(60, 10000, false)
    fmt.Print(""  For an angle of 60 degrees"")
    fmt.Println("" there are"", len(solutions), ""solutions."")
}",2226,74
41311,http://rosettacode.org/wiki/Latin_Squares_in_reduced_form,Latin Squares in reduced form,"A Latin Square is in its reduced form if the first row and first column contain items in their natural order. The order n is the number of items. For any given n there is a set of reduced Latin Squares whose size increases rapidly with n. g is a number which identifies a unique element within the set of reduced Latin Squares of order n. The objective of this task is to construct the set of all Latin Squares of a given order and to provide a means which given suitable values for g any element within the set may be obtained.

For a reduced Latin Square the first row is always 1 to n. The second row is all Permutations/Derangements of 1 to n starting with 2. The third row is all Permutations/Derangements of 1 to n starting with 3 which do not clash (do not have the same item in any column) with row 2. The fourth row is all Permutations/Derangements of 1 to n starting with 4 which do not clash with rows 2 or 3. Likewise continuing to the nth row.

Demonstrate by:

 displaying the four reduced Latin Squares of order 4.
 for n = 1 to 6 (or more) produce the set of reduced Latin Squares; produce a table which shows the size of the set of reduced Latin Squares and compares this value times n! times (n-1)! with the values in OEIS A002860.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
type matrix [][]int
 
// generate derangements of first n numbers, with 'start' in first place.
func dList(n, start int) (r matrix) {
    start-- // use 0 basing
    a := make([]int, n)
    for i := range a {
        a[i] = i
    }
    a[0], a[start] = start, a[0]
    sort.Ints(a[1:])
    first := a[1]
    // recursive closure permutes a[1:]
    var recurse func(last int)
    recurse = func(last int) {
        if last == first {
            // bottom of recursion.  you get here once for each permutation.
            // test if permutation is deranged.
            for j, v := range a[1:] { // j starts from 0, not 1
                if j+1 == v {
                    return // no, ignore it
                }
            }
            // yes, save a copy
            b := make([]int, n)
            copy(b, a)
            for i := range b {
                b[i]++ // change back to 1 basing
            }
            r = append(r, b)
            return
        }
        for i := last; i >= 1; i-- {
            a[i], a[last] = a[last], a[i]
            recurse(last - 1)
            a[i], a[last] = a[last], a[i]
        }
    }
    recurse(n - 1)
    return
}
 
func reducedLatinSquare(n int, echo bool) uint64 {
    if n <= 0 {
        if echo {
            fmt.Println(""[]\n"")
        }
        return 0
    } else if n == 1 {
        if echo {
            fmt.Println(""[1]\n"")
        }
        return 1
    }
    rlatin := make(matrix, n)
    for i := 0; i < n; i++ {
        rlatin[i] = make([]int, n)
    }
    // first row
    for j := 0; j < n; j++ {
        rlatin[0][j] = j + 1
    }
 
    count := uint64(0)
    // recursive closure to compute reduced latin squares and count or print them
    var recurse func(i int)
    recurse = func(i int) {
        rows := dList(n, i) // get derangements of first n numbers, with 'i' first.
    outer:
        for r := 0; r < len(rows); r++ {
            copy(rlatin[i-1], rows[r])
            for k := 0; k < i-1; k++ {
                for j := 1; j < n; j++ {
                    if rlatin[k][j] == rlatin[i-1][j] {
                        if r < len(rows)-1 {
                            continue outer
                        } else if i > 2 {
                            return
                        }
                    }
                }
            }
            if i < n {
                recurse(i + 1)
            } else {
                count++
                if echo {
                    printSquare(rlatin, n)
                }
            }
        }
        return
    }
 
    // remaining rows
    recurse(2)
    return count
}
 
func printSquare(latin matrix, n int) {
    for i := 0; i < n; i++ {
        fmt.Println(latin[i])
    }
    fmt.Println()
}
 
func factorial(n uint64) uint64 {
    if n == 0 {
        return 1
    }
    prod := uint64(1)
    for i := uint64(2); i <= n; i++ {
        prod *= i
    }
    return prod
}
 
func main() {
    fmt.Println(""The four reduced latin squares of order 4 are:\n"")
    reducedLatinSquare(4, true)
 
    fmt.Println(""The size of the set of reduced latin squares for the following orders"")
    fmt.Println(""and hence the total number of latin squares of these orders are:\n"")
    for n := uint64(1); n <= 6; n++ {
        size := reducedLatinSquare(int(n), false)
        f := factorial(n - 1)
        f *= f * n * size
        fmt.Printf(""Order %d: Size %-4d x %d! x %d! => Total %d\n"", n, size, n, n-1, f)
    }
}",3494,137
41337,http://rosettacode.org/wiki/Linear_congruential_generator,Linear congruential generator,"The linear congruential generator is a very simple example of a random number generator.

All linear congruential generators use this formula:

 




r

n
+
1


=
a
×

r

n


+
c


(
mod

m
)



{\displaystyle r_{n+1}=a\times r_{n}+c{\pmod {m}}}




Where:

 




r

0




{\displaystyle r_{0}}

 is a seed.
 




r

1




{\displaystyle r_{1}}

, 




r

2




{\displaystyle r_{2}}

, 




r

3




{\displaystyle r_{3}}

, ..., are the random numbers.
 



a


{\displaystyle a}

, 



c


{\displaystyle c}

, 



m


{\displaystyle m}

 are constants.


If one chooses the values of 



a


{\displaystyle a}

, 



c


{\displaystyle c}

 and 



m


{\displaystyle m}

 with care, then the generator produces a uniform distribution of integers from 



0


{\displaystyle 0}

 to 



m
−
1


{\displaystyle m-1}

.

LCG numbers have poor quality. 




r

n




{\displaystyle r_{n}}

 and 




r

n
+
1




{\displaystyle r_{n+1}}

 are not independent, as true random numbers would be. Anyone who knows 




r

n




{\displaystyle r_{n}}

 can predict 




r

n
+
1




{\displaystyle r_{n+1}}

, therefore LCG is not cryptographically secure. The LCG is still good enough for simple tasks like Miller-Rabin primality test, or FreeCell deals. Among the benefits of the LCG, one can easily reproduce a sequence of numbers, from the same 




r

0




{\displaystyle r_{0}}

. One can also reproduce such sequence with a different programming language, because the formula is so simple.

The task is to replicate two historic random number generators. One is the rand() function from BSD libc, and the other is the rand() function from the Microsoft C Runtime (MSCVRT.DLL). Each replica must yield the same sequence of integers as the original generator, when starting from the same seed.

In these formulas, the seed becomes 



s
t
a
t

e

0




{\displaystyle state_{0}}

. The random sequence is 



r
a
n

d

1




{\displaystyle rand_{1}}

, 



r
a
n

d

2




{\displaystyle rand_{2}}

 and so on.



BSD formula

 



s
t
a
t

e

n
+
1


=
1103515245
×
s
t
a
t

e

n


+
12345


(
mod


2

31


)



{\displaystyle state_{n+1}=1103515245\times state_{n}+12345{\pmod {2^{31}}}}


 



r
a
n

d

n


=
s
t
a
t

e

n




{\displaystyle rand_{n}=state_{n}}


 



r
a
n

d

n




{\displaystyle rand_{n}}

 is in range 0 to 2147483647.


Microsoft formula

 



s
t
a
t

e

n
+
1


=
214013
×
s
t
a
t

e

n


+
2531011


(
mod


2

31


)



{\displaystyle state_{n+1}=214013\times state_{n}+2531011{\pmod {2^{31}}}}


 



r
a
n

d

n


=
s
t
a
t

e

n


÷

2

16




{\displaystyle rand_{n}=state_{n}\div 2^{16}}


 



r
a
n

d

n




{\displaystyle rand_{n}}

 is in range 0 to 32767.


The BSD formula was so awful that FreeBSD switched to a different formula.

More info is at Random number generator (included)#C.



",#Go,Go,"package main
 
import ""fmt""
 
// basic linear congruential generator
func lcg(a, c, m, seed uint32) func() uint32 {
    r := seed
    return func() uint32 {
        r = (a*r + c) % m
        return r
    }
}
 
// microsoft generator has extra division step
func msg(seed uint32) func() uint32 {
    g := lcg(214013, 2531011, 1<<31, seed)
    return func() uint32 {
        return g() / (1 << 16)
    }
}
 
func example(seed uint32) {
    fmt.Printf(""\nWith seed = %d\n"", seed)
    bsd := lcg(1103515245, 12345, 1<<31, seed)
    msf := msg(seed)
    fmt.Println(""       BSD  Microsoft"")
    for i := 0; i < 5; i++ {
        fmt.Printf(""%10d    %5d\n"", bsd(), msf())
    }
}
 
func main() {
    example(0)
    example(1)
}",720,35
41473,http://rosettacode.org/wiki/Largest_proper_divisor_of_n,Largest proper divisor of n,"Task
a(1) = 1; for n > 1, a(n) = largest proper divisor of n, where n < 101 .

",#Go,Go,"package main
 
import ""fmt""
 
func largestProperDivisor(n int) int {
    for i := 2; i*i <= n; i++ {
        if n%i == 0 {
            return n / i
        }
    }
    return 1
}
 
func main() {
    fmt.Println(""The largest proper divisors for numbers in the interval [1, 100] are:"")
    fmt.Print("" 1  "")
    for n := 2; n <= 100; n++ {
        if n%2 == 0 {
            fmt.Printf(""%2d  "", n/2)
        } else {
            fmt.Printf(""%2d  "", largestProperDivisor(n))
        }
        if n%10 == 0 {
            fmt.Println()
        }
    }
}",547,27
41515,http://rosettacode.org/wiki/Kosaraju,Kosaraju,"

 This page uses content from Wikipedia. The original article was at Graph. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Kosaraju's algorithm (also known as the Kosaraju–Sharir algorithm) is a linear time algorithm to find the strongly connected components of a directed graph. Aho, Hopcroft and Ullman credit it to an unpublished paper from 1978 by S. Rao Kosaraju. The same algorithm was independently discovered by Micha Sharir and published by him in 1981. It makes use of the fact that the transpose graph (the same graph with the direction of every edge reversed) has exactly the same strongly connected components as the original graph.


For this task consider the directed graph with these connections:

 0 -> 1
 1 -> 2
 2 -> 0
 3 -> 1,  3 -> 2,  3 -> 4
 4 -> 3,  4 -> 5
 5 -> 2,  5 -> 6
 6 -> 5
 7 -> 4, 7  -> 6, 7 -> 7

And report the kosaraju strongly connected component for each node.



References

 The article on Wikipedia.",#Go,Go,"package main
 
import ""fmt""
 
var g = [][]int{
    0: {1},
    1: {2},
    2: {0},
    3: {1, 2, 4},
    4: {3, 5},
    5: {2, 6},
    6: {5},
    7: {4, 6, 7},
}
 
func main() {
    fmt.Println(kosaraju(g))
}
 
func kosaraju(g [][]int) []int {
    // 1. For each vertex u of the graph, mark u as unvisited. Let L be empty.
    vis := make([]bool, len(g))
    L := make([]int, len(g))
    x := len(L)                // index for filling L in reverse order
    t := make([][]int, len(g)) // transpose graph
    // 2. recursive subroutine:
    var Visit func(int)
    Visit = func(u int) {
        if !vis[u] {
            vis[u] = true
            for _, v := range g[u] {
                Visit(v)
                t[v] = append(t[v], u) // construct transpose
            }
            x--
            L[x] = u
        }
    }
    // 2. For each vertex u of the graph do Visit(u)
    for u := range g {
        Visit(u)
    }
    c := make([]int, len(g)) // result, the component assignment
    // 3: recursive subroutine:
    var Assign func(int, int)
    Assign = func(u, root int) {
        if vis[u] { // repurpose vis to mean ""unassigned""
            vis[u] = false
            c[u] = root
            for _, v := range t[u] {
                Assign(v, root)
            }
        }
    }
    // 3: For each element u of L in order, do Assign(u,u)
    for _, u := range L {
        Assign(u, u)
    }
    return c
}",1419,60
41552,http://rosettacode.org/wiki/Last_letter-first_letter,Last letter-first letter,"A certain children's game involves starting with a word in a particular category.   Each participant in turn says a word, but that word must begin with the final letter of the previous word.   Once a word has been given, it cannot be repeated.   If an opponent cannot give a word in the category, they fall out of the game.



For example, with   ""animals""   as the category,

Child 1: dog 
Child 2: goldfish
Child 1: hippopotamus
Child 2: snake
...



Task

Take the following selection of 70 English Pokemon names   (extracted from   Wikipedia's list of Pokemon)   and generate the/a sequence with the highest possible number of Pokemon names where the subsequent name starts with the final letter of the preceding name.

No Pokemon name is to be repeated.

audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon
cresselia croagunk darmanitan deino emboar emolga exeggcute gabite
girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan
kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine
nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2
porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking
sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko
tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask



Extra brownie points for dealing with the full list of   646   names.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
var pokemon = `audino bagon baltoy...67 names omitted...`
 
func main() {
    // split text into slice representing directed graph
    var d []string
    for _, l := range strings.Split(pokemon, ""\n"") {
        d = append(d, strings.Fields(l)...)
    }
    fmt.Println(""searching"", len(d), ""names..."")
    // try each name as possible start
    for i := range d {
        d[0], d[i] = d[i], d[0]
        search(d, 1, len(d[0]))
        d[0], d[i] = d[i], d[0]
    }
    fmt.Println(""maximum path length:"", len(ex))
    fmt.Println(""paths of that length:"", nMax)
    fmt.Print(""example path of that length:"")
    for i, n := range ex {
        if i%6 == 0 {
            fmt.Print(""\n   "")
        }
        fmt.Print(n, "" "")
    }
    fmt.Println()
}
 
var ex []string
var nMax int
 
func search(d []string, i, ncPath int) {
    // tally statistics
    if i == len(ex) {
        nMax++
    } else if i > len(ex) {
        nMax = 1
        ex = append(ex[:0], d[:i]...)
    }
    // recursive search
    lastName := d[i-1]
    lastChar := lastName[len(lastName)-1]
    for j := i; j < len(d); j++ {
        if d[j][0] == lastChar {
            d[i], d[j] = d[j], d[i]
            search(d, i+1, ncPath+1+len(d[i]))
            d[i], d[j] = d[j], d[i]
        }
    }
}",1318,56
41554,http://rosettacode.org/wiki/Largest_number_divisible_by_its_digits,Largest number divisible by its digits,"Task

Find the largest base 10 integer whose digits are all different,   and   is evenly divisible by each of its individual digits.



These numbers are also known as   Lynch-Bell numbers,   numbers   n   such that the
(base ten) digits are all different (and do not include zero)   and   n   is divisible by each of its individual digits.



Example

135   is evenly divisible by   1,   3,   and   5.



Note that the digit zero (0) can not be in the number as integer division by zero is undefined.

The digits must all be unique so a base ten number will have at most 9 digits.

Feel free to use analytics and clever algorithms to reduce the search space your example needs to visit, but it must do an actual search. (Don't just feed it the answer and verify it is correct.)



Stretch goal

Do the same thing for hexadecimal.



Related tasks

   gapful numbers.
   palindromic gapful numbers. 


Also see

   The OEIS sequence:   A115569: Lynch-Bell numbers. 

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
    ""strings""
)
 
func divByAll(num int, digits []byte) bool {
    for _, digit := range digits {
        if num%int(digit-'0') != 0 {
            return false
        }
    }
    return true
}
 
func main() {
    magic := 9 * 8 * 7
    high := 9876432 / magic * magic
    for i := high; i >= magic; i -= magic {
        if i%10 == 0 {
            continue // can't end in '0'
        }
        s := strconv.Itoa(i)
        if strings.ContainsAny(s, ""05"") {
            continue // can't contain '0'or '5'
        }
        var set = make(map[byte]bool)
        var sd []byte // distinct digits
        for _, b := range []byte(s) {
            if !set[b] {
                set[b] = true
                sd = append(sd, b)
            }
        }
        if len(sd) != len(s) {
            continue // digits must be unique
        }
        if divByAll(i, sd) {
            fmt.Println(""Largest decimal number is"", i)
            return
        }
    }
}",1003,45
41581,http://rosettacode.org/wiki/Kolakoski_sequence,Kolakoski sequence,"The Kolakoski sequence is an infinite sequence of natural numbers, (excluding zero); with the property that:

 if you form a new sequence from the counts of runs of the same number in the first sequence, this new sequence is the same as the first sequence.
Example

This is not a Kolakoski sequence:

1,1,2,2,2,1,2,2,1,2,...
Its sequence of run counts, (sometimes called a run length encoding, (RLE); but a true RLE also gives the character that each run encodes), is calculated like this:

 Starting from the leftmost number of the sequence we have 2 ones, followed by 3 twos, then 1 ones, 2 twos, 1 one, ...
The above gives the RLE of:

2, 3, 1, 2, 1, ...
The original sequence is different from its RLE in this case. It would be the same for a true Kolakoski sequence.

Creating a Kolakoski sequence

Lets start with the two numbers (1, 2) that we will cycle through; i.e. they will be used in this order:
 1,2,1,2,1,2,....

 We start the sequence s with the first item from the cycle c:
 1
 An index, k, into the, (expanding), sequence will step, or index through each item of the sequence s from the first, at its own rate.
 
We will arrange that the k'th item of s states how many times the last item of sshould appear at the end of s.

We started s with 1 and therefore s[k] states that it should appear only the 1 time.



Increment k
Get the next item from c and append it to the end of sequence s. s will then become:
 1, 2
k was moved to the second item in the list and s[k] states that it should appear two times, so append another of the last item to the sequence s:
 1, 2,2
Increment k
Append the next item from the cycle to the list:
 1, 2,2, 1
k is now at the third item in the list that states that the last item should appear twice so add another copy of the last item to the sequence s:
 1, 2,2, 1,1
increment k
...

Note that the RLE of 1, 2, 2, 1, 1, ... begins 1, 2, 2 which is the beginning of the original sequence. The generation algorithm ensures that this will always be the case.

Task

 Create a routine/proceedure/function/... that given an initial ordered list/array/tuple etc of the natural numbers (1, 2), returns the next number from the list when accessed in a cycle.
 Create another routine that when given the initial ordered list (1, 2) and the minimum length of the sequence to generate; uses the first routine and the algorithm above, to generate at least the requested first members of the kolakoski sequence.
 Create a routine that when given a sequence, creates the run length encoding of that sequence (as defined above) and returns the result of checking if sequence starts with the exact members of its RLE. (But note, due to sampling, do not compare the last member of the RLE).
 Show, on this page, (compactly), the first 20 members of the sequence generated from (1, 2)
 Check the sequence againt its RLE.
 Show, on this page, the first 20 members of the sequence generated from (2, 1)
 Check the sequence againt its RLE.
 Show, on this page, the first 30 members of the Kolakoski sequence generated from (1, 3, 1, 2)
 Check the sequence againt its RLE.
 Show, on this page, the first 30 members of the Kolakoski sequence generated from (1, 3, 2, 1)
 Check the sequence againt its RLE.
(There are rules on generating Kolakoski sequences from this method that are broken by the last example)
",#Go,Go,"package main
 
import ""fmt""
 
func nextInCycle(c []int, index int) int {
    return c[index % len(c)]
}
 
func kolakoski(c []int, slen int) []int {
    s := make([]int, slen)
    i, k := 0, 0
    for {
        s[i] = nextInCycle(c, k)
        if s[k] > 1 {
            for j := 1; j < s[k]; j++ {
                i++
                if i == slen {
                    return s
                }
                s[i] = s[i - 1]
            }
        }
        i++
        if i == slen {
            return s
        }
        k++
    }
}
 
func possibleKolakoski(s []int) bool {
    slen := len(s)
    rle := make([]int, 0, slen)
    prev := s[0]
    count := 1
    for i := 1; i < slen; i++ {
        if s[i] == prev {
            count++
        } else {
            rle = append(rle, count)
            count = 1
            prev = s[i]
        }
    }
    // no point adding final 'count' to rle as we're not going to compare it anyway
    for i := 0; i < len(rle); i++ {
        if rle[i] != s[i] {
            return false
        }
    }
    return true
}
 
func printInts(ia []int, suffix string) {
    fmt.Print(""["")
    alen := len(ia)
    for i := 0; i < alen; i++ {
        fmt.Print(ia[i])
        if i < alen - 1 {
            fmt.Print("", "")
        }
    }
    fmt.Printf(""]%s\n"", suffix)
}
 
func main() {
    ias := make([][]int, 4)
    ias[0] = []int{1, 2}
    ias[1] = []int{2, 1}
    ias[2] = []int{1, 3, 1, 2}
    ias[3] = []int{1, 3, 2, 1}
    slens := []int{20, 20, 30, 30}
    for i, ia := range ias {
        slen := slens[i]
        kol := kolakoski(ia, slen)
        fmt.Printf(""First %d members of the sequence generated by "", slen)
        printInts(ia, "":"")
        printInts(kol, """")
        p := possibleKolakoski(kol)
        poss := ""Yes""
        if !p {
            poss = ""No""
        }
        fmt.Println(""Possible Kolakoski sequence?"", poss, ""\n"")
    }
}",1894,86
41634,http://rosettacode.org/wiki/Knuth%27s_power_tree,Knuth's power tree,"(Knuth's power tree is used for computing   xn   efficiently.)




Task

Compute and show the list of Knuth's power tree integers necessary for the computation of:

   xn   for any real   x   and any non-negative integer   n.


Then, using those integers, calculate and show the exact values of (at least) the integer powers below:

   2n     where   n   ranges from   0 ──► 17   (inclusive) 

   3191
   1.181


A  zero  power is often handled separately as a special case.

Optionally, support negative integer powers.



Example

An example of a small power tree for some low integers:

                                                                    1
                                                                     \
                                                                      2
                          ___________________________________________/ \
                         /                                              \
                        3                                                4
                       / \____________________________________            \
                      /                                       \            \
                     5                                         6            8
                    / \____________                           / \            \
                   /               \                         /   \            \
                  7                 10                      9     12           16
                 /                 //\\                     │      │           /\
                /            _____//  \\________            │      │          /  \
              14            /     /    \        \           │      │         /    \
             /│ \         11    13      15       20        18     24        17    32
            / │  \         │    /\      /\        │        /\      │        /\     │
           /  │   \        │   /  \    /  \       │       /  \     │       /  \    │
         19  21    28     22 23   26  25   30    40     27   36    48     33 34   64
         │   /\    /│\     │  │   /\   │   /\    /│\     │   /\    /│\     │  │   /\
         │  /  \  / │ \    │  │  /  \  │  /  \  / │ \    │  /  \  / │ \    │  │  /  \
        38 35 42 29 31 56 44 46 39 52 50 45 60 41 43 80 54 37 72 49 51 96 66 68 65 128

Where, for the power   43,   following the tree ""downwards"" from   1:

   (for   2)   compute square of   X,   store X2
   (for   3)   compute   X * X2,   store X3
   (for   5)   compute   X3 * X2,   store X5
   (for 10)   compute square of   X5,   store X10
   (for 20)   compute square of   X10,   store X20
   (for 40)   compute square of   X20,   store X40
   (for 43)   compute   X40 * X3   (result).
Note that for every even integer (in the power tree),   one just squares the previous value.

For an odd integer, multiply the previous value with an appropriate odd power of   X   (which was previously calculated).
  For the last multiplication in the above example, it would be   (43-40),   or   3. 


According to Dr. Knuth (see below),   computer tests have shown that this power tree gives optimum results for all of the   n
  listed above in the graph.

For   n   ≤ 100,000,   the power tree method:

   bests the factor method   88,803   times,
   ties   11,191   times,
   loses   6   times.


References

   Donald E. Knuth's book:   The Art of Computer Programming, Vol. 2, Second Edition, Seminumerical Algorithms, section 4.6.3: Evaluation of Powers.
   link   codegolf.stackexchange.com/questions/3177/knuths-power-tree     It shows a   Haskell,   Python,   and a   Ruby   computer program example   (but they are mostly   code golf).
   link   comeoncodeon.wordpress.com/tag/knuth/     (See the section on Knuth's Power Tree.)     It shows a   C++   computer program example.
   link to Rosetta Code   addition-chain exponentiation.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
var (
    p   = map[int]int{1: 0}
    lvl = [][]int{[]int{1}}
)
 
func path(n int) []int {
    if n == 0 {
        return []int{}
    }
    for {
        if _, ok := p[n]; ok {
            break
        }
        var q []int
        for _, x := range lvl[0] {
            for _, y := range path(x) {
                z := x + y
                if _, ok := p[z]; ok {
                    break
                }
                p[z] = x
                q = append(q, z)
            }
        }
        lvl[0] = q
    }
    r := path(p[n])
    r = append(r, n)
    return r
}
 
func treePow(x float64, n int) *big.Float {
    r := map[int]*big.Float{0: big.NewFloat(1), 1: big.NewFloat(x)}
    p := 0
    for _, i := range path(n) {
        temp := new(big.Float).SetPrec(320)
        temp.Mul(r[i-p], r[p])
        r[i] = temp
        p = i
    }
    return r[n]
}
 
func showPow(x float64, n int, isIntegral bool) {
    fmt.Printf(""%d: %v\n"", n, path(n))
    f := ""%f""
    if isIntegral {
        f = ""%.0f""
    }
    fmt.Printf(f, x)
    fmt.Printf("" ^ %d = "", n)
    fmt.Printf(f+""\n\n"", treePow(x, n))
}
 
func main() {
    for n := 0; n <= 17; n++ {
        showPow(2, n, true)
    }
    showPow(1.1, 81, false)
    showPow(3, 191, true)
}",1295,68
41643,http://rosettacode.org/wiki/Lah_numbers,Lah numbers,"Lah numbers, sometimes referred to as Stirling numbers of the third kind, are coefficients of polynomial expansions expressing rising factorials in terms of falling factorials.

Unsigned Lah numbers count the number of ways a set of n elements can be partitioned into k non-empty linearly ordered subsets.

Lah numbers are closely related to Stirling numbers of the first & second kinds, and may be derived from them.

Lah numbers obey the identities and relations:

  L(n, 0), L(0, k) = 0   # for n, k > 0
  L(n, n) = 1
  L(n, 1) = n!
  L(n, k) =           ( n! * (n - 1)! ) / ( k! * (k - 1)! ) / (n - k)!      # For unsigned Lah numbers
     or
  L(n, k) = (-1)**n * ( n! * (n - 1)! ) / ( k! * (k - 1)! ) / (n - k)!      # For   signed Lah numbers

Task

 Write a routine (function, procedure, whatever) to find unsigned Lah numbers. There are several methods to generate unsigned Lah numbers. You are free to choose the most appropriate for your language. If your language has a built-in, or easily, publicly available library implementation, it is acceptable to use that.
 Using the routine, generate and show here, on this page, a table (or triangle) showing the unsigned Lah numbers, L(n, k), up to L(12, 12). it is optional to show the row / column for n == 0 and k == 0. It is optional to show places where L(n, k) == 0 (when k > n).
 If your language supports large integers, find and show here, on this page, the maximum value of L(n, k) where n == 100.


See also

 Wikipedia - Lah number
 OEIS:A105278 - Unsigned Lah numbers
 OEIS:A008297 - Signed Lah numbers


Related Tasks

 Stirling numbers of the first kind
 Stirling numbers of the second kind
 Bell numbers

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    limit := 100
    last := 12
    unsigned := true
    l := make([][]*big.Int, limit+1)
    for n := 0; n <= limit; n++ {
        l[n] = make([]*big.Int, limit+1)
        for k := 0; k <= limit; k++ {
            l[n][k] = new(big.Int)
        }
        l[n][n].SetInt64(int64(1))
        if n != 1 {
            l[n][1].MulRange(int64(2), int64(n))
        }
    }
    var t big.Int
    for n := 1; n <= limit; n++ {
        for k := 1; k <= n; k++ {
            t.Mul(l[n][1], l[n-1][1])
            t.Quo(&t, l[k][1])
            t.Quo(&t, l[k-1][1])
            t.Quo(&t, l[n-k][1])
            l[n][k].Set(&t)
            if !unsigned && (n%2 == 1) {
                l[n][k].Neg(l[n][k])
            }
        }
    }
    fmt.Println(""Unsigned Lah numbers: l(n, k):"")
    fmt.Printf(""n/k"")
    for i := 0; i <= last; i++ {
        fmt.Printf(""%10d "", i)
    }
    fmt.Printf(""\n--"")
    for i := 0; i <= last; i++ {
        fmt.Printf(""-----------"")
    }
    fmt.Println()
    for n := 0; n <= last; n++ {
        fmt.Printf(""%2d "", n)
        for k := 0; k <= n; k++ {
            fmt.Printf(""%10d "", l[n][k])
        }
        fmt.Println()
    }
    fmt.Println(""\nMaximum value from the l(100, *) row:"")
    max := new(big.Int).Set(l[limit][0])
    for k := 1; k <= limit; k++ {
        if l[limit][k].Cmp(max) > 0 {
            max.Set(l[limit][k])
        }
    }
    fmt.Println(max)
    fmt.Printf(""which has %d digits.\n"", len(max.String()))
}",1527,62
41732,http://rosettacode.org/wiki/Kronecker_product_based_fractals,Kronecker product based fractals,"This task is based on    Kronecker product   of two matrices.

If your language has no a built-in function for such product then you need to implement it first.

The essence of fractals is self-replication (at least, self-similar replications).

So, using   n   times self-product of the matrix   (filled with 0/1)   we will have a fractal of the   nth   order.

Actually, ""self-product"" is a Kronecker power of the matrix.

In other words: for a matrix   M   and a power   n   create a function like   matkronpow(M, n),

which returns   MxMxMx...   (n   times product).

A formal recurrent algorithm of creating Kronecker power of a matrix is the following:



Algorithm


Let M is an initial matrix, and Rn is a resultant block matrix of the Kronecker power, where n is the power (a.k.a. order).
Self-product of M, i.e., M x M producing R2 (resultant matrix with order/power 2).
To receive the next order/power matrix use this recurrent formula: Rn = R(n-1) x M.
Plot this Rn matrix to produce the nth order fractal.



Even just looking at the resultant matrix you can see what will be plotted.

There are virtually infinitely many fractals of this type. You are limited only by your creativity and
the power of your computer.



Task

Using  Kronecker product implement and show two popular and well-known fractals, i.e.:

  Vicsek fractal;
  Sierpinski carpet fractal.


The last one ( Sierpinski carpet) is already here on RC, but built using different approaches.




Test cases

These 2 fractals (each order/power 4 at least) should be built using the following 2 simple matrices:

          │ 0 1 0 │    and    │ 1 1 1 │
          │ 1 1 1 │           │ 1 0 1 │
          │ 0 1 0 │           │ 1 1 1 │

Note

 Output could be a graphical or ASCII-art representation, but if an order is set > 4 then printing is not suitable.
 The orientation and distortion of the fractal could be your language/tool specific.
 It would be nice to see one additional fractal of your choice, e.g., based on using a single (double) letter(s) of an alphabet, any sign(s) or already made a resultant matrix of the Kronecker product.


See implementations and results below in JavaScript, PARI/GP and R languages. They have additional samples of ""H"", ""+"" and checkerboard fractals.



",#Go,Go,"package main
 
import ""fmt""
 
type matrix [][]int
 
func (m1 matrix) kroneckerProduct(m2 matrix) matrix {
    m := len(m1)
    n := len(m1[0])
    p := len(m2)
    q := len(m2[0])
    rtn := m * p
    ctn := n * q
    r := make(matrix, rtn)
    for i := range r {
        r[i] = make([]int, ctn) // all elements zero by default
    }
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            for k := 0; k < p; k++ {
                for l := 0; l < q; l++ {
                    r[p*i+k][q*j+l] = m1[i][j] * m2[k][l]
                }
            }
        }
    }
    return r
}
 
func (m matrix) kroneckerPower(n int) matrix {
    pow := m
    for i := 1; i < n; i++ {
        pow = pow.kroneckerProduct(m)
    }
    return pow
}
 
func (m matrix) print(text string) {
    fmt.Println(text, ""fractal :\n"")
    for i := range m {
        for j := range m[0] {
            if m[i][j] == 1 {
                fmt.Print(""*"")
            } else {
                fmt.Print("" "")
            }
        }
        fmt.Println()
    }
    fmt.Println()
}
 
func main() {
    m1 := matrix{{0, 1, 0}, {1, 1, 1}, {0, 1, 0}}
    m1.kroneckerPower(4).print(""Vivsek"")
 
    m2 := matrix{{1, 1, 1}, {1, 0, 1}, {1, 1, 1}}
    m2.kroneckerPower(4).print(""Sierpinski carpet"")
}",1273,59
41785,http://rosettacode.org/wiki/Koch_curve,Koch curve,"Draw a Koch curve. See details: Koch curve
",#Go,Go,"package main
 
import (
    ""github.com/fogleman/gg""
    ""math""
)
 
var dc = gg.NewContext(512, 512)
 
func koch(x1, y1, x2, y2 float64, iter int) {
    angle := math.Pi / 3 // 60 degrees
    x3 := (x1*2 + x2) / 3
    y3 := (y1*2 + y2) / 3
    x4 := (x1 + x2*2) / 3
    y4 := (y1 + y2*2) / 3
    x5 := x3 + (x4-x3)*math.Cos(angle) + (y4-y3)*math.Sin(angle)
    y5 := y3 - (x4-x3)*math.Sin(angle) + (y4-y3)*math.Cos(angle)
    if iter > 0 {
        iter--
        koch(x1, y1, x3, y3, iter)
        koch(x3, y3, x5, y5, iter)
        koch(x5, y5, x4, y4, iter)
        koch(x4, y4, x2, y2, iter)
    } else {
        dc.LineTo(x1, y1)
        dc.LineTo(x3, y3)
        dc.LineTo(x5, y5)
        dc.LineTo(x4, y4)
        dc.LineTo(x2, y2)
    }
}
 
func main() {
    dc.SetRGB(1, 1, 1) // White background
    dc.Clear()
    koch(100, 100, 400, 400, 4)
    dc.SetRGB(0, 0, 1) // Blue curve
    dc.SetLineWidth(2)
    dc.Stroke()
    dc.SavePNG(""koch.png"")
}",956,41
41786,http://rosettacode.org/wiki/Knuth%27s_algorithm_S,Knuth's algorithm S,"This is a method of randomly sampling n items from a set of M items, with equal probability; where M >= n and M, the number of items is unknown until the end.
This means that the equal probability sampling should be maintained for all successive items > n as they become available (although the content of successive samples can change).



The algorithm

 Select the first n items as the sample as they become available;
 For the i-th item where i > n, have a random chance of n/i of keeping it. If failing this chance, the sample remains the same. If not, have it randomly (1/n) replace one of the previously selected n items of the sample.
 Repeat   2nd step   for any subsequent items.


The Task

 Create a function s_of_n_creator that given 



n


{\displaystyle n}

 the maximum sample size, returns a function s_of_n that takes one parameter, item.
 Function s_of_n when called with successive items returns an equi-weighted random sample of up to n of its items so far, each time it is called, calculated using Knuths Algorithm S.
 Test your functions by printing and showing the frequency of occurrences of the selected digits from 100,000 repetitions of:
 Use the s_of_n_creator with n == 3 to generate an s_of_n.
 call s_of_n with each of the digits 0 to 9 in order, keeping the returned three digits of its random sampling from its last call with argument item=9.


Note: A class taking n and generating a callable instance/function might also be used.



Reference

 The Art of Computer Programming, Vol 2, 3.4.2 p.142


Related tasks
 
 One of n lines in a file 
 Accumulator factory

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
func sOfNCreator(n int) func(byte) []byte {
    s := make([]byte, 0, n)
    m := n
    return func(item byte) []byte {
        if len(s) < n {
            s = append(s, item)
        } else {
            m++
            if rand.Intn(m) < n {
                s[rand.Intn(n)] = item
            }
        }
        return s
    }
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    var freq [10]int
    for r := 0; r < 1e5; r++ {
        sOfN := sOfNCreator(3)
        for d := byte('0'); d < '9'; d++ {
            sOfN(d)
        }
        for _, d := range sOfN('9') {
            freq[d-'0']++
        }
    }
    fmt.Println(freq)
}",707,38
41833,http://rosettacode.org/wiki/Levenshtein_distance,Levenshtein distance,"

 This page uses content from Wikipedia. The original article was at Levenshtein distance. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In information theory and computer science, the Levenshtein distance is a metric for measuring the amount of difference between two sequences (i.e. an edit distance). The Levenshtein distance between two strings is defined as the minimum number of edits needed to transform one string into the other, with the allowable edit operations being insertion, deletion, or substitution of a single character.



Example

The Levenshtein distance between ""kitten"" and ""sitting"" is 3, since the following three edits change one into the other, and there isn't a way to do it with fewer than three edits:

   kitten   sitten   (substitution of 'k' with 's')
   sitten   sittin   (substitution of 'e' with 'i')
   sittin   sitting   (insert 'g' at the end).

The Levenshtein distance between   ""rosettacode"",   ""raisethysword""   is   8.

The distance between two strings is same as that when both strings are reversed.



Task

Implements a Levenshtein distance function, or uses a library function, to show the Levenshtein distance between   ""kitten""   and   ""sitting"".



Related task

   Longest common subsequence



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    fmt.Println(ld(""kitten"", ""sitting""))
}
 
func ld(s, t string) int {
    d := make([][]int, len(s)+1)
    for i := range d {
        d[i] = make([]int, len(t)+1)
    }
    for i := range d {
        d[i][0] = i
    }
    for j := range d[0] {
        d[0][j] = j
    }
    for j := 1; j <= len(t); j++ {
        for i := 1; i <= len(s); i++ {
            if s[i-1] == t[j-1] {
                d[i][j] = d[i-1][j-1]
            } else {
                min := d[i-1][j]
                if d[i][j-1] < min {
                    min = d[i][j-1]
                }
                if d[i-1][j-1] < min {
                    min = d[i-1][j-1]
                }
                d[i][j] = min + 1
            }
        }
 
    }
    return d[len(s)][len(t)]
}",798,38
41871,http://rosettacode.org/wiki/Kronecker_product,Kronecker product,"Kronecker product

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Implement the   Kronecker product   of two matrices (arbitrary sized) resulting in a block matrix. 




Test cases

Show results for each of the following two samples:




Sample 1 (from Wikipedia):



          ┌   ┐     ┌   ┐     ┌           ┐
          │1 2│     │0 5│     │ 0  5  0 10│
          │3 4│  x  │6 7│  =  │ 6  7 12 14│
	  └   ┘     └   ┘     │ 0 15  0 20│
	                      │18 21 24 28│
                              └           ┘ 

Sample 2:

          ┌     ┐     ┌       ┐     ┌                       ┐       
          │0 1 0│     │1 1 1 1│     │0 0 0 0 1 1 1 1 0 0 0 0│
          │1 1 1│  x  │1 0 0 1│  =  │0 0 0 0 1 0 0 1 0 0 0 0│
          │0 1 0│     │1 1 1 1│     │0 0 0 0 1 1 1 1 0 0 0 0│
	  └     ┘     └       ┘     │1 1 1 1 1 1 1 1 1 1 1 1│
                                    │1 0 0 1 1 0 0 1 1 0 0 1│
                                    │1 1 1 1 1 1 1 1 1 1 1 1│
                                    │0 0 0 0 1 1 1 1 0 0 0 0│
                                    │0 0 0 0 1 0 0 1 0 0 0 0│
                                    │0 0 0 0 1 1 1 1 0 0 0 0│
                                    └                       ┘



See implementations and results below in JavaScript and PARI/GP languages.



Related task

  Kronecker product based fractals. 

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
type uintMatrix [][]uint
 
func (m uintMatrix) String() string {
    var max uint
    for _, r := range m {
        for _, e := range r {
            if e > max {
                max = e
            }
        }
    }
    w := len(fmt.Sprint(max))
    b := &strings.Builder{}
    for _, r := range m {
        fmt.Fprintf(b, ""|%*d"", w, r[0])
        for _, e := range r[1:] {
            fmt.Fprintf(b, "" %*d"", w, e)
        }
        fmt.Fprintln(b, ""|"")
    }
    return b.String()
}
 
func kronecker(m1, m2 uintMatrix) uintMatrix {
    p := make(uintMatrix, len(m1)*len(m2))
    for r1i, r1 := range m1 {
        for r2i, r2 := range m2 {
            rp := make([]uint, len(r1)*len(r2))
            for c1i, e1 := range r1 {
                for c2i, e2 := range r2 {
                    rp[c1i*len(r2)+c2i] = e1 * e2
                }
            }
            p[r1i*len(m2)+r2i] = rp
        }
    }
    return p
}
 
func sample(m1, m2 uintMatrix) {
    fmt.Println(""m1:"")
    fmt.Print(m1)
    fmt.Println(""m2:"")
    fmt.Print(m2)
    fmt.Println(""m1 ⊗ m2:"")
    fmt.Print(kronecker(m1, m2))
}
 
func main() {
    sample(uintMatrix{
        {1, 2},
        {3, 4},
    }, uintMatrix{
        {0, 5},
        {6, 7},
    })
    sample(uintMatrix{
        {0, 1, 0},
        {1, 1, 1},
        {0, 1, 0},
    }, uintMatrix{
        {1, 1, 1, 1},
        {1, 0, 0, 1},
        {1, 1, 1, 1},
    })
}",1452,73
41878,http://rosettacode.org/wiki/Largest_int_from_concatenated_ints,Largest int from concatenated ints,"Task
 
Given a set of positive integers, write a function to order the integers in such a way that the concatenation of the numbers forms the largest possible integer and return this integer.

Use the following two sets of integers as tests   and   show your program output here.

   {1, 34, 3, 98, 9, 76, 45, 4}
   {54, 546, 548, 60}


Possible algorithms

 A solution could be found by trying all combinations and return the best. 
 Another way to solve this is to note that in the best arrangement, for any two adjacent original integers X and Y, the concatenation X followed by Y will be numerically greater than or equal to the concatenation Y followed by X.
 Yet another way to solve this is to pad the integers to the same size by repeating the digits then sort using these repeated integers as a sort key.


See also

   Algorithms: What is the most efficient way to arrange the given numbers to form the biggest number?
   Constructing the largest number possible by rearranging a list

",#Go,Go,"// Variation of method 3.  Repeat digits to at least the size of the longest,
// then sort as strings.
package main
 
import (
    ""fmt""
    ""math/big""
    ""sort""
    ""strconv""
    ""strings""
)
 
type c struct {
    i     int
    s, rs string
}
 
type cc []*c
 
func (c cc) Len() int           { return len(c) }
func (c cc) Less(i, j int) bool { return c[j].rs < c[i].rs }
func (c cc) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }
 
// Function required by task.  Takes a list of integers, returns big int.
func li(is ...int) *big.Int {
    ps := make(cc, len(is))
    ss := make([]c, len(is))
    ml := 0
    for j, i := range is {
        p := &ss[j]
        ps[j] = p
        p.i = i
        p.s = strconv.Itoa(i)
        if len(p.s) > ml {
            ml = len(p.s)
        }
    }
    for _, p := range ps {
        p.rs = strings.Repeat(p.s, (ml+len(p.s)-1)/len(p.s))
    }
    sort.Sort(ps)
    s := make([]string, len(ps))
    for i, p := range ps {
        s[i] = p.s
    }
    b, _ := new(big.Int).SetString(strings.Join(s, """"), 10)
    return b
}
 
func main() {
    fmt.Println(li(1, 34, 3, 98, 9, 76, 45, 4))
    fmt.Println(li(54, 546, 548, 60))
}",1162,53
41971,http://rosettacode.org/wiki/Least_common_multiple,Least common multiple,"Least common multiple

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Compute the   least common multiple   (LCM)   of two integers.

Given   m   and   n,   the least common multiple is the smallest positive integer that has both   m   and   n   as factors.



Example

The least common multiple of   12   and   18   is   36,       because:

   12   is a factor     (12 × 3 = 36),     and 
   18   is a factor     (18 × 2 = 36),     and 
   there is no positive integer less than   36   that has both factors. 


As a special case,   if either   m   or   n   is zero,   then the least common multiple is zero.



One way to calculate the least common multiple is to iterate all the multiples of   m,   until you find one that is also a multiple of   n.

If you already have   gcd   for greatest common divisor,   then this formula calculates   lcm.



 



lcm
⁡
(
m
,
n
)
=




|

m
×
n

|



gcd
⁡
(
m
,
n
)





{\displaystyle \operatorname {lcm} (m,n)={\frac {|m\times n|}{\operatorname {gcd} (m,n)}}}




One can also find   lcm   by merging the prime decompositions of both   m   and   n.



Related task
   greatest common divisor.


See also

   MathWorld entry:   Least Common Multiple.
   Wikipedia entry:   Least common multiple.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
var m, n, z big.Int
 
func init() {
    m.SetString(""2562047788015215500854906332309589561"", 10)
    n.SetString(""6795454494268282920431565661684282819"", 10)
}
 
func main() {
    fmt.Println(z.Mul(z.Div(&m, z.GCD(nil, nil, &m, &n)), &n))
}",293,17
41994,http://rosettacode.org/wiki/Leap_year,Leap year,"Task

Determine whether a given year is a leap year in the Gregorian calendar.



See also

 Leap year (wiki)

",#Go,Go,"func isLeap(year int) bool {
    return year%400 == 0 || year%4 == 0 && year%100 != 0
}",87,3
42008,http://rosettacode.org/wiki/Letter_frequency,Letter frequency,"Task

Open a text file and count the occurrences of each letter.

Some of these programs count all characters (including punctuation),
but some only count letters A to Z.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""io/ioutil""
    ""sort""
    ""unicode""
)
 
const file = ""unixdict.txt""
 
func main() {
    bs, err := ioutil.ReadFile(file)
    if err != nil {
        fmt.Println(err)
        return
    }
    m := make(map[rune]int)
    for _, r := range string(bs) {
        m[r]++
    }
    // answer is now in m.  sort and format output:
    lfs := make(lfList, 0, len(m))
    for l, f := range m {
        lfs = append(lfs, &letterFreq{l, f})
    }
    sort.Sort(lfs)
    fmt.Println(""file:"", file)
    fmt.Println(""letter  frequency"")
    for _, lf := range lfs {
        if unicode.IsGraphic(lf.rune) {
            fmt.Printf(""   %c    %7d\n"", lf.rune, lf.freq)
        } else {
            fmt.Printf(""%U  %7d\n"", lf.rune, lf.freq)
        }
    }
}
 
type letterFreq struct {
    rune
    freq int
}
type lfList []*letterFreq
 
func (lfs lfList) Len() int { return len(lfs) }
func (lfs lfList) Less(i, j int) bool {
    switch fd := lfs[i].freq - lfs[j].freq; {
    case fd < 0:
        return false
    case fd > 0:
        return true
    }
    return lfs[i].rune < lfs[j].rune
}
func (lfs lfList) Swap(i, j int) {
    lfs[i], lfs[j] = lfs[j], lfs[i]
}",1183,57
42089,http://rosettacode.org/wiki/Last_Friday_of_each_month,Last Friday of each month,"Task

Write a program or a script that returns the date of the last Fridays of each month of a given year.

The year may be given through any simple input method in your language (command line, std in, etc).



Example of an expected output:

./last_fridays 2012
2012-01-27
2012-02-24
2012-03-30
2012-04-27
2012-05-25
2012-06-29
2012-07-27
2012-08-31
2012-09-28
2012-10-26
2012-11-30
2012-12-28



Related tasks
 Five weekends
 Day of the week
 Find the last Sunday of each month

",#Go,Go,"package main
 
import (
	""fmt""
	""os""
	""strconv""
	""time""
)
 
func main() {
	y := time.Now().Year()
	if len(os.Args) == 2 {
		if i, err := strconv.Atoi(os.Args[1]); err == nil {
			y = i
		}
	}
	for m := time.January; m <= time.December; m++ {
		d := time.Date(y, m+1, 1, 0, 0, 0, 0, time.UTC).Add(-24 * time.Hour)
		d = d.Add(-time.Duration((d.Weekday()+7-time.Friday)%7) * 24 * time.Hour)
		fmt.Println(d.Format(""2006-01-02""))
	}
}",431,22
42292,http://rosettacode.org/wiki/Langton%27s_ant,Langton's ant,"Langton's ant is a cellular automaton that models an ant sitting on a plane of cells, all of which are white initially, the ant facing in one of four directions.

Each cell can either be black or white.

The ant moves according to the color of the cell it is currently sitting in, with the following rules:

   If the cell is black, it changes to white and the ant turns left;
   If the cell is white, it changes to black and the ant turns right;
   The ant then moves forward to the next cell, and repeat from step 1.

This rather simple ruleset leads to an initially chaotic movement pattern, and after about 10000 steps, a cycle appears where the ant moves steadily away from the starting location in a diagonal corridor about 10 cells wide.
Conceptually the ant can then walk infinitely far away.



Task

Start the ant near the center of a 100x100 field of cells, which is about big enough to contain the initial chaotic part of the movement.

Follow the movement rules for the ant, terminate when it moves out of the region, and show the cell colors it leaves behind.



The problem has received some analysis; for more details, please take a look at the Wikipedia article   (a link is below)..



See also

   Wikipedia:   Langton's ant.


Related task

   Rosetta Code:   Conway's Game of Life.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""image""
    ""image/color""
    ""image/draw""
    ""image/png""
    ""os""
)
 
const (
    up = iota
    rt
    dn
    lt
)
 
func main() {
    bounds := image.Rect(0, 0, 100, 100)
    im := image.NewGray(bounds)
    gBlack := color.Gray{0}
    gWhite := color.Gray{255}
    draw.Draw(im, bounds, image.NewUniform(gWhite), image.ZP, draw.Src)
    pos := image.Point{50, 50}
    dir := up
    for pos.In(bounds) {
        switch im.At(pos.X, pos.Y).(color.Gray).Y {
        case gBlack.Y:
            im.SetGray(pos.X, pos.Y, gWhite)
            dir--
        case gWhite.Y:
            im.SetGray(pos.X, pos.Y, gBlack)
            dir++
        }
        if dir&1 == 1 {
            pos.X += 1 - dir&2
        } else {
            pos.Y -= 1 - dir&2
        }
    }
    f, err := os.Create(""ant.png"")
    if err != nil {
        fmt.Println(err)
        return
    }
    if err = png.Encode(f, im); err != nil {
        fmt.Println(err)
    }
    if err = f.Close(); err != nil {
        fmt.Println(err)
    }
}",1043,53
42547,http://rosettacode.org/wiki/Keyboard_macros,Keyboard macros,"Show how to link user defined methods to user defined keys.

An example of this is the facility provided by emacs for key bindings.

These key bindings may be application-specific or system-wide; state which you have done.



",#Go,Go,"package main
 
/*
#cgo LDFLAGS: -lX11
#include <stdlib.h>
#include <X11/Xlib.h>
#include <X11/keysym.h>
 
static inline Window DefaultRootWindow_macro(Display *dpy) {
    return ScreenOfDisplay(dpy, DefaultScreen(dpy))->root;
}
 
static inline int getXEvent_type(XEvent event) {
    return event.type;
}
 
static inline XKeyEvent getXEvent_xkey(XEvent event) {
    return event.xkey;
}
*/
import ""C""
import ""fmt""
import ""unsafe""
 
func main() {
    d := C.XOpenDisplay(nil)
    f7, f6 := C.CString(""F7""), C.CString(""F6"")
    defer C.free(unsafe.Pointer(f7))
    defer C.free(unsafe.Pointer(f6))
 
    if d != nil {
        C.XGrabKey(d, C.int(C.XKeysymToKeycode(d, C.XStringToKeysym(f7))),
            C.Mod1Mask, /* normally it's Alt */
            C.DefaultRootWindow_macro(d), C.True, C.GrabModeAsync, C.GrabModeAsync)
        C.XGrabKey(d, C.int(C.XKeysymToKeycode(d, C.XStringToKeysym(f6))),
            C.Mod1Mask,
            C.DefaultRootWindow_macro(d), C.True, C.GrabModeAsync, C.GrabModeAsync)
 
        var event C.XEvent
        for {
            C.XNextEvent(d, &event)
            if C.getXEvent_type(event) == C.KeyPress {
                xkeyEvent := C.getXEvent_xkey(event)
                s := C.XLookupKeysym(&xkeyEvent, 0)
                if s == C.XK_F7 {
                    fmt.Println(""something's happened"")
                } else if s == C.XK_F6 {
                    break
                }
            }
        }
 
        C.XUngrabKey(d, C.int(C.XKeysymToKeycode(d, C.XStringToKeysym(f7))), C.Mod1Mask, C.DefaultRootWindow_macro(d))
        C.XUngrabKey(d, C.int(C.XKeysymToKeycode(d, C.XStringToKeysym(f6))), C.Mod1Mask, C.DefaultRootWindow_macro(d))
    } else {
        fmt.Println(""XOpenDisplay did not succeed"")
    }
}",1755,58
42734,http://rosettacode.org/wiki/Keyboard_input/Flush_the_keyboard_buffer,Keyboard input/Flush the keyboard buffer,"Flush the   keyboard   buffer.

This reads characters from the keyboard input and
discards them until there are no more currently buffered,  
and then allows the program to continue.

The program must not wait for users to type anything.
",#Go,Go,"package main
 
import (
    ""log""
 
    gc ""code.google.com/p/goncurses""
)
 
func main() {
    _, err := gc.Init()
    if err != nil {
        log.Fatal(""init:"", err)
    }
    defer gc.End()
    gc.FlushInput()
}",213,16
42742,http://rosettacode.org/wiki/Knapsack_problem/Bounded,Knapsack problem/Bounded,"A tourist wants to make a good trip at the weekend with his friends.

They will go to the mountains to see the wonders of nature.   So he needs some items during the trip.   Food, clothing, etc.   He has a good knapsack for carrying the things, but he knows that he can carry only 4 kg weight in his knapsack, because they will make the trip from morning to evening.

He creates a list of what he wants to bring for the trip, but the total weight of all items is too much.   He adds a value to each item.   The value represents how important the thing for the tourist.

The list contains which items are the wanted things for the trip, what is the weight and value of an item, and how many units does he have from each items.



This is the list:


 Table of potential knapsack items


 item 
 weight (dag) (each) 
 value (each) 
 piece(s)


 map 
 9 
 150 
 1


 compass 
 13 
 35 
 1


 water 
 153 
 200 
 2


 sandwich 
 50 
 60 
 2


 glucose 
 15 
 60 
 2


 tin 
 68 
 45 
 3


 banana 
 27 
 60 
 3


 apple 
 39 
 40 
 3


 cheese 
 23 
 30 
 1


 beer 
 52 
 10 
 3


 suntan cream 
 11 
 70 
 1


 camera 
 32 
 30 
 1


 T-shirt 
 24 
 15 
 2


 trousers 
 48 
 10 
 2


 umbrella 
 73 
 40 
 1


 waterproof trousers 
 42 
 70 
 1


 waterproof overclothes 
 43 
 75 
 1


 note-case 
 22 
 80 
 1


 sunglasses 
 7 
 20 
 1


 towel 
 18 
 12 
 2


 socks 
 4 
 50 
 1


 book 
 30 
 10 
 2


 knapsack 
 ≤400 dag 
 ? 
 ?



The tourist can choose to take any combination of items from the list, and some number of each item is available   (see the column   piece(s)   in the list above).

He may not cut the items, so he can only take whole units of any item.



Task

Show which items does the tourist carry in his knapsack so that their total weight does not exceed 4 kg, and their total value is maximized.



Related tasks

   Knapsack problem/Unbounded
   Knapsack problem/Continuous
   Knapsack problem/0-1

",#Go,Go,"package main
 
import ""fmt""
 
type Item struct {
	name               string
	weight, value, qty int
}
 
var items = []Item{
	{""map"",			9,	150,	1},
	{""compass"",		13,	35,	1},
	{""water"",		153,	200,	2},
	{""sandwich"",		50,	60,	2},
	{""glucose"",		15,	60,	2},
	{""tin"",			68,	45,	3},
	{""banana"",		27,	60,	3},
	{""apple"",		39,	40,	3},
	{""cheese"",		23,	30,	1},
	{""beer"",		52,	10,	3},
	{""suntancream"",		11,	70,	1},
	{""camera"",		32,	30,	1},
	{""T-shirt"",		24,	15,	2},
	{""trousers"",		48,	10,	2},
	{""umbrella"",		73,	40,	1},
	{""w-trousers"",		42,	70,	1},
	{""w-overclothes"",	43,	75,	1},
	{""note-case"",		22,	80,	1},
	{""sunglasses"",		7,      20,	1},
	{""towel"",		18,	12,	2},
	{""socks"",		4,      50,	1},
	{""book"",		30,	10,	2},
}
 
type Chooser struct {
	Items []Item
	cache map[key]solution
}
 
type key struct {
	w, p int
}
 
type solution struct {
	v, w int
	qty  []int
}
 
func (c Chooser) Choose(limit int) (w, v int, qty []int) {
	c.cache = make(map[key]solution)
	s := c.rchoose(limit, len(c.Items)-1)
	c.cache = nil // allow cache to be garbage collected
	return s.v, s.w, s.qty
}
 
func (c Chooser) rchoose(limit, pos int) solution {
	if pos < 0 || limit <= 0 {
		return solution{0, 0, nil}
	}
 
	key := key{limit, pos}
	if s, ok := c.cache[key]; ok {
		return s
	}
 
	best_i, best := 0, solution{0, 0, nil}
	for i := 0; i*items[pos].weight <= limit && i <= items[pos].qty; i++ {
		sol := c.rchoose(limit-i*items[pos].weight, pos-1)
		sol.v += i * items[pos].value
		if sol.v > best.v {
			best_i, best = i, sol
		}
	}
 
	if best_i > 0 {
		// best.qty is used in another cache entry,
		// we need to duplicate it before modifying it to
		// store as our cache entry.
		old := best.qty
		best.qty = make([]int, len(items))
		copy(best.qty, old)
		best.qty[pos] = best_i
		best.w += best_i * items[pos].weight
	}
	c.cache[key] = best
	return best
}
 
func main() {
	v, w, s := Chooser{Items: items}.Choose(400)
 
	fmt.Println(""Taking:"")
	for i, t := range s {
		if t > 0 {
			fmt.Printf(""  %d of %d %s\n"", t, items[i].qty, items[i].name)
		}
	}
	fmt.Printf(""Value: %d; weight: %d\n"", v, w)
}",2073,99
42752,http://rosettacode.org/wiki/Keyboard_input/Obtain_a_Y_or_N_response,Keyboard input/Obtain a Y or N response,"

Task

Obtain a valid   Y   or   N   response from the keyboard.

The keyboard should be flushed, so that any outstanding key-presses are removed, preventing any existing   Y   or   N   key-press from being evaluated.

The response should be obtained as soon as   Y   or   N   are pressed, and there should be no need to press an   enter   key.



",#Go,Go,"package main
 
import (
    ""log""
 
    gc ""code.google.com/p/goncurses""
)
 
func main() {
    s, err := gc.Init()
    if err != nil {
        log.Fatal(""init:"", err)
    }
    defer gc.End()
    var k gc.Key
    for {
        gc.FlushInput()
        s.MovePrint(20, 0, ""Press y/n "")
        s.Refresh()
        switch k = s.GetChar(); k {
        default:
            continue
        case 'y', 'Y', 'n', 'N':
        }
        break
    }
    s.Printf(""\nThanks for the %c!\n"", k)
    s.Refresh()
    s.GetChar()
}",516,30
42775,http://rosettacode.org/wiki/Keyboard_input/Keypress_check,Keyboard input/Keypress check,"

Determine if a key has been pressed and store this in a variable.

If no key has been pressed, the program should continue without waiting.



",#Go,Go,"package main
 
import (
    ""log""
    ""time""
 
    gc ""code.google.com/p/goncurses""
)
 
func main() {
    s, err := gc.Init()
    if err != nil {
        log.Fatal(""init:"", err)
    }
    defer gc.End()
    gc.Cursor(0)
    s.Move(20, 0)
    s.Print(""Key check in "")
    for i := 3; i >= 1; i-- {
        s.MovePrint(20, 13, i)
        s.Refresh()
        time.Sleep(500 * time.Millisecond)
    }",396,23
42830,http://rosettacode.org/wiki/Knapsack_problem/Continuous,Knapsack problem/Continuous,"

A thief burgles a butcher's shop, where he can select from some items.

The thief knows the weights and prices of each items.   Because he has a knapsack with 15 kg maximal capacity, he wants to select the items such that he would have his profit maximized.   He may cut the items;   the item has a reduced price after cutting that is proportional to the original price by the ratio of masses.   That means:   half of an item has half the price of the original.



This is the item list in the butcher's shop:


 Table of potential knapsack items


 Item 
 Weight (kg) 
 Price (Value)


 beef 
 3.8 
 36


 pork 
 5.4 
 43


 ham 
 3.6 
 90


 greaves 
 2.4 
 45


 flitch 
 4.0 
 30


 brawn 
 2.5 
 56


 welt 
 3.7 
 67


 salami 
 3.0 
 95


 sausage 
 5.9 
 98


 Knapsack 
 <=15 kg 
 ?



Task

Show which items the thief carries in his knapsack so that their total weight does not exceed 15 kg, and their total value is maximized.



Related tasks

   Knapsack problem/Bounded
   Knapsack problem/Unbounded
   Knapsack problem/0-1


See also

   Wikipedia article:   continuous knapsack.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
type item struct {
    item   string
    weight float64
    price  float64
}
 
type items []item
 
var all = items{
    {""beef"", 3.8, 36},
    {""pork"", 5.4, 43},
    {""ham"", 3.6, 90},
    {""greaves"", 2.4, 45},
    {""flitch"", 4.0, 30},
    {""brawn"", 2.5, 56},
    {""welt"", 3.7, 67},
    {""salami"", 3.0, 95},
    {""sausage"", 5.9, 98},
}
 
// satisfy sort interface
func (z items) Len() int      { return len(z) }
func (z items) Swap(i, j int) { z[i], z[j] = z[j], z[i] }
func (z items) Less(i, j int) bool {
    return z[i].price/z[i].weight > z[j].price/z[j].weight
}
 
func main() {
    left := 15.
    sort.Sort(all)
    for _, i := range all {
        if i.weight <= left {
            fmt.Println(""take all the"", i.item)
            if i.weight == left {
                return
            }
            left -= i.weight
        } else {
            fmt.Printf(""take %.1fkg %s\n"", left, i.item)
            return
        }
    }
}",983,50
42855,http://rosettacode.org/wiki/Knapsack_problem/Unbounded,Knapsack problem/Unbounded,"A traveler gets diverted and has to make an unscheduled stop in what turns out to be Shangri La.   Opting to leave, he is allowed to take as much as he likes of the following items, so long as it will fit in his knapsack, and he can carry it.

He knows that he can carry no more than   25   'weights' in total;   and that the capacity of his knapsack is   0.25   'cubic lengths'.

Looking just above the bar codes on the items he finds their weights and volumes.   He digs out his recent copy of a financial paper and gets the value of each item.

ItemExplanationValue (each)weightVolume (each)panacea
(vials of)Incredible healing properties30000.30.025ichor
(ampules of)Vampires blood18000.20.015gold
(bars)Shiney shiney25002.00.002KnapsackFor the carrying of-<=25<=0.25 



He can only take whole units of any item, but there is much more of any item than he could ever carry



Task

Show how many of each item does he take to maximize the value of items he is carrying away with him.



Note
 
   There are four solutions that maximize the value taken.   Only one need be given.


Related tasks

   Knapsack problem/Bounded
   Knapsack problem/Continuous
   Knapsack problem/0-1

",#Go,Go,"package main
 
import ""fmt""
 
type Item struct {
	Name           string
	Value          int
	Weight, Volume float64
}
 
type Result struct {
	Counts []int
	Sum    int
}
 
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
 
func Knapsack(items []Item, weight, volume float64) (best Result) {
	if len(items) == 0 {
		return
	}
	n := len(items) - 1
	maxCount := min(int(weight/items[n].Weight), int(volume/items[n].Volume))
	for count := 0; count <= maxCount; count++ {
		sol := Knapsack(items[:n],
			weight-float64(count)*items[n].Weight,
			volume-float64(count)*items[n].Volume)
		sol.Sum += items[n].Value * count
		if sol.Sum > best.Sum {
			sol.Counts = append(sol.Counts, count)
			best = sol
		}
	}
	return
}
 
func main() {
	items := []Item{
		{""Panacea"", 3000, 0.3, 0.025},
		{""Ichor"", 1800, 0.2, 0.015},
		{""Gold"", 2500, 2.0, 0.002},
	}
	var sumCount, sumValue int
	var sumWeight, sumVolume float64
 
	result := Knapsack(items, 25, 0.25)
 
	for i := range result.Counts {
		fmt.Printf(""%-8s x%3d  -> Weight: %4.1f  Volume: %5.3f  Value: %6d\n"",
			items[i].Name, result.Counts[i], items[i].Weight*float64(result.Counts[i]),
			items[i].Volume*float64(result.Counts[i]), items[i].Value*result.Counts[i])
 
		sumCount += result.Counts[i]
		sumValue += items[i].Value * result.Counts[i]
		sumWeight += items[i].Weight * float64(result.Counts[i])
		sumVolume += items[i].Volume * float64(result.Counts[i])
	}
 
	fmt.Printf(""TOTAL (%3d items) Weight: %4.1f  Volume: %5.3f  Value: %6d\n"",
		sumCount, sumWeight, sumVolume, sumValue)
}",1550,66
42973,http://rosettacode.org/wiki/K-d_tree,K-d tree,"

 This page uses content from Wikipedia. The original article was at K-d tree. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

A k-d tree (short for k-dimensional tree) is a space-partitioning data structure for organizing points in a k-dimensional space. k-d trees are a useful data structure for several applications, such as searches involving a multidimensional search key (e.g. range searches and nearest neighbor searches).
k-d trees are a special case of binary space partitioning trees.

k-d trees are not suitable, however, for efficiently finding the nearest neighbor in high dimensional spaces. As a general rule, if the dimensionality is k, the number of points in the data, N, should be N ≫ 2k.
Otherwise, when k-d trees are used with high-dimensional data, most of the points in the tree will be evaluated and the efficiency is no better than exhaustive search, and other methods such as approximate nearest-neighbor are used instead.

Task: Construct a k-d tree and perform a nearest neighbor search for two example data sets:

 The Wikipedia example data of [(2,3), (5,4), (9,6), (4,7), (8,1), (7,2)].
 1000 3-d points uniformly distributed in a 3-d cube.
For the Wikipedia example, find the nearest neighbor to point (9, 2)
For the random data, pick a random location and find the nearest neighbor.

In addition, instrument your code to count the number of nodes visited in the nearest neighbor search. Count a node as visited if any field of it is accessed.

Output should show the point searched for, the point found,
the distance to the point, and the number of nodes visited.

There are variant algorithms for constructing the tree.
You can use a simple median strategy or implement something more efficient.
Variants of the nearest neighbor search include nearest N neighbors, approximate nearest neighbor, and range searches.
You do not have to implement these.
The requirement for this task is specifically the nearest single neighbor.
Also there are algorithms for inserting, deleting, and balancing k-d trees.
These are also not required for the task.
",#Go,Go,"// Implmentation following pseudocode from ""An intoductory tutorial on kd-trees""
// by Andrew W. Moore, Carnegie Mellon University, PDF accessed from
// http://www.autonlab.org/autonweb/14665
package main
 
import (
    ""fmt""
    ""math""
    ""math/rand""
    ""sort""
    ""time""
)
 
// point is a k-dimensional point.
type point []float64
 
// sqd returns the square of the euclidean distance.
func (p point) sqd(q point) float64 {
    var sum float64
    for dim, pCoord := range p {
        d := pCoord - q[dim]
        sum += d * d
    }
    return sum
}
 
// kdNode following field names in the paper.
// rangeElt would be whatever data is associated with the point.  we don't
// bother with it for this example.
type kdNode struct {
    domElt      point
    split       int
    left, right *kdNode
}   
 
type kdTree struct {
    n      *kdNode
    bounds hyperRect
}
 
type hyperRect struct {
    min, max point
}
 
// Go slices are reference objects.  The data must be copied if you want
// to modify one without modifying the original.
func (hr hyperRect) copy() hyperRect {
    return hyperRect{append(point{}, hr.min...), append(point{}, hr.max...)}
}   
 
// newKd constructs a kdTree from a list of points, also associating the
// bounds of the tree.  The bounds could be computed of course, but in this
// example we know them already.  The algorithm is table 6.3 in the paper.
func newKd(pts []point, bounds hyperRect) kdTree {
    var nk2 func([]point, int) *kdNode
    nk2 = func(exset []point, split int) *kdNode {
        if len(exset) == 0 {
            return nil
        }
        // pivot choosing procedure.  we find median, then find largest
        // index of points with median value.  this satisfies the
        // inequalities of steps 6 and 7 in the algorithm.
        sort.Sort(part{exset, split})
        m := len(exset) / 2
        d := exset[m]
        for m+1 < len(exset) && exset[m+1][split] == d[split] {
            m++
        }
        // next split
        s2 := split + 1
        if s2 == len(d) {
            s2 = 0
        }
        return &kdNode{d, split, nk2(exset[:m], s2), nk2(exset[m+1:], s2)}
    }
    return kdTree{nk2(pts, 0), bounds}
}
 
// a container type used for sorting.  it holds the points to sort and
// the dimension to use for the sort key.
type part struct {
    pts   []point
    dPart int
}
 
// satisfy sort.Interface
func (p part) Len() int { return len(p.pts) }
func (p part) Less(i, j int) bool {
    return p.pts[i][p.dPart] < p.pts[j][p.dPart]
}
func (p part) Swap(i, j int) { p.pts[i], p.pts[j] = p.pts[j], p.pts[i] }
 
// nearest.  find nearest neighbor.  return values are:
//    nearest neighbor--the point within the tree that is nearest p.
//    square of the distance to that point.
//    a count of the nodes visited in the search.
func (t kdTree) nearest(p point) (best point, bestSqd float64, nv int) {
    return nn(t.n, p, t.bounds, math.Inf(1))
}
 
// algorithm is table 6.4 from the paper, with the addition of counting
// the number nodes visited.
func nn(kd *kdNode, target point, hr hyperRect,
    maxDistSqd float64) (nearest point, distSqd float64, nodesVisited int) {
    if kd == nil {
        return nil, math.Inf(1), 0
    }
    nodesVisited++
    s := kd.split
    pivot := kd.domElt
    leftHr := hr.copy()
    rightHr := hr.copy()
    leftHr.max[s] = pivot[s]
    rightHr.min[s] = pivot[s]
    targetInLeft := target[s] <= pivot[s]
    var nearerKd, furtherKd *kdNode
    var nearerHr, furtherHr hyperRect
    if targetInLeft {
        nearerKd, nearerHr = kd.left, leftHr
        furtherKd, furtherHr = kd.right, rightHr
    } else {
        nearerKd, nearerHr = kd.right, rightHr
        furtherKd, furtherHr = kd.left, leftHr
    }
    var nv int
    nearest, distSqd, nv = nn(nearerKd, target, nearerHr, maxDistSqd)
    nodesVisited += nv
    if distSqd < maxDistSqd {
        maxDistSqd = distSqd
    }
    d := pivot[s] - target[s]
    d *= d
    if d > maxDistSqd {
        return
    }
    if d = pivot.sqd(target); d < distSqd {
        nearest = pivot
        distSqd = d
        maxDistSqd = distSqd
    }
    tempNearest, tempSqd, nv := nn(furtherKd, target, furtherHr, maxDistSqd)
    nodesVisited += nv
    if tempSqd < distSqd {
        nearest = tempNearest
        distSqd = tempSqd
    }
    return
}
 
func main() {
    rand.Seed(time.Now().Unix())
    kd := newKd([]point{{2, 3}, {5, 4}, {9, 6}, {4, 7}, {8, 1}, {7, 2}},
        hyperRect{point{0, 0}, point{10, 10}})
    showNearest(""WP example data"", kd, point{9, 2})
    kd = newKd(randomPts(3, 1000), hyperRect{point{0, 0, 0}, point{1, 1, 1}})
    showNearest(""1000 random 3d points"", kd, randomPt(3))
}   
 
func randomPt(dim int) point {
    p := make(point, dim)
    for d := range p {
        p[d] = rand.Float64()
    }
    return p
}   
 
func randomPts(dim, n int) []point {
    p := make([]point, n)
    for i := range p {
        p[i] = randomPt(dim) 
    } 
    return p
}
 
func showNearest(heading string, kd kdTree, p point) {
    fmt.Println()
    fmt.Println(heading)
    fmt.Println(""point:           "", p)
    nn, ssq, nv := kd.nearest(p)
    fmt.Println(""nearest neighbor:"", nn)
    fmt.Println(""distance:        "", math.Sqrt(ssq))
    fmt.Println(""nodes visited:   "", nv)
}",5264,183
42981,http://rosettacode.org/wiki/Kernighans_large_earthquake_problem,Kernighans large earthquake problem,"Brian Kernighan, in a lecture at the University of Nottingham, described a problem on which this task is based.

Problem

You are given a a data file of thousands of lines; each of three `whitespace` separated fields: a date, a one word name and the magnitude of the event.

Example lines from the file would be lines like:

8/27/1883    Krakatoa            8.8
5/18/1980    MountStHelens       7.6
3/13/2009    CostaRica           5.1
Task

 Create a program or script invocation to find all the events with magnitude greater than 6
 Assuming an appropriate name e.g. ""data.txt"" for the file:
 Either: Show how your program is invoked to process a data file of that name.
 Or: Incorporate the file name into the program, (as it is assumed that the program is single use).

",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""os""
    ""strconv""
    ""strings""
)
 
func main() {
    f, err := os.Open(""data.txt"")
    if err != nil {
        fmt.Println(""Unable to open the file"")
        return
    }
    defer f.Close()
    fmt.Println(""Those earthquakes with a magnitude > 6.0 are:\n"")
    input := bufio.NewScanner(f)
    for input.Scan() {
        line := input.Text()
        fields := strings.Fields(line)
        mag, err := strconv.ParseFloat(fields[2], 64)
        if err != nil {
            fmt.Println(""Unable to parse magnitude of an earthquake"")
            return
        }
        if mag > 6.0 {
            fmt.Println(line)
        }
    }
}",681,32
42995,http://rosettacode.org/wiki/Juggler_sequence,Juggler sequence,"Background of the   juggler sequence:

Juggler sequences were publicized by an American mathematician and author   Clifford A. Pickover.   The name of the sequence gets it's name from the similarity of the rising and falling nature of the numbers in the sequences,   much like balls in the hands of a juggler.



Description
A juggler sequence is an integer sequence that starts with a positive integer a[0], with each subsequent term in the sequence being defined by the recurrence relation:

            a[k + 1]  =  floor(a[k] ^ 0.5)    if a[k] is even    or       
            a[k + 1]  =  floor(a[k] ^ 1.5)    if a[k] is odd                                   

If a juggler sequence reaches 1, then all subsequent terms are equal to 1. This is known to be the case for initial terms up to 1,000,000 but it is not known whether all juggler sequences after that will eventually reach 1.



Task

Compute and show here the following statistics for juggler sequences with an initial term of a[n] where n is between 20 and 39 inclusive:

 l[n] - the number of terms needed to reach 1.
 h[n] - the maximum value reached in that sequence.
 i[n] - the index of the term (starting from 0) at which the maximum is (first) reached.


If your language supports big integers with an integer square root function, also compute and show here the same statistics for as many as you reasonably can of the following values for n:

113, 173, 193, 2183, 11229, 15065, 15845, 30817, 48443, 275485, 1267909, 2264915, 5812827

Those with fast languages and fast machines may also like to try their luck at n = 7110201.

However, as h[n] for most of these numbers is thousands or millions of digits long, show instead of h[n]:

 d[n] - the number of digits in h[n]


The results can be (partially) verified against the table here.



Related tasks

   Hailstone sequence
   Yellowstone sequence
   Isqrt_(integer_square_root)_of_X


See also

 oeis:A007320 Number of steps needed for Juggler sequence started at n to reach 1 
 oeis:A094716 Largest value in the Juggler sequence started at n

",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    //""math/big""
    big ""github.com/ncw/gmp""
    ""rcu""
)
 
var zero = new(big.Int)
var one = big.NewInt(1)
var two = big.NewInt(2)
 
func juggler(n int64) (int, int, *big.Int, int) {
    if n < 1 {
        log.Fatal(""Starting value must be a positive integer."")
    }
    count := 0
    maxCount := 0
    a := big.NewInt(n)
    max := big.NewInt(n)
    tmp := new(big.Int)
    for a.Cmp(one) != 0 {
        if tmp.Rem(a, two).Cmp(zero) == 0 {
            a.Sqrt(a)
        } else {
            tmp.Mul(a, a)
            tmp.Mul(tmp, a)
            a.Sqrt(tmp)
        }
        count++
        if a.Cmp(max) > 0 {
            max.Set(a)
            maxCount = count
        }
    }
    return count, maxCount, max, len(max.String())
}
 
func main() {
    fmt.Println(""n    l[n]  i[n]  h[n]"")
    fmt.Println(""-----------------------------------"")
    for n := int64(20); n < 40; n++ {
        count, maxCount, max, _ := juggler(n)
        cmax := rcu.Commatize(int(max.Int64()))
        fmt.Printf(""%2d    %2d   %2d    %s\n"", n, count, maxCount, cmax)
    }
    fmt.Println()
    nums := []int64{
        113, 173, 193, 2183, 11229, 15065, 15845, 30817, 48443, 275485, 1267909,
        2264915, 5812827, 7110201, 56261531, 92502777, 172376627, 604398963,
    }
    fmt.Println(""       n      l[n]   i[n]   d[n]"")
    fmt.Println(""-------------------------------------"")
    for _, n := range nums {
        count, maxCount, _, digits := juggler(n)
        cn := rcu.Commatize(int(n))
        fmt.Printf(""%11s   %3d    %3d    %s\n"", cn, count, maxCount, rcu.Commatize(digits))
    }
}",1628,61
43003,http://rosettacode.org/wiki/K-means%2B%2B_clustering,K-means++ clustering,"K-means++ clustering
K-means
 This data was partitioned into 7 clusters using the K-means algorithm.
The task is to implement the K-means++ algorithm. Produce a function which takes two arguments: the number of clusters K, and the dataset to classify. K is a positive integer and the dataset is a list of points in the Cartesian plane. The output is a list of clusters (related sets of points, according to the algorithm).

For extra credit (in order):

 Provide a function to exercise your code, which generates a list of random points.
 Provide a visualization of your results, including centroids (see example image). 
 Generalize the function to polar coordinates (in radians).
 Generalize the function to points in an arbitrary N space (i.e. instead of x,y pairs, points are an N-tuples representing coordinates in ℝN). 
If this is different or more difficult than the [naive] solution for ℝ2, discuss what had to change to support N dimensions.
Extra credit is only awarded if the examples given demonstrate the feature in question. To earn credit for 1. and 2., visualize 6 clusters of 30,000 points in ℝ2. It is not necessary to provide visualization for spaces higher than ℝ2 but the examples should demonstrate features 3. and 4. if the solution has them.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""image""
    ""image/color""
    ""image/draw""
    ""image/png""
    ""math""
    ""math/rand""
    ""os""
    ""time""
)
 
type r2 struct {
    x, y float64
}
 
type r2c struct {
    r2
    c int // cluster number
}
 
// kmpp implements K-means++, satisfying the basic task requirement
func kmpp(k int, data []r2c) {
    kMeans(data, kmppSeeds(k, data))
}
 
// kmppSeeds is the ++ part.
// It generates the initial means for the k-means algorithm.
func kmppSeeds(k int, data []r2c) []r2 {
    s := make([]r2, k)
    s[0] = data[rand.Intn(len(data))].r2
    d2 := make([]float64, len(data))
    for i := 1; i < k; i++ {
        var sum float64
        for j, p := range data {
            _, dMin := nearest(p, s[:i])
            d2[j] = dMin * dMin
            sum += d2[j]
        }
        target := rand.Float64() * sum
        j := 0
        for sum = d2[0]; sum < target; sum += d2[j] {
            j++
        }
        s[i] = data[j].r2
    }
    return s
}
 
// nearest finds the nearest mean to a given point.
// return values are the index of the nearest mean, and the distance from
// the point to the mean.
func nearest(p r2c, mean []r2) (int, float64) {
    iMin := 0
    dMin := math.Hypot(p.x-mean[0].x, p.y-mean[0].y)
    for i := 1; i < len(mean); i++ {
        d := math.Hypot(p.x-mean[i].x, p.y-mean[i].y)
        if d < dMin {
            dMin = d
            iMin = i
        }
    }
    return iMin, dMin
}
 
// kMeans algorithm.  Lloyd's
func kMeans(data []r2c, mean []r2) {
    // initial assignment
    for i, p := range data {
        cMin, _ := nearest(p, mean)
        data[i].c = cMin
    }
    mLen := make([]int, len(mean))
    for {
        // update means
        for i := range mean {
            mean[i] = r2{}
            mLen[i] = 0
        }
        for _, p := range data {
            mean[p.c].x += p.x
            mean[p.c].y += p.y
            mLen[p.c]++
        }
        for i := range mean {
            inv := 1 / float64(mLen[i])
            mean[i].x *= inv
            mean[i].y *= inv
        }
        // make new assignments, count changes
        var changes int
        for i, p := range data {
            if cMin, _ := nearest(p, mean); cMin != p.c {
                changes++
                data[i].c = cMin
            }
        }
        if changes == 0 {
            return
        }
    }
}
 
// parameters for extra credit exercises
type ecParam struct {
    k          int
    nPoints    int
    xBox, yBox int
    stdv       int
}
 
// extra credit 1 and 2:
func main() {
    ec := &ecParam{6, 30000, 300, 200, 30}
 
    origin, data := genECData(ec)
    vis(ec, data, ""origin"")
    fmt.Println(""Data set origins:"")
    fmt.Println(""    x      y"")
    for _, o := range origin {
        fmt.Printf(""%5.1f  %5.1f\n"", o.x, o.y)
    }
 
    kmpp(ec.k, data)
 
    fmt.Println(
        ""\nCluster centroids, mean distance from centroid, number of points:"")
    fmt.Println(""    x      y  distance  points"")
    cent := make([]r2, ec.k)
    cLen := make([]int, ec.k)
    inv := make([]float64, ec.k)
    for _, p := range data {
        cent[p.c].x += p.x 
        cent[p.c].y += p.y 
        cLen[p.c]++
    }
    for i, iLen := range cLen {
        inv[i] = 1 / float64(iLen)
        cent[i].x *= inv[i]
        cent[i].y *= inv[i]
    }
    dist := make([]float64, ec.k)
    for _, p := range data {
        dist[p.c] += math.Hypot(p.x-cent[p.c].x, p.y-cent[p.c].y)
    }
    for i, iLen := range cLen {
        fmt.Printf(""%5.1f  %5.1f  %8.1f  %6d\n"",
            cent[i].x, cent[i].y, dist[i]*inv[i], iLen)
    }
    vis(ec, data, ""clusters"")
}
 
// genECData generates random data for extra credit tasks.
// k origin points are randomly selected in a bounding box.
// nPoints/k coordinates are then generated for each origin point.
// The x and y coordinates of the data are normally distributed
// with standard deviation stdv.  Thus data coordinates are not
// constrained to the origin box; they can range to +/- max float64.
func genECData(ec *ecParam) (orig []r2, data []r2c) {
    rand.Seed(time.Now().UnixNano())
    orig = make([]r2, ec.k)
    data = make([]r2c, ec.nPoints)
    for i, n := 0, 0; i < ec.k; i++ {
        x := rand.Float64() * float64(ec.xBox)
        y := rand.Float64() * float64(ec.yBox)
        orig[i] = r2{x, y}
        for j := ec.nPoints / ec.k; j > 0; j-- {
            data[n].x = rand.NormFloat64()*float64(ec.stdv) + x
            data[n].y = rand.NormFloat64()*float64(ec.stdv) + y
            data[n].c = i
            n++
        }
    }
    return
}
 
// vis writes a .png for extra credit 2.
func vis(ec *ecParam, data []r2c, fn string) {
    colors := make([]color.NRGBA, ec.k)
    for i := range colors {
        i3 := i * 3
        third := i3 / ec.k
        frac := uint8((i3 % ec.k) * 255 / ec.k)
        switch third {
        case 0:
            colors[i] = color.NRGBA{frac, 255 - frac, 0, 255}
        case 1:
            colors[i] = color.NRGBA{0, frac, 255 - frac, 255}
        case 2:
            colors[i] = color.NRGBA{255 - frac, 0, frac, 255}
        }
    }
    bounds := image.Rect(-ec.stdv, -ec.stdv, ec.xBox+ec.stdv, ec.yBox+ec.stdv)
    im := image.NewNRGBA(bounds)
    draw.Draw(im, bounds, image.NewUniform(color.White), image.ZP, draw.Src)
    fMinX := float64(bounds.Min.X)
    fMaxX := float64(bounds.Max.X)
    fMinY := float64(bounds.Min.Y)
    fMaxY := float64(bounds.Max.Y)
    for _, p := range data {
        imx := math.Floor(p.x)
        imy := math.Floor(float64(ec.yBox) - p.y)
        if imx >= fMinX && imx < fMaxX && imy >= fMinY && imy < fMaxY {
            im.SetNRGBA(int(imx), int(imy), colors[p.c])
        }
    }
    f, err := os.Create(fn + "".png"")
    if err != nil {
        fmt.Println(err)
        return
    }
    err = png.Encode(f, im)
    if err != nil {
        fmt.Println(err)
    }
    err = f.Close()
    if err != nil {
        fmt.Println(err)
    }
}",5947,222
43090,http://rosettacode.org/wiki/Joystick_position,Joystick position,"The task is to determine the joystick position and represent this on the display via a crosshair.
For a centred joystick, the crosshair should appear in the centre of the screen.
If the joystick is pushed left or right, then the cross hair should move left or right according to the extent that the joystick is pushed.

If the joystick is pushed forward or pulled back, then the crosshair should move up or down according to the extent that that joystick is pushed or pulled.
The edges of the display represent maximum extents for joystick movement.

For example, a joystick pushed fully forward would raise the crosshair to the top centre of the screen.

A joystick pulled backwards and to the right would move the crosshair to the bottom right of the screen (except for a small area reserved to show joystick status). Implementations can use a graphical display method to produce the crosshair, or alternatively represent the crosshair using a plus symbol on
a terminal, and move the plus symbol position according to the joystick.
The bottom part of the display can hide or show an alphanumeric sequence to represent the buttons pressed.

For example, if pushbuttons 1,4 and 10 are depressed, we could display ""1 4 A"".

The implemented code should continue to redraw the crosshair according to the joystick position and show the current pushbutton statuses until the task is terminated.
Digital joysticks that produce no extent data, should have their position indicated as full extent movement of the crosshair.

For the purpose of this task, we assume that the joystick is calibrated and that the first joystick is being used. 

The task implementer could at their option provide a solution that includes a joystick selection facility, enabling the user to choose which joystick is to be used for this task.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""github.com/nsf/termbox-go""
    ""github.com/simulatedsimian/joystick""
    ""log""
    ""os""
    ""strconv""
    ""time""
)
 
func printAt(x, y int, s string) {
    for _, r := range s {
        termbox.SetCell(x, y, r, termbox.ColorDefault, termbox.ColorDefault)
        x++
    }
}
 
func readJoystick(js joystick.Joystick, hidden bool) {
    jinfo, err := js.Read()
    check(err)
 
    w, h := termbox.Size()
    tbcd := termbox.ColorDefault
    termbox.Clear(tbcd, tbcd)
    printAt(1, h-1, ""q - quit"")
    if hidden {
        printAt(11, h-1, ""s - show buttons:"")
    } else {
        bs := """"
        printAt(11, h-1, ""h - hide buttons:"")
        for button := 0; button < js.ButtonCount(); button++ {
            if jinfo.Buttons&(1<<uint32(button)) != 0 {
                // Buttons assumed to be numbered from 1, not 0.
                bs += fmt.Sprintf("" %X"", button+1)
            }
        }
        printAt(28, h-1, bs)
    }
 
    // Map axis values in range -32767 to +32768 to termbox co-ordinates.
    x := int(float64((jinfo.AxisData[0]+32767)*(w-1)) / 65535)
    y := int(float64((jinfo.AxisData[1]+32767)*(h-2)) / 65535)
    printAt(x, y, ""+"") // display crosshair
    termbox.Flush()
}
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func main() {
    // Under Linux the id is used to construct the joystick device name.
    // For example: id 0 will open device: ""/dev/input/js0""
    // Under Windows the id is the actual numeric id of the joystick.
    jsid := 0
    // Optionally pass joystick id to be used as a command line argument.
    if len(os.Args) > 1 {
        i, err := strconv.Atoi(os.Args[1])
        check(err)
        jsid = i
    }
 
    js, jserr := joystick.Open(jsid)
    check(jserr)
 
    err := termbox.Init()
    check(err)
    defer termbox.Close()
 
    eventQueue := make(chan termbox.Event)
    go func() {
        for {
            eventQueue <- termbox.PollEvent()
        }
    }()
 
    ticker := time.NewTicker(time.Millisecond * 40)
    hidden := false // Controls whether button display hidden or not.
 
    for doQuit := false; !doQuit; {
        select {
        case ev := <-eventQueue:
            if ev.Type == termbox.EventKey {
                if ev.Ch == 'q' {
                    doQuit = true
                } else if ev.Ch == 'h' {
                    hidden = true
                } else if ev.Ch == 's' {
                    hidden = false
                }
            }
            if ev.Type == termbox.EventResize {
                termbox.Flush()
            }
        case <-ticker.C:
            readJoystick(js, hidden)
        }
    }
}",2678,103
43195,http://rosettacode.org/wiki/Jump_anywhere,Jump anywhere,"Imperative programs
conditional structures
loops
local jumps
This task is to demonstrate a local jump and a global jump and the various other types of jumps that the language supports.
For the purpose of this task, the jumps need not be used for a single purpose and you have the freedom to use these jumps for different purposes.
You may also defer to more specific tasks, like Exceptions or Generator.
This task provides a ""grab bag"" for several types of jumps. There are non-local jumps across function calls, or long jumps to anywhere within a program. Anywhere means not only to the tops of functions!

 Some languages can go to any global label in a program.
 Some languages can break multiple function calls, also known as unwinding the call stack.
 Some languages can save a continuation. The program can later continue from the same place. So you can jump anywhere, but only if you have a previous visit there (to save the continuation).

These jumps are not all alike.
A simple goto never touches the call stack.
A continuation saves the call stack, so you can continue a function call after it ends.



Task

Use your language to demonstrate the various types of jumps that it supports.

Because the possibilities vary by language, this task is not specific.
You have the freedom to use these jumps for different purposes.
You may also defer to more specific tasks, like Exceptions or Generator.



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    outer:
    for i := 0; i < 4; i++ {
        for j := 0; j < 4; j++ {
            if i + j == 4 { continue outer }
            if i + j == 5 { break outer }
            fmt.Println(i + j)
        }
    }
 
    k := 3
    if k == 3 { goto later }
    fmt.Println(k)  // never executed
    later:
    k++
    fmt.Println(k)
}",370,21
43250,http://rosettacode.org/wiki/Julia_set,Julia set,"
Task
Generate and draw a Julia set.




Related tasks
   Mandelbrot Set

",#Go,Go,"package main
 
import (
	""image""
	""image/color""
	""image/png""
	""log""
	""os""
	""sync""
)
 
func main() {
	const (
		width, height = 800.0, 600.0
		maxIter       = 255
		cX, cY        = -0.7, 0.27015
		fileName      = ""julia.png""
	)
	img := image.NewNRGBA(image.Rect(0, 0, width, height))
 
	var wg sync.WaitGroup
	wg.Add(width)
	for x := 0; x < width; x++ {
		thisx := float64(x)
		go func() {
			var tmp, zx, zy float64
			var i uint8
			for y := 0.0; y < height; y++ {
				zx = 1.5 * (thisx - width/2) / (0.5 * width)
				zy = (y - height/2) / (0.5 * height)
				i = maxIter
				for zx*zx+zy*zy < 4.0 && i > 0 {
					tmp = zx*zx - zy*zy + cX
					zy = 2.0*zx*zy + cY
					zx = tmp
					i--
				}
				img.Set(int(thisx), int(y), color.RGBA{i, i, i << 3, 255})
			}
			wg.Done()
		}()
	}
	wg.Wait()
	imgFile, err := os.Create(fileName)
	if err != nil {
		log.Fatal(err)
	}
	defer imgFile.Close()
	if err := png.Encode(imgFile, img); err != nil {
		imgFile.Close()
		log.Fatal(err)
	}
}",980,53
43356,http://rosettacode.org/wiki/JSON,JSON,"Load a JSON string into a data structure.
Also, create a new data structure and serialize it into JSON.

Use objects and arrays (as appropriate for your language)
and make sure your JSON is valid (https://jsonformatter.org).
",#Go,Go,"package main
 
import ""encoding/json""
import ""fmt""
 
func main() {
    var data interface{}
    err := json.Unmarshal([]byte(`{""foo"":1, ""bar"":[10, ""apples""]}`), &data)
    if err == nil {
        fmt.Println(data)
    } else {
        fmt.Println(err)
    }
 
    sample := map[string]interface{}{
        ""blue"":  []interface{}{1, 2},
        ""ocean"": ""water"",
    }
    json_string, err := json.Marshal(sample)
    if err == nil {
        fmt.Println(string(json_string))
    } else {
        fmt.Println(err)
    }
}",519,25
43358,http://rosettacode.org/wiki/Knight%27s_tour,Knight's tour,"
Task
Problem: you have a standard 8x8 chessboard, empty but for a single knight on some square. Your task is to emit a series of legal knight moves that result in the knight visiting every square on the chessboard exactly once. Note that it is not a requirement that the tour be ""closed""; that is, the knight need not end within a single move of its start position.

Input and output may be textual or graphical, according to the conventions of the programming environment. If textual, squares should be indicated in algebraic notation. The output should indicate the order in which the knight visits the squares, starting with the initial position. The form of the output may be a diagram of the board with the squares numbered according to visitation sequence, or a textual list of algebraic coordinates in order, or even an actual animation of the knight moving around the chessboard.

Input: starting square

Output: move sequence



Related tasks
 A* search algorithm
 N-queens problem
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
// input, 0-based start position
const startRow = 0
const startCol = 0
 
func main() {
    rand.Seed(time.Now().Unix())
    for !knightTour() {
    }
}
 
var moves = []struct{ dr, dc int }{
    {2, 1},
    {2, -1},
    {1, 2},
    {1, -2},
    {-1, 2},
    {-1, -2},
    {-2, 1},
    {-2, -1},
}
 
// Attempt knight tour starting at startRow, startCol using Warnsdorff's rule
// and random tie breaking.  If a tour is found, print it and return true.
// Otherwise no backtracking, just return false.
func knightTour() bool {
    // 8x8 board.  squares hold 1-based visit order.  0 means unvisited.
    board := make([][]int, 8)
    for i := range board {
        board[i] = make([]int, 8)
    }
    r := startRow
    c := startCol
    board[r][c] = 1 // first move
    for move := 2; move <= 64; move++ {
        minNext := 8
        var mr, mc, nm int
    candidateMoves:
        for _, cm := range moves {
            cr := r + cm.dr
            if cr < 0 || cr >= 8 { // off board
                continue
            }
            cc := c + cm.dc
            if cc < 0 || cc >= 8 { // off board
                continue
            }
            if board[cr][cc] > 0 { // already visited
                continue
            }
            // cr, cc candidate legal move.
            p := 0 // count possible next moves.
            for _, m2 := range moves {
                r2 := cr + m2.dr
                if r2 < 0 || r2 >= 8 {
                    continue
                }
                c2 := cc + m2.dc
                if c2 < 0 || c2 >= 8 {
                    continue
                }
                if board[r2][c2] > 0 {
                    continue
                }
                p++
                if p > minNext { // bail out as soon as it's eliminated
                    continue candidateMoves
                }
            }
            if p < minNext { // it's better.  keep it.
                minNext = p // new min possible next moves
                nm = 1      // number of candidates with this p
                mr = cr     // best candidate move
                mc = cc
                continue
            }
            // it ties for best so far.
            // keep it with probability 1/(number of tying moves)
            nm++                    // number of tying moves
            if rand.Intn(nm) == 0 { // one chance to keep it
                mr = cr
                mc = cc
            }
        }
        if nm == 0 { // no legal move
            return false
        }
        // make selected move
        r = mr
        c = mc
        board[r][c] = move
    }
    // tour complete.  print board.
    for _, r := range board {
        for _, m := range r {
            fmt.Printf(""%3d"", m)
        }
        fmt.Println()
    }
    return true
}",2862,108
43369,http://rosettacode.org/wiki/Kaprekar_numbers,Kaprekar numbers,"A positive integer is a Kaprekar number if:

 It is   1     (unity)
 The decimal representation of its square may be split once into two parts consisting of positive integers which sum to the original number. 

Note that a split resulting in a part consisting purely of 0s is not valid,
as 0 is not considered positive.



Example Kaprekar numbers

 



2223


{\displaystyle 2223}

 is a Kaprekar number, as 



2223
∗
2223
=
4941729


{\displaystyle 2223*2223=4941729}

, 



4941729


{\displaystyle 4941729}

 may be split to 



494


{\displaystyle 494}

 and 



1729


{\displaystyle 1729}

, and 



494
+
1729
=
2223


{\displaystyle 494+1729=2223}

.
 The series of Kaprekar numbers is known as A006886, and begins as 



1
,
9
,
45
,
55
,
.
.
.


{\displaystyle 1,9,45,55,...}

.


Example process

10000 (1002) splitting from left to right:

 The first split is [1, 0000], and is invalid; the 0000 element consists entirely of 0s, and 0 is not considered positive.
 Slight optimization opportunity: When splitting from left to right, once the right part consists entirely of 0s, no further testing is needed; all further splits would also be invalid.


Task

Generate and show all Kaprekar numbers less than 10,000.



Extra credit

Optionally, count (and report the count of) how many Kaprekar numbers are less than 1,000,000.



Extra extra credit

The concept of Kaprekar numbers is not limited to base 10 (i.e. decimal numbers);
if you can, show that Kaprekar numbers exist in other bases too.



For this purpose, do the following:

 Find all Kaprekar numbers for base 17 between 1 and 1,000,000 (one million);
 Display each of them in base 10 representation;
 Optionally, using base 17 representation (use letters 'a' to 'g' for digits 10(10) to 16(10)), display each of the numbers, its square, and where to split the square. 


225   d4  a52g  a5 + 2g


Reference

 The Kaprekar Numbers by Douglas E. Iannucci (2000). PDF version


Related task

   Casting out nines

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
func kaprekar(n uint64, base uint64) (bool, int) {
    order := 0
    if n == 1 {
        return true, -1
    }
 
    nn, power := n*n, uint64(1)
    for power <= nn {
        power *= base
        order++
    }
 
    power /= base
    order--
    for ; power > 1; power /= base {
        q, r := nn/power, nn%power
        if q >= n {
            return false, -1
        }
 
        if q+r == n {
            return true, order
        }
 
        order--
    }
 
    return false, -1
}
 
func main() {
    max := uint64(10000)
    fmt.Printf(""Kaprekar numbers < %d:\n"", max)
    for m := uint64(0); m < max; m++ {
        if is, _ := kaprekar(m, 10); is {
            fmt.Println(""  "", m)
        }
    }
 
    // extra credit
    max = 1e6
    var count int
    for m := uint64(0); m < max; m++ {
        if is, _ := kaprekar(m, 10); is {
            count++
        }
    }
    fmt.Printf(""\nThere are %d Kaprekar numbers < %d.\n"", count, max)
 
    // extra extra credit
    const base = 17
    maxB := ""1000000""
    fmt.Printf(""\nKaprekar numbers between 1 and %s(base %d):\n"", maxB, base)
    max, _ = strconv.ParseUint(maxB, base, 64)
    fmt.Printf(""\n Base 10  Base %d        Square       Split\n"", base)
    for m := uint64(2); m < max; m++ {
        is, pos := kaprekar(m, base)
        if !is {
            continue
        }
        sq := strconv.FormatUint(m*m, base)
        str := strconv.FormatUint(m, base)
        split := len(sq)-pos
        fmt.Printf(""%8d  %7s  %12s  %6s + %s\n"", m,
            str, sq, sq[:split], sq[split:]) // optional extra extra credit
    }
}",1643,74
43467,http://rosettacode.org/wiki/Knapsack_problem/0-1,Knapsack problem/0-1,"A tourist wants to make a good trip at the weekend with his friends.

They will go to the mountains to see the wonders of nature, so he needs to pack well for the trip.

He has a good knapsack for carrying things, but knows that he can carry a maximum of only 4kg in it,   and it will have to last the whole day.

He creates a list of what he wants to bring for the trip but the total weight of all items is too much.

He then decides to add columns to his initial list detailing their weights and a numerical value representing how important the item is for the trip.



Here is the list:


 Table of potential knapsack items


 item 
 weight (dag) 
 value


 map 
 9 
 150


 compass 
 13 
 35


 water 
 153 
 200


 sandwich 
 50 
 160


 glucose 
 15 
 60


 tin 
 68 
 45


 banana 
 27 
 60


 apple 
 39 
 40


 cheese 
 23 
 30


 beer 
 52 
 10


 suntan cream 
 11 
 70


 camera 
 32 
 30


 T-shirt 
 24 
 15


 trousers 
 48 
 10


 umbrella 
 73 
 40


 waterproof trousers 
 42 
 70


 waterproof overclothes 
 43 
 75


 note-case 
 22 
 80


 sunglasses 
 7 
 20


 towel 
 18 
 12


 socks 
 4 
 50


 book 
 30 
 10


 knapsack 
 ≤400 dag 
 ?



The tourist can choose to take any combination of items from the list,
but only one of each item is available.

He may not cut or diminish the items, so he can only take whole units of any item.



Task

Show which items the tourist can carry in his knapsack so that their total weight does not
exceed 400 dag [4 kg],   and their total value is maximized.

[dag = decagram = 10 grams]



Related tasks

   Knapsack problem/Bounded
   Knapsack problem/Unbounded
   Knapsack problem/Continuous
   A* search algorithm

",#Go,Go,"package main
 
import ""fmt""
 
type item struct {
    string
    w, v int
}
 
var wants = []item{
    {""map"", 9, 150},
    {""compass"", 13, 35},
    {""water"", 153, 200},
    {""sandwich"", 50, 160},
    {""glucose"", 15, 60},
    {""tin"", 68, 45},
    {""banana"", 27, 60},
    {""apple"", 39, 40},
    {""cheese"", 23, 30},
    {""beer"", 52, 10},
    {""suntan cream"", 11, 70},
    {""camera"", 32, 30},
    {""T-shirt"", 24, 15},
    {""trousers"", 48, 10},
    {""umbrella"", 73, 40},
    {""waterproof trousers"", 42, 70},
    {""waterproof overclothes"", 43, 75},
    {""note-case"", 22, 80},
    {""sunglasses"", 7, 20},
    {""towel"", 18, 12},
    {""socks"", 4, 50},
    {""book"", 30, 10},
}
 
const maxWt = 400
 
func main() {
    items, w, v := m(len(wants)-1, maxWt)
    fmt.Println(items)
    fmt.Println(""weight:"", w)
    fmt.Println(""value:"", v)
}
 
func m(i, w int) ([]string, int, int) {
    if i < 0 || w == 0 {
        return nil, 0, 0
    } else if wants[i].w > w {
        return m(i-1, w)
    }
    i0, w0, v0 := m(i-1, w)
    i1, w1, v1 := m(i-1, w-wants[i].w)
    v1 += wants[i].v
    if v1 > v0 {
        return append(i1, wants[i].string), w1 + wants[i].w, v1
    }
    return i0, w0, v0
}",1179,57
43494,http://rosettacode.org/wiki/Knuth_shuffle,Knuth shuffle,"The   Knuth shuffle   (a.k.a. the Fisher-Yates shuffle)   is an algorithm for randomly shuffling the elements of an array.



Task

Implement the Knuth shuffle for an integer array (or, if possible, an array of any type).



Specification

Given an array items with indices ranging from 0 to last, the algorithm can be defined as follows (pseudo-code):

       for i from last downto 1 do:
           let j = random integer in range 0 
  
    
      
        ≤
      
    
    {\displaystyle \leq }
  
 j 
  
    
      
        ≤
      
    
    {\displaystyle \leq }
  
 i
           swap items[i] with items[j]

Notes

   It modifies the input array in-place. 
   If that is unreasonable in your programming language, you may amend the algorithm to return the shuffled items as a new array instead.
   The algorithm can also be amended to iterate from left to right, if that is more convenient.


Test cases



 Input array

 Possible output arrays


 []

 []


 [10]

 [10]


 [10, 20]

 [10, 20]
[20, 10]


 [10, 20, 30]

 [10, 20, 30]
[10, 30, 20]
[20, 10, 30]
[20, 30, 10]
[30, 10, 20]
[30, 20, 10]

(These are listed here just for your convenience; no need to demonstrate them on the page.)



Related task

 Sattolo cycle



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
func main() {
    var a [20]int
    for i := range a {
        a[i] = i
    }
    fmt.Println(a)
 
    rand.Seed(time.Now().UnixNano())
    for i := len(a) - 1; i >= 1; i-- {
        j := rand.Intn(i + 1)
        a[i], a[j] = a[j], a[i]
    }
    fmt.Println(a)
}",328,22
43776,http://rosettacode.org/wiki/JortSort,JortSort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 Note:   jortSort is considered a work of satire.   It achieves its result in an intentionally roundabout way.   You are encouraged to write your solutions in the spirit of the original jortsort rather than trying to give the most concise or idiomatic solution.



JortSort is a sorting tool set that makes the user do the work and guarantees efficiency because you don't have to sort ever again.

It was originally presented by Jenn ""Moneydollars"" Schiffer at the
prestigious   JSConf.



JortSort is a function that takes a single array of comparable objects as its argument.

It then sorts the array in ascending order and compares the sorted array to the originally provided array.

If the arrays match   (i.e. the original array was already sorted),   the function returns   true.

If the arrays do not match (i.e. the original array was not sorted), the function returns   false.



",#Go,Go," 
package main
 
import (
  ""log""
  ""sort""
)
 
func main() {
  log.Println(jortSort([]int{1, 2, 1, 11, 213, 2, 4})) //false
  log.Println(jortSort([]int{0, 1, 0, 0, 0, 0}))       //false 
  log.Println(jortSort([]int{1, 2, 4, 11, 22, 22}))    //true
  log.Println(jortSort([]int{0, 0, 0, 1, 2, 2}))       //true
}
 
func jortSort(a []int) bool {
  c := make([]int, len(a))
  copy(c, a)
  sort.Ints(a)
  for k, v := range c {
    if v == a[k] {
      continue
    } else {
      return false
    }
  }
  return true
}
 
 ",520,30
43807,http://rosettacode.org/wiki/Jensen%27s_Device,Jensen's Device,"Jensen's Device

You are encouraged to solve this task according to the task description, using any language you may know.
This task is an exercise in call by name.

Jensen's Device is a computer programming technique devised by Danish computer scientist Jørn Jensen after studying the ALGOL 60 Report.

The following program was proposed to illustrate the technique. It computes the 100th harmonic number:

begin
   integer i;
   real procedure sum (i, lo, hi, term);
      value lo, hi;
      integer i, lo, hi;
      real term;
      comment term is passed by-name, and so is i;
   begin
      real temp;
      temp := 0;
      for i := lo step 1 until hi do
         temp := temp + term;
      sum := temp
   end;
   comment note the correspondence between the mathematical notation and the call to sum;
   print (sum (i, 1, 100, 1/i))
end

The above exploits call by name to produce the correct answer (5.187...). It depends on the assumption that an expression passed as an actual parameter to a procedure would be re-evaluated in the caller's context every time the corresponding formal parameter's value was required. If the last parameter to sum had been passed by value, and assuming the initial value of i were 1, the result would have been 100 × 1/1 = 100.

Moreover, the first parameter to sum, representing the ""bound"" variable of the summation, must also be passed by name (or at least by reference), otherwise changes to it (made within sum) would not be visible in the caller's context when computing each of the values to be added.
(On the other hand, the global variable does not have to use the same identifier, in this case i, as the formal parameter.)

Donald Knuth later proposed the Man or Boy Test as a more rigorous exercise.



",#Go,Go,"package main
 
import ""fmt""
 
var i int
 
func sum(i *int, lo, hi int, term func() float64) float64 {
    temp := 0.0
    for *i = lo; *i <= hi; (*i)++ {
        temp += term()
    }
    return temp
}
 
func main() {
    fmt.Printf(""%f\n"", sum(&i, 1, 100, func() float64 { return 1.0 / float64(i) }))
}",302,17
43811,http://rosettacode.org/wiki/Jacobi_symbol,Jacobi symbol,"The Jacobi symbol is a multiplicative function that generalizes the Legendre symbol. Specifically, the Jacobi symbol (a | n) equals the product of the Legendre symbols (a | p_i)^(k_i), where n = p_1^(k_1)*p_2^(k_2)*...*p_i^(k_i) and the Legendre symbol (a | p) denotes the value of a ^ ((p-1)/2) (mod p)

 (a | p) ≡   1     if a is a square (mod p)
 (a | p) ≡ -1     if a is not a square (mod p)
 (a | p) ≡   0     if a ≡ 0 
If n is prime, then the Jacobi symbol (a | n) equals the Legendre symbol (a | n).

Task

Calculate the Jacobi symbol (a | n).

Reference

 Wikipedia article on Jacobi symbol.",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math/big""
)
 
func jacobi(a, n uint64) int {
    if n%2 == 0 {
        log.Fatal(""'n' must be a positive odd integer"")
    }
    a %= n
    result := 1
    for a != 0 {
        for a%2 == 0 {
            a /= 2
            nn := n % 8
            if nn == 3 || nn == 5 {
                result = -result
            }
        }
        a, n = n, a
        if a%4 == 3 && n%4 == 3 {
            result = -result
        }
        a %= n
    }
    if n == 1 {
        return result
    }
    return 0
}
 
func main() {
    fmt.Println(""Using hand-coded version:"")
    fmt.Println(""n/a  0  1  2  3  4  5  6  7  8  9"")
    fmt.Println(""---------------------------------"")
    for n := uint64(1); n <= 17; n += 2 {
        fmt.Printf(""%2d "", n)
        for a := uint64(0); a <= 9; a++ {
            fmt.Printf("" % d"", jacobi(a, n))
        }
        fmt.Println()
    }
 
    ba, bn := new(big.Int), new(big.Int)
    fmt.Println(""\nUsing standard library function:"")
    fmt.Println(""n/a  0  1  2  3  4  5  6  7  8  9"")
    fmt.Println(""---------------------------------"")
    for n := uint64(1); n <= 17; n += 2 {
        fmt.Printf(""%2d "", n)
        for a := uint64(0); a <= 9; a++ {
            ba.SetUint64(a)
            bn.SetUint64(n)
            fmt.Printf("" % d"", big.Jacobi(ba, bn))            
        }
        fmt.Println()
    }
}",1389,60
43817,http://rosettacode.org/wiki/Jewels_and_stones,Jewels and stones,"Jewels and stones

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a function which takes two string parameters: 'stones' and 'jewels' and returns an integer.

Both strings can contain any number of upper or lower case letters. However, in the case of 'jewels', all letters must be distinct.

The function should count (and return) how many 'stones' are 'jewels' or, in other words, how many letters in 'stones' are also letters in 'jewels'.



Note that:

 Only letters in the ISO basic Latin alphabet i.e. 'A to Z' or 'a to z' need be considered. 
 A lower case letter is considered to be different from its upper case equivalent for this purpose, i.e., 'a' != 'A'.
 The parameters do not need to have exactly the same names.
 Validating the arguments is unnecessary. 
So, for example, if passed ""aAAbbbb"" for 'stones' and ""aA"" for 'jewels', the function should return 3.

This task was inspired by this problem.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func js(stones, jewels string) (n int) {
    for _, b := range []byte(stones) {
        if strings.IndexByte(jewels, b) >= 0 {
            n++
        }
    }
    return
}
 
func main() {
    fmt.Println(js(""aAAbbbb"", ""aA""))
}",278,19
43910,http://rosettacode.org/wiki/Jaro-Winkler_distance,Jaro-Winkler distance,"The Jaro-Winkler distance is a metric for measuring the edit distance between words.
It is similar to the more basic Levenstein distance but the Jaro distance also accounts
for transpositions between letters in the words. With the Winkler modification to the Jaro
metric, the Jaro-Winkler distance also adds an increase in similarity for words which
start with the same letters (prefix).

The Jaro-Winkler distance is a modification of the Jaro similarity metric, which
measures the similarity between two strings. The Jaro similarity is 1.0 when strings are
identical and 0 when strings have no letters in common. Distance measures such as the
Jaro distance or Jaro-Winkler distance, on the other hand, are 0 when strings are
identical and 1 when they have no letters in common.

The Jaro similarity between two strings s1 and s2, simj, is defined as

 simj = 0     if m is 0.
 simj = ( (m / length of s1) + (m / length of s2) + (m - t) / m ) / 3     otherwise.
Where:

 



m


{\displaystyle m}

   is the number of matching characters (the same character within max(|s1|, |s2|)/2 - 1 of one another);
 



t


{\displaystyle t}

   is half the number of transpositions (a shared character placed in different positions).


The Winkler modification to Jaro is to check for identical prefixes of the strings.

If we define the number of initial (prefix) characters in common as:

l = the length of a common prefix between strings, up to 4 characters

and, additionally, select a multiplier (Winkler suggested 0.1) for the relative importance of the
prefix for the word similarity:

 p    =   0.1

The Jaro-Winkler similarity can then be defined as

simw = simj + lp(1 - simj)

Where:

 simj   is the Jaro similarity.
 l   is the number of matching characters at the beginning of the strings, up to 4.
 p   is a factor to modify the amount to which the prefix similarity affects the metric.
Winkler suggested this be 0.1.



The Jaro-Winkler distance between strings, which is 0.0 for identical strings, is then defined as

dw = 1 - simw

String metrics such as Jaro-Winkler distance are useful in applications such as spelling checkers,
because letter transpositions are common typing errors and humans tend to misspell the middle portions
of words more often than their beginnings. This may help a spelling checker program to generate
better alternatives for misspelled word replacement.

The task

Using a dictionary of your choice and the following list of 9 commonly misspelled words:

""accomodate"", ""definately"", ""goverment​"", ""occured"", ""publically"", ""recieve​"", ""seperate"", ""untill"", ""wich​""

 Calculate the Jaro-Winkler distance between the misspelled word and words in the dictionary.
 Use this distance to list close alternatives (at least two per word) to the misspelled words.
 Show the calculated distances between the misspelled words and their potential replacements.
 See also
   Wikipedia page: Jaro–Winkler distance.
   Comparing string similarity algorithms. Comparison of algorithms on Medium

",#Go,Go,"package main
 
import (
    ""bytes""
    ""fmt""
    ""io/ioutil""
    ""log""
    ""sort""
)
 
func jaroSim(str1, str2 string) float64 {
    if len(str1) == 0 && len(str2) == 0 {
        return 1
    }
    if len(str1) == 0 || len(str2) == 0 {
        return 0
    }
    match_distance := len(str1)
    if len(str2) > match_distance {
        match_distance = len(str2)
    }
    match_distance = match_distance/2 - 1
    str1_matches := make([]bool, len(str1))
    str2_matches := make([]bool, len(str2))
    matches := 0.
    transpositions := 0.
    for i := range str1 {
        start := i - match_distance
        if start < 0 {
            start = 0
        }
        end := i + match_distance + 1
        if end > len(str2) {
            end = len(str2)
        }
        for k := start; k < end; k++ {
            if str2_matches[k] {
                continue
            }
            if str1[i] != str2[k] {
                continue
            }
            str1_matches[i] = true
            str2_matches[k] = true
            matches++
            break
        }
    }
    if matches == 0 {
        return 0
    }
    k := 0
    for i := range str1 {
        if !str1_matches[i] {
            continue
        }
        for !str2_matches[k] {
            k++
        }
        if str1[i] != str2[k] {
            transpositions++
        }
        k++
    }
    transpositions /= 2
    return (matches/float64(len(str1)) +
        matches/float64(len(str2)) +
        (matches-transpositions)/matches) / 3
}
 
func jaroWinklerDist(s, t string) float64 {
    ls := len(s)
    lt := len(t)
    lmax := lt
    if ls < lt {
        lmax = ls
    }
    if lmax > 4 {
        lmax = 4
    }
    l := 0
    for i := 0; i < lmax; i++ {
        if s[i] == t[i] {
            l++
        }
    }
    js := jaroSim(s, t)
    p := 0.1
    ws := js + float64(l)*p*(1-js)
    return 1 - ws
}
 
type wd struct {
    word string
    dist float64
}
 
func main() {
    misspelt := []string{
        ""accomodate"", ""definately"", ""goverment"", ""occured"", ""publically"",
        ""recieve"", ""seperate"", ""untill"", ""wich"",
    }
    b, err := ioutil.ReadFile(""unixdict.txt"")
    if err != nil {
        log.Fatal(""Error reading file"")
    }
    words := bytes.Fields(b)
    for _, ms := range misspelt {
        var closest []wd
        for _, w := range words {
            word := string(w)
            if word == """" {
                continue
            }
            jwd := jaroWinklerDist(ms, word)
            if jwd < 0.15 {
                closest = append(closest, wd{word, jwd})
            }
        }
        fmt.Println(""Misspelt word:"", ms, "":"")
        sort.Slice(closest, func(i, j int) bool { return closest[i].dist < closest[j].dist })
        for i, c := range closest {
            fmt.Printf(""%0.4f %s\n"", c.dist, c.word)
            if i == 5 {
                break
            }
        }
        fmt.Println()
    }
}",2923,130
43955,http://rosettacode.org/wiki/Jacobsthal_numbers,Jacobsthal numbers,"Jacobsthal numbers are an integer sequence related to Fibonacci numbers. Similar to Fibonacci, where each term is the sum of the previous two terms, each term is the sum of the previous, plus twice the one before that. Traditionally the sequence starts with the given terms 0, 1.


   J0 = 0
   J1 = 1
   Jn = Jn-1 + 2 × Jn-2


Terms may be calculated directly using one of several possible formulas:


   Jn = ( 2n - (-1)n ) / 3



Jacobsthal-Lucas numbers are very similar. They have the same recurrence relationship, the only difference is an initial starting value J0 = 2 rather than J0 = 0.

Terms may be calculated directly using one of several possible formulas:

   
   JLn = 2n + (-1)n
   

Jacobsthal oblong numbers is the sequence obtained from multiplying each Jacobsthal number Jn by its direct successor Jn+1.


Jacobsthal primes are Jacobsthal numbers that are prime.



Task
 Find and display the first 30 Jacobsthal numbers
 Find and display the first 30 Jacobsthal-Lucas numbers
 Find and display the first 20 Jacobsthal oblong numbers
 Find and display at least the first 10 Jacobsthal primes


See also
 Wikipedia: Jacobsthal number
 Numbers Aplenty - Jacobsthal number
 OEIS:A001045 - Jacobsthal sequence (or Jacobsthal numbers)
 OEIS:A014551 - Jacobsthal-Lucas numbers.
 OEIS:A084175 - Jacobsthal oblong numbers
 OEIS:A049883 - Primes in the Jacobsthal sequence
 Related task: Fibonacci sequence
 Related task: Leonardo numbers



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func jacobsthal(n uint) *big.Int {
    t := big.NewInt(1)
    t.Lsh(t, n)
    s := big.NewInt(1)
    if n%2 != 0 {
        s.Neg(s)
    }
    t.Sub(t, s)
    return t.Div(t, big.NewInt(3))
}
 
func jacobsthalLucas(n uint) *big.Int {
    t := big.NewInt(1)
    t.Lsh(t, n)
    a := big.NewInt(1)
    if n%2 != 0 {
        a.Neg(a)
    }
    return t.Add(t, a)
}
 
func main() {
    jac := make([]*big.Int, 30)
    fmt.Println(""First 30 Jacobsthal numbers:"")
    for i := uint(0); i < 30; i++ {
        jac[i] = jacobsthal(i)
        fmt.Printf(""%9d "", jac[i])
        if (i+1)%5 == 0 {
            fmt.Println()
        }
    }
 
    fmt.Println(""\nFirst 30 Jacobsthal-Lucas numbers:"")
    for i := uint(0); i < 30; i++ {
        fmt.Printf(""%9d "", jacobsthalLucas(i))
        if (i+1)%5 == 0 {
            fmt.Println()
        }
    }
 
    fmt.Println(""\nFirst 20 Jacobsthal oblong numbers:"")
    for i := uint(0); i < 20; i++ {
        t := big.NewInt(0)
        fmt.Printf(""%11d "", t.Mul(jac[i], jac[i+1]))
        if (i+1)%5 == 0 {
            fmt.Println()
        }
    }
 
    fmt.Println(""\nFirst 20 Jacobsthal primes:"")
    for n, count := uint(0), 0; count < 20; n++ {
        j := jacobsthal(n)
        if j.ProbablyPrime(10) {
            fmt.Println(j)
            count++
        }
    }
}",1357,65
44075,http://rosettacode.org/wiki/Inverted_syntax,Inverted syntax,"Inverted syntax with conditional expressions

In traditional syntax conditional expressions are usually shown before the action within a statement or code block:

 IF raining=true THEN needumbrella=true 
In inverted syntax, the action is listed before the conditional expression in the statement or code block:

 needumbrella=true IF raining=true 
Inverted syntax with assignment

In traditional syntax, assignments are usually expressed with the variable appearing before the expression:

 a = 6
In inverted syntax, the expression appears before the variable:

 6 = a
Task

The task is to demonstrate support for inverted syntax forms within the language by showing both the traditional and inverted forms.
",#Go,Go,"package main
 
import ""fmt""
 
type ibool bool
 
const itrue ibool = true
 
func (ib ibool) iif(cond bool) bool {
    if cond {
        return bool(ib)
    }
    return bool(!ib)
}
 
func main() {
    var needUmbrella bool
    raining := true
 
    // normal syntax
    if raining {
        needUmbrella = true
    }
    fmt.Printf(""Is it raining? %t. Do I need an umbrella? %t\n"", raining, needUmbrella)
 
    // inverted syntax
    raining = false
    needUmbrella = itrue.iif(raining)
    fmt.Printf(""Is it raining? %t. Do I need an umbrella? %t\n"", raining, needUmbrella)
}",576,30
44173,http://rosettacode.org/wiki/Jaro_similarity,Jaro similarity,"The Jaro distance is a measure of edit distance between two strings; its inverse, called the Jaro similarity, is a measure of two strings' similarity: the higher the value, the more similar the strings are. The score is normalized such that   0   equates to no similarities and   1   is an exact match.



Definition
The Jaro similarity   




d

j




{\displaystyle d_{j}}

   of two given strings   




s

1




{\displaystyle s_{1}}

   and   




s

2




{\displaystyle s_{2}}

   is

 




d

j


=

{




0



if 

m
=
0






1
3



(


m


|


s

1



|




+


m


|


s

2



|




+



m
−
t

m


)




otherwise









{\displaystyle d_{j}=\left\{{\begin{array}{l l}0&{\text{if }}m=0\\{\frac {1}{3}}\left({\frac {m}{|s_{1}|}}+{\frac {m}{|s_{2}|}}+{\frac {m-t}{m}}\right)&{\text{otherwise}}\end{array}}\right.}


Where:

 



m


{\displaystyle m}

   is the number of matching characters;
 



t


{\displaystyle t}

   is half the number of transpositions.


Two characters from   




s

1




{\displaystyle s_{1}}

   and   




s

2




{\displaystyle s_{2}}

   respectively, are considered matching only if they are the same and not farther apart than   




⌊



max
(

|


s

1



|

,

|


s

2



|

)

2


⌋

−
1


{\displaystyle \left\lfloor {\frac {\max(|s_{1}|,|s_{2}|)}{2}}\right\rfloor -1}

 characters.

Each character of   




s

1




{\displaystyle s_{1}}

   is compared with all its matching characters in   




s

2




{\displaystyle s_{2}}

. Each difference in position is half a transposition; that is, the number of transpositions is half the number of characters which are common to the two strings but occupy different positions in each one.



Example
Given the strings   




s

1




{\displaystyle s_{1}}

   DWAYNE   and   




s

2




{\displaystyle s_{2}}

   DUANE   we find:

 



m
=
4


{\displaystyle m=4}


 




|


s

1



|

=
6


{\displaystyle |s_{1}|=6}


 




|


s

2



|

=
5


{\displaystyle |s_{2}|=5}


 



t
=
0


{\displaystyle t=0}




We find a Jaro score of:

 




d

j


=


1
3



(


4
6


+


4
5


+



4
−
0

4


)

=
0.822


{\displaystyle d_{j}={\frac {1}{3}}\left({\frac {4}{6}}+{\frac {4}{5}}+{\frac {4-0}{4}}\right)=0.822}




Task
Implement the Jaro algorithm and show the similarity scores for each of the following pairs:

 (""MARTHA"", ""MARHTA"")
 (""DIXON"", ""DICKSONX"")
 (""JELLYFISH"", ""SMELLYFISH"")


 See also
 Jaro–Winkler distance on Wikipedia.

",#Go,Go,"package main
 
import ""fmt""
 
func jaro(str1, str2 string) float64 {
    if len(str1) == 0 && len(str2) == 0 {
        return 1
    }
    if len(str1) == 0 || len(str2) == 0 {
        return 0
    }
    match_distance := len(str1)
    if len(str2) > match_distance {
        match_distance = len(str2)
    }
    match_distance = match_distance/2 - 1
    str1_matches := make([]bool, len(str1))
    str2_matches := make([]bool, len(str2))
    matches := 0.
    transpositions := 0.
    for i := range str1 {
        start := i - match_distance
        if start < 0 {
            start = 0
        }
        end := i + match_distance + 1
        if end > len(str2) {
            end = len(str2)
        }
        for k := start; k < end; k++ {
            if str2_matches[k] {
                continue
            }
            if str1[i] != str2[k] {
                continue
            }
            str1_matches[i] = true
            str2_matches[k] = true
            matches++
            break
        }
    }
    if matches == 0 {
        return 0
    }
    k := 0
    for i := range str1 {
        if !str1_matches[i] {
            continue
        }
        for !str2_matches[k] {
            k++
        }
        if str1[i] != str2[k] {
            transpositions++
        }
        k++
    }
    transpositions /= 2
    return (matches/float64(len(str1)) +
        matches/float64(len(str2)) +
        (matches-transpositions)/matches) / 3
}
 
func main() {
    fmt.Printf(""%f\n"", jaro(""MARTHA"", ""MARHTA""))
    fmt.Printf(""%f\n"", jaro(""DIXON"", ""DICKSONX""))
    fmt.Printf(""%f\n"", jaro(""JELLYFISH"", ""SMELLYFISH""))
}",1626,69
44220,http://rosettacode.org/wiki/Iterated_digits_squaring,Iterated digits squaring,"If you add the square of the digits of a Natural number (an integer bigger than zero), you always end with either 1 or 89:

15 -> 26 -> 40 -> 16 -> 37 -> 58 -> 89
7 -> 49 -> 97 -> 130 -> 10 -> 1
An example in Python:

>>> step = lambda x: sum(int(d) ** 2 for d in str(x))
>>> iterate = lambda x: x if x in [1, 89] else iterate(step(x))
>>> [iterate(x) for x in xrange(1, 20)]
[1, 89, 89, 89, 89, 89, 1, 89, 89, 1, 89, 89, 1, 89, 89, 89, 89, 89, 1]


Task

 Count how many number chains for integers 1 <= n < 100_000_000 end with a value 89.
Or, for much less credit - (showing that your algorithm and/or language is slow):

 Count how many number chains for integers 1 <= n < 1_000_000 end with a value 89.
This problem derives from the Project Euler problem 92.

For a quick algorithm for this task see the talk page



Related tasks

 Combinations with repetitions
 Digital root
 Digital root/Multiplicative digital root

",#Go,Go,"package main
 
import (
	""fmt""
)
 
func main() {
	var d, n, o, u, u89 int64
 
	for n = 1; n < 100000000; n++ {
		o = n
		for {
			u = 0
			for {
				d = o%10
				o = (o - d) / 10
				u += d*d
				if o == 0 {
					break 
				}
			}
			if u == 89 || u == 1 {
				if u == 89 { u89++ }
				break
			}
			o = u
		}
	}
	fmt.Println(u89)
}",332,30
44267,http://rosettacode.org/wiki/Intersecting_number_wheels,Intersecting number wheels,"A number wheel has:

 A name which is an uppercase letter.
 A set of ordered values which are either numbers or names.

A number is generated/yielded from a named wheel by:

1. Starting at the first value of the named wheel and advancing through subsequent values and wrapping around to the first value to form a ""wheel"":
1.a If the value is a number, yield it.
1.b If the value is a name, yield the next value from the named wheel
1.c Advance the position of this wheel.
Given the wheel

 A: 1 2 3
the number 1 is first generated, then 2, then 3, 1, 2, 3, 1, ...

Note: When more than one wheel is defined as a set of intersecting wheels then the
first named wheel is assumed to be the one that values are generated from.

Examples

Given the wheels:

   A: 1 B 2
   B: 3 4

The series of numbers generated starts:

   1, 3, 2, 1, 4, 2, 1, 3, 2, 1, 4, 2, 1, 3, 2...

The intersections of number wheels can be more complex, (and might loop forever),
and wheels may be multiply connected. 


Note: If a named wheel is referenced more than
once by one or many other wheels, then there is only one position of the wheel
that is advanced by each and all references to it.

E.g.

 A:  1 D D
 D:  6 7 8
 Generates:
   1 6 7 1 8 6 1 7 8 1 6 7 1 8 6 1 7 8 1 6 ...    

Task

Generate and show the first twenty terms of the sequence of numbers generated
from these groups:

   Intersecting Number Wheel group:
     A:  1 2 3
   
   Intersecting Number Wheel group:
     A:  1 B 2
     B:  3 4
   
   Intersecting Number Wheel group:
     A:  1 D D
     D:  6 7 8
   
   Intersecting Number Wheel group:
     A:  1 B C
     B:  3 4
     C:  5 B

Show your output here, on this page.


",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
    ""strconv""
)
 
type wheel struct {
    next   int
    values []string
}
 
type wheelMap = map[string]wheel
 
func generate(wheels wheelMap, start string, maxCount int) {
    count := 0
    w := wheels[start]
    for {
        s := w.values[w.next]
        v, err := strconv.Atoi(s)
        w.next = (w.next + 1) % len(w.values)
        wheels[start] = w
        if err == nil {
            fmt.Printf(""%d "", v)
            count++
            if count == maxCount {
                fmt.Println(""...\n"")
                return
            }
        } else {
            for {
                w2 := wheels[s]
                ss := s
                s = w2.values[w2.next]
                w2.next = (w2.next + 1) % len(w2.values)
                wheels[ss] = w2
                v, err = strconv.Atoi(s)
                if err == nil {
                    fmt.Printf(""%d "", v)
                    count++
                    if count == maxCount {
                        fmt.Println(""...\n"")
                        return
                    }
                    break
                }
            }
        }
    }
}
 
func printWheels(wheels wheelMap) {
    var names []string
    for name := range wheels {
        names = append(names, name)
    }
    sort.Strings(names)
    fmt.Println(""Intersecting Number Wheel group:"")
    for _, name := range names {
        fmt.Printf(""  %s: %v\n"", name, wheels[name].values)
    }
    fmt.Print(""  Generates:\n    "")
}
 
func main() {
    wheelMaps := []wheelMap{
        {
            ""A"": {0, []string{""1"", ""2"", ""3""}},
        },
        {
            ""A"": {0, []string{""1"", ""B"", ""2""}},
            ""B"": {0, []string{""3"", ""4""}},
        },
        {
            ""A"": {0, []string{""1"", ""D"", ""D""}},
            ""D"": {0, []string{""6"", ""7"", ""8""}},
        },
        {
            ""A"": {0, []string{""1"", ""B"", ""C""}},
            ""B"": {0, []string{""3"", ""4""}},
            ""C"": {0, []string{""5"", ""B""}},
        },
    }
    for _, wheels := range wheelMaps {
        printWheels(wheels)
        generate(wheels, ""A"", 20)
    }
}",2117,89
44271,http://rosettacode.org/wiki/ISBN13_check_digit,ISBN13 check digit,"Task

Validate the check digit of an ISBN-13 code:

   Multiply every other digit by  3.
   Add these numbers and the other digits.
   Take the remainder of this number after division by  10.
   If it is  0,   the ISBN-13 check digit is correct.


Use the following codes for testing:

   978-1734314502       (good)
   978-1734314509         (bad)
   978-1788399081       (good)
   978-1788399083         (bad)


Show output here, on this page



See also

   for details:   13-digit ISBN method of validation.       (installs cookies.)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
    ""unicode/utf8""
)
 
func checkIsbn13(isbn string) bool {
    // remove any hyphens or spaces
    isbn = strings.ReplaceAll(strings.ReplaceAll(isbn, ""-"", """"), "" "", """")
    // check length == 13
    le := utf8.RuneCountInString(isbn)
    if le != 13 {
        return false
    }
    // check only contains digits and calculate weighted sum
    sum := int32(0)
    for i, c := range isbn {
        if c < '0' || c > '9' {
            return false
        }
        if i%2 == 0 {
            sum += c - '0'
        } else {
            sum += 3 * (c - '0')
        }
    }
    return sum%10 == 0
}
 
func main() {
    isbns := []string{""978-1734314502"", ""978-1734314509"", ""978-1788399081"", ""978-1788399083""}
    for _, isbn := range isbns {
        res := ""bad""
        if checkIsbn13(isbn) {
            res = ""good""
        }
        fmt.Printf(""%s: %s\n"", isbn, res)
    }
}",924,41
44279,http://rosettacode.org/wiki/Isqrt_(integer_square_root)_of_X,Isqrt (integer square root) of X,"Sometimes a function is needed to find the integer square root of   X,   where   X   can be a
real non─negative number.

Often   X   is actually a non─negative integer.

For the purposes of this task,   X   can be an integer or a real number,   but if it
simplifies things in your computer programming language,   assume it's an integer.



One of the most common uses of   Isqrt   is in the division of an integer by all factors   (or
primes)   up to the   
√ X     of that
integer,   either to find the factors of that integer,   or to determine primality.



An alternative method for finding the   Isqrt   of a number is to
calculate:        floor( sqrt(X) ) 

   where   sqrt    is the   square root   function for non─negative real numbers,   and
   where   floor   is the   floor   function for real numbers.


If the hardware supports the computation of (real) square roots,   the above method might be a faster method for
small numbers that don't have very many significant (decimal) digits.

However, floating point arithmetic is limited in the number of   (binary or decimal)   digits that it can support.



Pseudo─code using quadratic residue

For this task, the integer square root of a non─negative number will be computed using a version
of   quadratic residue,   which has the advantage that no   floating point   calculations are
used,   only integer arithmetic.

Furthermore, the two divisions can be performed by bit shifting,   and the one multiplication can also be be performed by bit shifting or additions.

The disadvantage is the limitation of the size of the largest integer that a particular computer programming language can support.



Pseudo─code of a procedure for finding the integer square root of   X       (all variables are integers):

         q ◄── 1                                /*initialize  Q  to unity.  */
                                  /*find a power of 4 that's greater than X.*/
                  perform  while q <= x         /*perform while  Q <= X.    */
                  q ◄── q * 4                   /*multiply  Q  by  four.    */
                  end  /*perform*/
                                                /*Q  is now greater than  X.*/
         z ◄── x                                /*set  Z  to the value of X.*/
         r ◄── 0                                /*initialize  R  to zero.   */
                  perform  while q > 1          /*perform while  Q > unity. */
                  q ◄── q ÷ 4                   /*integer divide by  four.  */
                  t ◄── z - r - q               /*compute value of  T.      */
                  r ◄── r ÷ 2                   /*integer divide by  two.   */
                  if t >= 0  then do            
                                  z ◄── t       /*set  Z  to value of  T.   */
                                  r ◄── r + q   /*compute new value of  R.  */
                                  end
                  end  /*perform*/
                                                /*R  is now the  Isqrt(X).  */

         /* Sidenote: Also, Z is now the remainder after square root (i.e.  */
         /*           R^2 + Z = X, so if Z = 0 then X is a perfect square). */

Another version for the (above)   1st   perform   is:

                  perform  until q > X          /*perform until  Q > X.     */
                  q ◄── q * 4                   /*multiply  Q  by  four.    */
                  end  /*perform*/



Integer square roots of some values:

Isqrt( 0)  is   0               Isqrt(60)  is  7                Isqrt( 99)  is   9
Isqrt( 1)  is   1               Isqrt(61)  is  7                Isqrt(100)  is  10
Isqrt( 2)  is   1               Isqrt(62)  is  7                Isqrt(102)  is  10
Isqrt( 3)  is   1               Isqrt(63)  is  7
Isqrt( 4)  is   2               Isqrt(64)  is  8                Isqet(120)  is  10
Isqrt( 5)  is   2               Isqrt(65)  is  8                Isqrt(121)  is  11
Isqrt( 6)  is   2               Isqrt(66)  is  8                Isqrt(122)  is  11
Isqrt( 7)  is   2               Isqrt(67)  is  8
Isqrt( 8)  is   2               Isqrt(68)  is  8                Isqrt(143)  is  11
Isqrt( 9)  is   3               Isqrt(69)  is  8                Isqrt(144)  is  12
Isqrt(10)  is   3               Isqrt(70)  is  8                Isqrt(145)  is  12



Task

Compute and show all output here   (on this page)   for:

   the Isqrt of the     integers     from     0 ───► 65    (inclusive), shown in a horizontal format.
   the Isqrt of the   odd powers  from   71 ───► 773   (inclusive), shown in a   vertical   format.
   use commas in the displaying of larger numbers.


You can show more numbers for the 2nd requirement if the displays fits on one screen on Rosetta Code.

If your computer programming language only supports smaller integers,   show what you can.



Related tasks

   sequence of non-squares
   integer roots
   square root by hand

",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math/big""
)
 
var zero = big.NewInt(0)
var one = big.NewInt(1)
 
func isqrt(x *big.Int) *big.Int {
    if x.Cmp(zero) < 0 {
        log.Fatal(""Argument cannot be negative."")
    }
    q := big.NewInt(1)
    for q.Cmp(x) <= 0 {
        q.Lsh(q, 2)
    }
    z := new(big.Int).Set(x)
    r := big.NewInt(0)
    for q.Cmp(one) > 0 {
        q.Rsh(q, 2)
        t := new(big.Int)
        t.Add(t, z)
        t.Sub(t, r)
        t.Sub(t, q)
        r.Rsh(r, 1)
        if t.Cmp(zero) >= 0 {
            z.Set(t)
            r.Add(r, q)
        }
    }
    return r
}
 
func commatize(s string) string {
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    return s
}
 
func main() {
    fmt.Println(""The integer square roots of integers from 0 to 65 are:"")
    for i := int64(0); i <= 65; i++ {
        fmt.Printf(""%d "", isqrt(big.NewInt(i)))
    }
    fmt.Println()
    fmt.Println(""\nThe integer square roots of powers of 7 from 7^1 up to 7^73 are:\n"")
    fmt.Println(""power                                    7 ^ power                                                 integer square root"")
    fmt.Println(""----- --------------------------------------------------------------------------------- -----------------------------------------"")
    pow7 := big.NewInt(7)
    bi49 := big.NewInt(49)
    for i := 1; i <= 73; i += 2 {
        fmt.Printf(""%2d %84s %41s\n"", i, commatize(pow7.String()), commatize(isqrt(pow7).String()))
        pow7.Mul(pow7, bi49)
    }
}",1554,60
44351,http://rosettacode.org/wiki/Interactive_programming_(repl),Interactive programming (repl),"Many language implementations come with an interactive mode.

This is a command-line interpreter that reads lines from the user and evaluates these lines as statements or expressions.

An interactive mode may also be known as a command mode,   a read-eval-print loop (REPL),   or a shell.



Task

Show how to start this mode.

Then, as a small example of its use, interactively create a function of two strings and a separator that returns the strings separated by two concatenated instances of the separator   (the 3rd argument).



Example

             f('Rosetta',  'Code',  ':')   

should return

             'Rosetta::Code'               



Note

This task is   not   about creating your own interactive mode.



",#Go,Go,"package main
 
import ""fmt""
 
func f(s1, s2, sep string) string {
	return s1 + sep + sep + s2
}
 
func main() {
	fmt.Println(f(""Rosetta"", ""Code"", "":""))
}",153,11
44368,http://rosettacode.org/wiki/Josephus_problem,Josephus problem,"Josephus problem is a math puzzle with a grim description: 



n


{\displaystyle n}

 prisoners are standing on a circle, sequentially numbered from 



0


{\displaystyle 0}

 to 



n
−
1


{\displaystyle n-1}

.

An executioner walks along the circle, starting from prisoner 



0


{\displaystyle 0}

,
removing every 



k


{\displaystyle k}

-th prisoner and killing him.

As the process goes on, the circle becomes smaller and smaller, until only one prisoner remains, who is then freed. >

For example, if there are 



n
=
5


{\displaystyle n=5}

 prisoners and 



k
=
2


{\displaystyle k=2}

, the order the prisoners are killed in (let's call it the ""killing sequence"") will be 1, 3, 0, and 4, and the survivor will be #2.



Task

Given any   



n
,
k
>
0


{\displaystyle n,k>0}

,   find out which prisoner will be the final survivor.

In one such incident, there were 41 prisoners and every 3rd prisoner was being killed   (



k
=
3


{\displaystyle k=3}

).

Among them was a clever chap name Josephus who worked out the problem, stood at the surviving position, and lived on to tell the tale.

Which number was he?



Extra

The captors may be especially kind and let 



m


{\displaystyle m}

 survivors free,

and Josephus might just have   



m
−
1


{\displaystyle m-1}

   friends to save.

Provide a way to calculate which prisoner is at any given position on the killing sequence.



Notes

 You can always play the executioner and follow the procedure exactly as described, walking around the circle, counting (and cutting off) heads along the way. This would yield the complete killing sequence and answer the above questions, with a complexity of probably 



O
(
k
n
)


{\displaystyle O(kn)}

. However, individually it takes no more than 



O
(
m
)


{\displaystyle O(m)}

 to find out which prisoner is the 



m


{\displaystyle m}

-th to die.
 If it's more convenient, you can number prisoners from   



1


{\displaystyle 1}

 to 



n


{\displaystyle n}

   instead.   If you choose to do so, please state it clearly.
 An alternative description has the people committing assisted suicide instead of being executed, and the last person simply walks away. These details are not relevant, at least not mathematically.

",#Go,Go,"package main
 
import ""fmt""
 
// basic task function
func finalSurvivor(n, k int) int {
    // argument validation omitted
    circle := make([]int, n)
    for i := range circle {
        circle[i] = i
    }
    k--
    exPos := 0
    for len(circle) > 1 {
        exPos = (exPos + k) % len(circle)
        circle = append(circle[:exPos], circle[exPos+1:]...)
    }
    return circle[0]
}
 
// extra
func position(n, k, pos int) int {
    // argument validation omitted
    circle := make([]int, n)
    for i := range circle {
        circle[i] = i
    }
    k--
    exPos := 0
    for len(circle) > 1 {
        exPos = (exPos + k) % len(circle)
        if pos == 0 {
            return circle[exPos]
        }
        pos--
        circle = append(circle[:exPos], circle[exPos+1:]...)
    }
    return circle[0]
}
 
func main() {
    // show basic task function on given test case
    fmt.Println(finalSurvivor(41, 3))
    // show extra function on all positions of given test case
    fmt.Println(""Position  Prisoner"")
    for i := 0; i < 41; i++ {
        fmt.Printf(""%5d%10d\n"", i, position(41, 3, i))
    }
}",1113,49
44412,http://rosettacode.org/wiki/Introspection,Introspection,"Task

 verify the version/revision of your currently running (compiler/interpreter/byte-compiler/runtime environment/whatever your language uses) and exit if it is too old.
 check whether the variable ""bloop"" exists and whether the math-function ""abs()"" is available and if yes compute abs(bloop).


Extra credit

 Report the number of integer variables in global scope, and their sum.

",#Go,Go,"package main
 
import (
    ""debug/elf""
    ""debug/gosym""
    ""fmt""
    ""log""
    ""math""
    ""os""
    ""runtime""
)
 
var bloop = -3.4
 
func main() {
    fmt.Println(""task 1: verify version"")
    fmt.Println(""   program compiled with"", runtime.Version())
 
    fmt.Println(""task 2: check for presence of variable and function"")
    // inspect ELF symbol table
    f, err := elf.Open(os.Args[0])
    if err != nil {
        log.Fatal(err)
    }
    defer f.Close()
    symSection := f.Section("".gosymtab"")
    lineSection := f.Section("".gopclntab"")
    textSection := f.Section("".text"")
    if symSection == nil || lineSection == nil || textSection == nil {
        log.Fatal(""symbolic information not found"")
    }
    symData, err := symSection.Data()
    if err != nil {
        log.Fatal(err)
    }
    lineData, err := lineSection.Data()
    if err != nil {
        log.Fatal(err)
    }
    table, err := gosym.NewTable(symData,
        gosym.NewLineTable(lineData, textSection.Addr))
    if err != nil {
        log.Fatal(""  "", err)
    }
    var foundBloop, foundFabs bool
    for _, s := range table.Syms {
        if s.Name == ""main.bloop"" {
            foundBloop = true
            fmt.Println(""   bloop symbol table entry:"", s)
        } else if s.Name == ""math.Abs"" {
            foundFabs = true
            fmt.Println(""   abs symbol table entry:"", s)
        }
    }
    if foundBloop && foundFabs {
        fmt.Println(""   bloop:     "", bloop)
        fmt.Println(""   abs(bloop): "", math.Abs(bloop))
    }
}",1522,59
44510,http://rosettacode.org/wiki/Integer_overflow,Integer overflow,"Some languages support one or more integer types of the underlying processor.

This integer types have fixed size;   usually   8-bit,   16-bit,   32-bit,   or   64-bit.

The integers supported by such a type can be   signed   or   unsigned.

Arithmetic for machine level integers can often be done by single CPU instructions.

This allows high performance and is the main reason to support machine level integers.



Definition

An integer overflow happens when the result of a computation does not fit into the fixed size integer.
The result can be too small or too big to be representable in the fixed size integer.



Task

When a language has fixed size integer types, create a program that
does arithmetic computations for the fixed size integers of the language.

These computations must be done such that the result would overflow.

The program should demonstrate what the following expressions do.



For 32-bit signed integers:



Expression

Result that does not fit into a 32-bit signed integer


 -(-2147483647-1)

 2147483648


 2000000000 + 2000000000

 4000000000


 -2147483647 - 2147483647

 -4294967294


 46341 * 46341

 2147488281


 (-2147483647-1) / -1

 2147483648

For 64-bit signed integers:



Expression

Result that does not fit into a 64-bit signed integer


 -(-9223372036854775807-1)

 9223372036854775808


 5000000000000000000+5000000000000000000

 10000000000000000000


 -9223372036854775807 - 9223372036854775807

 -18446744073709551614


 3037000500 * 3037000500

 9223372037000250000


 (-9223372036854775807-1) / -1

 9223372036854775808

For 32-bit unsigned integers:



Expression

Result that does not fit into a 32-bit unsigned integer


 -4294967295

 -4294967295


 3000000000 + 3000000000

 6000000000


 2147483647 - 4294967295

 -2147483648


 65537 * 65537

 4295098369

For 64-bit unsigned integers:



Expression

Result that does not fit into a 64-bit unsigned integer


 -18446744073709551615

 -18446744073709551615


 10000000000000000000 + 10000000000000000000

 20000000000000000000


 9223372036854775807 - 18446744073709551615

 -9223372036854775808


 4294967296 * 4294967296

 18446744073709551616



Notes

   When the integer overflow does trigger an exception show how the exception is caught.
   When the integer overflow produces some value,   print it.
   It should be explicitly noted when an integer overflow is not recognized,   the program continues with wrong results.
   This should be done for signed and unsigned integers of various sizes supported by the computer programming language.
   When a language has no fixed size integer type,   or when no integer overflow can occur for other reasons,   this should be noted.
   It is okay to mention,   when a language supports unlimited precision integers,   but this task is NOT the place to demonstrate the 
  capabilities of unlimited precision integers.

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
	// Go's builtin integer types are:
	//    int,  int8,  int16,  int32,  int64
	//   uint, uint8, uint16, uint32, uint64
	//   byte, rune, uintptr
	//
	// int is either 32 or 64 bit, depending on the system
	// uintptr is large enough to hold the bit pattern of any pointer
	// byte is 8 bits like int8
	// rune is 32 bits like int32
	//
	// Overflow and underflow is silent. The math package defines a number
	// of constants that can be helpfull, e.g.:
	//    math.MaxInt64  = 1<<63 - 1
	//    math.MinInt64  = -1 << 63
	//    math.MaxUint64 = 1<<64 - 1
	//
	// The math/big package implements multi-precision
	// arithmetic (big numbers).
	//
	// In all cases assignment from one type to another requires
	// an explicit cast, even if the types are otherwise identical
	// (e.g. rune and int32 or int and either int32 or int64).
	// Casts silently truncate if required.
	//
	// Invalid:
	//    var i int  = int32(0)
	//    var r rune = int32(0)
	//    var b byte = int8(0)
	//
	// Valid:
	var i64 int64 = 42
	var i32 int32 = int32(i64)
	var i16 int16 = int16(i64)
	var i8 int8 = int8(i16)
	var i int = int(i8)
	var r rune = rune(i)
	var b byte = byte(r)
	var u64 uint64 = uint64(b)
	var u32 uint32
 
	//const c int = -(-2147483647 - 1) // Compiler error on 32 bit systems, ok on 64 bit
	const c = -(-2147483647 - 1) // Allowed even on 32 bit systems, c is untyped
	i64 = c
	//i32 = c                          // Compiler error
	//i32 = -(-2147483647 - 1)         // Compiler error
	i32 = -2147483647
	i32 = -(-i32 - 1)
	fmt.Println(""32 bit signed integers"")
	fmt.Printf(""  -(-2147483647 - 1) = %d, got %d\n"", i64, i32)
 
	i64 = 2000000000 + 2000000000
	//i32 = 2000000000 + 2000000000    // Compiler error
	i32 = 2000000000
	i32 = i32 + i32
	fmt.Printf(""  2000000000 + 2000000000 = %d, got %d\n"", i64, i32)
	i64 = -2147483647 - 2147483647
	i32 = 2147483647
	i32 = -i32 - i32
	fmt.Printf(""  -2147483647 - 2147483647 = %d, got %d\n"", i64, i32)
	i64 = 46341 * 46341
	i32 = 46341
	i32 = i32 * i32
	fmt.Printf(""  46341 * 46341 = %d, got %d\n"", i64, i32)
	i64 = (-2147483647 - 1) / -1
	i32 = -2147483647
	i32 = (i32 - 1) / -1
	fmt.Printf(""  (-2147483647-1) / -1 = %d, got %d\n"", i64, i32)
 
	fmt.Println(""\n64 bit signed integers"")
	i64 = -9223372036854775807
	fmt.Printf(""  -(%d - 1): %d\n"", i64, -(i64 - 1))
	i64 = 5000000000000000000
	fmt.Printf(""  %d + %d: %d\n"", i64, i64, i64+i64)
	i64 = 9223372036854775807
	fmt.Printf(""  -%d - %d: %d\n"", i64, i64, -i64-i64)
	i64 = 3037000500
	fmt.Printf(""  %d * %d: %d\n"", i64, i64, i64*i64)
	i64 = -9223372036854775807
	fmt.Printf(""  (%d - 1) / -1: %d\n"", i64, (i64-1)/-1)
 
	fmt.Println(""\n32 bit unsigned integers:"")
	//u32 = -4294967295 // Compiler error
	u32 = 4294967295
	fmt.Printf(""  -%d: %d\n"", u32, -u32)
	u32 = 3000000000
	fmt.Printf(""  %d + %d: %d\n"", u32, u32, u32+u32)
	a := uint32(2147483647)
	u32 = 4294967295
	fmt.Printf(""  %d - %d: %d\n"", a, u32, a-u32)
	u32 = 65537
	fmt.Printf(""  %d * %d: %d\n"", u32, u32, u32*u32)
 
	fmt.Println(""\n64 bit unsigned integers:"")
	u64 = 18446744073709551615
	fmt.Printf(""  -%d: %d\n"", u64, -u64)
	u64 = 10000000000000000000
	fmt.Printf(""  %d + %d: %d\n"", u64, u64, u64+u64)
	aa := uint64(9223372036854775807)
	u64 = 18446744073709551615
	fmt.Printf(""  %d - %d: %d\n"", aa, u64, aa-u64)
	u64 = 4294967296
	fmt.Printf(""  %d * %d: %d\n"", u64, u64, u64*u64)
}",3387,108
44532,http://rosettacode.org/wiki/Inheritance/Multiple,Inheritance/Multiple,"Multiple inheritance allows to specify that one  class is a subclass of several other classes.

Some languages allow multiple inheritance for arbitrary classes,   others restrict it to interfaces,   some don't allow it at all.



Task

Write two classes (or interfaces) Camera and MobilePhone,   then write a class CameraPhone which is both a Camera and a MobilePhone.

There is no need to implement any functions for those classes.



",#Go,Go,"// Example of composition of anonymous structs
package main
 
import ""fmt""
 
// Two ordinary structs
type camera struct {
    optics, sensor string
}
 
type mobilePhone struct {
    sim, firmware string
}
 
// Fields are anonymous because only the type is listed.
// Also called an embedded field.
type cameraPhone struct {
    camera
    mobilePhone
}
 
func main() {
    // Struct literals must still reflect the nested structure
    htc := cameraPhone{camera{optics: ""zoom""}, mobilePhone{firmware: ""3.14""}}
 
    // But fields of anonymous structs can be referenced without qualification.
    // This provides some effect of the two parent structs being merged, as
    // with multiple inheritance in some other programming languages.
    htc.sim = ""XYZ""
    fmt.Println(htc)
}",780,31
44542,http://rosettacode.org/wiki/Inverted_index,Inverted index,"An Inverted Index is a data structure used to create full text search.



Task

Given a set of text files, implement a program to create an inverted index.

Also create a user interface to do a search using that inverted index which returns a list of files that contain the query term / terms.

The search index can be in memory.



",#Go,Go,"package main
 
import (
    ""bufio""
    ""bytes""
    ""errors""
    ""fmt""
    ""io""
    ""os""
)
 
// inverted index representation
var index map[string][]int // ints index into indexed
var indexed []doc
 
type doc struct {
    file  string
    title string
}
 
func main() {
    // initialize representation
    index = make(map[string][]int)
 
    // build index
    if err := indexDir(""docs""); err != nil {
        fmt.Println(err)
        return
    }
 
    // run user interface
    ui()
}
 
func indexDir(dir string) error {
    df, err := os.Open(dir)
    if err != nil {
        return err
    }
    fis, err := df.Readdir(-1)
    if err != nil {
        return err
    }
    if len(fis) == 0 {
        return errors.New(fmt.Sprintf(""no files in %s"", dir))
    }
    indexed := 0
    for _, fi := range fis {
        if !fi.IsDir() {
            if indexFile(dir + ""/"" + fi.Name()) {
                indexed++
            }
        }
    }
    return nil
}
 
func indexFile(fn string) bool {
    f, err := os.Open(fn)
    if err != nil {
        fmt.Println(err)
        return false // only false return
    }
 
    // register new file
    x := len(indexed)
    indexed = append(indexed, doc{fn, fn})
    pdoc := &indexed[x]
 
    // scan lines
    r := bufio.NewReader(f)
    lines := 0
    for {
        b, isPrefix, err := r.ReadLine()
        switch {
        case err == io.EOF:
            return true
        case err != nil:
            fmt.Println(err)
            return true
        case isPrefix:
            fmt.Printf(""%s: unexpected long line\n"", fn)
            return true
        case lines < 20 && bytes.HasPrefix(b, []byte(""Title:"")):
            // in a real program you would write code
            // to skip the Gutenberg document header
            // and not index it.
            pdoc.title = string(b[7:])
        }
        // index line of text in b
        // again, in a real program you would write a much
        // nicer word splitter.
    wordLoop:
        for _, bword := range bytes.Fields(b) {
            bword := bytes.Trim(bword, "".,-~?!\""'`;:()<>[]{}\\|/=_+*&^%$#@"")
            if len(bword) > 0 {
                word := string(bword)
                dl := index[word]
                for _, d := range dl {
                    if d == x {
                        continue wordLoop
                    }
                }
                index[word] = append(dl, x)
            }
        }
    }
    return true
}
 
func ui() {
    fmt.Println(len(index), ""words indexed in"", len(indexed), ""files"")
    fmt.Println(""enter single words to search for"")
    fmt.Println(""enter a blank line when done"")
    var word string
    for {
        fmt.Print(""search word: "")
        wc, _ := fmt.Scanln(&word)
        if wc == 0 {
            return
        }
        switch dl := index[word]; len(dl) {
        case 0:
            fmt.Println(""no match"")
        case 1:
            fmt.Println(""one match:"")
            fmt.Println(""   "", indexed[dl[0]].file, indexed[dl[0]].title)
        default:
            fmt.Println(len(dl), ""matches:"")
            for _, d := range dl {
                fmt.Println(""   "", indexed[d].file, indexed[d].title)
            }
        }
    }
}",3219,135
44636,http://rosettacode.org/wiki/Increasing_gaps_between_consecutive_Niven_numbers,Increasing gaps between consecutive Niven numbers,"Note:   Niven   numbers are also called   Harshad   numbers.

   They are also called    multidigital   numbers.

Niven numbers are positive integers which are evenly divisible by the sum of its
digits   (expressed in base ten).

Evenly divisible   means   divisible with no remainder.



Task

   find the gap (difference) of a Niven number from the previous Niven number
   if the gap is   larger   than the (highest) previous gap,   then:
   show the index (occurrence) of the gap     (the 1st gap is   1)
   show the index of the Niven number that starts the gap     (1st Niven number is   1,   33rd Niven number is   100)
   show the Niven number that starts the gap
   show all numbers with comma separators where appropriate   (optional)
   I.E.:   the gap size of   60   starts at the   33,494th   Niven number which is Niven number   297,864
   show all increasing gaps up to the   ten millionth   (10,000,000th)   Niven number
   (optional)   show all gaps up to whatever limit is feasible/practical/realistic/reasonable/sensible/viable on your computer
   show all output here, on this page


Related task

   Harshad or Niven series.


Also see

   Journal of Integer Sequences, Vol. 6 (2004), Article 03.2.5, Large and Small Gaps Between Consecutive Niven Numbers.
   (PDF) version of the (above) article by Doyon.

",#Go,Go,"package main
 
import ""fmt""
 
type is func() uint64
 
func newSum() is {
    var ms is
    ms = func() uint64 {
        ms = newSum()
        return ms()
    }
    var msd, d uint64
    return func() uint64 {
        if d < 9 {
            d++
        } else {
            d = 0
            msd = ms()
        }
        return msd + d
    }
}
 
func newHarshard() is {
    i := uint64(0)
    sum := newSum()
    return func() uint64 {
        for i++; i%sum() != 0; i++ {
        }
        return i
    }
}
 
func commatize(n uint64) string {
    s := fmt.Sprintf(""%d"", n)
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    return s
}
 
func main() {
    fmt.Println(""Gap    Index of gap   Starting Niven"")
    fmt.Println(""===   =============   =============="")
    h := newHarshard()
    pg := uint64(0) // previous highest gap
    pn := h()       // previous Niven number
    for i, n := uint64(1), h(); n <= 20e9; i, n = i+1, h() {
        g := n - pn
        if g > pg {
            fmt.Printf(""%3d   %13s   %14s\n"", g, commatize(i), commatize(pn))
            pg = g
        }
        pn = n
    }
}",1152,58
44685,http://rosettacode.org/wiki/Idiomatically_determine_all_the_characters_that_can_be_used_for_symbols,Idiomatically determine all the characters that can be used for symbols,"Idiomatically determine all the characters that can be used for symbols.
The word symbols is meant things like names of variables, procedures (i.e., named fragments of programs, functions, subroutines, routines), statement labels, events or conditions, and in general, anything a computer programmer can choose to name, but not being restricted to this list. Identifiers might be another name for symbols.

The method should find the characters regardless of the hardware architecture that is being used (ASCII, EBCDIC, or other).

Task requirements
Display the set of all the characters that can be used for symbols which can be used (allowed) by the computer program.
You may want to mention what hardware architecture is being used, and if applicable, the operating system.

Note that most languages have additional restrictions on what characters can't be used for the first character of a variable or statement label, for instance. These type of restrictions needn't be addressed here (but can be mentioned).

See also
 Idiomatically determine all the lowercase and uppercase letters.

",#Go,Go,"package main
 
import (
	""fmt""
	""go/ast""
	""go/parser""
	""strings""
	""unicode""
)
 
func isValidIdentifier(identifier string) bool {
	node, err := parser.ParseExpr(identifier)
	if err != nil {
		return false
	}
	ident, ok := node.(*ast.Ident)
	return ok && ident.Name == identifier
}
 
type runeRanges struct {
	ranges   []string
	hasStart bool
	start    rune
	end      rune
}
 
func (r *runeRanges) add(cp rune) {
	if !r.hasStart {
		r.hasStart = true
		r.start = cp
		r.end = cp
		return
	}
 
	if cp == r.end+1 {
		r.end = cp
		return
	}
 
	r.writeTo(&r.ranges)
 
	r.start = cp
	r.end = cp
}
 
func (r *runeRanges) writeTo(ranges *[]string) {
	if r.hasStart {
		if r.start == r.end {
			*ranges = append(*ranges, fmt.Sprintf(""%U"", r.end))
		} else {
			*ranges = append(*ranges, fmt.Sprintf(""%U-%U"", r.start, r.end))
		}
	}
}
 
func (r *runeRanges) String() string {
	ranges := r.ranges
	r.writeTo(&ranges)
	return strings.Join(ranges, "", "")
}
 
func main() {
	var validFirst runeRanges
	var validFollow runeRanges
	var validOnlyFollow runeRanges
 
	for r := rune(0); r <= unicode.MaxRune; r++ {
		first := isValidIdentifier(string([]rune{r}))
		follow := isValidIdentifier(string([]rune{'_', r}))
		if first {
			validFirst.add(r)
		}
		if follow {
			validFollow.add(r)
		}
		if follow && !first {
			validOnlyFollow.add(r)
		}
	}
 
	_, _ = fmt.Println(""Valid first:"", validFirst.String())
	_, _ = fmt.Println(""Valid follow:"", validFollow.String())
	_, _ = fmt.Println(""Only follow:"", validOnlyFollow.String())
}",1512,84
44688,http://rosettacode.org/wiki/Index_finite_lists_of_positive_integers,Index finite lists of positive integers,"It is known that the set of finite lists of positive integers is    countable.

This means that there exists a subset of natural integers which can be mapped to the set of finite lists of positive integers.



Task

Implement such a mapping:

   write a function     rank     which assigns an integer to any finite, arbitrarily long list of arbitrary large positive integers.
   write a function   unrank   which is the   rank    inverse function.


Demonstrate your solution by:

   picking a random-length list of random positive integers
   turn it into an integer,   and 
   get the list back.


There are many ways to do this.   Feel free to choose any one you like.



Extra credit

Make the   rank   function as a    bijection   and show   unrank(n)   for   n   varying from   0   to   10.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func rank(l []uint) (r big.Int) {
    for _, n := range l {
        r.Lsh(&r, n+1)
        r.SetBit(&r, int(n), 1)
    }
    return
}
 
func unrank(n big.Int) (l []uint) {
    m := new(big.Int).Set(&n)
    for a := m.BitLen(); a > 0; {
        m.SetBit(m, a-1, 0)
        b := m.BitLen()
        l = append(l, uint(a-b-1))
        a = b
    }
    return
}
 
func main() {
    var b big.Int
    for i := 0; i <= 10; i++ {
        b.SetInt64(int64(i))
        u := unrank(b)
        r := rank(u)
        fmt.Println(i, u, &r)
    }
    b.SetString(""12345678901234567890"", 10)
    u := unrank(b)
    r := rank(u)
    fmt.Printf(""\n%v\n%d\n%d\n"", &b, u, &r)
}",708,39
44797,http://rosettacode.org/wiki/Inheritance/Single,Inheritance/Single," This task is about derived types;   for implementation inheritance, see Polymorphism.


Inheritance is an operation of type algebra that creates a new type from one or several parent types.

The obtained type is called derived type.

It inherits some of the properties of its parent types.

Usually inherited properties are:

   methods
   components
   parts of the representation


The  class of the new type is a   subclass   of the classes rooted in the parent types.

When all (in certain sense) properties of the parents are preserved by the derived type,   it is said to be a Liskov subtype.

When properties are preserved then the derived type is substitutable for its parents in all contexts.   Usually full substitutability is achievable only in some contexts.



Inheritance is

   single, when only one parent is allowed
    multiple, otherwise


Some single inheritance languages usually allow multiple inheritance for certain abstract types, interfaces in particular.

Inheritance can be considered as a relation parent-child.

Parent types are sometimes called supertype, the derived ones are subtype.   This relation is transitive and reflexive.

Types bound by the relation form a wp:Directed_acyclic_graph directed acyclic graph (ignoring reflexivity).

With single inheritance it becomes a tree.



Task

Show a tree of types which inherit from each other.

   At the top of the tree should be a class called   Animal. 
   The second level should have Dog and Cat. 
   Under   Dog   should be   Lab   and   Collie. 
   None of the classes need to have any functions,   the only thing they need to do is inherit from the specified superclasses 
   (overriding functions should be shown in Polymorphism). 


The tree should look like this:

                        Animal
                          /\
                         /  \
                        /    \
                      Dog    Cat
                      /\
                     /  \
                    /    \
                  Lab  Collie


",#Go,Go,"package main
 
type animal struct {
    alive bool
}
 
type dog struct {
    animal
    obedienceTrained bool
}
 
type cat struct {
    animal
    litterBoxTrained bool
}
 
type lab struct {
    dog
    color string
}
 
type collie struct {
    dog
    catchesFrisbee bool
}
 
func main() {
    var pet lab
    pet.alive = true
    pet.obedienceTrained = false
    pet.color = ""yellow""
}
 ",389,33
44986,http://rosettacode.org/wiki/Idiomatically_determine_all_the_lowercase_and_uppercase_letters,Idiomatically determine all the lowercase and uppercase letters,"
Idiomatically determine all the lowercase and uppercase letters   (of the Latin [English] alphabet)   being used currently by a computer programming language.
The method should find the letters regardless of the hardware architecture that is being used (ASCII, EBCDIC, or other).



Task requirements
Display the set of all:

   lowercase letters 
   uppercase letters

that can be used (allowed) by the computer program,


where   letter   is a member of the Latin (English) alphabet:     a ──► z     and     A ──► Z.



You may want to mention what hardware architecture is being used, and if applicable, the operating system.



See also
 Idiomatically determine all the characters that can be used for symbols.

",#Go,Go,"package main
 
import (
	""fmt""
	""unicode""
)
 
const (
	lcASCII = ""abcdefghijklmnopqrstuvwxyz""
	ucASCII = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
)
 
func main() {
	fmt.Println(""ASCII lower case:"")
	fmt.Println(lcASCII)
	for l := 'a'; l <= 'z'; l++ {
		fmt.Print(string(l))
	}
	fmt.Println()
 
	fmt.Println(""\nASCII upper case:"")
	fmt.Println(ucASCII)
	for l := 'A'; l <= 'Z'; l++ {
		fmt.Print(string(l))
	}
	fmt.Println()
 
	fmt.Println(""\nUnicode version "" + unicode.Version)
	showRange16(""Lower case 16-bit code points:"", unicode.Lower.R16)
	showRange32(""Lower case 32-bit code points:"", unicode.Lower.R32)
	showRange16(""Upper case 16-bit code points:"", unicode.Upper.R16)
	showRange32(""Upper case 32-bit code points:"", unicode.Upper.R32)
}
 
func showRange16(hdr string, rList []unicode.Range16) {
	fmt.Print(""\n"", hdr, ""\n"")
	fmt.Printf(""%d ranges:\n"", len(rList))
	for _, rng := range rList {
		fmt.Printf(""%U: "", rng.Lo)
		for r := rng.Lo; r <= rng.Hi; r += rng.Stride {
			fmt.Printf(""%c"", r)
		}
		fmt.Println()
	}
}
 
func showRange32(hdr string, rList []unicode.Range32) {
	fmt.Print(""\n"", hdr, ""\n"")
	fmt.Printf(""%d ranges:\n"", len(rList))
	for _, rng := range rList {
		fmt.Printf(""%U: "", rng.Lo)
		for r := rng.Lo; r <= rng.Hi; r += rng.Stride {
			fmt.Printf(""%c"", r)
		}
		fmt.Println()
	}
}",1296,57
44987,http://rosettacode.org/wiki/Imaginary_base_numbers,Imaginary base numbers,"Imaginary base numbers are a non-standard positional numeral system which uses an imaginary number as its radix. The most common is quater-imaginary with radix 2i.

The quater-imaginary numeral system was first proposed by Donald Knuth in 1955 as a submission for a high school science talent search. [Ref.]

Other imaginary bases are possible too but are not as widely discussed and aren't specifically named.

Task: Write a set of procedures (functions, subroutines, however they are referred to in your language) to convert base 10 numbers to an imaginary base and back.

At a minimum, support quater-imaginary (base 2i).

For extra kudos, support positive or negative bases 2i through 6i (or higher).

As a stretch goal, support converting non-integer numbers ( E.G. 227.65625+10.859375i ) to an imaginary base.

See Wikipedia: Quater-imaginary_base for more details.

For reference, here are some some decimal and complex numbers converted to quater-imaginary.






Base 10
Base 2i


1
 1


2
 2


3
 3


4
 10300


5
 10301


6
 10302


7
 10303


8
 10200


9
 10201


10
 10202


11
 10203


12
 10100


13
 10101


14
 10102


15
 10103


16
 10000






Base 10
Base 2i


−1
 103


−2
 102


−3
 101


−4
 100


−5
 203


−6
 202


−7
 201


−8
 200


−9
 303


−10
 302


−11
 301


−12
 300


−13
 1030003


−14
 1030002


−15
 1030001


−16
 1030000






Base 10
Base 2i


1i
10.2


2i
10.0


3i
20.2


4i
20.0


5i
30.2


6i
30.0


7i
103000.2


8i
103000.0


9i
103010.2


10i
103010.0


11i
103020.2


12i
103020.0


13i
103030.2


14i
103030.0


15i
102000.2


16i
102000.0






Base 10
Base 2i


−1i
0.2


−2i
1030.0


−3i
1030.2


−4i
1020.0


−5i
1020.2


−6i
1010.0


−7i
1010.2


−8i
1000.0


−9i
1000.2


−10i
2030.0


−11i
2030.2


−12i
2020.0


−13i
2020.2


−14i
2010.0


−15i
2010.2


−16i
2000.0




",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""strconv""
    ""strings""
)
 
const (
    twoI    = 2.0i
    invTwoI = 1.0 / twoI
)
 
type quaterImaginary struct {
    b2i string
}
 
func reverse(s string) string {
    r := []rune(s)
    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {
        r[i], r[j] = r[j], r[i]
    }
    return string(r)
}
 
func newQuaterImaginary(b2i string) quaterImaginary {
    b2i = strings.TrimSpace(b2i)
    _, err := strconv.ParseFloat(b2i, 64)
    if err != nil {
        panic(""invalid Base 2i number"")
    }
    return quaterImaginary{b2i}
}
 
func toComplex(q quaterImaginary) complex128 {
    pointPos := strings.Index(q.b2i, ""."")
    var posLen int
    if pointPos != -1 {
        posLen = pointPos
    } else {
        posLen = len(q.b2i)
    }
    sum := 0.0i
    prod := complex(1.0, 0.0)
    for j := 0; j < posLen; j++ {
        k := float64(q.b2i[posLen-1-j] - '0')
        if k > 0.0 {
            sum += prod * complex(k, 0.0)
        }
        prod *= twoI
    }
    if pointPos != -1 {
        prod = invTwoI
        for j := posLen + 1; j < len(q.b2i); j++ {
            k := float64(q.b2i[j] - '0')
            if k > 0.0 {
                sum += prod * complex(k, 0.0)
            }
            prod *= invTwoI
        }
    }
    return sum
}
 
func (q quaterImaginary) String() string {
    return q.b2i
}
 
// only works properly if 'real' and 'imag' are both integral
func toQuaterImaginary(c complex128) quaterImaginary {
    if c == 0i {
        return quaterImaginary{""0""}
    }
    re := int(real(c))
    im := int(imag(c))
    fi := -1
    var sb strings.Builder
    for re != 0 {
        rem := re % -4
        re /= -4
        if rem < 0 {
            rem += 4
            re++
        }
        sb.WriteString(strconv.Itoa(rem))
        sb.WriteString(""0"")
    }
    if im != 0 {
        f := real(complex(0.0, imag(c)) / 2.0i)
        im = int(math.Ceil(f))
        f = -4.0 * (f - float64(im))
        index := 1
        for im != 0 {
            rem := im % -4
            im /= -4
            if rem < 0 {
                rem += 4
                im++
            }
            if index < sb.Len() {
                bs := []byte(sb.String())
                bs[index] = byte(rem + 48)
                sb.Reset()
                sb.Write(bs)
            } else {
                sb.WriteString(""0"")
                sb.WriteString(strconv.Itoa(rem))
            }
            index += 2
        }
        fi = int(f)
    }
    s := reverse(sb.String())
    if fi != -1 {
        s = fmt.Sprintf(""%s.%d"", s, fi)
    }
    s = strings.TrimLeft(s, ""0"")
    if s[0] == '.' {
        s = ""0"" + s
    }
    return newQuaterImaginary(s)
}
 
func main() {
    for i := 1; i <= 16; i++ {
        c1 := complex(float64(i), 0.0)
        qi := toQuaterImaginary(c1)
        c2 := toComplex(qi)
        fmt.Printf(""%4.0f -> %8s -> %4.0f     "", real(c1), qi, real(c2))
        c1 = -c1
        qi = toQuaterImaginary(c1)
        c2 = toComplex(qi)
        fmt.Printf(""%4.0f -> %8s -> %4.0f\n"", real(c1), qi, real(c2))
    }
    fmt.Println()
    for i := 1; i <= 16; i++ {
        c1 := complex(0.0, float64(i))
        qi := toQuaterImaginary(c1)
        c2 := toComplex(qi)
        fmt.Printf(""%3.0fi -> %8s -> %3.0fi     "", imag(c1), qi, imag(c2))
        c1 = -c1
        qi = toQuaterImaginary(c1)
        c2 = toComplex(qi)
        fmt.Printf(""%3.0fi -> %8s -> %3.0fi\n"", imag(c1), qi, imag(c2))
    }
}",3469,147
44992,http://rosettacode.org/wiki/Image_convolution,Image convolution,"One class of image digital filters is described by a rectangular matrix of real coefficients called kernel convoluted in a sliding window of image pixels. Usually the kernel is square 




K

k
l




{\displaystyle K_{kl}}

, where k, l are in the range -R,-R+1,..,R-1,R. W=2R+1 is the kernel width. The filter determines the new value of a monochromatic image pixel Pij as a convolution of the image pixels in the window centered in i, j and the kernel values:







P

i
j


=


∑

k
=
−
R


R



∑

l
=
−
R


R



P

i
+
k
 
j
+
l



K

k
l





{\displaystyle P_{ij}=\displaystyle \sum _{k=-R}^{R}\sum _{l=-R}^{R}P_{i+k\ j+l}K_{kl}}




Color images are usually split into the channels which are filtered independently. A color model can be changed as well, i.e. filtration is performed not necessarily in RGB. Common kernels sizes are 3x3 and 5x5. The complexity of filtrating grows quadratically (O(n2)) with the kernel width.

Task: Write a generic convolution 3x3 kernel filter. Optionally show some end user filters that use this generic one.

(You can use, to test the functions below, these input and output solutions.)
",#Go,Go,"package main
 
import (
    ""fmt""
    ""image""
    ""image/color""
    ""image/jpeg""
    ""math""
    ""os""
)
 
// kf3 is a generic convolution 3x3 kernel filter that operatates on
// images of type image.Gray from the Go standard image library.
func kf3(k *[9]float64, src, dst *image.Gray) {
    for y := src.Rect.Min.Y; y < src.Rect.Max.Y; y++ {
        for x := src.Rect.Min.X; x < src.Rect.Max.X; x++ {
            var sum float64
            var i int
            for yo := y - 1; yo <= y+1; yo++ {
                for xo := x - 1; xo <= x+1; xo++ {
                    if (image.Point{xo, yo}).In(src.Rect) {
                        sum += k[i] * float64(src.At(xo, yo).(color.Gray).Y)
                    } else {
                        sum += k[i] * float64(src.At(x, y).(color.Gray).Y)
                    }
                    i++
                }
            }
            dst.SetGray(x, y,
                color.Gray{uint8(math.Min(255, math.Max(0, sum)))})
        }
    }
}
 
var blur = [9]float64{
    1. / 9, 1. / 9, 1. / 9,
    1. / 9, 1. / 9, 1. / 9,
    1. / 9, 1. / 9, 1. / 9}
 
// blurY example function applies blur kernel to Y channel
// of YCbCr image using generic kernel filter function kf3
func blurY(src *image.YCbCr) *image.YCbCr {
    dst := *src
 
    // catch zero-size image here
    if src.Rect.Max.X == src.Rect.Min.X || src.Rect.Max.Y == src.Rect.Min.Y {
        return &dst
    }
 
    // pass Y channels as gray images
    srcGray := image.Gray{src.Y, src.YStride, src.Rect}
    dstGray := srcGray
    dstGray.Pix = make([]uint8, len(src.Y))
    kf3(&blur, &srcGray, &dstGray) // call generic convolution function
 
    // complete result
    dst.Y = dstGray.Pix                   // convolution result
    dst.Cb = append([]uint8{}, src.Cb...) // Cb, Cr are just copied
    dst.Cr = append([]uint8{}, src.Cr...)
    return &dst
}
 
func main() {
    // Example file used here is Lenna100.jpg from the task ""Percentage
    // difference between images""
    f, err := os.Open(""Lenna100.jpg"")
    if err != nil {
        fmt.Println(err)
        return
    }
    img, err := jpeg.Decode(f)
    if err != nil {
        fmt.Println(err)
        return
    }
    f.Close()
    y, ok := img.(*image.YCbCr)
    if !ok {
        fmt.Println(""expected color jpeg"")
        return
    }
    f, err = os.Create(""blur.jpg"")
    if err != nil {
        fmt.Println(err)
        return
    }
    err = jpeg.Encode(f, blurY(y), &jpeg.Options{90})
    if err != nil {
        fmt.Println(err)
    }
}",2518,91
44997,http://rosettacode.org/wiki/Infinity,Infinity,"Task

Write a function which tests if infinity is supported for floating point numbers (this step should be omitted for languages where the language specification already demands the existence of infinity, e.g. by demanding IEEE numbers), and if so, returns positive infinity.   Otherwise, return the largest possible positive floating point number.

For languages with several floating point types, use the type of the literal constant   1.5   as floating point type.



Related task

   Extreme floating point values

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
// function called for by task
func posInf() float64 {
    return math.Inf(1) // argument specifies positive infinity
}
 
func main() {
    x := 1.5 // type of x determined by literal
    // that this compiles demonstrates that PosInf returns same type as x,
    // the type specified by the task.
    x = posInf()                     // test function
    fmt.Println(x, math.IsInf(x, 1)) // demonstrate result
}",461,19
45003,http://rosettacode.org/wiki/Input_loop,Input loop,"Input loop is part of Short Circuit's Console Program Basics selection.
Task

Read from a text stream either word-by-word or line-by-line until the stream runs out of data.

The stream will have an unknown amount of data on it.



",#Go,Go,"package main
 
import (
	""bufio""
	""io""
	""log""
	""os""
)
 
func main() {
	in := bufio.NewReader(os.Stdin)
	for {
		s, err := in.ReadString('\n')
		if err != nil {
			// io.EOF is expected, anything else
			// should be handled/reported
			if err != io.EOF {
				log.Fatal(err)
			}
			break
		}
		// Do something with the line of text
		// in string variable s.
		_ = s
	}
}",371,26
45213,http://rosettacode.org/wiki/Hunt_the_Wumpus,Hunt the Wumpus,"This task has been flagged for clarification. Code on this page in its current state may be flagged incorrect once this task has been clarified. See this page's Talk page for discussion.
Create a simple implementation of the classic textual game Hunt The Wumpus.

The rules are:

The game is set in a cave that consists of a 20 room labyrinth.
Each room is connected to 3 other rooms (the cave is modeled after the
vertices of a dodecahedron).
The objective of the player is to find and kill the horrendous beast Wumpus that lurks in the cave.

The player has 5 arrows.
If they run out of arrows before killing the Wumpus, the player loses the game.

In the cave there are:

 One Wumpus
 Two giant bats
 Two bottomless pits
If the player enters a room with the Wumpus, he is eaten by it and the game is lost.

If the player enters a room with a bottomless pit, he falls into it and the game is lost.

If the player enters a room with a giant bat, the bat takes him and transports him into a random empty room.

Each turn the player can either walk into an adjacent room or shoot into an adjacent room.

Whenever the player enters a room, he ""senses"" what happens in adjacent rooms.
The messages are:

 Nearby Wumpus: ""You smell something terrible nearby.""
 Nearby bat: ""You hear a rustling.""
 Nearby pit: ""You feel a cold wind blowing from a nearby cavern.""
When the player shoots, he wins the game if he is shooting in the room with the Wumpus.
If he shoots into another room, the Wumpus has a 75% of chance of waking up and moving into an adjacent room: if this is the room with the player, he eats him up and the game is lost.
",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""log""
    ""math/rand""
    ""os""
    ""strconv""
    ""strings""
    ""time""
)
 
var cave = map[int][3]int{
    1: {2, 3, 4}, 2: {1, 5, 6}, 3: {1, 7, 8}, 4: {1, 9, 10}, 5: {2, 9, 11},
    6: {2, 7, 12}, 7: {3, 6, 13}, 8: {3, 10, 14}, 9: {4, 5, 15}, 10: {4, 8, 16},
    11: {5, 12, 17}, 12: {6, 11, 18}, 13: {7, 14, 18}, 14: {8, 13, 19},
    15: {9, 16, 17}, 16: {10, 15, 19}, 17: {11, 20, 15}, 18: {12, 13, 20},
    19: {14, 16, 20}, 20: {17, 18, 19},
}
 
var player, wumpus, bat1, bat2, pit1, pit2 int
 
var arrows = 5
 
func isEmpty(r int) bool {
    if r != player && r != wumpus && r != bat1 && r != bat2 && r != pit1 && r != pit2 {
        return true
    }
    return false
}
 
func sense(adj [3]int) {
    bat := false
    pit := false
    for _, ar := range adj {
        if ar == wumpus {
            fmt.Println(""You smell something terrible nearby."")
        }
        switch ar {
        case bat1, bat2:
            if !bat {
                fmt.Println(""You hear a rustling."")
                bat = true
            }
        case pit1, pit2:
            if !pit {
                fmt.Println(""You feel a cold wind blowing from a nearby cavern."")
                pit = true
            }
        }
    }
    fmt.Println()
}
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func plural(n int) string {
    if n != 1 {
        return ""s""
    }
    return """"
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    player = 1
    wumpus = rand.Intn(19) + 2 // 2 to 20
    bat1 = rand.Intn(19) + 2
    for {
        bat2 = rand.Intn(19) + 2
        if bat2 != bat1 {
            break
        }
    }
    for {
        pit1 = rand.Intn(19) + 2
        if pit1 != bat1 && pit1 != bat2 {
            break
        }
    }
    for {
        pit2 = rand.Intn(19) + 2
        if pit2 != bat1 && pit2 != bat2 && pit2 != pit1 {
            break
        }
    }
    scanner := bufio.NewScanner(os.Stdin)
    for {
        fmt.Printf(""\nYou are in room %d with %d arrow%s left\n"", player, arrows, plural(arrows))
        adj := cave[player]
        fmt.Printf(""The adjacent rooms are %v\n"", adj)
        sense(adj)
        var room int
        for {
            fmt.Print(""Choose an adjacent room : "")
            scanner.Scan()
            room, _ = strconv.Atoi(scanner.Text())
            if room != adj[0] && room != adj[1] && room != adj[2] {
                fmt.Println(""Invalid response, try again"")
            } else {
                break
            }
        }
        check(scanner.Err())
        var action byte
        for {
            fmt.Print(""Walk or shoot w/s : "")
            scanner.Scan()
            reply := strings.ToLower(scanner.Text())
            if len(reply) != 1 || (len(reply) == 1 && reply[0] != 'w' && reply[0] != 's') {
                fmt.Println(""Invalid response, try again"")
            } else {
                action = reply[0]
                break
            }
        }
        check(scanner.Err())
        if action == 'w' {
            player = room
            switch player {
            case wumpus:
                fmt.Println(""You have been eaten by the Wumpus and lost the game!"")
                return
            case pit1, pit2:
                fmt.Println(""You have fallen down a bottomless pit and lost the game!"")
                return
            case bat1, bat2:
                for {
                    room = rand.Intn(19) + 2
                    if isEmpty(room) {
                        fmt.Println(""A bat has transported you to a random empty room"")
                        player = room
                        break
                    }
                }
            }
        } else {
            if room == wumpus {
                fmt.Println(""You have killed the Wumpus and won the game!!"")
                return
            } else {
                chance := rand.Intn(4) // 0 to 3
                if chance > 0 {        // 75% probability
                    wumpus = cave[wumpus][rand.Intn(3)]
                    if player == wumpus {
                        fmt.Println(""You have been eaten by the Wumpus and lost the game!"")
                        return
                    }
                }
            }
            arrows--
            if arrows == 0 {
                fmt.Println(""You have run out of arrows and lost the game!"")
                return
            }
        }
    }
}",4457,163
45218,http://rosettacode.org/wiki/Image_noise,Image noise,"Generate a random black and white   320x240   image continuously,
showing FPS (frames per second).



A sample image
 

",#Go,Go,"package main
 
import (
    ""code.google.com/p/x-go-binding/ui/x11""
    ""fmt""
    ""image""
    ""image/color""
    ""image/draw""
    ""log""
    ""os""
    ""time""
)
 
var randcol = genrandcol()
 
func genrandcol() <-chan color.Color {
    c := make(chan color.Color)
 
    go func() {
        for {
            select {
            case c <- image.Black:
            case c <- image.White:
            }
        }
    }()
 
    return c
}
 
func gennoise(screen draw.Image) {
    for y := 0; y < 240; y++ {
        for x := 0; x < 320; x++ {
            screen.Set(x, y, <-randcol)
        }
    }
}
 
func fps() chan<- bool {
    up := make(chan bool)
 
    go func() {
        var frames int64
        var lasttime time.Time
        var totaltime time.Duration
 
        for {
            <-up
            frames++
            now := time.Now()
            totaltime += now.Sub(lasttime)
            if totaltime > time.Second {
                fmt.Printf(""FPS: %v\n"", float64(frames)/totaltime.Seconds())
                frames = 0
                totaltime = 0
            }
            lasttime = now
        }
    }()
 
    return up
}
 
func main() {
    win, err := x11.NewWindow()
    if err != nil {
        fmt.Println(err)
        os.Exit(1)
    }
    defer win.Close()
 
    go func() {
        upfps := fps()
        screen := win.Screen()
 
        for {
            gennoise(screen)
 
            win.FlushImage()
 
            upfps <- true
        }
    }()
 
    for _ = range win.EventChan() {
    }
}
 ",1515,88
45392,http://rosettacode.org/wiki/Include_a_file,Include a file,"Task

Demonstrate the language's ability to include source code from other files.




See Also
 Compiler/Simple file inclusion pre processor



",#Go,Go,"// main.go
package main
 
import ""fmt""
 
func hello() {
    fmt.Println(""Hello from main.go"")
}
 
func main() {
    hello()
    hello2()
}",138,13
45406,http://rosettacode.org/wiki/Integer_sequence,Integer sequence,"Task

Create a program that, when run, would display all integers from   1   to      ∞      (or any relevant implementation limit),   in sequence   (i.e.   1, 2, 3, 4, etc)   if given enough time.



An example may not be able to reach arbitrarily-large numbers based on implementations limits.   For example, if integers are represented as a 32-bit unsigned value with 0 as the smallest representable value, the largest representable value would be 4,294,967,295.   Some languages support arbitrarily-large numbers as a built-in feature, while others make use of a module or library.

If appropriate, provide an example which reflect the language implementation's common built-in limits as well as an example which supports arbitrarily large numbers, and describe the nature of such limitations—or lack thereof.



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    for i := 1;; i++ {
        fmt.Println(i)
    }
}",97,9
45524,http://rosettacode.org/wiki/Humble_numbers,Humble numbers,"Humble numbers are positive integers which have   no   prime factors    >    7.



Humble numbers are also called   7-smooth numbers,   and sometimes called   highly composite,

although this conflicts with another meaning of   highly composite numbers.



Another way to express the above is:

  humble  =  2i × 3j × 5k × 7m 

           where     i, j, k, m ≥ 0 



Task

   show the first   50   humble numbers   (in a horizontal list)
   show the number of humble numbers that have   x   decimal digits for all   x's   up to   n   (inclusive).
   show   (as many as feasible or reasonable for above)   on separate lines
   show all output here on this page


Related tasks

   Hamming numbers


References

   Wikipedia: Smooth numbers, see the 2nd paragraph.
   OEIS A002473: humble numbers
   University of Ulm, The first 5842 terms of humble numbers

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
var (
    one   = new(big.Int).SetUint64(1)
    two   = new(big.Int).SetUint64(2)
    three = new(big.Int).SetUint64(3)
    five  = new(big.Int).SetUint64(5)
    seven = new(big.Int).SetUint64(7)
    ten   = new(big.Int).SetUint64(10)
)
 
func min(a, b *big.Int) *big.Int {
    if a.Cmp(b) < 0 {
        return a
    }
    return b
}
 
func humble(n int) []*big.Int {
    h := make([]*big.Int, n)
    h[0] = new(big.Int).Set(one)
    next2, next3 := new(big.Int).Set(two), new(big.Int).Set(three)
    next5, next7 := new(big.Int).Set(five), new(big.Int).Set(seven)
    var i, j, k, l int
    for m := 1; m < len(h); m++ {
        h[m] = new(big.Int).Set(min(next2, min(next3, min(next5, next7))))
        if h[m].Cmp(next2) == 0 {
            i++
            next2.Mul(two, h[i])
        }
        if h[m].Cmp(next3) == 0 {
            j++
            next3.Mul(three, h[j])
        }
        if h[m].Cmp(next5) == 0 {
            k++
            next5.Mul(five, h[k])
        }
        if h[m].Cmp(next7) == 0 {
            l++
            next7.Mul(seven, h[l])
        }
    }
    return h
}
 
func commatize(n int) string {
    s := fmt.Sprintf(""%d"", n)
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    return s
}
 
func main() {
    const n = 13 * 1e6  // calculate the first 13 million humble numbers, say
    h := humble(n) 
    fmt.Println(""The first 50 humble numbers are:"")
    fmt.Println(h[0:50])
 
    maxDigits := len(h[len(h)-1].String()) - 1
    counts := make([]int, maxDigits+1)
    var maxUsed int
    digits := 1
    pow10 := new(big.Int).Set(ten)
    for i := 0; i < len(h); i++ {
        for {
            if h[i].Cmp(pow10) >= 0 {
                pow10.Mul(pow10, ten)
                digits++
            } else {
                break
            }
        }  
        if digits > maxDigits {
            maxUsed = i
            break
        }
        counts[digits]++
    }
    fmt.Printf(""\nOf the first %s humble numbers:\n"", commatize(maxUsed))
    for i := 1; i <= maxDigits; i++ {
        s := ""s""
        if i == 1 {
            s = """"
        }
        fmt.Printf(""%9s have %2d digit%s\n"", commatize(counts[i]), i, s)
    }       
}",2268,95
45790,http://rosettacode.org/wiki/I_before_E_except_after_C,I before E except after C,"The phrase      ""I before E, except after C""     is a
widely known mnemonic which is supposed to help when spelling English words.



Task

Using the word list from   http://wiki.puzzlers.org/pub/wordlists/unixdict.txt,

check if the two sub-clauses of the phrase are plausible individually:

   ""I before E when not preceded by C""
   ""E before I when preceded by C""


If both sub-phrases are plausible then the original phrase can be said to be plausible.

Something is plausible if the number of words having the feature is more than two times the number of words having the opposite feature (where feature is 'ie' or 'ei' preceded or not by 'c' as appropriate).



Stretch goal

As a stretch goal use the entries from the table of Word Frequencies in Written and Spoken English: based on the British National Corpus, (selecting those rows with three space or tab separated words only), to see if the phrase is plausible when word frequencies are taken into account.


Show your output here as well as your program.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




cf.

 Schools to rethink 'i before e' - BBC news, 20 June 2009
 I Before E Except After C - QI Series 8 Ep 14, (humorous)
 Companion website for the book: ""Word Frequencies in Written and Spoken English: based on the British National Corpus"".

",#Go,Go,"package main
 
import (
	""bufio""
	""fmt""
	""log""
	""os""
	""regexp""
	""strings""
)
 
func main() {
	f, err := os.Open(""unixdict.txt"")
	if err != nil {
		log.Fatalln(err)
	}
	defer f.Close()
 
	s := bufio.NewScanner(f)
	rie := regexp.MustCompile(""^ie|[^c]ie"")
	rei := regexp.MustCompile(""^ei|[^c]ei"")
	var cie, ie int
	var cei, ei int
	for s.Scan() {
		line := s.Text()
		if strings.Contains(line, ""cie"") {
			cie++
		}
		if strings.Contains(line, ""cei"") {
			cei++
		}
		if rie.MatchString(line) {
			ie++
		}
		if rei.MatchString(line) {
			ei++
		}
	}
	err = s.Err()
	if err != nil {
		log.Fatalln(err)
	}
 
	if check(ie, ei, ""I before E when not preceded by C"") &&
		check(cei, cie, ""E before I when preceded by C"") {
		fmt.Println(""Both plausable."")
		fmt.Println(`""I before E, except after C"" is plausable.`)
	} else {
		fmt.Println(""One or both implausable."")
		fmt.Println(`""I before E, except after C"" is implausable.`)
	}
}
 
// check checks if a statement is plausible. Something is plausible if a is more
// than two times b.
func check(a, b int, s string) bool {
	switch {
	case a > b*2:
		fmt.Printf(""%q is plausible (%d vs %d).\n"", s, a, b)
		return true
	case a >= b:
		fmt.Printf(""%q is implausible (%d vs %d).\n"", s, a, b)
	default:
		fmt.Printf(""%q is implausible and contra-indicated (%d vs %d).\n"",
			s, a, b)
	}
	return false
}",1342,68
45797,http://rosettacode.org/wiki/IBAN,IBAN,"

 This page uses content from Wikipedia. The original article was at IBAN. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The   International Bank Account Number (IBAN)   is an internationally agreed means of identifying bank accounts across national borders with a reduced risk of propagating transcription errors.

The IBAN consists of up to 34 alphanumeric characters:

   first the two-letter ISO 3166-1 alpha-2 country code, 
   then two check digits, and 
   finally a country-specific Basic Bank Account Number (BBAN). 


The check digits enable a sanity check of the bank account number to confirm its integrity even before submitting a transaction.



Task

Validate the following fictitious IBAN:    GB82 WEST 1234 5698 7654 32 



Details of the algorithm can be found on the Wikipedia page.



",#Go,Go,"package main
 
import (
	""regexp""
	""strings""
	""testing""
)
 
var lengthByCountryCode = map[string]int{
	""AL"": 28, ""AD"": 24, ""AT"": 20, ""AZ"": 28, ""BE"": 16, ""BH"": 22,
	""BA"": 20, ""BR"": 29, ""BG"": 22, ""CR"": 21, ""HR"": 21, ""CY"": 28,
	""CZ"": 24, ""DK"": 18, ""DO"": 28, ""EE"": 20, ""FO"": 18, ""FI"": 18,
	""FR"": 27, ""GE"": 22, ""DE"": 22, ""GI"": 23, ""GR"": 27, ""GL"": 18,
	""GT"": 28, ""HU"": 28, ""IS"": 26, ""IE"": 22, ""IL"": 23, ""IT"": 27,
	""KZ"": 20, ""KW"": 30, ""LV"": 21, ""LB"": 28, ""LI"": 21, ""LT"": 20,
	""LU"": 20, ""MK"": 19, ""MT"": 31, ""MR"": 27, ""MU"": 30, ""MC"": 27,
	""MD"": 24, ""ME"": 22, ""NL"": 18, ""NO"": 15, ""PK"": 24, ""PS"": 29,
	""PL"": 28, ""PT"": 25, ""RO"": 24, ""SM"": 27, ""SA"": 24, ""RS"": 22,
	""SK"": 24, ""SI"": 19, ""ES"": 24, ""SE"": 24, ""CH"": 21, ""TN"": 24,
	""TR"": 26, ""AE"": 23, ""GB"": 22, ""VG"": 24,
}
 
func isValidIBAN(iban string) bool {
	if len(iban) < 4 {
		return false
	}
	iban = regexp.MustCompile(`\s+`).ReplaceAllString(iban, """")
	iban = strings.ToUpper(iban)
 
	if ibanLen := lengthByCountryCode[iban[0:2]]; ibanLen == len(iban) {
		return false
	}
	iban = iban[4:] + iban[:4]
 
	result := 0
	for _, ch := range iban {
		var n int
		if '0' <= ch && ch <= '9' {
			n = int(ch) - '0'
		} else if 'A' <= ch && ch <= 'Z' {
			n = 10 + int(ch) - 'A'
		} else {
			return false
		}
 
		if n < 10 {
			result = (10*result + n) % 97
		} else {
			result = (100*result + n) % 97
		}
	}
	return result == 1
}
 
func TestIsValidIBAN(t *testing.T) {
	tests := []struct {
		iban  string
		valid bool
	}{
		{""GB82 WEST 1234 5698 7654 32"", true},
		{""GB82 TEST 1234 5698 7654 32"", false},
	}
	for _, test := range tests {
		if isValidIBAN(test.iban) == test.valid {
			return
		}
		t.Errorf(""Expected %q to be %v"", test.iban, test.valid)
	}
}
 ",1693,70
45810,http://rosettacode.org/wiki/Increment_a_numerical_string,Increment a numerical string,"Task

Increment a numerical string.



",#Go,Go,"package main
import ""fmt""
import ""strconv""
func main() {
  i, _ := strconv.Atoi(""1234"")
  fmt.Println(strconv.Itoa(i + 1))
}",124,7
45974,http://rosettacode.org/wiki/Integer_comparison,Integer comparison,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Get two integers from the user.

Then,   display a message if the first integer is:

   less than, 
   equal to,   or 
   greater than
the second integer.



Test the condition   for each case separately,   so that   all three comparison operators are used   in the code.



Related task

   String comparison

",#Go,Go,"package main
 
import (
	""fmt""
	""log""
)
 
func main() {
	var n1, n2 int
	fmt.Print(""enter number: "")
	if _, err := fmt.Scan(&n1); err != nil {
		log.Fatal(err)
	}
	fmt.Print(""enter number: "")
	if _, err := fmt.Scan(&n2); err != nil {
		log.Fatal(err)
	}
	switch {
	case n1 < n2:
		fmt.Println(n1, ""less than"", n2)
	case n1 == n2:
		fmt.Println(n1, ""equal to"", n2)
	case n1 > n2:
		fmt.Println(n1, ""greater than"", n2)
	}
}",421,26
46030,http://rosettacode.org/wiki/Identity_matrix,Identity matrix,"Task

Build an   identity matrix   of a size known at run-time.



An identity matrix is a square matrix of size n × n,

where the diagonal elements are all 1s (ones),

and all the other elements are all 0s (zeroes).







I

n


=


[



1


0


0


⋯


0




0


1


0


⋯


0




0


0


1


⋯


0




⋮


⋮


⋮


⋱


⋮




0


0


0


⋯


1



]




{\displaystyle I_{n}={\begin{bmatrix}1&0&0&\cdots &0\\0&1&0&\cdots &0\\0&0&1&\cdots &0\\\vdots &\vdots &\vdots &\ddots &\vdots \\0&0&0&\cdots &1\\\end{bmatrix}}}





Related tasks

   Spiral matrix
   Zig-zag matrix 
   Ulam_spiral_(for_primes)

",#Go,Go,"package main
 
import (
    ""fmt""
 
    ""gonum.org/v1/gonum/mat""
)
 
func eye(n int) *mat.Dense {
    m := mat.NewDense(n, n, nil)
    for i := 0; i < n; i++ {
        m.Set(i, i, 1)
    }
    return m
}
 
func main() {
    fmt.Println(mat.Formatted(eye(3)))
}",260,19
46055,http://rosettacode.org/wiki/HTTPS/Client-authenticated,HTTPS/Client-authenticated,"Demonstrate how to connect to a web server over HTTPS where that server requires that the client present a certificate to prove who (s)he is. Unlike with the HTTPS request with authentication task, it is not acceptable to perform the authentication by a username/password or a set cookie.

This task is in general useful for use with webservice clients as it offers a high level of assurance that the client is an acceptable counterparty for the server. For example, Amazon Web Services uses this style of authentication.
",#Go,Go,"package main
 
import (
	""crypto/tls""
	""io/ioutil""
	""log""
	""net/http""
)
 
func main() {
 
	// load key pair
	cert, err := tls.LoadX509KeyPair(
		""./client.local.tld/client.local.tld.crt"",
		""./client.local.tld/client.local.tld.key"",
	)
 
	if err != nil {
		log.Fatal(""Error while loading x509 key pair"", err)
	}
 
	// Create TLS Config in order to had client certificate
	tlsConfig := &tls.Config{Certificates: []tls.Certificate{cert}}
 
	tlsConfig.BuildNameToCertificate()
	transport := &http.Transport{TLSClientConfig: tlsConfig}
 
	// create http client with our custom transport with TLS config
	client := &http.Client{Transport: transport}
 
	res, err := client.Get(""https://www.example.com/"")
	if err != nil {
		log.Fatal(err)
	}
	contents, err := ioutil.ReadAll(res.Body)
	log.Print(string(contents))
 
}
 ",813,39
46105,http://rosettacode.org/wiki/HTTPS/Authenticated,HTTPS/Authenticated,"The goal of this task is to demonstrate HTTPS requests with authentication.
Implementations of this task should not use client certificates for this: that is the subject of another task.
",#Go,Go,"package main
 
import (
    ""encoding/base64""
    ""io""
    ""log""
    ""net/http""
    ""strings""
)
 
const userPass = ""rosetta:code""
const unauth = http.StatusUnauthorized
 
func hw(w http.ResponseWriter, req *http.Request) {
    auth := req.Header.Get(""Authorization"")
    if !strings.HasPrefix(auth, ""Basic "") {
        log.Print(""Invalid authorization:"", auth)
        http.Error(w, http.StatusText(unauth), unauth)
        return
    }
    up, err := base64.StdEncoding.DecodeString(auth[6:])
    if err != nil {
        log.Print(""authorization decode error:"", err)
        http.Error(w, http.StatusText(unauth), unauth)
        return
    }
    if string(up) != userPass {
        log.Print(""invalid username:password:"", string(up))
        http.Error(w, http.StatusText(unauth), unauth)
        return
    }
    io.WriteString(w, ""Goodbye, World!"")
}
 
func main() {
    http.HandleFunc(""/"", hw)
    log.Fatal(http.ListenAndServeTLS("":8080"", ""cert.pem"", ""key.pem"", nil))
}",976,38
46229,http://rosettacode.org/wiki/Hough_transform,Hough transform,"Task

Implement the Hough transform, which is used as part of feature extraction with digital images.

It is a tool that makes it far easier to identify straight lines in the source image, whatever their orientation.

The transform maps each point in the target image, 



(
ρ
,
θ
)


{\displaystyle (\rho ,\theta )}

, to the average color of the pixels on the corresponding line of the source image (in 



(
x
,
y
)


{\displaystyle (x,y)}

-space, where the line corresponds to points of the form 



x
cos
⁡
θ
+
y
sin
⁡
θ
=
ρ


{\displaystyle x\cos \theta +y\sin \theta =\rho }

). The idea is that where there is a straight line in the original image, it corresponds to a bright (or dark, depending on the color of the background field) spot; by applying a suitable filter to the results of the transform, it is possible to extract the locations of the lines in the original image.

 Sample PNG image to use for the Hough transform.
The target space actually uses polar coordinates, but is conventionally plotted on rectangular coordinates for display. There's no specification of exactly how to map polar coordinates to a flat surface for display, but a convenient method is to use one axis for 



θ


{\displaystyle \theta }

 and the other for 



ρ


{\displaystyle \rho }

, with the center of the source image being the origin.

There is also a spherical Hough transform, which is more suited to identifying planes in 3D data.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""image""
    ""image/color""
    ""image/draw""
    ""image/png""
    ""math""
    ""os""
)
 
func hough(im image.Image, ntx, mry int) draw.Image {
    nimx := im.Bounds().Max.X
    mimy := im.Bounds().Max.Y
 
    him := image.NewGray(image.Rect(0, 0, ntx, mry))
    draw.Draw(him, him.Bounds(), image.NewUniform(color.White),
        image.Point{}, draw.Src)
 
    rmax := math.Hypot(float64(nimx), float64(mimy))
    dr := rmax / float64(mry/2)
    dth := math.Pi / float64(ntx)
 
    for jx := 0; jx < nimx; jx++ {
        for iy := 0; iy < mimy; iy++ {
            col := color.GrayModel.Convert(im.At(jx, iy)).(color.Gray)
            if col.Y == 255 {
                continue
            }
            for jtx := 0; jtx < ntx; jtx++ {
                th := dth * float64(jtx)
                r := float64(jx)*math.Cos(th) + float64(iy)*math.Sin(th)
                iry := mry/2 - int(math.Floor(r/dr+.5))
                col = him.At(jtx, iry).(color.Gray)
                if col.Y > 0 {
                    col.Y--
                    him.SetGray(jtx, iry, col)
                }
            }
        }
    }
    return him
}
 
func main() {
    f, err := os.Open(""Pentagon.png"")
    if err != nil {
        fmt.Println(err)
        return
    }
    pent, err := png.Decode(f)
    if err != nil {
        fmt.Println(err)
        return
    }
    if err = f.Close(); err != nil {
        fmt.Println(err)
    }
    h := hough(pent, 460, 360)
    if f, err = os.Create(""hough.png""); err != nil {
        fmt.Println(err)
        return
    }
    if err = png.Encode(f, h); err != nil {
        fmt.Println(err)
    }
    if cErr := f.Close(); cErr != nil && err == nil {
        fmt.Println(err)
    }
}",1738,71
46271,http://rosettacode.org/wiki/HTTPS,HTTPS,"Task

Send a GET request to obtain the resource located at the URL ""https://www.w3.org/"", then print it to the console.

Checking the host certificate for validity is recommended.

Do not authenticate. That is the subject of other tasks.

Readers may wish to contrast with the HTTP Request task, and also the task on HTTPS request with authentication.

",#Go,Go," 
package main
 
import (
    ""io""
    ""log""
    ""net/http""
    ""os""
)
 
func main() {
    r, err := http.Get(""https://sourceforge.net/"")
    if err != nil {
        log.Fatalln(err)
    }
    io.Copy(os.Stdout, r.Body)
}
 ",223,18
46371,http://rosettacode.org/wiki/Host_introspection,Host introspection,"Print the word size and endianness of the host machine.

See also: Variable size/Get
",#Go,Go,"package main
 
import (
	""fmt""
	""io/ioutil""
	""runtime""
	""strconv""
	""strings""
	""unsafe""
)
 
func main() {
	fmt.Println(runtime.Version(), runtime.GOOS, runtime.GOARCH)
 
	// Inspect a uint32 variable to determine endianness.
	x := uint32(0x01020304)
	switch *(*byte)(unsafe.Pointer(&x)) {
	case 0x01:
		fmt.Println(""big endian"")
	case 0x04:
		fmt.Println(""little endian"")
	default:
		fmt.Println(""mixed endian?"")
	}
 
	// Usually one cares about the size the executible was compiled for
	// rather than the actual underlying host's size.
 
	// There are several ways of determining the size of an int/uint.
	fmt.Println(""         strconv.IntSize ="", strconv.IntSize)
	// That uses the following definition we can also be done by hand
	intSize := 32 << uint(^uint(0)>>63)
	fmt.Println(""32 << uint(^uint(0)>>63) ="", intSize)
 
	// With Go 1.0, 64-bit architectures had 32-bit int and 64-bit
	// uintptr. This was changed in Go 1.1. In general it would
	// still be possible that int and uintptr (the type large enough
	// to hold the bit pattern of any pointer) are of different sizes.
	const bitsPerByte = 8
	fmt.Println(""  sizeof(int)     in bits:"", unsafe.Sizeof(int(0))*bitsPerByte)
	fmt.Println(""  sizeof(uintptr) in bits:"", unsafe.Sizeof(uintptr(0))*bitsPerByte)
	// If we really want to know the architecture size the executable was
	// compiled for and not the size of int it safest to take the max of those.
	archSize := unsafe.Sizeof(int(0))
	if psize := unsafe.Sizeof(uintptr(0)); psize > archSize {
		archSize = psize
	}
	fmt.Println(""  compiled with word size:"", archSize*bitsPerByte)
 
	// There are some *very* unportable ways to attempt to get the actual
	// underlying hosts' word size.
	// Inspect cpuinfo to determine word size (some unix-like OS' only).
	c, err := ioutil.ReadFile(""/proc/cpuinfo"")
	if err != nil {
		fmt.Println(err)
		return
	}
	ls := strings.Split(string(c), ""\n"")
	for _, l := range ls {
		if strings.HasPrefix(l, ""flags"") {
			for _, f := range strings.Fields(l) {
				if f == ""lm"" { // ""long mode""
					fmt.Println(""64 bit word size"")
					return
				}
			}
			fmt.Println(""32 bit word size"")
			return
		}
	}
}",2150,71
46389,http://rosettacode.org/wiki/Home_primes,Home primes,"

 This page uses content from Wikipedia. The original article was at Home prime. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

In number theory, the home prime HP(n) of an integer n greater than 1 is the prime number obtained by repeatedly factoring the increasing concatenation of prime factors including repetitions.

The traditional notation has the prefix ""HP"" and a postfix count of the number of iterations until the home prime is found (if the count is greater than 0), for instance HP4(2) === HP22(1) === 211 is the same as saying the home prime of 4 needs 2 iterations and is the same as the home prime of 22 which needs 1 iteration, and (both) resolve to 211, a prime.

Prime numbers are their own home prime;

So:

   HP2 = 2
   
   HP7 = 7

If the integer obtained by concatenating increasing prime factors is not prime, iterate until you reach a prime number; the home prime.

   HP4(2) = HP22(1) = 211
   HP4(2) = 2 × 2 => 22; HP22(1) = 2 × 11 => 211; 211 is prime  
   
   HP10(4) = HP25(3) = HP55(2) = HP511(1) = 773
   HP10(4) = 2 × 5 => 25; HP25(3) = 5 × 5 => 55; HP55(2) = 5 × 11 => 511; HP511(1) = 7 × 73 => 773; 773 is prime  



Task
 Find and show here, on this page, the home prime iteration chains for the integers 2 through 20 inclusive.


Stretch goal
 Find and show the iteration chain for 65.


Impossible goal
 Show the the home prime for HP49.


See also
 OEIS:A037274 - Home primes for n >= 2
 OEIS:A056938 - Concatenation chain for HP49

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""rcu""
    ""sort""
)
 
var zero = new(big.Int)
var one = big.NewInt(1)
var two = big.NewInt(2)
var three = big.NewInt(3)
var four = big.NewInt(4)
var five = big.NewInt(5)
var six = big.NewInt(6)
 
// simple wheel based prime factors routine for BigInt
func primeFactorsWheel(m *big.Int) []*big.Int {
    n := new(big.Int).Set(m)
    t := new(big.Int)
    inc := []*big.Int{four, two, four, two, four, six, two, six}
    var factors []*big.Int
    for t.Rem(n, two).Cmp(zero) == 0 {
        factors = append(factors, two)
        n.Quo(n, two)
    }
    for t.Rem(n, three).Cmp(zero) == 0 {
        factors = append(factors, three)
        n.Quo(n, three)
    }
    for t.Rem(n, five).Cmp(zero) == 0 {
        factors = append(factors, five)
        n.Quo(n, five)
    }
    k := big.NewInt(7)
    i := 0
    for t.Mul(k, k).Cmp(n) <= 0 {
        if t.Rem(n, k).Cmp(zero) == 0 {
            factors = append(factors, new(big.Int).Set(k))
            n.Quo(n, k)
        } else {
            k.Add(k, inc[i])
            i = (i + 1) % 8
        }
    }
    if n.Cmp(one) > 0 {
        factors = append(factors, n)
    }
    return factors
}
 
func pollardRho(n *big.Int) *big.Int {
    g := func(x, n *big.Int) *big.Int {
        x2 := new(big.Int)
        x2.Mul(x, x)
        x2.Add(x2, one)
        return x2.Mod(x2, n)
    }
    x, y, d := new(big.Int).Set(two), new(big.Int).Set(two), new(big.Int).Set(one)
    t, z := new(big.Int), new(big.Int).Set(one)
    count := 0
    for {
        x = g(x, n)
        y = g(g(y, n), n)
        t.Sub(x, y)
        t.Abs(t)
        t.Mod(t, n)
        z.Mul(z, t)
        count++
        if count == 100 {
            d.GCD(nil, nil, z, n)
            if d.Cmp(one) != 0 {
                break
            }
            z.Set(one)
            count = 0
        }
    }
    if d.Cmp(n) == 0 {
        return new(big.Int)
    }
    return d
}
 
func primeFactors(m *big.Int) []*big.Int {
    n := new(big.Int).Set(m)
    var factors []*big.Int
    lim := big.NewInt(1e9)
    for n.Cmp(one) > 0 {
        if n.Cmp(lim) > 0 {
            d := pollardRho(n)
            if d.Cmp(zero) != 0 {
                factors = append(factors, primeFactorsWheel(d)...)
                n.Quo(n, d)
                if n.ProbablyPrime(10) {
                    factors = append(factors, n)
                    break
                }
            } else {
                factors = append(factors, primeFactorsWheel(n)...)
                break
            }
        } else {
            factors = append(factors, primeFactorsWheel(n)...)
            break
        }
    }
    sort.Slice(factors, func(i, j int) bool { return factors[i].Cmp(factors[j]) < 0 })
    return factors
}
 
func main() {
    list := make([]int, 20)
    for i := 2; i <= 20; i++ {
        list[i-2] = i
    }
    list[19] = 65
    for _, i := range list {
        if rcu.IsPrime(i) {
            fmt.Printf(""HP%d = %d\n"", i, i)
            continue
        }
        n := 1
        j := big.NewInt(int64(i))
        h := []*big.Int{j}
        for {
            pf := primeFactors(j)
            k := """"
            for _, f := range pf {
                k += fmt.Sprintf(""%d"", f)
            }
            j, _ = new(big.Int).SetString(k, 10)
            h = append(h, j)
            if j.ProbablyPrime(10) {
                for l := n; l > 0; l-- {
                    fmt.Printf(""HP%d(%d) = "", h[n-l], l)
                }
                fmt.Println(h[n])
                break
            } else {
                n++
            }
        }
    }
}",3603,146
46394,http://rosettacode.org/wiki/Hostname,Hostname,"Task

Find the name of the host on which the routine is running.



",#Go,Go,"package main
 
import (
	""fmt""
	""os""
)
 
func main() {
	fmt.Println(os.Hostname())
}",84,10
46542,http://rosettacode.org/wiki/Huffman_coding,Huffman coding,"Huffman encoding is a way to assign binary codes to symbols that reduces the overall number of bits used to encode a typical string of those symbols.

For example, if you use letters as symbols and have details of the frequency of occurrence of those letters in typical strings, then you could just encode each letter with a fixed number of bits, such as in ASCII codes. You can do better than this by encoding more frequently occurring letters such as e and a, with smaller bit strings; and less frequently occurring letters such as q and x with longer bit strings.

Any string of letters will be encoded as a string of bits that are no-longer of the same length per letter. To successfully decode such as string, the smaller codes assigned to letters such as 'e' cannot occur as a prefix in the larger codes such as that for 'x'.

If you were to assign a code 01 for 'e' and code 011 for 'x', then if the bits to decode started as 011... then you would not know if you should decode an 'e' or an 'x'.
The Huffman coding scheme takes each symbol and its weight (or frequency of occurrence), and generates proper encodings for each symbol taking account of the weights of each symbol, so that higher weighted symbols have fewer bits in their encoding. (See the WP article for more information).

A Huffman encoding can be computed by first creating a tree of nodes:


 Create a leaf node for each symbol and add it to the priority queue.
 While there is more than one node in the queue:
 Remove the node of highest priority (lowest probability) twice to get two nodes.
 Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes' probabilities.
 Add the new node to the queue.
 The remaining node is the root node and the tree is complete.


Traverse the constructed binary tree from root to leaves assigning and accumulating a '0' for one branch and a '1' for the other at each node. The accumulated zeros and ones at each leaf constitute a Huffman encoding for those symbols and weights:



Task

Using the characters and their frequency from the string:

     this is an example for huffman encoding  
create a program to generate a Huffman encoding for each character as a table.



",#Go,Go,"package main
 
import (
    ""container/heap""
    ""fmt""
)
 
type HuffmanTree interface {
    Freq() int
}
 
type HuffmanLeaf struct {
    freq  int
    value rune
}
 
type HuffmanNode struct {
    freq        int
    left, right HuffmanTree
}
 
func (self HuffmanLeaf) Freq() int {
    return self.freq
}
 
func (self HuffmanNode) Freq() int {
    return self.freq
}
 
type treeHeap []HuffmanTree
 
func (th treeHeap) Len() int { return len(th) }
func (th treeHeap) Less(i, j int) bool {
    return th[i].Freq() < th[j].Freq()
}
func (th *treeHeap) Push(ele interface{}) {
    *th = append(*th, ele.(HuffmanTree))
}
func (th *treeHeap) Pop() (popped interface{}) {
    popped = (*th)[len(*th)-1]
    *th = (*th)[:len(*th)-1]
    return
}
func (th treeHeap) Swap(i, j int) { th[i], th[j] = th[j], th[i] }
 
func buildTree(symFreqs map[rune]int) HuffmanTree {
    var trees treeHeap
    for c, f := range symFreqs {
        trees = append(trees, HuffmanLeaf{f, c})
    }
    heap.Init(&trees)
    for trees.Len() > 1 {
        // two trees with least frequency
        a := heap.Pop(&trees).(HuffmanTree)
        b := heap.Pop(&trees).(HuffmanTree)
 
        // put into new node and re-insert into queue
        heap.Push(&trees, HuffmanNode{a.Freq() + b.Freq(), a, b})
    }
    return heap.Pop(&trees).(HuffmanTree)
}
 
func printCodes(tree HuffmanTree, prefix []byte) {
    switch i := tree.(type) {
    case HuffmanLeaf:
        // print out symbol, frequency, and code for this
        // leaf (which is just the prefix)
        fmt.Printf(""%c\t%d\t%s\n"", i.value, i.freq, string(prefix))
    case HuffmanNode:
        // traverse left
        prefix = append(prefix, '0')
        printCodes(i.left, prefix)
        prefix = prefix[:len(prefix)-1]
 
        // traverse right
        prefix = append(prefix, '1')
        printCodes(i.right, prefix)
        prefix = prefix[:len(prefix)-1]
    }
}
 
func main() {
    test := ""this is an example for huffman encoding""
 
    symFreqs := make(map[rune]int)
    // read each symbol and record the frequencies
    for _, c := range test {
        symFreqs[c]++
    }
 
    // build tree
    tree := buildTree(symFreqs)
 
    // print out results
    fmt.Println(""SYMBOL\tWEIGHT\tHUFFMAN CODE"")
    printCodes(tree, []byte{})
}",2274,97
46675,http://rosettacode.org/wiki/Honeycombs,Honeycombs,"The task is to produce a matrix of 20 hexagon shaped widgets in a honeycomb arrangement. The matrix should be arranged in such a manner that there are five
columns of four hexagons. The hexagons in columns one, three and five are aligned horizontally, whereas the hexagons in columns two and four occupy a lower position within the arrangement. Each hexagon should be the same colour, and should
display a unique randomly selected single capital letter on the front. The application should now wait for the user to select a hexagon, either by using a pointing device, or by pressing a key that carries a corresponding letter on a hexagon. For platforms that support pointing devices and keyboards, the application should support both methods of selection. A record of the chosen letters should be maintained and the code should be suitably commented, at the point where the the selected letter has been determined. The selected hexagon should now change colour on the display. The cycle repeats until the user has chosen all of the letters. Note that each letter can only be selected once and previously selected hexagons retain their colour after selection. The program terminates when all letters have been chosen.

Optionally: output the list of selected letters and show the last selected letter, cater for a different number of columns or a different number of hexagons in each column, cater for two players, (turns alternate and the hexagons change a different colour depending on whether they were selected by player one or player two and records of both players selections are maintained.)


",#Go,Go,"package main
 
import (
    rl ""github.com/gen2brain/raylib-go/raylib""
    ""math""
    ""strings""
)
 
type hexagon struct {
    x, y     float32
    letter   rune
    selected bool
}
 
func (h hexagon) points(r float32) []rl.Vector2 {
    res := make([]rl.Vector2, 7)
    for i := 0; i < 7; i++ {
        fi := float64(i)
        res[i].X = h.x + r*float32(math.Cos(math.Pi*fi/3))
        res[i].Y = h.y + r*float32(math.Sin(math.Pi*fi/3))
    }
    return res
}
 
func inHexagon(pts []rl.Vector2, pt rl.Vector2) bool {
    rec := rl.NewRectangle(pts[4].X, pts[4].Y, pts[5].X-pts[4].X, pts[2].Y-pts[4].Y)
    if rl.CheckCollisionPointRec(pt, rec) {
        return true
    }
    if rl.CheckCollisionPointTriangle(pt, pts[2], pts[3], pts[4]) {
        return true
    }
    if rl.CheckCollisionPointTriangle(pt, pts[0], pts[1], pts[5]) {
        return true
    }
    return false
}
 
func DrawLineStrip(points []rl.Vector2, pointsCount int32, color rl.Color) {
    for i := int32(0);  i < pointsCount - 1; i++  {
         rl.DrawLineV(points[i], points[i+1], color)
    }
}
 
func main() {
    screenWidth := int32(600)
    screenHeight := int32(600)
    rl.InitWindow(screenWidth, screenHeight, ""Honeycombs"")
    rl.SetTargetFPS(60)
 
    letters := ""LRDGITPFBVOKANUYCESM""
    runes := []rune(letters)
    var combs [20]hexagon
    var pts [20][]rl.Vector2
 
    x1, y1 := 150, 100
    x2, y2 := 225, 143
    w, h := 150, 87
    r := float32(w / 3)
    for i := 0; i < 20; i++ {
        var x, y int
        if i < 12 {
            x = x1 + (i%3)*w
            y = y1 + (i/3)*h
        } else {
            x = x2 + (i%2)*w
            y = y2 + (i-12)/2*h
        }
        combs[i] = hexagon{float32(x), float32(y), runes[i], false}
        pts[i] = combs[i].points(r)
    }
 
    nChosen := 0
    sChosen := ""Chosen: ""
    lChosen := ""Last chosen: ""
 
    for !rl.WindowShouldClose() {
        rl.BeginDrawing()
        rl.ClearBackground(rl.RayWhite)
        for i, c := range combs {
            ctr := pts[i][0]
            ctr.X -= r
            index := -1
            if key := rl.GetKeyPressed(); key > 0 {
                if key >= 97 && key <= 122 {
                    key -= 32
                }
                index = strings.IndexRune(letters, key)
            } else if rl.IsMouseButtonPressed(rl.MouseLeftButton) {
                pt := rl.Vector2{float32(rl.GetMouseX()), float32(rl.GetMouseY())}
                for i := 0; i < 20; i++ {
                    if inHexagon(pts[i], pt) {
                        index = i
                        break
                    }
                }
            }
            if index >= 0 {
                if !combs[index].selected {
                    combs[index].selected = true
                    nChosen++
                    s := string(combs[index].letter)
                    sChosen += s
                    lChosen = ""Last chosen: "" + s
                    if nChosen == 20 {
                        lChosen += "" (All 20 Chosen!)""
                    }
                }
            }
            if !c.selected {
                rl.DrawPoly(ctr, 6, r-1, 30, rl.Yellow)
            } else {
                rl.DrawPoly(ctr, 6, r-1, 30, rl.Magenta)
            }
            rl.DrawText(string(c.letter), int32(c.x)-5, int32(c.y)-10, 32, rl.Black)
            DrawLineStrip(pts[i], 7, rl.Black)
            rl.DrawText(sChosen, 100, 525, 24, rl.Black)
            rl.DrawText(lChosen, 100, 565, 24, rl.Black)
        }
        rl.EndDrawing()
    }
 
    rl.CloseWindow()
}",3544,124
46799,http://rosettacode.org/wiki/History_variables,History variables,"Storing the history of objects in a program is a common task. 
Maintaining the history of an object in a program has traditionally required programmers either to write specific code for handling the historical data, or to use a library which supports history logging.

History variables are variables in a programming language which store not only their current value, but also the values they have contained in the past. Some existing languages do provide support for history variables. However these languages typically have many limits and restrictions on use of history variables.
 

[http://www.bod.com/index.php?id=3435&objk_id=148050 ""History Variables:
The Semantics, Formal Correctness, and Implementation of History Variables
in an Imperative Programming Language"" by Mallon and Takaoka]

Concept also discussed on LtU and Patents.com.

Task
 
Demonstrate History variable support:

 enable history variable support (if needed) 
 define a history variable
 assign three values
 non-destructively display the history
 recall the three values. 

For extra points, if the language of choice does not support history variables,
demonstrate how this might be implemented.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
    ""sync""
    ""time""
)
 
// data type for history variable (its an int)
type history struct {
    timestamp tsFunc
    hs        []hset
}
 
// data type for timestamp generator
type tsFunc func() time.Time
 
// data type for a ""set"" event
type hset struct {
    int           // new value
    t   time.Time // timestamp
}
 
// newHistory creates a history variable
func newHistory(ts tsFunc) history {
    return history{ts, []hset{{t: ts()}}}
}   
 
// int returns the current value
func (h history) int() int {
    return h.hs[len(h.hs)-1].int
}
 
// set does what you expect and returns the timestamp recorded for the event
func (h *history) set(x int) time.Time {
    t := h.timestamp()
    h.hs = append(h.hs, hset{x, t})
    return t
}
 
// dump displays a complete history
func (h history) dump() {
    for _, hs := range h.hs {
        fmt.Println(hs.t.Format(time.StampNano), hs.int)
    }
}   
 
// recall recalls the value stored in the history variable at time t.
// if the variable had not been created yet, ok is false.
func (h history) recall(t time.Time) (int, /*ok*/ bool) {
    i := sort.Search(len(h.hs), func(i int) bool {
        return h.hs[i].t.After(t)
    })
    if i > 0 {
        return h.hs[i-1].int, true
    }
    return 0, false
}
 
// newTimestamper returns a function that generates unique timestamps.
// Use a single timestamper for multiple history variables to preserve
// an unambiguous sequence of assignments across the multiple history
// variables within a single goroutine.
func newTimestamper() tsFunc {
    var last time.Time
    return func() time.Time {
        if t := time.Now(); t.After(last) {
            last = t
        } else {
            last.Add(1)
        }
        return last
    }
}
 
// newProtectedTimestamper generates unique timestamps for concurrent
// goroutines.
func newProtectedTimestamper() tsFunc {
    var last time.Time
    var m sync.Mutex
    return func() (t time.Time) {
        t = time.Now()
        m.Lock() // m protects last
        if t.After(last) {
            last = t
        } else {
            last.Add(1)
            t = last
        }
        m.Unlock()
        return
    }
}
 
func main() {
    // enable history variable support appropriate for single goroutine.
    ts := newTimestamper()
    // define a history variable
    h := newHistory(ts)
    // assign three values.  (timestamps kept for future reference.)
    ref := []time.Time{h.set(3), h.set(1), h.set(4)}
    // non-destructively display history
    fmt.Println(""History of variable h:"")
    h.dump() 
    // recall the three values.  (this is non-destructive as well, but
    // different than the dump in that values are recalled by time.)
    fmt.Println(""Recalling values:"")
    for _, t := range ref {
        rv, _ := h.recall(t)
        fmt.Println(rv)
    }
}",2873,113
46808,http://rosettacode.org/wiki/Horizontal_sundial_calculations,Horizontal sundial calculations,"Task

Create a program that calculates the hour, sun hour angle, dial hour line angle from 6am to 6pm for an operator entered location.



For example, the user is prompted for a location and inputs the latitude and longitude 4°57′S 150°30′W (4.95°S 150.5°W of Jules Verne's Lincoln Island, aka Ernest Legouve Reef), with a legal meridian of 150°W.

(Note: the ""meridian"" is approximately the same concept as the ""longitude"" - the distinction is that the meridian is used to determine when it is ""noon"" for official purposes. This will typically be slightly different from when the sun appears at its highest location, because of the structure of time zones. For most, but not all, time zones (hour wide zones with hour zero centred on Greenwich), the legal meridian will be an even multiple of 15 degrees.)

Wikipedia: A sundial is a device that measures time by the position of the Sun. In common designs such as the horizontal sundial, the sun casts a shadow from its style (also called its Gnomon, a thin rod or a sharp, straight edge) onto a flat surface marked with lines indicating the hours of the day (also called the dial face or dial plate). As the sun moves across the sky, the shadow-edge progressively aligns with different hour-lines on the plate. Such designs rely on the style being aligned with the axis of the Earth's rotation. Hence, if such a sundial is to tell the correct time, the style must point towards true north (not the north or south magnetic pole) and the style's angle with horizontal must equal the sundial's geographical latitude.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""os""
)
 
func getnum(prompt string) (r float64) {
    fmt.Print(prompt)
    if _, err := fmt.Scan(&r); err != nil {
        fmt.Println(err)
        os.Exit(-1)
    }
    return
}
 
func main() {
    lat := getnum(""Enter latitude       => "")
    lng := getnum(""Enter longitude      => "")
    ref := getnum(""Enter legal meridian => "")
    slat := math.Sin(lat * math.Pi / 180)
    diff := lng - ref
    fmt.Println(""\n    sine of latitude:   "", slat)
    fmt.Println(""    diff longitude:     "", diff)
    fmt.Println(""\nHour, sun hour angle, dial hour line angle from 6am to 6pm"")
    for h := -6.; h <= 6; h++ {
        hra := 15*h - diff
        s, c := math.Sincos(hra * math.Pi / 180)
        hla := math.Atan2(slat*s, c) * 180 / math.Pi
        fmt.Printf(""%2.0f %8.3f %8.3f\n"", h, hra, hla)
    }
}",852,33
46901,http://rosettacode.org/wiki/Hickerson_series_of_almost_integers,Hickerson series of almost integers,"The following function,   due to D. Hickerson,   is said to generate ""Almost integers"" by the

""Almost Integer"" page of Wolfram MathWorld,   (December 31 2013).   (See formula numbered   51.)



The function is:           



h
(
n
)
=



n
!


2
(
ln
⁡

2


)

n
+
1







{\displaystyle h(n)={\operatorname {n} ! \over 2(\ln {2})^{n+1}}}





It is said to produce ""almost integers"" for   n   between   1   and   17.
The purpose of the task is to verify this assertion.

Assume that an ""almost integer"" has either a nine or a zero as its first digit after the decimal point of its decimal string representation



Task

Calculate all values of the function checking and stating which are ""almost integers"".

Note: Use extended/arbitrary precision numbers in your calculation if necessary to ensure you have adequate precision of results as for example:

               h(18) = 3385534663256845326.39...


",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    ln2, _ := new(big.Rat).SetString(""0.6931471805599453094172"")
    h := big.NewRat(1, 2)
    h.Quo(h, ln2)
    var f big.Rat
    var w big.Int
    for i := int64(1); i <= 17; i++ {
        h.Quo(h.Mul(h, f.SetInt64(i)), ln2)
        w.Quo(h.Num(), h.Denom())
        f.Sub(h, f.SetInt(&w))
        y, _ := f.Float64()
        d := fmt.Sprintf(""%.3f"", y)
        fmt.Printf(""n: %2d  h: %18d%s  Nearly integer: %t\n"",
            i, &w, d[1:], d[2] == '0' || d[2] == '9')
    }
}",546,23
46914,http://rosettacode.org/wiki/Horner%27s_rule_for_polynomial_evaluation,Horner's rule for polynomial evaluation,"A fast scheme for evaluating a polynomial such as:

 



−
19
+
7
x
−
4

x

2


+
6

x

3





{\displaystyle -19+7x-4x^{2}+6x^{3}\,}


when

 



x
=
3



{\displaystyle x=3\;}

.
is to arrange the computation as follows:

 



(
(
(
(
0
)
x
+
6
)
x
+
(
−
4
)
)
x
+
7
)
x
+
(
−
19
)



{\displaystyle ((((0)x+6)x+(-4))x+7)x+(-19)\;}


And compute the result from the innermost brackets outwards as in this pseudocode:

coefficients := [-19, 7, -4, 6] # list coefficients of all x^0..x^n in order
x := 3
accumulator := 0
for i in length(coefficients) downto 1 do
    # Assumes 1-based indexing for arrays
    accumulator := ( accumulator * x ) + coefficients[i]
done
# accumulator now has the answer

Task Description

Create a routine that takes a list of coefficients of a polynomial in order of increasing powers of x; together with a value of x to compute its value at, and return the value of the polynomial at that value using Horner's rule.
Cf. Formal power series
",#Go,Go,"package main
 
import ""fmt""
 
func horner(x int64, c []int64) (acc int64) {
    for i := len(c) - 1; i >= 0; i-- {
        acc = acc*x + c[i]
    }
    return
}
 
func main() {
    fmt.Println(horner(3, []int64{-19, 7, -4, 6}))
}",229,14
46916,http://rosettacode.org/wiki/Hilbert_curve,Hilbert curve,"

Task
Produce a graphical or ASCII-art representation of a Hilbert curve of at least order 3.
",#Go,Go,"package main
 
import ""github.com/fogleman/gg""
 
var points []gg.Point
 
const width = 64
 
func hilbert(x, y, lg, i1, i2 int) {
    if lg == 1 {
        px := float64(width-x) * 10
        py := float64(width-y) * 10
        points = append(points, gg.Point{px, py})
        return
    }
    lg >>= 1
    hilbert(x+i1*lg, y+i1*lg, lg, i1, 1-i2)
    hilbert(x+i2*lg, y+(1-i2)*lg, lg, i1, i2)
    hilbert(x+(1-i1)*lg, y+(1-i1)*lg, lg, i1, i2)
    hilbert(x+(1-i2)*lg, y+i2*lg, lg, 1-i1, i2)
}
 
func main() {
    hilbert(0, 0, width, 0, 0)
    dc := gg.NewContext(650, 650)
    dc.SetRGB(0, 0, 0) // Black background
    dc.Clear()
    for _, p := range points {
        dc.LineTo(p.X, p.Y)
    }
    dc.SetHexColor(""#90EE90"") // Light green curve
    dc.SetLineWidth(1)
    dc.Stroke()
    dc.SavePNG(""hilbert.png"")
}",817,35
46986,http://rosettacode.org/wiki/Hofstadter_Figure-Figure_sequences,Hofstadter Figure-Figure sequences,"These two sequences of positive integers are defined as:

 







R
(
1
)



=
1
 
;
 
S
(
1
)
=
2




R
(
n
)



=
R
(
n
−
1
)
+
S
(
n
−
1
)
,

n
>
1.






{\displaystyle {\begin{aligned}R(1)&=1\ ;\ S(1)=2\\R(n)&=R(n-1)+S(n-1),\quad n>1.\end{aligned}}}




The sequence 



S
(
n
)


{\displaystyle S(n)}

 is further defined as the sequence of positive integers not present in 



R
(
n
)


{\displaystyle R(n)}

.

Sequence 



R


{\displaystyle R}

 starts:

   1, 3, 7, 12, 18, ...

Sequence 



S


{\displaystyle S}

 starts:

   2, 4, 5, 6, 8, ...



Task

 Create two functions named ffr and ffs that when given n return R(n) or S(n) respectively.
(Note that R(1) = 1 and S(1) = 2 to avoid off-by-one errors).
 No maximum value for n should be assumed.
 Calculate and show that the first ten values of R are:
 1, 3, 7, 12, 18, 26, 35, 45, 56, and 69
 Calculate and show that the first 40 values of ffr plus the first 960 values of ffs include all the integers from 1 to 1000 exactly once.


References

 Sloane's A005228 and A030124.
 Wolfram MathWorld
 Wikipedia: Hofstadter Figure-Figure sequences.

",#Go,Go,"package main
 
import ""fmt""
 
var ffr, ffs func(int) int
 
// The point of the init function is to encapsulate r and s.  If you are
// not concerned about that or do not want that, r and s can be variables at
// package level and ffr and ffs can be ordinary functions at package level.
func init() {
    // task 1, 2
    r := []int{0, 1}
    s := []int{0, 2}
 
    ffr = func(n int) int {
        for len(r) <= n {
            nrk := len(r) - 1       // last n for which r(n) is known
            rNxt := r[nrk] + s[nrk] // next value of r:  r(nrk+1)
            r = append(r, rNxt)     // extend sequence r by one element
            for sn := r[nrk] + 2; sn < rNxt; sn++ {
                s = append(s, sn)   // extend sequence s up to rNext
            }
            s = append(s, rNxt+1)   // extend sequence s one past rNext
        }
        return r[n]
    }
 
    ffs = func(n int) int {
        for len(s) <= n {
            ffr(len(r))
        }
        return s[n]
    }
}
 
func main() {
    // task 3
    for n := 1; n <= 10; n++ {
        fmt.Printf(""r(%d): %d\n"", n, ffr(n))
    }
    // task 4
    var found [1001]int
    for n := 1; n <= 40; n++ {
        found[ffr(n)]++
    }
    for n := 1; n <= 960; n++ {
        found[ffs(n)]++
    }
    for i := 1; i <= 1000; i++ {
        if found[i] != 1 {
            fmt.Println(""task 4: FAIL"")
            return
        }
    }
    fmt.Println(""task 4: PASS"")
}",1425,56
47043,"http://rosettacode.org/wiki/Hofstadter-Conway_$10,000_sequence","Hofstadter-Conway $10,000 sequence","The definition of the sequence is colloquially described as:

   Starting with the list [1,1],
   Take the last number in the list so far: 1, I'll call it x.
   Count forward x places from the beginning of the list to find the first number to add (1)
   Count backward x places from the end of the list to find the second number to add (1)
   Add the two indexed numbers from the list and the result becomes the next number in the list (1+1)
   This would then produce [1,1,2] where 2 is the third element of the sequence.

Note that indexing for the description above starts from alternately the left and right ends of the list and starts from an index of one.

A less wordy description of the sequence is:

   a(1)=a(2)=1
   a(n)=a(a(n-1))+a(n-a(n-1))

The sequence begins:

   1, 1, 2, 2, 3, 4, 4, 4, 5, ...

Interesting features of the sequence are that:

   a(n)/n   tends to   0.5   as   n   grows towards infinity.
   a(n)/n   where   n   is a power of   2   is   0.5
   For   n>4   the maximal value of   a(n)/n   between successive powers of 2 decreases.



The sequence is so named because John Conway offered a prize of $10,000 to the first person who could
find the first position,   p   in the sequence where

   │a(n)/n│ < 0.55  for all  n > p

It was later found that Hofstadter had also done prior work on the sequence.

The 'prize' was won quite quickly by Dr. Colin L. Mallows who proved the properties of the sequence and allowed him to find the value of   n   (which is much smaller than the 3,173,375,556 quoted in the NYT article).



Task

   Create a routine to generate members of the Hofstadter-Conway $10,000 sequence.
   Use it to show the maxima of   a(n)/n   between successive powers of two up to   2**20
   As a stretch goal:   compute the value of   n   that would have won the prize and confirm it is true for   n   up to 2**20


Also see

   Conways Challenge Sequence, Mallows' own account.
   Mathworld Article.

",#Go,Go,"package main
 
import (
    ""fmt""
)
 
func main() {
    a := []int{0, 1, 1} // ignore 0 element. work 1 based.
    x := 1  // last number in list
    n := 2  // index of last number in list = len(a)-1
    mallow := 0
    for p := 1; p < 20; p++ {
        max := 0.
        for nextPot := n*2; n < nextPot; {
            n = len(a) // advance n
            x = a[x]+a[n-x]
            a = append(a, x)
            f := float64(x)/float64(n)
            if f > max {
                max = f
            }
            if f >= .55 {
                mallow = n
            }
        }
        fmt.Printf(""max between 2^%d and 2^%d was %f\n"", p, p+1, max)
    }
    fmt.Println(""winning number"", mallow)
}",699,29
47066,http://rosettacode.org/wiki/Holidays_related_to_Easter,Holidays related to Easter,"Task

Calculate the dates of:

   Easter
   Ascension Thursday
   Pentecost
   Trinity Sunday
   Corpus Christi feast (for Catholic)
   All Saints' Sunday (for Orthodox)


As an example, calculate for the first year of each century from;

   years     400   to   2100 CE   and for 
   years   2010   to   2020 CE.
Note

From the year 325 CE on,   Easter Sunday   has been defined as the first Sunday after the first full moon on or after the day of the March equinox. However, the actual astronomical values for the moments of the full moon and equinox are not used. Instead, approximations are used, the first one being that the equinox is assumed to fall on March 21st every year. The tracking of the moon phases is similarly done with relatively straightforward arithmetic (compared to the sort required for astronomical accuracy) which amounts to maintaining a lunisolar calendar in parallel to our standard purely-solar one.

When Pope Gregory reformed the Catholic calendar in 1582 CE, the drifting of Easter with respect to the seasons was the driving motivation, and the rules for determining it (called the computus) were altered to correct that drift. Catholic nations adopted both the new calendar and the new computus right away, while Western Protestant nations adopted them more gradually over the next 350 years or so. Eventually, even nations dominated by the Eastern Orthodox church adopted a similar calendar reform (the Revised Julian calendar), so pretty much the whole world agrees on what day it is for civil purposes. But the Eastern churches never adopted the corresponding Easter rule changes; they still use the original Julian calendar and computus to determine the date of what is known in the West as ""Orthodox Easter"". Therefore, your output should indicate which computus was used to calculate the dates and, at least for historical dates where the calendar can't be assumed or is location-dependent, which calendar those dates are given in.

You may find algorithms on the Computus Wikipedia page. Some of the results:

In the year 400 CE, Easter Sunday was April 1st (in the contemporary Julian calendar), making Ascension Thursday May 10th and Pentecost May 20th. It is ahistorical to give a date so far back for either Trinity Sunday or Corpus Christi, neither of which were observed until centuries later, but they would have been May 27th and 31st. If you extend the modern civil calendar back that far, those days are instead assigned the subsequent dates: Easter on April 2nd, Ascension on May 11th, Pentecost on May 21st.

Skipping forward to the year 2100 CE, assuming the rules don't change between now and then, the Western churches will observe Easter on March 28, Ascension Thursday May 6th, Pentecost May 16th, Trinity Sunday May 23rd and Corpus Christi May 27th. Heading East, the Orthodox rules place Easter on April 18 in the original Julian calendar; the corresponding civil date is May 2nd. That puts the Ascension on June 10th and Pentecost June 20th. Orthodox Trinity Sunday is the same day as Pentecost, but they observe All Saints' Sunday the following week, June 27th. Corpus Christi is a purely Catholic date that has no Orthodox version.

Test values of Easter dates



 Year

 Orthodox

 Catholic

 Calendar


400

01 Apr

 —

Jul.


800

19 Apr

 —

Jul.


1200

09 Apr

 —

Jul.


2000

30 Apr

23 Apr

Gr.


2020

19 Apr

12 Apr

Gr.


",#Go,Go,"package main
 
import (
    ""fmt""
    ""time""
)
 
type holiday struct {
    time.Time
}
 
func easter(y int) holiday {
    c := y / 100
    n := mod(y, 19)
    i := mod(c-c/4-(c-(c-17)/25)/3+19*n+15, 30)
    i -= (i / 28) * (1 - (i/28)*(29/(i+1))*((21-n)/11))
    l := i - mod(y+y/4+i+2-c+c/4, 7)
    m := 3 + (l+40)/44
    d := l + 28 - 31*(m/4)
    return holiday{time.Date(y, time.Month(m), d, 0, 0, 0, 0, time.UTC)}
}
 
func mod(a, n int) int {
    r := a % n
    if r < 0 {
        return r + n
    }
    return r
}
 
func (h holiday) addDays(d int) holiday {
    return holiday{h.Add(time.Duration(d) * 24 * time.Hour)}
}
 
type easterRelated struct {
    easter, ascension, pentecost, trinity, corpusChristi holiday
}
 
func newEasterRelated(y int) (er easterRelated) {
    er.easter = easter(y)
    er.ascension = er.easter.addDays(39)
    er.pentecost = er.ascension.addDays(10)
    er.trinity = er.pentecost.addDays(7)
    er.corpusChristi = er.trinity.addDays(4)
    return
}
 
func (er easterRelated) print() {
    const wdmdm = "": Mon _2 Jan""
    fmt.Printf(""%4d %s, %s, %s, %s, %s\n"",
        er.easter.Year(),
        er.easter.Format(""Easter""+wdmdm),
        er.ascension.Format(""Ascension""+wdmdm),
        er.pentecost.Format(""Pentecost""+wdmdm),
        er.trinity.Format(""Trinity""+wdmdm),
        er.corpusChristi.Format(""Corpus""+wdmdm))
}
 
func main() {
    fmt.Println(""Christian holidays, related to Easter, "" +
        ""for each centennial from 400 to 2100 CE:"")
    for y := 400; y <= 2100; y += 100 {
        newEasterRelated(y).print()
    }
    fmt.Println(""\nChristian holidays, related to Easter, "" +
        ""for years from 2010 to 2020 CE:"")
    for y := 2010; y <= 2020; y++ {
        newEasterRelated(y).print()
    }
}",1751,70
47125,http://rosettacode.org/wiki/Here_document,Here document,"A   here document   (or ""heredoc"")   is a way of specifying a text block, preserving the line breaks, indentation and other whitespace within the text.

Depending on the language being used, a   here document   is constructed using a command followed by ""<<"" (or some other symbol) followed by a token string.

The text block will then start on the next line, and will be followed by the chosen token at the beginning of the following line, which is used to mark the end of the text block.



Task

Demonstrate the use of   here documents   within the language.

Related task

   Documentation

",#Go,Go,"var m = `    leading spaces
 
and blank lines`",46,3
47175,http://rosettacode.org/wiki/HTTP,HTTP,"Task

Access and print a URL's content (the located resource) to the console.

There is a separate task for HTTPS Requests.



",#Go,Go," 
package main
 
import (
    ""io""
    ""log""
    ""net/http""
    ""os""
)
 
func main() {
    r, err := http.Get(""http://rosettacode.org/robots.txt"")
    if err != nil {
        log.Fatalln(err)
    }
    io.Copy(os.Stdout, r.Body)
}
 ",232,18
47249,http://rosettacode.org/wiki/Hello_world/Web_server,Hello world/Web server,"The browser is the new GUI !



Task

Serve our standard text   Goodbye, World!   to   http://localhost:8080/   so that it can be viewed with a web browser.

The provided solution must start or implement a server that accepts multiple client connections and serves text as requested.

Note that starting a web browser or opening a new window with this URL
is not part of the task.

Additionally, it is permissible to serve the provided page as a plain text file (there is no requirement to serve properly formatted HTML here).

The browser will generally do the right thing with simple text like this.



",#Go,Go,"package main
 
import (
  ""fmt""
  ""log""
  ""net/http""
)
 
func main() {
  http.HandleFunc(""/"", func(w http.ResponseWriter, req *http.Request) {
    fmt.Fprintln(w, ""Goodbye, World!"")
  })
  log.Fatal(http.ListenAndServe("":8080"", nil))
}
 ",237,15
47307,http://rosettacode.org/wiki/Hello_world/Standard_error,Hello world/Standard error,"Hello world/Standard error is part of Short Circuit's Console Program Basics selection.
A common practice in computing is to send error messages
to a different output stream than normal text console messages.

The normal messages print to what is called ""standard output"" or ""standard out"".

The error messages print to ""standard error"".

This separation can be used to redirect error messages to a different place than normal messages.



Task

Show how to print a message to standard error by printing     Goodbye, World!     on that stream.



",#Go,Go,"package main
func main() { println(""Goodbye, World!"") }",55,2
47347,http://rosettacode.org/wiki/Heronian_triangles,Heronian triangles,"Hero's formula for the area of a triangle given the length of its three sides    a,   b,   and   c   is given by:

 



A
=


s
(
s
−
a
)
(
s
−
b
)
(
s
−
c
)


,


{\displaystyle A={\sqrt {s(s-a)(s-b)(s-c)}},}


where   s   is half the perimeter of the triangle; that is,

 



s
=



a
+
b
+
c

2


.


{\displaystyle s={\frac {a+b+c}{2}}.}



Heronian triangles
are triangles whose sides and area are all integers.

 An example is the triangle with sides   3, 4, 5   whose area is   6   (and whose perimeter is   12). 


Note that any triangle whose sides are all an integer multiple of   3, 4, 5;   such as   6, 8, 10,   will also be a Heronian triangle.

Define a Primitive Heronian triangle as a Heronian triangle where the greatest common divisor
of all three sides is   1   (unity).

This will exclude, for example, triangle   6, 8, 10.



Task

 Create a named function/method/procedure/... that implements Hero's formula.
 Use the function to generate all the primitive Heronian triangles with sides <= 200.
 Show the count of how many triangles are found.
 Order the triangles by first increasing area, then by increasing perimeter, then by increasing maximum side lengths
 Show the first ten ordered triangles in a table of sides, perimeter, and area.
 Show a similar ordered table for those triangles with area = 210


Show all output here.

Note: when generating triangles it may help to restrict 



a
<=
b
<=
c


{\displaystyle a<=b<=c}


",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""sort""
)
 
const (
    n = 200
    header = ""\nSides          P   A""
)
 
func gcd(a, b int) int {
    leftover := 1
    var dividend, divisor int
    if (a > b) { dividend, divisor = a, b } else { dividend, divisor = b, a }
 
    for (leftover != 0) {
        leftover = dividend % divisor
        if (leftover > 0) {
            dividend, divisor = divisor, leftover
        }
    }
    return divisor
}
 
func is_heron(h float64) bool {
    return h > 0 && math.Mod(h, 1) == 0.0
}
 
// by_area_perimeter implements sort.Interface for [][]int based on the area first and perimeter value
type by_area_perimeter [][]int
 
func (a by_area_perimeter) Len() int           { return len(a) }
func (a by_area_perimeter) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a by_area_perimeter) Less(i, j int) bool {
    return a[i][4] < a[j][4] || a[i][4] == a[j][4] && a[i][3] < a[j][3]
}
 
func main() {
    var l [][]int
    for c := 1; c <= n; c++ {
        for b := 1; b <= c; b++ {
            for a := 1; a <= b; a++ {
                if (gcd(gcd(a, b), c) == 1) {
                    p := a + b + c
                    s := float64(p) / 2.0
                    area := math.Sqrt(s * (s - float64(a)) * (s - float64(b)) * (s - float64(c)))
                    if (is_heron(area)) {
                        l = append(l, []int{a, b, c, p, int(area)})
                    }
                }
            }
        }
    }
 
    fmt.Printf(""Number of primitive Heronian triangles with sides up to %d: %d"", n, len(l))
    sort.Sort(by_area_perimeter(l))
    fmt.Printf(""\n\nFirst ten when ordered by increasing area, then perimeter:"" + header)
    for i := 0; i < 10; i++ { fmt.Printf(""\n%3d"", l[i]) }
 
    a := 210
    fmt.Printf(""\n\nArea = %d%s"", a, header)
    for _, it := range l  {
        if (it[4] == a) {
            fmt.Printf(""\n%3d"", it)
        }
    }
}",1915,70
47434,http://rosettacode.org/wiki/Hofstadter_Q_sequence,Hofstadter Q sequence,"Hofstadter Q sequence


 







Q
(
1
)



=
Q
(
2
)
=
1
,




Q
(
n
)



=
Q


(


n
−
Q
(
n
−
1
)


)


+
Q


(


n
−
Q
(
n
−
2
)


)


,

n
>
2.






{\displaystyle {\begin{aligned}Q(1)&=Q(2)=1,\\Q(n)&=Q{\big (}n-Q(n-1){\big )}+Q{\big (}n-Q(n-2){\big )},\quad n>2.\end{aligned}}}




It is defined like the Fibonacci sequence, but whereas the next term in the Fibonacci sequence is the sum of the previous two terms, in the Q sequence the previous two terms tell you how far to go back in the Q sequence to find the two numbers to sum to make the next term of the sequence.



Task

 Confirm and display that the first ten terms of the sequence are: 1, 1, 2, 3, 3, 4, 5, 5, 6, and 6 
 Confirm and display that the 1000th term is:   502


Optional extra credit
 Count and display how many times a member of the sequence is less than its preceding term for terms up to and including the 100,000th term.
 Ensure that the extra credit solution   safely   handles being initially asked for an nth term where   n   is large.

(This point is to ensure that caching and/or recursion limits, if it is a concern, is correctly handled).



",#Go,Go,"package main
 
import ""fmt""
 
var m map[int]int
 
func initMap() {
    m = make(map[int]int)
    m[1] = 1
    m[2] = 1
}
 
func q(n int) (r int) {
    if r = m[n]; r == 0 {
        r = q(n-q(n-1)) + q(n-q(n-2))
        m[n] = r
    }
    return
}
 
func main() {
    initMap()
    // task
    for n := 1; n <= 10; n++ {
        showQ(n)
    }
    // task
    showQ(1000)
    // extra credit
    count, p := 0, 1
    for n := 2; n <= 1e5; n++ {
        qn := q(n)
        if qn < p {
            count++
        }
        p = qn
    }
    fmt.Println(""count:"", count)
    // extra credit
    initMap()
    showQ(1e6)
}
 
func showQ(n int) {
    fmt.Printf(""Q(%d) = %d\n"", n, q(n))
}",681,46
47953,http://rosettacode.org/wiki/Higher-order_functions,Higher-order functions,"Task

Pass a function     as an argument     to another function.



Related task

   First-class functions

",#Go,Go,"package main
import ""fmt""
 
func func1(f func(string) string) string { return f(""a string"") }
func func2(s string) string { return ""func2 called with "" + s }
func main() { fmt.Println(func1(func2)) }",199,6
48145,http://rosettacode.org/wiki/Hello_world/Line_printer,Hello world/Line printer,"Task

Cause a line printer attached to the computer to print a line containing the message:    Hello World! 



Note

A line printer is not the same as standard output.

A   line printer   was an older-style printer which prints one line at a time to a continuous ream of paper.

With some systems, a line printer can be any device attached to an appropriate port (such as a parallel port).



",#Go,Go,"package main
 
import (
	""fmt""
	""os""
)
 
func main() {
	lp0, err := os.Create(""/dev/lp0"")
 
	if err != nil {
		panic(err)
	}
 
	defer lp0.Close()
 
	fmt.Fprintln(lp0, ""Hello World!"")
}",184,18
48265,http://rosettacode.org/wiki/Hash_join,Hash join,"An inner join is an operation that combines two data tables into one table, based on matching column values. The simplest way of implementing this operation is the nested loop join algorithm, but a more scalable alternative is the hash join algorithm.

Task[edit]
Implement the ""hash join"" algorithm, and demonstrate that it passes the test-case listed below.

You should represent the tables as data structures that feel natural in your programming language.

Guidance
The ""hash join"" algorithm consists of two steps:

 Hash phase: Create a multimap from one of the two tables, mapping from each join column value to all the rows that contain it.

 The multimap must support hash-based lookup which scales better than a simple linear search, because that's the whole point of this algorithm.
 Ideally we should create the multimap for the smaller table, thus minimizing its creation time and memory size.
 Join phase: Scan the other table, and find matching rows by looking in the multimap created before.


In pseudo-code, the algorithm could be expressed as follows:

let A = the first input table (or ideally, the larger one)
let B = the second input table (or ideally, the smaller one)
let jA = the join column ID of table A
let jB = the join column ID of table B
let MB = a multimap for mapping from single values to multiple rows of table B (starts out empty)
let C = the output table (starts out empty)

for each row b in table B:
   place b in multimap MB under key b(jB)

for each row a in table A:
   for each row b in multimap MB under key a(jA):
      let c = the concatenation of row a and row b
      place row c in table C

Test-case


 Input

 Output





 A =




 Age 
 Name


 27 
 Jonah


 18 
 Alan


 28 
 Glory


 18 
 Popeye


 28 
 Alan




 B =




 Character 
 Nemesis


 Jonah 
 Whales


 Jonah 
 Spiders


 Alan 
 Ghosts


 Alan 
 Zombies


 Glory 
 Buffy



 jA =

 Name (i.e. column 1)

 jB =

 Character (i.e. column 0)





 A.Age 
 A.Name 
 B.Character 
 B.Nemesis


 27 
 Jonah 
 Jonah 
 Whales


 27 
 Jonah 
 Jonah 
 Spiders


 18 
 Alan 
 Alan 
 Ghosts


 18 
 Alan 
 Alan 
 Zombies


 28 
 Glory 
 Glory 
 Buffy


 28 
 Alan 
 Alan 
 Ghosts


 28 
 Alan 
 Alan 
 Zombies


The order of the rows in the output table is not significant.

If you're using numerically indexed arrays to represent table rows (rather than referring to columns by name), you could represent the output rows in the form [[27, ""Jonah""], [""Jonah"", ""Whales""]].



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    tableA := []struct {
        value int
        key   string
    }{
        {27, ""Jonah""}, {18, ""Alan""}, {28, ""Glory""}, {18, ""Popeye""},
        {28, ""Alan""},
    }
    tableB := []struct {
        key   string
        value string
    }{
        {""Jonah"", ""Whales""}, {""Jonah"", ""Spiders""},
        {""Alan"", ""Ghosts""}, {""Alan"", ""Zombies""}, {""Glory"", ""Buffy""},
    }
    // hash phase
    h := map[string][]int{}
    for i, r := range tableA {
        h[r.key] = append(h[r.key], i)
    }
    // join phase
    for _, x := range tableB {
        for _, a := range h[x.key] {
            fmt.Println(tableA[a], x)
        }
    }
}",674,31
48339,http://rosettacode.org/wiki/Hello_world/Newbie,Hello world/Newbie,"Task

Guide a new user of a language through the steps necessary
to install the programming language and selection of a text editor if needed,
to run the languages' example in the Hello world/Text task.

 Assume the language-newbie is a programmer in another language.
 Assume the language-newbie is competent in installing software for the platform.
 Assume the language-newbie can use one simple text editor for the OS/platform, (but that may not necessarily be a particular one if the installation needs a particular editor).
 Refer to, (and link to), already existing documentation as much as possible (but provide a summary here).
 Remember to state where to view the output.
 If particular IDE's or editors are required that are not standard, then point to/explain their installation too.


Note:
 If it is more natural for a language to give output via a GUI or to a file etc, then use that method of output rather than as text to a terminal/command-line, but remember to give instructions on how to view the output generated.
 You may use sub-headings if giving instructions for multiple platforms.

",#Go,Go,"$ cat >hello.go
",16,2
48380,http://rosettacode.org/wiki/Harmonic_series,Harmonic series,"

 This page uses content from Wikipedia. The original article was at Harmonic number. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In mathematics, the n-th harmonic number is the sum of the reciprocals of the first n natural numbers:

   Hn = 1 + 1/2 + 1/3 + ... + 1/n

The series of harmonic numbers thus obtained is often loosely referred to as the harmonic series.

Harmonic numbers are closely related to the Riemann zeta function, and roughly approximate the natural logarithm function; differing by γ (lowercase Gamma), the Euler–Mascheroni constant.

The harmonic series is divergent, albeit quite slowly, and grows toward infinity.



Task
 Write a function (routine, procedure, whatever it may be called in your language) to generate harmonic numbers.
 Use that procedure to show the values of the first 20 harmonic numbers.
 Find and show the position in the series of the first value greater than the integers 1 through 5


Stretch
 Find and show the position in the series of the first value greater than the integers 6 through 10


Related
 Egyptian fractions

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func harmonic(n int) *big.Rat {
    sum := new(big.Rat)
    for i := int64(1); i <= int64(n); i++ {
        r := big.NewRat(1, i)
        sum.Add(sum, r)
    }
    return sum
}
 
func main() {
    fmt.Println(""The first 20 harmonic numbers and the 100th, expressed in rational form, are:"")
    numbers := make([]int, 21)
    for i := 1; i <= 20; i++ {
        numbers[i-1] = i
    }
    numbers[20] = 100
    for _, i := range numbers {
        fmt.Printf(""%3d : %s\n"", i, harmonic(i))
    }
 
    fmt.Println(""\nThe first harmonic number to exceed the following integers is:"")
    const limit = 10
    for i, n, h := 1, 1, 0.0; i <= limit; n++ {
        h += 1.0 / float64(n)
        if h > float64(i) {
            fmt.Printf(""integer = %2d  -> n = %6d  ->  harmonic number = %9.6f (to 6dp)\n"", i, n, h)
            i++
        }
    }
}",892,37
48526,http://rosettacode.org/wiki/Halt_and_catch_fire,Halt and catch fire,"Task
Create a program that crashes as soon as possible, with as few lines of code as possible. Be smart and don't damage your computer, ok?

The code should be syntactically valid. It should be possible to insert [a subset of] your submission into another program, presumably to help debug it, or perhaps for use when an internal corruption has been detected and it would be dangerous and irresponsible to continue.

References
 Wikipedia: Halt and Catch Fire


Related Tasks
 Program termination

",#Go,Go,"package main; import ""fmt""; func main(){a, b := 0, 0; fmt.Println(a/b)}",71,1
48575,http://rosettacode.org/wiki/Handle_a_signal,Handle a signal,"Most operating systems provide interrupt facilities, sometimes called signals either generated by the user or as a result of program failure or reaching a limit like file space.
Unhandled signals generally terminate a program in a disorderly manner.
Signal handlers are created so that the program behaves in a well-defined manner upon receipt of a signal.

Task

Provide a program that displays an integer on each line of output at the rate of about one per half second.
Upon receipt of the SIGINT signal (often generated by the user typing ctrl-C ( or better yet, SIGQUIT ctrl-\ )) the program will cease outputting integers, output the number of seconds the program has run, and then the program will quit.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""os""
    ""os/signal""
    ""time""
)
 
func main() {
    start := time.Now()
    k := time.Tick(time.Second / 2)
    sc := make(chan os.Signal, 1)
    signal.Notify(sc, os.Interrupt)
    for n := 1; ; {
        // not busy waiting, this blocks until one of the two
        // channel operations is possible
        select {
        case <-k:
            fmt.Println(n)
            n++
        case <-sc:
            fmt.Printf(""Ran for %f seconds.\n"",
                time.Now().Sub(start).Seconds())
            return
        }
    }
}",572,28
48583,http://rosettacode.org/wiki/Hash_from_two_arrays,Hash from two arrays,"Task

Using two Arrays of equal length, create a Hash object
where the elements from one array (the keys) are linked
to the elements of the other (the values)



Related task

   Associative arrays/Creation

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    keys := []string{""a"", ""b"", ""c""}
    vals := []int{1, 2, 3}
    hash := map[string]int{}
    for i, key := range keys {
        hash[key] = vals[i]
    }
    fmt.Println(hash)
}",224,13
48648,http://rosettacode.org/wiki/Hello_world/Newline_omission,Hello world/Newline omission,"Some languages automatically insert a newline after outputting a string, unless measures are taken to prevent its output.



Task

Display the string   Goodbye, World!   without a trailing newline.



Related tasks

   Hello world/Graphical
   Hello world/Line Printer
   Hello world/Standard error
   Hello world/Text

",#Go,Go,"package main
 
import ""fmt""
 
func main() { fmt.Print(""Goodbye, World!"") }",74,5
48693,http://rosettacode.org/wiki/GUI/Maximum_window_dimensions,GUI/Maximum window dimensions,"The task is to determine the maximum height and width of a window that can fit within the physical display area of the screen without scrolling.

This is effectively the screen size (not the total desktop area, which could be bigger than the screen display area) in pixels minus any adjustments for window decorations and menubars.

The idea is to determine the physical display parameters for the maximum height and width of the usable display area in pixels (without scrolling).

The values calculated should represent the usable desktop area of a window maximized to fit the the screen.



Considerations

--- Multiple Monitors

For multiple monitors, the values calculated should represent the size of the usable display area on the monitor which is related to the task (i.e.:   the monitor which would display a window if such instructions were given).

--- Tiling Window Managers
For a tiling window manager, the values calculated should represent the maximum height and width of the display area of the maximum size a window can be created (without scrolling). This would typically be a full screen window (minus any areas occupied by desktop bars), unless the window manager has restrictions that prevents the creation of a full screen window, in which case the values represent the usable area of the desktop that occupies the maximum permissible window size (without scrolling).



",#Go,Go,"package main
 
import (
    ""fmt""
    ""github.com/go-vgo/robotgo""
)
 
func main() {
    w, h := robotgo.GetScreenSize()
    fmt.Printf(""Screen size: %d x %d\n"", w, h)
    fpid, err := robotgo.FindIds(""firefox"")
    if err == nil && len(fpid) > 0 {
        pid := fpid[0]
        robotgo.ActivePID(pid)
        robotgo.MaxWindow(pid)
        _, _, w, h = robotgo.GetBounds(pid)
        fmt.Printf(""Max usable : %d x %d\n"", w, h)
    }
}",435,19
48943,http://rosettacode.org/wiki/GUI_enabling/disabling_of_controls,GUI enabling/disabling of controls,"In addition to fundamental GUI component interaction, an application should
dynamically enable and disable GUI components, to give some guidance to the
user, and prohibit (inter)actions which are inappropriate in the current state
of the application.



Task

Similar to the task GUI component interaction, write a program
that presents a form with three components to the user:

   a numeric input field (""Value"") 
   a button   (""increment"")
   a button   (""decrement"")


The field is initialized to zero.
The user may manually enter a new value into the field,
increment its value with the ""increment"" button,
or decrement the value with the ""decrement"" button.

The input field should be enabled only when its value is zero.
The ""increment"" button only as long as the field's value is less then 10:
When the value 10 is reached, the button should go into a disabled state.
Analogously, the ""decrement"" button should be enabled only as long as
the value is greater than zero.

Effectively, the user can now either increment up to 10, or down to zero.
Manually entering values outside that range is still legal,
but the buttons should reflect that and enable/disable accordingly.



",#Go,Go,"package main
 
import (
    ""github.com/gotk3/gotk3/gtk""
    ""log""
    ""math/rand""
    ""strconv""
    ""time""
)
 
func validateInput(window *gtk.Window, str string) (int64, bool) {
    i, err := strconv.ParseInt(str, 10, 64)
    if err != nil {
        dialog := gtk.MessageDialogNew(
            window,
            gtk.DIALOG_MODAL,
            gtk.MESSAGE_ERROR,
            gtk.BUTTONS_OK,
            ""Invalid value"",
        )
        dialog.Run()
        dialog.Destroy()
        return 0, false
    }
    return i, true
}
 
func check(err error, msg string) {
    if err != nil {
        log.Fatal(msg, err)
    }
}
 
func processState(i int64, entry *gtk.Entry, ib, db *gtk.Button) {
    if i == 0 {
        entry.SetSensitive(true)
    } else {
        entry.SetSensitive(false)
    }
    if i < 10 {
        ib.SetSensitive(true)
    } else {
        ib.SetSensitive(false)
    }
    if i > 0 {
        db.SetSensitive(true)
    } else {
        db.SetSensitive(false)
    }
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    gtk.Init(nil)
 
    window, err := gtk.WindowNew(gtk.WINDOW_TOPLEVEL)
    check(err, ""Unable to create window:"")
    window.SetTitle(""Rosetta Code"")
    window.SetPosition(gtk.WIN_POS_CENTER)
    window.Connect(""destroy"", func() {
        gtk.MainQuit()
    })
 
    box, err := gtk.BoxNew(gtk.ORIENTATION_HORIZONTAL, 1)
    check(err, ""Unable to create box:"")
    box.SetBorderWidth(1)
 
    label, err := gtk.LabelNew(""Value:"")
    check(err, ""Unable to create label:"")
 
    entry, err := gtk.EntryNew()
    check(err, ""Unable to create entry:"")
    entry.SetText(""0"") // initialize to zero
    entry.SetSensitive(true)
 
    // button to increment
    ib, err := gtk.ButtonNewWithLabel(""Increment"")
    check(err, ""Unable to create increment button:"")
    ib.SetSensitive(true)
 
    // button to decrement
    db, err := gtk.ButtonNewWithLabel(""Decrement"")
    check(err, ""Unable to create decrement button:"")
    db.SetSensitive(false)
 
    entry.Connect(""activate"", func() {
        // read and validate the entered value
        str, _ := entry.GetText()
        i, ok := validateInput(window, str)
        if !ok {
            entry.SetText(""0"")
        }
        processState(i, entry, ib, db)
    })
 
    ib.Connect(""clicked"", func() {
        // read the entered value
        str, _ := entry.GetText()
        i, _ := validateInput(window, str)
        i++
        entry.SetText(strconv.FormatInt(i, 10))
        processState(i, entry, ib, db)
    })
 
    db.Connect(""clicked"", func() {
        // read the entered value
        str, _ := entry.GetText()
        i, _ := validateInput(window, str)
        i--
        entry.SetText(strconv.FormatInt(i, 10))
        processState(i, entry, ib, db)
    })
 
    box.PackStart(label, false, false, 2)
    box.PackStart(entry, false, false, 2)
    box.PackStart(ib, false, false, 2)
    box.PackStart(db, false, false, 2)
    window.Add(box)
 
    window.ShowAll()
    gtk.Main()
}",2986,122
48954,http://rosettacode.org/wiki/Harshad_or_Niven_series,Harshad or Niven series,"The Harshad or Niven numbers are positive integers ≥ 1 that are divisible by the sum of their digits.

For example,   42   is a Harshad number as   42   is divisible by   (4 + 2)   without remainder.

Assume that the series is defined as the numbers in increasing order.



Task

The task is to create a function/method/procedure to generate successive members of the Harshad sequence.

Use it to:

   list the first 20 members of the sequence,   and
   list the first Harshad number greater than 1000.


Show your output here.



Related task
   Increasing gaps between consecutive Niven numbers


See also
    OEIS: A005349

",#Go,Go,"package main
 
import ""fmt""
 
type is func() int
 
func newSum() is {
    var ms is
    ms = func() int {
        ms = newSum()
        return ms()
    }
    var msd, d int
    return func() int {
        if d < 9 {
            d++
        } else {
            d = 0
            msd = ms()
        }
        return msd + d
    }
}
 
func newHarshard() is {
    i := 0
    sum := newSum()
    return func() int {
        for i++; i%sum() != 0; i++ {
        }
        return i
    }
}
 
func main() {
    h := newHarshard()
    fmt.Print(h())
    for i := 1; i < 20; i++ {
        fmt.Print("" "", h())
    }
    fmt.Println()
    h = newHarshard()
    n := h()
    for ; n <= 1000; n = h() {
    }
    fmt.Println(n)
}",716,47
49094,http://rosettacode.org/wiki/Haversine_formula,Haversine formula,"

 This page uses content from Wikipedia. The original article was at Haversine formula. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The haversine formula is an equation important in navigation, giving great-circle distances between two points on a sphere from their longitudes and latitudes.

It is a special case of a more general formula in spherical trigonometry, the law of haversines, relating the sides and angles of spherical ""triangles"".



Task

Implement a great-circle distance function, or use a library function,
to show the great-circle distance between:

 Nashville International Airport (BNA)   in Nashville, TN, USA,   which is: 
   N 36°7.2',   W 86°40.2'     (36.12,   -86.67)           -and-

 Los Angeles International Airport (LAX)  in Los Angeles, CA, USA,   which is:
   N 33°56.4',  W 118°24.0'    (33.94,  -118.40)   



User Kaimbridge clarified on the Talk page:

 -- 6371.0 km is the authalic radius based on/extracted from surface area;
 -- 6372.8 km is an approximation of the radius of the average circumference
    (i.e., the average great-elliptic or great-circle radius), where the
     boundaries are the meridian (6367.45 km) and the equator (6378.14 km).

Using either of these values results, of course, in differing distances:

 6371.0 km -> 2886.44444283798329974715782394574671655 km;
 6372.8 km -> 2887.25995060711033944886005029688505340 km;
 (results extended for accuracy check:  Given that the radii are only
  approximations anyways, .01' ≈ 1.0621333 km and .001"" ≈ .00177 km,
  practical precision required is certainly no greater than about
  .0000001——i.e., .1 mm!)

As distances are segments of great circles/circumferences, it is
recommended that the latter value (r = 6372.8 km) be used (which
most of the given solutions have already adopted, anyways). 

Most of the examples below adopted Kaimbridge's recommended value of
6372.8 km for the earth radius. However, the derivation of this
ellipsoidal quadratic mean radius
is wrong (the averaging over azimuth is biased). When applying these
examples in real applications, it is better to use the
mean earth radius,
6371 km. This value is recommended by the International Union of
Geodesy and Geophysics and it minimizes the RMS relative error between the
great circle and geodesic distance.





",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func haversine(θ float64) float64 {
    return .5 * (1 - math.Cos(θ))
}
 
type pos struct {
    φ float64 // latitude, radians
    ψ float64 // longitude, radians
}
 
func degPos(lat, lon float64) pos {
    return pos{lat * math.Pi / 180, lon * math.Pi / 180}
}
 
const rEarth = 6372.8 // km
 
func hsDist(p1, p2 pos) float64 {
    return 2 * rEarth * math.Asin(math.Sqrt(haversine(p2.φ-p1.φ)+
        math.Cos(p1.φ)*math.Cos(p2.φ)*haversine(p2.ψ-p1.ψ)))
}
 
func main() {
    fmt.Println(hsDist(degPos(36.12, -86.67), degPos(33.94, -118.40)))
}",594,30
49175,http://rosettacode.org/wiki/GUI_component_interaction,GUI component interaction,"

Almost every application needs to communicate with the user in some way.
Therefore, a substantial part of the code deals with the interaction
of program logic with GUI components.

Typically, the following is needed:

 put values into input fields under program control
 read and check input from the user
 pop up dialogs to query the user for further information


Task

For a minimal ""application"", write a program that presents a form with three components to the user:

 a numeric input field (""Value"") 
 a button (""increment"")
 a button (""random"")


The field is initialized to zero.

The user may manually enter a new value into the field,
or increment its value with the ""increment"" button.

Entering a non-numeric value should be either impossible,
or issue an error message.

Pressing the ""random"" button presents a confirmation dialog,
and resets the field's value to a random value if the answer is ""Yes"".

(This task may be regarded as an extension of the task Simple windowed application).


",#Go,Go,"package main
 
import (
    ""github.com/gotk3/gotk3/gtk""
    ""log""
    ""math/rand""
    ""strconv""
    ""time""
)
 
func validateInput(window *gtk.Window, str string) (int64, bool) {
    i, err := strconv.ParseInt(str, 10, 64)
    if err != nil {
        dialog := gtk.MessageDialogNew(
            window,
            gtk.DIALOG_MODAL,
            gtk.MESSAGE_ERROR,
            gtk.BUTTONS_OK,
            ""Invalid value"",
        )
        dialog.Run()
        dialog.Destroy()
        return 0, false
    }
    return i, true
}
 
func check(err error, msg string) {
    if err != nil {
        log.Fatal(msg, err)
    }
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    gtk.Init(nil)
 
    window, err := gtk.WindowNew(gtk.WINDOW_TOPLEVEL)
    check(err, ""Unable to create window:"")
    window.SetTitle(""Rosetta Code"")
    window.SetPosition(gtk.WIN_POS_CENTER)
    window.Connect(""destroy"", func() {
        gtk.MainQuit()
    })
 
    box, err := gtk.BoxNew(gtk.ORIENTATION_HORIZONTAL, 1)
    check(err, ""Unable to create box:"")
    box.SetBorderWidth(1)
 
    label, err := gtk.LabelNew(""Value:"")
    check(err, ""Unable to create label:"")
 
    entry, err := gtk.EntryNew()
    check(err, ""Unable to create entry:"")
    entry.SetText(""0"") // initialize to zero
    entry.Connect(""activate"", func() {
        // read and validate the entered value
        str, _ := entry.GetText()
        validateInput(window, str)
    })
 
    // button to increment
    ib, err := gtk.ButtonNewWithLabel(""Increment"")
    check(err, ""Unable to create increment button:"")
    ib.Connect(""clicked"", func() {
        // read and validate the entered value
        str, _ := entry.GetText()
        if i, ok := validateInput(window, str); ok {
            entry.SetText(strconv.FormatInt(i+1, 10))
        }
    })
 
    // button to put in a random value if confirmed
    rb, err := gtk.ButtonNewWithLabel(""Random"")
    check(err, ""Unable to create random button:"")
    rb.Connect(""clicked"", func() {
        dialog := gtk.MessageDialogNew(
            window,
            gtk.DIALOG_MODAL,
            gtk.MESSAGE_QUESTION,
            gtk.BUTTONS_YES_NO,
            ""Set random value"",
        )
        answer := dialog.Run()
        dialog.Destroy()
        if answer == gtk.RESPONSE_YES {
            entry.SetText(strconv.Itoa(rand.Intn(10000)))
        }
    })
 
    box.PackStart(label, false, false, 2)
    box.PackStart(entry, false, false, 2)
    box.PackStart(ib, false, false, 2)
    box.PackStart(rb, false, false, 2)
    window.Add(box)
 
    window.ShowAll()
    gtk.Main()
}",2587,99
49231,http://rosettacode.org/wiki/Guess_the_number/With_feedback_(player),Guess the number/With feedback (player),"Task

Write a player for the game that follows the following rules:

The scorer will choose a number between set limits. The computer player will print a guess of the target number. The computer asks for a score of whether its guess is higher than, lower than, or equal to the target. The computer guesses, and the scorer scores, in turn, until the computer correctly guesses the target number.
The computer should guess intelligently based on the accumulated scores given. One way is to use a Binary search based algorithm.



Related tasks

   Guess the number/With Feedback
   Bulls and cows/Player

",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
func main() {
    lower, upper := 0, 100
    fmt.Printf(`Instructions:
Think of integer number from %d (inclusive) to %d (exclusive) and
I will guess it. After each guess, I will ask you if it is less than
or equal to some number, and you will respond with ""yes"" or ""no"".
`, lower, upper)
    answer := sort.Search(upper-lower, func (i int) bool {
        fmt.Printf(""Is your number less than or equal to %d? "", lower+i)
        s := """"
        fmt.Scanf(""%s"", &s)
        return s != """" && s[0] == 'y'
    })
    fmt.Printf(""Your number is %d.\n"", lower+answer)
}",613,22
49252,http://rosettacode.org/wiki/Greyscale_bars/Display,Greyscale bars/Display,"The task is to display a series of vertical greyscale bars (contrast bars) with a sufficient number of bars to span the entire width of the display.

For the top quarter of the display, the left hand bar should be black, and we then incrementally step through six shades of grey until we have a white bar on the right hand side of the display. (This gives a total of 8 bars)

For the second quarter down, we start with white and step down through 14 shades of gray, getting darker until we have black on the right hand side of the display. (This gives a total of 16 bars).

Halfway down the display, we start with black, and produce 32 bars, ending in white, and for the last quarter, we start with white and step through 62 shades of grey, before finally arriving at black in the bottom right hand corner, producing a total of 64 bars for the bottom quarter.
",#Go,Go,"package main
 
import (
    ""github.com/fogleman/gg""
    ""math""
)
 
func greyBars(dc *gg.Context) {
    run := 0
    colorComp := 0.0 // component of the color
    for colCount := 8; colCount < 128; colCount *= 2 {
        // by this gap we change the background color
        colorGap := 255.0 / float64(colCount-1)
        colWidth := float64(dc.Width() / colCount)
        colHeight := float64(dc.Height() / 4)
        // switches color directions with each iteration of for loop
        if run%2 == 0 {
            colorComp = 0.0
        } else {
            colorComp = 255.0
            colorGap = -colorGap
        }
        xstart, ystart := 0.0, colHeight*float64(run)
        for i := 0; i < colCount; i++ {
            icolor := int(math.Round(colorComp)) // round to nearer integer
            dc.SetRGB255(icolor, icolor, icolor)
            dc.DrawRectangle(xstart, ystart, colWidth, colHeight)
            dc.Fill()
            xstart += colWidth
            colorComp += colorGap
        }
        run++
    }
}
 
func main() {
    dc := gg.NewContext(640, 320)
    greyBars(dc)
    dc.SavePNG(""greybars.png"")
}",1128,40
49266,http://rosettacode.org/wiki/Hello_world/Graphical,Hello world/Graphical,"

Task

Display the string       Goodbye, World!       on a GUI object   (alert box, plain window, text area, etc.).



Related task

   Hello world/Text

",#Go,Go,"package main
 
import ""github.com/mattn/go-gtk/gtk""
 
func main() {
   gtk.Init(nil)
   win := gtk.NewWindow(gtk.WINDOW_TOPLEVEL)
   win.SetTitle(""Goodbye, World!"")
   win.SetSizeRequest(300, 200)
   win.Connect(""destroy"", gtk.MainQuit)
   button := gtk.NewButtonWithLabel(""Goodbye, World!"")
   win.Add(button)
   button.Connect(""clicked"", gtk.MainQuit)
   win.ShowAll()
   gtk.Main()
}",386,16
49359,http://rosettacode.org/wiki/Graph_colouring,Graph colouring,"

A Graph is a collection of nodes
(or vertices), connected by edges (or not).
Nodes directly connected by edges are called neighbours.

In our representation of graphs, nodes are numbered and edges are represented
by the two node numbers connected by the edge separated by a dash.
Edges define the nodes being connected. Only unconnected nodes need a separate
description.

For example,

0-1 1-2 2-0 3
Describes the following graph. Note that node 3 has no neighbours



Example graph

+---+
| 3 |
+---+

  +-------------------+
  |                   |
+---+     +---+     +---+
| 0 | --- | 1 | --- | 2 |
+---+     +---+     +---+

A useful internal datastructure for a graph and for later graph algorithms is
as a mapping between each node and the set/list of its neighbours.

In the above example:

0 maps-to 1 and 2
1 maps to 2 and 0
2 maps-to 1 and 0
3 maps-to <nothing>
Graph colouring task

Colour the vertices of a given graph so that no edge is between verticies of
the same colour.

 Integers may be used to denote different colours.
 Algorithm should do better than just assigning each vertex a separate colour. The idea is to minimise the number of colours used, although no algorithm short of exhaustive search for the minimum is known at present, (and exhaustive search is not a requirement).
 Show for each edge, the colours assigned on each vertex.
 Show the total number of nodes, edges, and colours used for each graph.
Use the following graphs

Ex1

       0-1 1-2 2-0 3

+---+
| 3 |
+---+

  +-------------------+
  |                   |
+---+     +---+     +---+
| 0 | --- | 1 | --- | 2 |
+---+     +---+     +---+

Ex2

The wp articles left-side graph

   1-6 1-7 1-8 2-5 2-7 2-8 3-5 3-6 3-8 4-5 4-6 4-7


  +----------------------------------+
  |                                  |
  |                      +---+       |
  |    +-----------------| 3 | ------+----+
  |    |                 +---+       |    |
  |    |                   |         |    |
  |    |                   |         |    |
  |    |                   |         |    |
  |  +---+     +---+     +---+     +---+  |
  |  | 8 | --- | 1 | --- | 6 | --- | 4 |  |
  |  +---+     +---+     +---+     +---+  |
  |    |         |                   |    |
  |    |         |                   |    |
  |    |         |                   |    |
  |    |       +---+     +---+     +---+  |
  +----+------ | 7 | --- | 2 | --- | 5 | -+
       |       +---+     +---+     +---+
       |                   |
       +-------------------+

Ex3

The wp articles right-side graph which is the same graph as Ex2, but with
different node orderings and namings.

   1-4 1-6 1-8 3-2 3-6 3-8 5-2 5-4 5-8 7-2 7-4 7-6


  +----------------------------------+
  |                                  |
  |                      +---+       |
  |    +-----------------| 5 | ------+----+
  |    |                 +---+       |    |
  |    |                   |         |    |
  |    |                   |         |    |
  |    |                   |         |    |
  |  +---+     +---+     +---+     +---+  |
  |  | 8 | --- | 1 | --- | 4 | --- | 7 |  |
  |  +---+     +---+     +---+     +---+  |
  |    |         |                   |    |
  |    |         |                   |    |
  |    |         |                   |    |
  |    |       +---+     +---+     +---+  |
  +----+------ | 6 | --- | 3 | --- | 2 | -+
       |       +---+     +---+     +---+
       |                   |
       +-------------------+

Ex4

This is the same graph, node naming, and edge order as Ex2 except some of the edges x-y are flipped to y-x.
This might alter the node order used in the greedy algorithm leading to differing numbers of colours.

   1-6 7-1 8-1 5-2 2-7 2-8 3-5 6-3 3-8 4-5 4-6 4-7


                      +-------------------------------------------------+
                      |                                                 |
                      |                                                 |
  +-------------------+---------+                                       |
  |                   |         |                                       |
+---+     +---+     +---+     +---+     +---+     +---+     +---+     +---+
| 4 | --- | 5 | --- | 2 | --- | 7 | --- | 1 | --- | 6 | --- | 3 | --- | 8 |
+---+     +---+     +---+     +---+     +---+     +---+     +---+     +---+
  |         |                             |         |         |         |
  +---------+-----------------------------+---------+         |         |
            |                             |                   |         |
            |                             |                   |         |
            +-----------------------------+-------------------+         |
                                          |                             |
                                          |                             |
                                          +-----------------------------+

References

 Greedy coloring Wikipedia.
 Graph Coloring : Greedy Algorithm & Welsh Powell Algorithm by Priyank Jain.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
type graph struct {
    nn  int     // number of nodes
    st  int     // node numbering starts from
    nbr [][]int // neighbor list for each node
}
 
type nodeval struct {
    n int // number of node
    v int // valence of node i.e. number of neighbors
}
 
func contains(s []int, n int) bool {
    for _, e := range s {
        if e == n {
            return true
        }
    }
    return false
}
 
func newGraph(nn, st int) graph {
    nbr := make([][]int, nn)
    return graph{nn, st, nbr}
}
 
// Note that this creates a single 'virtual' edge for an isolated node.
func (g graph) addEdge(n1, n2 int) {
    n1, n2 = n1-g.st, n2-g.st // adjust to starting node number
    g.nbr[n1] = append(g.nbr[n1], n2)
    if n1 != n2 {
        g.nbr[n2] = append(g.nbr[n2], n1)
    }
}
 
// Uses 'greedy' algorithm.
func (g graph) greedyColoring() []int {
    // create a slice with a color for each node, starting with color 0
    cols := make([]int, g.nn) // all zero by default including the first node
    for i := 1; i < g.nn; i++ {
        cols[i] = -1 // mark all nodes after the first as having no color assigned (-1)
    }
    // create a bool slice to keep track of which colors are available
    available := make([]bool, g.nn) // all false by default
    // assign colors to all nodes after the first
    for i := 1; i < g.nn; i++ {
        // iterate through neighbors and mark their colors as available
        for _, j := range g.nbr[i] {
            if cols[j] != -1 {
                available[cols[j]] = true
            }
        }
        // find the first available color
        c := 0
        for ; c < g.nn; c++ {
            if !available[c] {
                break
            }
        }
        cols[i] = c // assign it to the current node
        // reset the neighbors' colors to unavailable
        // before the next iteration
        for _, j := range g.nbr[i] {
            if cols[j] != -1 {
                available[cols[j]] = false
            }
        }
    }
    return cols
}
 
// Uses Welsh-Powell algorithm.
func (g graph) wpColoring() []int {
    // create nodeval for each node
    nvs := make([]nodeval, g.nn)
    for i := 0; i < g.nn; i++ {
        v := len(g.nbr[i])
        if v == 1 && g.nbr[i][0] == i { // isolated node
            v = 0
        }
        nvs[i] = nodeval{i, v}
    }
    // sort the nodevals in descending order by valence
    sort.Slice(nvs, func(i, j int) bool {
        return nvs[i].v > nvs[j].v
    })
    // create colors slice with entries for each node
    cols := make([]int, g.nn)
    for i := range cols {
        cols[i] = -1 // set all nodes to no color (-1) initially
    }
    currCol := 0 // start with color 0
    for f := 0; f < g.nn-1; f++ {
        h := nvs[f].n
        if cols[h] != -1 { // already assigned a color
            continue
        }
        cols[h] = currCol
        // assign same color to all subsequent uncolored nodes which are
        // not connected to a previous colored one
    outer:
        for i := f + 1; i < g.nn; i++ {
            j := nvs[i].n
            if cols[j] != -1 { // already colored
                continue
            }
            for k := f; k < i; k++ {
                l := nvs[k].n
                if cols[l] == -1 { // not yet colored
                    continue
                }
                if contains(g.nbr[j], l) {
                    continue outer // node j is connected to an earlier colored node
                }
            }
            cols[j] = currCol
        }
        currCol++
    }
    return cols
}
 
func main() {
    fns := [](func(graph) []int){graph.greedyColoring, graph.wpColoring}
    titles := []string{""'Greedy'"", ""Welsh-Powell""}
    nns := []int{4, 8, 8, 8}
    starts := []int{0, 1, 1, 1}
    edges1 := [][2]int{{0, 1}, {1, 2}, {2, 0}, {3, 3}}
    edges2 := [][2]int{{1, 6}, {1, 7}, {1, 8}, {2, 5}, {2, 7}, {2, 8},
        {3, 5}, {3, 6}, {3, 8}, {4, 5}, {4, 6}, {4, 7}}
    edges3 := [][2]int{{1, 4}, {1, 6}, {1, 8}, {3, 2}, {3, 6}, {3, 8},
        {5, 2}, {5, 4}, {5, 8}, {7, 2}, {7, 4}, {7, 6}}
    edges4 := [][2]int{{1, 6}, {7, 1}, {8, 1}, {5, 2}, {2, 7}, {2, 8},
        {3, 5}, {6, 3}, {3, 8}, {4, 5}, {4, 6}, {4, 7}}
    for j, fn := range fns {
        fmt.Println(""Using the"", titles[j], ""algorithm:\n"")
        for i, edges := range [][][2]int{edges1, edges2, edges3, edges4} {
            fmt.Println(""  Example"", i+1)
            g := newGraph(nns[i], starts[i])
            for _, e := range edges {
                g.addEdge(e[0], e[1])
            }
            cols := fn(g)
            ecount := 0 // counts edges
            for _, e := range edges {
                if e[0] != e[1] {
                    fmt.Printf(""    Edge  %d-%d -> Color %d, %d\n"", e[0], e[1],
                        cols[e[0]-g.st], cols[e[1]-g.st])
                    ecount++
                } else {
                    fmt.Printf(""    Node  %d   -> Color %d\n"", e[0], cols[e[0]-g.st])
                }
            }
            maxCol := 0 // maximum color number used
            for _, col := range cols {
                if col > maxCol {
                    maxCol = col
                }
            }
            fmt.Println(""    Number of nodes  :"", nns[i])
            fmt.Println(""    Number of edges  :"", ecount)
            fmt.Println(""    Number of colors :"", maxCol+1)
            fmt.Println()
        }
    }
}",5445,172
49502,http://rosettacode.org/wiki/Go_Fish,Go Fish,"Write a program to let the user play Go Fish against a computer opponent. Use the following rules:

 Each player is dealt nine cards to start with.
 On their turn, a player asks their opponent for a given rank (such as threes or kings). A player must already have at least one card of a given rank to ask for more.
 If the opponent has any cards of the named rank, they must hand over all such cards, and the requester can ask again.
 If the opponent has no cards of the named rank, the requester draws a card and ends their turn.
 A book is a collection of every card of a given rank. Whenever a player completes a book, they may remove it from their hand.
 If at any time a player's hand is empty, they may immediately draw a new card, so long as any new cards remain in the deck.
 The game ends when every book is complete. The player with the most books wins.
The game's AI need not be terribly smart, but it should use at least some strategy. That is, it shouldn't choose legal moves entirely at random.

You may want to use code from Playing Cards.

Related tasks:

 Playing cards
 Card shuffles
 Deal cards_for_FreeCell
 War Card_Game
 Poker hand_analyser

",#Go,Go,"#!/usr/bin/perl
 
use strict; # https://rosettacode.org/wiki/Go_Fish
use warnings;
use List::Util qw( first shuffle );
 
my $pat = qr/[atjqk2-9]/; # ranks
my $deck = join '', shuffle map { my $rank = $_; map ""$rank$_"", qw( S H C D ) }
  qw( a t j q k ), 2 .. 9;
 
my $mebooks = my $youbooks = 0;
 
my $me = substr $deck, 0, 2 * 9, '';
my $mepicks = join '', $me =~ /$pat/g;
arrange($me);
$mebooks++ while $me =~ s/($pat).\1.\1.\1.//;
my $you = substr $deck, 0, 2 * 9, '';
my $youpicks = join '', $you =~ /$pat/g;
arrange($you);
$youbooks++ while $you =~ s/($pat).\1.\1.\1.//;
 
while( $mebooks + $youbooks < 13 )
  {
  play( \$you, \$youbooks, \$youpicks, \$me, \$mebooks, 1 );
  $mebooks + $youbooks == 13 and last;
  play( \$me, \$mebooks, \$mepicks, \$you, \$youbooks, 0 );
  }
print ""me $mebooks you $youbooks\n"";
 
sub arrange { $_[0] = join '', sort $_[0] =~ /../g }
 
sub human
  {
  my $have = shift =~ s/($pat).\K(?!\1)/ /gr;
  local $| = 1;
  my $pick;
  do
    {
    print ""You have $have, enter request: "";
    ($pick) = lc(<STDIN>) =~ /$pat/g;
    } until $pick and $have =~ /$pick/;
  return $pick;
  }
 
sub play
  {
  my ($me, $mb, $lastpicks, $you, $yb, $human) = @_;
  my $more = 1;
  while( arrange( $$me ), $more and $$mb + $$yb < 13 )
    {
#   use Data::Dump 'dd'; dd \@_, ""deck $deck"";
    if( $$me =~ s/($pat).\1.\1.\1.// )
      {
      print ""book of $&\n"";
      $$mb++;
      }
    elsif( $$me )
      {
      my $pick = $human ? do { human($$me) } : do
        {
        my %picks;
        $picks{$_}++ for my @picks = $$me =~ /$pat/g;
        my $pick = first { $picks{$_} } split(//, $$lastpicks), shuffle @picks;
        print ""pick $pick\n"";
        $$lastpicks =~ s/$pick//g;
        $$lastpicks .= $pick;
        $pick;
        };
      if( $$you =~ s/(?:$pick.)+// )
        {
        $$me .= $&;
        }
      else
        {
        print ""GO FISH !!\n"";
        $$me .= substr $deck, 0, 2, '';
        $more = 0;
        }
      }
    elsif( $deck )
      {
      $$me .= substr $deck, 0, 2, '';
      }
    else
      {
      $more = 0;
      }
    }
  arrange( $$me );
  }",2114,90
49618,http://rosettacode.org/wiki/Grayscale_image,Grayscale image,"Many image processing algorithms are defined for grayscale (or else monochromatic) images.



Task

Extend the data storage type defined on this page to support grayscale images.

Define two operations, one to convert a color image to a grayscale image and one for the backward conversion.

To get luminance of a color use the formula recommended by CIE:

 L  =  0.2126 × R   +   0.7152 × G   +   0.0722 × B 

When using floating-point arithmetic make sure that rounding errors would not cause run-time problems or else distorted results when calculated luminance is stored as an unsigned integer.



",#Go,Go,"package raster
 
import (
    ""math""
    ""math/rand""
)
 
// Grmap parallels Bitmap, but with an element type of uint16
// in place of Pixel.
type Grmap struct {
    Comments   []string
    rows, cols int
    px         []uint16
    pxRow      [][]uint16
}
 
// NewGrmap constructor.
func NewGrmap(x, y int) (b *Grmap) {
    g := &Grmap{
        Comments: []string{creator}, // creator a const in bitmap source file
        rows:     y,
        cols:     x,
        px:       make([]uint16, x*y),
        pxRow:    make([][]uint16, y),
    }
    x0, x1 := 0, x
    for i := range g.pxRow {
        g.pxRow[i] = g.px[x0:x1]
        x0, x1 = x1, x1+x
    }
    return g
}
 
func (b *Grmap) Extent() (cols, rows int) {
    return b.cols, b.rows
}
 
func (g *Grmap) Fill(c uint16) {
    for i := range g.px {
        g.px[i] = c
    }
}
 
func (g *Grmap) SetPx(x, y int, c uint16) bool {
    defer func() { recover() }()
    g.pxRow[y][x] = c
    return true
}
 
func (g *Grmap) GetPx(x, y int) (uint16, bool) {
    defer func() { recover() }()
    return g.pxRow[y][x], true
}
 
// Grmap method of Bitmap, converts (color) Bitmap to (grayscale) Grmap
func (b *Bitmap) Grmap() *Grmap {
    g := NewGrmap(b.cols, b.rows)
    g.Comments = append([]string{}, b.Comments...)
    for i, p := range b.px {
        g.px[i] = uint16((int64(p.R)*2126 + int64(p.G)*7152 + int64(p.B)*722) *
            math.MaxUint16 / (math.MaxUint8 * 10000))
    }
    return g
}
 
// Bitmap method Grmap, converts Grmap to Bitmap.  All pixels in the resulting
// color Bitmap will be (very nearly) shades of gray.
func (g *Grmap) Bitmap() *Bitmap {
    b := NewBitmap(g.cols, g.rows)
    b.Comments = append([]string{}, g.Comments...)
    for i, p := range g.px {
        roundedSum := int(p) * 3 * math.MaxUint8 / math.MaxUint16
        rounded := uint8(roundedSum / 3)
        remainder := roundedSum % 3
        b.px[i].R = rounded
        b.px[i].G = rounded
        b.px[i].B = rounded
        if remainder > 0 {
            odd := rand.Intn(3)
            switch odd + (remainder * 3) {
            case 3:
                b.px[i].R++
            case 4:
                b.px[i].G++
            case 5:
                b.px[i].B++
            case 6:
                b.px[i].G++
                b.px[i].B++
            case 7:
                b.px[i].R++
                b.px[i].B++
            case 8:
                b.px[i].R++
                b.px[i].G++
            }
        }
    }
    return b
}",2480,100
49739,http://rosettacode.org/wiki/Guess_the_number,Guess the number,"Task

Write a program where the program chooses a number between   1   and   10.

A player is then prompted to enter a guess.   If the player guesses wrong,   then the prompt appears again until the guess is correct.

When the player has made a successful guess the computer will issue a   ""Well guessed!""   message,   and the program exits.

A   conditional loop   may be used to repeat the guessing until the user is correct.



Related tasks

   Bulls and cows
   Bulls and cows/Player
   Guess the number/With Feedback
   Mastermind

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
func main() {
    fmt.Print(""Guess number from 1 to 10: "")
    rand.Seed(time.Now().Unix())
    n := rand.Intn(10) + 1
    for guess := n; ; fmt.Print(""No. Try again: "") {
        switch _, err := fmt.Scan(&guess); {
        case err != nil:
            fmt.Println(""\n"", err, ""\nSo, bye."")
            return
        case guess == n:
            fmt.Println(""Well guessed!"")
            return
        }
    }
}",477,23
49747,http://rosettacode.org/wiki/Hello_world/Text,Hello world/Text,"Hello world/Text is part of Short Circuit's Console Program Basics selection.
Task

Display the string Hello world! on a text console.

Related tasks

   Hello world/Graphical
   Hello world/Line Printer
   Hello world/Newbie
   Hello world/Newline omission
   Hello world/Standard error
   Hello world/Web server

",#Go,Go,"package main
 
import ""fmt""
 
func main() { fmt.Println(""Hello world!"") }",73,5
49783,http://rosettacode.org/wiki/Get_system_command_output,Get system command output,"Task
Execute a system command and get its output into the program. The output may be stored in any kind of collection (array, list, etc.).




Related task
  Execute a system command

",#Go,Go,"package main
 
import (
  ""fmt""
  ""log""
  ""os/exec""
)
 
func main() {
  output, err := exec.Command(""ls"", ""-l"").CombinedOutput()
  if err != nil {
    log.Fatal(err)
  }
  fmt.Print(string(output))
}",199,15
49789,http://rosettacode.org/wiki/Globally_replace_text_in_several_files,Globally replace text in several files,"Task

Replace every occurring instance of a piece of text in a group of text files with another one.



For this task we want to replace the text   ""Goodbye London!""   with   ""Hello New York!""   for a list of files.



",#Go,Go,"package main
 
import (
    ""bytes""
    ""io/ioutil""
    ""log""
    ""os""
)
 
func main() {
    gRepNFiles(""Goodbye London!"", ""Hello New York!"", []string{
        ""a.txt"",
        ""b.txt"",
        ""c.txt"",
    })
}
 
func gRepNFiles(olds, news string, files []string) {
    oldb := []byte(olds)
    newb := []byte(news)
    for _, fn := range files {
        if err := gRepFile(oldb, newb, fn); err != nil {
            log.Println(err)
        }
    }
}
 
func gRepFile(oldb, newb []byte, fn string) (err error) {
    var f *os.File
    if f, err = os.OpenFile(fn, os.O_RDWR, 0); err != nil {
        return
    }
    defer func() {
        if cErr := f.Close(); err == nil {
            err = cErr
        }
    }()
    var b []byte
    if b, err = ioutil.ReadAll(f); err != nil {
        return
    }
    if bytes.Index(b, oldb) < 0 {
        return
    }
    r := bytes.Replace(b, oldb, newb, -1)
    if err = f.Truncate(0); err != nil {
        return
    }
    _, err = f.WriteAt(r, 0)
    return
}",1001,51
49798,http://rosettacode.org/wiki/Greatest_subsequential_sum,Greatest subsequential sum,"Task

Given a sequence of integers, find a continuous subsequence which maximizes the sum of its elements, that is, the elements of no other single subsequence add up to a value larger than this one.



An empty subsequence is considered to have the sum of   0;   thus if all elements are negative, the result must be the empty sequence.



",#Go,Go,"package main
 
import ""fmt""
 
func gss(s []int) ([]int, int) {
    var best, start, end, sum, sumStart int
    for i, x := range s {
        sum += x
        switch {
        case sum > best:
            best = sum
            start = sumStart
            end = i + 1
        case sum < 0:
            sum = 0
            sumStart = i + 1
        }
    }
    return s[start:end], best
}
 
var testCases = [][]int{
    {-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1},
    {-1, 1, 2, -5, -6},
    {},
    {-1, -2, -1},
}
 
func main() {
    for _, c := range testCases {
        fmt.Println(""Input:  "", c)
        subSeq, sum := gss(c)
        fmt.Println(""Sub seq:"", subSeq)
        fmt.Println(""Sum:    "", sum, ""\n"")
    }
}",716,36
50007,http://rosettacode.org/wiki/Gray_code,Gray code,"Gray code
Karnaugh maps
Create functions to encode a number to and decode a number from Gray code.

Display the normal binary representations, Gray code representations, and decoded Gray code values for all 5-bit binary numbers (0-31 inclusive, leading 0's not necessary).

There are many possible Gray codes. The following encodes what is called ""binary reflected Gray code.""

Encoding (MSB is bit 0, b is binary, g is Gray code):

if b[i-1] = 1
   g[i] = not b[i]
else
   g[i] = b[i]
Or:

g = b xor (b logically right shifted 1 time)
Decoding (MSB is bit 0, b is binary, g is Gray code):

b[0] = g[0]

for other bits:
b[i] = g[i] xor b[i-1]
Reference
 Converting Between Gray and Binary Codes. It includes step-by-step animations.",#Go,Go,"package main
 
import ""fmt""
 
func enc(b int) int {
    return b ^ b>>1
}
 
func dec(g int) (b int) {
    for ; g != 0; g >>= 1 {
        b ^= g
    }
    return
}
 
func main() {
    fmt.Println(""decimal  binary   gray    decoded"")
    for b := 0; b < 32; b++ {
        g := enc(b)
        d := dec(g)
        fmt.Printf(""  %2d     %05b   %05b   %05b  %2d\n"", b, b, g, d, d)
    }
}",383,23
50024,http://rosettacode.org/wiki/Happy_numbers,Happy numbers,"From Wikipedia, the free encyclopedia:

 A happy number is defined by the following process:
 Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals   1   (where it will stay),   or it loops endlessly in a cycle which does not include   1.   


 Those numbers for which this process end in   1   are       happy   numbers,   
 while   those numbers   that   do   not   end in   1   are   unhappy   numbers. 


Task

Find and print the first   8   happy numbers.

Display an example of your output here on this page.



See also

   The OEIS entry:   The     happy numbers:   A007770
   The OEIS entry:   The unhappy numbers;   A031177

",#Go,Go,"package main
 
import ""fmt""
 
func happy(n int) bool {
	m := make(map[int]bool)
	for n > 1 {
		m[n] = true
		var x int
		for x, n = n, 0; x > 0; x /= 10 {
			d := x % 10
			n += d * d
		}
		if m[n] {
			return false
		}
	}
	return true
}
 
func main() {
	for found, n := 0, 1; found < 8; n++ {
		if happy(n) {
			fmt.Print(n, "" "")
			found++
		}
	}
	fmt.Println()
}",365,29
50070,http://rosettacode.org/wiki/Hamming_numbers,Hamming numbers,"Hamming numbers are numbers of the form  

    H = 2i × 3j × 5k
           where 
     i,  j,  k  ≥  0 

Hamming numbers   are also known as   ugly numbers   and also   5-smooth numbers   (numbers whose prime divisors are less or equal to 5).



Task

Generate the sequence of Hamming numbers, in increasing order.   In particular:

 Show the   first twenty   Hamming numbers.
 Show the   1691st   Hamming number (the last one below   231).
 Show the   one millionth   Hamming number (if the language – or a convenient library – supports arbitrary-precision integers).


Related tasks

 Humble numbers
 N-smooth numbers


References

 Wikipedia entry:   Hamming numbers     (this link is re-directed to   Regular number).
 Wikipedia entry:   Smooth number
 OEIS entry:   A051037   5-smooth   or   Hamming numbers
 Hamming problem from Dr. Dobb's CodeTalk (dead link as of Sep 2011; parts of the thread here and here).

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func min(a, b *big.Int) *big.Int {
    if a.Cmp(b) < 0 {
        return a
    }
    return b
}
 
func hamming(n int) []*big.Int {
    h := make([]*big.Int, n)
    h[0] = big.NewInt(1)
    two, three, five    := big.NewInt(2), big.NewInt(3), big.NewInt(5)
    next2, next3, next5 := big.NewInt(2), big.NewInt(3), big.NewInt(5)
    i, j, k := 0, 0, 0
    for m := 1; m < len(h); m++ {
        h[m] = new(big.Int).Set(min(next2, min(next3, next5)))
        if h[m].Cmp(next2) == 0 { i++; next2.Mul(  two, h[i]) } 
        if h[m].Cmp(next3) == 0 { j++; next3.Mul(three, h[j]) } 
        if h[m].Cmp(next5) == 0 { k++; next5.Mul( five, h[k]) } 
    }
    return h
}
 
func main() {
    h := hamming(1e6)
    fmt.Println(h[:20])
    fmt.Println(h[1691-1])
    fmt.Println(h[len(h)-1])
}",834,35
50157,http://rosettacode.org/wiki/Guess_the_number/With_feedback,Guess the number/With feedback,"Task

Write a game (computer program) that follows the following rules:

 The computer chooses a number between given set limits.
 The player is asked for repeated guesses until the the target number is guessed correctly
 At each guess, the computer responds with whether the guess is:
 higher than the target,
 equal to the target, 
 less than the target,   or
 the input was inappropriate. 


Related task

   Guess the number/With Feedback (Player)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
const lower, upper = 1, 100
 
func main() {
    fmt.Printf(""Guess integer number from %d to %d: "", lower, upper)
    rand.Seed(time.Now().Unix())
    n := rand.Intn(upper-lower+1) + lower
    for guess := n; ; {
        switch _, err := fmt.Scan(&guess); {
        case err != nil:
            fmt.Println(""\n"", err, ""So, bye."")
            return
        case guess < n:
            fmt.Print(""Too low. Try again: "")
        case guess > n:
            fmt.Print(""Too high. Try again: "")
        default:
            fmt.Println(""Well guessed!"")
            return
        }
    }
}",648,29
50760,http://rosettacode.org/wiki/Greatest_element_of_a_list,Greatest element of a list,"Task

Create a function that returns the maximum value in a provided set of values,

where the number of values may not be known until run-time.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
// function, per task description
func largest(a []int) (lg int, ok bool) {
    if len(a) == 0 {
        return
    }
    lg = a[0]
    for _, e := range a[1:] {
        if e > lg {
            lg = e
        }
    }
    return lg, true
}
 
func main() {
    // random size slice
    rand.Seed(time.Now().UnixNano())
    a := make([]int, rand.Intn(11))
    for i := range a {
        a[i] = rand.Intn(101) - 100 // fill with random numbers
    }
 
    fmt.Println(a)
    lg, ok := largest(a)
    if ok {
        fmt.Println(lg)
    } else {
        fmt.Println(""empty list.  no maximum."")
    }
}",661,38
50781,http://rosettacode.org/wiki/Hailstone_sequence,Hailstone sequence,"The Hailstone sequence of numbers can be generated from a starting positive integer,   n   by:

   If   n   is     1     then the sequence ends.
   If   n   is   even then the next   n   of the sequence    = n/2 
   If   n   is   odd   then the next   n   of the sequence    = (3 * n) + 1 


The (unproven) Collatz conjecture is that the hailstone sequence for any starting number always terminates.



This sequence was named by Lothar Collatz in 1937   (or possibly in 1939),   and is also known as (the):

   hailstone sequence,   hailstone numbers
   3x + 2 mapping,   3n + 1 problem
   Collatz sequence
   Hasse's algorithm
   Kakutani's problem
   Syracuse algorithm,   Syracuse problem
   Thwaites conjecture 
   Ulam's problem


The hailstone sequence is also known as   hailstone numbers   (because the values are usually subject to multiple descents and ascents like hailstones in a cloud).



Task

 Create a routine to generate the hailstone sequence for a number.
 Use the routine to show that the hailstone sequence for the number 27 has 112 elements starting with 27, 82, 41, 124 and ending with 8, 4, 2, 1
 Show the number less than 100,000 which has the longest hailstone sequence together with that sequence's length.
   (But don't show the actual sequence!)


See also

   xkcd (humourous).
   The Notorious Collatz conjecture Terence Tao, UCLA (Presentation, pdf).
   The Simplest Math Problem No One Can Solve Veritasium (video, sponsored).

",#Go,Go,"package main
 
import ""fmt""
 
// 1st arg is the number to generate the sequence for.
// 2nd arg is a slice to recycle, to reduce garbage.
func hs(n int, recycle []int) []int {
    s := append(recycle[:0], n)
    for n > 1 {
        if n&1 == 0 {
            n = n / 2
        } else {
            n = 3*n + 1
        }
        s = append(s, n)
    }
    return s
}
 
func main() {
    seq := hs(27, nil)
    fmt.Printf(""hs(27): %d elements: [%d %d %d %d ... %d %d %d %d]\n"",
        len(seq), seq[0], seq[1], seq[2], seq[3],
        seq[len(seq)-4], seq[len(seq)-3], seq[len(seq)-2], seq[len(seq)-1])
 
    var maxN, maxLen int
    for n := 1; n < 100000; n++ {
        seq = hs(n, seq)
        if len(seq) > maxLen {
            maxN = n
            maxLen = len(seq)
        }
    }
    fmt.Printf(""hs(%d): %d elements\n"", maxN, maxLen)
}",840,35
50805,http://rosettacode.org/wiki/Generic_swap,Generic swap,"Task

Write a generic swap function or operator which exchanges the values of two variables (or, more generally, any two storage places that can be assigned), regardless of their types.

If your solution language is statically typed please describe the way your language provides genericity.

If variables are typed in the given language, it is permissible that the two variables be constrained to having a mutually compatible type, such that each is permitted to hold the value previously stored in the other without a type violation.
That is to say, solutions do not have to be capable of exchanging, say, a string and integer value, if the underlying storage locations are not attributed with types that permit such an exchange.

Generic swap is a task which brings together a few separate issues in programming language semantics.

Dynamically typed languages deal with values in a generic way quite readily, but do not necessarily make it easy to write a function to destructively swap two variables, because this requires indirection upon storage places or upon the syntax designating storage places.

Functional languages, whether static or dynamic, do not necessarily allow a destructive operation such as swapping two variables regardless of their generic capabilities.

Some static languages have difficulties with generic programming due to a lack of support for (Parametric Polymorphism).

Do your best!



",#Go,Go,"a, b = b, a",11,1
50883,http://rosettacode.org/wiki/Greatest_common_divisor,Greatest common divisor,"Greatest common divisor

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Find the greatest common divisor   (GCD)   of two integers.


Greatest common divisor   is also known as   greatest common factor (gcf)   and   greatest common measure.



Related task

   least common multiple.


See also

   MathWorld entry:   greatest common divisor.
   Wikipedia entry:     greatest common divisor.

",#Go,Go,"package main
 
import ""fmt""
 
func gcd(a, b int) int {
    var bgcd func(a, b, res int) int
 
    bgcd = func(a, b, res int) int {
	switch {
	case a == b:
	    return res * a
	case a % 2 == 0 && b % 2 == 0:
	    return bgcd(a/2, b/2, 2*res)
	case a % 2 == 0:
	    return bgcd(a/2, b, res)
	case b % 2 == 0:
	    return bgcd(a, b/2, res)
	case a > b:
	    return bgcd(a-b, b, res)
	default:
	    return bgcd(a, b-a, res)
	}
    }
 
    return bgcd(a, b, 1)
}
 
func main() {
    type pair struct {
	a int
	b int
    }
 
    var testdata []pair = []pair{
	pair{33, 77},
	pair{49865, 69811},
    }
 
    for _, v := range testdata {
	fmt.Printf(""gcd(%d, %d) = %d\n"", v.a, v.b, gcd(v.a, v.b))
    }
}
 ",698,43
51365,http://rosettacode.org/wiki/Generate_random_chess_position,Generate random chess position,"Task
 
Generate a random chess position in FEN format.

The position does not have to be realistic or even balanced,  but it must comply to the following rules:

 there is one and only one king of each color  (one black king and one white king);
 the kings must not be placed on adjacent squares;
 there can not be any pawn in the promotion square  (no white pawn in the eighth rank, and no black pawn in the first rank);
 including the kings, up to 32 pieces of either color can be placed. 
 There is no requirement for material balance between sides. 
 The picking of pieces does not have to comply to a regular chess set --- there can be five knights, twenty rooks, whatever ... as long as the total number of pieces do not exceed thirty-two. 
 it is white's turn.
 It's assumed that both sides have lost castling rights and that there is no possibility for   en passant   (the FEN should thus end in w - - 0 1).


No requirement is made regarding the probability distribution of your method, but your program should be able to span a reasonably representative sample of all possible positions. For instance, programs that would always generate positions with say five pieces on the board, or with kings on a corner, would not be considered truly random.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""strconv""
    ""strings""
    ""time""
)
 
var grid [8][8]byte
 
func abs(i int) int {
    if i >= 0 {
        return i
    } else {
        return -i
    }
}
 
func createFen() string {
    placeKings()
    placePieces(""PPPPPPPP"", true)
    placePieces(""pppppppp"", true)
    placePieces(""RNBQBNR"", false)
    placePieces(""rnbqbnr"", false)
    return toFen()
}
 
func placeKings() {
    for {
        r1 := rand.Intn(8)
        c1 := rand.Intn(8)
        r2 := rand.Intn(8)
        c2 := rand.Intn(8)
        if r1 != r2 && abs(r1-r2) > 1 && abs(c1-c2) > 1 {
            grid[r1][c1] = 'K'
            grid[r2][c2] = 'k'
            return
        }
    }
}
 
func placePieces(pieces string, isPawn bool) {
    numToPlace := rand.Intn(len(pieces))
    for n := 0; n < numToPlace; n++ {
        var r, c int
        for {
            r = rand.Intn(8)
            c = rand.Intn(8)
            if grid[r][c] == '\000' && !(isPawn && (r == 7 || r == 0)) {
                break
            }
        }
        grid[r][c] = pieces[n]
    }
}
 
func toFen() string {
    var fen strings.Builder
    countEmpty := 0
    for r := 0; r < 8; r++ {
        for c := 0; c < 8; c++ {
            ch := grid[r][c]
            if ch == '\000' {
                ch = '.'
            }
            fmt.Printf(""%2c "", ch)
            if ch == '.' {
                countEmpty++
            } else {
                if countEmpty > 0 {
                    fen.WriteString(strconv.Itoa(countEmpty))
                    countEmpty = 0
                }
                fen.WriteByte(ch)
            }
        }
        if countEmpty > 0 {
            fen.WriteString(strconv.Itoa(countEmpty))
            countEmpty = 0
        }
        fen.WriteString(""/"")
        fmt.Println()
    }
    fen.WriteString("" w - - 0 1"")
    return fen.String()
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    fmt.Println(createFen())
}",1959,93
51481,http://rosettacode.org/wiki/Generate_Chess960_starting_position,Generate Chess960 starting position,"Chess960 is a variant of chess created by world champion Bobby Fischer. Unlike other variants of the game, Chess960 does not require a different material, but instead relies on a random initial position, with a few constraints:

 as in the standard chess game, all eight white pawns must be placed on the second rank.
 White pieces must stand on the first rank as in the standard game, in random column order but with the two following constraints:
 the bishops must be placed on opposite color squares (i.e. they must be an odd number of spaces apart or there must be an even number of spaces between them)
 the King must be between two rooks (with any number of other pieces between them all)
 Black pawns and pieces must be placed respectively on the seventh and eighth ranks, mirroring the white pawns and pieces, just as in the standard game. (That is, their positions are not independently randomized.)


With those constraints there are 960 possible starting positions, thus the name of the variant.



Task

The purpose of this task is to write a program that can randomly generate any one of the 960 Chess960 initial positions. You will show the result as the first rank displayed with Chess symbols in Unicode: ♔♕♖♗♘ or with the letters King Queen Rook Bishop kNight.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
)
 
type symbols struct{ k, q, r, b, n rune }
 
var A = symbols{'K', 'Q', 'R', 'B', 'N'}
var W = symbols{'♔', '♕', '♖', '♗', '♘'}
var B = symbols{'♚', '♛', '♜', '♝', '♞'}
 
var krn = []string{
    ""nnrkr"", ""nrnkr"", ""nrknr"", ""nrkrn"",
    ""rnnkr"", ""rnknr"", ""rnkrn"",
    ""rknnr"", ""rknrn"",
    ""rkrnn""}
 
func (sym symbols) chess960(id int) string {
    var pos [8]rune
    q, r := id/4, id%4
    pos[r*2+1] = sym.b
    q, r = q/4, q%4
    pos[r*2] = sym.b
    q, r = q/6, q%6
    for i := 0; ; i++ {
        if pos[i] != 0 {
            continue
        }
        if r == 0 {
            pos[i] = sym.q
            break
        }
        r--
    }
    i := 0
    for _, f := range krn[q] {
        for pos[i] != 0 {
            i++
        }
        switch f {
        case 'k':
            pos[i] = sym.k
        case 'r':
            pos[i] = sym.r
        case 'n':
            pos[i] = sym.n
        }
    }
    return string(pos[:])
}
 
func main() {
    fmt.Println("" ID  Start position"")
    for _, id := range []int{0, 518, 959} {
        fmt.Printf(""%3d  %s\n"", id, A.chess960(id))
    }
    fmt.Println(""\nRandom"")
    for i := 0; i < 5; i++ {
        fmt.Println(W.chess960(rand.Intn(960)))
    }
}",1257,63
51525,http://rosettacode.org/wiki/Generator/Exponential,Generator/Exponential,"A generator is an executable entity (like a function or procedure) that contains code that yields a sequence of values, one at a time, so that each time you call the generator, the next value in the sequence is provided.

Generators are often built on top of coroutines or objects so that the internal state of the object is handled “naturally”.

Generators are often used in situations where a sequence is potentially infinite, and where it is possible to construct the next value of the sequence with only minimal state.



Task

 Create a function that returns a generation of the m'th powers of the positive integers starting from zero, in order, and without obvious or simple upper limit. (Any upper limit to the generator should not be stated in the source but should be down to factors such as the languages natural integer size limit or computational time/size).
 Use it to create a generator of:
   Squares.
   Cubes. 
 Create a new generator that filters all cubes from the generator of squares.
 Drop the first 20 values from this last generator of filtered results, and then show the next 10 values.


Note that this task requires the use of generators in the calculation of the result.



Also see

 Generator

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
// note: exponent not limited to ints
func newPowGen(e float64) func() float64 {
    var i float64
    return func() (r float64) {
        r = math.Pow(i, e)
        i++
        return
    }
}
 
// given two functions af, bf, both monotonically increasing, return a
// new function that returns values of af not returned by bf.
func newMonoIncA_NotMonoIncB_Gen(af, bf func() float64) func() float64 {
    a, b := af(), bf()
    return func() (r float64) {
        for {
            if a < b {
                r = a
                a = af()
                break
            }
            if b == a {
                a = af()
            }
            b = bf()
        }
        return
    }
}
 
func main() {
    fGen := newMonoIncA_NotMonoIncB_Gen(newPowGen(2), newPowGen(3))
    for i := 0; i < 20; i++ {
        fGen()
    }
    for i := 0; i < 10; i++ {
        fmt.Print(fGen(), "" "")
    }
    fmt.Println()
}",963,47
51554,http://rosettacode.org/wiki/Gauss-Jordan_matrix_inversion,Gauss-Jordan matrix inversion,"Task

Invert matrix   A   using Gauss-Jordan method.

A   being an   n × n   matrix.



",#Go,Go,"package main
 
import ""fmt""
 
type vector = []float64
type matrix []vector
 
func (m matrix) inverse() matrix {
    le := len(m)
    for _, v := range m {
        if len(v) != le {
            panic(""Not a square matrix"")
        }
    }
    aug := make(matrix, le)
    for i := 0; i < le; i++ {
        aug[i] = make(vector, 2*le)
        copy(aug[i], m[i])
        // augment by identity matrix to right
        aug[i][i+le] = 1
    }
    aug.toReducedRowEchelonForm()
    inv := make(matrix, le)
    // remove identity matrix to left
    for i := 0; i < le; i++ {
        inv[i] = make(vector, le)
        copy(inv[i], aug[i][le:])
    }
    return inv
}
 
// note: this mutates the matrix in place
func (m matrix) toReducedRowEchelonForm() {
    lead := 0
    rowCount, colCount := len(m), len(m[0])
    for r := 0; r < rowCount; r++ {
        if colCount <= lead {
            return
        }
        i := r
 
        for m[i][lead] == 0 {
            i++
            if rowCount == i {
                i = r
                lead++
                if colCount == lead {
                    return
                }
            }
        }
 
        m[i], m[r] = m[r], m[i]
        if div := m[r][lead]; div != 0 {
            for j := 0; j < colCount; j++ {
                m[r][j] /= div
            }
        }
 
        for k := 0; k < rowCount; k++ {
            if k != r {
                mult := m[k][lead]
                for j := 0; j < colCount; j++ {
                    m[k][j] -= m[r][j] * mult
                }
            }
        }
        lead++
    }
}
 
func (m matrix) print(title string) {
    fmt.Println(title)
    for _, v := range m {
        fmt.Printf(""% f\n"", v)
    }
    fmt.Println()
}
 
func main() {
    a := matrix{{1, 2, 3}, {4, 1, 6}, {7, 8, 9}}
    a.inverse().print(""Inverse of A is:\n"")
 
    b := matrix{{2, -1, 0}, {-1, 2, -1}, {0, -1, 2}}
    b.inverse().print(""Inverse of B is:\n"")
}",1934,86
51567,http://rosettacode.org/wiki/Functional_coverage_tree,Functional coverage tree,"Functional coverage is a measure of how much a particular function of a system
has been verified as correct. It is used heavily in tracking the completeness
of the verification of complex System on Chip (SoC) integrated circuits, where
it can also be used to track how well the functional requirements of the
system have been verified.

This task uses a sub-set of the calculations sometimes used in tracking
functional coverage but uses a more familiar(?) scenario.

Task Description

The head of the clean-up crews for ""The Men in a very dark shade of grey when
viewed at night"" has been tasked with managing the cleansing of two properties
after an incident involving aliens.

She arranges the task hierarchically with a manager for the crews working on
each house who return with a breakdown of how they will report on progress in
each house.

The overall hierarchy of (sub)tasks is as follows,

cleaning
    house1
        bedrooms
        bathrooms
            bathroom1
            bathroom2
            outside lavatory
        attic
        kitchen
        living rooms
            lounge
            dining room
            conservatory
            playroom
        basement
        garage
        garden
    house2
        upstairs
            bedrooms
                suite 1
                suite 2
                bedroom 3
                bedroom 4
            bathroom
            toilet
            attics
        groundfloor
            kitchen
            living rooms
                lounge
                dining room
                conservatory
                playroom
            wet room & toilet
            garage
            garden
            hot tub suite
        basement
            cellars
            wine cellar
            cinema
The head of cleanup knows that her managers will report fractional completion of leaf tasks (tasks with no child tasks of their own), and she knows that she will want to modify the weight of values of completion as she sees fit.

Some time into the cleaning, and some coverage reports have come in and she thinks see needs to weight the big house2 60-40 with respect to coverage from house1 She prefers a tabular view of her data where missing weights are assumed to be 1.0 and missing coverage 0.0.

NAME_HIERARCHY                  |WEIGHT  |COVERAGE  |
cleaning                        |        |          |
    house1                      |40      |          |
        bedrooms                |        |0.25      |
        bathrooms               |        |          |
            bathroom1           |        |0.5       |
            bathroom2           |        |          |
            outside_lavatory    |        |1         |
        attic                   |        |0.75      |
        kitchen                 |        |0.1       |
        living_rooms            |        |          |
            lounge              |        |          |
            dining_room         |        |          |
            conservatory        |        |          |
            playroom            |        |1         |
        basement                |        |          |
        garage                  |        |          |
        garden                  |        |0.8       |
    house2                      |60      |          |
        upstairs                |        |          |
            bedrooms            |        |          |
                suite_1         |        |          |
                suite_2         |        |          |
                bedroom_3       |        |          |
                bedroom_4       |        |          |
            bathroom            |        |          |
            toilet              |        |          |
            attics              |        |0.6       |
        groundfloor             |        |          |
            kitchen             |        |          |
            living_rooms        |        |          |
                lounge          |        |          |
                dining_room     |        |          |
                conservatory    |        |          |
                playroom        |        |          |
            wet_room_&_toilet   |        |          |
            garage              |        |          |
            garden              |        |0.9       |
            hot_tub_suite       |        |1         |
        basement                |        |          |
            cellars             |        |1         |
            wine_cellar         |        |1         |
            cinema              |        |0.75      |
Calculation

The coverage of a node in the tree is calculated as the weighted average of the coverage of its children evaluated bottom-upwards in the tree.

The task is to calculate the overall coverage of the cleaning task and display the coverage at all levels of the hierarchy on this page, in a manner that visually shows the hierarchy, weights and coverage of all nodes.

Extra Credit

After calculating the coverage for all nodes, one can also calculate the additional/delta top level coverage that would occur if any (sub)task were to be fully covered from its current fractional coverage. This is done by multiplying the extra coverage that could be gained 



1
−
c
o
v
e
r
a
g
e


{\displaystyle 1-coverage}

 for any node, by the product of the `powers` of its parent nodes from the top down to the node.

The power of a direct child of any parent is given by the power of the parent multiplied by the weight of the child divided by the sum of the weights of all the direct children.

The pseudo code would be:

   method delta_calculation(this, power):
       sum_of_weights = sum(node.weight for node in children)
       this.delta  = (1 - this.coverage) * power
       for node in self.children:
           node.delta_calculation(power * node.weight / sum_of_weights)
       return this.delta

Followed by a call to:

   top.delta_calculation(power=1)


Note: to aid in getting the data into your program you might want to use an alternative, more functional description of the starting data given on the discussion page.
",#Go,Go,"package main
 
import ""fmt""
 
type FCNode struct {
    name     string
    weight   int
    coverage float64
    children []*FCNode
    parent   *FCNode
}
 
func newFCN(name string, weight int, coverage float64) *FCNode {
    return &FCNode{name, weight, coverage, nil, nil}
}
 
func (n *FCNode) addChildren(nodes []*FCNode) {
    for _, node := range nodes {
        node.parent = n
        n.children = append(n.children, node)
    }
    n.updateCoverage()
}
 
func (n *FCNode) setCoverage(value float64) {
    if n.coverage != value {
        n.coverage = value
        // update any parent's coverage
        if n.parent != nil {
            n.parent.updateCoverage()
        }
    }
}
 
func (n *FCNode) updateCoverage() {
    v1 := 0.0
    v2 := 0
    for _, node := range n.children {
        v1 += float64(node.weight) * node.coverage
        v2 += node.weight
    }
    n.setCoverage(v1 / float64(v2))
}
 
func (n *FCNode) show(level int) {
    indent := level * 4
    nl := len(n.name) + indent
    fmt.Printf(""%*s%*s  %3d   | %8.6f |\n"", nl, n.name, 32-nl, ""|"", n.weight, n.coverage)
    if len(n.children) == 0 {
        return
    }
    for _, child := range n.children {
        child.show(level + 1)
    }
}
 
var houses = []*FCNode{
    newFCN(""house1"", 40, 0),
    newFCN(""house2"", 60, 0),
}
 
var house1 = []*FCNode{
    newFCN(""bedrooms"", 1, 0.25),
    newFCN(""bathrooms"", 1, 0),
    newFCN(""attic"", 1, 0.75),
    newFCN(""kitchen"", 1, 0.1),
    newFCN(""living_rooms"", 1, 0),
    newFCN(""basement"", 1, 0),
    newFCN(""garage"", 1, 0),
    newFCN(""garden"", 1, 0.8),
}
 
var house2 = []*FCNode{
    newFCN(""upstairs"", 1, 0),
    newFCN(""groundfloor"", 1, 0),
    newFCN(""basement"", 1, 0),
}
 
var h1Bathrooms = []*FCNode{
    newFCN(""bathroom1"", 1, 0.5),
    newFCN(""bathroom2"", 1, 0),
    newFCN(""outside_lavatory"", 1, 1),
}
 
var h1LivingRooms = []*FCNode{
    newFCN(""lounge"", 1, 0),
    newFCN(""dining_room"", 1, 0),
    newFCN(""conservatory"", 1, 0),
    newFCN(""playroom"", 1, 1),
}
 
var h2Upstairs = []*FCNode{
    newFCN(""bedrooms"", 1, 0),
    newFCN(""bathroom"", 1, 0),
    newFCN(""toilet"", 1, 0),
    newFCN(""attics"", 1, 0.6),
}
 
var h2Groundfloor = []*FCNode{
    newFCN(""kitchen"", 1, 0),
    newFCN(""living_rooms"", 1, 0),
    newFCN(""wet_room_&_toilet"", 1, 0),
    newFCN(""garage"", 1, 0),
    newFCN(""garden"", 1, 0.9),
    newFCN(""hot_tub_suite"", 1, 1),
}
 
var h2Basement = []*FCNode{
    newFCN(""cellars"", 1, 1),
    newFCN(""wine_cellar"", 1, 1),
    newFCN(""cinema"", 1, 0.75),
}
 
var h2UpstairsBedrooms = []*FCNode{
    newFCN(""suite_1"", 1, 0),
    newFCN(""suite_2"", 1, 0),
    newFCN(""bedroom_3"", 1, 0),
    newFCN(""bedroom_4"", 1, 0),
}
 
var h2GroundfloorLivingRooms = []*FCNode{
    newFCN(""lounge"", 1, 0),
    newFCN(""dining_room"", 1, 0),
    newFCN(""conservatory"", 1, 0),
    newFCN(""playroom"", 1, 0),
}
 
func main() {
    cleaning := newFCN(""cleaning"", 1, 0)
 
    house1[1].addChildren(h1Bathrooms)
    house1[4].addChildren(h1LivingRooms)
    houses[0].addChildren(house1)
 
    h2Upstairs[0].addChildren(h2UpstairsBedrooms)
    house2[0].addChildren(h2Upstairs)
    h2Groundfloor[1].addChildren(h2GroundfloorLivingRooms)
    house2[1].addChildren(h2Groundfloor)
    house2[2].addChildren(h2Basement)
    houses[1].addChildren(house2)
 
    cleaning.addChildren(houses)
    topCoverage := cleaning.coverage
    fmt.Printf(""TOP COVERAGE = %8.6f\n\n"", topCoverage)
    fmt.Println(""NAME HIERARCHY                 | WEIGHT | COVERAGE |"")
    cleaning.show(0)
 
    h2Basement[2].setCoverage(1) // change Cinema node coverage to 1
    diff := cleaning.coverage - topCoverage
    fmt.Println(""\nIf the coverage of the Cinema node were increased from 0.75 to 1"")
    fmt.Print(""the top level coverage would increase by "")
    fmt.Printf(""%8.6f to %8.6f\n"", diff, topCoverage+diff)
    h2Basement[2].setCoverage(0.75) // restore to original value if required
}",3889,154
51624,http://rosettacode.org/wiki/General_FizzBuzz,General FizzBuzz,"Task

Write a generalized version of FizzBuzz that works for any list of factors, along with their words.

This is basically a ""fizzbuzz"" implementation where the user supplies the parameters.

The user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.

For simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.



For example, given:

>20      #This is the maximum number, supplied by the user
>3 Fizz  #The user now enters the starting factor (3) and the word they want associated with it (Fizz)
>5 Buzz  #The user now enters the next factor (5) and the word they want associated with it (Buzz)
>7 Baxx  #The user now enters the next factor (7) and the word they want associated with it (Baxx)

In other words: For this example, print the numbers 1 through 20, replacing every multiple of 3 with ""Fizz"", every multiple of 5 with ""Buzz"", and every multiple of 7 with ""Baxx"".

In the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor.

For instance, the number 15 is a multiple of both 3 and 5; print ""FizzBuzz"".

If the max number was 105 instead of 20, you would print ""FizzBuzzBaxx"" because it's a multiple of 3, 5, and 7.


Output:
1
2
Fizz
4
Buzz
Fizz
Baxx
8
Fizz
Buzz
11
Fizz
13
Baxx
FizzBuzz
16
17
Fizz
19
Buzz


",#Go,Go," 
package main
 
import (
	""fmt""
)
 
const numbers = 3
 
func main() {
 
	//using the provided data
	max := 20
	words := map[int]string{
		3: ""Fizz"",
		5: ""Buzz"",
		7: ""Baxx"",
	}
	keys := []int{3, 5, 7}
	divisible := false
	for i := 1; i <= max; i++ {
		for _, n := range keys {
			if i % n == 0 {
				fmt.Print(words[n])
				divisible = true
			}
		}
		if !divisible {
			fmt.Print(i)
		}
		fmt.Println()
		divisible = false
	}
 
}",432,35
51663,http://rosettacode.org/wiki/Function_prototype,Function prototype,"Some languages provide the facility to declare functions and subroutines through the use of function prototyping.



Task

Demonstrate the methods available for declaring prototypes within the language. The provided solutions should include:

 An explanation of any placement restrictions for prototype declarations
 A prototype declaration for a function that does not require arguments
 A prototype declaration for a function that requires two arguments
 A prototype declaration for a function that utilizes varargs
 A prototype declaration for a function that utilizes optional arguments
 A prototype declaration for a function that utilizes named parameters
 Example of prototype declarations for subroutines or procedures (if these differ from functions)
 An explanation and example of any special forms of prototyping not covered by the above


Languages that do not provide function prototyping facilities should be omitted from this task.



",#Go,Go,"func a()          // function with no arguments
func b(x, y int)  // function with two arguments
func c(...int)    // varargs are called ""variadic parameters"" in Go.",165,3
51722,http://rosettacode.org/wiki/Galton_box_animation,Galton box animation," Example of a Galton Box at the end of animation.


A   Galton device   Sir Francis Galton's device   is also known as a   bean machine,   a   Galton Board,   or a   quincunx.



Description of operation

In a Galton box, there are a set of pins arranged in a triangular pattern.   A number of balls are dropped so that they fall in line with the top pin, deflecting to the left or the right of the pin.   The ball continues to fall to the left or right of lower pins before arriving at one of the collection points between and to the sides of the bottom row of pins.

Eventually the balls are collected into bins at the bottom   (as shown in the image),   the ball column heights in the bins approximate a   bell curve.   Overlaying   Pascal's triangle   onto the pins shows the number of different paths that can be taken to get to each bin.



Task

Generate an animated simulation of a Galton device.



Task requirements

   The box should have at least 5 pins on the bottom row. 
   A solution can use graphics or ASCII animation. 
   Provide a sample of the output/display such as a screenshot.
   There can be one or more balls in flight at the same time. 
   If multiple balls are in flight, ensure they don't interfere with each other.
   A solution should allow users to specify the number of balls, or it should run until full or a preset limit. 
   Optionally,   display the number of balls.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
const boxW = 41      // Galton box width
const boxH = 37      // Galton box height.
const pinsBaseW = 19 // Pins triangle base.
const nMaxBalls = 55 // Number of balls.
 
const centerH = pinsBaseW + (boxW-pinsBaseW*2+1)/2 - 1
 
const (
    empty  = ' '
    ball   = 'o'
    wall   = '|'
    corner = '+'
    floor  = '-'
    pin    = '.'
)
 
type Ball struct{ x, y int }
 
func newBall(x, y int) *Ball {
    if box[y][x] != empty {
        panic(""Tried to create a new ball in a non-empty cell. Program terminated."")
    }
    b := Ball{x, y}
    box[y][x] = ball
    return &b
}
 
func (b *Ball) doStep() {
    if b.y <= 0 {
        return // Reached the bottom of the box.
    }
    cell := box[b.y-1][b.x]
    switch cell {
    case empty:
        box[b.y][b.x] = empty
        b.y--
        box[b.y][b.x] = ball
    case pin:
        box[b.y][b.x] = empty
        b.y--
        if box[b.y][b.x-1] == empty && box[b.y][b.x+1] == empty {
            b.x += rand.Intn(2)*2 - 1
            box[b.y][b.x] = ball
            return
        } else if box[b.y][b.x-1] == empty {
            b.x++
        } else {
            b.x--
        }
        box[b.y][b.x] = ball
    default:
        // It's frozen - it always piles on other balls.
    }
}
 
type Cell = byte
 
/* Galton box. Will be printed upside down. */
var box [boxH][boxW]Cell
 
func initializeBox() {
    // Set ceiling and floor
    box[0][0] = corner
    box[0][boxW-1] = corner
    for i := 1; i < boxW-1; i++ {
        box[0][i] = floor
    }
    for i := 0; i < boxW; i++ {
        box[boxH-1][i] = box[0][i]
    }
 
    // Set walls
    for r := 1; r < boxH-1; r++ {
        box[r][0] = wall
        box[r][boxW-1] = wall
    }
 
    // Set rest to empty initially
    for i := 1; i < boxH-1; i++ {
        for j := 1; j < boxW-1; j++ {
            box[i][j] = empty
        }
    }
 
    // Set pins
    for nPins := 1; nPins <= pinsBaseW; nPins++ {
        for p := 0; p < nPins; p++ {
            box[boxH-2-nPins][centerH+1-nPins+p*2] = pin
        }
    }
}
 
func drawBox() {
    for r := boxH - 1; r >= 0; r-- {
        for c := 0; c < boxW; c++ {
            fmt.Printf(""%c"", box[r][c])
        }
        fmt.Println()
    }
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    initializeBox()
    var balls []*Ball
    for i := 0; i < nMaxBalls+boxH; i++ {
        fmt.Println(""\nStep"", i, "":"")
        if i < nMaxBalls {
            balls = append(balls, newBall(centerH, boxH-2)) // add ball
        }
        drawBox()
 
        // Next step for the simulation.
        // Frozen balls are kept in balls slice for simplicity
        for _, b := range balls {
            b.doStep()
        }
    }
}",2750,127
51745,http://rosettacode.org/wiki/Function_frequency,Function frequency,"Display - for a program or runtime environment (whatever suits the style of your language) - the top ten most frequently occurring functions (or also identifiers or tokens, if preferred).

This is a static analysis: The question is not how often each function is
actually executed at runtime, but how often it is used by the programmer.

Besides its practical usefulness, the intent of this task is to show how to do self-inspection within the language.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""go/ast""
    ""go/parser""
    ""go/token""
    ""io/ioutil""
    ""os""
    ""sort""
)
 
func main() {
    if len(os.Args) != 2 {
        fmt.Println(""usage ff <go source filename>"")
        return
    }
    src, err := ioutil.ReadFile(os.Args[1])
    if err != nil {
        fmt.Println(err)
        return
    }
    fs := token.NewFileSet()
    a, err := parser.ParseFile(fs, os.Args[1], src, 0)
    if err != nil {
        fmt.Println(err)
        return
    }
    f := fs.File(a.Pos())
    m := make(map[string]int)
    ast.Inspect(a, func(n ast.Node) bool {
        if ce, ok := n.(*ast.CallExpr); ok {
            start := f.Offset(ce.Pos())
            end := f.Offset(ce.Lparen)
            m[string(src[start:end])]++
        }
        return true
    })
    cs := make(calls, 0, len(m))
    for k, v := range m {
        cs = append(cs, &call{k, v})
    }
    sort.Sort(cs)
    for i, c := range cs {
        fmt.Printf(""%-20s %4d\n"", c.expr, c.count)
        if i == 9 {
            break
        }
    }
}
 
type call struct {
    expr  string
    count int
}
type calls []*call
 
func (c calls) Len() int           { return len(c) }
func (c calls) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }
func (c calls) Less(i, j int) bool { return c[i].count > c[j].count }",1307,60
51750,http://rosettacode.org/wiki/Gaussian_elimination,Gaussian elimination,"Task

Solve   Ax=b   using Gaussian elimination then backwards substitution.

A   being an   n by n   matrix.

Also,   x and b   are   n by 1   vectors.

To improve accuracy, please use partial pivoting and scaling.



See also

   the Wikipedia entry:   Gaussian elimination

",#Go,Go,"package main
 
import (
    ""errors""
    ""fmt""
    ""log""
    ""math""
)
 
type testCase struct {
    a [][]float64
    b []float64
    x []float64
}
 
var tc = testCase{
    // common RC example.  Result x computed with rational arithmetic then
    // converted to float64, and so should be about as close to correct as
    // float64 represention allows.
    a: [][]float64{
        {1.00, 0.00, 0.00, 0.00, 0.00, 0.00},
        {1.00, 0.63, 0.39, 0.25, 0.16, 0.10},
        {1.00, 1.26, 1.58, 1.98, 2.49, 3.13},
        {1.00, 1.88, 3.55, 6.70, 12.62, 23.80},
        {1.00, 2.51, 6.32, 15.88, 39.90, 100.28},
        {1.00, 3.14, 9.87, 31.01, 97.41, 306.02}},
    b: []float64{-0.01, 0.61, 0.91, 0.99, 0.60, 0.02},
    x: []float64{-0.01, 1.602790394502114, -1.6132030599055613,
        1.2454941213714368, -0.4909897195846576, 0.065760696175232},
}
 
// result from above test case turns out to be correct to this tolerance.
const ε = 1e-13
 
func main() {
    x, err := GaussPartial(tc.a, tc.b)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(x)
    for i, xi := range x {
        if math.Abs(tc.x[i]-xi) > ε {
            log.Println(""out of tolerance"")
            log.Fatal(""expected"", tc.x)
        }
    }
}
 
func GaussPartial(a0 [][]float64, b0 []float64) ([]float64, error) {
    // make augmented matrix
    m := len(b0)
    a := make([][]float64, m)
    for i, ai := range a0 {
        row := make([]float64, m+1)
        copy(row, ai)
        row[m] = b0[i]
        a[i] = row
    }
    // WP algorithm from Gaussian elimination page
    // produces row-eschelon form
    for k := range a {
        // Find pivot for column k:
        iMax := k
        max := math.Abs(a[k][k])
        for i := k + 1; i < m; i++ {
            if abs := math.Abs(a[i][k]); abs > max {
                iMax = i
                max = abs
            }
        }
        if a[iMax][k] == 0 {
            return nil, errors.New(""singular"")
        }
        // swap rows(k, i_max)
        a[k], a[iMax] = a[iMax], a[k]
        // Do for all rows below pivot:
        for i := k + 1; i < m; i++ {
            // Do for all remaining elements in current row:
            for j := k + 1; j <= m; j++ {
                a[i][j] -= a[k][j] * (a[i][k] / a[k][k])
            }
            // Fill lower triangular matrix with zeros:
            a[i][k] = 0
        }
    }
    // end of WP algorithm.
    // now back substitute to get result.
    x := make([]float64, m)
    for i := m - 1; i >= 0; i-- {
        x[i] = a[i][m]
        for j := i + 1; j < m; j++ {
            x[i] -= a[i][j] * x[j]
        }
        x[i] /= a[i][i]
    }
    return x, nil
}",2662,97
51764,http://rosettacode.org/wiki/FTP,FTP,"Task
Connect to a server, change directory, list its contents and download a file as binary using the FTP protocol. Use passive mode if available.



",#Go,Go,"package main
 
import (
	""fmt""
	""io""
	""log""
	""os""
 
	""github.com/stacktic/ftp""
)
 
func main() {
	// Hard-coded demonstration values
	const (
		hostport = ""localhost:21""
		username = ""anonymous""
		password = ""anonymous""
		dir      = ""pub""
		file     = ""somefile.bin""
	)
 
	conn, err := ftp.Connect(hostport)
	if err != nil {
		log.Fatal(err)
	}
	defer conn.Quit()
	fmt.Println(conn)
 
	if err = conn.Login(username, password); err != nil {
		log.Fatal(err)
	}
	if err = conn.ChangeDir(dir); err != nil {
		log.Fatal(err)
	}
	fmt.Println(conn.CurrentDir())
	files, err := conn.List(""."")
	if err != nil {
		log.Fatal(err)
	}
	for _, f := range files {
		fmt.Printf(""%v %12d %v %v\n"", f.Time, f.Size, f.Type, f.Name)
	}
 
	r, err := conn.Retr(file)
	if err != nil {
		log.Fatal(err)
	}
	defer r.Close()
 
	f, err := os.Create(file)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
 
	n, err := io.Copy(f, r)
	if err != nil {
		log.Fatal(err)
	}
 
	fmt.Println(""Wrote"", n, ""bytes to"", file)
}",993,62
51769,http://rosettacode.org/wiki/French_Republican_calendar,French Republican calendar,"Write a program to convert dates between the Gregorian calendar and the French Republican calendar.

The year 1 of the Republican calendar began on 22 September 1792. There were twelve months (Vendémiaire, Brumaire, Frimaire, Nivôse, Pluviôse, Ventôse, Germinal, Floréal, Prairial, Messidor, Thermidor, and Fructidor) of 30 days each, followed by five intercalary days or Sansculottides (Fête de la vertu / Virtue Day, Fête du génie / Talent Day, Fête du travail / Labour Day, Fête de l'opinion / Opinion Day, and Fête des récompenses / Honours Day). In leap years (the years 3, 7, and 11) a sixth Sansculottide was added: Fête de la Révolution / Revolution Day.

As a minimum, your program should give correct results for dates in the range from 1 Vendémiaire 1 = 22 September 1792 to 10 Nivôse 14 = 31 December 1805 (the last day when the Republican calendar was officially in use). If you choose to accept later dates, be aware that there are several different methods (described on the Wikipedia page) about how to determine leap years after the year 14. You should indicate which method you are using. (Because of these different methods, correct programs may sometimes give different results for dates after 1805.)

Test your program by converting the following dates both from Gregorian to Republican and from Republican to Gregorian:

• 1 Vendémiaire 1 = 22 September 1792

• 1 Prairial 3 = 20 May 1795

• 27 Messidor 7 = 15 July 1799 (Rosetta Stone discovered)

• Fête de la Révolution 11 = 23 September 1803

• 10 Nivôse 14 = 31 December 1805
",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""os""
    ""strconv""
    ""strings""
)
 
var (
    gregorianStr = []string{""January"", ""February"", ""March"",
        ""April"", ""May"", ""June"",
        ""July"", ""August"", ""September"",
        ""October"", ""November"", ""December""}
    gregorian     = []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
    republicanStr = []string{""Vendemiaire"", ""Brumaire"", ""Frimaire"",
        ""Nivose"", ""Pluviose"", ""Ventose"",
        ""Germinal"", ""Floreal"", ""Prairial"",
        ""Messidor"", ""Thermidor"", ""Fructidor""}
    sansculottidesStr = []string{""Fete de la vertu"", ""Fete du genie"",
        ""Fete du travail"", ""Fete de l'opinion"",
        ""Fete des recompenses"", ""Fete de la Revolution""}
)
 
func main() {
    fmt.Println(""*** French  Republican ***"")
    fmt.Println(""*** calendar converter ***"")
    fmt.Println(""Enter a date to convert, in the format 'day month year'"")
    fmt.Println(""e.g.: 1 Prairial 3,"")
    fmt.Println(""      20 May 1795."")
    fmt.Println(""For Sansculottides, use 'day year'"")
    fmt.Println(""e.g.: Fete de l'opinion 9."")
    fmt.Println(""Or just press 'RETURN' to exit the program."")
    fmt.Println()
    for sc := bufio.NewScanner(os.Stdin); ; {
        fmt.Print(""> "")
        sc.Scan()
        src := sc.Text()
        if src == """" {
            return
        }
        day, month, year := split(src)
        if year < 1792 {
            day, month, year = dayToGre(repToDay(day, month, year))
            fmt.Println(day, gregorianStr[month-1], year)
        } else {
            day, month, year := dayToRep(greToDay(day, month, year))
            if month == 13 {
                fmt.Println(sansculottidesStr[day-1], year)
            } else {
                fmt.Println(day, republicanStr[month-1], year)
            }
        }
    }
}
 
func split(s string) (d, m, y int) {
    if strings.HasPrefix(s, ""Fete"") {
        m = 13
        for i, sc := range sansculottidesStr {
            if strings.HasPrefix(s, sc) {
                d = i + 1
                y, _ = strconv.Atoi(s[len(sc)+1:])
            }
        }
    } else {
        d, _ = strconv.Atoi(s[:strings.Index(s, "" "")])
        my := s[strings.Index(s, "" "")+1:]
        mStr := my[:strings.Index(my, "" "")]
        y, _ = strconv.Atoi(my[strings.Index(my, "" "")+1:])
        months := gregorianStr
        if y < 1792 {
            months = republicanStr
        }
        for i, mn := range months {
            if mn == mStr {
                m = i + 1
            }
        }
    }
    return
}
 
func greToDay(d, m, y int) int {
    if m < 3 {
        y--
        m += 12
    }
    return y*36525/100 - y/100 + y/400 + 306*(m+1)/10 + d - 654842
}
 
func repToDay(d, m, y int) int {
    if m == 13 {
        m--
        d += 30
    }
    if repLeap(y) {
        d--
    }
    return 365*y + (y+1)/4 - (y+1)/100 + (y+1)/400 + 30*m + d - 395
}
 
func dayToGre(day int) (d, m, y int) {
    y = day * 100 / 36525
    d = day - y*36525/100 + 21
    y += 1792
    d += y/100 - y/400 - 13
    m = 8
    for d > gregorian[m] {
        d -= gregorian[m]
        m++
        if m == 12 {
            m = 0
            y++
            if greLeap(y) {
                gregorian[1] = 29
            } else {
                gregorian[1] = 28
            }
        }
    }
    m++
    return
}
 
func dayToRep(day int) (d, m, y int) {
    y = (day-1) * 100 / 36525
    if repLeap(y) {
        y--
    }
    d = day - (y+1)*36525/100 + 365 + (y+1)/100 - (y+1)/400
    y++
    m = 1
    sansculottides := 5
    if repLeap(y) {
        sansculottides = 6
    }
    for d > 30 {
        d -= 30
        m += 1
        if m == 13 {
            if d > sansculottides {
                d -= sansculottides
                m = 1
                y++
                sansculottides = 5
                if repLeap(y) {
                    sansculottides = 6
                }
            }
        }
    }
    return
}
 
func repLeap(year int) bool {
    return (year+1)%4 == 0 && ((year+1)%100 != 0 || (year+1)%400 == 0)
}
 
func greLeap(year int) bool {
    return year%4 == 0 && (year%100 != 0 || year%400 == 0)
}",4125,163
51778,http://rosettacode.org/wiki/Gapful_numbers,Gapful numbers,"Numbers   (positive integers expressed in base ten)   that are (evenly) divisible by the number formed by the
first and last digit are known as   gapful numbers.


Evenly divisible   means divisible with   no   remainder.



All   one─   and two─digit   numbers have this property and are trivially excluded.   Only
numbers    ≥  100   will be considered for this Rosetta Code task.



Example

187   is a   gapful   number because it is evenly divisible by the
number   17   which is formed by the first and last decimal digits
of    187. 



About   7.46%   of positive integers are   gapful.



Task

   Generate and show all sets of numbers (below) on one line (horizontally) with a title,   here on this page
   Show the first   30   gapful numbers
   Show the first   15   gapful numbers    ≥           1,000,000
   Show the first   10   gapful numbers    ≥    1,000,000,000


Related tasks

   Harshad or Niven series.
   palindromic gapful numbers.
   largest number divisible by its digits.


Also see

   The OEIS entry:   A108343 gapful numbers.
   numbersaplenty gapful numbers

",#Go,Go,"package main
 
import ""fmt""
 
func commatize(n uint64) string {
    s := fmt.Sprintf(""%d"", n)
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    return s
}
 
func main() {
    starts := []uint64{1e2, 1e6, 1e7, 1e9, 7123}
    counts := []int{30, 15, 15, 10, 25}
    for i := 0; i < len(starts); i++ {
        count := 0
        j := starts[i]
        pow := uint64(100)
        for {
            if j < pow*10 {
                break
            }
            pow *= 10
        }
        fmt.Printf(""First %d gapful numbers starting at %s:\n"", counts[i], commatize(starts[i]))
        for count < counts[i] {
            fl := (j/pow)*10 + (j % 10)
            if j%fl == 0 {
                fmt.Printf(""%d "", j)
                count++
            }
            j++
            if j >= 10*pow {
                pow *= 10
            }
        }
        fmt.Println(""\n"")
    }
}",925,41
51984,http://rosettacode.org/wiki/Generate_lower_case_ASCII_alphabet,Generate lower case ASCII alphabet,"Task

Generate an array, list, lazy sequence, or even an indexable string of all the lower case ASCII characters, from  a  to  z. If the standard library contains such a sequence, show how to access it, but don't fail to show how to generate a similar sequence.

For this basic task use a reliable style of coding, a style fit for a very large program, and use strong typing if available. It's bug prone to enumerate all the lowercase characters manually in the code.

During code review it's not immediate obvious to spot the bug in a Tcl line like this contained in a page of code:

set alpha {a b c d e f g h i j k m n o p q r s t u v w x y z}



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"func loweralpha() string {
	p := make([]byte, 26)
	for i := range p {
		p[i] = 'a' + byte(i)
	}
	return string(p)
}",115,7
52039,http://rosettacode.org/wiki/Fusc_sequence,Fusc sequence,"

Definitions

The   fusc   integer sequence is defined as:

   fusc(0) = 0
   fusc(1) = 1
   for n>1,   the   nth   term is defined as:
   if   n   is even;     fusc(n) = fusc(n/2)
   if   n   is   odd;     fusc(n) = fusc((n-1)/2)   +   fusc((n+1)/2)


Note that MathWorld's definition starts with unity, not zero.   This task will be using the OEIS' version   (above).



An observation

   fusc(A) = fusc(B)
where   A   is some non-negative integer expressed in binary,   and
where   B   is the binary value of   A   reversed.



Fusc numbers are also known as:

   fusc function   (named by Dijkstra, 1982)
   Stern's Diatomic series   (although it starts with unity, not zero)
   Stern-Brocot sequence   (although it starts with unity, not zero)


Task

   show the first   61   fusc numbers (starting at zero) in a horizontal format.
   show the fusc number (and its index) whose length is greater than any previous fusc number length.
   (the length is the number of decimal digits when the fusc number is expressed in base ten.)
   show all numbers with commas   (if appropriate).
   show all output here.


Related task

   RosettaCode Stern-Brocot sequence


Also see

   the MathWorld entry:   Stern's Diatomic Series.
   the OEIS entry:   A2487.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
func fusc(n int) []int {
    if n <= 0 {
        return []int{}
    }
    if n == 1 {
        return []int{0}
    }    
    res := make([]int, n)
    res[0] = 0
    res[1] = 1
    for i := 2; i < n; i++ {
        if i%2 == 0 {
            res[i] = res[i/2]
        } else {
            res[i] = res[(i-1)/2] + res[(i+1)/2]
        }
    }
    return res
}
 
func fuscMaxLen(n int) [][2]int {
    maxLen := -1
    maxFusc := -1
    f := fusc(n)
    var res [][2]int
    for i := 0; i < n; i++ {
        if f[i] <= maxFusc {
            continue // avoid expensive strconv operation where possible
        }
        maxFusc = f[i]
        le := len(strconv.Itoa(f[i]))
        if le > maxLen {
            res = append(res, [2]int{i, f[i]})
            maxLen = le
        }
    }
    return res
}
 
func commatize(n int) string {
    s := fmt.Sprintf(""%d"", n)
    if n < 0 {
        s = s[1:]
    }
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    if n >= 0 {
        return s
    }
    return ""-"" + s
}
 
func main() {
    fmt.Println(""The first 61 fusc numbers are:"")
    fmt.Println(fusc(61))
    fmt.Println(""\nThe fusc numbers whose length > any previous fusc number length are:"")
    res := fuscMaxLen(20000000)  // examine first twenty million numbers say
    for i := 0; i < len(res); i++ {
        fmt.Printf(""%7s (index %10s)\n"", commatize(res[i][1]), commatize(res[i][0]))
    }
}",1491,70
52075,http://rosettacode.org/wiki/Fraction_reduction,Fraction reduction,"              There is a fine line between numerator and denominator.       ─── anonymous



A method to   ""reduce""   some reducible fractions is to   cross out   a digit from the
numerator and the denominator.   An example is:

       16                                                  16
      ────     and then (simply) cross─out the sixes:      ────
       64                                                  64

resulting in:

        1
       ───    
        4



Naturally,   this ""method"" of reduction must reduce to the proper value   (shown as a fraction).

This ""method"" is also known as   anomalous cancellation   and also   accidental cancellation.



(Of course,   this ""method"" shouldn't be taught to impressionable or gullible minds.)        😇 



Task

Find and show some fractions that can be reduced by the above ""method"".

   show 2-digit fractions found   (like the example shown above)
   show 3-digit fractions
   show 4-digit fractions
   show 5-digit fractions   (and higher)       (optional)
   show each (above) n-digit fractions separately from other different n-sized fractions, don't mix different ""sizes"" together
   for each ""size"" fraction,   only show a dozen examples   (the 1st twelve found)
   (it's recognized that not every programming solution will have the same generation algorithm)
   for each ""size"" fraction:
   show a count of how many reducible fractions were found.   The example (above) is size 2
   show a count of which digits were crossed out   (one line for each different digit)
   for each ""size"" fraction,   show a count of how many were found.   The example (above) is size 2
   show each n-digit example   (to be shown on one line):
   show each n-digit fraction
   show each reduced n-digit fraction
   show what digit was crossed out for the numerator and the denominator


Task requirements/restrictions

   only proper fractions and their reductions   (the result)   are to be used   (no vulgar fractions)
   only positive fractions are to be used   (no negative signs anywhere)
   only base ten integers are to be used for the numerator and denominator
   no zeros   (decimal digit)   can be used within the numerator or the denominator
   the numerator and denominator should be composed of the same number of digits
   no digit can be repeated in the numerator
   no digit can be repeated in the denominator
   (naturally)   there should be a shared decimal digit in the numerator   and   the denominator
   fractions can be shown as   16/64   (for example)


Show all output here, on this page.



Somewhat related task

   Farey sequence       (It concerns fractions.) 


References

   Wikipedia entry:   proper and improper fractions.
   Wikipedia entry:   anomalous cancellation and/or accidental cancellation.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""time""
)
 
func indexOf(n int, s []int) int {
    for i, j := range s {
        if n == j {
            return i
        }
    }
    return -1
}
 
func getDigits(n, le int, digits []int) bool {
    for n > 0 {
        r := n % 10
        if r == 0 || indexOf(r, digits) >= 0 {
            return false
        }
        le--
        digits[le] = r
        n /= 10
    }
    return true
}
 
var pows = [5]int{1, 10, 100, 1000, 10000}
 
func removeDigit(digits []int, le, idx int) int {
    sum := 0
    pow := pows[le-2]
    for i := 0; i < le; i++ {
        if i == idx {
            continue
        }
        sum += digits[i] * pow
        pow /= 10
    }
    return sum
}
 
func main() {
    start := time.Now()
    lims := [5][2]int{
        {12, 97},
        {123, 986},
        {1234, 9875},
        {12345, 98764},
        {123456, 987653},
    }
    var count [5]int
    var omitted [5][10]int
    for i, lim := range lims {
        nDigits := make([]int, i+2)
        dDigits := make([]int, i+2)
        blank := make([]int, i+2)
        for n := lim[0]; n <= lim[1]; n++ {
            copy(nDigits, blank)
            nOk := getDigits(n, i+2, nDigits)
            if !nOk {
                continue
            }
            for d := n + 1; d <= lim[1]+1; d++ {
                copy(dDigits, blank)
                dOk := getDigits(d, i+2, dDigits)
                if !dOk {
                    continue
                }
                for nix, digit := range nDigits {
                    if dix := indexOf(digit, dDigits); dix >= 0 {
                        rn := removeDigit(nDigits, i+2, nix)
                        rd := removeDigit(dDigits, i+2, dix)
                        if float64(n)/float64(d) == float64(rn)/float64(rd) {
                            count[i]++
                            omitted[i][digit]++
                            if count[i] <= 12 {
                                fmt.Printf(""%d/%d = %d/%d by omitting %d's\n"", n, d, rn, rd, digit)
                            }
                        }
                    }
                }
            }
        }
        fmt.Println()
    }
 
    for i := 2; i <= 6; i++ {
        fmt.Printf(""There are %d %d-digit fractions of which:\n"", count[i-2], i)
        for j := 1; j <= 9; j++ {
            if omitted[i-2][j] == 0 {
                continue
            }
            fmt.Printf(""%6d have %d's omitted\n"", omitted[i-2][j], j)
        }
        fmt.Println()
    }
    fmt.Printf(""Took %s\n"", time.Since(start))
}",2549,101
52092,http://rosettacode.org/wiki/Fractal_tree,Fractal tree,"Generate and draw a fractal tree.

 Draw the trunk
 At the end of the trunk, split by some angle and draw two branches
 Repeat at the end of each branch until a sufficient level of branching is reached


Related tasks
 Pythagoras Tree

",#Go,Go,"package main
 
// Files required to build supporting package raster are found in:
// * Bitmap
// * Grayscale image
// * Xiaolin Wu's line algorithm
// * Write a PPM file
 
import (
    ""math""
    ""raster""
)
 
const (
    width  = 400
    height = 300
    depth  = 8
    angle  = 12
    length = 50
    frac   = .8
)
 
func main() {
    g := raster.NewGrmap(width, height)
    ftree(g, width/2, height*9/10, length, 0, depth)
    g.Bitmap().WritePpmFile(""ftree.ppm"")
}
 
func ftree(g *raster.Grmap, x, y, distance, direction float64, depth int) {
    x2 := x + distance*math.Sin(direction*math.Pi/180)
    y2 := y - distance*math.Cos(direction*math.Pi/180)
    g.AaLine(x, y, x2, y2)
    if depth > 0 {
        ftree(g, x2, y2, distance*frac, direction-angle, depth-1)
        ftree(g, x2, y2, distance*frac, direction+angle, depth-1)
    }
}",841,37
52116,http://rosettacode.org/wiki/Gamma_function,Gamma function,"Task

Implement one algorithm (or more) to compute the Gamma (



Γ


{\displaystyle \Gamma }

) function (in the real field only).

If your language has the function as built-in or you know a library which has it, compare your implementation's results with the results of the built-in/library function.

The Gamma function can be defined as:

  



Γ
(
x
)
=


∫

0


∞



t

x
−
1



e

−
t


d
t



{\displaystyle \Gamma (x)=\displaystyle \int _{0}^{\infty }t^{x-1}e^{-t}dt}


This suggests a straightforward (but inefficient) way of computing the 



Γ


{\displaystyle \Gamma }

 through numerical integration.



Better suggested methods:

 Lanczos approximation
 Stirling's approximation

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func main() {
    fmt.Println(""    x               math.Gamma                 Lanczos7"")
    for _, x := range []float64{-.5, .1, .5, 1, 1.5, 2, 3, 10, 140, 170} {
        fmt.Printf(""%5.1f %24.16g %24.16g\n"", x, math.Gamma(x), lanczos7(x))
    }
}
 
func lanczos7(z float64) float64 {
    t := z + 6.5
    x := .99999999999980993 +
        676.5203681218851/z -
        1259.1392167224028/(z+1) +
        771.32342877765313/(z+2) -
        176.61502916214059/(z+3) +
        12.507343278686905/(z+4) -
        .13857109526572012/(z+5) +
        9.9843695780195716e-6/(z+6) +
        1.5056327351493116e-7/(z+7)
    return math.Sqrt2 * math.SqrtPi * math.Pow(t, z-.5) * math.Exp(-t) * x
}",737,27
52246,http://rosettacode.org/wiki/Function_composition,Function composition,"Task

Create a function, compose,   whose two arguments   f   and   g,   are both functions with one argument.



The result of compose is to be a function of one argument, (lets call the argument   x),   which works like applying function    f    to the result of applying function    g    to    x.



Example

 compose(f, g) (x) = f(g(x))



Reference: Function composition

Hint: In some languages, implementing compose correctly requires creating a closure.



",#Go,Go,"// Go doesn't have generics, but sometimes a type definition helps
// readability and maintainability.   This example is written to
// the following function type, which uses float64.
type ffType func(float64) float64
 
// compose function requested by task
func compose(f, g ffType) ffType {
    return func(x float64) float64 {
        return f(g(x))
    }
}",360,11
52249,http://rosettacode.org/wiki/Fractran,Fractran,"FRACTRAN is a Turing-complete esoteric programming language invented by the mathematician John Horton Conway.

A FRACTRAN program is an ordered list of positive fractions 



P
=
(

f

1


,

f

2


,
…
,

f

m


)


{\displaystyle P=(f_{1},f_{2},\ldots ,f_{m})}

, together with an initial positive integer input 



n


{\displaystyle n}

.



The program is run by updating the integer 



n


{\displaystyle n}

 as follows:

 for the first fraction, 




f

i




{\displaystyle f_{i}}

, in the list for which 



n

f

i




{\displaystyle nf_{i}}

 is an integer, replace 



n


{\displaystyle n}

 with 



n

f

i




{\displaystyle nf_{i}}

 ;
 repeat this rule until no fraction in the list produces an integer when multiplied by 



n


{\displaystyle n}

, then halt.


Conway gave a program for primes in FRACTRAN:

 



17

/

91


{\displaystyle 17/91}

, 



78

/

85


{\displaystyle 78/85}

, 



19

/

51


{\displaystyle 19/51}

, 



23

/

38


{\displaystyle 23/38}

, 



29

/

33


{\displaystyle 29/33}

, 



77

/

29


{\displaystyle 77/29}

, 



95

/

23


{\displaystyle 95/23}

, 



77

/

19


{\displaystyle 77/19}

, 



1

/

17


{\displaystyle 1/17}

, 



11

/

13


{\displaystyle 11/13}

, 



13

/

11


{\displaystyle 13/11}

, 



15

/

14


{\displaystyle 15/14}

, 



15

/

2


{\displaystyle 15/2}

, 



55

/

1


{\displaystyle 55/1}


Starting with 



n
=
2


{\displaystyle n=2}

, this FRACTRAN program will change 



n


{\displaystyle n}

 to 



15
=
2
×
(
15

/

2
)


{\displaystyle 15=2\times (15/2)}

, then 



825
=
15
×
(
55

/

1
)


{\displaystyle 825=15\times (55/1)}

, generating the following sequence of integers:

 



2


{\displaystyle 2}

, 



15


{\displaystyle 15}

, 



825


{\displaystyle 825}

, 



725


{\displaystyle 725}

, 



1925


{\displaystyle 1925}

, 



2275


{\displaystyle 2275}

, 



425


{\displaystyle 425}

, 



390


{\displaystyle 390}

, 



330


{\displaystyle 330}

, 



290


{\displaystyle 290}

, 



770


{\displaystyle 770}

, 



…


{\displaystyle \ldots }


After 2, this sequence contains the following powers of 2:






2

2


=
4


{\displaystyle 2^{2}=4}

, 




2

3


=
8


{\displaystyle 2^{3}=8}

, 




2

5


=
32


{\displaystyle 2^{5}=32}

, 




2

7


=
128


{\displaystyle 2^{7}=128}

, 




2

11


=
2048


{\displaystyle 2^{11}=2048}

, 




2

13


=
8192


{\displaystyle 2^{13}=8192}

, 




2

17


=
131072


{\displaystyle 2^{17}=131072}

, 




2

19


=
524288


{\displaystyle 2^{19}=524288}

, 



…


{\displaystyle \ldots }


which are the prime powers of 2.



Task

Write a program that reads a list of fractions in a natural format from the keyboard or from a string,
to parse it into a sequence of fractions (i.e. two integers),
and runs the FRACTRAN starting from a provided integer, writing the result at each step.
It is also required that the number of steps is limited (by a parameter easy to find).



Extra credit

Use this program to derive the first 20 or so prime numbers.



See also

For more on how to program FRACTRAN as a universal programming language, see:

 J. H. Conway (1987). Fractran: A Simple Universal Programming Language for Arithmetic. In: Open Problems in Communication and Computation, pages 4–26. Springer.
 J. H. Conway (2010). ""FRACTRAN: A simple universal programming language for arithmetic"". In Jeffrey C. Lagarias. The Ultimate Challenge: the 3x+1 problem. American Mathematical Society. pp. 249–264. ISBN 978-0-8218-4940-8. Zbl 1216.68068.
 Number Pathology: Fractran by Mark C. Chu-Carroll; October 27, 2006.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math/big""
    ""os""
    ""strconv""
    ""strings""
)
 
func compile(src string) ([]big.Rat, bool) {
    s := strings.Fields(src)
    r := make([]big.Rat, len(s))
    for i, s1 := range s {
        if _, ok := r[i].SetString(s1); !ok {
            return nil, false
        }
    }
    return r, true
}
 
func exec(p []big.Rat, n *big.Int, limit int) {
    var q, r big.Int
rule:
    for i := 0; i < limit; i++ {
        fmt.Printf(""%d "", n)
        for j := range p {
            q.QuoRem(n, p[j].Denom(), &r)
            if r.BitLen() == 0 {
                n.Mul(&q, p[j].Num())
                continue rule
            }
        }
        break
    }
    fmt.Println()
}
 
func usage() {
    log.Fatal(""usage: ft <limit> <n> <prog>"")
}
 
func main() {
    if len(os.Args) != 4 {
        usage()
    }
    limit, err := strconv.Atoi(os.Args[1])
    if err != nil {
        usage()
    }
    var n big.Int
    _, ok := n.SetString(os.Args[2], 10)
    if !ok {
        usage()
    }
    p, ok := compile(os.Args[3])
    if !ok {
        usage()
    }
    exec(p, &n, limit)
}",1121,62
52657,http://rosettacode.org/wiki/Fortunate_numbers,Fortunate numbers,"Definition
A Fortunate number is the smallest integer m > 1 such that for a given positive integer n, primorial(n) + m is a prime number, where primorial(n) is the product of the first n prime numbers.

For example the first fortunate number is 3 because primorial(1) is 2 and 2 + 3 = 5 which is prime whereas 2 + 2 = 4 is composite.



Task
After sorting and removal of any duplicates, compute and show on this page the first 8 Fortunate numbers or, if your language supports big integers, the first 50 Fortunate numbers.



Related task
 Primorial numbers


See also
 oeis:A005235 Fortunate numbers 
 oeis:A046066 Fortunate numbers, sorted with duplicates removed

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""rcu""
    ""sort""
)
 
func main() {
    primes := rcu.Primes(379)
    primorial := big.NewInt(1)
    var fortunates []int
    bPrime := new(big.Int)
    for _, prime := range primes {
        bPrime.SetUint64(uint64(prime))
        primorial.Mul(primorial, bPrime)
        for j := 3; ; j += 2 {
            jj := big.NewInt(int64(j))
            bPrime.Add(primorial, jj)
            if bPrime.ProbablyPrime(5) {
                fortunates = append(fortunates, j)
                break
            }
        }
    }
    m := make(map[int]bool)
    for _, f := range fortunates {
        m[f] = true
    }
    fortunates = fortunates[:0]
    for k := range m {
        fortunates = append(fortunates, k)
    }
    sort.Ints(fortunates)
    fmt.Println(""After sorting, the first 50 distinct fortunate numbers are:"")
    for i, f := range fortunates[0:50] {
        fmt.Printf(""%3d "", f)
        if (i+1)%10 == 0 {
            fmt.Println()
        }
    }
    fmt.Println()
}",1026,44
52737,http://rosettacode.org/wiki/Function_definition,Function definition,"A function is a body of code that returns a value.

The value returned may depend on arguments provided to the function.



Task

Write a definition of a function called ""multiply"" that takes two arguments and returns their product.

(Argument types should be chosen so as not to distract from showing how functions are created and values returned).



Related task

   Function prototype

",#Go,Go,"func multiply(a, b float64) float64 {
   return a * b
}",55,3
52813,http://rosettacode.org/wiki/Fork,Fork,"Task

Spawn a new process which can run simultaneously with, and independently of, the original parent process.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""os""
)
 
func main() {
    fmt.Printf(""PID: %v\n"", os.Getpid())
    if len(os.Args) < 2 {
        fmt.Println(""Done."")
        return
    }
    cp, err := os.StartProcess(os.Args[0], nil,
        &os.ProcAttr{Files: []*os.File{nil, os.Stdout}},
    )
    if err != nil {
        fmt.Println(err)
    }
    // Child process running independently at this point.
    // We have its PID and can print it.
    fmt.Printf(""Child's PID: %v\n"", cp.Pid)
    if _, err = cp.Wait(); err != nil {
        fmt.Println(err)
    }
}",555,26
52834,http://rosettacode.org/wiki/Four_is_the_number_of_letters_in_the_...,Four is the number of letters in the ...,"The      Four is ...      sequence is based on the counting of the number of
letters in the words of the (never─ending) sentence:

  Four is the number of letters in the first word of this sentence, two in the second,
  three in the third, six in the fourth, two in the fifth, seven in the sixth, ··· 



Definitions and directives

   English is to be used in spelling numbers.
   Letters   are defined as the upper─ and lowercase letters in the Latin alphabet   (A──►Z   and   a──►z).
   Commas are not counted,   nor are hyphens (dashes or minus signs).
   twenty─three   has eleven letters.
   twenty─three   is considered one word   (which is hyphenated).
   no    and    words are to be used when spelling a (English) word for a number.
   The American version of numbers will be used here in this task   (as opposed to the British version).
         2,000,000,000   is two billion,   not   two milliard.



Task

   Write a driver (invoking routine) and a function (subroutine/routine···) that returns the sequence (for any positive integer) of the number of letters in the first   N   words in the never─ending sentence.   For instance, the portion of the never─ending sentence shown above (2nd sentence of this task's preamble),   the sequence would be:
         4  2  3  6  2  7

   Only construct as much as is needed for the never─ending sentence.
   Write a driver (invoking routine) to show the number of letters in the   Nth   word,   as well as   showing the   Nth   word itself.
   After each test case, show the total number of characters   (including blanks, commas, and punctuation)   of the sentence that was constructed.
   Show all output here.


Test cases

 Display the first  201  numbers in the sequence   (and the total number of characters in the sentence).
 Display the number of letters  (and the word itself)  of the       1,000th  word.
 Display the number of letters  (and the word itself)  of the      10,000th  word.
 Display the number of letters  (and the word itself)  of the     100,000th  word.
 Display the number of letters  (and the word itself)  of the   1,000,000th  word.
 Display the number of letters  (and the word itself)  of the  10,000,000th  word  (optional).



Related tasks

   Four is magic
   Look-and-say sequence
   Number names
   Self-describing numbers
   Self-referential sequence
   Spelling of ordinal numbers


Also see

   See the OEIS sequence  A72425 ""Four is the number of letters..."".
   See the OEIS sequence  A72424 ""Five's the number of letters...""

",#Go,Go,"package main
 
import (
	""fmt""
	""strings""
	""unicode""
)
 
func main() {
	f := NewFourIsSeq()
	fmt.Print(""The lengths of the first 201 words are:"")
	for i := 1; i <= 201; i++ {
		if i%25 == 1 {
			fmt.Printf(""\n%3d: "", i)
		}
		_, n := f.WordLen(i)
		fmt.Printf("" %2d"", n)
	}
	fmt.Println()
	fmt.Println(""Length of sentence so far:"", f.TotalLength())
	/* For debugging:
	log.Println(""sentence:"", strings.Join(f.words, "" ""))
	for i, w := range f.words {
		log.Printf(""%3d: %2d %q\n"", i, countLetters(w), w)
	}
	log.Println(f.WordLen(2202))
	log.Println(""len(f.words):"", len(f.words))
	log.Println(""sentence:"", strings.Join(f.words, "" ""))
	*/
	for i := 1000; i <= 1e7; i *= 10 {
		w, n := f.WordLen(i)
		fmt.Printf(""Word %8d is %q, with %d letters."", i, w, n)
		fmt.Println(""  Length of sentence so far:"", f.TotalLength())
	}
}
 
type FourIsSeq struct {
	i     int      // index of last word processed
	words []string // strings.Join(words,"" "") gives the sentence so far
}
 
func NewFourIsSeq() *FourIsSeq {
	return &FourIsSeq{
		//words: strings.Fields(""Four is the number of letters in the first word of this sentence,""),
		words: []string{
			""Four"", ""is"", ""the"", ""number"",
			""of"", ""letters"", ""in"", ""the"",
			""first"", ""word"", ""of"", ""this"", ""sentence,"",
		},
	}
}
 
// WordLen returns the w'th word and its length (only counting letters).
func (f *FourIsSeq) WordLen(w int) (string, int) {
	for len(f.words) < w {
		f.i++
		n := countLetters(f.words[f.i])
		ns := say(int64(n))
		os := sayOrdinal(int64(f.i+1)) + "",""
		// append something like: ""two in the second,""
		f.words = append(f.words, strings.Fields(ns)...)
		f.words = append(f.words, ""in"", ""the"")
		f.words = append(f.words, strings.Fields(os)...)
	}
	word := f.words[w-1]
	return word, countLetters(word)
}
 
// TotalLength returns the total number of characters (including blanks,
// commas, and punctuation) of the sentence so far constructed.
func (f FourIsSeq) TotalLength() int {
	cnt := 0
	for _, w := range f.words {
		cnt += len(w) + 1
	}
	return cnt - 1
}
 
func countLetters(s string) int {
	cnt := 0
	for _, r := range s {
		if unicode.IsLetter(r) {
			cnt++
		}
	}
	return cnt
}
 
// ...
// the contents of
// https://rosettacode.org/wiki/Spelling_of_ordinal_numbers#Go
// omitted from this listing
// ...
 ",2280,94
52911,http://rosettacode.org/wiki/Formal_power_series,Formal power series,"A power series is an infinite sum of the form






a

0


+

a

1


⋅
x
+

a

2


⋅

x

2


+

a

3


⋅

x

3


+
⋯


{\displaystyle a_{0}+a_{1}\cdot x+a_{2}\cdot x^{2}+a_{3}\cdot x^{3}+\cdots }



The ai are called the coefficients of the series. Such sums can be added, multiplied etc., where the new coefficients of the powers of x are calculated according to the usual rules.

If one is not interested in evaluating such a series for particular values of x, or in other words, if convergence doesn't play a role, then such a collection of coefficients is called formal power series. It can be treated like a new kind of number.

Task: Implement formal power series as a numeric type. Operations should at least include addition, multiplication, division and additionally non-numeric operations like differentiation and integration (with an integration constant of zero). Take care that your implementation deals with the potentially infinite number of coefficients.

As an example, define the power series of sine and cosine in terms of each other using integration, as in





sin
⁡
x
=

∫

0


x


cos
⁡
t

d
t


{\displaystyle \sin x=\int _{0}^{x}\cos t\,dt}







cos
⁡
x
=
1
−

∫

0


x


sin
⁡
t

d
t


{\displaystyle \cos x=1-\int _{0}^{x}\sin t\,dt}



Goals: Demonstrate how the language handles new numeric types and delayed (or lazy) evaluation.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
// Task:  Formal power series type
//
// Go does not have a concept of numeric types other than the built in
// integers, floating points, and so on.  Nor does it have function or
// operator overloading, or operator defintion.  The type use to implement
// fps here is an interface with a single method, extract.
// While not named in the task description, extract is described in the
// WP article as ""important.""  In fact, by representing a way to index
// all of the coefficients of a fps, any type that implements the interface
// represents a formal power series.
 
type fps interface {
    extract(int) float64
}
 
// Task:  Operations on FPS
//
// Separate operations are implemented with separate extract methods.
// This requires each operation on the fps type to have a concrete type.
// Executing a fps operation is the act of instantiating the concrete type.
// This is implemented here with constructor functions that construct a
// new fps from fps arguments.
 
// Constructor functions are shown here as a group, followed by concrete
// type definitions and associated extract methods.
 
func one() fps {
    return &oneFps{}
}
 
func add(s1, s2 fps) fps {
    return &sum{s1: s1, s2: s2}
}
 
func sub(s1, s2 fps) fps {
    return &diff{s1: s1, s2: s2}
}
 
func mul(s1, s2 fps) fps {
    return &prod{s1: s1, s2: s2}
}
 
func div(s1, s2 fps) fps {
    return &quo{s1: s1, s2: s2}
}
 
func differentiate(s1 fps) fps {
    return &deriv{s1: s1}
}
 
func integrate(s1 fps) fps {
    return &integ{s1: s1}
}
 
// Example:  Mutually recursive defintion of sine and cosine.
// This is a constructor just as those above.  It is nullary and returns
// two fps.  Note sin and cos implemented as instances of other fps defined
// above, and so do not need new concrete types.  Note also the constant
// term of the integration fps provides the case that terminates recursion
// of the extract function.
func sinCos() (fps, fps) {
    sin := &integ{}
    cos := sub(one(), integrate(sin))
    sin.s1 = cos
    return sin, cos
}
 
// Following are type definitions and extract methods for fps operators
// (constructor functions) just defined.
//
// Goal:  lazy evaluation
//
// Go has no built in support for lazy evaluation, so we make it from
// scratch here.  Types contain, at a minimum, their fps operands and
// representation neccessary to implement lazy evaluation.  Typically
// this is a coefficient slice, although constant terms are not stored,
// so in the case of a constant fps, no slice is needed at all.
// Coefficients are generated only as they are requested.  Computed
// coefficients are stored in the slice and if requested subsequently,
// are returned immediately rather than recomputed.
//
// Types can also contain any other intermediate values useful for
// computing coefficients.
 
// Constant one:  A constant is a nullary function and no coefficent
// storage is needed so an empty struct is used for the type.
type oneFps struct{}
 
// The extract method implements the fps interface.  It simply has to
// return 1 for the first term and return 0 for all other terms.
func (*oneFps) extract(n int) float64 {
    if n == 0 {
        return 1
    }
    return 0
}
 
// Addition is a binary function so the sum type stores its two fps operands
// and its computed terms.
type sum struct {
    s      []float64
    s1, s2 fps
}
 
func (s *sum) extract(n int) float64 {
    for i := len(s.s); i <= n; i++ {
        s.s = append(s.s, s.s1.extract(i)+s.s2.extract(i))
    }
    return s.s[n]
}
 
// Subtraction and other binary operations are similar.
// (The common field definitions could be factored out with an embedded
// struct, but the clutter of the extra syntax required doesn't seem
// to be worthwhile.)
type diff struct {
    s      []float64
    s1, s2 fps
}
 
func (s *diff) extract(n int) float64 {
    for i := len(s.s); i <= n; i++ {
        s.s = append(s.s, s.s1.extract(i)-s.s2.extract(i))
    }
    return s.s[n]
}
 
type prod struct {
    s      []float64
    s1, s2 fps
}
 
func (s *prod) extract(n int) float64 {
    for i := len(s.s); i <= n; i++ {
        c := 0.
        for k := 0; k <= i; k++ {
            c += s.s1.extract(k) * s.s1.extract(n-k)
        }
        s.s = append(s.s, c)
    }
    return s.s[n]
}
 
// Note a couple of fields in addition to those of other binary operators.
// They simply optimize computations a bit.
type quo struct {
    s1, s2 fps
    inv    float64   // optimizes a divide
    c      []float64 // saves multiplications
    s      []float64
}
 
// WP formula.  Note the limitation s2[0] cannot be 0.  In this case
// the function returns NaN for all terms.  The switch statement catches
// this case and avoids storing a slice of all NaNs.
func (s *quo) extract(n int) float64 {
    switch {
    case len(s.s) > 0:
    case !math.IsInf(s.inv, 1):
        a0 := s.s2.extract(0)
        s.inv = 1 / a0
        if a0 != 0 {
            break
        }
        fallthrough
    default:
        return math.NaN()
    }
    for i := len(s.s); i <= n; i++ {
        c := 0.
        for k := 1; k <= i; k++ {
            c += s.s2.extract(k) * s.c[n-k]
        }
        c = s.s1.extract(i) - c*s.inv
        s.c = append(s.c, c)
        s.s = append(s.s, c*s.inv)
    }
    return s.s[n]
}
 
// Note differentiation and integration are unary so their types contain
// only a single fps operand.
 
type deriv struct {
    s   []float64
    s1  fps
}
 
func (s *deriv) extract(n int) float64 {
    for i := len(s.s); i <= n; {
        i++
        s.s = append(s.s, float64(i)*s.s1.extract(i))
    }
    return s.s[n]
}
 
type integ struct {
    s   []float64
    s1  fps
}
 
func (s *integ) extract(n int) float64 {
    if n == 0 {
        return 0 // constant term C=0
    }
    // with constant term handled, s starts at 1
    for i := len(s.s) + 1; i <= n; i++ {
        s.s = append(s.s, s.s1.extract(i-1)/float64(i))
    }
    return s.s[n-1]
}
 
// Demonstrate working sin, cos.
func main() {
    // Format several terms in a way that is easy to compare visually.
    partialSeries := func(f fps) (s string) {
        for i := 0; i < 6; i++ {
            s = fmt.Sprintf(""%s %8.5f "", s, f.extract(i))
        }
        return
    }
    sin, cos := sinCos()
    fmt.Println(""sin:"", partialSeries(sin))
    fmt.Println(""cos:"", partialSeries(cos))
}",6387,232
53067,http://rosettacode.org/wiki/Formatted_numeric_output,Formatted numeric output,"Task

Express a number in decimal as a fixed-length string with leading zeros.



For example, the number   7.125   could be expressed as   00007.125.



",#Go,Go,"fmt.Printf(""%09.3f"", 7.125)",27,1
53098,http://rosettacode.org/wiki/Four_is_magic,Four is magic,"Task

Write a subroutine, function, whatever it may be called in your language, that takes an integer number and returns an English text sequence starting with the English cardinal representation of that integer, the word 'is' and then the English cardinal representation of the count of characters that made up the first word, followed by a comma.

Continue the sequence by using the previous count word as the first word of the next phrase, append 'is' and the cardinal count of the letters in that word.

Continue until you reach four. Since four has four characters, finish by adding the words 'four is magic' and a period. All integers will eventually wind up at four.

For instance, suppose your are given the integer 3. Convert 3 to Three, add  is , then the cardinal character count of three, or five, with a comma to separate if from the next phrase. Continue the sequence five is four, (five has four letters), and finally, four is magic.

     Three is five, five is four, four is magic.

For reference, here are outputs for 0 through 9.

     Zero is four, four is magic.
     One is three, three is five, five is four, four is magic.
     Two is three, three is five, five is four, four is magic.
     Three is five, five is four, four is magic.
     Four is magic.
     Five is four, four is magic.
     Six is three, three is five, five is four, four is magic.
     Seven is five, five is four, four is magic.
     Eight is five, five is four, four is magic.
     Nine is four, four is magic.



Some task guidelines

 You may assume the input will only contain integer numbers.
 Cardinal numbers between 20 and 100 may use either hyphens or spaces as word separators but they must use a word separator. (23 is twenty three or twenty-three not twentythree.)
 Cardinal number conversions should follow the  English short scale. (billion is 1e9, trillion is 1e12, etc.)
 Cardinal numbers should not include commas. (20140 is twenty thousand one hundred forty not twenty thousand, one hundred forty.)
 When converted to a string, 100 should be one hundred, not a hundred or hundred, 1000 should be one thousand, not a thousand or thousand.
 When converted to a string, there should be no and in the cardinal string. 130 should be one hundred thirty not one hundred and thirty.
 When counting characters, count all of the characters in the cardinal number including spaces and hyphens. One hundred fifty-one should be 21 not 18.
 The output should follow the format ""N is K, K is M, M is ... four is magic."" (unless the input is 4, in which case the output should simply be ""four is magic."")
 The output can either be the return value from the function, or be displayed from within the function.
 You are encouraged, though not mandated to use proper sentence capitalization.
 You may optionally support negative numbers. -7 is negative seven.
 Show the output here for a small representative sample of values, at least 5 but no more than 25. You are free to choose which which numbers to use for output demonstration.


You can choose to use a library, (module, external routine, whatever) to do the cardinal conversions as long as the code is easily and freely available to the public.

If you roll your own, make the routine accept at minimum any integer from 0 up to 999999. If you use a pre-made library, support at least up to unsigned 64 bit integers. (or the largest integer supported in your language if it is less.)

Four is magic is a popular code-golf task. This is not code golf. Write legible, idiomatic and well formatted code.




Related tasks

   Four is the number of_letters in the ...
   Look-and-say sequence
   Number names
   Self-describing numbers
   Summarize and say sequence
   Spelling of ordinal numbers
   De Bruijn sequences

",#Go,Go,"package main
 
import (
	""fmt""
	""math""
	""strings""
)
 
func main() {
	for _, n := range [...]int64{
		0, 4, 6, 11, 13, 75, 100, 337, -164,
		math.MaxInt64,
	} {
		fmt.Println(fourIsMagic(n))
	}
}
 
func fourIsMagic(n int64) string {
	s := say(n)
	s = strings.ToUpper(s[:1]) + s[1:]
	t := s
	for n != 4 {
		n = int64(len(s))
		s = say(n)
		t += "" is "" + s + "", "" + s
	}
	t += "" is magic.""
	return t
}
 
// Following is from https://rosettacode.org/wiki/Number_names#Go
 
var small = [...]string{""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"",
	""seven"", ""eight"", ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"",
	""fourteen"", ""fifteen"", ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen""}
var tens = [...]string{"""", """", ""twenty"", ""thirty"", ""forty"",
	""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""}
var illions = [...]string{"""", "" thousand"", "" million"", "" billion"",
	"" trillion"", "" quadrillion"", "" quintillion""}
 
func say(n int64) string {
	var t string
	if n < 0 {
		t = ""negative ""
		// Note, for math.MinInt64 this leaves n negative.
		n = -n
	}
	switch {
	case n < 20:
		t += small[n]
	case n < 100:
		t += tens[n/10]
		s := n % 10
		if s > 0 {
			t += ""-"" + small[s]
		}
	case n < 1000:
		t += small[n/100] + "" hundred""
		s := n % 100
		if s > 0 {
			t += "" "" + say(s)
		}
	default:
		// work right-to-left
		sx := """"
		for i := 0; n > 0; i++ {
			p := n % 1000
			n /= 1000
			if p > 0 {
				ix := say(p) + illions[i]
				if sx != """" {
					ix += "" "" + sx
				}
				sx = ix
			}
		}
		t += sx
	}
	return t
}",1510,80
53119,http://rosettacode.org/wiki/Four_bit_adder,Four bit adder,"Task

""Simulate"" a four-bit adder.

This design can be realized using four 1-bit full adders.
Each of these 1-bit full adders can be built with two half adders and an   or   gate. ;

Finally a half adder can be made using an   xor   gate and an   and   gate.

The   xor   gate can be made using two   nots,   two   ands   and one   or.

Not,   or   and   and,   the only allowed ""gates"" for the task, can be ""imitated"" by using the bitwise operators of your language.

If there is not a bit type in your language, to be sure that the   not   does not ""invert"" all the other bits of the basic type   (e.g. a byte)   we are not interested in,   you can use an extra   nand   (and   then   not)   with the constant   1   on one input.

Instead of optimizing and reducing the number of gates used for the final 4-bit adder,   build it in the most straightforward way,   connecting the other ""constructive blocks"",   in turn made of ""simpler"" and ""smaller"" ones.


Schematics of the ""constructive blocks""


(Xor gate with ANDs, ORs and NOTs)        

   (A half adder)        

          (A full adder)            

                (A 4-bit adder)        












Solutions should try to be as descriptive as possible, making it as easy as possible to identify ""connections"" between higher-order ""blocks"".

It is not mandatory to replicate the syntax of higher-order blocks in the atomic ""gate"" blocks, i.e. basic ""gate"" operations can be performed as usual bitwise operations, or they can be ""wrapped"" in a block in order to expose the same syntax of higher-order blocks, at implementers' choice.

To test the implementation, show the sum of two four-bit numbers (in binary).



",#Go,Go,"package main
 
import ""fmt""
 
func xor(a, b byte) byte {
    return a&(^b) | b&(^a)
}
 
func ha(a, b byte) (s, c byte) {
    return xor(a, b), a & b
}
 
func fa(a, b, c0 byte) (s, c1 byte) {
    sa, ca := ha(a, c0)
    s, cb := ha(sa, b)
    c1 = ca | cb
    return
}
 
func add4(a3, a2, a1, a0, b3, b2, b1, b0 byte) (v, s3, s2, s1, s0 byte) {
    s0, c0 := fa(a0, b0, 0)
    s1, c1 := fa(a1, b1, c0)
    s2, c2 := fa(a2, b2, c1)
    s3, v = fa(a3, b3, c2)
    return
}
 
func main() {
    // add 10+9  result should be 1 0 0 1 1
    fmt.Println(add4(1, 0, 1, 0, 1, 0, 0, 1))
}",577,31
53187,http://rosettacode.org/wiki/Fixed_length_records,Fixed length records,"Fixed length read/write

Before terminals, computers commonly used punch card readers or paper tape input.

A common format before these devices were superseded by terminal technology was based on the Hollerith code, Hollerith code.

These input devices handled 80 columns per card and had a limited character set, encoded by punching holes in one or more rows of the card for each column.

These devices assumed/demanded a fixed line width of 80 characters, newlines were not required (and could not even be encoded in some systems).

Task

Write a program to read 80 column fixed length records (no newline terminators (but newline characters allowed in the data)) and then write out the reverse of each line as fixed length 80 column records.

Samples here use printable characters, but that is not a given with fixed length data. Filenames used are sample.txt, infile.dat, outfile.dat.

Note: There are no newlines, inputs and outputs are fixed at 80 columns, no more, no less, space padded. Fixed length data is 8 bit complete. NUL bytes of zero are allowed.

These fixed length formats are still in wide use on mainframes, with JCL and with COBOL (which commonly use EBCDIC encoding and not ASCII). Most of the large players in day to day financial transactions know all about fixed length records and the expression logical record length.

Sample data

To create the sample input file, use an editor that supports fixed length records or use a conversion utility. For instance, most GNU/Linux versions of dd support blocking and unblocking records with a conversion byte size.

Line 1...1.........2.........3.........4.........5.........6.........7.........8
Line 2
Line 3
Line 4

Line 6
Line 7
     Indented line 8............................................................
Line 9                                                                 RT MARGIN


prompt$ dd if=sample.txt of=infile.dat cbs=80 conv=block
prompt$ dd if=infile.dat cbs=80 conv=unblock


Bonus round

Forth systems often include BLOCK words. A block is 1024 bytes. Source code is stored as 16 lines of 64 characters each (again, no newline character or sequence to mark the end of a line).

Write a program to convert a block file to text (using newlines). Trailing spaces should be excluded from the output.

Also demonstrate how to convert from a normal text file to block form. All lines either truncated or padded to 64 characters with no newline terminators. The last block filled to be exactly 1024 characters by adding blanks if needed. Assume a full range of 8 bit byte values for each character.

The COBOL example uses forth.txt and forth.blk filenames.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""os""
    ""os/exec""
)
 
func reverseBytes(bytes []byte) {
    for i, j := 0, len(bytes)-1; i < j; i, j = i+1, j-1 {
        bytes[i], bytes[j] = bytes[j], bytes[i]
    }
}
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func main() {
    in, err := os.Open(""infile.dat"")
    check(err)
    defer in.Close()
 
    out, err := os.Create(""outfile.dat"")
    check(err)
 
    record := make([]byte, 80)
    empty := make([]byte, 80)
    for {
        n, err := in.Read(record)
        if err != nil {
            if n == 0 {
                break // EOF reached
            } else {
                out.Close()
                log.Fatal(err)
            }
        }
        reverseBytes(record)
        out.Write(record)
        copy(record, empty)
    }
    out.Close()
 
    // Run dd from within program to write output.dat
    // to standard output as normal text with newlines.
    cmd := exec.Command(""dd"", ""if=outfile.dat"", ""cbs=80"", ""conv=unblock"")
    bytes, err := cmd.Output()
    check(err)
    fmt.Println(string(bytes))
}",1108,54
53191,http://rosettacode.org/wiki/Forward_difference,Forward difference,"Task

Provide code that produces a list of numbers which is the   nth  order forward difference, given a non-negative integer (specifying the order) and a list of numbers.



The first-order forward difference of a list of numbers   A   is a new list   B,   where   Bn = An+1 - An.

List   B   should have one fewer element as a result.

The second-order forward difference of   A   will be:

tdefmodule Diff do
	def forward(arr,i\\1) do
		forward(arr,[],i)
	end

	def forward([_|[]],diffs,i) do
		if i == 1 do
			IO.inspect diffs
		else 
			forward(diffs,[],i-1)
		end
	end

	def forward([val1|[val2|vals]],diffs,i) do
		forward([val2|vals],diffs++[val2-val1],i) 
	end
end 

The same as the first-order forward difference of   B.

That new list will have two fewer elements than   A   and one less than   B.

The goal of this task is to repeat this process up to the desired order.

For a more formal description, see the related   Mathworld article.



Algorithmic options

 Iterate through all previous forward differences and re-calculate a new array each time.
 Use this formula (from Wikipedia):


 




Δ

n


[
f
]
(
x
)
=

∑

k
=
0


n





(


n
k


)



(
−
1

)

n
−
k


f
(
x
+
k
)


{\displaystyle \Delta ^{n}[f](x)=\sum _{k=0}^{n}{n \choose k}(-1)^{n-k}f(x+k)}




 (Pascal's Triangle   may be useful for this option.)

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    a := []int{90, 47, 58, 29, 22, 32, 55, 5, 55, 73}
    fmt.Println(a)
    fmt.Println(fd(a, 9))
}
 
func fd(a []int, ord int) []int {
    for i := 0; i < ord; i++ {
        for j := 0; j < len(a)-i-1; j++ {
            a[j] = a[j+1] - a[j]
        }
    }
    return a[:len(a)-ord]
}",330,18
53339,http://rosettacode.org/wiki/Flow-control_structures,Flow-control structures,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops



Task

Document common flow-control structures.



One common example of a flow-control structure is the    goto    construct.

Note that   Conditional Structures   and   Loop Structures   have their own articles/categories.



Related tasks

   Conditional Structures
   Loop Structures 

",#Go,Go,"func main() {
inf:
    goto inf
}",33,4
53343,http://rosettacode.org/wiki/Floyd-Warshall_algorithm,Floyd-Warshall algorithm,"The Floyd–Warshall algorithm is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights.




Task
Find the lengths of the shortest paths between all pairs of vertices of the given directed graph. Your code may assume that the input has already been checked for loops, parallel edges and negative cycles.


Print the pair, the distance and (optionally) the path.




Example
pair     dist    path
1 -> 2    -1     1 -> 3 -> 4 -> 2
1 -> 3    -2     1 -> 3
1 -> 4     0     1 -> 3 -> 4
2 -> 1     4     2 -> 1
2 -> 3     2     2 -> 1 -> 3
2 -> 4     4     2 -> 1 -> 3 -> 4
3 -> 1     5     3 -> 4 -> 2 -> 1
3 -> 2     1     3 -> 4 -> 2
3 -> 4     2     3 -> 4
4 -> 1     3     4 -> 2 -> 1
4 -> 2    -1     4 -> 2
4 -> 3     1     4 -> 2 -> 1 -> 3


See also
 Floyd-Warshall Algorithm - step by step guide (youtube)

",#Go,Go,"package main
 
import (
  ""fmt""
  ""strconv""
)
 
// A Graph is the interface implemented by graphs that
// this algorithm can run on.
type Graph interface {
  Vertices() []Vertex
  Neighbors(v Vertex) []Vertex
  Weight(u, v Vertex) int
}
 
// Nonnegative integer ID of vertex
type Vertex int
 
// ig is a graph of integers that satisfies the Graph interface.
type ig struct {
  vert  []Vertex
  edges map[Vertex]map[Vertex]int
}
 
func (g ig) edge(u, v Vertex, w int) {
  if _, ok := g.edges[u]; !ok {
    g.edges[u] = make(map[Vertex]int)
  }
  g.edges[u][v] = w
}
func (g ig) Vertices() []Vertex { return g.vert }
func (g ig) Neighbors(v Vertex) (vs []Vertex) {
  for k := range g.edges[v] {
    vs = append(vs, k)
  }
  return vs
}
func (g ig) Weight(u, v Vertex) int { return g.edges[u][v] }
func (g ig) path(vv []Vertex) (s string) {
  if len(vv) == 0 {
    return """"
  }
  s = strconv.Itoa(int(vv[0]))
  for _, v := range vv[1:] {
    s += "" -> "" + strconv.Itoa(int(v))
  }
  return s
}
 
const Infinity = int(^uint(0) >> 1)
 
func FloydWarshall(g Graph) (dist map[Vertex]map[Vertex]int, next map[Vertex]map[Vertex]*Vertex) {
  vert := g.Vertices()
  dist = make(map[Vertex]map[Vertex]int)
  next = make(map[Vertex]map[Vertex]*Vertex)
  for _, u := range vert {
    dist[u] = make(map[Vertex]int)
    next[u] = make(map[Vertex]*Vertex)
    for _, v := range vert {
      dist[u][v] = Infinity
    }
    dist[u][u] = 0
    for _, v := range g.Neighbors(u) {
      v := v
      dist[u][v] = g.Weight(u, v)
      next[u][v] = &v
    }
  }
  for _, k := range vert {
    for _, i := range vert {
      for _, j := range vert {
        if dist[i][k] < Infinity && dist[k][j] < Infinity {
          if dist[i][j] > dist[i][k]+dist[k][j] {
            dist[i][j] = dist[i][k] + dist[k][j]
            next[i][j] = next[i][k]
          }
        }
      }
    }
  }
  return dist, next
}
 
func Path(u, v Vertex, next map[Vertex]map[Vertex]*Vertex) (path []Vertex) {
  if next[u][v] == nil {
    return
  }
  path = []Vertex{u}
  for u != v {
    u = *next[u][v]
    path = append(path, u)
  }
  return path
}
 
func main() {
  g := ig{[]Vertex{1, 2, 3, 4}, make(map[Vertex]map[Vertex]int)}
  g.edge(1, 3, -2)
  g.edge(3, 4, 2)
  g.edge(4, 2, -1)
  g.edge(2, 1, 4)
  g.edge(2, 3, 3)
 
  dist, next := FloydWarshall(g)
  fmt.Println(""pair\tdist\tpath"")
  for u, m := range dist {
    for v, d := range m {
      if u != v {
        fmt.Printf(""%d -> %d\t%3d\t%s\n"", u, v, d, g.path(Path(u, v, next)))
      }
    }
  }
}",2516,113
53373,http://rosettacode.org/wiki/Flipping_bits_game,Flipping bits game,"The game

Given an   N×N   square array of zeroes or ones in an initial configuration,   and a target configuration of zeroes and ones.



The game is to transform one to the other in as few moves as possible by inverting whole numbered rows or whole lettered
columns at once   (as one move).

In an inversion.   any  1  becomes  0,   and any  0  becomes  1  for that whole row or column.



Task

Create a program to score for the Flipping bits game.

 The game should create an original random target configuration and a starting configuration.
 Ensure that the starting position is never the target position.
 The target position must be guaranteed as reachable from the starting position.   (One possible way to do this is to generate the start position by legal flips from a random target position.   The flips will always be reversible back to the target from the given start position).
 The number of moves taken so far should be shown.


Show an example of a short game here, on this page, for a   3×3   array of bits.



",#Go,Go,"package main
 
import (
	""fmt""
	""math/rand""
	""time""
)
 
func main() {
 
	rand.Seed(time.Now().UnixNano())
 
	var n int = 3 // Change to define board size
	var moves int = 0
 
	a := make([][]int, n)
	for i := range a {
		a[i] = make([]int, n)
		for j := range a {
			a[i][j] = rand.Intn(2)
		}
	}
 
    b := make([][]int, len(a))
	for i := range a {
		b[i] = make([]int, len(a[i]))
		copy(b[i], a[i])
	}
 
	for i := rand.Intn(100); i > 0 || compareSlices(a, b) == true; i-- {
		b = flipCol(b, rand.Intn(n) + 1)
		b = flipRow(b, rand.Intn(n) + 1)
	}
 
	fmt.Println(""Target:"")
	drawBoard(a)
	fmt.Println(""\nBoard:"")
	drawBoard(b)
 
	var rc rune
	var num int
 
	for {
		for{
			fmt.Printf(""\nFlip row (r) or column (c)  1 .. %d (c1, ...): "", n)
			_, err := fmt.Scanf(""%c%d"", &rc, &num)
			if err != nil {
				fmt.Println(err)
				continue
			}
			if num < 1 || num > n {
				fmt.Println(""Wrong command!"")
				continue
			}
			break
		}
 
		switch rc {
			case 'c':
				fmt.Printf(""Column %v will be flipped\n"", num)
				flipCol(b, num)
			case 'r':
				fmt.Printf(""Row %v will be flipped\n"", num)
				flipRow(b, num)
			default:
				fmt.Println(""Wrong command!"")
				continue
		}
 
		moves++
		fmt.Println(""\nMoves taken: "", moves)
 
		fmt.Println(""Target:"")
		drawBoard(a)
		fmt.Println(""\nBoard:"")
		drawBoard(b)
 
		if compareSlices(a, b) {
			fmt.Printf(""Finished. You win with %d moves!\n"", moves)
			break
		}
	}
}
 
func drawBoard (m [][]int) {
	fmt.Print(""   "")
	for i := range m {
		fmt.Printf(""%d "", i+1)	
	}
	for i := range m {
		fmt.Println()
		fmt.Printf(""%d "", i+1)
		for _, val := range m[i] {
			fmt.Printf("" %d"", val)
		}
	}
	fmt.Print(""\n"")
}
 
func flipRow(m [][]int, row int) ([][]int) {
	for j := range m {
		m[row-1][j] ^= 1
	}
	return m
}
 
func flipCol(m [][]int, col int) ([][]int) {
	for j := range m {
		m[j][col-1] ^= 1
	}
	return m
}
 
func compareSlices(m [][]int, n[][]int) bool {
	o := true
	for i := range m {
		for j := range m {
			if m[i][j] != n[i][j] { o = false }
		}
	}
	return o 
}",2019,122
53469,http://rosettacode.org/wiki/First-class_functions/Use_numbers_analogously,First-class functions/Use numbers analogously,"In First-class functions, a language is showing how its manipulation of functions is similar to its manipulation of other types.

This tasks aim is to compare and contrast a language's implementation of first class functions, with its normal handling of numbers.



Write a program to create an ordered collection of a mixture of literally typed and expressions producing a real number, together with another ordered collection of their multiplicative inverses. Try and use the following pseudo-code to generate the numbers for the ordered collections:

  x  = 2.0
  xi = 0.5
  y  = 4.0
  yi = 0.25
  z  = x + y
  zi = 1.0 / ( x + y )

Create a function multiplier, that given two numbers as arguments returns a function that when called with one argument, returns the result of multiplying the two arguments to the call to multiplier that created it and the argument in the call:

 new_function = multiplier(n1,n2)
 # where new_function(m) returns the result of n1 * n2 * m

Applying the multiplier of a number and its inverse from the two ordered collections of numbers in pairs, show that the result in each case is one.

Compare and contrast the resultant program with the corresponding entry in First-class functions. They should be close.

To paraphrase the task description: Do what was done before, but with numbers rather than functions
",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    x := 2.
    xi := .5
    y := 4.
    yi := .25
    z := x + y
    zi := 1 / (x + y)
    // point A
 
    numbers := []float64{x, y, z}
    inverses := []float64{xi, yi, zi}
    // point B
 
    mfs := make([]func(float64) float64, len(numbers))
    for i := range mfs {
        mfs[i] = multiplier(numbers[i], inverses[i])
    }
    // point C
 
    for _, mf := range mfs {
        fmt.Println(mf(1))
    }
}
 
func multiplier(n1, n2 float64) func(float64) float64 {
    // compute product of n's, store in a new variable
    n1n2 := n1 * n2
    // close on variable containing product
    return func(m float64) float64 {
        return n1n2 * m
    }
}",703,36
53493,http://rosettacode.org/wiki/First_power_of_2_that_has_leading_decimal_digits_of_12,First power of 2 that has leading decimal digits of 12,"(This task is taken from a   Project Euler   problem.)

(All numbers herein are expressed in base ten.)


27   =   128   and   7   is
the first power of   2   whose leading decimal digits are   12.

The next power of   2   whose leading decimal digits
are   12   is   80,

280   =   1208925819614629174706176.



Define        p(L,n)      to be the  nth-smallest
value of    j    such that the base ten representation
of    2j    begins with the digits of    L .

    So   p(12, 1) =  7    and
         p(12, 2) = 80



You are also given that:

         p(123, 45)   =   12710



Task

   find: 
     p(12, 1)  
     p(12, 2)  
     p(123, 45)  
     p(123, 12345)  
     p(123, 678910)  
   display the results here, on this page.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""time""
)
 
const ld10 = math.Ln2 / math.Ln10
 
func commatize(n uint64) string {
    s := fmt.Sprintf(""%d"", n)
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    return s
}
 
func p(L, n uint64) uint64 {
    i := L
    digits := uint64(1)
    for i >= 10 {
        digits *= 10
        i /= 10
    }
    count := uint64(0)
    for i = 0; count < n; i++ {
        e := math.Exp(math.Ln10 * math.Mod(float64(i)*ld10, 1))
        if uint64(math.Trunc(e*float64(digits))) == L {
            count++            
        }
    }
    return i - 1
}
 
func main() {
    start := time.Now()
    params := [][2]uint64{{12, 1}, {12, 2}, {123, 45}, {123, 12345}, {123, 678910}}
    for _, param := range params {
        fmt.Printf(""p(%d, %d) = %s\n"", param[0], param[1], commatize(p(param[0], param[1])))
    }
    fmt.Printf(""\nTook %s\n"", time.Since(start))
}",946,44
53517,http://rosettacode.org/wiki/First_class_environments,First class environments,"According to Wikipedia, ""In computing, a first-class object ... is an entity that can be constructed at run-time, passed as a parameter, returned from a subroutine, or assigned into a variable"".

Often this term is used in the context of ""first class functions"". In an analogous way, a programming language may support ""first class environments"".

The environment is minimally, the set of variables accessible to a statement being executed. Change the environments and the same statement could produce different results when executed.

Often an environment is captured in a closure, which encapsulates a function together with an environment. That environment, however, is not first-class, as it cannot be created, passed etc. independently from the function's code.

Therefore, a first class environment is a set of variable bindings which can be constructed at run-time, passed as a parameter, returned from a subroutine, or assigned into a variable. It is like a closure without code. A statement must be able to be executed within a stored first class environment and act according to the environment variable values stored within.



Task

Build a dozen environments, and a single piece of code to be run repeatedly in each of these environments.

Each environment contains the bindings for two variables:

   a value in the Hailstone sequence, and 
   a count which is incremented until the value drops to 1. 


The initial hailstone values are 1 through 12, and the count in each environment is zero.

When the code runs, it calculates the next hailstone step in the current environment (unless the value is already 1) and counts the steps. Then it prints the current value in a tabular form.

When all hailstone values dropped to 1, processing stops, and the total number of hailstone steps for each environment is printed.



",#Go,Go,"package main
 
import ""fmt""
 
const jobs = 12
 
type environment struct{ seq, cnt int }
 
var (
    env      [jobs]environment
    seq, cnt *int
)
 
func hail() {
    fmt.Printf(""% 4d"", *seq)
    if *seq == 1 {
        return
    }
    (*cnt)++
    if *seq&1 != 0 {
        *seq = 3*(*seq) + 1
    } else {
        *seq /= 2
    }
}
 
func switchTo(id int) {
    seq = &env[id].seq
    cnt = &env[id].cnt
}
 
func main() {
    for i := 0; i < jobs; i++ {
        switchTo(i)
        env[i].seq = i + 1
    }
 
again:
    for i := 0; i < jobs; i++ {
        switchTo(i)
        hail()
    }
    fmt.Println()
 
    for j := 0; j < jobs; j++ {
        switchTo(j)
        if *seq != 1 {
            goto again
        }
    }
    fmt.Println()
 
    fmt.Println(""COUNTS:"")
    for i := 0; i < jobs; i++ {
        switchTo(i)
        fmt.Printf(""% 4d"", *cnt)
    }
    fmt.Println()
}",881,59
53598,http://rosettacode.org/wiki/Fivenum,Fivenum,"Many big data or scientific programs use boxplots to show distributions of data.   In addition, sometimes saving large arrays for boxplots can be impractical and use extreme amounts of RAM.   It can be useful to save large arrays as arrays with five numbers to save memory.

For example, the   R   programming language implements Tukey's five-number summary as the fivenum function.



Task

Given an array of numbers, compute the five-number summary.



Note
 
While these five numbers can be used to draw a boxplot,   statistical packages will typically need extra data.

Moreover, while there is a consensus about the ""box"" of the boxplot,   there are variations among statistical packages for the whiskers.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""sort""
)
 
func fivenum(a []float64) (n5 [5]float64) {
    sort.Float64s(a)
    n := float64(len(a))
    n4 := float64((len(a)+3)/2) / 2
    d := []float64{1, n4, (n + 1) / 2, n + 1 - n4, n}
    for e, de := range d {
        floor := int(de - 1)
        ceil := int(math.Ceil(de - 1))
        n5[e] = .5 * (a[floor] + a[ceil])
    }
    return
}
 
var (
    x1 = []float64{36, 40, 7, 39, 41, 15}
    x2 = []float64{15, 6, 42, 41, 7, 36, 49, 40, 39, 47, 43}
    x3 = []float64{
        0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594,
        0.73438555, -0.03035726, 1.46675970, -0.74621349, -0.72588772,
        0.63905160, 0.61501527, -0.98983780, -1.00447874, -0.62759469,
        0.66206163, 1.04312009, -0.10305385, 0.75775634, 0.32566578,
    }
)
 
func main() {
    fmt.Println(fivenum(x1))
    fmt.Println(fivenum(x2))
    fmt.Println(fivenum(x3))
}",919,37
53695,http://rosettacode.org/wiki/First_perfect_square_in_base_n_with_n_unique_digits,First perfect square in base n with n unique digits,"Find the first perfect square in a given base N that has at least N digits and
exactly N significant unique digits when expressed in base N.

E.G. In base 10, the first perfect square with at least 10 unique digits is 1026753849 (32043²).

You may use analytical methods to reduce the search space, but the code must do a search. Do not use magic numbers or just feed the code the answer to verify it is correct.

Task
 Find and display here, on this page, the first perfect square in base N, with N significant unique digits when expressed in base N, for each of base 2 through 12. Display each number in the base N for which it was calculated.
 (optional) Do the same for bases 13 through 16.
 (stretch goal) Continue on for bases 17 - ?? (Big Integer math)


See also

 OEIS A260182: smallest square that is pandigital in base n.
Related task
 Casting out nines

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""strconv""
    ""time""
)
 
const maxBase = 27
const minSq36 = ""1023456789abcdefghijklmnopqrstuvwxyz""
const minSq36x = ""10123456789abcdefghijklmnopqrstuvwxyz""
 
var bigZero = new(big.Int)
var bigOne = new(big.Int).SetUint64(1)
 
func containsAll(sq string, base int) bool {
    var found [maxBase]byte
    le := len(sq)
    reps := 0
    for _, r := range sq {
        d := r - 48
        if d > 38 {
            d -= 39
        }
        found[d]++
        if found[d] > 1 {
            reps++
            if le-reps < base {
                return false
            }
        }
    }
    return true
}
 
func sumDigits(n, base *big.Int) *big.Int {
    q := new(big.Int).Set(n)
    r := new(big.Int)
    sum := new(big.Int).Set(bigZero)
    for q.Cmp(bigZero) == 1 {
        q.QuoRem(q, base, r)
        sum.Add(sum, r)
    }
    return sum
}
 
func digitalRoot(n *big.Int, base int) int {
    root := new(big.Int)
    b := big.NewInt(int64(base))
    for i := new(big.Int).Set(n); i.Cmp(b) >= 0; i.Set(root) {
        root.Set(sumDigits(i, b))
    }
    return int(root.Int64())
}
 
func minStart(base int) (string, uint64, int) {
    nn := new(big.Int)
    ms := minSq36[:base]
    nn.SetString(ms, base)
    bdr := digitalRoot(nn, base)
    var drs []int
    var ixs []uint64
    for n := uint64(1); n < uint64(2*base); n++ {
        nn.SetUint64(n * n)
        dr := digitalRoot(nn, base)
        if dr == 0 {
            dr = int(n * n)
        }
        if dr == bdr {
            ixs = append(ixs, n)
        }
        if n < uint64(base) && dr >= bdr {
            drs = append(drs, dr)
        }
    }
    inc := uint64(1)
    if len(ixs) >= 2 && base != 3 {
        inc = ixs[1] - ixs[0]
    }
    if len(drs) == 0 {
        return ms, inc, bdr
    }
    min := drs[0]
    for _, dr := range drs[1:] {
        if dr < min {
            min = dr
        }
    }
    rd := min - bdr
    if rd == 0 {
        return ms, inc, bdr
    }
    if rd == 1 {
        return minSq36x[:base+1], 1, bdr
    }
    ins := string(minSq36[rd])
    return (minSq36[:rd] + ins + minSq36[rd:])[:base+1], inc, bdr
}
 
func main() {
    start := time.Now()
    var nb, nn big.Int
    for n, k, base := uint64(2), uint64(1), 2; ; n += k {
        if base > 2 && n%uint64(base) == 0 {
            continue
        } 
        nb.SetUint64(n)
        sq := nb.Mul(&nb, &nb).Text(base)
        if !containsAll(sq, base) {
            continue
        }
        ns := strconv.FormatUint(n, base)
        tt := time.Since(start).Seconds()
        fmt.Printf(""Base %2d:%15s² = %-27s in %8.3fs\n"", base, ns, sq, tt)
        if base == maxBase {
            break
        }
        base++
        ms, inc, bdr := minStart(base)
        k = inc
        nn.SetString(ms, base)
        nb.Sqrt(&nn)
        if nb.Uint64() < n+1 {
            nb.SetUint64(n + 1)
        }
        if k != 1 {
            for {
                nn.Mul(&nb, &nb)
                dr := digitalRoot(&nn, base)
                if dr == bdr {
                    n = nb.Uint64() - k
                    break
                }
                nb.Add(&nb, bigOne)
            }
        } else {
            n = nb.Uint64() - k
        }
    }
}",3245,141
53697,http://rosettacode.org/wiki/Forest_fire,Forest fire,"

 This page uses content from Wikipedia. The original article was at Forest-fire model. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Implement the Drossel and Schwabl definition of the forest-fire model.



It is basically a 2D   cellular automaton   where each cell can be in three distinct states (empty, tree and burning) and evolves according to the following rules (as given by Wikipedia)

 A burning cell turns into an empty cell
 A tree will burn if at least one neighbor is burning
 A tree ignites with probability   f    even if no neighbor is burning
 An empty space fills with a tree with probability    p 

Neighborhood is the   Moore neighborhood;   boundary conditions are so that on the boundary the cells are always empty (""fixed"" boundary condition).

At the beginning, populate the lattice with empty and tree cells according to a specific probability (e.g. a cell has the probability 0.5 to be a tree). Then, let the system evolve.

Task's requirements do not include graphical display or the ability to change parameters (probabilities    p    and    f )   through a graphical or command line interface.



Related tasks

   See   Conway's Game of Life 
   See   Wireworld.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""strings""
)
 
const (
    rows = 20
    cols = 30
    p    = .01
    f    = .001
)
 
const rx = rows + 2
const cx = cols + 2
 
func main() {
    odd := make([]byte, rx*cx)
    even := make([]byte, rx*cx)
    for r := 1; r <= rows; r++ {
        for c := 1; c <= cols; c++ {
            if rand.Intn(2) == 1 {
                odd[r*cx+c] = 'T'
            }
        }
    }
    for {
        print(odd)
        step(even, odd)
        fmt.Scanln()
 
        print(even)
        step(odd, even)
        fmt.Scanln()
    }
}
 
func print(model []byte) {
    fmt.Println(strings.Repeat(""__"", cols))
    fmt.Println()
    for r := 1; r <= rows; r++ {
        for c := 1; c <= cols; c++ {
            if model[r*cx+c] == 0 {
                fmt.Print(""  "")
            } else {
                fmt.Printf("" %c"", model[r*cx+c])
            }
        }
        fmt.Println()
    }
}
 
func step(dst, src []byte) {
    for r := 1; r <= rows; r++ {
        for c := 1; c <= cols; c++ {
            x := r*cx + c
            dst[x] = src[x]
            switch dst[x] {
            case '#':
                // rule 1. A burning cell turns into an empty cell
                dst[x] = 0
            case 'T':
                // rule 2. A tree will burn if at least one neighbor is burning
                if src[x-cx-1]=='#'  || src[x-cx]=='#' || src[x-cx+1]=='#' ||
                    src[x-1] == '#'  ||                   src[x+1] == '#'  ||
                    src[x+cx-1]=='#' || src[x+cx]=='#' || src[x+cx+1] == '#' {
                    dst[x] = '#'
 
                    // rule 3. A tree ignites with probability f
                    // even if no neighbor is burning
                } else if rand.Float64() < f {
                    dst[x] = '#'
                }
            default:
                // rule 4. An empty space fills with a tree with probability p
                if rand.Float64() < p {
                    dst[x] = 'T'
                }
            }
        }
    }
}",2039,84
53886,http://rosettacode.org/wiki/Floyd%27s_triangle,Floyd's triangle,"Floyd's triangle   lists the natural numbers in a right triangle aligned to the left where

 the first row is   1     (unity)
 successive rows start towards the left with the next number followed by successive naturals listing one more number than the line above.


The first few lines of a Floyd triangle looks like this:

 1
 2  3
 4  5  6
 7  8  9 10
11 12 13 14 15



Task

 Write a program to generate and display here the first   n   lines of a Floyd triangle. 
(Use   n=5   and   n=14   rows).
 Ensure that when displayed in a mono-space font, the numbers line up in vertical columns as shown and that only one space separates numbers of the last row.

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    floyd(5)
    floyd(14)
}
 
func floyd(n int) {
    fmt.Printf(""Floyd %d:\n"", n)
    lowerLeftCorner := n*(n-1)/2 + 1
    lastInColumn := lowerLeftCorner
    lastInRow := 1
    for i, row := 1, 1; row <= n; i++ {
        w := len(fmt.Sprint(lastInColumn))
        if i < lastInRow {
            fmt.Printf(""%*d "", w, i)
            lastInColumn++
        } else {
            fmt.Printf(""%*d\n"", w, i)
            row++
            lastInRow += row
            lastInColumn = lowerLeftCorner
        }
    }
}",556,27
53955,http://rosettacode.org/wiki/Find_the_intersection_of_a_line_with_a_plane,Find the intersection of a line with a plane,"Finding the intersection of an infinite ray with a plane in 3D is an important topic in collision detection.



Task

Find the point of intersection for the infinite ray with direction   (0, -1, -1)   passing through position   (0, 0, 10)   with the infinite plane with a normal vector of   (0, 0, 1)   and which passes through [0, 0, 5].



",#Go,Go,"package main
 
import ""fmt""
 
type Vector3D struct{ x, y, z float64 }
 
func (v *Vector3D) Add(w *Vector3D) *Vector3D {
    return &Vector3D{v.x + w.x, v.y + w.y, v.z + w.z}
}
 
func (v *Vector3D) Sub(w *Vector3D) *Vector3D {
    return &Vector3D{v.x - w.x, v.y - w.y, v.z - w.z}
}
 
func (v *Vector3D) Mul(s float64) *Vector3D {
    return &Vector3D{s * v.x, s * v.y, s * v.z}
}
 
func (v *Vector3D) Dot(w *Vector3D) float64 {
    return v.x*w.x + v.y*w.y + v.z*w.z
}
 
func (v *Vector3D) String() string {
    return fmt.Sprintf(""(%v, %v, %v)"", v.x, v.y, v.z)
}
 
func intersectPoint(rayVector, rayPoint, planeNormal, planePoint *Vector3D) *Vector3D {
    diff := rayPoint.Sub(planePoint)
    prod1 := diff.Dot(planeNormal)
    prod2 := rayVector.Dot(planeNormal)
    prod3 := prod1 / prod2
    return rayPoint.Sub(rayVector.Mul(prod3))
}
 
func main() {
    rv := &Vector3D{0.0, -1.0, -1.0}
    rp := &Vector3D{0.0, 0.0, 10.0}
    pn := &Vector3D{0.0, 0.0, 1.0}
    pp := &Vector3D{0.0, 0.0, 5.0}
    ip := intersectPoint(rv, rp, pn, pp)
    fmt.Println(""The ray intersects the plane at"", ip)
}",1097,42
54011,http://rosettacode.org/wiki/Find_the_intersection_of_two_lines,Find the intersection of two lines,"[1]


Task

Find the point of intersection of two lines in 2D.



The 1st line passes though    (4,0)    and    (6,10) .

The 2nd line passes though    (0,3)    and    (10,7) .



",#Go,Go," 
package main
 
import (
	""fmt""
	""errors""
)
 
type Point struct {
	x float64
	y float64
}
 
type Line struct {
	slope float64
	yint float64
}
 
func CreateLine (a, b Point) Line {
	slope := (b.y-a.y) / (b.x-a.x)
	yint := a.y - slope*a.x
	return Line{slope, yint}
} 
 
func EvalX (l Line, x float64) float64 {
	return l.slope*x + l.yint
}
 
func Intersection (l1, l2 Line) (Point, error) {
	if l1.slope == l2.slope {
		return Point{}, errors.New(""The lines do not intersect"")
	}
	x := (l2.yint-l1.yint) / (l1.slope-l2.slope)
	y := EvalX(l1, x)
	return Point{x, y}, nil
}
 
func main() {
	l1 := CreateLine(Point{4, 0}, Point{6, 10})
	l2 := CreateLine(Point{0, 3}, Point{10, 7})
	if result, err := Intersection(l1, l2); err == nil {
		fmt.Println(result)
	} else {
		fmt.Println(""The lines do not intersect"")
	}
}
 ",813,47
54087,http://rosettacode.org/wiki/First-class_functions,First-class functions,"A language has first-class functions if it can do each of the following without recursively invoking a compiler or interpreter or otherwise metaprogramming:

 Create new functions from preexisting functions at run-time
 Store functions in collections
 Use functions as arguments to other functions
 Use functions as return values of other functions


Task

Write a program to create an ordered collection A of functions of a real number. At least one function should be built-in and at least one should be user-defined; try using the sine, cosine, and cubing functions. Fill another collection B with the inverse of each function in A. Implement function composition as in Functional Composition. Finally, demonstrate that the result of applying the composition of each function in A and its inverse in B to a value, is the original value. (Within the limits of computational accuracy).

(A solution need not actually call the collections ""A"" and ""B"". These names are only used in the preceding paragraph for clarity.)



Related task
 
First-class Numbers
",#Go,Go,"package main
 
import ""math""
import ""fmt""
 
// user-defined function, per task.  Other math functions used are built-in.
func cube(x float64) float64 { return math.Pow(x, 3) }
 
// ffType and compose function taken from Function composition task
type ffType func(float64) float64
 
func compose(f, g ffType) ffType {
    return func(x float64) float64 {
        return f(g(x))
    }
}
 
func main() {
    // collection A
    funclist := []ffType{math.Sin, math.Cos, cube}
    // collection B
    funclisti := []ffType{math.Asin, math.Acos, math.Cbrt}
    for i := 0; i < 3; i++ {
        // apply composition and show result
        fmt.Println(compose(funclisti[i], funclist[i])(.5))
    }
}",692,27
54147,http://rosettacode.org/wiki/Five_weekends,Five weekends,"The month of October in 2010 has five Fridays, five Saturdays, and five Sundays.



Task

 Write a program to show all months that have this same characteristic of five full weekends from the year 1900 through 2100 (Gregorian calendar). 
 Show the number of months with this property (there should be 201).
 Show at least the first and last five dates, in order.

Algorithm suggestions

 Count the number of Fridays, Saturdays, and Sundays in every month.
 Find all of the 31-day months that begin on Friday.

Extra credit

Count and/or show all of the years which do not have at least one five-weekend month (there should be 29).



Related tasks
 Day of the week
 Last Friday of each month
 Find last sunday of each month

",#Go,Go,"package main
 
import (
    ""fmt""
    ""time""
)
 
func main() {
    var n int                                 // for task item 2
    var first, last time.Time                 // for task item 3
    haveNone := make([]int, 0, 29)            // for extra credit
    fmt.Println(""Months with five weekends:"") // for task item 1
    for year := 1900; year <= 2100; year++ {
        var hasOne bool // for extra credit
        for _, month := range []time.Month{1, 3, 5, 7, 8, 10, 12} {
            t := time.Date(year, month, 1, 0, 0, 0, 0, time.UTC)
            if t.Weekday() == time.Friday {
                // task item 1:  show month
                fmt.Println(""  "", t.Format(""2006 January""))
                n++
                hasOne = true
                last = t
                if first.IsZero() {
                    first = t
                }
            }
        }
        if !hasOne {
            haveNone = append(haveNone, year)
        }
    }
    fmt.Println(n, ""total\n"") // task item 2: number of months
    // task item 3
    fmt.Println(""First five dates of weekends:"")
    for i := 0; i < 5; i++ {
        fmt.Println(""  "", first.Format(""Monday, January 2, 2006""))
        first = first.Add(7 * 24 * time.Hour)
    }
    fmt.Println(""Last five dates of weekends:"")
    for i := 0; i < 5; i++ {
        fmt.Println(""  "", last.Format(""Monday, January 2, 2006""))
        last = last.Add(7 * 24 * time.Hour)
    }
    // extra credit
    fmt.Println(""\nYears with no months with five weekends:"")
    for _, y := range haveNone {
        fmt.Println(""  "", y)
    }
    fmt.Println(len(haveNone), ""total"")
}",1623,50
54203,http://rosettacode.org/wiki/Flatten_a_list,Flatten a list,"Task

Write a function to flatten the nesting in an arbitrary list of values.

Your program should work on the equivalent of this list:

  [[1], 2, [[3, 4], 5], [[[]]], [[[6]]], 7, 8, []]

Where the correct result would be the list:

   [1, 2, 3, 4, 5, 6, 7, 8]

Related task

   Tree traversal

",#Go,Go,"package main
 
import ""fmt""
 
func list(s ...interface{}) []interface{} {
    return s
}
 
func main() {
    s := list(list(1),
        2,
        list(list(3, 4), 5),
        list(list(list())),
        list(list(list(6))),
        7,
        8,
        list(),
    )
    fmt.Println(s)
    fmt.Println(flatten(s))
}
 
func flatten(s []interface{}) (r []int) {
    for _, e := range s {
        switch i := e.(type) {
        case int:
            r = append(r, i)
        case []interface{}:
            r = append(r, flatten(i)...)
        }
    }
    return
}",563,33
54211,http://rosettacode.org/wiki/Find_the_last_Sunday_of_each_month,Find the last Sunday of each month,"Write a program or a script that returns the last Sundays of each month of a given year. The year may be given through any simple input method in your language (command line, std in, etc).

Example of an expected output:

./last_sundays 2013
2013-01-27
2013-02-24
2013-03-31
2013-04-28
2013-05-26
2013-06-30
2013-07-28
2013-08-25
2013-09-29
2013-10-27
2013-11-24
2013-12-29


Related tasks
 Day of the week
 Five weekends
 Last Friday of each month

",#Go,Go,"package main
 
import (
	""fmt""
	""time""
)
 
func main() {
 
	var year int
	var t time.Time
	var lastDay = [12]int { 31,29,31,30,31,30,31,31,30,31,30,31 }
 
	for {
		fmt.Print(""Please select a year: "")
		_, err := fmt.Scanf(""%d"", &year)
		if err != nil {
			fmt.Println(err)
			continue
		} else {
			break
		}
	}
 
	fmt.Println(""Last Sundays of each month of"", year)
	fmt.Println(""=================================="")
 
	for i := 1;i < 13; i++ {
		j := lastDay[i-1]
		if i == 2 {
			if time.Date(int(year), time.Month(i), j, 0, 0, 0, 0, time.UTC).Month() == time.Date(int(year), time.Month(i), j-1, 0, 0, 0, 0, time.UTC).Month() {
				j = 29
			} else {
				j = 28
			}
		}
		for {
			t = time.Date(int(year), time.Month(i), j, 0, 0, 0, 0, time.UTC)
			if t.Weekday() == 0 {
				fmt.Printf(""%s: %d\n"", time.Month(i), j)
				break
			}
			j = j - 1
		}
	}
}
 ",857,47
54274,http://rosettacode.org/wiki/Find_the_missing_permutation,Find the missing permutation,"                    ABCD
                    CABD
                    ACDB
                    DACB
                    BCDA
                    ACBD
                    ADCB
                    CDAB
                    DABC
                    BCAD
                    CADB
                    CDBA
                    CBAD
                    ABDC
                    ADBC
                    BDCA
                    DCBA
                    BACD
                    BADC
                    BDAC
                    CBDA
                    DBCA
                    DCAB

Listed above are   all-but-one   of the permutations of the symbols   A,   B,   C,   and   D,   except   for one permutation that's   not   listed.



Task

Find that missing permutation.



Methods

 Obvious method: 
        enumerate all permutations of   A,  B,  C,  and  D,  
        and then look for the missing permutation. 

 alternate method:
        Hint:  if all permutations were shown above,  how many 
        times would  A  appear in each position?     
        What is the  parity  of this number?

 another alternate method:
        Hint:  if you add up the letter values of each column, 
        does a missing letter   A,  B,  C,  and  D   from each
        column cause the total value for each column to be unique?



Related task

   Permutations)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
var given = strings.Split(`ABCD
CABD
ACDB
DACB
BCDA
ACBD
ADCB
CDAB
DABC
BCAD
CADB
CDBA
CBAD
ABDC
ADBC
BDCA
DCBA
BACD
BADC
BDAC
CBDA
DBCA
DCAB`, ""\n"")
 
func main() {
    b := make([]byte, len(given[0]))
    for i := range b {
        m := make(map[byte]int)
        for _, p := range given {
            m[p[i]]++
        }
        for char, count := range m {
            if count&1 == 1 {
                b[i] = char
                break
            }
        }
    }
    fmt.Println(string(b))
}",551,47
54607,http://rosettacode.org/wiki/Find_duplicate_files,Find duplicate files,"In a large directory structure it is easy to inadvertently leave unnecessary copies of files around, which can use considerable disk space and create confusion.



Task

Create a program which, given a minimum size and a folder/directory, will find all files of at least size bytes with duplicate contents under the directory and output or show the sets of duplicate files in order of decreasing size.

The program may be command-line or graphical, and duplicate content may be determined by direct comparison or by calculating a hash of the data.

Specify which filesystems or operating systems your program works with if it has any filesystem- or OS-specific requirements.

Identify hard links (filenames referencing the same content) in the output if applicable for the filesystem.

For extra points, detect when whole directory sub-trees are identical, or optionally remove or link identical files.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""crypto/md5""
    ""io/ioutil""
    ""log""
    ""os""
    ""path/filepath""
    ""sort""
    ""time""
)
 
type fileData struct {
    filePath string
    info     os.FileInfo
}
 
type hash [16]byte
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func checksum(filePath string) hash {
    bytes, err := ioutil.ReadFile(filePath)
    check(err)
    return hash(md5.Sum(bytes))
}
 
func findDuplicates(dirPath string, minSize int64) [][2]fileData {
    var dups [][2]fileData
    m := make(map[hash]fileData)
    werr := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        if !info.IsDir() && info.Size() >= minSize {
            h := checksum(path)
            fd, ok := m[h]
            fd2 := fileData{path, info}
            if !ok {
                m[h] = fd2
            } else {
                dups = append(dups, [2]fileData{fd, fd2})
            }
        }
        return nil
    })
    check(werr)
    return dups
}
 
func main() {
    dups := findDuplicates(""."", 1)
    fmt.Println(""The following pairs of files have the same size and the same hash:\n"")
    fmt.Println(""File name                 Size      Date last modified"")
    fmt.Println(""=========================================================="")
    sort.Slice(dups, func(i, j int) bool {
        return dups[i][0].info.Size() > dups[j][0].info.Size() // in order of decreasing size
    })
    for _, dup := range dups {
        for i := 0; i < 2; i++ {
            d := dup[i]
            fmt.Printf(""%-20s  %8d    %v\n"", d.filePath, d.info.Size(), d.info.ModTime().Format(time.ANSIC))
        }
        fmt.Println()
    }
}",1743,71
54614,http://rosettacode.org/wiki/Find_Chess960_starting_position_identifier,Find Chess960 starting position identifier,"As described on the Chess960 page, Chess960 (a.k.a Fischer Random Chess, Chess9LX) is a variant of chess where the array of pieces behind the pawns is randomized at the start of the game to minimize the value of opening theory ""book knowledge"". That task is to generate legal starting positions, and some of the solutions accept a standard Starting Position Identifier number (""SP-ID""), and generate the corresponding position.

Task

This task is to go the other way: given a starting array of pieces (provided in any form that suits your implementation, whether string or list or array, of letters or Unicode chess symbols or enum values, etc.), derive its unique SP-ID. For example, given the starting array QNRBBNKR (or ♕♘♖♗♗♘♔♖ or ♛♞♜♝♝♞♚♜), your (sub)program should return 105; given the starting lineup of standard chess, it should return 518.

You may assume the input is a valid Chess960 position; detecting invalid input (including illegal characters or starting arrays with the bishops on the same color square or the king not between the two rooks) is optional.

Algorithm

The derivation is the inverse of the algorithm given at Wikipedia, and goes like this (we'll use the standard chess setup as an example):

1. Ignoring the Queen and Bishops, find the positions of the Knights within the remaining five spaces (in the standard array they're in the second and fourth positions), and then find the index number of that combination. There's a table at the above Wikipedia article, but it's just the possible positions sorted left to right and numbered 0 to 9: 0=NN---, 1=N-N--, 2=N--N-, 3=N---N, 4=-NN--, etc; our pair is combination number 5. Call this number N. N=5

2. Now ignoring the Knights (but including the Queen and Bishops), find the position of the Queen in the remaining 6 spaces; number them 0..5 from left to right and call the index of the Queen's position Q. In our example, Q=2.

3. Finally, find the positions of the two bishops within their respective sets of four like-colored squares. It's important to note here that the board in chess is placed such that the leftmost position on the home row is on a dark square and the rightmost a light. So if we number the squares of each color 0..3 from left to right, the dark bishop in the standard position is on square 1 (D=1), and the light bishop is on square 2 (L=2).

4. Then the position number is given by 4(4(6N + Q)+D)+L, which reduces to 96N + 16Q + 4D + L. In our example, that's 96×5 + 16×2 + 4×1 + 2 = 480 + 32 + 4 + 2 = 518.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""strings""
)
 
var glyphs = []rune(""♜♞♝♛♚♖♘♗♕♔"")
var names = map[rune]string{'R': ""rook"", 'N': ""knight"", 'B': ""bishop"", 'Q': ""queen"", 'K': ""king""}
var g2lMap = map[rune]string{
    '♜': ""R"", '♞': ""N"", '♝': ""B"", '♛': ""Q"", '♚': ""K"",
    '♖': ""R"", '♘': ""N"", '♗': ""B"", '♕': ""Q"", '♔': ""K"",
}
 
var ntable = map[string]int{""01"": 0, ""02"": 1, ""03"": 2, ""04"": 3, ""12"": 4, ""13"": 5, ""14"": 6, ""23"": 7, ""24"": 8, ""34"": 9}
 
func g2l(pieces string) string {
    lets := """"
    for _, p := range pieces {
        lets += g2lMap[p]
    }
    return lets
}
 
func spid(pieces string) int {
    pieces = g2l(pieces) // convert glyphs to letters
 
    /* check for errors */
    if len(pieces) != 8 {
        log.Fatal(""There must be exactly 8 pieces."")
    }
    for _, one := range ""KQ"" {
        count := 0
        for _, p := range pieces {
            if p == one {
                count++
            }
        }
        if count != 1 {
            log.Fatalf(""There must be one %s."", names[one])
        }
    }
    for _, two := range ""RNB"" {
        count := 0
        for _, p := range pieces {
            if p == two {
                count++
            }
        }
        if count != 2 {
            log.Fatalf(""There must be two %s."", names[two])
        }
    }
    r1 := strings.Index(pieces, ""R"")
    r2 := strings.Index(pieces[r1+1:], ""R"") + r1 + 1
    k := strings.Index(pieces, ""K"")
    if k < r1 || k > r2 {
        log.Fatal(""The king must be between the rooks."")
    }
    b1 := strings.Index(pieces, ""B"")
    b2 := strings.Index(pieces[b1+1:], ""B"") + b1 + 1
    if (b2-b1)%2 == 0 {
        log.Fatal(""The bishops must be on opposite color squares."")
    }
 
    /* compute SP_ID */
    piecesN := strings.ReplaceAll(pieces, ""Q"", """")
    piecesN = strings.ReplaceAll(piecesN, ""B"", """")
    n1 := strings.Index(piecesN, ""N"")
    n2 := strings.Index(piecesN[n1+1:], ""N"") + n1 + 1
    np := fmt.Sprintf(""%d%d"", n1, n2)
    N := ntable[np]
 
    piecesQ := strings.ReplaceAll(pieces, ""N"", """")
    Q := strings.Index(piecesQ, ""Q"")
 
    D := strings.Index(""0246"", fmt.Sprintf(""%d"", b1))
    L := strings.Index(""1357"", fmt.Sprintf(""%d"", b2))
    if D == -1 {
        D = strings.Index(""0246"", fmt.Sprintf(""%d"", b2))
        L = strings.Index(""1357"", fmt.Sprintf(""%d"", b1))
    }
 
    return 96*N + 16*Q + 4*D + L
}
 
func main() {
    for _, pieces := range []string{""♕♘♖♗♗♘♔♖"", ""♖♘♗♕♔♗♘♖""} {
        fmt.Printf(""%s or %s has SP-ID of %d\n"", pieces, g2l(pieces), spid(pieces))
    }
}",2529,92
54670,http://rosettacode.org/wiki/Find_largest_left_truncatable_prime_in_a_given_base,Find largest left truncatable prime in a given base,"A truncatable prime is one where all non-empty substrings that finish at the end of the number (right-substrings) are also primes when understood as numbers in a particular base. The largest such prime in a given (integer) base is therefore computable, provided the base is larger than 2.

Let's consider what happens in base 10. Obviously the right most digit must be prime, so in base 10 candidates are 2,3,5,7. Putting a digit in the range 1 to base-1 in front of each candidate must result in a prime. So 2 and 5, like the whale and the petunias in The Hitchhiker's Guide to the Galaxy, come into existence only to be extinguished before they have time to realize it, because 2 and 5 preceded by any digit in the range 1 to base-1 is not prime. Some numbers formed by preceding 3 or 7 by a digit in the range 1 to base-1 are prime. So 13,17,23,37,43,47,53,67,73,83,97 are candidates. Again, putting a digit in the range 1 to base-1 in front of each candidate must be a prime. Repeating until there are no larger candidates finds the largest left truncatable prime.

Let's work base 3 by hand:

0 and 1 are not prime so the last digit must be 2. 123 = 510 which is prime, 223 = 810 which is not so 123 is the only candidate. 1123 = 1410 which is not prime, 2123 = 2310 which is, so 2123 is the only candidate. 12123 = 5010 which is not prime, 22123 = 7710 which also is not prime. So there are no more candidates, therefore 23 is the largest left truncatable prime in base 3.

The task is to reconstruct as much, and possibly more, of the table in the OEIS as you are able.

Related Tasks:

 Miller-Rabin primality test

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
var smallPrimes = [...]int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}
 
const maxStack = 128
 
var (
    tens, values    [maxStack]big.Int
    bigTemp, answer = new(big.Int), new(big.Int)
    base, seenDepth int
)
 
func addDigit(i int) {
    for d := 1; d < base; d++ {
        values[i].Set(&values[i-1])
        bigTemp.SetUint64(uint64(d))
        bigTemp.Mul(bigTemp, &tens[i])
        values[i].Add(&values[i], bigTemp)
        if !values[i].ProbablyPrime(0) {
            continue
        }
        if i > seenDepth || (i == seenDepth && values[i].Cmp(answer) == 1) {
            if !values[i].ProbablyPrime(0) {
                continue
            }
            answer.Set(&values[i])
            seenDepth = i
        }
        addDigit(i + 1)
    }
}
 
func doBase() {
    answer.SetUint64(0)
    tens[0].SetUint64(1)
    bigTemp.SetUint64(uint64(base))
    seenDepth = 0
    for i := 1; i < maxStack; i++ {
        tens[i].Mul(&tens[i-1], bigTemp)
    }
    for i := 0; smallPrimes[i] < base; i++ {
        values[0].SetUint64(uint64(smallPrimes[i]))
        addDigit(1)
    }
    fmt.Printf(""%2d: %s\n"", base, answer.String())
}
 
func main() {
    for base = 3; base <= 17; base++ {
        doBase()
    }
}",1267,57
54754,http://rosettacode.org/wiki/Find_if_a_point_is_within_a_triangle,Find if a point is within a triangle,"Find if a point is within a triangle.



Task

   Assume points are on a plane defined by (x, y) real number coordinates.
   Given a point P(x, y) and a triangle formed by points A, B, and C, determine if P is within triangle ABC. 
   You may use any algorithm. 
   Bonus: explain why the algorithm you chose works.


Related tasks

   Determine_if_two_triangles_overlap


Also see

 Discussion of several methods. [[1]]
 Determine if a point is in a polygon [[2]]
 Triangle based coordinate systems [[3]]
 Wolfram entry [[4]]

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
const EPS = 0.001
const EPS_SQUARE = EPS * EPS
 
func side(x1, y1, x2, y2, x, y float64) float64 {
    return (y2-y1)*(x-x1) + (-x2+x1)*(y-y1)
}
 
func naivePointInTriangle(x1, y1, x2, y2, x3, y3, x, y float64) bool {
    checkSide1 := side(x1, y1, x2, y2, x, y) >= 0
    checkSide2 := side(x2, y2, x3, y3, x, y) >= 0
    checkSide3 := side(x3, y3, x1, y1, x, y) >= 0
    return checkSide1 && checkSide2 && checkSide3
}
 
func pointInTriangleBoundingBox(x1, y1, x2, y2, x3, y3, x, y float64) bool {
    xMin := math.Min(x1, math.Min(x2, x3)) - EPS
    xMax := math.Max(x1, math.Max(x2, x3)) + EPS
    yMin := math.Min(y1, math.Min(y2, y3)) - EPS
    yMax := math.Max(y1, math.Max(y2, y3)) + EPS
    return !(x < xMin || xMax < x || y < yMin || yMax < y)
}
 
func distanceSquarePointToSegment(x1, y1, x2, y2, x, y float64) float64 {
    p1_p2_squareLength := (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)
    dotProduct := ((x-x1)*(x2-x1) + (y-y1)*(y2-y1)) / p1_p2_squareLength
    if dotProduct < 0 {
        return (x-x1)*(x-x1) + (y-y1)*(y-y1)
    } else if dotProduct <= 1 {
        p_p1_squareLength := (x1-x)*(x1-x) + (y1-y)*(y1-y)
        return p_p1_squareLength - dotProduct*dotProduct*p1_p2_squareLength
    } else {
        return (x-x2)*(x-x2) + (y-y2)*(y-y2)
    }
}
 
func accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y float64) bool {
    if !pointInTriangleBoundingBox(x1, y1, x2, y2, x3, y3, x, y) {
        return false
    }
    if naivePointInTriangle(x1, y1, x2, y2, x3, y3, x, y) {
        return true
    }
    if distanceSquarePointToSegment(x1, y1, x2, y2, x, y) <= EPS_SQUARE {
        return true
    }
    if distanceSquarePointToSegment(x2, y2, x3, y3, x, y) <= EPS_SQUARE {
        return true
    }
    if distanceSquarePointToSegment(x3, y3, x1, y1, x, y) <= EPS_SQUARE {
        return true
    }
    return false
}
 
func main() {
    pts := [][2]float64{{0, 0}, {0, 1}, {3, 1}}
    tri := [][2]float64{{3.0 / 2, 12.0 / 5}, {51.0 / 10, -31.0 / 10}, {-19.0 / 5, 1.2}}
    fmt.Println(""Triangle is"", tri)
    x1, y1 := tri[0][0], tri[0][1]
    x2, y2 := tri[1][0], tri[1][1]
    x3, y3 := tri[2][0], tri[2][1]
    for _, pt := range pts {
        x, y := pt[0], pt[1]
        within := accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)
        fmt.Println(""Point"", pt, ""is within triangle?"", within)
    }
    fmt.Println()
    tri = [][2]float64{{1.0 / 10, 1.0 / 9}, {100.0 / 8, 100.0 / 3}, {100.0 / 4, 100.0 / 9}}
    fmt.Println(""Triangle is"", tri)
    x1, y1 = tri[0][0], tri[0][1]
    x2, y2 = tri[1][0], tri[1][1]
    x3, y3 = tri[2][0], tri[2][1]
    x := x1 + (3.0/7)*(x2-x1)
    y := y1 + (3.0/7)*(y2-y1)
    pt := [2]float64{x, y}
    within := accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)
    fmt.Println(""Point"", pt, ""is within triangle ?"", within)
    fmt.Println()
    tri = [][2]float64{{1.0 / 10, 1.0 / 9}, {100.0 / 8, 100.0 / 3}, {-100.0 / 8, 100.0 / 6}}
    fmt.Println(""Triangle is"", tri)
    x3 = tri[2][0]
    y3 = tri[2][1]
    within = accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)
    fmt.Println(""Point"", pt, ""is within triangle ?"", within)
}",3162,92
54771,http://rosettacode.org/wiki/Find_palindromic_numbers_in_both_binary_and_ternary_bases,Find palindromic numbers in both binary and ternary bases,"Find palindromic numbers in both binary and ternary bases

You are encouraged to solve this task according to the task description, using any language you may know.
Task

   Find and show (in decimal) the first six numbers (non-negative integers) that are   palindromes   in   both:
   base 2
   base 3
   Display   0   (zero) as the first number found, even though some other definitions ignore it.
   Optionally, show the decimal number found in its binary and ternary form.
   Show all output here.


It's permissible to assume the first two numbers and simply list them.



See also
   Sequence A60792,   numbers that are palindromic in bases 2 and 3 on The On-Line Encyclopedia of Integer Sequences.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
    ""time""
)
 
func isPalindrome2(n uint64) bool {
    x := uint64(0)
    if (n & 1) == 0 {
        return n == 0
    }
    for x < n {
        x = (x << 1) | (n & 1)
        n >>= 1
    }
    return n == x || n == (x>>1)
}
 
func reverse3(n uint64) uint64 {
    x := uint64(0)
    for n != 0 {
        x = x*3 + (n % 3)
        n /= 3
    }
    return x
}
 
func show(n uint64) {
    fmt.Println(""Decimal :"", n)
    fmt.Println(""Binary  :"", strconv.FormatUint(n, 2))
    fmt.Println(""Ternary :"", strconv.FormatUint(n, 3))
    fmt.Println(""Time    :"", time.Since(start))
    fmt.Println()
}
 
func min(a, b uint64) uint64 {
    if a < b {
        return a
    }
    return b
}
 
func max(a, b uint64) uint64 {
    if a > b {
        return a
    }
    return b
}
 
var start time.Time
 
func main() {
    start = time.Now()
    fmt.Println(""The first 7 numbers which are palindromic in both binary and ternary are :\n"")
    show(0)
    cnt := 1
    var lo, hi, pow2, pow3 uint64 = 0, 1, 1, 1
    for {
        i := lo
        for ; i < hi; i++ {
            n := (i*3+1)*pow3 + reverse3(i)
            if !isPalindrome2(n) {
                continue
            }
            show(n)
            cnt++
            if cnt >= 7 {
                return
            }
        }
 
        if i == pow3 {
            pow3 *= 3
        } else {
            pow2 *= 4
        }
 
        for {
            for pow2 <= pow3 {
                pow2 *= 4
            }
 
            lo2 := (pow2/pow3 - 1) / 3
            hi2 := (pow2*2/pow3-1)/3 + 1
            lo3 := pow3 / 3
            hi3 := pow3
 
            if lo2 >= hi3 {
                pow3 *= 3
            } else if lo3 >= hi2 {
                pow2 *= 4
            } else {
                lo = max(lo2, lo3)
                hi = min(hi2, hi3)
                break
            }
        }
    }
}",1901,101
54804,http://rosettacode.org/wiki/File_size_distribution,File size distribution,"Task

Beginning from the current directory, or optionally from a directory specified as a command-line argument, determine how many files there are of various sizes in a directory hierarchy.



My suggestion is to sort by logarithmn of file size, since a few bytes here or there, or even a factor of two or three, may not be that significant.

Don't forget that empty files may exist, to serve as a marker.



Is your file system predominantly devoted to a large number of smaller files, or a smaller number of huge files?



",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math""
    ""os""
    ""path/filepath""
)
 
func commatize(n int64) string {
    s := fmt.Sprintf(""%d"", n)
    if n < 0 {
        s = s[1:]
    }
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    if n >= 0 {
        return s
    }
    return ""-"" + s
}
 
func fileSizeDistribution(root string) {
    var sizes [12]int
    files := 0
    directories := 0
    totalSize := int64(0)
    walkFunc := func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        files++
        if info.IsDir() {
            directories++
        }
        size := info.Size()
        if size == 0 {
            sizes[0]++
            return nil
        }
        totalSize += size
        logSize := math.Log10(float64(size))
        index := int(math.Floor(logSize))
        sizes[index+1]++
        return nil
    }
    err := filepath.Walk(root, walkFunc)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(""File size distribution for '%s' :-\n\n"", root)
    for i := 0; i < len(sizes); i++ {
        if i == 0 {
            fmt.Print(""  "")
        } else {
            fmt.Print(""+ "")
        }
        fmt.Printf(""Files less than 10 ^ %-2d bytes : %5d\n"", i, sizes[i])
    }
    fmt.Println(""                                  -----"")
    fmt.Printf(""= Total number of files         : %5d\n"", files)
    fmt.Printf(""  including directories         : %5d\n"", directories)
    c := commatize(totalSize)
    fmt.Println(""\n  Total size of files           :"", c, ""bytes"")
}
 
func main() {
    fileSizeDistribution(""./"")
}",1664,72
54897,http://rosettacode.org/wiki/Find_limit_of_recursion,Find limit of recursion,"Find limit of recursion is part of Short Circuit's Console Program Basics selection.
Task

Find the limit of recursion.



",#Go,Go,"package main
 
import (
	""flag""
	""fmt""
	""runtime/debug""
)
 
func main() {
	stack := flag.Int(""stack"", 0, ""maximum per goroutine stack size or 0 for the default"")
	flag.Parse()
	if *stack > 0 {
		debug.SetMaxStack(*stack)
	}
	r(1)
}
 
func r(l int) {
	if l%1000 == 0 {
		fmt.Println(l)
	}
	r(l + 1)
}",299,23
54990,http://rosettacode.org/wiki/File_modification_time,File modification time,"Task

Get and set the modification time of a file.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""os""
    ""syscall""
    ""time""
)
 
var filename = ""input.txt""
 
func main() {
    foo, err := os.Stat(filename)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(""mod time was:"", foo.ModTime())
    mtime := time.Now()
    atime := mtime // a default, because os.Chtimes has an atime parameter.
    // but see if there's a real atime that we can preserve.
    if ss, ok := foo.Sys().(*syscall.Stat_t); ok {
        atime = time.Unix(ss.Atim.Sec, ss.Atim.Nsec)
    }
    os.Chtimes(filename, atime, mtime)
    fmt.Println(""mod time now:"", mtime)
}",614,27
55016,http://rosettacode.org/wiki/Find_common_directory_path,Find common directory path,"Create a routine that, given a set of strings representing directory paths and a single character directory separator, will return a string representing that part of the directory tree that is common to all the directories.

Test your routine using the forward slash '/' character as the directory separator and the following three strings as input paths:

     '/home/user1/tmp/coverage/test'
     '/home/user1/tmp/covert/operator'
     '/home/user1/tmp/coven/members'

Note: The resultant path should be the valid directory '/home/user1/tmp' and not the longest common string '/home/user1/tmp/cove'.

If your language has a routine that performs this function (even if it does not have a changeable separator character), then mention it as part of the task.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
	""fmt""
	""os""
	""path""
)
 
func CommonPrefix(sep byte, paths ...string) string {
	// Handle special cases.
	switch len(paths) {
	case 0:
		return """"
	case 1:
		return path.Clean(paths[0])
	}
 
	// Note, we treat string as []byte, not []rune as is often
	// done in Go. (And sep as byte, not rune). This is because
	// most/all supported OS' treat paths as string of non-zero
	// bytes. A filename may be displayed as a sequence of Unicode
	// runes (typically encoded as UTF-8) but paths are
	// not required to be valid UTF-8 or in any normalized form
	// (e.g. ""é"" (U+00C9) and ""é"" (U+0065,U+0301) are different
	// file names.
	c := []byte(path.Clean(paths[0]))
 
	// We add a trailing sep to handle the case where the
	// common prefix directory is included in the path list
	// (e.g. /home/user1, /home/user1/foo, /home/user1/bar).
	// path.Clean will have cleaned off trailing / separators with
	// the exception of the root directory, ""/"" (in which case we
	// make it ""//"", but this will get fixed up to ""/"" bellow).
	c = append(c, sep)
 
	// Ignore the first path since it's already in c
	for _, v := range paths[1:] {
		// Clean up each path before testing it
		v = path.Clean(v) + string(sep)
 
		// Find the first non-common byte and truncate c
		if len(v) < len(c) {
			c = c[:len(v)]
		}
		for i := 0; i < len(c); i++ {
			if v[i] != c[i] {
				c = c[:i]
				break
			}
		}
	}
 
	// Remove trailing non-separator characters and the final separator
	for i := len(c) - 1; i >= 0; i-- {
		if c[i] == sep {
			c = c[:i]
			break
		}
	}
 
	return string(c)
}
 
func main() {
	c := CommonPrefix(os.PathSeparator,
		//""/home/user1/tmp"",
		""/home/user1/tmp/coverage/test"",
		""/home/user1/tmp/covert/operator"",
		""/home/user1/tmp/coven/members"",
		""/home//user1/tmp/coventry"",
		""/home/user1/././tmp/covertly/foo"",
		""/home/bob/../user1/tmp/coved/bar"",
	)
	if c == """" {
		fmt.Println(""No common path"")
	} else {
		fmt.Println(""Common path:"", c)
	}
}",1976,79
55030,http://rosettacode.org/wiki/File_extension_is_in_extensions_list,File extension is in extensions list,"File extension is in extensions list

You are encouraged to solve this task according to the task description, using any language you may know.
Filename extensions are a rudimentary but commonly used way of identifying files types.



Task

Given an arbitrary filename and a list of extensions, tell whether the filename has one of those extensions.



Notes:

 The check should be case insensitive.
 The extension must occur at the very end of the filename, and be immediately preceded by a dot (.).
 You may assume that none of the given extensions are the empty string, and none of them contain a dot. Other than that they may be arbitrary strings.


Extra credit:
 Allow extensions to contain dots. This way, users of your function/program have full control over what they consider as the extension in cases like:
  archive.tar.gz

 Please state clearly whether or not your solution does this.
Test cases
The following test cases all assume this list of extensions:   zip, rar, 7z, gz, archive, A##



 Filename

 Result


 MyData.a## 
 true


 MyData.tar.Gz 
 true


 MyData.gzip 
 false


 MyData.7z.backup 
 false


 MyData... 
 false


 MyData 
 false

If your solution does the extra credit requirement, add tar.bz2 to the list of extensions, and check the following additional test cases:



 Filename

 Result


 MyData_v1.0.tar.bz2 
 true


 MyData_v1.0.bz2 
 false

Motivation
Checking if a file is in a certain category of file formats with known extensions (e.g. archive files, or image files) is a common problem in practice, and may be approached differently from extracting and outputting an arbitrary extension (see e.g. FileNameExtensionFilter in Java).

It also requires less assumptions about the format of an extension, because the calling code can decide what extensions are valid.

For these reasons, this task exists in addition to the Extract file extension task.



Related tasks
 
 Extract file extension
 String matching

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
var extensions = []string{""zip"", ""rar"", ""7z"", ""gz"", ""archive"", ""A##"", ""tar.bz2""}
 
func fileExtInList(filename string) (bool, string) {
    filename2 := strings.ToLower(filename)
    for _, ext := range extensions {
        ext2 := ""."" + strings.ToLower(ext)
        if strings.HasSuffix(filename2, ext2) {
            return true, ext
        }
    }
    s := strings.Split(filename, ""."")
    if len(s) > 1 {
        t := s[len(s)-1]
        if t != """" {
            return false, t
        } else {
            return false, ""<empty>""
        }
    } else {
        return false, ""<none>""
    }
}
 
func main() {
    fmt.Println(""The listed extensions are:"")
    fmt.Println(extensions, ""\n"")
    tests := []string{
        ""MyData.a##"", ""MyData.tar.Gz"", ""MyData.gzip"",
        ""MyData.7z.backup"", ""MyData..."", ""MyData"",
        ""MyData_v1.0.tar.bz2"", ""MyData_v1.0.bz2"",
    }
    for _, test := range tests {
        ok, ext := fileExtInList(test)
        fmt.Printf(""%-20s => %-5t  (extension = %s)\n"", test, ok, ext)
    }
}",1081,43
55033,http://rosettacode.org/wiki/Fibonacci_word/fractal,Fibonacci word/fractal,"
The Fibonacci word may be represented as a fractal as described here:


(Clicking on the above website   (hal.archives-ouvertes.fr)    will leave a cookie.)



For F_wordm start with F_wordCharn=1
Draw a segment forward
If current F_wordChar is 0
Turn left if n is even
Turn right if n is odd
next n and iterate until end of F_word


Task

Create and display a fractal similar to Fig 1.


(Clicking on the above website   (hal.archives-ouvertes.fr)    will leave a cookie.)
",#Go,Go,"package main
 
import (
    ""github.com/fogleman/gg""
    ""strings""
)
 
func wordFractal(i int) string {
    if i < 2 {
        if i == 1 {
            return ""1""
        }
        return """"
    }
    var f1 strings.Builder
    f1.WriteString(""1"")
    var f2 strings.Builder
    f2.WriteString(""0"")
    for j := i - 2; j >= 1; j-- {
        tmp := f2.String()
        f2.WriteString(f1.String())
        f1.Reset()
        f1.WriteString(tmp)
    }
    return f2.String()
}
 
func draw(dc *gg.Context, x, y, dx, dy float64, wf string) {
    for i, c := range wf {
        dc.DrawLine(x, y, x+dx, y+dy)
        x += dx
        y += dy
        if c == '0' {
            tx := dx
            dx = dy
            if i%2 == 0 {
                dx = -dy
            }
            dy = -tx
            if i%2 == 0 {
                dy = tx
            }
        }
    }
}
 
func main() {
    dc := gg.NewContext(450, 620)
    dc.SetRGB(0, 0, 0)
    dc.Clear()
    wf := wordFractal(23)
    draw(dc, 20, 20, 1, 0, wf)
    dc.SetRGB(0, 1, 0)
    dc.SetLineWidth(1)
    dc.Stroke()
    dc.SavePNG(""fib_wordfractal.png"")
}",1110,57
55116,http://rosettacode.org/wiki/Fermat_numbers,Fermat numbers,"In mathematics, a Fermat number, named after Pierre de Fermat who first studied them, is a positive integer of the form Fn = 22n + 1 where n is a non-negative integer.

Despite the simplicity of generating Fermat numbers, they have some powerful mathematical properties and are extensively used in cryptography & pseudo-random number generation, and are often linked to other number theoric fields.

As of this writing, (mid 2019), there are only five known prime Fermat numbers, the first five (F0 through F4). Only the first twelve Fermat numbers have been completely factored, though many have been partially factored.



Task

 Write a routine (function, procedure, whatever) to generate Fermat numbers.
 Use the routine to find and display here, on this page, the first 10 Fermat numbers - F0 through F9.
 Find and display here, on this page, the prime factors of as many Fermat numbers as you have patience for. (Or as many as can be found in five minutes or less of processing time). Note: if you make it past F11, there may be money, and certainly will be acclaim in it for you.


See also

 Wikipedia - Fermat numbers
 OEIS:A000215 - Fermat numbers
 OEIS:A019434 - Fermat primes

",#Go,Go,"package main
 
import (
    ""fmt""
    ""github.com/jbarham/primegen""
    ""math""
    ""math/big""
    ""math/rand""
    ""sort""
    ""time""
)
 
const (
    maxCurves = 10000
    maxRnd    = 1 << 31
    maxB1     = uint64(43 * 1e7)
    maxB2     = uint64(2 * 1e10)
)
 
var (
    zero  = big.NewInt(0)
    one   = big.NewInt(1)
    two   = big.NewInt(2)
    three = big.NewInt(3)
    four  = big.NewInt(4)
    five  = big.NewInt(5)
)
 
// Uses algorithm in Wikipedia article, including speed-up.
func pollardRho(n *big.Int) (*big.Int, error) {
    // g(x) = (x^2 + 1) mod n
    g := func(x, n *big.Int) *big.Int {
        x2 := new(big.Int)
        x2.Mul(x, x)
        x2.Add(x2, one)
        return x2.Mod(x2, n)
    }
    x, y, d := new(big.Int).Set(two), new(big.Int).Set(two), new(big.Int).Set(one)
    t, z := new(big.Int), new(big.Int).Set(one)
    count := 0
    for {
        x = g(x, n)
        y = g(g(y, n), n)
        t.Sub(x, y)
        t.Abs(t)
        t.Mod(t, n)
        z.Mul(z, t)
        count++
        if count == 100 {
            d.GCD(nil, nil, z, n)
            if d.Cmp(one) != 0 {
                break
            }
            z.Set(one)
            count = 0
        }
    }
    if d.Cmp(n) == 0 {
        return nil, fmt.Errorf(""Pollard's rho failure"")
    }
    return d, nil
}
 
// Gets all primes under 'n' - uses a Sieve of Atkin under the hood.
func getPrimes(n uint64) []uint64 {
    pg := primegen.New()
    var primes []uint64
    for {
        prime := pg.Next()
        if prime < n {
            primes = append(primes, prime)
        } else {
            break
        }
    }
    return primes
}
 
// Computes Stage 1 and Stage 2 bounds.
func computeBounds(n *big.Int) (uint64, uint64) {
    le := len(n.String())
    var b1, b2 uint64
    switch {
    case le <= 30:
        b1, b2 = 2000, 147396
    case le <= 40:
        b1, b2 = 11000, 1873422
    case le <= 50:
        b1, b2 = 50000, 12746592
    case le <= 60:
        b1, b2 = 250000, 128992510
    case le <= 70:
        b1, b2 = 1000000, 1045563762
    case le <= 80:
        b1, b2 = 3000000, 5706890290
    default:
        b1, b2 = maxB1, maxB2
    }
    return b1, b2
}
 
// Adds two specified P and Q points (in Montgomery form). Assumes R = P - Q.
func pointAdd(px, pz, qx, qz, rx, rz, n *big.Int) (*big.Int, *big.Int) {
    t := new(big.Int).Sub(px, pz)
    u := new(big.Int).Add(qx, qz)
    u.Mul(t, u)
    t.Add(px, pz)
    v := new(big.Int).Sub(qx, qz)
    v.Mul(t, v)
    upv := new(big.Int).Add(u, v)
    umv := new(big.Int).Sub(u, v)
    x := new(big.Int).Mul(upv, upv)
    x.Mul(x, rz)
    if x.Cmp(n) >= 0 {
        x.Mod(x, n)
    }
    z := new(big.Int).Mul(umv, umv)
    z.Mul(z, rx)
    if z.Cmp(n) >= 0 {
        z.Mod(z, n)
    }
    return x, z
}
 
// Doubles a point P (in Montgomery form).
func pointDouble(px, pz, n, a24 *big.Int) (*big.Int, *big.Int) {
    u2 := new(big.Int).Add(px, pz)
    u2.Mul(u2, u2)
    v2 := new(big.Int).Sub(px, pz)
    v2.Mul(v2, v2)
    t := new(big.Int).Sub(u2, v2)
    x := new(big.Int).Mul(u2, v2)
    if x.Cmp(n) >= 0 {
        x.Mod(x, n)
    }
    z := new(big.Int).Mul(a24, t)
    z.Add(v2, z)
    z.Mul(t, z)
    if z.Cmp(n) >= 0 {
        z.Mod(z, n)
    }
    return x, z
}
 
// Multiplies a specified point P (in Montgomery form) by a specified scalar.
func scalarMultiply(k, px, pz, n, a24 *big.Int) (*big.Int, *big.Int) {
    sk := fmt.Sprintf(""%b"", k)
    lk := len(sk)
    qx := new(big.Int).Set(px)
    qz := new(big.Int).Set(pz)
    rx, rz := pointDouble(px, pz, n, a24)
    for i := 1; i < lk; i++ {
        if sk[i] == '1' {
            qx, qz = pointAdd(rx, rz, qx, qz, px, pz, n)
            rx, rz = pointDouble(rx, rz, n, a24)
 
        } else {
            rx, rz = pointAdd(qx, qz, rx, rz, px, pz, n)
            qx, qz = pointDouble(qx, qz, n, a24)
        }
    }
    return qx, qz
}
 
// Lenstra's two-stage ECM algorithm.
func ecm(n *big.Int) (*big.Int, error) {
    if n.Cmp(one) == 0 || n.ProbablyPrime(10) {
        return n, nil
    }
    b1, b2 := computeBounds(n)
    dd := uint64(math.Sqrt(float64(b2)))
    beta := make([]*big.Int, dd+1)
    for i := 0; i < len(beta); i++ {
        beta[i] = new(big.Int)
    }
    s := make([]*big.Int, 2*dd+2)
    for i := 0; i < len(s); i++ {
        s[i] = new(big.Int)
    }
 
    // stage 1 and stage 2 precomputations
    curves := 0
    logB1 := math.Log(float64(b1))
    primes := getPrimes(b2)
    numPrimes := len(primes)
    idxB1 := sort.Search(len(primes), func(i int) bool { return primes[i] >= b1 })
 
    // compute a B1-powersmooth integer 'k'
    k := big.NewInt(1)
    for i := 0; i < idxB1; i++ {
        p := primes[i]
        bp := new(big.Int).SetUint64(p)
        t := uint64(logB1 / math.Log(float64(p)))
        bt := new(big.Int).SetUint64(t)
        bt.Exp(bp, bt, nil)
        k.Mul(k, bt)
    }
    g := big.NewInt(1)
    for (g.Cmp(one) == 0 || g.Cmp(n) == 0) && curves <= maxCurves {
        curves++
        st := int64(6 + rand.Intn(maxRnd-5))
        sigma := big.NewInt(st)
 
        // generate a new random curve in Montgomery form with Suyama's parameterization
        u := new(big.Int).Mul(sigma, sigma)
        u.Sub(u, five)
        u.Mod(u, n)
        v := new(big.Int).Mul(four, sigma)
        v.Mod(v, n)
        vmu := new(big.Int).Sub(v, u)
        a := new(big.Int).Mul(vmu, vmu)
        a.Mul(a, vmu)
        t := new(big.Int).Mul(three, u)
        t.Add(t, v)
        a.Mul(a, t)
        t.Mul(four, u)
        t.Mul(t, u)
        t.Mul(t, u)
        t.Mul(t, v)
        a.Quo(a, t)
        a.Sub(a, two)
        a.Mod(a, n)
        a24 := new(big.Int).Add(a, two)
        a24.Quo(a24, four)
 
        // stage 1
        px := new(big.Int).Mul(u, u)
        px.Mul(px, u)
        t.Mul(v, v)
        t.Mul(t, v)
        px.Quo(px, t)
        px.Mod(px, n)
        pz := big.NewInt(1)
        qx, qz := scalarMultiply(k, px, pz, n, a24)
        g.GCD(nil, nil, n, qz)
 
        // if stage 1 is successful, return a non-trivial factor else
        // move on to stage 2
        if g.Cmp(one) != 0 && g.Cmp(n) != 0 {
            return g, nil
        }
 
        // stage 2
        s[1], s[2] = pointDouble(qx, qz, n, a24)
        s[3], s[4] = pointDouble(s[1], s[2], n, a24)
        beta[1].Mul(s[1], s[2])
        beta[1].Mod(beta[1], n)
        beta[2].Mul(s[3], s[4])
        beta[2].Mod(beta[2], n)
        for d := uint64(3); d <= dd; d++ {
            d2 := 2 * d
            s[d2-1], s[d2] = pointAdd(s[d2-3], s[d2-2], s[1], s[2], s[d2-5], s[d2-4], n)
            beta[d].Mul(s[d2-1], s[d2])
            beta[d].Mod(beta[d], n)
        }
        g.SetUint64(1)
        b := new(big.Int).SetUint64(b1 - 1)
        rx, rz := scalarMultiply(b, qx, qz, n, a24)
        t.Mul(two, new(big.Int).SetUint64(dd))
        t.Sub(b, t)
        tx, tz := scalarMultiply(t, qx, qz, n, a24)
        q, step := idxB1, 2*dd
        for r := b1 - 1; r < b2; r += step {
            alpha := new(big.Int).Mul(rx, rz)
            alpha.Mod(alpha, n)
            limit := r + step
            for q < numPrimes && primes[q] <= limit {
                d := (primes[q] - r) / 2
                t := new(big.Int).Sub(rx, s[2*d-1])
                f := new(big.Int).Add(rz, s[2*d])
                f.Mul(t, f)
                f.Sub(f, alpha)
                f.Add(f, beta[d])
                g.Mul(g, f)
                g.Mod(g, n)
                q++
            }
            trx := new(big.Int).Set(rx)
            trz := new(big.Int).Set(rz)
            rx, rz = pointAdd(rx, rz, s[2*dd-1], s[2*dd], tx, tz, n)
            tx.Set(trx)
            tz.Set(trz)
        }
        g.GCD(nil, nil, n, g)
    }
 
    // no non-trivial factor found, return an error
    if curves > maxCurves {
        return zero, fmt.Errorf(""maximum curves exceeded before a factor was found"")
    }
    return g, nil
}
 
// find prime factors of 'n' using an appropriate method.
func primeFactors(n *big.Int) ([]*big.Int, error) {
    var res []*big.Int
    if n.ProbablyPrime(10) {
        return append(res, n), nil
    }
    le := len(n.String())
    var factor1 *big.Int
    var err error
    if le > 20 && le <= 60 {
        factor1, err = ecm(n)
    } else {
        factor1, err = pollardRho(n)
    }
    if err != nil {
        return nil, err
    }
    if !factor1.ProbablyPrime(10) {
        return nil, fmt.Errorf(""first factor is not prime"")
    }
    factor2 := new(big.Int)
    factor2.Quo(n, factor1)
    if !factor2.ProbablyPrime(10) {
        return nil, fmt.Errorf(""%d (second factor is not prime)"", factor1)
    }
    return append(res, factor1, factor2), nil
}
 
func fermatNumbers(n int) (res []*big.Int) {
    f := new(big.Int).SetUint64(3) // 2^1 + 1
    for i := 0; i < n; i++ {
        t := new(big.Int).Set(f)
        res = append(res, t)
        f.Sub(f, one)
        f.Mul(f, f)
        f.Add(f, one)
    }
    return res
}
 
func main() {
    start := time.Now()
    rand.Seed(time.Now().UnixNano())
    fns := fermatNumbers(10)
    fmt.Println(""First 10 Fermat numbers:"")
    for i, f := range fns {
        fmt.Printf(""F%c = %d\n"", 0x2080+i, f)
    }
 
    fmt.Println(""\nFactors of first 10 Fermat numbers:"")
    for i, f := range fns {
        fmt.Printf(""F%c = "", 0x2080+i)
        factors, err := primeFactors(f)
        if err != nil {
            fmt.Println(err)
            continue
        }
        for _, factor := range factors {
            fmt.Printf(""%d "", factor)
        }
        if len(factors) == 1 {
            fmt.Println(""- prime"")
        } else {
            fmt.Println()
        }
    }
    fmt.Printf(""\nTook %s\n"", time.Since(start))
}",9634,361
55145,http://rosettacode.org/wiki/Feigenbaum_constant_calculation,Feigenbaum constant calculation,"Task

Calculate the Feigenbaum constant.



See

   Details in the Wikipedia article:   Feigenbaum constant.

",#Go,Go,"package main
 
import ""fmt""
 
func feigenbaum() {
    maxIt, maxItJ := 13, 10
    a1, a2, d1 := 1.0, 0.0, 3.2
    fmt.Println("" i       d"")
    for i := 2; i <= maxIt; i++ {
        a := a1 + (a1-a2)/d1
        for j := 1; j <= maxItJ; j++ {
            x, y := 0.0, 0.0
            for k := 1; k <= 1<<uint(i); k++ {
                y = 1.0 - 2.0*y*x
                x = a - x*x
            }
            a -= x / y
        }
        d := (a1 - a2) / (a - a1)
        fmt.Printf(""%2d    %.8f\n"", i, d)
        d1, a2, a1 = d, a1, a
    }
}
 
func main() {
    feigenbaum()
}",575,27
55157,http://rosettacode.org/wiki/File_size,File size,"Verify the size of a file called     input.txt     for a file in the current working directory, and another one in the file system root.



",#Go,Go,"package main
 
import ""fmt""
import ""os""
 
func printFileSize(f string) {
    if stat, err := os.Stat(f); err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(stat.Size())
    }
}
 
func main() {
    printFileSize(""input.txt"")
    printFileSize(""/input.txt"")
}",277,17
55371,http://rosettacode.org/wiki/FizzBuzz,FizzBuzz,"Task

Write a program that prints the integers from   1   to   100   (inclusive).



But:

   for multiples of three,   print   Fizz     (instead of the number)
   for multiples of five,   print   Buzz     (instead of the number)
   for multiples of both three and five,   print   FizzBuzz     (instead of the number) 


The   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.



Also see

   (a blog)   dont-overthink-fizzbuzz
   (a blog)   fizzbuzz-the-programmers-stairway-to-heaven

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    for i := 1; i <= 100; i++ {
        switch {
        case i%15==0:
            fmt.Println(""FizzBuzz"")
        case i%3==0:
            fmt.Println(""Fizz"")
        case i%5==0:
            fmt.Println(""Buzz"")
        default: 
            fmt.Println(i)
        }
    }
}",319,18
55376,http://rosettacode.org/wiki/Fibonacci_word,Fibonacci word,"The   Fibonacci Word   may be created in a manner analogous to the   Fibonacci Sequence   as described here:

    Define   F_Word1   as   1
    Define   F_Word2   as   0
    Form     F_Word3   as   F_Word2     concatenated with   F_Word1    i.e.:   01
    Form     F_Wordn   as   F_Wordn-1   concatenated with   F_wordn-2



Task

Perform the above steps for     n = 37.

You may display the first few but not the larger values of   n.

{Doing so will get the task's author into trouble with them what be (again!).} 

Instead, create a table for   F_Words   1   to   37   which shows:

   The number of characters in the word
   The word's Entropy


Related tasks
 
   Fibonacci word/fractal
   Entropy
   Entropy/Narcissist

",#Go,Go,"package main
 
import (
	""fmt""
	""math""
)
 
// From http://rosettacode.org/wiki/Entropy#Go
func entropy(s string) float64 {
	m := map[rune]float64{}
	for _, r := range s {
		m[r]++
	}
	hm := 0.
	for _, c := range m {
		hm += c * math.Log2(c)
	}
	l := float64(len(s))
	return math.Log2(l) - hm/l
}
 
const F_Word1 = ""1""
const F_Word2 = ""0""
 
func FibonacciWord(n int) string {
	a, b := F_Word1, F_Word2
	for ; n > 1; n-- {
		a, b = b, b+a
	}
	return a
}
 
func FibonacciWordGen() <-chan string {
	ch := make(chan string)
	go func() {
		a, b := F_Word1, F_Word2
		for {
			ch <- a
			a, b = b, b+a
		}
	}()
	return ch
}
 
func main() {
	fibWords := FibonacciWordGen()
	fmt.Printf(""%3s %9s  %-18s  %s\n"", ""N"", ""Length"", ""Entropy"", ""Word"")
	n := 1
	for ; n < 10; n++ {
		s := <-fibWords
		// Just to show the function and generator do the same thing:
		if s2 := FibonacciWord(n); s != s2 {
			fmt.Printf(""For %d, generator produced %q, function produced %q\n"", n, s, s2)
		}
		fmt.Printf(""%3d %9d  %.16f  %s\n"", n, len(s), entropy(s), s)
	}
	for ; n <= 37; n++ {
		s := <-fibWords
		fmt.Printf(""%3d %9d  %.16f\n"", n, len(s), entropy(s))
	}
}",1136,61
55378,http://rosettacode.org/wiki/FASTA_format,FASTA format,"In bioinformatics, long character strings are often encoded in a format called FASTA.

A FASTA file can contain several strings, each identified by a name marked by a > (greater than) character at the beginning of the line.



Task

Write a program that reads a FASTA file such as:

>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED


Output:
Rosetta_Example_1: THERECANBENOSPACE
Rosetta_Example_2: THERECANBESEVERALLINESBUTTHEYALLMUSTBECONCATENATED

Note that a high-quality implementation will not hold the entire file in memory at once; real FASTA files can be multiple gigabytes in size.



",#Go,Go,"package main
 
import (
        ""bufio""
        ""fmt""
        ""os""
)
 
func main() {
        f, err := os.Open(""rc.fasta"")
        if err != nil {
                fmt.Println(err)
                return
        }
        defer f.Close()
        s := bufio.NewScanner(f)
        headerFound := false
        for s.Scan() {
                line := s.Text()
                switch {
                case line == """":
                        continue
                case line[0] != '>':
                        if !headerFound {
                                fmt.Println(""missing header"")
                                return
                        }
                        fmt.Print(line)
                case headerFound:
                        fmt.Println()
                        fallthrough
                default:
                        fmt.Printf(""%s: "", line[1:])
                        headerFound = true
                }
        }
        if headerFound {
                fmt.Println()
        }
        if err := s.Err(); err != nil {
                fmt.Println(err)
        }
}",1098,43
55413,http://rosettacode.org/wiki/Faulhaber%27s_formula,Faulhaber's formula,"In mathematics,   Faulhaber's formula,   named after Johann Faulhaber,   expresses the sum of the p-th powers of the first n positive integers as a (p + 1)th-degree polynomial function of n,   the coefficients involving Bernoulli numbers.



Task

Generate the first 10 closed-form expressions, starting with p = 0.



Related tasks

   Bernoulli numbers.
   evaluate binomial coefficients.


See also

   The Wikipedia entry:   Faulhaber's formula.
   The Wikipedia entry:   Bernoulli numbers.
   The Wikipedia entry:   binomial coefficients.

",#Go,Go,"package main
 
import (
	""fmt""
	""math/big""
)
 
func bernoulli(z *big.Rat, n int64) *big.Rat {
	if z == nil {
		z = new(big.Rat)
	}
	a := make([]big.Rat, n+1)
	for m := range a {
		a[m].SetFrac64(1, int64(m+1))
		for j := m; j >= 1; j-- {
			d := &a[j-1]
			d.Mul(z.SetInt64(int64(j)), d.Sub(d, &a[j]))
		}
	}
	return z.Set(&a[0])
}
 
func main() {
	// allocate needed big.Rat's once
	q := new(big.Rat)
	c := new(big.Rat)      // coefficients
	be := new(big.Rat)     // for Bernoulli numbers
	bi := big.NewRat(1, 1) // for binomials
 
	for p := int64(0); p < 10; p++ {
		fmt.Print(p, "" : "")
		q.SetFrac64(1, p+1)
		neg := true
		for j := int64(0); j <= p; j++ {
			neg = !neg
			if neg {
				c.Neg(q)
			} else {
				c.Set(q)
			}
			bi.Num().Binomial(p+1, j)
			bernoulli(be, j)
			c.Mul(c, bi)
			c.Mul(c, be)
			if c.Num().BitLen() == 0 {
				continue
			}
			if j == 0 {
				fmt.Printf("" %4s"", c.RatString())
			} else {
				fmt.Printf("" %+2d/%-2d"", c.Num(), c.Denom())
			}
			fmt.Print(""×n"")
			if exp := p + 1 - j; exp > 1 {
				fmt.Printf(""^%-2d"", exp)
			}
		}
		fmt.Println()
	}
}",1089,60
55446,http://rosettacode.org/wiki/Faulhaber%27s_triangle,Faulhaber's triangle,"Named after Johann Faulhaber, the rows of Faulhaber's triangle are the coefficients of polynomials that represent sums of integer powers, which are extracted from Faulhaber's formula:








∑

k
=
1


n



k

p


=


1

p
+
1




∑

j
=
0


p





(



p
+
1

j


)




B

j



n

p
+
1
−
j




{\displaystyle \sum _{k=1}^{n}k^{p}={1 \over p+1}\sum _{j=0}^{p}{p+1 \choose j}B_{j}n^{p+1-j}}




where 




B

n




{\displaystyle B_{n}}

 is the nth-Bernoulli number.



The first 5 rows of Faulhaber's triangle, are:

    1
  1/2  1/2
  1/6  1/2  1/3
    0  1/4  1/2  1/4
-1/30    0  1/3  1/2  1/5



Using the third row of the triangle, we have:






∑

k
=
1


n



k

2


=


1
6


n
+


1
2



n

2


+


1
3



n

3




{\displaystyle \sum _{k=1}^{n}k^{2}={1 \over 6}n+{1 \over 2}n^{2}+{1 \over 3}n^{3}}





 Task
 show the first 10 rows of Faulhaber's triangle.
 using the 18th row of Faulhaber's triangle, compute the sum: 




∑

k
=
1


1000



k

17




{\displaystyle \sum _{k=1}^{1000}k^{17}}

 (extra credit).
 See also

 Bernoulli numbers
 Evaluate binomial coefficients
 Faulhaber's formula (Wikipedia)
 Faulhaber's triangle (PDF)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func bernoulli(n uint) *big.Rat {
    a := make([]big.Rat, n+1)
    z := new(big.Rat)
    for m := range a {
        a[m].SetFrac64(1, int64(m+1))
        for j := m; j >= 1; j-- {
            d := &a[j-1]
            d.Mul(z.SetInt64(int64(j)), d.Sub(d, &a[j]))
        }
    }
    // return the 'first' Bernoulli number
    if n != 1 {
        return &a[0]
    }
    a[0].Neg(&a[0])
    return &a[0]
}
 
func binomial(n, k int) int64 {
    if n <= 0 || k <= 0 || n < k {
        return 1
    }
    var num, den int64 = 1, 1
    for i := k + 1; i <= n; i++ {
        num *= int64(i)
    }
    for i := 2; i <= n-k; i++ {
        den *= int64(i)
    }
    return num / den
}
 
func faulhaberTriangle(p int) []big.Rat {
    coeffs := make([]big.Rat, p+1)
    q := big.NewRat(1, int64(p)+1)
    t := new(big.Rat)
    u := new(big.Rat)
    sign := -1
    for j := range coeffs {
        sign *= -1
        d := &coeffs[p-j]
        t.SetInt64(int64(sign))
        u.SetInt64(binomial(p+1, j))
        d.Mul(q, t)
        d.Mul(d, u)
        d.Mul(d, bernoulli(uint(j)))
    }
    return coeffs
}
 
func main() {
    for i := 0; i < 10; i++ {
        coeffs := faulhaberTriangle(i)
        for _, coeff := range coeffs {
            fmt.Printf(""%5s  "", coeff.RatString())
        }
        fmt.Println()
    }
    fmt.Println()
    // get coeffs for (k + 1)th row
    k := 17
    cc := faulhaberTriangle(k)
    n := int64(1000)
    nn := big.NewRat(n, 1)
    np := big.NewRat(1, 1)
    sum := new(big.Rat)
    tmp := new(big.Rat)
    for _, c := range cc {
        np.Mul(np, nn)
        tmp.Set(np)
        tmp.Mul(tmp, &c)
        sum.Add(sum, tmp)
    }
    fmt.Println(sum.RatString())
}",1740,82
55476,http://rosettacode.org/wiki/Fairshare_between_two_and_more,Fairshare between two and more,"The Thue-Morse sequence is a sequence of ones and zeros that if two people
take turns in the given order, the first persons turn for every '0' in the
sequence, the second for every '1'; then this is shown to give a fairer, more
equitable sharing of resources. (Football penalty shoot-outs for example, might
not favour the team that goes first as much if the penalty takers take turns
according to the Thue-Morse sequence and took 2^n penalties)

The Thue-Morse sequence of ones-and-zeroes can be generated by:

""When counting in binary, the digit sum modulo 2 is the Thue-Morse sequence""


Sharing fairly between two or more

Use this method:

When counting base b, the digit sum modulo b is the Thue-Morse sequence of fairer sharing between b people.


Task
Counting from zero;   using a function/method/routine to express an integer count in base b,

sum the digits modulo b to produce the next member of the Thue-Morse fairshare series for b people.



Show the first 25 terms of the fairshare sequence:

   For two people:
   For three people
   For five people
   For eleven people


Related tasks

   Non-decimal radices/Convert
   Thue-Morse


See also

   A010060, A053838, A053840: The On-Line Encyclopedia of Integer Sequences® (OEIS®)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
    ""strconv""
    ""strings""
)
 
func fairshare(n, base int) []int {
    res := make([]int, n)
    for i := 0; i < n; i++ {
        j := i
        sum := 0
        for j > 0 {
            sum += j % base
            j /= base
        }
        res[i] = sum % base
    }
    return res
}
 
func turns(n int, fss []int) string {
    m := make(map[int]int)
    for _, fs := range fss {
        m[fs]++
    }
    m2 := make(map[int]int)
    for _, v := range m {
        m2[v]++
    }
    res := []int{}
    sum := 0
    for k, v := range m2 {
        sum += v
        res = append(res, k)
    }
    if sum != n {
        return fmt.Sprintf(""only %d have a turn"", sum)
    }
    sort.Ints(res)
    res2 := make([]string, len(res))
    for i := range res {
        res2[i] = strconv.Itoa(res[i])
    }
    return strings.Join(res2, "" or "")
}
 
func main() {
    for _, base := range []int{2, 3, 5, 11} {
        fmt.Printf(""%2d : %2d\n"", base, fairshare(25, base))
    }
    fmt.Println(""\nHow many times does each get a turn in 50000 iterations?"")
    for _, base := range []int{191, 1377, 49999, 50000, 50001} {
        t := turns(base, fairshare(50000, base))
        fmt.Printf(""  With %d people: %s\n"", base, t)
    }
}",1263,59
55526,http://rosettacode.org/wiki/File_input/output,File input/output,"File input/output is part of Short Circuit's Console Program Basics selection.
Task

Create a file called   ""output.txt"",   and place in it the contents of the file   ""input.txt"",   via an intermediate variable.

In other words, your program will demonstrate:

   how to read from a file into a variable
   how to write a variable's contents into a file


Oneliners that skip the intermediate variable are of secondary interest — operating systems have copy commands for that.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""io/ioutil""
)
 
func main() {
    b, err := ioutil.ReadFile(""input.txt"")
    if err != nil {
        fmt.Println(err)
        return
    }
    if err = ioutil.WriteFile(""output.txt"", b, 0666); err != nil {
        fmt.Println(err)
    }
}",276,17
55703,http://rosettacode.org/wiki/Farey_sequence,Farey sequence,"The   Farey sequence    Fn   of order   n   is the sequence of completely reduced fractions between   0   and   1   which, when in lowest terms, have denominators less than or equal to   n,   arranged in order of increasing size.

The   Farey sequence   is sometimes incorrectly called a   Farey series.



Each Farey sequence:

   starts with the value   0   (zero),   denoted by the fraction     





0
1




{\displaystyle {\frac {0}{1}}}


   ends with the value   1   (unity),   denoted by the fraction   





1
1




{\displaystyle {\frac {1}{1}}}

.


The Farey sequences of orders   1   to   5   are:

 







F




1


=


0
1


,


1
1




{\displaystyle {\bf {\it {F}}}_{1}={\frac {0}{1}},{\frac {1}{1}}}



 







F




2


=


0
1


,


1
2


,


1
1




{\displaystyle {\bf {\it {F}}}_{2}={\frac {0}{1}},{\frac {1}{2}},{\frac {1}{1}}}



 







F




3


=


0
1


,


1
3


,


1
2


,


2
3


,


1
1




{\displaystyle {\bf {\it {F}}}_{3}={\frac {0}{1}},{\frac {1}{3}},{\frac {1}{2}},{\frac {2}{3}},{\frac {1}{1}}}



 







F




4


=


0
1


,


1
4


,


1
3


,


1
2


,


2
3


,


3
4


,


1
1




{\displaystyle {\bf {\it {F}}}_{4}={\frac {0}{1}},{\frac {1}{4}},{\frac {1}{3}},{\frac {1}{2}},{\frac {2}{3}},{\frac {3}{4}},{\frac {1}{1}}}



 







F




5


=


0
1


,


1
5


,


1
4


,


1
3


,


2
5


,


1
2


,


3
5


,


2
3


,


3
4


,


4
5


,


1
1




{\displaystyle {\bf {\it {F}}}_{5}={\frac {0}{1}},{\frac {1}{5}},{\frac {1}{4}},{\frac {1}{3}},{\frac {2}{5}},{\frac {1}{2}},{\frac {3}{5}},{\frac {2}{3}},{\frac {3}{4}},{\frac {4}{5}},{\frac {1}{1}}}


Task
   Compute and show the Farey sequence for orders   1   through   11   (inclusive).
   Compute and display the   number   of fractions in the Farey sequence for order   100   through   1,000   (inclusive)   by hundreds.
   Show the fractions as    n/d    (using the solidus [or slash] to separate the numerator from the denominator). 


The length   (the number of fractions)   of a Farey sequence asymptotically approaches:

  3 × n2   ÷   



π


{\displaystyle \pi }

2 
See also

   OEIS sequence   A006842 numerators of Farey series of order 1, 2, ··· 
   OEIS sequence   A006843 denominators of Farey series of order 1, 2, ··· 
   OEIS sequence   A005728 number of fractions in Farey series of order n 
   MathWorld entry   Farey sequence
   Wikipedia   entry   Farey sequence

",#Go,Go,"package main
 
import ""fmt""
 
type frac struct{ num, den int }
 
func (f frac) String() string {
    return fmt.Sprintf(""%d/%d"", f.num, f.den)
}
 
func f(l, r frac, n int) {
    m := frac{l.num + r.num, l.den + r.den}
    if m.den <= n {
        f(l, m, n)
        fmt.Print(m, "" "")
        f(m, r, n)
    }
}
 
func main() {
    // task 1.  solution by recursive generation of mediants
    for n := 1; n <= 11; n++ {
        l := frac{0, 1}
        r := frac{1, 1}
        fmt.Printf(""F(%d): %s "", n, l)
        f(l, r, n)
        fmt.Println(r)
    }
    // task 2.  direct solution by summing totient function
    // 2.1 generate primes to 1000
    var composite [1001]bool
    for _, p := range []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31} {
        for n := p * 2; n <= 1000; n += p {
            composite[n] = true
        }
    }
    // 2.2 generate totients to 1000
    var tot [1001]int
    for i := range tot {
        tot[i] = 1
    }
    for n := 2; n <= 1000; n++ {
        if !composite[n] {
            tot[n] = n - 1
            for a := n * 2; a <= 1000; a += n {
                f := n - 1
                for r := a / n; r%n == 0; r /= n {
                    f *= n
                }
                tot[a] *= f
            }
        }
    }
    // 2.3 sum totients
    for n, sum := 1, 1; n <= 1000; n++ {
        sum += tot[n]
        if n%100 == 0 {
            fmt.Printf(""|F(%d)|: %d\n"", n, sum)
        }
    }
}",1440,61
55864,http://rosettacode.org/wiki/Fast_Fourier_transform,Fast Fourier transform,"Task

Calculate the   FFT   (Fast Fourier Transform)   of an input sequence.

The most general case allows for complex numbers at the input
and results in a sequence of equal length, again of complex numbers.
If you need to restrict yourself to real numbers, the output should
be the magnitude   (i.e.:   sqrt(re2 + im2))   of the complex result.

The classic version is the recursive Cooley–Tukey FFT. Wikipedia has pseudo-code for that.
Further optimizations are possible but not required.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/cmplx""
)
 
func ditfft2(x []float64, y []complex128, n, s int) {
    if n == 1 {
        y[0] = complex(x[0], 0)
        return
    }
    ditfft2(x, y, n/2, 2*s)
    ditfft2(x[s:], y[n/2:], n/2, 2*s)
    for k := 0; k < n/2; k++ {
        tf := cmplx.Rect(1, -2*math.Pi*float64(k)/float64(n)) * y[k+n/2]
        y[k], y[k+n/2] = y[k]+tf, y[k]-tf
    }
}
 
func main() {
    x := []float64{1, 1, 1, 1, 0, 0, 0, 0}
    y := make([]complex128, len(x))
    ditfft2(x, y, len(x), 1)
    for _, c := range y {
        fmt.Printf(""%8.4f\n"", c)
    }
}",599,29
55903,http://rosettacode.org/wiki/Factors_of_a_Mersenne_number,Factors of a Mersenne number,"A Mersenne number is a number in the form of 2P-1.

If P is prime, the Mersenne number may be a Mersenne prime
(if P is not prime, the Mersenne number is also not prime).

In the search for Mersenne prime numbers it is advantageous to eliminate exponents by finding a small factor before starting a, potentially lengthy, Lucas-Lehmer test.

There are very efficient algorithms for determining if a number divides 2P-1 (or equivalently, if 2P mod (the number) = 1).
Some languages already have built-in implementations of this exponent-and-mod operation (called modPow or similar).

The following is how to implement this modPow yourself:

For example, let's compute 223 mod 47.
Convert the exponent 23 to binary, you get 10111. Starting with square = 1, repeatedly square it.
Remove the top bit of the exponent, and if it's 1 multiply square by the base of the exponentiation (2), then compute square modulo 47.
Use the result of the modulo from the last step as the initial value of square in the next step:

                  remove       optional   
      square      top bit   multiply by 2   mod 47
   ────────────   ───────   ─────────────   ────── 
   1*1 = 1        1  0111   1*2 = 2            2
   2*2 = 4        0   111      no              4
   4*4 = 16       1    11   16*2 = 32         32
   32*32 = 1024   1     1   1024*2 = 2048     27
   27*27 = 729    1         729*2 = 1458       1

Since 223 mod 47 = 1, 47 is a factor of 2P-1.
(To see this, subtract 1 from both sides: 223-1 = 0 mod 47.)
Since we've shown that 47 is a factor, 223-1 is not prime.
Further properties of Mersenne numbers allow us to refine the process even more.
Any factor q of 2P-1 must be of the form 2kP+1, k being a positive integer or zero. Furthermore, q must be 1 or 7 mod 8.
Finally any potential factor q must be prime.
As in other trial division algorithms, the algorithm stops when 2kP+1 > sqrt(N).

These primality tests only work on Mersenne numbers where P is prime. For example, M4=15 yields no factors using these techniques, but factors into 3 and 5, neither of which fit 2kP+1.



Task

Using the above method find a factor of 2929-1 (aka M929)



Related tasks

   count in factors
   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division


See also

   Computers in 1948: 2127 - 1 
       (Note:   This video is no longer available because the YouTube account associated with this video has been terminated.)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
// limit search to small primes.  really this is higher than
// you'd want it, but it's fun to factor M67.
const qlimit = 2e8
 
func main() {
    mtest(31)
    mtest(67)
    mtest(929)
}
 
func mtest(m int32) {
    // the function finds odd prime factors by
    // searching no farther than sqrt(N), where N = 2^m-1.
    // the first odd prime is 3, 3^2 = 9, so M3 = 7 is still too small.
    // M4 = 15 is first number for which test is meaningful.
    if m < 4 {
        fmt.Printf(""%d < 4.  M%d not tested.\n"", m, m)
        return
    }
    flimit := math.Sqrt(math.Pow(2, float64(m)) - 1)
    var qlast int32
    if flimit < qlimit {
        qlast = int32(flimit)
    } else {
        qlast = qlimit
    }
    composite := make([]bool, qlast+1)
    sq := int32(math.Sqrt(float64(qlast)))
loop:
    for q := int32(3); ; {
        if q <= sq {
            for i := q * q; i <= qlast; i += q {
                composite[i] = true
            }
        }
        if q8 := q % 8; (q8 == 1 || q8 == 7) && modPow(2, m, q) == 1 {
            fmt.Printf(""M%d has factor %d\n"", m, q)
            return
        }
        for {
            q += 2
            if q > qlast {
                break loop
            }
            if !composite[q] {
                break
            }
        }
    }
    fmt.Printf(""No factors of M%d found.\n"", m)
}
 
// base b to power p, mod m
func modPow(b, p, m int32) int32 {
    pow := int64(1)
    b64 := int64(b)
    m64 := int64(m)
    bit := uint(30)
    for 1<<bit&p == 0 {
        bit--
    }
    for {
        pow *= pow
        if 1<<bit&p != 0 {
            pow *= b64
        }
        pow %= m64
        if bit == 0 {
            break
        }
        bit--
    }
    return int32(pow)
}",1781,81
55953,http://rosettacode.org/wiki/Fibonacci_n-step_number_sequences,Fibonacci n-step number sequences,"These number series are an expansion of the ordinary Fibonacci sequence where:

 For 



n
=
2


{\displaystyle n=2}

 we have the Fibonacci sequence; with initial values 



[
1
,
1
]


{\displaystyle [1,1]}

 and 




F

k


2


=

F

k
−
1


2


+

F

k
−
2


2




{\displaystyle F_{k}^{2}=F_{k-1}^{2}+F_{k-2}^{2}}


 For 



n
=
3


{\displaystyle n=3}

 we have the tribonacci sequence; with initial values 



[
1
,
1
,
2
]


{\displaystyle [1,1,2]}

 and 




F

k


3


=

F

k
−
1


3


+

F

k
−
2


3


+

F

k
−
3


3




{\displaystyle F_{k}^{3}=F_{k-1}^{3}+F_{k-2}^{3}+F_{k-3}^{3}}


 For 



n
=
4


{\displaystyle n=4}

 we have the tetranacci sequence; with initial values 



[
1
,
1
,
2
,
4
]


{\displaystyle [1,1,2,4]}

 and 




F

k


4


=

F

k
−
1


4


+

F

k
−
2


4


+

F

k
−
3


4


+

F

k
−
4


4




{\displaystyle F_{k}^{4}=F_{k-1}^{4}+F_{k-2}^{4}+F_{k-3}^{4}+F_{k-4}^{4}}


...
 For general 



n
>
2


{\displaystyle n>2}

 we have the Fibonacci 



n


{\displaystyle n}

-step sequence - 




F

k


n




{\displaystyle F_{k}^{n}}

; with initial values of the first 



n


{\displaystyle n}

 values of the 



(
n
−
1
)


{\displaystyle (n-1)}

'th Fibonacci 



n


{\displaystyle n}

-step sequence 




F

k


n
−
1




{\displaystyle F_{k}^{n-1}}

; and 



k


{\displaystyle k}

'th value of this 



n


{\displaystyle n}

'th sequence being 




F

k


n


=

∑

i
=
1


(
n
)




F

k
−
i


(
n
)





{\displaystyle F_{k}^{n}=\sum _{i=1}^{(n)}{F_{k-i}^{(n)}}}


For small values of 



n


{\displaystyle n}

, Greek numeric prefixes are sometimes used to individually name each series.


 Fibonacci 



n


{\displaystyle n}

-step sequences


 



n


{\displaystyle n}

 
 Series name 
 Values


 2 
 fibonacci 
 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...


 3 
 tribonacci 
 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...


 4 
 tetranacci 
 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...


 5 
 pentanacci 
 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...


 6 
 hexanacci 
 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...


 7 
 heptanacci 
 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...


 8 
 octonacci 
 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...


 9 
 nonanacci 
 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...


 10 
 decanacci 
 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...

Allied sequences can be generated where the initial values are changed:

 The Lucas series sums the two preceding values like the fibonacci series for 



n
=
2


{\displaystyle n=2}

 but uses 



[
2
,
1
]


{\displaystyle [2,1]}

 as its initial values.


Task

 Write a function to generate Fibonacci 



n


{\displaystyle n}

-step number sequences given its initial values and assuming the number of initial values determines how many previous values are summed to make the next number of the series.
 Use this to print and show here at least the first ten members of the Fibo/tribo/tetra-nacci and Lucas sequences.


Related tasks

   Fibonacci sequence
   Wolfram Mathworld
   Hofstadter Q sequence‎
   Leonardo numbers


Also see

   Lucas Numbers - Numberphile (Video)
   Tribonacci Numbers (and the Rauzy Fractal) - Numberphile (Video)
   Wikipedia, Lucas number
   MathWorld, Fibonacci Number
   Some identities for r-Fibonacci numbers
   OEIS Fibonacci numbers
   OEIS Lucas numbers

",#Go,Go,"package main
 
import ""fmt""
 
func g(i []int, c chan<- int) {
	var sum int
	b := append([]int(nil), i...) // make a copy
	for _, t := range b {
		c <- t
		sum += t
	}
	for {
		for j, t := range b {
			c <- sum
			b[j], sum = sum, sum+sum-t
		}
	}
}
 
func main() {
	for _, s := range [...]struct {
		seq string
		i   []int
	}{
		{""Fibonacci"", []int{1, 1}},
		{""Tribonacci"", []int{1, 1, 2}},
		{""Tetranacci"", []int{1, 1, 2, 4}},
		{""Lucas"", []int{2, 1}},
	} {
		fmt.Printf(""%10s:"", s.seq)
		c := make(chan int)
		// Note/warning: these goroutines are leaked.
		go g(s.i, c)
		for j := 0; j < 10; j++ {
			fmt.Print("" "", <-c)
		}
		fmt.Println()
	}
}",648,39
55954,http://rosettacode.org/wiki/Filter,Filter,"Task

Select certain elements from an Array into a new Array in a generic way.



To demonstrate, select all even numbers from an Array.

As an option, give a second solution which filters destructively,
by modifying the original Array rather than creating a new Array.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
)
 
func main() {
    a := rand.Perm(20)
    fmt.Println(a)       // show array to filter
    fmt.Println(even(a)) // show result of non-destructive filter
    fmt.Println(a)       // show that original array is unchanged
    reduceToEven(&a)     // destructive filter
    fmt.Println(a)       // show that a is now changed
    // a is not only changed, it is changed in place.  length and capacity
    // show that it still has its original allocated capacity but has now
    // been reduced in length.
    fmt.Println(""a len:"", len(a), ""cap:"", cap(a))
}
 
func even(a []int) (r []int) {
    for _, e := range a {
        if e%2 == 0 {
            r = append(r, e)
        }
    }
    return
}
 
func reduceToEven(pa *[]int) {
    a := *pa
    var last int
    for _, e := range a {
        if e%2 == 0 {
            a[last] = e
            last++
        }
    }
    *pa = a[:last]
}",935,40
56344,http://rosettacode.org/wiki/Factors_of_an_integer,Factors of an integer,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Compute the   factors   of a positive integer.

These factors are the positive integers by which the number being factored can be divided to yield a positive integer result.

(Though the concepts function correctly for zero and negative integers, the set of factors of zero has countably infinite members, and the factors of negative integers can be obtained from the factors of related positive numbers without difficulty;   this task does not require handling of either of these cases).

Note that every prime number has two factors:   1   and itself.



Related tasks

   count in factors
   prime decomposition
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division
   sequence: smallest number greater than previous term with exactly n divisors

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    printFactors(-1)
    printFactors(0)
    printFactors(1)
    printFactors(2)
    printFactors(3)
    printFactors(53)
    printFactors(45)
    printFactors(64)
    printFactors(600851475143)
    printFactors(999999999999999989)
}
 
func printFactors(nr int64) {
    if nr < 1 {
        fmt.Println(""\nFactors of"", nr, ""not computed"")
        return
    }
    fmt.Printf(""\nFactors of %d: "", nr)
    fs := make([]int64, 1)
    fs[0] = 1
    apf := func(p int64, e int) {
        n := len(fs)
        for i, pp := 0, p; i < e; i, pp = i+1, pp*p {
            for j := 0; j < n; j++ {
                fs = append(fs, fs[j]*pp)
            }
        }
    }
    e := 0
    for ; nr & 1 == 0; e++ {
        nr >>= 1
    }
    apf(2, e)
    for d := int64(3); nr > 1; d += 2 {
        if d*d > nr {
            d = nr
        }
        for e = 0; nr%d == 0; e++ {
            nr /= d
        }
        if e > 0 {
            apf(d, e)
        }
    }
    fmt.Println(fs)
    fmt.Println(""Number of factors ="", len(fs))
}",1062,52
56466,http://rosettacode.org/wiki/Faces_from_a_mesh,Faces from a mesh,"A mesh defining a surface has uniquely numbered vertices, and named,
simple-polygonal faces described usually by an ordered list of edge numbers
going around the face,



For example:
External image of two faces

Rough textual version without edges:


      1         
                        17
 7   A
             B

       11                     
                  23


 A is the triangle (1, 11, 7), or equally (7, 11, 1), going anti-clockwise, or
any of all the rotations of those ordered vertices.

      1         
                        
 7   A
            

       11
 B is the four-sided face (1, 17, 23, 11), or equally (23, 17, 1, 11) or any 
of their rotations.

1         
                  17

       B

 11                     
            23
Let's call the above the perimeter format as it traces around the perimeter.

A second format

A separate algorithm returns polygonal faces consisting of a face name and an unordered
set of edge definitions for each face.

 A single edge is described by the vertex numbers at its two ends, always in 
ascending order.

 All edges for the face are given, but in an undefined order.
For example face A could be described by the edges (1, 11), (7, 11), and (1, 7)
(The order of each vertex number in an edge is ascending, but the order in
which the edges are stated is arbitrary).

Similarly face B could be described by the edges (11, 23), (1, 17), (17, 23),
and (1, 11) in arbitrary order of the edges.

Let's call this second format the edge format.



Task

1. Write a routine to check if two perimeter formatted faces have the same perimeter. Use it to check if the following pairs of perimeters are the same:

 Q: (8, 1, 3)
 R: (1, 3, 8)

 U: (18, 8, 14, 10, 12, 17, 19)
 V: (8, 14, 10, 12, 17, 19, 18)

2. Write a routine and use it to transform the following faces from edge to perimeter format.

 E: {(1, 11), (7, 11), (1, 7)}
 F: {(11, 23), (1, 17), (17, 23), (1, 11)}
 G: {(8, 14), (17, 19), (10, 12), (10, 14), (12, 17), (8, 18), (18, 19)}
 H: {(1, 3), (9, 11), (3, 11), (1, 11)}

Show your output here.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
// Check a slice contains a value.
func contains(s []int, f int) bool {
    for _, e := range s {
        if e == f {
            return true
        }
    }
    return false
}
 
// Assumes s1, s2 are of same length.
func sliceEqual(s1, s2 []int) bool {
    for i := 0; i < len(s1); i++ {
        if s1[i] != s2[i] {
            return false
        }
    }
    return true
}
 
// Reverses slice in place.
func reverse(s []int) {
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}
 
// Check two perimeters are equal.
func perimEqual(p1, p2 []int) bool {
    le := len(p1)
    if le != len(p2) {
        return false
    }
    for _, p := range p1 {
        if !contains(p2, p) {
            return false
        }
    }
    // use copy to avoid mutating 'p1'
    c := make([]int, le)
    copy(c, p1)
    for r := 0; r < 2; r++ {
        for i := 0; i < le; i++ {
            if sliceEqual(c, p2) {
                return true
            }
            // do circular shift to right
            t := c[le-1]
            copy(c[1:], c[0:le-1])
            c[0] = t
        }
        // now process in opposite direction
        reverse(c)
    }
    return false
}
 
type edge [2]int
 
// Translates a face to perimeter format.
func faceToPerim(face []edge) []int {
    // use copy to avoid mutating 'face'
    le := len(face)
    if le == 0 {
        return nil
    }
    edges := make([]edge, le)
    for i := 0; i < le; i++ {
        // check edge pairs are in correct order
        if face[i][1] <= face[i][0] {
            return nil
        }
        edges[i] = face[i]
    }
    // sort edges in ascending order
    sort.Slice(edges, func(i, j int) bool {
        if edges[i][0] != edges[j][0] {
            return edges[i][0] < edges[j][0]
        }
        return edges[i][1] < edges[j][1]
    })
    var perim []int
    first, last := edges[0][0], edges[0][1]
    perim = append(perim, first, last)
    // remove first edge
    copy(edges, edges[1:])
    edges = edges[0 : le-1]
    le--
outer:
    for le > 0 {
        for i, e := range edges {
            found := false
            if e[0] == last {
                perim = append(perim, e[1])
                last, found = e[1], true
            } else if e[1] == last {
                perim = append(perim, e[0])
                last, found = e[0], true
            }
            if found {
                // remove i'th edge
                copy(edges[i:], edges[i+1:])
                edges = edges[0 : le-1]
                le--
                if last == first {
                    if le == 0 {
                        break outer
                    } else {
                        return nil
                    }
                }
                continue outer
            }
        }
    }
    return perim[0 : len(perim)-1]
}
 
func main() {
    fmt.Println(""Perimeter format equality checks:"")
    areEqual := perimEqual([]int{8, 1, 3}, []int{1, 3, 8})
    fmt.Printf(""  Q == R is %t\n"", areEqual)
    areEqual = perimEqual([]int{18, 8, 14, 10, 12, 17, 19}, []int{8, 14, 10, 12, 17, 19, 18})
    fmt.Printf(""  U == V is %t\n"", areEqual)
    e := []edge{{7, 11}, {1, 11}, {1, 7}}
    f := []edge{{11, 23}, {1, 17}, {17, 23}, {1, 11}}
    g := []edge{{8, 14}, {17, 19}, {10, 12}, {10, 14}, {12, 17}, {8, 18}, {18, 19}}
    h := []edge{{1, 3}, {9, 11}, {3, 11}, {1, 11}}
    fmt.Println(""\nEdge to perimeter format translations:"")
    for i, face := range [][]edge{e, f, g, h} {
        perim := faceToPerim(face)
        if perim == nil {
            fmt.Printf(""  %c => Invalid edge format\n"", i + 'E')
        } else {
            fmt.Printf(""  %c => %v\n"", i + 'E', perim)
        }
    }
}",3761,145
56492,http://rosettacode.org/wiki/Exponentiation_with_infix_operators_in_(or_operating_on)_the_base,Exponentiation with infix operators in (or operating on) the base,"(Many programming languages,   especially those with extended─precision integer arithmetic,   usually
support one of  **, ^, ↑  or some such for exponentiation.)



Some languages treat/honor infix operators when performing exponentiation   (raising
numbers to some power by the language's exponentiation operator,   if the computer
programming language has one).



Other programming languages may make use of the   POW   or some other BIF
  (Built─In Ffunction),   or some other library service.

If your language's exponentiation operator is not one of the usual ones, please comment on how to recognize it.



This task will deal with the case where there is some form of an   infix operator   operating
in   (or operating on)   the base.



Example

A negative five raised to the 3rd power could be specified as:

   -5  ** 3          or as
  -(5) ** 3          or as
  (-5) ** 3          or as something else


(Not all computer programming languages have an exponential operator and/or support these syntax expression(s).



Task

   compute and display exponentiation with a possible infix operator, whether specified and/or implied/inferred.
   Raise the following numbers   (integer or real):
   -5     and
   +5
   to the following powers:
   2nd     and
   3rd
   using the following expressions   (if applicable in your language):
   -x**p
   -(x)**p
   (-x)**p
   -(x**p)
   Show here (on this page) the four (or more) types of symbolic expressions for each number and power.


Try to present the results in the same format/manner as the other programming entries to make any differences apparent.



The variables may be of any type(s) that is/are applicable in your language.



Related tasks

   Exponentiation order
   Exponentiation operator
   Arbitrary-precision integers (included)
   Parsing/RPN to infix conversion
   Operator precedence


References

 Wikipedia: Order of operations in Programming languages

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
type float float64
 
func (f float) p(e float) float { return float(math.Pow(float64(f), float64(e))) }
 
func main() {
    ops := []string{""-x.p(e)"", ""-(x).p(e)"", ""(-x).p(e)"", ""-(x.p(e))""}
    for _, x := range []float{float(-5), float(5)} {
        for _, e := range []float{float(2), float(3)} {
            fmt.Printf(""x = %2.0f e = %0.0f | "", x, e)
            fmt.Printf(""%s = %4.0f | "", ops[0], -x.p(e))
            fmt.Printf(""%s = %4.0f | "", ops[1], -(x).p(e))
            fmt.Printf(""%s = %4.0f | "", ops[2], (-x).p(e))
            fmt.Printf(""%s = %4.0f\n"", ops[3], -(x.p(e)))
        }
    }
}",653,23
56519,http://rosettacode.org/wiki/Factorial_base_numbers_indexing_permutations_of_a_collection,Factorial base numbers indexing permutations of a collection,"You need a random arrangement of a deck of cards, you are sick of lame ways of doing this. This task is a super-cool way of doing this using factorial base numbers.
The first 25 factorial base numbers in increasing order are: 0.0.0, 0.0.1, 0.1.0, 0.1.1, 0.2.0, 0.2.1, 1.0.0, 1.0.1, 1.1.0, 1.1.1,1.2.0, 1.2.1, 2.0.0, 2.0.1, 2.1.0, 2.1.1, 2.2.0, 2.2.1, 3.0.0, 3.0.1, 3.1.0, 3.1.1, 3.2.0, 3.2.1, 1.0.0.0
Observe that the least significant digit is base 2 the next base 3, in general an n-digit factorial base number has digits n..1 in base n+1..2.

I want to produce a 1 to 1 mapping between these numbers and permutations:-

       0.0.0 -> 0123
       0.0.1 -> 0132
       0.1.0 -> 0213
       0.1.1 -> 0231
       0.2.0 -> 0312
       0.2.1 -> 0321
       1.0.0 -> 1023
       1.0.1 -> 1032
       1.1.0 -> 1203
       1.1.1 -> 1230
       1.2.0 -> 1302
       1.2.1 -> 1320
       2.0.0 -> 2013
       2.0.1 -> 2031
       2.1.0 -> 2103
       2.1.1 -> 2130
       2.2.0 -> 2301
       2.2.1 -> 2310
       3.0.0 -> 3012
       3.0.1 -> 3021
       3.1.0 -> 3102
       3.1.1 -> 3120
       3.2.0 -> 3201
       3.2.1 -> 3210

The following psudo-code will do this:
Starting with m=0 and Ω, an array of elements to be permutated, for each digit g starting with the most significant digit in the factorial base number.

If g is greater than zero, rotate the elements from m to m+g in Ω (see example)
Increment m and repeat the first step using the next most significant digit until the factorial base number is exhausted.
For example: using the factorial base number 2.0.1 and Ω = 0 1 2 3 where place 0 in both is the most significant (left-most) digit/element.

Step 1: m=0 g=2; Rotate places 0 through 2. 0 1 2 3 becomes 2 0 1 3
Step 2: m=1 g=0; No action.
Step 3: m=2 g=1; Rotate places 2 through 3. 2 0 1 3 becomes 2 0 3 1

Let me work 2.0.1 and 0123

    step 1 n=0 g=2 Ω=2013
    step 2 n=1 g=0 so no action
    step 3 n=2 g=1 Ω=2031

The task:

 First use your function to recreate the above table.
 Secondly use your function to generate all permutaions of 11 digits, perhaps count them don't display them, compare this method with
    methods in rc's permutations task.
 Thirdly here following are two ramdom 51 digit factorial base numbers I prepared earlier:
   39.49.7.47.29.30.2.12.10.3.29.37.33.17.12.31.29.34.17.25.2.4.25.4.1.14.20.6.21.18.1.1.1.4.0.5.15.12.4.3.10.10.9.1.6.5.5.3.0.0.0
   51.48.16.22.3.0.19.34.29.1.36.30.12.32.12.29.30.26.14.21.8.12.1.3.10.4.7.17.6.21.8.12.15.15.13.15.7.3.12.11.9.5.5.6.6.3.4.0.3.2.1
   use your function to crate the corresponding permutation of the following shoe of cards:
      A♠K♠Q♠J♠10♠9♠8♠7♠6♠5♠4♠3♠2♠A♥K♥Q♥J♥10♥9♥8♥7♥6♥5♥4♥3♥2♥A♦K♦Q♦J♦10♦9♦8♦7♦6♦5♦4♦3♦2♦A♣K♣Q♣J♣10♣9♣8♣7♣6♣5♣4♣3♣2♣
 Finally create your own 51 digit factorial base number and produce the corresponding permutation of the above shoe
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""strconv""
    ""strings""
    ""time""
)
 
func factorial(n int) int {
    fact := 1
    for i := 2; i <= n; i++ {
        fact *= i
    }
    return fact
}
 
func genFactBaseNums(size int, countOnly bool) ([][]int, int) {
    var results [][]int
    count := 0
    for n := 0; ; n++ {
        radix := 2
        var res []int = nil
        if !countOnly { 
            res = make([]int, size)
        }
        k := n
        for k > 0 {
            div := k / radix
            rem := k % radix
            if !countOnly {
                if radix <= size+1 {
                    res[size-radix+1] = rem
                }
            }
            k = div
            radix++
        }
        if radix > size+2 {
            break
        }
        count++
        if !countOnly {
            results = append(results, res)
        }
    }
    return results, count
}
 
func mapToPerms(factNums [][]int) [][]int {
    var perms [][]int
    psize := len(factNums[0]) + 1
    start := make([]int, psize)
    for i := 0; i < psize; i++ {
        start[i] = i
    }
    for _, fn := range factNums {
        perm := make([]int, psize)
        copy(perm, start)
        for m := 0; m < len(fn); m++ {
            g := fn[m]
            if g == 0 {
                continue
            }
            first := m
            last := m + g
            for i := 1; i <= g; i++ {
                temp := perm[first]
                for j := first + 1; j <= last; j++ {
                    perm[j-1] = perm[j]
                }
                perm[last] = temp
            }
        }
        perms = append(perms, perm)
    }
    return perms
}
 
func join(is []int, sep string) string {
    ss := make([]string, len(is))
    for i := 0; i < len(is); i++ {
        ss[i] = strconv.Itoa(is[i])
    }
    return strings.Join(ss, sep)
}
 
func undot(s string) []int {
    ss := strings.Split(s, ""."")
    is := make([]int, len(ss))
    for i := 0; i < len(ss); i++ {
        is[i], _ = strconv.Atoi(ss[i])
    }
    return is
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
 
    // Recreate the table.
    factNums, _ := genFactBaseNums(3, false)
    perms := mapToPerms(factNums)
    for i, fn := range factNums {
        fmt.Printf(""%v -> %v\n"", join(fn, "".""), join(perms[i], """"))
    }
 
    // Check that the number of perms generated is equal to 11! (this takes a while).
    _, count := genFactBaseNums(10, true)
    fmt.Println(""\nPermutations generated ="", count)
    fmt.Println(""compared to 11! which  ="", factorial(11))
    fmt.Println()
 
    // Generate shuffles for the 2 given 51 digit factorial base numbers.
    fbn51s := []string{
        ""39.49.7.47.29.30.2.12.10.3.29.37.33.17.12.31.29.34.17.25.2.4.25.4.1.14.20.6.21.18.1.1.1.4.0.5.15.12.4.3.10.10.9.1.6.5.5.3.0.0.0"",
        ""51.48.16.22.3.0.19.34.29.1.36.30.12.32.12.29.30.26.14.21.8.12.1.3.10.4.7.17.6.21.8.12.15.15.13.15.7.3.12.11.9.5.5.6.6.3.4.0.3.2.1"",
    }
    factNums = [][]int{undot(fbn51s[0]), undot(fbn51s[1])}
    perms = mapToPerms(factNums)
    shoe := []rune(""A♠K♠Q♠J♠T♠9♠8♠7♠6♠5♠4♠3♠2♠A♥K♥Q♥J♥T♥9♥8♥7♥6♥5♥4♥3♥2♥A♦K♦Q♦J♦T♦9♦8♦7♦6♦5♦4♦3♦2♦A♣K♣Q♣J♣T♣9♣8♣7♣6♣5♣4♣3♣2♣"")
    cards := make([]string, 52)
    for i := 0; i < 52; i++ {
        cards[i] = string(shoe[2*i : 2*i+2])
        if cards[i][0] == 'T' {
            cards[i] = ""10"" + cards[i][1:]
        }
    }
    for i, fbn51 := range fbn51s {
        fmt.Println(fbn51)
        for _, d := range perms[i] {
            fmt.Print(cards[d])
        }
        fmt.Println(""\n"")
    }
 
    // Create a random 51 digit factorial base number and produce a shuffle from that.
    fbn51 := make([]int, 51)
    for i := 0; i < 51; i++ {
        fbn51[i] = rand.Intn(52 - i)
    }
    fmt.Println(join(fbn51, "".""))
    perms = mapToPerms([][]int{fbn51})
    for _, d := range perms[0] {
        fmt.Print(cards[d])
    }
    fmt.Println()
}",3922,148
56601,http://rosettacode.org/wiki/Extreme_floating_point_values,Extreme floating point values,"The IEEE floating point specification defines certain 'extreme' floating point values such as minus zero, -0.0, a value distinct from plus zero; not a number, NaN; and plus and minus infinity.

The task is to use expressions involving other 'normal' floating point values in your language to calculate these, (and maybe other), extreme floating point values in your language and assign them to variables.

Print the values of these variables if possible; and show some arithmetic with these values and variables.

If your language can directly enter these extreme floating point values then show it.



See also

   What Every Computer Scientist Should Know About Floating-Point Arithmetic


Related tasks

   Infinity
   Detect division by zero
   Literals/Floating point

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func main() {
    // compute ""extreme values"" from non-extreme values
    var zero float64                         // zero is handy.
    var negZero, posInf, negInf, nan float64 // values to compute.
    negZero = zero * -1
    posInf = 1 / zero
    negInf = -1 / zero
    nan = zero / zero
 
    // print extreme values stored in variables
    fmt.Println(negZero, posInf, negInf, nan)
 
    // directly obtain extreme values
    fmt.Println(math.Float64frombits(1<<63),
        math.Inf(1), math.Inf(-1), math.NaN())
 
    // validate some arithmetic on extreme values
    fmt.Println()
    validateNaN(negInf+posInf, ""-Inf + Inf"")
    validateNaN(0*posInf, ""0 * Inf"")
    validateNaN(posInf/posInf, ""Inf / Inf"")
    // mod is specifically named in ""What every computer scientist...""
    // Go math package doc lists many special cases for other package functions.
    validateNaN(math.Mod(posInf, 1), ""Inf % 1"")
    validateNaN(1+nan, ""1 + NaN"")
    validateZero(1/posInf, ""1 / Inf"")
    validateGT(posInf, math.MaxFloat64, ""Inf > max value"")
    validateGT(-math.MaxFloat64, negInf, ""-Inf < max neg value"")
    validateNE(nan, nan, ""NaN != NaN"")
    validateEQ(negZero, 0, ""-0 == 0"")
}
 
func validateNaN(n float64, op string) {
    if math.IsNaN(n) {
        fmt.Println(op, ""-> NaN"")
    } else {
        fmt.Println(""!!! Expected NaN from"", op, ""  Found"", n)
    }
}
 
func validateZero(n float64, op string) {
    if n == 0 {
        fmt.Println(op, ""-> 0"")
    } else {
        fmt.Println(""!!! Expected 0 from"", op, ""  Found"", n)
    }
}
 
func validateGT(a, b float64, op string) {
    if a > b {
        fmt.Println(op)
    } else {
        fmt.Println(""!!! Expected"", op, ""  Found not true."")
    }
}
 
func validateNE(a, b float64, op string) {
    if a == b {
        fmt.Println(""!!! Expected"", op, ""  Found not true."")
    } else {
        fmt.Println(op)
    }
}
 
func validateEQ(a, b float64, op string) {
    if a == b {
        fmt.Println(op)
    } else {
        fmt.Println(""!!! Expected"", op, ""  Found not true."")
    }
}",2096,78
56605,http://rosettacode.org/wiki/Factorions,Factorions,"

Definition

A factorion is a natural number that equals the sum of the factorials of its digits.



Example
 
145   is a factorion in base 10 because:


          1! + 4! + 5!   =   1 + 24 + 120   =   145 





It can be shown (see talk page) that no factorion in base 10 can exceed   1,499,999.



Task

Write a program in your language to demonstrate, by calculating and printing out the factorions, that:

   There are   3   factorions in base   9
   There are   4   factorions in base 10
   There are   5   factorions in base 11 
   There are   2   factorions in base 12     (up to the same upper bound as for base 10)


See also

 Wikipedia article
 OEIS:A014080 - Factorions in base 10
 OEIS:A193163 - Factorions in base n

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
func main() {
    // cache factorials from 0 to 11
    var fact [12]uint64
    fact[0] = 1
    for n := uint64(1); n < 12; n++ {
        fact[n] = fact[n-1] * n
    }
 
    for b := 9; b <= 12; b++ {
        fmt.Printf(""The factorions for base %d are:\n"", b)
        for i := uint64(1); i < 1500000; i++ {
            digits := strconv.FormatUint(i, b)
            sum := uint64(0)
            for _, digit := range digits {
                if digit < 'a' {
                    sum += fact[digit-'0']
                } else {
                    sum += fact[digit+10-'a']
                }
            }
            if sum == i {
                fmt.Printf(""%d "", i)
            }
        }
        fmt.Println(""\n"")
    }
}",776,34
56746,http://rosettacode.org/wiki/Exponentiation_order,Exponentiation order,"This task will demonstrate the order of exponentiation   (xy)    when there are multiple exponents.

(Many programming languages,   especially those with extended─precision integer arithmetic,   usually support one of  **, ^, ↑  or some such for exponentiation.)



Task requirements
Show the result of a language's evaluation of multiple exponentiation (either as an integer or floating point).

If your language's exponentiation operator is not one of the usual ones, please comment on how to recognize it.



Using whatever operator or syntax your language supports (if any), show the results in three lines (with identification):


   5**3**2 
   (5**3)**2
   5**(3**2)




If there are other methods (or formats) of multiple exponentiations, show them as well.



See also

 MathWorld entry:   exponentiation


Related tasks

   exponentiation operator
   arbitrary-precision integers (included)
   Exponentiation with infix operators in (or operating on) the base

",#Go,Go,"package main
 
import ""fmt""
import ""math""
 
func main() {
    var a, b, c float64
    a = math.Pow(5, math.Pow(3, 2))
    b = math.Pow(math.Pow(5, 3), 2)
    c = math.Pow(5, math.Pow(3, 2))
    fmt.Printf(""5^3^2   = %.0f\n"", a)
    fmt.Printf(""(5^3)^2 = %.0f\n"", b)
    fmt.Printf(""5^(3^2) = %.0f\n"", c)
}",305,14
56798,http://rosettacode.org/wiki/Fibonacci_sequence,Fibonacci sequence,"The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:

      F0 = 0 
      F1 = 1 
      Fn = Fn-1 + Fn-2, if n>1 



Task

Write a function to generate the    nth    Fibonacci number.

Solutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).

The sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:

      Fn = Fn+2 - Fn+1, if n<0   

support for negative      n      in the solution is optional.



Related tasks

   Fibonacci n-step number sequences‎
   Leonardo numbers


References

   Wikipedia, Fibonacci number
   Wikipedia, Lucas number
   MathWorld, Fibonacci Number
   Some identities for r-Fibonacci numbers
   OEIS Fibonacci numbers
   OEIS Lucas numbers

",#Go,Go,"func fib(a int) int {
  if a < 2 {
    return a
  }
  return fib(a - 1) + fib(a - 2)
}",86,6
56805,http://rosettacode.org/wiki/Execute_SNUSP,Execute SNUSP,"Execute SNUSP is an implementation of SNUSP.
Other implementations of SNUSP.
RCSNUSP
SNUSP
An implementation need only properly implement the Core SNUSP instructions ('$', '\', '/', '+', '-', '<', '>', ',', '.', '!', and '?'). Modular SNUSP ('#', '@') and Bloated SNUSP (':', ';', '%', and '&') are also allowed, but not required. Any extra characters that you implement should be noted in the description of your implementation. Any cell size is allowed, EOF support is optional, as is whether you have bounded or unbounded memory.
",#Go,Go,"#
# snusp.icn, A Modular SNUSP interpreter
#
 
$define VERSION 0.6
 
# allow a couple of cli options
link options
 
# directions
$define DRIGHT 1
$define DLEFT  2
$define DUP    3
$define DDOWN  4
 
record position(row, col)
global dir, ip, ram
 
procedure main(argv)
   local ch, codespace, col, dp, fn, line
   local row := 1
   local wid := 0
   local dirs := []
   local ips := []
   local opts, verbose, debug
 
   opts := options(argv, ""-h! -v! -d!"", errorproc)
   \opts[""v""] & verbose := 1
   \opts[""h""] & show_help(verbose)
   \opts[""d""] & debug := 1
 
   ip := position(1,1)
 
   # initial direction
   dir := DRIGHT 
 
   # prepare initial memory
   ram := list(1, 0)
 
   # prepare code field
   codespace := []
 
   fn := open(argv[1], ""r"") | &input
   if (fn === &input) & \opts[""h""] then return
 
   while line := read(fn) do {
      put(codespace, line)
      wid := max(*line, wid)
   }
   if *codespace = 0 then return
   every line := !codespace do {
      codespace[row] := left(codespace[row], wid)
      # track starting indicator
      if /col := find(""$"", codespace[row]) then {
         ip.row := row
         ip.col := col
      }
      row +:= 1
   }
 
   if \verbose then {
      write(""Starting at "", ip.row, "", "", ip.col, "" with codespace:"")
      every write(!codespace)
   }
 
   dp := 1
   repeat {
      if not (ch := codespace[ip.row][ip.col]) then break 
      if \debug then {
         write(&errout, ""dir: "", dir, "" ch: "", ch, "" ["", ord(ch), ""]"",
                        "" row: "", ip.row, "" col: "", ip.col,
                        "" dp: "", dp, "" ram[dp]: "", ram[dp])
      }
      case ch of {
         # six of the bf instructions
         ""+"": ram[dp] +:= 1
         ""-"": ram[dp] -:= 1
         "">"": resize(dp +:= 1)
         ""<"": dp -:= 1
         ""."": writes(char(ram[dp]) | char(0))
         "","": ram[dp] := getche()
         # direction change, LURD, RULD, SKIP, SKIPZ
         ""\\"": { # LURD
            case dir of {
               DRIGHT: dir := DDOWN
               DLEFT:  dir := DUP
               DUP:    dir := DLEFT
               DDOWN:  dir := DRIGHT
            }
         } 
         ""/"": { # RULD
            case dir of {
               DRIGHT: dir := DUP
               DLEFT:  dir := DDOWN
               DUP:    dir := DRIGHT
               DDOWN:  dir := DLEFT
            }
         }
         ""!"": step()
         ""?"": { # skipz
            if ram[dp] = 0 then {
               step()
            }
         }
         # modular SNUSP
         ""@"": { # Enter
            push(dirs, dir)
            push(ips, copy(ip))
         }
         ""#"": { # Leave
            if *dirs < 1 then break
            dir := pop(dirs)
            ip := pop(ips)
            step()
         }
      }
      step()
   }
end
 
# advance the ip depending on direction
procedure step()
   case dir of {
      DRIGHT: ip.col +:= 1
      DLEFT:  ip.col -:= 1
      DUP:    ip.row -:= 1
      DDOWN:  ip.row +:= 1
   }
end
 
# enlarge memory when needed
procedure resize(elements)
   until *ram >= elements do put(ram, 0)
end 
 
# quick help or verbose help
procedure show_help(verbose)
   write(""SNUSP interpeter in Unicon, version "", VERSION)
   write(""CORE and MODULAR, not yet BLOATED"")
   write()
   write(""Usage: unicon snusp.icn -x [filename] [-h|-v|-d]"")
   write("" -h, help"")
   write("" -v, verbose (and verbose help"")
   write("" -d, debug (step tracer)"")
   if \verbose then {
      write()
      write(""Instructions:"")
      write("" + INCR,  Increment current memory location"")
      write("" - DECR,  Decrement current memory location"")
      write("" > RIGHT, Advance memory pointer"")
      write("" < LEFT,  Retreat memory pointer"")
      write("" . WRITE, Output contents of current memory cell, in ASCII"")
      write("" , READ,  Accept key and place byte value in current memory cell"")
      write("" \\ LURD, If going:"")
      write(""           left,  go up"")
      write(""           up,    go left"")
      write(""           right, go down"")
      write(""           down,  go right"")
      write("" / RULD, If going:"")
      write(""           right, go up"")
      write(""           up,    go right"")
      write(""           left,  go down"")
      write(""           down,  go left"")
      write("" !, SKIP,  Move forward one step in current direction"")
      write("" ?, SKIPZ, If current memory cell is zero then SKIP"")
      write(""Modular SNUSP adds:"")
      write("" @, ENTER, Push direction and instruction pointer"")
      write("" #, LEAVE, Pop direction and instruction pointer and SKIP"")
      write()
      write(""All other characters are NOOP, explicitly includes =,|,spc"")
      write("" $, can set the starting location; first one found"")
      write()
      write(""Hello world examples:"")
      write()
      write(""CORE SNUSP:"")
      write(""/++++!/===========?\\>++.>+.+++++++..+++\\"")
      write(""\\+++\\ | /+>+++++++>/ /++++++++++<<.++>./"")
      write(""$+++/ | \\+++++++++>\\ \\+++++.>.+++.-----\\"")
      write(""      \\==-<<<<+>+++/ /=.>.+>.--------.-/"")
      write()
      write(""Modular SNUSP:"")
      write(""      /@@@@++++#               #+++@@\                #-----@@@\\n"")
      write(""$@\\H.@/e.+++++++l.l.+++o.>>++++.< .<@/w.@\\o.+++r.++@\\l.@\\d.>+.@/.#"")
      write(""  \\@@@@=>++++>+++++<<@+++++#       #---@@/!=========/!==/"")
      write()
   }
end",5329,187
56866,http://rosettacode.org/wiki/Extensible_prime_generator,Extensible prime generator,"Task

Write a generator of prime numbers, in order, that will automatically adjust to accommodate the generation of any reasonably high prime.

The routine should demonstrably rely on either:

 Being based on an open-ended counter set to count without upper limit other than system or programming language limits. In this case, explain where this counter is in the code.
 Being based on a limit that is extended automatically. In this case, choose a small limit that ensures the limit will be passed when generating some of the values to be asked for below.
 If other methods of creating an extensible prime generator are used, the algorithm's means of extensibility/lack of limits should be stated.


The routine should be used to:

 Show the first twenty primes.
 Show the primes between 100 and 150.
 Show the number of primes between 7,700 and 8,000.
 Show the 10,000th prime.


Show output on this page.

Note: You may reference code already on this site if it is written to be imported/included, then only the code necessary for import and the performance of this task need be shown. (It is also important to leave a forward link on the referenced tasks entry so that later editors know that the code is used for multiple tasks).

Note 2: If a languages in-built prime generator is extensible or is guaranteed to generate primes up to a system limit, (231 or memory overflow for example), then this may be used as long as an explanation of the limits of the prime generator is also given. (Which may include a link to/excerpt from, language documentation).

Note 3:The task is written so it may be useful in solving the task   Emirp primes   as well as others (depending on its efficiency).





Reference

 Prime Numbers. Website with large count of primes.

",#Go,Go,"package main
 
import (
    ""container/heap""
    ""fmt""
)
 
func main() {
    p := newP()
    fmt.Print(""First twenty: "")
    for i := 0; i < 20; i++ {
        fmt.Print(p(), "" "")
    }
    fmt.Print(""\nBetween 100 and 150: "")
    n := p()
    for n <= 100 {
        n = p()
    }
    for ; n < 150; n = p() {
        fmt.Print(n, "" "")
    }
    for n <= 7700 {
        n = p()
    }
    c := 0
    for ; n < 8000; n = p() {
        c++
    }
    fmt.Println(""\nNumber beween 7,700 and 8,000:"", c)
    p = newP()
    for i := 1; i < 10000; i++ {
        p()
    }
    fmt.Println(""10,000th prime:"", p())
}
 
func newP() func() int {
    n := 1
    var pq pQueue
    top := &pMult{2, 4, 0}
    return func() int {
        for {
            n++
            if n < top.pMult { // n is a new prime
                heap.Push(&pq, &pMult{prime: n, pMult: n * n})
                top = pq[0]
                return n
            }
            // n was next on the queue, it's a composite
            for top.pMult == n {
                top.pMult += top.prime
                heap.Fix(&pq, 0)
                top = pq[0]
            }
        }
    }
}
 
type pMult struct {
    prime int
    pMult int
    index int
}
 
type pQueue []*pMult
 
func (q pQueue) Len() int           { return len(q) }
func (q pQueue) Less(i, j int) bool { return q[i].pMult < q[j].pMult }
func (q pQueue) Swap(i, j int) {
    q[i], q[j] = q[j], q[i]
    q[i].index = i
    q[j].index = j
}
func (p *pQueue) Push(x interface{}) {
    q := *p
    e := x.(*pMult)
    e.index = len(q)
    *p = append(q, e)
}
func (p *pQueue) Pop() interface{} {
    q := *p
    last := len(q) - 1
    e := q[last]
    *p = q[:last]
    return e
}",1699,86
56898,http://rosettacode.org/wiki/Executable_library,Executable library,"The general idea behind an executable library is to create a library
that when used as a library does one thing;
but has the ability to be run directly via command line.
Thus the API comes with a CLI in the very same source code file.

Task detail

 Create a library/module/dll/shared object/... for a programming language that contains a function/method called hailstone that is a function taking a positive integer and returns the Hailstone sequence for that number.
 The library, when executed directly should satisfy the remaining requirements of the Hailstone sequence task:
 2. Use the routine to show that the hailstone sequence for the number 27 has 112 elements starting with 27, 82, 41, 124 and ending with 8, 4, 2, 1
 3. Show the number less than 100,000 which has the longest hailstone sequence together with that sequence's length.
 Create a second executable to calculate the following:
 Use the library's hailstone function, in the standard manner, (or document how this use deviates from standard use of a library), together with extra code in this executable, to find the hailstone length returned most often for 1 ≤ n < 100,000.
 Explain any extra setup/run steps needed to complete the task.
Notes:

 It is assumed that for a language that overwhelmingly ships in a compiled form, such as C, the library must also be an executable and the compiled user of that library is to do so without changing the compiled library. I.e. the compile tool-chain is assumed not to be present in the runtime environment.
 Interpreters are present in the runtime environment.",#Go,Go,"// modulino.go
package main
 
import ""fmt""
 
// Function borrowed from Hailstone sequence task.
// 1st arg is the number to generate the sequence for.
// 2nd arg is a slice to recycle, to reduce garbage.
func hailstone(n int, recycle []int) []int {
    s := append(recycle[:0], n)
    for n > 1 {
        if n&1 == 0 {
            n = n / 2
        } else {
            n = 3*n + 1
        }
        s = append(s, n)
    }
    return s
}
 
func libMain() {
    seq := hailstone(27, nil)
    fmt.Println(""\nHailstone sequence for the number 27:"")
    fmt.Println(""  has"", len(seq), ""elements"")
    fmt.Println(""  starts with"", seq[0:4])
    fmt.Println(""  ends with"", seq[len(seq)-4:])
 
    var longest, length int
    for i := 1; i < 100000; i++ {
        if le := len(hailstone(i, nil)); le > length {
            longest = i
            length = le
        }
    }
    fmt.Printf(""\n%d has the longest Hailstone sequence, its length being %d.\n"", longest, length)
}",968,37
56904,http://rosettacode.org/wiki/Extend_your_language,Extend your language,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops

Some programming languages allow you to extend the language. While this can be done to a certain degree in most languages (e.g. by using macros), other languages go much further. Most notably in the Forth and Lisp families, programming per se is done by extending the language without any formal distinction between built-in and user-defined elements.

If your language supports it, show how to introduce a new flow control mechanism. A practical and useful example is a four-way branch:

Occasionally, code must be written that depends on two conditions, resulting in up to four branches (depending on whether both, only the first, only the second, or none of the conditions are ""true""). In a C-like language this could look like the following:

  if (condition1isTrue) {
     if (condition2isTrue)
        bothConditionsAreTrue();
     else
        firstConditionIsTrue();
  }
  else if (condition2isTrue)
     secondConditionIsTrue();
  else
     noConditionIsTrue();

Besides being rather cluttered, the statement(s) for 'condition2isTrue' must be written down twice. If 'condition2isTrue' were a lengthy and involved expression, it would be quite unreadable, and the code generated by the compiler might be unnecessarily large.

This can be improved by introducing a new keyword if2. It is similar to if, but takes two conditional statements instead of one, and up to three 'else' statements. One proposal (in pseudo-C syntax) might be:

  if2 (condition1isTrue) (condition2isTrue)
     bothConditionsAreTrue();
  else1
     firstConditionIsTrue();
  else2
     secondConditionIsTrue();
  else
     noConditionIsTrue();

Pick the syntax which suits your language. The keywords 'else1' and 'else2' are just examples. The new conditional expression should look, nest and behave analogously to the language's built-in 'if' statement.
",#Go,Go,"package main
 
import ""fmt""
 
type F func()
 
type If2 struct {cond1, cond2 bool}
 
func (i If2) else1(f F) If2 {
    if i.cond1 && !i.cond2 {
        f()
    }
    return i
}
 
func (i If2) else2(f F) If2 {
    if i.cond2 && !i.cond1 {
        f()
    }
    return i
}
 
func (i If2) else0(f F) If2 {
    if !i.cond1 && !i.cond2 {
        f()
    }
    return i
}
 
func if2(cond1, cond2 bool, f F) If2 {
    if cond1 && cond2 {
        f()
    }
    return If2{cond1, cond2}
}
 
func main() {
    a, b := 0, 1
    if2 (a == 1, b == 3, func() {
        fmt.Println(""a = 1 and b = 3"")
    }).else1 (func() {
        fmt.Println(""a = 1 and b <> 3"")
    }).else2 (func() {
        fmt.Println(""a <> 1 and b = 3"")
    }).else0 (func() {
        fmt.Println(""a <> 1 and b <> 3"")
    })
 
    // It's also possible to omit any (or all) of the 'else' clauses or to call them out of order
    a, b = 1, 0
    if2 (a == 1, b == 3, func() {
        fmt.Println(""a = 1 and b = 3"")
    }).else0 (func() {
        fmt.Println(""a <> 1 and b <> 3"")
    }).else1 (func() {
        fmt.Println(""a = 1 and b <> 3"")
    })
}",1106,58
57105,http://rosettacode.org/wiki/Execute_HQ9%2B,Execute HQ9+,"Task

Implement a    HQ9+    interpreter or compiler.



",#Go,Go,"module hq9plus
 
function main = |args| {
  var accumulator = 0
  let source = readln(""please enter your source code: "")
  foreach ch in source: chars() {
    case {
      when ch == 'h' or ch == 'H' {
        println(""Hello, world!"")
      }
      when ch == 'q' or ch == 'Q' {
        println(source)
      }
      when ch == '9' {
        ninety9Bottles()
      }
      when ch == '+' {
        accumulator = accumulator + 1
      }
      otherwise {
        println(""syntax error"")
      }
    }
  }
}
 
function bottles = |amount| -> match {
  when amount == 1 then ""One bottle""
  when amount == 0 then ""No bottles""
  otherwise amount + "" bottles""
}
 
function ninety9Bottles = {
  foreach n in [99..0]: decrementBy(1) {
    println(bottles(n) + "" of beer on the wall,"")
    println(bottles(n) + "" of beer!"")
    println(""Take one down, pass it around,"")
    println(bottles(n - 1) + "" of beer on the wall!"")
  }
}
 ",921,41
57161,http://rosettacode.org/wiki/Exponentiation_operator,Exponentiation operator,"Most programming languages have a built-in implementation of exponentiation.



Task

Re-implement integer exponentiation for both   intint   and   floatint   as both a procedure,   and an operator (if your language supports operator definition).

If the language supports operator (or procedure) overloading, then an overloaded form should be provided for both   intint   and   floatint   variants.



Related tasks

   Exponentiation order
   arbitrary-precision integers (included)
   Exponentiation with infix operators in (or operating on) the base

",#Go,Go,"package main
 
import (
    ""errors""
    ""fmt""
)
 
func expI(b, p int) (int, error) {
    if p < 0 {
        return 0, errors.New(""negative power not allowed"")
    }
    r := 1
    for i := 1; i <= p; i++ {
        r *= b
    }
    return r, nil
}
 
func expF(b float32, p int) float32 {
    var neg bool
    if p < 0 {
        neg = true
        p = -p
    }
    r := float32(1)
    for pow := b; p > 0; pow *= pow {
        if p&1 == 1 {
            r *= pow
        }
        p >>= 1
    }
    if neg {
        r = 1 / r
    }
    return r
}
 
func main() {
    ti := func(b, p int) {
        fmt.Printf(""%d^%d: "", b, p)
        e, err := expI(b, p)
        if err != nil {
            fmt.Println(err)
        } else {
            fmt.Println(e)
        }
    }
 
    fmt.Println(""expI tests"")
    ti(2, 10)
    ti(2, -10)
    ti(-2, 10)
    ti(-2, 11)
    ti(11, 0)
 
    fmt.Println(""overflow undetected"")
    ti(10, 10)
 
    tf := func(b float32, p int) {
        fmt.Printf(""%g^%d: %g\n"", b, p, expF(b, p))
    }
 
    fmt.Println(""\nexpF tests:"")
    tf(2, 10)
    tf(2, -10)
    tf(-2, 10)
    tf(-2, 11)
    tf(11, 0)
 
    fmt.Println(""disallowed in expI, allowed here"")
    tf(0, -1)
 
    fmt.Println(""other interesting cases for 32 bit float type"")
    tf(10, 39)
    tf(10, -39)
    tf(-10, 39)
}",1313,77
57195,http://rosettacode.org/wiki/Execute_a_Markov_algorithm,Execute a Markov algorithm,"Execute a Markov algorithm

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Create an interpreter for a Markov Algorithm.

Rules have the syntax:

<ruleset> ::= ((<comment> | <rule>) <newline>+)*
<comment> ::= # {<any character>}
<rule> ::= <pattern> <whitespace> -> <whitespace> [.] <replacement>
<whitespace> ::= (<tab> | <space>) [<whitespace>]

There is one rule per line.

If there is a   .   (period)   present before the   <replacement>,   then this is a terminating rule in which case the interpreter must halt execution.

A ruleset consists of a sequence of rules, with optional comments.


 Rulesets 

Use the following tests on entries:



Ruleset 1

# This rules file is extracted from Wikipedia:
# http://en.wikipedia.org/wiki/Markov_Algorithm
A -> apple
B -> bag
S -> shop
T -> the
the shop -> my brother
a never used -> .terminating rule

Sample text of:

  I bought a B of As from T S. 
Should generate the output:

  I bought a bag of apples from my brother. 


Ruleset 2

A test of the terminating rule

# Slightly modified from the rules on Wikipedia
A -> apple
B -> bag
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule
Sample text of:

 I bought a B of As from T S.
Should generate:

 I bought a bag of apples from T shop.


Ruleset 3

This tests for correct substitution order and may trap simple regexp based replacement routines if special regexp characters are not escaped.

# BNF Syntax testing rules
A -> apple
WWWW -> with
Bgage -> ->.*
B -> bag
->.* -> money
W -> WW
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule

Sample text of:

 I bought a B of As W my Bgage from T S.
Should generate:

 I bought a bag of apples with my money from T shop.


Ruleset 4

This tests for correct order of scanning of rules, and may trap replacement routines that scan in the wrong order.   It implements a general unary multiplication engine.   (Note that the input expression must be placed within underscores in this implementation.)

### Unary Multiplication Engine, for testing Markov Algorithm implementations
### By Donal Fellows.
# Unary addition engine
_+1 -> _1+
1+1 -> 11+
# Pass for converting from the splitting of multiplication into ordinary
# addition
1! -> !1
,! -> !+
_! -> _
# Unary multiplication by duplicating left side, right side times
1*1 -> x,@y
1x -> xX
X, -> 1,1
X1 -> 1X
_x -> _X
,x -> ,X
y1 -> 1y
y_ -> _
# Next phase of applying
1@1 -> x,@y
1@_ -> @_
,@_ -> !_
++ -> +
# Termination cleanup for addition
_1 -> 1
1+_ -> 1
_+_ -> 

Sample text of:

  _1111*11111_ 
should generate the output:

  11111111111111111111 


Ruleset 5

A simple Turing machine,
implementing a three-state busy beaver.

The tape consists of 0s and 1s,   the states are A, B, C and H (for Halt), and the head position is indicated by writing the state letter before the character where the head is.
All parts of the initial tape the machine operates on have to be given in the input.

Besides demonstrating that the Markov algorithm is Turing-complete, it also made me catch a bug in the C++ implementation which wasn't caught by the first four rulesets.

# Turing machine: three-state busy beaver
#
# state A, symbol 0 => write 1, move right, new state B
A0 -> 1B
# state A, symbol 1 => write 1, move left, new state C
0A1 -> C01
1A1 -> C11
# state B, symbol 0 => write 1, move left, new state A
0B0 -> A01
1B0 -> A11
# state B, symbol 1 => write 1, move right, new state B
B1 -> 1B
# state C, symbol 0 => write 1, move left, new state B
0C0 -> B01
1C0 -> B11
# state C, symbol 1 => write 1, move left, halt
0C1 -> H01
1C1 -> H11

This ruleset should turn

  000000A000000 
into

  00011H1111000 

",#Go,Go,"package main
 
import (
    ""fmt""
    ""regexp""
    ""strings""
)
 
type testCase struct {
    ruleSet, sample, output string
}
 
func main() {
    fmt.Println(""validating"", len(testSet), ""test cases"")
    var failures bool
    for i, tc := range testSet {
        if r, ok := interpret(tc.ruleSet, tc.sample); !ok {
            fmt.Println(""test"", i+1, ""invalid ruleset"")
            failures = true
        } else if r != tc.output {
            fmt.Printf(""test %d: got %q, want %q\n"", i+1, r, tc.output)
            failures = true
        }
    }
    if !failures {
        fmt.Println(""no failures"")
    }
}
 
func interpret(ruleset, input string) (string, bool) {
    if rules, ok := parse(ruleset); ok {
        return run(rules, input), true
    }
    return """", false
}
 
type rule struct {
    pat  string
    rep  string
    term bool
}
 
var (
    rxSet   = regexp.MustCompile(ruleSet)
    rxEle   = regexp.MustCompile(ruleEle)
    ruleSet = `(?m:^(?:` + ruleEle + `)*$)`
    ruleEle = `(?:` + comment + `|` + ruleRe + `)\n+`
    comment = `#.*`
    ruleRe  = `(.*)` + ws + `->` + ws + `([.])?(.*)`
    ws      = `[\t ]+`
)
 
func parse(rs string) ([]rule, bool) {
    if !rxSet.MatchString(rs) {
        return nil, false
    }
    x := rxEle.FindAllStringSubmatchIndex(rs, -1)
    var rules []rule
    for _, x := range x {
        if x[2] > 0 {
            rules = append(rules,
                rule{pat: rs[x[2]:x[3]], term: x[4] > 0, rep: rs[x[6]:x[7]]})
        }
    }
    return rules, true
}
 
func run(rules []rule, s string) string {
step1:
    for _, r := range rules {
        if f := strings.Index(s, r.pat); f >= 0 {
            s = s[:f] + r.rep + s[f+len(r.pat):]
            if r.term {
                return s
            }
            goto step1
        }
    }
    return s
}
 
// text all cut and paste from RC task page
var testSet = []testCase{
    {`# This rules file is extracted from Wikipedia:
# http://en.wikipedia.org/wiki/Markov_Algorithm
A -> apple
B -> bag
S -> shop
T -> the
the shop -> my brother
a never used -> .terminating rule
`,
        `I bought a B of As from T S.`,
        `I bought a bag of apples from my brother.`,
    },
    {`# Slightly modified from the rules on Wikipedia
A -> apple
B -> bag
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule
`,
        `I bought a B of As from T S.`,
        `I bought a bag of apples from T shop.`,
    },
    {`# BNF Syntax testing rules
A -> apple
WWWW -> with
Bgage -> ->.*
B -> bag
->.* -> money
W -> WW
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule
`,
        `I bought a B of As W my Bgage from T S.`,
        `I bought a bag of apples with my money from T shop.`,
    },
    {`### Unary Multiplication Engine, for testing Markov Algorithm implementations
### By Donal Fellows.
# Unary addition engine
_+1 -> _1+
1+1 -> 11+
# Pass for converting from the splitting of multiplication into ordinary
# addition
1! -> !1
,! -> !+
_! -> _
# Unary multiplication by duplicating left side, right side times
1*1 -> x,@y
1x -> xX
X, -> 1,1
X1 -> 1X
_x -> _X
,x -> ,X
y1 -> 1y
y_ -> _
# Next phase of applying
1@1 -> x,@y
1@_ -> @_
,@_ -> !_
++ -> +
# Termination cleanup for addition
_1 -> 1
1+_ -> 1
_+_ -> 
`,
        `_1111*11111_`,
        `11111111111111111111`,
    },
    {`# Turing machine: three-state busy beaver
#
# state A, symbol 0 => write 1, move right, new state B
A0 -> 1B
# state A, symbol 1 => write 1, move left, new state C
0A1 -> C01
1A1 -> C11
# state B, symbol 0 => write 1, move left, new state A
0B0 -> A01
1B0 -> A11
# state B, symbol 1 => write 1, move right, new state B
B1 -> 1B
# state C, symbol 0 => write 1, move left, new state B
0C0 -> B01
1C0 -> B11
# state C, symbol 1 => write 1, move left, halt
0C1 -> H01
1C1 -> H11
`,
        `000000A000000`,
        `00011H1111000`,
    },
}",3869,176
57196,http://rosettacode.org/wiki/Exceptions/Catch_an_exception_thrown_in_a_nested_call,Exceptions/Catch an exception thrown in a nested call,"Show how to create a user-defined exception   and   show how to catch an exception raised from several nested calls away.

   Create two user-defined exceptions,   U0   and   U1. 
   Have function   foo   call function   bar   twice.
   Have function   bar   call function   baz. 
   Arrange for function   baz   to raise, or throw exception   U0   on its first call, then exception   U1   on its second.
   Function   foo   should catch only exception   U0,   not   U1.


Show/describe what happens when the program is run.



",#Go,Go,"// Outline for a try/catch-like exception mechanism in Go
//
// As all Go programmers should know, the Go authors are sharply critical of
// the try/catch idiom and consider it bad practice in general.
// See http://golang.org/doc/go_faq.html#exceptions
 
package main
 
import (
    ""fmt""
    ""runtime""
    ""strings""
)
 
// trace is for pretty output for the Rosetta Code task.
// It would have no place in a practical program.
func trace(s string) {
    nc := runtime.Callers(2, cs)
    f := runtime.FuncForPC(cs[0])
    fmt.Print(strings.Repeat(""  "", nc-3), f.Name()[5:], "": "", s, ""\n"")
}
 
var cs = make([]uintptr, 10)
 
type exception struct {
    name    string
    handler func()
}
 
// try implents the try/catch-like exception mechanism.  It takes a function
// to be called, and a list of exceptions to catch during the function call.
// Note that for this simple example, f has no parameters.  In a practical
// program it might, of course.  In this case, the signature of try would
// have to be modified to take these parameters and then supply them to f
// when it calls f.
func try(f func(), exs []exception) {
    trace(""start"")
    defer func() {
        if pv := recover(); pv != nil {
            trace(""Panic mode!"")
            if px, ok := pv.(exception); ok {
                for _, ex := range exs {
                    if ex.name == px.name {
                        trace(""handling exception"")
                        px.handler()
                        trace(""panic over"")
                        return
                    }
                }
            }
            trace(""can't recover this one!"")
            panic(pv)
        }
    }()
    f()
    trace(""complete"")
}
 
func main() {
    trace(""start"")
    foo()
    trace(""complete"")
}
 
// u0, u1 declared at package level so they can be accessed by any function.
var u0, u1 exception
 
// foo.  Note that function literals u0, u1 here in the lexical scope
// of foo serve the purpose of catch blocks of other languages.
// Passing u0 to try serves the purpose of the catch condition.
// While try(bar... reads much like the try statement of other languages,
// this try is an ordinary function.  foo is passing bar into try,
// not calling it directly.
func foo() {
    trace(""start"")
    u0 = exception{""U0"", func() { trace(""U0 handled"") }}
    u1 = exception{""U1"", func() { trace(""U1 handled"") }}
    try(bar, []exception{u0})
    try(bar, []exception{u0})
    trace(""complete"")
}
 
func bar() {
    trace(""start"")
    baz()
    trace(""complete"")
}
 
var bazCall int
 
func baz() {
    trace(""start"")
    bazCall++
    switch bazCall {
    case 1:
        trace(""panicking with execption U0"")
        panic(u0)
    case 2:
        trace(""panicking with execption U1"")
        panic(u1)
    }
    trace(""complete"")
}",2805,103
57316,http://rosettacode.org/wiki/Exceptions,Exceptions,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops

This task is to give an example of an exception handling routine
and to ""throw"" a new exception.



Related task

   Exceptions Through Nested Calls

",#Go,Go,"package main
 
import ""fmt""
 
func foo() int {
	fmt.Println(""let's foo..."")
	defer func() {
		if e := recover(); e != nil {
			fmt.Println(""Recovered from"", e)
		}
	}()
	var a []int
	a[12] = 0
	fmt.Println(""there's no point in going on."")
	panic(""never reached"")
	panic(fmt.Scan) // Can use any value, here a function!
}
 
func main() {
	foo()
	fmt.Println(""glad that's over."")
}",379,22
57440,http://rosettacode.org/wiki/Execute_a_system_command,Execute a system command,"Task

Run either the   ls   system command   (dir   on Windows),   or the   pause   system command.




Related task
  Get system command output

",#Go,Go,"package main
 
import (
    ""log""
    ""os""
    ""os/exec""
)
 
func main() {
    cmd := exec.Command(""ls"", ""-l"")
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    if err := cmd.Run(); err != nil {
        log.Fatal(err)
    }
}",233,16
57724,http://rosettacode.org/wiki/Evolutionary_algorithm,Evolutionary algorithm,"Starting with:

 The target string: ""METHINKS IT IS LIKE A WEASEL"".
 An array of random characters chosen from the set of upper-case letters together with the space, and of the same length as the target string. (Call it the parent).
 A fitness function that computes the ‘closeness’ of its argument to the target string.
 A mutate function that given a string and a mutation rate returns a copy of the string, with some characters probably mutated.
 While the parent is not yet the target:
 copy the parent C times, each time allowing some random probability that another character might be substituted using mutate.
 Assess the fitness of the parent and all the copies to the target and make the most fit string the new parent, discarding the others.
 repeat until the parent converges, (hopefully), to the target.


See also

   Wikipedia entry:   Weasel algorithm.
   Wikipedia entry:   Evolutionary algorithm.

Note: to aid comparison, try and ensure the variables and functions mentioned in the task description appear in solutions



A cursory examination of a few of the solutions reveals that the instructions have not been followed rigorously in some solutions. Specifically,

 While the parent is not yet the target:
 copy the parent C times, each time allowing some random probability that another character might be substituted using mutate.
Note that some of the the solutions given retain characters in the mutated string that are correct in the target string. However, the instruction above does not state to retain any of the characters while performing the mutation. Although some may believe to do so is implied from the use of ""converges""

(:* repeat until the parent converges, (hopefully), to the target.

Strictly speaking, the new parent should be selected from the new pool of mutations, and then the new parent used to generate the next set of mutations with parent characters getting retained only by not being mutated. It then becomes possible that the new set of mutations has no member that is fitter than the parent!

As illustration of this error, the code for 8th has the following remark.

Create a new string based on the TOS, changing randomly any characters which
don't already match the target:

NOTE: this has been changed, the 8th version is completely random now

Clearly, this algo will be applying the mutation function only to the parent characters that don't match to the target characters!

To ensure that the new parent is never less fit than the prior parent, both the parent and all of the latest mutations are subjected to the fitness test to select the next parent.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
var target = []byte(""METHINKS IT IS LIKE A WEASEL"")
var set = []byte(""ABCDEFGHIJKLMNOPQRSTUVWXYZ "")
var parent []byte
 
func init() {
    rand.Seed(time.Now().UnixNano())
    parent = make([]byte, len(target))
    for i := range parent {
        parent[i] = set[rand.Intn(len(set))]
    }
}
 
// fitness:  0 is perfect fit.  greater numbers indicate worse fit.
func fitness(a []byte) (h int) {
    // (hamming distance)
    for i, tc := range target {
        if a[i] != tc {
            h++
        }
    }
    return
}
 
// set m to mutation of p, with each character of p mutated with probability r
func mutate(p, m []byte, r float64) {
    for i, ch := range p {
        if rand.Float64() < r {
            m[i] = set[rand.Intn(len(set))]
        } else {
            m[i] = ch
        }
    }
}
 
func main() {
    const c = 20 // number of times to copy and mutate parent
 
    copies := make([][]byte, c)
    for i := range copies {
        copies[i] = make([]byte, len(parent))
    }
 
    fmt.Println(string(parent))
    for best := fitness(parent); best > 0; {
        for _, cp := range copies {
            mutate(parent, cp, .05)
        }
        for _, cp := range copies {
            fm := fitness(cp)
            if fm < best {
                best = fm
                copy(parent, cp)
                fmt.Println(string(parent))
            }
        }
    }
}",1445,65
57756,http://rosettacode.org/wiki/Execute_Brain****,Execute Brain****,"Execute Brain**** is an implementation of Brainf***.
Other implementations of Brainf***.
RCBF is a set of Brainf*** compilers and interpreters written for Rosetta Code in a variety of languages.

Below are links to each of the versions of RCBF.

An implementation need only properly implement the following instructions:



Command

Description


 > 
 Move the pointer to the right


 < 
 Move the pointer to the left


 + 
 Increment the memory cell under the pointer


 - 
 Decrement the memory cell under the pointer


 . 
 Output the character signified by the cell at the pointer


 , 
 Input a character and store it in the cell at the pointer


 [ 
 Jump past the matching ] if the cell under the pointer is 0


 ] 
 Jump back to the matching [ if the cell under the pointer is nonzero

Any cell size is allowed,   EOF   (End-O-File)   support is optional, as is whether you have bounded or unbounded memory.



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    // example program is current Brain**** solution to
    // Hello world/Text task.  only requires 10 bytes of data store!
    bf(10, `++++++++++[>+>+++>++++>+++++++>++++++++>+++++++++>++
++++++++>+++++++++++>++++++++++++<<<<<<<<<-]>>>>+.>>>
>+..<.<++++++++.>>>+.<<+.<<<<++++.<++.>>>+++++++.>>>.+++.
<+++++++.--------.<<<<<+.<+++.---.`)
}
 
func bf(dLen int, is string) {
    ds := make([]byte, dLen) // data store
    var dp int               // data pointer
    for ip := 0; ip < len(is); ip++ {
        switch is[ip] {
        case '>':
            dp++
        case '<':
            dp--
        case '+':
            ds[dp]++
        case '-':
            ds[dp]--
        case '.':
            fmt.Printf(""%c"", ds[dp])
        case ',':
            fmt.Scanf(""%c"", &ds[dp])
        case '[':
            if ds[dp] == 0 {
                for nc := 1; nc > 0; {
                    ip++
                    if is[ip] == '[' {
                        nc++
                    } else if is[ip] == ']' {
                        nc--
                    }
                }
            }
        case ']':
            if ds[dp] != 0 {
                for nc := 1; nc > 0; {
                    ip--
                    if is[ip] == ']' {
                        nc++
                    } else if is[ip] == '[' {
                        nc--
                    }
                }
            }
        }
    }
}",1459,55
58121,http://rosettacode.org/wiki/Factorial,Factorial,"Definitions

   The factorial of   0   (zero)   is defined as being   1   (unity).
   The   Factorial Function   of a positive integer,    n,    is defined as the product of the sequence:
                 n,   n-1,   n-2,   ...   1 



Task

Write a function to return the factorial of a number.

Solutions can be iterative or recursive.

Support for trapping negative    n    errors is optional.



Related task

   Primorial numbers

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    fmt.Println(factorial(800))
}
 
func factorial(n int64) *big.Int {
    if n < 0 {
        return nil
    }
    r := big.NewInt(1)
    var f big.Int
    for i := int64(2); i <= n; i++ {
        r.Mul(r, f.SetInt64(i))
    }
    return r
}",308,22
58210,http://rosettacode.org/wiki/Euler%27s_identity,Euler's identity,"

 This page uses content from Wikipedia. The original article was at Euler's_identity. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In mathematics, Euler's identity is the equality:

               ei
  
    
      
        π
      
    
    {\displaystyle \pi }
  
 + 1 = 0

where

   e is Euler's number, the base of natural logarithms,
   i is the imaginary unit, which satisfies i2 = −1, and
   
  
    
      
        π
      
    
    {\displaystyle \pi }
  
 is pi, the ratio of the circumference of a circle to its diameter.

Euler's identity is often cited as an example of deep mathematical beauty. Three of the basic arithmetic operations occur exactly once each: addition, multiplication, and exponentiation. The identity also links five fundamental mathematical constants:

   The number 0.
   The number 1.
   The number 
  
    
      
        π
      
    
    {\displaystyle \pi }
  
 (
  
    
      
        π
      
    
    {\displaystyle \pi }
  
 = 3.14159+),
   The number e (e = 2.71828+), which occurs widely in mathematical analysis.
   The number i, the imaginary unit of the complex numbers.

Task
Show in your language that Euler's identity is true. As much as possible and practical, mimic the Euler's identity equation.

Most languages are limited to IEEE 754 floating point calculations so will have some error in the calculation.

If that is the case, or there is some other limitation, show
that ei



π


{\displaystyle \pi }

 + 1 is approximately equal to zero and
show the amount of error in the calculation.

If your language is capable of symbolic calculations, show
that ei



π


{\displaystyle \pi }

 + 1 is exactly equal to zero for bonus kudos points.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/cmplx""
)
 
func main() {
    fmt.Println(cmplx.Exp(math.Pi * 1i) + 1.0)
}",128,11
58271,http://rosettacode.org/wiki/Erd%C3%B6s-Selfridge_categorization_of_primes,Erdös-Selfridge categorization of primes,"A prime p is in category 1 if the prime factors of p+1 are 2 and or 3. p is in category 2 if all the prime factors of p+1 are in category 1. p is in category g if all the prime factors of p+1 are in categories 1 to g-1.

The task is first to display the first 200 primes allocated to their category, then assign the first million primes to their category, displaying the smallest prime, the largest prime, and the count of primes allocated to each category.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""rcu""
)
 
var limit = int(math.Log(1e6) * 1e6 * 1.2) // should be more than enough
var primes = rcu.Primes(limit)
 
var prevCats = make(map[int]int)
 
func cat(p int) int {
    if v, ok := prevCats[p]; ok {
        return v
    }
    pf := rcu.PrimeFactors(p + 1)
    all := true
    for _, f := range pf {
        if f != 2 && f != 3 {
            all = false
            break
        }
    }
    if all {
        return 1
    }
    if p > 2 {
        len := len(pf)
        for i := len - 1; i >= 1; i-- {
            if pf[i-1] == pf[i] {
                pf = append(pf[:i], pf[i+1:]...)
            }
        }
    }
    for c := 2; c <= 11; c++ {
        all := true
        for _, f := range pf {
            if cat(f) >= c {
                all = false
                break
            }
        }
        if all {
            prevCats[p] = c
            return c
        }
    }
    return 12
}
 
func main() {
    es := make([][]int, 12)
    fmt.Println(""First 200 primes:\n"")
    for _, p := range primes[0:200] {
        c := cat(p)
        es[c-1] = append(es[c-1], p)
    }
    for c := 1; c <= 6; c++ {
        if len(es[c-1]) > 0 {
            fmt.Println(""Category"", c, ""\b:"")
            fmt.Println(es[c-1])
            fmt.Println()
        }
    }
 
    fmt.Println(""First million primes:\n"")
    for _, p := range primes[200:1e6] {
        c := cat(p)
        es[c-1] = append(es[c-1], p)
    }
    for c := 1; c <= 12; c++ {
        e := es[c-1]
        if len(e) > 0 {
            format := ""Category %-2d: First = %7d  Last = %8d  Count = %6d\n""
            fmt.Printf(format, c, e[0], e[len(e)-1], len(e))
        }
    }
}",1699,80
58352,http://rosettacode.org/wiki/Equal_prime_and_composite_sums,Equal prime and composite sums,"Suppose we have a sequence of prime sums, where each term Pn is the sum of the first n primes.

P = (2), (2 + 3), (2 + 3 + 5), (2 + 3 + 5 + 7), (2 + 3 + 5 + 7 + 11), ...

P = 2, 5, 10, 17, 28, etc.



Further; suppose we have a sequence of composite sums, where each term Cm is the sum of the first m composites.

C = (4), (4 + 6), (4 + 6 + 8), (4 + 6 + 8 + 9), (4 + 6 + 8 + 9 + 10), ...

C = 4, 10, 18, 27, 37, etc.



Notice that the third term of P; P3 (10) is equal to the second term of C; C2 (10);



Task
 Find and display the indices (n, m) and value of at least the first 6 terms of the sequence of numbers that are both the sum of the first n primes and the first m composites.


See also
 OEIS:A007504 - Sum of the first n primes
 OEIS:A053767 - Sum of first n composite numbers
 OEIS:A294174 - Numbers that can be expressed both as the sum of first primes and as the sum of first composites

",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""rcu""
    ""sort""
)
 
func ord(n int) string {
    if n < 0 {
        log.Fatal(""Argument must be a non-negative integer."")
    }
    m := n % 100
    if m >= 4 && m <= 20 {
        return fmt.Sprintf(""%sth"", rcu.Commatize(n))
    }
    m %= 10
    suffix := ""th""
    if m == 1 {
        suffix = ""st""
    } else if m == 2 {
        suffix = ""nd""
    } else if m == 3 {
        suffix = ""rd""
    }
    return fmt.Sprintf(""%s%s"", rcu.Commatize(n), suffix)
}
 
func main() {
    limit := int(4 * 1e8)
    c := rcu.PrimeSieve(limit-1, true)
    var compSums []int
    var primeSums []int
    csum := 0
    psum := 0
    for i := 2; i < limit; i++ {
        if c[i] {
            csum += i
            compSums = append(compSums, csum)
        } else {
            psum += i
            primeSums = append(primeSums, psum)
        }
    }
 
    for i := 0; i < len(primeSums); i++ {
        ix := sort.SearchInts(compSums, primeSums[i])
        if ix < len(compSums) && compSums[ix] == primeSums[i] {
            cps := rcu.Commatize(primeSums[i])
            fmt.Printf(""%21s - %12s prime sum, %12s composite sum\n"", cps, ord(i+1), ord(ix+1))
        }
    }
}",1204,54
58372,http://rosettacode.org/wiki/Euler_method,Euler method,"Euler's method numerically approximates solutions of first-order ordinary differential equations (ODEs) with a given initial value.   It is an explicit method for solving initial value problems (IVPs), as described in the wikipedia page.

The ODE has to be provided in the following form:

 






d
y
(
t
)


d
t



=
f
(
t
,
y
(
t
)
)


{\displaystyle {\frac {dy(t)}{dt}}=f(t,y(t))}


with an initial value

 



y
(

t

0


)
=

y

0




{\displaystyle y(t_{0})=y_{0}}


To get a numeric solution, we replace the derivative on the   LHS   with a finite difference approximation:

 






d
y
(
t
)


d
t



≈



y
(
t
+
h
)
−
y
(
t
)

h




{\displaystyle {\frac {dy(t)}{dt}}\approx {\frac {y(t+h)-y(t)}{h}}}


then solve for 



y
(
t
+
h
)


{\displaystyle y(t+h)}

:

 



y
(
t
+
h
)
≈
y
(
t
)
+
h




d
y
(
t
)


d
t





{\displaystyle y(t+h)\approx y(t)+h\,{\frac {dy(t)}{dt}}}


which is the same as

 



y
(
t
+
h
)
≈
y
(
t
)
+
h

f
(
t
,
y
(
t
)
)


{\displaystyle y(t+h)\approx y(t)+h\,f(t,y(t))}


The iterative solution rule is then:

 




y

n
+
1


=

y

n


+
h

f
(

t

n


,

y

n


)


{\displaystyle y_{n+1}=y_{n}+h\,f(t_{n},y_{n})}


where   



h


{\displaystyle h}

   is the step size, the most relevant parameter for accuracy of the solution.   A smaller step size increases accuracy but also the computation cost, so it has always has to be hand-picked according to the problem at hand.


Example: Newton's Cooling Law

Newton's cooling law describes how an object of initial temperature   



T
(

t

0


)
=

T

0




{\displaystyle T(t_{0})=T_{0}}

   cools down in an environment of temperature   




T

R




{\displaystyle T_{R}}

:

 






d
T
(
t
)


d
t



=
−
k

Δ
T


{\displaystyle {\frac {dT(t)}{dt}}=-k\,\Delta T}


or

 






d
T
(
t
)


d
t



=
−
k

(
T
(
t
)
−

T

R


)


{\displaystyle {\frac {dT(t)}{dt}}=-k\,(T(t)-T_{R})}




It says that the cooling rate   






d
T
(
t
)


d
t





{\displaystyle {\frac {dT(t)}{dt}}}

   of the object is proportional to the current temperature difference   



Δ
T
=
(
T
(
t
)
−

T

R


)


{\displaystyle \Delta T=(T(t)-T_{R})}

   to the surrounding environment.

The analytical solution, which we will compare to the numerical approximation, is

 



T
(
t
)
=

T

R


+
(

T

0


−

T

R


)


e

−
k
t




{\displaystyle T(t)=T_{R}+(T_{0}-T_{R})\;e^{-kt}}




Task

Implement a routine of Euler's method and then to use it to solve the given example of Newton's cooling law with it for three different step sizes of:

   2 s
   5 s       and 
   10 s 
and to compare with the analytical solution.



Initial values

   initial temperature   




T

0




{\displaystyle T_{0}}

   shall be   100 °C
   room temperature   




T

R




{\displaystyle T_{R}}

   shall be   20 °C
   cooling constant     



k


{\displaystyle k}

     shall be   0.07 
   time interval to calculate shall be from   0 s   ──►   100 s


A reference solution (Common Lisp) can be seen below.   We see that bigger step sizes lead to reduced approximation accuracy.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
// fdy is a type for function f used in Euler's method.
type fdy func(float64, float64) float64
 
// eulerStep computes a single new value using Euler's method.
// Note that step size h is a parameter, so a variable step size
// could be used.
func eulerStep(f fdy, x, y, h float64) float64 {
    return y + h*f(x, y)
}
 
// Definition of cooling rate.  Note that this has general utility and
// is not specific to use in Euler's method.
 
// newCoolingRate returns a function that computes cooling rate
// for a given cooling rate constant k.
func newCoolingRate(k float64) func(float64) float64 {
    return func(deltaTemp float64) float64 {
        return -k * deltaTemp
    }
}
 
// newTempFunc returns a function that computes the analytical solution
// of cooling rate integrated over time.
func newTempFunc(k, ambientTemp, initialTemp float64) func(float64) float64 {
    return func(time float64) float64 {
        return ambientTemp + (initialTemp-ambientTemp)*math.Exp(-k*time)
    }
}
 
// newCoolingRateDy returns a function of the kind needed for Euler's method.
// That is, a function representing dy(x, y(x)).
//
// Parameters to newCoolingRateDy are cooling constant k and ambient
// temperature.
func newCoolingRateDy(k, ambientTemp float64) fdy {
    crf := newCoolingRate(k)
    // note that result is dependent only on the object temperature.
    // there are no additional dependencies on time, so the x parameter
    // provided by eulerStep is unused.
    return func(_, objectTemp float64) float64 {
        return crf(objectTemp - ambientTemp)
    }
}
 
func main() {
    k := .07
    tempRoom := 20.
    tempObject := 100.
    fcr := newCoolingRateDy(k, tempRoom)
    analytic := newTempFunc(k, tempRoom, tempObject)
    for _, deltaTime := range []float64{2, 5, 10} {
        fmt.Printf(""Step size = %.1f\n"", deltaTime)
        fmt.Println("" Time Euler's Analytic"")
        temp := tempObject
        for time := 0.; time <= 100; time += deltaTime {
            fmt.Printf(""%5.1f %7.3f %7.3f\n"", time, temp, analytic(time))
            temp = eulerStep(fcr, time, temp, deltaTime)
        }
        fmt.Println()
    }
}",2196,68
58379,http://rosettacode.org/wiki/Esthetic_numbers,Esthetic numbers,"An esthetic number is a positive integer where every adjacent digit differs from its neighbour by 1.



E.G.
 12 is an esthetic number. One and two differ by 1.
 5654 is an esthetic number. Each digit is exactly 1 away from its neighbour.
 890 is not an esthetic number. Nine and zero differ by 9.


These examples are nominally in base 10 but the concept extends easily to numbers in other bases. Traditionally, single digit numbers are included in esthetic numbers; zero may or may not be. For our purposes, for this task, do not include zero (0) as an esthetic number. Do not include numbers with leading zeros.

Esthetic numbers are also sometimes referred to as stepping numbers.



Task
 Write a routine (function, procedure, whatever) to find esthetic numbers in a given base.
 Use that routine to find esthetic numbers in bases 2 through 16 and display, here on this page, the esthectic numbers from index (base × 4) through index (base × 6), inclusive. (E.G. for base 2: 8th through 12th, for base 6: 24th through 36th, etc.)
 Find and display, here on this page, the base 10 esthetic numbers with a magnitude between 1000 and 9999.
 Stretch: Find and display, here on this page, the base 10 esthetic numbers with a magnitude between 1.0e8 and 1.3e8.


Related task

   numbers with equal rises and falls


See also

OEIS A033075 - Positive numbers n such that all pairs of consecutive decimal digits differ by 1
Numbers Aplenty - Esthetic numbers
Geeks for Geeks - Stepping numbers

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
func uabs(a, b uint64) uint64 {
    if a > b {
        return a - b
    }
    return b - a
}
 
func isEsthetic(n, b uint64) bool {
    if n == 0 {
        return false
    }
    i := n % b
    n /= b
    for n > 0 {
        j := n % b
        if uabs(i, j) != 1 {
            return false
        }
        n /= b
        i = j
    }
    return true
}
 
var esths []uint64
 
func dfs(n, m, i uint64) {
    if i >= n && i <= m {
        esths = append(esths, i)
    }
    if i == 0 || i > m {
        return
    }
    d := i % 10
    i1 := i*10 + d - 1
    i2 := i1 + 2
    if d == 0 {
        dfs(n, m, i2)
    } else if d == 9 {
        dfs(n, m, i1)
    } else {
        dfs(n, m, i1)
        dfs(n, m, i2)
    }
}
 
func listEsths(n, n2, m, m2 uint64, perLine int, all bool) {
    esths = esths[:0]
    for i := uint64(0); i < 10; i++ {
        dfs(n2, m2, i)
    }
    le := len(esths)
    fmt.Printf(""Base 10: %s esthetic numbers between %s and %s:\n"",
        commatize(uint64(le)), commatize(n), commatize(m))
    if all {
        for c, esth := range esths {
            fmt.Printf(""%d "", esth)
            if (c+1)%perLine == 0 {
                fmt.Println()
            }
        }
    } else {
        for i := 0; i < perLine; i++ {
            fmt.Printf(""%d "", esths[i])
        }
        fmt.Println(""\n............\n"")
        for i := le - perLine; i < le; i++ {
            fmt.Printf(""%d "", esths[i])
        }
    }
    fmt.Println(""\n"")
}
 
func commatize(n uint64) string {
    s := fmt.Sprintf(""%d"", n)
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    return s
}
 
func main() {
    for b := uint64(2); b <= 16; b++ {
        fmt.Printf(""Base %d: %dth to %dth esthetic numbers:\n"", b, 4*b, 6*b)
        for n, c := uint64(1), uint64(0); c < 6*b; n++ {
            if isEsthetic(n, b) {
                c++
                if c >= 4*b {
                    fmt.Printf(""%s "", strconv.FormatUint(n, int(b)))
                }
            }
        }
        fmt.Println(""\n"")
    }
 
    // the following all use the obvious range limitations for the numbers in question
    listEsths(1000, 1010, 9999, 9898, 16, true)
    listEsths(1e8, 101_010_101, 13*1e7, 123_456_789, 9, true)
    listEsths(1e11, 101_010_101_010, 13*1e10, 123_456_789_898, 7, false)
    listEsths(1e14, 101_010_101_010_101, 13*1e13, 123_456_789_898_989, 5, false)
    listEsths(1e17, 101_010_101_010_101_010, 13*1e16, 123_456_789_898_989_898, 4, false)
}",2546,110
58528,http://rosettacode.org/wiki/Entropy/Narcissist,Entropy/Narcissist,"
Task

Write a computer program that computes and shows its own   entropy.



Related Tasks

   Fibonacci_word
   Entropy

",#Go,Go,"package main
 
import (
    ""fmt""
    ""io/ioutil""
    ""log""
    ""math""
    ""os""
    ""runtime""
)
 
func main() {
    _, src, _, _ := runtime.Caller(0)
    fmt.Println(""Source file entropy:"", entropy(src))
    fmt.Println(""Binary file entropy:"", entropy(os.Args[0]))
}
 
func entropy(file string) float64 {
    d, err := ioutil.ReadFile(file)
    if err != nil {
        log.Fatal(err)
    }
    var f [256]float64
    for _, b := range d {
        f[b]++
    }
    hm := 0.
    for _, c := range f {
        if c > 0 {
            hm += c * math.Log2(c)
        }
    }
    l := float64(len(d))
    return math.Log2(l) - hm/l
}",626,35
58635,http://rosettacode.org/wiki/Environment_variables,Environment variables,"Task

Show how to get one of your process's environment variables.

The available variables vary by system;   some of the common ones available on Unix include:

   PATH
   HOME
   USER

",#Go,Go,"package main
 
import (
    ""fmt""
    ""os""
)
 
func main() {
    fmt.Println(os.Getenv(""SHELL""))
}",98,10
58677,http://rosettacode.org/wiki/Evaluate_binomial_coefficients,Evaluate binomial coefficients,"This programming task, is to calculate ANY binomial coefficient.

However, it has to be able to output   






(


5
3


)





{\displaystyle {\binom {5}{3}}}

,   which is   10.

This formula is recommended:


 






(


n
k


)



=



n
!


(
n
−
k
)
!
k
!



=



n
(
n
−
1
)
(
n
−
2
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
(
k
−
2
)
…
1





{\displaystyle {\binom {n}{k}}={\frac {n!}{(n-k)!k!}}={\frac {n(n-1)(n-2)\ldots (n-k+1)}{k(k-1)(k-2)\ldots 1}}}





See Also:

 Combinations and permutations
 Pascal's triangle

 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",#Go,Go,"package main
import ""fmt""
import ""math/big""
 
func main() {
  fmt.Println(new(big.Int).Binomial(5, 3))
  fmt.Println(new(big.Int).Binomial(60, 30))
}",149,8
58723,http://rosettacode.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm,Elliptic Curve Digital Signature Algorithm,"Elliptic curves.
An elliptic curve E over ℤp (p ≥ 5) is defined by an equation of the form
y^2 = x^3 + ax + b, where a, b ∈ ℤp and the discriminant ≢ 0 (mod p),
together with a special point 𝒪 called the point at infinity.
The set E(ℤp) consists of all points (x, y), with x, y ∈ ℤp,
which satisfy the above defining equation, together with 𝒪.

There is a rule for adding two points on an elliptic curve to give a third point.
This addition operation and the set of points E(ℤp) form a group with identity 𝒪.
It is this group that is used in the construction of elliptic curve cryptosystems.

The addition rule — which can be explained geometrically — is summarized as follows:

1. P + 𝒪 = 𝒪 + P = P for all P ∈ E(ℤp).

2. If P = (x, y) ∈ E(ℤp), then inverse -P = (x,-y), and P + (-P) = 𝒪.

3. Let P = (xP, yP) and Q = (xQ, yQ), both ∈ E(ℤp), where P ≠ -Q.
   Then R = P + Q = (xR, yR), where

   xR = λ^2 - xP - xQ
   yR = λ·(xP - xR) - yP,

   with

   λ = (yP - yQ) / (xP - xQ) if P ≠ Q,
       (3·xP·xP + a) / 2·yP  if P = Q (point doubling).

Remark: there already is a task page requesting “a simplified (without modular arithmetic)
version of the elliptic curve arithmetic”.
Here we do add modulo operations. If also the domain is changed from reals to rationals,
the elliptic curves are no longer continuous but break up into a finite number of distinct points.
In that form we use them to implement ECDSA:



Elliptic curve digital signature algorithm.
A digital signature is the electronic analogue of a hand-written signature
that convinces the recipient that a message has been sent intact by the presumed sender.
Anyone with access to the public key of the signer may verify this signature.
Changing even a single bit of a signed message will cause the verification procedure to fail.

ECDSA key generation. Party A does the following:

1. Select an elliptic curve E defined over ℤp.

 The number of points in E(ℤp) should be divisible by a large prime r.

2. Select a base point G ∈ E(ℤp) of order r (which means that rG = 𝒪).

3. Select a random integer s in the interval [1, r - 1].

4. Compute W = sG.

 The public key is (E, G, r, W), the private key is s.

ECDSA signature computation. To sign a message m, A does the following:

1. Compute message representative f = H(m), using a
cryptographic hash function.

 Note that f can be greater than r but not longer (measuring bits).

2. Select a random integer u in the interval [1, r - 1].

3. Compute V = uG = (xV, yV) and c ≡ xV mod r  (goto (2) if c = 0).

4. Compute d ≡ u^-1·(f + s·c) mod r  (goto (2) if d = 0).

 The signature for the message m is the pair of integers (c, d).

ECDSA signature verification. To verify A's signature, B should do the following:

1. Obtain an authentic copy of A's public key (E, G, r, W).

 Verify that c and d are integers in the interval [1, r - 1].

2. Compute f = H(m) and h ≡ d^-1 mod r.

3. Compute h1 ≡ f·h mod r and h2 ≡ c·h mod r.

4. Compute h1G + h2W = (x1, y1) and c1 ≡ x1 mod r.

 Accept the signature if and only if c1 = c.

To be cryptographically useful, the parameter r should have at least 250 bits.
The basis for the security of elliptic curve cryptosystems
is the intractability of the elliptic curve discrete logarithm problem (ECDLP) in a group of this size:
given two points G, W ∈ E(ℤp), where W lies in the subgroup of order r generated by G,
determine an integer k such that W = kG and 0 ≤ k < r.



Task.
The task is to write a toy version of the ECDSA, quasi the equal of a real-world
implementation, but utilizing parameters that fit into standard arithmetic types.
To keep things simple there's no need for key export or a hash function (just a sample
hash value and a way to tamper with it). The program should be lenient where possible
(for example: if it accepts a composite modulus N it will either function as expected,
or demonstrate the principle of elliptic curve factorization)
— but strict where required (a point G that is not on E will always cause failure).

Toy ECDSA is of course completely useless for its cryptographic purpose.
If this bothers you, please add a multiple-precision version.



Reference.
Elliptic curves are in the IEEE Std 1363-2000 (Standard Specifications for Public-Key Cryptography), see:

7. Primitives based on the elliptic curve discrete logarithm problem (p. 27ff.)

7.1 The EC setting

7.1.2 EC domain parameters

7.1.3 EC key pairs

7.2 Primitives

7.2.7 ECSP-DSA (p. 35)

7.2.8 ECVP-DSA (p. 36)

Annex A. Number-theoretic background

A.9 Elliptic curves: overview (p. 115)

A.10 Elliptic curves: algorithms (p. 121)


",#Go,Go,"package main
 
import (
    ""crypto/ecdsa""
    ""crypto/elliptic""
    ""crypto/rand""
    ""crypto/sha256""
    ""encoding/binary""
    ""fmt""
    ""log""
)
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func main() {
    priv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
    check(err)
    fmt.Println(""Private key:\nD:"", priv.D)
    pub := priv.Public().(*ecdsa.PublicKey)
    fmt.Println(""\nPublic key:"")
    fmt.Println(""X:"", pub.X)
    fmt.Println(""Y:"", pub.Y)
 
    msg := ""Rosetta Code""
    fmt.Println(""\nMessage:"", msg)
    hash := sha256.Sum256([]byte(msg)) // as [32]byte
    hexHash := fmt.Sprintf(""0x%x"", binary.BigEndian.Uint32(hash[:]))
    fmt.Println(""Hash   :"", hexHash)
 
    r, s, err := ecdsa.Sign(rand.Reader, priv, hash[:])
    check(err)
    fmt.Println(""\nSignature:"")
    fmt.Println(""R:"", r)
    fmt.Println(""S:"", s)
 
    valid := ecdsa.Verify(&priv.PublicKey, hash[:], r, s)
    fmt.Println(""\nSignature verified:"", valid)
}",986,42
58728,http://rosettacode.org/wiki/Enforced_immutability,Enforced immutability,"Task

Demonstrate any means your language has to prevent the modification of values, or to create objects that cannot be modified after they have been created.



",#Go,Go,"package main
 
func main() {
    s := ""immutable""
    s[0] = 'a'
}",66,6
58789,http://rosettacode.org/wiki/Enumerations,Enumerations,"Task

Create an enumeration of constants with and without explicit values.



",#Go,Go,"const (
	apple = iota
	banana
	cherry
)",39,5
58824,http://rosettacode.org/wiki/Elementary_cellular_automaton/Random_Number_Generator,Elementary cellular automaton/Random Number Generator,"Rule 30 is considered to be chaotic enough to generate good pseudo-random numbers. As a matter of fact, rule 30 is used by the Mathematica software for its default random number generator.

Steven Wolfram's recommendation for random number generation from rule 30 consists in extracting successive bits in a fixed position in the array of cells, as the automaton changes state.

The purpose of this task is to demonstrate this. With the code written in the parent task, which you don't need to re-write here, show the ten first bytes that emerge from this recommendation. To be precise, you will start with a state of all cells but one equal to zero, and you'll follow the evolution of the particular cell whose state was initially one. Then you'll regroup those bits by packets of eight, reconstituting bytes with the first bit being the most significant.

You can pick which ever length you want for the initial array but it should be visible in the code so that your output can be reproduced with an other language.

For extra-credits, you will make this algorithm run as fast as possible in your language, for instance with an extensive use of bitwise logic.

Reference

 Cellular automata: Is Rule 30 random? (PDF).

",#Go,Go,"package main
 
import ""fmt""
 
const n = 64
 
func pow2(x uint) uint64 {
    return uint64(1) << x
}
 
func evolve(state uint64, rule int) {
    for p := 0; p < 10; p++ {
        b := uint64(0)
        for q := 7; q >= 0; q-- {
            st := state
            b |= (st & 1) << uint(q)
            state = 0
            for i := uint(0); i < n; i++ {
                var t1, t2, t3 uint64
                if i > 0 {
                    t1 = st >> (i - 1)
                } else {
                    t1 = st >> 63
                }
                if i == 0 {
                    t2 = st << 1
                } else if i == 1 {
                    t2 = st << 63
 
                } else {
                    t2 = st << (n + 1 - i)
                }
                t3 = 7 & (t1 | t2)
                if (uint64(rule) & pow2(uint(t3))) != 0 {
                    state |= pow2(i)
                }
            }
        }
        fmt.Printf(""%d "", b)
    }
    fmt.Println()
}
 
func main() {
    evolve(1, 30)
}",1014,46
58838,http://rosettacode.org/wiki/Equilibrium_index,Equilibrium index,"An equilibrium index of a sequence is an index into the sequence such that the sum of elements at lower indices is equal to the sum of elements at higher indices.



For example, in a sequence   



A


{\displaystyle A}

:

   




A

0


=
−
7


{\displaystyle A_{0}=-7}


   




A

1


=
1


{\displaystyle A_{1}=1}


   




A

2


=
5


{\displaystyle A_{2}=5}


   




A

3


=
2


{\displaystyle A_{3}=2}


   




A

4


=
−
4


{\displaystyle A_{4}=-4}


   




A

5


=
3


{\displaystyle A_{5}=3}


   




A

6


=
0


{\displaystyle A_{6}=0}


3   is an equilibrium index, because:

   




A

0


+

A

1


+

A

2


=

A

4


+

A

5


+

A

6




{\displaystyle A_{0}+A_{1}+A_{2}=A_{4}+A_{5}+A_{6}}


6   is also an equilibrium index, because:

   




A

0


+

A

1


+

A

2


+

A

3


+

A

4


+

A

5


=
0


{\displaystyle A_{0}+A_{1}+A_{2}+A_{3}+A_{4}+A_{5}=0}


(sum of zero elements is zero)

7   is not an equilibrium index, because it is not a valid index of sequence 



A


{\displaystyle A}

.



Task;
Write a function that, given a sequence, returns its equilibrium indices (if any).

Assume that the sequence may be very long.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
func main() {
    fmt.Println(ex([]int32{-7, 1, 5, 2, -4, 3, 0}))
 
    // sequence of 1,000,000 random numbers, with values
    // chosen so that it will be likely to have a couple
    // of equalibrium indexes.
    rand.Seed(time.Now().UnixNano())
    verylong := make([]int32, 1e6)
    for i := range verylong {
        verylong[i] = rand.Int31n(1001) - 500
    }
    fmt.Println(ex(verylong))
}
 
func ex(s []int32) (eq []int) {
    var r, l int64
    for _, el := range s {
        r += int64(el)
    }
    for i, el := range s {
        r -= int64(el)
        if l == r {
            eq = append(eq, i)
        }
        l += int64(el)
    }
    return
}",725,36
58852,http://rosettacode.org/wiki/Elliptic_curve_arithmetic,Elliptic curve arithmetic,"Elliptic curves   are sometimes used in   cryptography   as a way to perform   digital signatures.

The purpose of this task is to implement a simplified (without modular arithmetic) version of the elliptic curve arithmetic which is required by the   elliptic curve DSA   protocol.

In a nutshell, an elliptic curve is a bi-dimensional curve defined by the following relation between the x and y coordinates of any point on the curve:

   




y

2


=

x

3


+
a
x
+
b


{\displaystyle y^{2}=x^{3}+ax+b}


a and b are arbitrary parameters that define the specific curve which is used.

For this particular task, we'll use the following parameters:

    a=0,   b=7 
The most interesting thing about elliptic curves is the fact that it is possible to define a   group   structure on it.

To do so we define an   internal composition   rule with an additive notation +,   such that for any three distinct points P, Q and R on the curve, whenever these points are aligned, we have:

    P + Q + R = 0  
Here   0   (zero)   is the infinity point,   for which the x and y values are not defined.   It's basically the same kind of point which defines the horizon in   projective geometry.

We'll also assume here that this infinity point is unique and defines the   neutral element   of the addition.

This was not the definition of the addition, but only its desired property.   For a more accurate definition, we proceed as such:

Given any three aligned points P, Q and R,   we define the sum   S = P + Q   as the point (possibly the infinity point) such that   S, R   and the infinity point are aligned.

Considering the symmetry of the curve around the x-axis, it's easy to convince oneself that two points S and R can be aligned with the infinity point if and only if S and R are symmetric of one another towards the x-axis   (because in that case there is no other candidate than the infinity point to complete the alignment triplet).

S is thus defined as the symmetric of R towards the x axis.

The task consists in defining the addition which, for any two points of the curve, returns the sum of these two points.   You will pick two random points on the curve, compute their sum and show that the symmetric of the sum is aligned with the two initial points.

You will use the a and b parameters of secp256k1, i.e. respectively zero and seven.

Hint:   You might need to define a ""doubling"" function, that returns P+P for any given point P.

Extra credit:   define the full elliptic curve arithmetic (still not modular, though) by defining a ""multiply"" function that returns,

for any point P and integer n,   the point P + P + ... + P     (n times).



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
const bCoeff = 7
 
type pt struct{ x, y float64 }
 
func zero() pt {
    return pt{math.Inf(1), math.Inf(1)}
}
 
func is_zero(p pt) bool {
    return p.x > 1e20 || p.x < -1e20
}
 
func neg(p pt) pt {
    return pt{p.x, -p.y}
}
 
func dbl(p pt) pt {
    if is_zero(p) {
        return p
    }
    L := (3 * p.x * p.x) / (2 * p.y)
    x := L*L - 2*p.x
    return pt{
        x: x,
        y: L*(p.x-x) - p.y,
    }
}
 
func add(p, q pt) pt {
    if p.x == q.x && p.y == q.y {
        return dbl(p)
    }
    if is_zero(p) {
        return q
    }
    if is_zero(q) {
        return p
    }
    L := (q.y - p.y) / (q.x - p.x)
    x := L*L - p.x - q.x
    return pt{
        x: x,
        y: L*(p.x-x) - p.y,
    }
}
 
func mul(p pt, n int) pt {
    r := zero()
    for i := 1; i <= n; i <<= 1 {
        if i&n != 0 {
            r = add(r, p)
        }
        p = dbl(p)
    }
    return r
}
 
func show(s string, p pt) {
    fmt.Printf(""%s"", s)
    if is_zero(p) {
        fmt.Println(""Zero"")
    } else {
        fmt.Printf(""(%.3f, %.3f)\n"", p.x, p.y)
    }
}
 
func from_y(y float64) pt {
    return pt{
        x: math.Cbrt(y*y - bCoeff),
        y: y,
    }
}
 
func main() {
    a := from_y(1)
    b := from_y(2)
    show(""a = "", a)
    show(""b = "", b)
    c := add(a, b)
    show(""c = a + b = "", c)
    d := neg(c)
    show(""d = -c = "", d)
    show(""c + d = "", add(c, d))
    show(""a + b + d = "", add(a, add(b, d)))
    show(""a * 12345 = "", mul(a, 12345))
}",1511,93
58949,http://rosettacode.org/wiki/Euler%27s_sum_of_powers_conjecture,Euler's sum of powers conjecture,"There is a conjecture in mathematics that held for over two hundred years before it was disproved by the finding of a counterexample in 1966 by Lander and Parkin.



Euler's (disproved) sum of powers   conjecture

  At least  k  positive  kth  powers are required to sum to a  kth  power,  
  except for the trivial case of one  kth power:  yk = yk 



In 1966,   Leon J. Lander   and   Thomas R. Parkin   used a brute-force search on a   CDC 6600   computer restricting numbers to those less than 250.



Task

Write a program to search for an integer solution for:


  x05 + x15 + x25 + x35 == y5 

Where all     xi's   and    y    are distinct integers between   0   and   250   (exclusive).

Show an answer here.



Related tasks

   Pythagorean quadruples. 
   Pythagorean triples.

",#Go,Go,"package main
 
import (
	""fmt""
	""log""
)
 
func main() {
	fmt.Println(eulerSum())
}
 
func eulerSum() (x0, x1, x2, x3, y int) {
	var pow5 [250]int
	for i := range pow5 {
		pow5[i] = i * i * i * i * i
	}
	for x0 = 4; x0 < len(pow5); x0++ {
		for x1 = 3; x1 < x0; x1++ {
			for x2 = 2; x2 < x1; x2++ {
				for x3 = 1; x3 < x2; x3++ {
					sum := pow5[x0] +
						pow5[x1] +
						pow5[x2] +
						pow5[x3]
					for y = x0 + 1; y < len(pow5); y++ {
						if sum == pow5[y] {
							return
						}
					}
				}
			}
		}
	}
	log.Fatal(""no solution"")
	return
}",553,36
58999,http://rosettacode.org/wiki/Empty_directory,Empty directory,"Starting with a path to some directory, determine whether the directory is empty.

An empty directory contains no files nor subdirectories.
With Unix or Windows systems, every directory contains an entry for “.” and almost every directory contains “..” (except for a root directory); an empty directory contains no other entries.
",#Go,Go,"package main
 
import (
	""fmt""
	""io/ioutil""
	""log""
)
 
func main() {
	empty, err := IsEmptyDir(""/tmp"")
	if err != nil {
		log.Fatalln(err)
	}
	if empty {
		fmt.Printf(""/tmp is empty\n"")
	} else {
		fmt.Printf(""/tmp is not empty\n"")
	}
}
 
func IsEmptyDir(name string) (bool, error) {
	entries, err := ioutil.ReadDir(name)
	if err != nil {
		return false, err
	}
	return len(entries) == 0, nil
}
 ",396,28
59284,http://rosettacode.org/wiki/Emirp_primes,Emirp primes,"An   emirp   (prime spelled backwards)   are primes that when reversed   (in their decimal representation)   are a different prime.

(This rules out palindromic primes.)



Task

   show the first   twenty   emirps
   show all emirps between   7,700   and   8,000
   show the   10,000th   emirp


In each list, the numbers should be in order.

Invoke the (same) program once per task requirement, this will show what limit is used as the upper bound for calculating surplus (regular) primes.

The specific method of how to determine if a range or if specific values are to be shown will be left to the programmer.



See also

   Wikipedia, Emirp.
   The Prime Pages, emirp.
   Wolfram MathWorld™, Emirp.
   The On‑Line Encyclopedia of Integer Sequences, emirps (A6567).

",#Go,Go,"package main
 
import (
	""flag""
	""fmt""
	""github.com/jbarham/primegen.go"" // Sieve of Atkin implementation
	""math""
)
 
// primeCache is a simple cache of small prime numbers, it very
// well might be faster to just regenerate them as needed.
type primeCache struct {
	gen    *primegen.Primegen
	primes []uint64
}
 
func NewPrimeCache() primeCache {
	g := primegen.New()
	return primeCache{gen: g, primes: []uint64{g.Next()}}
}
 
// upto returns a slice of primes <= n.
// The returned slice is shared with all callers, do not modify it!
func (pc *primeCache) upto(n uint64) []uint64 {
	if p := pc.primes[len(pc.primes)-1]; p <= n {
		for p <= n {
			p = pc.gen.Next()
			pc.primes = append(pc.primes, p)
		}
		return pc.primes[:len(pc.primes)-1]
	}
	for i, p := range pc.primes {
		if p > n {
			return pc.primes[:i]
		}
	}
	panic(""not reached"")
}
 
var cache = NewPrimeCache()
 
func sqrt(x uint64) uint64 { return uint64(math.Sqrt(float64(x))) }
 
// isprime does a simple test if n is prime.
// See also math/big.ProbablyPrime().
func isprime(n uint64) bool {
	for _, p := range cache.upto(sqrt(n)) {
		if n%p == 0 {
			return false
		}
	}
	return true
}
 
func reverse(n uint64) (r uint64) {
	for n > 0 {
		r = 10*r + n%10
		n /= 10
	}
	return
}
 
// isEmirp does a simple test if n is Emirp, n must be prime
func isEmirp(n uint64) bool {
	r := reverse(n)
	return r != n && isprime(r)
}
 
// EmirpGen is a sequence generator for Emirp primes
type EmirpGen struct {
	pgen     *primegen.Primegen
	nextn    uint64
	r1l, r1h uint64
	r2l, r2h uint64
	r3l, r3h uint64
}
 
func NewEmirpGen() *EmirpGen {
	e := &EmirpGen{pgen: primegen.New()}
	e.Reset()
	return e
}
 
func (e *EmirpGen) Reset() {
	e.pgen.Reset()
	e.nextn = 0
	// Primes >7 cannot end in 2,4,5,6,8 (leaving 1,3,7)
	e.r1l, e.r1h = 20, 30
	e.r2l, e.r2h = 40, 70
	e.r3l, e.r3h = 80, 90
}
 
func (e *EmirpGen) next() (n uint64) {
	for n = e.pgen.Next(); !isEmirp(n); n = e.pgen.Next() {
		// Skip over inpossible ranges
		// Benchmarks show this saves ~20% when generating n upto 1e6
		switch {
		case e.r1l <= n && n < e.r1h:
			e.pgen.SkipTo(e.r1h)
		case e.r2l <= n && n < e.r2h:
			e.pgen.SkipTo(e.r2h)
		case e.r3l <= n && n < e.r3h:
			e.pgen.SkipTo(e.r3h)
		case n > e.r3h:
			e.r1l *= 10
			e.r1h *= 10
			e.r2l *= 10
			e.r2h *= 10
			e.r3l *= 10
			e.r3h *= 10
		}
	}
	return
}
 
func (e *EmirpGen) Next() (n uint64) {
	if n = e.nextn; n != 0 {
		e.nextn = 0
		return
	}
	return e.next()
}
 
func (e *EmirpGen) Peek() uint64 {
	if e.nextn == 0 {
		e.nextn = e.next()
	}
	return e.nextn
}
 
func (e *EmirpGen) SkipTo(nn uint64) {
	e.pgen.SkipTo(nn)
	e.nextn = 0
	return
}
 
// SequenceGen defines an arbitrary sequence generator.
// Both *primegen.Primegen and *EmirpGen implement this.
type SequenceGen interface {
	Next() uint64
	Peek() uint64
	Reset()
	SkipTo(uint64)
	//Count(uint64) uint64 // not implemented for *EmirpGen
}
 
func main() {
	var start, end uint64
	var n, skip uint
	var oneline, primes bool
	flag.UintVar(&n, ""n"", math.MaxUint64, ""number of emirps to print"")
	flag.UintVar(&skip, ""skip"", 0, ""number of emirps to skip"")
	flag.Uint64Var(&start, ""start"", 0, ""start at x>=start"")
	flag.Uint64Var(&end, ""end"", math.MaxUint64, ""stop at x<=end"")
	flag.BoolVar(&oneline, ""oneline"", false, ""output on a single line"")
	flag.BoolVar(&primes, ""primes"", false, ""generate primes rather than emirps"")
	flag.Parse()
 
	sep := ""\n""
	if oneline {
		sep = "" ""
	}
 
	// Here's where making SequenceGen an interface comes in handy:
	var seq SequenceGen
	if primes {
		seq = primegen.New()
	} else {
		seq = NewEmirpGen()
	}
 
	for seq.Peek() < start {
		seq.Next()
	}
	for ; skip > 0; skip-- {
		seq.Next()
	}
	for ; n > 0 && seq.Peek() <= end; n-- {
		fmt.Print(seq.Next(), sep)
	}
	if oneline {
		fmt.Println()
	}
}",3784,184
59338,http://rosettacode.org/wiki/Entropy,Entropy,"Task

Calculate the Shannon entropy   H   of a given input string.

Given the discrete random variable 



X


{\displaystyle X}

 that is a string of 



N


{\displaystyle N}

 ""symbols"" (total characters) consisting of 



n


{\displaystyle n}

 different characters (n=2 for binary), the Shannon entropy of X in bits/symbol is :






H

2


(
X
)
=
−

∑

i
=
1


n





c
o
u
n

t

i



N



log

2


⁡

(



c
o
u
n

t

i



N


)



{\displaystyle H_{2}(X)=-\sum _{i=1}^{n}{\frac {count_{i}}{N}}\log _{2}\left({\frac {count_{i}}{N}}\right)}


where 



c
o
u
n

t

i




{\displaystyle count_{i}}

 is the count of character 




n

i




{\displaystyle n_{i}}

.

For this task, use X=""1223334444"" as an example. The result should be 1.84644... bits/symbol. This assumes X was a random variable, which may not be the case, or it may depend on the observer.

This coding problem calculates the ""specific"" or ""intensive"" entropy that finds its parallel in physics with ""specific entropy"" S0 which is entropy per kg or per mole, not like physical entropy S and therefore not the ""information"" content of a file. It comes from Boltzmann's H-theorem where 



S
=

k

B


N
H


{\displaystyle S=k_{B}NH}

 where N=number of molecules. Boltzmann's H is the same equation as Shannon's H, and it gives the specific entropy H on a ""per molecule"" basis.

The ""total"", ""absolute"", or ""extensive"" information entropy is





S
=

H

2


N


{\displaystyle S=H_{2}N}

 bits
This is not the entropy being coded here, but it is the closest to physical entropy and a measure of the information content of a string. But it does not look for any patterns that might be available for compression, so it is a very restricted, basic, and certain measure of ""information"". Every binary file with an equal number of 1's and 0's will have S=N bits. All hex files with equal symbol frequencies will have 



S
=
N

log

2


⁡
(
16
)


{\displaystyle S=N\log _{2}(16)}

 bits of entropy. The total entropy in bits of the example above is S= 10*18.4644 = 18.4644 bits.

The H function does not look for any patterns in data or check if X was a random variable. For example, X=000000111111 gives the same calculated entropy in all senses as Y=010011100101. For most purposes it is usually more relevant to divide the gzip length by the length of the original data to get an informal measure of how much ""order"" was in the data.

Two other ""entropies"" are useful:

Normalized specific entropy:






H

n


=




H

2


∗
log
⁡
(
2
)


log
⁡
(
n
)





{\displaystyle H_{n}={\frac {H_{2}*\log(2)}{\log(n)}}}

 
which varies from 0 to 1 and it has units of ""entropy/symbol"" or just 1/symbol. For this example, Hn<\sub>= 0.923.

Normalized total (extensive) entropy:






S

n


=




H

2


N
∗
log
⁡
(
2
)


log
⁡
(
n
)





{\displaystyle S_{n}={\frac {H_{2}N*\log(2)}{\log(n)}}}


which varies from 0 to N and does not have units. It is simply the ""entropy"", but it needs to be called ""total normalized extensive entropy"" so that it is not confused with Shannon's (specific) entropy or physical entropy. For this example, Sn<\sub>= 9.23.

Shannon himself is the reason his ""entropy/symbol"" H function is very confusingly called ""entropy"". That's like calling a function that returns a speed a ""meter"". See section 1.7 of his classic A Mathematical Theory of Communication and search on ""per symbol"" and ""units"" to see he always stated his entropy H has units of ""bits/symbol"" or ""entropy/symbol"" or ""information/symbol"". So it is legitimate to say entropy NH is ""information"".

In keeping with Landauer's limit, the physics entropy generated from erasing N bits is 



S
=

H

2


N

k

B


ln
⁡
(
2
)


{\displaystyle S=H_{2}Nk_{B}\ln(2)}

 if the bit storage device is perfectly efficient. This can be solved for H2*N to (arguably) get the number of bits of information that a physical entropy represents.

Related tasks

 Fibonacci_word
 Entropy/Narcissist

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""strings""
)
 
func main(){
    fmt.Println(H(""1223334444""))
}
 
func H(data string) (entropy float64) {
    if data == """" {
        return 0
    }
    for i := 0; i < 256; i++ {
        px := float64(strings.Count(data, string(byte(i)))) / float64(len(data))
        if px > 0 {
	    entropy += -px * math.Log2(px)
	}
    }
    return entropy
}",393,24
59456,http://rosettacode.org/wiki/Even_or_odd,Even or odd,"Task

Test whether an integer is even or odd.

There is more than one way to solve this task:

 Use the even and odd predicates, if the language provides them.
 Check the least significant digit. With binary integers, i bitwise-and 1 equals 0 iff i is even, or equals 1 iff i is odd.
 Divide i by 2. The remainder equals 0 iff i is even. The remainder equals +1 or -1 iff i is odd.
 Use modular congruences:
 i ≡ 0 (mod 2) iff i is even.
 i ≡ 1 (mod 2) iff i is odd.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    test(-2)
    test(-1)
    test(0)
    test(1)
    test(2)
    testBig(""-222222222222222222222222222222222222"")
    testBig(""-1"")
    testBig(""0"")
    testBig(""1"")
    testBig(""222222222222222222222222222222222222"")
}
 
func test(n int) {
    fmt.Printf(""Testing integer %3d:  "", n)
    // & 1 is a good way to test
    if n&1 == 0 {
        fmt.Print(""even "")
    } else {
        fmt.Print("" odd "")
    }
    // Careful when using %: negative n % 2 returns -1.  So, the code below
    // works, but can be broken by someone thinking they can reverse the
    // test by testing n % 2 == 1.  The valid reverse test is n % 2 != 0.
    if n%2 == 0 {
        fmt.Println(""even"")
    } else {
        fmt.Println("" odd"")
    }
}
 
func testBig(s string) {
    b, _ := new(big.Int).SetString(s, 10)
    fmt.Printf(""Testing big integer %v:  "", b)
    // the Bit function is the only sensible test for big ints.
    if b.Bit(0) == 0 {
        fmt.Println(""even"")
    } else {
        fmt.Println(""odd"")
    }
}",1073,48
59511,http://rosettacode.org/wiki/Empty_string,Empty string,"Languages may have features for dealing specifically with empty strings
(those containing no characters).



Task

   Demonstrate how to assign an empty string to a variable.
   Demonstrate how to check that a string is empty.
   Demonstrate how to check that a string is not empty.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"// define and initialize an empty string
var s string
s2 := """"
 
// assign an empty string to a variable
s = """"
 
// check that a string is empty, any of:
s == """"
len(s) == 0
 
// check that a string is not empty, any of:
s != """"
len(s) != 0 // or > 0",251,14
59533,http://rosettacode.org/wiki/Ethiopian_multiplication,Ethiopian multiplication,"Ethiopian multiplication is a method of multiplying integers using only addition, doubling, and halving.


Method:

 Take two numbers to be multiplied and write them down at the top of two columns.
 In the left-hand column repeatedly halve the last number, discarding any remainders, and write the result below the last in the same column, until you write a value of 1.
 In the right-hand column repeatedly double the last number and write the result below. stop when you add a result in the same row as where the left hand column shows 1.
 Examine the table produced and discard any row where the value in the left column is even.
 Sum the values in the right-hand column that remain to produce the result of multiplying the original two numbers together

For example:   17 × 34

       17    34

Halving the first column:

       17    34
        8
        4
        2
        1

Doubling the second column:

       17    34
        8    68
        4   136 
        2   272
        1   544

Strike-out rows whose first cell is even:

       17    34
        8    68 
        4   136 
        2   272 
        1   544

Sum the remaining numbers in the right-hand column:

       17    34
        8    -- 
        4   --- 
        2   --- 
        1   544
           ====
            578

So 17 multiplied by 34, by the Ethiopian method is 578.



Task

The task is to define three named functions/methods/procedures/subroutines:

 one to halve an integer,
 one to double an integer, and
 one to state if an integer is even.


Use these functions to create a function that does Ethiopian multiplication.



References

Ethiopian multiplication explained (BBC Video clip)
A Night Of Numbers - Go Forth And Multiply (Video)
Russian Peasant Multiplication
Programming Praxis: Russian Peasant Multiplication

",#Go,Go,"package main
 
import ""fmt""
 
func halve(i int) int { return i/2 }
 
func double(i int) int { return i*2 }
 
func isEven(i int) bool { return i%2 == 0 }
 
func ethMulti(i, j int) (r int) {
    for ; i > 0; i, j = halve(i), double(j) {
        if !isEven(i) {
            r += j
        }
    }
    return
}
 
func main() {
    fmt.Printf(""17 ethiopian 34 = %d\n"", ethMulti(17, 34))
}",383,22
59648,http://rosettacode.org/wiki/Empty_program,Empty program,"Task

Create the simplest possible program that is still considered ""correct.""



",#Go,Go,"package main
func main() { }",28,2
59956,http://rosettacode.org/wiki/EKG_sequence_convergence,EKG sequence convergence,"The sequence is from the natural numbers and is defined by:

 a(1) = 1; 
 a(2) = Start = 2;
 for n > 2, a(n) shares at least one prime factor with a(n-1) and is the smallest such natural number not already used.

The sequence is called the EKG sequence (after its visual similarity to an electrocardiogram when graphed).

Variants of the sequence can be generated starting 1, N where N is any natural number larger than one. For the purposes of this task let us call:

 The sequence described above , starting 1, 2, ... the EKG(2) sequence;
 the sequence starting 1, 3, ... the EKG(3) sequence; 
 ... the sequence starting 1, N, ... the EKG(N) sequence.


Convergence
If an algorithm that keeps track of the minimum amount of numbers and their corresponding prime factors used to generate the next term is used, then this may be known as the generators essential state. Two EKG generators with differing starts can converge to produce the same sequence after initial differences.

EKG(N1) and EKG(N2) are said to to have converged at and after generation a(c) if state_of(EKG(N1).a(c)) == state_of(EKG(N2).a(c)).



Task

 Calculate and show here the first 10 members of EKG(2).
 Calculate and show here the first 10 members of EKG(5).
 Calculate and show here the first 10 members of EKG(7).
 Calculate and show here the first 10 members of EKG(9).
 Calculate and show here the first 10 members of EKG(10).
 Calculate and show here at which term EKG(5) and EKG(7) converge   (stretch goal).
Related Tasks

 Greatest common divisor
 Sieve of Eratosthenes


Reference

 The EKG Sequence and the Tree of Numbers. (Video).

",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
func contains(a []int, b int) bool {
    for _, j := range a {
        if j == b {
            return true
        }
    }
    return false
}
 
func gcd(a, b int) int {
    for a != b {
        if a > b {
            a -= b
        } else {
            b -= a
        }
    }
    return a
}
 
func areSame(s, t []int) bool {
    le := len(s)
    if le != len(t) {
        return false
    }
    sort.Ints(s)
    sort.Ints(t)
    for i := 0; i < le; i++ {
        if s[i] != t[i] {
            return false
        }
    }
    return true
}
 
func main() {
    const limit = 100
    starts := [5]int{2, 5, 7, 9, 10}
    var ekg [5][limit]int
 
    for s, start := range starts {
        ekg[s][0] = 1
        ekg[s][1] = start
        for n := 2; n < limit; n++ {
            for i := 2; ; i++ {
                // a potential sequence member cannot already have been used
                // and must have a factor in common with previous member
                if !contains(ekg[s][:n], i) && gcd(ekg[s][n-1], i) > 1 {
                    ekg[s][n] = i
                    break
                }
            }
        }
        fmt.Printf(""EKG(%2d): %v\n"", start, ekg[s][:30])
    }   
 
    // now compare EKG5 and EKG7 for convergence
    for i := 2; i < limit; i++ {
        if ekg[1][i] == ekg[2][i] && areSame(ekg[1][:i], ekg[2][:i]) {
            fmt.Println(""\nEKG(5) and EKG(7) converge at term"", i+1)
            return
        }
    }
    fmt.Println(""\nEKG5(5) and EKG(7) do not converge within"", limit, ""terms"")
}",1574,72
60038,http://rosettacode.org/wiki/Elementary_cellular_automaton/Infinite_length,Elementary cellular automaton/Infinite length,"The purpose of this task is to create a version of an Elementary cellular automaton whose number of cells is only limited by the memory size of the computer.

To be precise, consider the state of the automaton to be made of an infinite number of cells, but with a bounded support. In other words, to describe the state of the automaton, you need a finite number of adjacent cells, along with their individual state, and you then consider that the individual state of each of all other cells is the negation of the closest individual cell among the previously defined finite number of cells.

Examples:

1        ->   ..., 0, 0,      1,      0, 0, ...
0, 1     ->   ..., 1, 1,   0, 1,      0, 0, ...
1, 0, 1  ->   ..., 0, 0,   1, 0, 1,   0, 0, ...

More complex methods can be imagined, provided it is possible to somehow encode the infinite sections. But for this task we will stick to this simple version.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func btoi(b bool) int {
    if b {
        return 1
    }
    return 0
}
 
func evolve(l, rule int) {
    fmt.Printf("" Rule #%d:\n"", rule)
    cells := ""O""
    for x := 0; x < l; x++ {
        cells = addNoCells(cells)
        width := 40 + (len(cells) >> 1)
        fmt.Printf(""%*s\n"", width, cells)
        cells = step(cells, rule)
    }
}
 
func step(cells string, rule int) string {
    newCells := new(strings.Builder)
    for i := 0; i < len(cells)-2; i++ {
        bin := 0
        b := uint(2)
        for n := i; n < i+3; n++ {
            bin += btoi(cells[n] == 'O') << b
            b >>= 1
        }
        a := '.'
        if rule&(1<<uint(bin)) != 0 {
            a = 'O'
        }
        newCells.WriteRune(a)
    }
    return newCells.String()
}
 
func addNoCells(cells string) string {
    l, r := ""O"", ""O""
    if cells[0] == 'O' {
        l = "".""
    }
    if cells[len(cells)-1] == 'O' {
        r = "".""
    }
    cells = l + cells + r
    cells = l + cells + r
    return cells
}
 
func main() {
    for _, r := range []int{90, 30} {
        evolve(25, r)
        fmt.Println()
    }
}",1161,62
60110,http://rosettacode.org/wiki/Eertree,Eertree,"An eertree is a data structure designed for efficient processing of certain palindrome tasks, for instance counting the number of sub-palindromes in an input string.

The data structure has commonalities to both tries and suffix trees.
  See links below.



Task

Construct an eertree for the string ""eertree"", then output all sub-palindromes by traversing the tree.



See also

   Wikipedia entry:   trie.
   Wikipedia entry:   suffix tree 
   Cornell University Library, Computer Science, Data Structures and Algorithms ───► EERTREE: An Efficient Data Structure for Processing Palindromes in Strings.

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    tree := eertree([]byte(""eertree""))
    fmt.Println(subPalindromes(tree))
}
 
type edges map[byte]int
 
type node struct {
    length int
    edges
    suffix int
}
 
const evenRoot = 0
const oddRoot = 1
 
func eertree(s []byte) []node {
    tree := []node{
        evenRoot: {length: 0, suffix: oddRoot, edges: edges{}},
        oddRoot:  {length: -1, suffix: oddRoot, edges: edges{}},
    }
    suffix := oddRoot
    var n, k int
    for i, c := range s {
        for n = suffix; ; n = tree[n].suffix {
            k = tree[n].length
            if b := i - k - 1; b >= 0 && s[b] == c {
                break
            }
        }
        if e, ok := tree[n].edges[c]; ok {
            suffix = e
            continue
        }
        suffix = len(tree)
        tree = append(tree, node{length: k + 2, edges: edges{}})
        tree[n].edges[c] = suffix
        if tree[suffix].length == 1 {
            tree[suffix].suffix = 0
            continue
        }
        for {
            n = tree[n].suffix
            if b := i - tree[n].length - 1; b >= 0 && s[b] == c {
                break
            }
        }
        tree[suffix].suffix = tree[n].edges[c]
    }
    return tree
}
 
func subPalindromes(tree []node) (s []string) {
    var children func(int, string)
    children = func(n int, p string) {
        for c, n := range tree[n].edges {
            c := string(c)
            p := c + p + c
            s = append(s, p)
            children(n, p)
        }
    }
    children(0, """")
    for c, n := range tree[1].edges {
        c := string(c)
        s = append(s, c)
        children(n, c)
    }
    return
}",1677,74
60165,http://rosettacode.org/wiki/Earliest_difference_between_prime_gaps,Earliest difference between prime gaps,"When calculating prime numbers > 2, the difference between adjacent primes is always an even number. This difference, also referred to as the gap, varies in an random pattern; at least, no pattern has ever been discovered, and it is strongly conjectured that no pattern exists. However, it is also conjectured that between some two adjacent primes will be a gap corresponding to every positive even integer.






gap
minimal
starting
prime
ending
prime


2
3
5


4
7
11


6
23
29


8
89
97


10
139
149


12
199
211


14
113
127


16
1831
1847


18
523
541


20
887
907


22
1129
1151


24
1669
1693


26
2477
2503


28
2971
2999


30
4297
4327


This task involves locating the minimal primes corresponding to those gaps.

Though every gap value exists, they don't seem to come in any particular order. For example, this table shows the gaps and minimum starting value primes for 2 through 30:



For the purposes of this task, considering only primes greater than 2, consider prime gaps that differ by exactly two to be adjacent.



Task
For each order of magnitude m from 10¹ through 10⁶:

 Find the first two sets of adjacent minimum prime gaps where the absolute value of the difference between the prime gap start values is greater than m.


E.G.
For an m of 10¹;

The start value of gap 2 is 3, the start value of gap 4 is 7, the difference is 7 - 3 or 4. 4 < 10¹ so keep going.

The start value of gap 4 is 7, the start value of gap 6 is 23, the difference is 23 - 7, or 16. 16 > 10¹ so this the earliest adjacent gap difference > 10¹.



Stretch goal
 Do the same for 10⁷ and 10⁸ (and higher?) orders of magnitude
Note: the earliest value found for each order of magnitude may not be unique, in fact, is not unique; also, with the gaps in ascending order, the minimal starting values are not strictly ascending.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""rcu""
)
 
func main() {
    limit := int(1e9)
    gapStarts := make(map[int]int)
    primes := rcu.Primes(limit * 5)
    for i := 1; i < len(primes); i++ {
        gap := primes[i] - primes[i-1]
        if _, ok := gapStarts[gap]; !ok {
            gapStarts[gap] = primes[i-1]
        }
    }
    pm := 10
    gap1 := 2
    for {
        for _, ok := gapStarts[gap1]; !ok; {
            gap1 += 2
        }
        start1 := gapStarts[gap1]
        gap2 := gap1 + 2
        if _, ok := gapStarts[gap2]; !ok {
            gap1 = gap2 + 2
            continue
        }
        start2 := gapStarts[gap2]
        diff := start2 - start1
        if diff < 0 {
            diff = -diff
        }
        if diff > pm {
            cpm := rcu.Commatize(pm)
            cst1 := rcu.Commatize(start1)
            cst2 := rcu.Commatize(start2)
            cd := rcu.Commatize(diff)
            fmt.Printf(""Earliest difference > %s between adjacent prime gap starting primes:\n"", cpm)
            fmt.Printf(""Gap %d starts at %s, gap %d starts at %s, difference is %s.\n\n"", gap1, cst1, gap2, cst2, cd)
            if pm == limit {
                break
            }
            pm *= 10
        } else {
            gap1 = gap2
        }
    }
}",1276,50
60253,http://rosettacode.org/wiki/Echo_server,Echo server,"Create a network service that sits on TCP port 12321, which accepts connections on that port, and which echoes complete lines (using a carriage-return/line-feed sequence as line separator) back to clients. No error handling is required. For the purposes of testing, it is only necessary to support connections from localhost (127.0.0.1 or perhaps ::1). Logging of connection information to standard output is recommended.

The implementation must be able to handle simultaneous connections from multiple clients. A multi-threaded or multi-process solution may be used. Each connection must be able to echo more than a single line.

The implementation must not stop responding to other clients if one client sends a partial line or stops reading responses.
",#Go,Go,"package main
 
import (
	""fmt""
	""net""
	""bufio""
)
 
func echo(s net.Conn, i int) {
	defer s.Close();
 
	fmt.Printf(""%d: %v <-> %v\n"", i, s.LocalAddr(), s.RemoteAddr())
	b := bufio.NewReader(s)
	for {
		line, e := b.ReadBytes('\n')
		if e != nil {
			break
		}
		s.Write(line)
	}
	fmt.Printf(""%d: closed\n"", i)
}
 
func main() {
	l, e := net.Listen(""tcp"", "":12321"")
	for i := 0; e == nil; i++ {
		var s net.Conn
		s, e = l.Accept()
		go echo(s, i)
	}
}",450,31
60292,http://rosettacode.org/wiki/Elementary_cellular_automaton,Elementary cellular automaton,"An elementary cellular automaton is a one-dimensional cellular automaton where there are two possible states (labeled 0 and 1) and the rule to determine the state of a cell in the next generation depends only on the current state of the cell and its two immediate neighbors. Those three values can be encoded with three bits.

The rules of evolution are then encoded with eight bits indicating the outcome of each of the eight possibilities 111, 110, 101, 100, 011, 010, 001 and 000 in this order. Thus for instance the rule 13 means that a state is updated to 1 only in the cases 011, 010 and 000, since 13 in binary is 0b00001101.



Task

Create a subroutine, program or function that allows to create and visualize the evolution of any of the 256 possible elementary cellular automaton of arbitrary space length and for any given initial state. You can demonstrate your solution with any automaton of your choice.

The space state should wrap: this means that the left-most cell should be considered as the right neighbor of the right-most cell, and reciprocally.

This task is basically a generalization of one-dimensional cellular automata.



See also
 Cellular automata (natureofcode.com)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""math/rand""
    ""strings""
)
 
func main() {
    const cells = 20
    const generations = 9
    fmt.Println(""Single 1, rule 90:"")
    a := big.NewInt(1)
    a.Lsh(a, cells/2)
    elem(90, cells, generations, a)
    fmt.Println(""Random intial state, rule 30:"")
    a = big.NewInt(1)
    a.Rand(rand.New(rand.NewSource(3)), a.Lsh(a, cells))
    elem(30, cells, generations, a)
}
 
func elem(rule uint, cells, generations int, a *big.Int) {
    output := func() {
        fmt.Println(strings.Replace(strings.Replace(
            fmt.Sprintf(""%0*b"", cells, a), ""0"", "" "", -1), ""1"", ""#"", -1))
    }
    output()
    a1 := new(big.Int)
    set := func(cell int, k uint) {
        a1.SetBit(a1, cell, rule>>k&1)
    }
    last := cells - 1
    for r := 0; r < generations; r++ {
        k := a.Bit(last) | a.Bit(0)<<1 | a.Bit(1)<<2
        set(0, k)
        for c := 1; c < last; c++ {
            k = k>>1 | a.Bit(c+1)<<2
            set(c, k)
        }
        set(last, k>>1|a.Bit(0)<<2)
        a, a1 = a1, a
        output()
    }
}",1081,45
60302,http://rosettacode.org/wiki/Duffinian_numbers,Duffinian numbers,"A Duffinian number is a composite number k that is relatively prime to its sigma sum σ.

The sigma sum of k is the sum of the divisors of k.



E.G.
161 is a Duffinian number.

 It is composite. (7 × 23)
 The sigma sum 192 (1 + 7 + 23 + 161) is relatively prime to 161. 


Duffinian numbers are very common.

It is not uncommon for two consecutive integers to be Duffinian (a Duffinian twin) (8, 9), (35, 36), (49, 50), etc.

Less common are Duffinian triplets; three consecutive Duffinian numbers. (63, 64, 65), (323, 324, 325), etc.

Much, much less common are Duffinian quadruplets and quintuplets. The first Duffinian quintuplet is (202605639573839041, 202605639573839042, 202605639573839043, 202605639573839044, 202605639573839045).

It is not possible to have six consecutive Duffinian numbers



Task
 Find and show the first 50 Duffinian numbers.
 Find and show at least the first 15 Duffinian triplets.


See also
 Numbers Aplenty - Duffinian numbers
 OEIS:A003624 - Duffinian numbers: composite numbers k relatively prime to sigma(k)



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""rcu""
)
 
func isSquare(n int) bool {
    s := int(math.Sqrt(float64(n)))
    return s*s == n
}
 
func main() {
    limit := 200000 // say
    d := rcu.PrimeSieve(limit-1, true)
    d[1] = false
    for i := 2; i < limit; i++ {
        if !d[i] {
            continue
        }
        if i%2 == 0 && !isSquare(i) && !isSquare(i/2) {
            d[i] = false
            continue
        }
        sigmaSum := rcu.SumInts(rcu.Divisors(i))
        if rcu.Gcd(sigmaSum, i) != 1 {
            d[i] = false
        }
    }
 
    var duff []int
    for i := 1; i < len(d); i++ {
        if d[i] {
            duff = append(duff, i)
        }
    }
    fmt.Println(""First 50 Duffinian numbers:"")
    rcu.PrintTable(duff[0:50], 10, 3, false)
 
    var triplets [][3]int
    for i := 2; i < limit; i++ {
        if d[i] && d[i-1] && d[i-2] {
            triplets = append(triplets, [3]int{i - 2, i - 1, i})
        }
    }
    fmt.Println(""\nFirst 56 Duffinian triplets:"")
    for i := 0; i < 14; i++ {
        s := fmt.Sprintf(""%6v"", triplets[i*4:i*4+4])
        fmt.Println(s[1 : len(s)-1])
    }
}",1141,52
60385,http://rosettacode.org/wiki/Element-wise_operations,Element-wise operations,"This task is similar to:

   Matrix multiplication
   Matrix transposition


Task

Implement basic element-wise matrix-matrix and scalar-matrix operations, which can be referred to in other, higher-order tasks.

Implement:

   addition
   subtraction
   multiplication
   division
   exponentiation


Extend the task if necessary to include additional basic operations, which should not require their own specialised task.



",#Go,Go,"package element
 
import (
    ""fmt""
    ""math""
)
 
type Matrix struct {
    ele    []float64
    stride int
}
 
func MatrixFromRows(rows [][]float64) Matrix {
    if len(rows) == 0 {
        return Matrix{nil, 0}
    }
    m := Matrix{make([]float64, len(rows)*len(rows[0])), len(rows[0])}
    for rx, row := range rows {
        copy(m.ele[rx*m.stride:(rx+1)*m.stride], row)
    }
    return m
}
 
func like(m Matrix) Matrix {
    return Matrix{make([]float64, len(m.ele)), m.stride}
}
 
func (m Matrix) String() string {
    s := """"
    for e := 0; e < len(m.ele); e += m.stride {
        s += fmt.Sprintf(""%6.3f \n"", m.ele[e:e+m.stride])
    }
    return s
}
 
type binaryFunc64 func(float64, float64) float64
 
func elementWiseMM(m1, m2 Matrix, f binaryFunc64) Matrix {
    z := like(m1)
    for i, m1e := range m1.ele {
        z.ele[i] = f(m1e, m2.ele[i])
    }
    return z
}
 
func elementWiseMS(m Matrix, s float64, f binaryFunc64) Matrix {
    z := like(m)
    for i, e := range m.ele {
        z.ele[i] = f(e, s)
    }
    return z
}
 
func add(a, b float64) float64 { return a + b }
func sub(a, b float64) float64 { return a - b }
func mul(a, b float64) float64 { return a * b }
func div(a, b float64) float64 { return a / b }
func exp(a, b float64) float64 { return math.Pow(a, b) }
 
func AddMatrix(m1, m2 Matrix) Matrix { return elementWiseMM(m1, m2, add) }
func SubMatrix(m1, m2 Matrix) Matrix { return elementWiseMM(m1, m2, sub) }
func MulMatrix(m1, m2 Matrix) Matrix { return elementWiseMM(m1, m2, mul) }
func DivMatrix(m1, m2 Matrix) Matrix { return elementWiseMM(m1, m2, div) }
func ExpMatrix(m1, m2 Matrix) Matrix { return elementWiseMM(m1, m2, exp) }
 
func AddScalar(m Matrix, s float64) Matrix { return elementWiseMS(m, s, add) }
func SubScalar(m Matrix, s float64) Matrix { return elementWiseMS(m, s, sub) }
func MulScalar(m Matrix, s float64) Matrix { return elementWiseMS(m, s, mul) }
func DivScalar(m Matrix, s float64) Matrix { return elementWiseMS(m, s, div) }
func ExpScalar(m Matrix, s float64) Matrix { return elementWiseMS(m, s, exp) }",2070,70
60391,http://rosettacode.org/wiki/Egyptian_fractions,Egyptian fractions,"An   Egyptian fraction   is the sum of distinct unit fractions such as:

  






1
2



+



1
3



+



1
16




(
=



43
48



)


{\displaystyle {\tfrac {1}{2}}+{\tfrac {1}{3}}+{\tfrac {1}{16}}\,(={\tfrac {43}{48}})}

 
Each fraction in the expression has a numerator equal to   1   (unity)   and a denominator that is a positive integer,   and all the denominators are distinct   (i.e., no repetitions).

Fibonacci's   Greedy algorithm for Egyptian fractions   expands the fraction    






x
y





{\displaystyle {\tfrac {x}{y}}}

    to be represented by repeatedly performing the replacement

  





x
y


=


1

⌈
y

/

x
⌉



+



(
−
y
)





mod


x


y
⌈
y

/

x
⌉





{\displaystyle {\frac {x}{y}}={\frac {1}{\lceil y/x\rceil }}+{\frac {(-y)\!\!\!\!\mod x}{y\lceil y/x\rceil }}}

 


(simplifying the 2nd term in this replacement as necessary, and where    



⌈
x
⌉


{\displaystyle \lceil x\rceil }

    is the   ceiling   function).



For this task,   Proper and improper fractions   must be able to be expressed.



Proper  fractions   are of the form    






a
b





{\displaystyle {\tfrac {a}{b}}}

    where    



a


{\displaystyle a}

    and    



b


{\displaystyle b}

    are positive integers, such that    



a
<
b


{\displaystyle a<b}

,     and

improper fractions are of the form    






a
b





{\displaystyle {\tfrac {a}{b}}}

    where    



a


{\displaystyle a}

    and    



b


{\displaystyle b}

    are positive integers, such that    a ≥ b.



(See the REXX programming example to view one method of expressing the whole number part of an improper fraction.)

For improper fractions, the integer part of any improper fraction should be first isolated and shown preceding the Egyptian unit fractions, and be surrounded by square brackets [n].



Task requirements

   show the Egyptian fractions for: 






43
48





{\displaystyle {\tfrac {43}{48}}}

 and 






5
121





{\displaystyle {\tfrac {5}{121}}}

 and 






2014
59





{\displaystyle {\tfrac {2014}{59}}}


   for all proper fractions,    






a
b





{\displaystyle {\tfrac {a}{b}}}

    where    



a


{\displaystyle a}

    and    



b


{\displaystyle b}

    are positive one-or two-digit (decimal) integers, find and show an Egyptian fraction that has:
   the largest number of terms,
   the largest denominator.
   for all one-, two-, and three-digit integers,   find and show (as above).     {extra credit}


Also see

   Wolfram MathWorld™ entry: Egyptian fraction

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""strings""
)
 
var zero = new(big.Int)
var one = big.NewInt(1)
 
func toEgyptianRecursive(br *big.Rat, fracs []*big.Rat) []*big.Rat {
    if br.Num().Cmp(zero) == 0 {
        return fracs
    }
    iquo := new(big.Int)
    irem := new(big.Int)
    iquo.QuoRem(br.Denom(), br.Num(), irem)
    if irem.Cmp(zero) > 0 {
        iquo.Add(iquo, one)
    }
    rquo := new(big.Rat).SetFrac(one, iquo)
    fracs = append(fracs, rquo)
    num2 := new(big.Int).Neg(br.Denom())
    num2.Rem(num2, br.Num())
    if num2.Cmp(zero) < 0 {
        num2.Add(num2, br.Num())
    }
    denom2 := new(big.Int)
    denom2.Mul(br.Denom(), iquo)
    f := new(big.Rat).SetFrac(num2, denom2)
    if f.Num().Cmp(one) == 0 {
        fracs = append(fracs, f)
        return fracs
    }
    fracs = toEgyptianRecursive(f, fracs)
    return fracs
}
 
func toEgyptian(rat *big.Rat) []*big.Rat {
    if rat.Num().Cmp(zero) == 0 {
        return []*big.Rat{rat}
    }
    var fracs []*big.Rat
    if rat.Num().CmpAbs(rat.Denom()) >= 0 {
        iquo := new(big.Int)
        iquo.Quo(rat.Num(), rat.Denom())
        rquo := new(big.Rat).SetFrac(iquo, one)
        rrem := new(big.Rat)
        rrem.Sub(rat, rquo)
        fracs = append(fracs, rquo)
        fracs = toEgyptianRecursive(rrem, fracs)
    } else {
        fracs = toEgyptianRecursive(rat, fracs)
    }
    return fracs
}
 
func main() {
    fracs := []*big.Rat{big.NewRat(43, 48), big.NewRat(5, 121), big.NewRat(2014, 59)}
    for _, frac := range fracs {
        list := toEgyptian(frac)
        if list[0].Denom().Cmp(one) == 0 {
            first := fmt.Sprintf(""[%v]"", list[0].Num())
            temp := make([]string, len(list)-1)
            for i := 1; i < len(list); i++ {
                temp[i-1] = list[i].String()
            }
            rest := strings.Join(temp, "" + "")
            fmt.Printf(""%v -> %v + %s\n"", frac, first, rest)
        } else {
            temp := make([]string, len(list))
            for i := 0; i < len(list); i++ {
                temp[i] = list[i].String()
            }
            all := strings.Join(temp, "" + "")
            fmt.Printf(""%v -> %s\n"", frac, all)
        }
    }
 
    for _, r := range [2]int{98, 998} {
        if r == 98 {
            fmt.Println(""\nFor proper fractions with 1 or 2 digits:"")
        } else {
            fmt.Println(""\nFor proper fractions with 1, 2 or 3 digits:"")
        }
        maxSize := 0
        var maxSizeFracs []*big.Rat
        maxDen := zero
        var maxDenFracs []*big.Rat
        var sieve = make([][]bool, r+1) // to eliminate duplicates
        for i := 0; i <= r; i++ {
            sieve[i] = make([]bool, r+2)
        }
        for i := 1; i <= r; i++ {
            for j := i + 1; j <= r+1; j++ {
                if sieve[i][j] {
                    continue
                }
                f := big.NewRat(int64(i), int64(j))
                list := toEgyptian(f)
                listSize := len(list)
                if listSize > maxSize {
                    maxSize = listSize
                    maxSizeFracs = maxSizeFracs[0:0]
                    maxSizeFracs = append(maxSizeFracs, f)
                } else if listSize == maxSize {
                    maxSizeFracs = append(maxSizeFracs, f)
                }
                listDen := list[len(list)-1].Denom()
                if listDen.Cmp(maxDen) > 0 {
                    maxDen = listDen
                    maxDenFracs = maxDenFracs[0:0]
                    maxDenFracs = append(maxDenFracs, f)
                } else if listDen.Cmp(maxDen) == 0 {
                    maxDenFracs = append(maxDenFracs, f)
                }
                if i < r/2 {
                    k := 2
                    for {
                        if j*k > r+1 {
                            break
                        }
                        sieve[i*k][j*k] = true
                        k++
                    }
                }
            }
        }
        fmt.Println(""  largest number of items ="", maxSize)
        fmt.Println(""  fraction(s) with this number :"", maxSizeFracs)
        md := maxDen.String()
        fmt.Print(""  largest denominator = "", len(md), "" digits, "")
        fmt.Print(md[0:20], ""..."", md[len(md)-20:], ""\b\n"")
        fmt.Println(""  fraction(s) with this denominator :"", maxDenFracs)
    }
}",4364,137
60426,http://rosettacode.org/wiki/Egyptian_division,Egyptian division,"Egyptian division is a method of dividing integers using addition and
doubling that is similar to the algorithm of Ethiopian multiplication

Algorithm:

Given two numbers where the dividend is to be divided by the divisor:

 Start the construction of a table of two columns: powers_of_2, and doublings; by a first row of a 1 (i.e. 2^0) in the first column and 1 times the divisor in the first row second column.
 Create the second row with columns of 2 (i.e 2^1), and 2 * divisor in order.
 Continue with successive i’th rows of 2^i and 2^i * divisor.
 Stop adding rows, and keep only those rows, where 2^i * divisor is less than or equal to the dividend.
 We now assemble two separate sums that both start as zero, called here answer and accumulator
 Consider each row of the table, in the reverse order of its construction.
 If the current value of the accumulator added to the doublings cell would be less than or equal to the dividend then add it to the accumulator, as well as adding the powers_of_2 cell value to the answer.
 When the first row has been considered as above, then the integer division of dividend by divisor is given by answer.
 (And the remainder is given by the absolute value of accumulator - dividend).


Example: 580 / 34

 Table creation: 



 powers_of_2

 doublings


 1

 34


 2

 68


 4

 136


 8

 272


 16

 544

 Initialization of sums: 



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272






 16

 544










 0

 0

 Considering table rows, bottom-up: 

When a row is considered it is shown crossed out if it is not accumulated, or bold if the row causes summations.



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272






 16

 544

 16

 544



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272

 16

 544


 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136

 16

 544


 8

 272






 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68

 16

 544


 4

 136






 8

 272






 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34

 17

 578


 2

 68






 4

 136






 8

 272






 16

 544





Answer

So 580 divided by 34 using the Egyptian method is 17 remainder (578 - 580) or 2.



Task

The task is to create a function that does Egyptian division. The function should

closely follow the description above in using a list/array of powers of two, and

another of doublings.

 Functions should be clear interpretations of the algorithm.
 Use the function to divide 580 by 34 and show the answer here, on this page.


Related tasks

   Egyptian fractions


References

   Egyptian Number System

",#Go,Go,"package main
 
import ""fmt""
 
func egyptianDivide(dividend, divisor int) (quotient, remainder int) {
    if dividend < 0 || divisor <= 0 {
        panic(""Invalid argument(s)"")
    }
    if dividend < divisor {
        return 0, dividend
    }
    powersOfTwo := []int{1}
    doublings := []int{divisor}
    doubling := divisor
    for {
        doubling *= 2
        if doubling > dividend {
            break
        }
        l := len(powersOfTwo)
        powersOfTwo = append(powersOfTwo, powersOfTwo[l-1]*2)
        doublings = append(doublings, doubling)
    }
    answer := 0
    accumulator := 0
    for i := len(doublings) - 1; i >= 0; i-- {
        if accumulator+doublings[i] <= dividend {
            accumulator += doublings[i]
            answer += powersOfTwo[i]
            if accumulator == dividend {
                break
            }
        }
    }
    return answer, dividend - accumulator
}
 
func main() {
    dividend := 580
    divisor := 34
    quotient, remainder := egyptianDivide(dividend, divisor)
    fmt.Println(dividend, ""divided by"", divisor, ""is"", quotient, ""with remainder"", remainder)
}",1124,43
60438,http://rosettacode.org/wiki/Eban_numbers,Eban numbers,"

Definition

An   eban   number is a number that has no letter    e    in it when the number is spelled in English.

Or more literally,   spelled numbers that contain the letter   e   are banned.



The American version of spelling numbers will be used here   (as opposed to the British).

2,000,000,000   is two billion,   not   two milliard.



Only numbers less than   one sextillion   (1021)   will be considered in/for this task.

This will allow optimizations to be used.



Task

   show all eban numbers   ≤   1,000   (in a horizontal format),   and a count
   show all eban numbers between   1,000   and   4,000   (inclusive),   and a count
   show a count of all eban numbers up and including           10,000
   show a count of all eban numbers up and including         100,000
   show a count of all eban numbers up and including      1,000,000
   show a count of all eban numbers up and including    10,000,000
   show all output here.


See also

   The MathWorld entry:   eban numbers.
   The OEIS entry:   A6933, eban numbers.

",#Go,Go,"package main
 
import ""fmt""
 
type Range struct {
    start, end uint64
    print      bool
}
 
func main() {
    rgs := []Range{
        {2, 1000, true},
        {1000, 4000, true},
        {2, 1e4, false},
        {2, 1e5, false},
        {2, 1e6, false},
        {2, 1e7, false},
        {2, 1e8, false},
        {2, 1e9, false},
    }
    for _, rg := range rgs {
        if rg.start == 2 {
            fmt.Printf(""eban numbers up to and including %d:\n"", rg.end)
        } else {
            fmt.Printf(""eban numbers between %d and %d (inclusive):\n"", rg.start, rg.end)
        }
        count := 0
        for i := rg.start; i <= rg.end; i += 2 {
            b := i / 1000000000
            r := i % 1000000000
            m := r / 1000000
            r = i % 1000000
            t := r / 1000
            r %= 1000
            if m >= 30 && m <= 66 {
                m %= 10
            }
            if t >= 30 && t <= 66 {
                t %= 10
            }
            if r >= 30 && r <= 66 {
                r %= 10
            }
            if b == 0 || b == 2 || b == 4 || b == 6 {             
                if m == 0 || m == 2 || m == 4 || m == 6 {
                    if t == 0 || t == 2 || t == 4 || t == 6 {
                        if r == 0 || r == 2 || r == 4 || r == 6 {
                            if rg.print {
                                fmt.Printf(""%d "", i)
                            }
                            count++
                        }
                    }
                }
            }
        }
        if rg.print {
            fmt.Println()
        }
        fmt.Println(""count ="", count, ""\n"")
    }
}",1657,62
60442,http://rosettacode.org/wiki/Dynamic_variable_names,Dynamic variable names,"Task

Create a variable with a user-defined name.

The variable name should not be written in the program text, but should be taken from the user dynamically.



See also
   Eval in environment is a similar task.

",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""log""
    ""os""
    ""strconv""
    ""strings""
)
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func main() {
    scanner := bufio.NewScanner(os.Stdin)
    n := 0
    for n < 1 || n > 5 {
        fmt.Print(""How many integer variables do you want to create (max 5) : "")
        scanner.Scan()
        n, _ = strconv.Atoi(scanner.Text())
        check(scanner.Err())
    }
    vars := make(map[string]int)
    fmt.Println(""OK, enter the variable names and their values, below"")
    for i := 1; i <= n; {
        fmt.Println(""\n  Variable"", i)
        fmt.Print(""    Name  : "")
        scanner.Scan()
        name := scanner.Text()
        check(scanner.Err())
        if _, ok := vars[name]; ok {
            fmt.Println(""  Sorry, you've already created a variable of that name, try again"")
            continue
        }
        var value int
        var err error
        for {
            fmt.Print(""    Value : "")
            scanner.Scan()
            value, err = strconv.Atoi(scanner.Text())
            check(scanner.Err())
            if err != nil {
                fmt.Println(""  Not a valid integer, try again"")
            } else {
                break
            }
        }
        vars[name] = value
        i++
    }
    fmt.Println(""\nEnter q to quit"")
    for {
        fmt.Print(""\nWhich variable do you want to inspect : "")
        scanner.Scan()
        name := scanner.Text()
        check(scanner.Err())
        if s := strings.ToLower(name); s == ""q"" {
            return
        }
        v, ok := vars[name]
        if !ok {
            fmt.Println(""Sorry there's no variable of that name, try again"")
        } else {
            fmt.Println(""It's value is"", v)
        }
    }
}",1785,71
60545,http://rosettacode.org/wiki/Draw_a_pixel,Draw a pixel,"Task

Create a window and draw a pixel in it, subject to the following:

  the window is 320 x 240
  the color of the pixel must be red (255,0,0)
  the position of the pixel is x = 100, y = 100",#Go,Go,"package main
 
import (
    ""fmt""
    ""image""
    ""image/color""
    ""image/draw""
)
 
func main() {
    rect := image.Rect(0, 0, 320, 240)
    img := image.NewRGBA(rect)
 
    // Use green background, say.
    green := color.RGBA{0, 255, 0, 255}
    draw.Draw(img, rect, &image.Uniform{green}, image.ZP, draw.Src)
 
    // Set color of pixel at (100, 100) to red
    red := color.RGBA{255, 0, 0, 255}
    img.Set(100, 100, red)
 
    // Check it worked.
    cmap := map[color.Color]string{green: ""green"", red: ""red""}
    c1 := img.At(0, 0)
    c2 := img.At(100, 100)
    fmt.Println(""The color of the pixel at (  0,   0) is"", cmap[c1], ""\b."")
    fmt.Println(""The color of the pixel at (100, 100) is"", cmap[c2], ""\b."")
}",719,28
60600,http://rosettacode.org/wiki/Draw_a_rotating_cube,Draw a rotating cube,"Task
Draw a rotating cube.

It should be oriented with one vertex pointing straight up, and its opposite vertex on the main diagonal (the one farthest away) straight down. It can be solid or wire-frame, and you can use ASCII art if your language doesn't have graphical capabilities. Perspective is optional.




Related tasks
 Draw a cuboid
 write language name in 3D ASCII

",#Go,Go,"package main
 
import (
	""image""
	""image/color""
	""image/gif""
	""log""
	""math""
	""os""
)
 
const (
	width, height = 640, 640
	offset        = height / 2
	fileName      = ""rotatingCube.gif""
)
 
var nodes = [][]float64{{-100, -100, -100}, {-100, -100, 100}, {-100, 100, -100}, {-100, 100, 100},
	{100, -100, -100}, {100, -100, 100}, {100, 100, -100}, {100, 100, 100}}
var edges = [][]int{{0, 1}, {1, 3}, {3, 2}, {2, 0}, {4, 5}, {5, 7}, {7, 6},
	{6, 4}, {0, 4}, {1, 5}, {2, 6}, {3, 7}}
 
func main() {
	var images []*image.Paletted
	fgCol := color.RGBA{0xff, 0x00, 0xff, 0xff}
	var palette = []color.Color{color.RGBA{0x00, 0x00, 0x00, 0xff}, fgCol}
	var delays []int
 
	imgFile, err := os.Create(fileName)
	if err != nil {
		log.Fatal(err)
	}
	defer imgFile.Close()
 
	rotateCube(math.Pi/4, math.Atan(math.Sqrt(2)))
	var frame float64
	for frame = 0; frame < 360; frame++ {
		img := image.NewPaletted(image.Rect(0, 0, width, height), palette)
		images = append(images, img)
		delays = append(delays, 5)
		for _, edge := range edges {
			xy1 := nodes[edge[0]]
			xy2 := nodes[edge[1]]
			drawLine(int(xy1[0])+offset, int(xy1[1])+offset, int(xy2[0])+offset, int(xy2[1])+offset, img, fgCol)
		}
		rotateCube(math.Pi/180, 0)
	}
	if err := gif.EncodeAll(imgFile, &gif.GIF{Image: images, Delay: delays}); err != nil {
		imgFile.Close()
		log.Fatal(err)
	}
 
}
 
func rotateCube(angleX, angleY float64) {
	sinX := math.Sin(angleX)
	cosX := math.Cos(angleX)
	sinY := math.Sin(angleY)
	cosY := math.Cos(angleY)
	for _, node := range nodes {
		x := node[0]
		y := node[1]
		z := node[2]
		node[0] = x*cosX - z*sinX
		node[2] = z*cosX + x*sinX
		z = node[2]
		node[1] = y*cosY - z*sinY
		node[2] = z*cosY + y*sinY
	}
}
 
func drawLine(x0, y0, x1, y1 int, img *image.Paletted, col color.RGBA) {
	dx := abs(x1 - x0)
	dy := abs(y1 - y0)
	var sx, sy int = -1, -1
	if x0 < x1 {
		sx = 1
	}
	if y0 < y1 {
		sy = 1
	}
	err := dx - dy
	for {
		img.Set(x0, y0, col)
		if x0 == x1 && y0 == y1 {
			break
		}
		e2 := 2 * err
		if e2 > -dy {
			err -= dy
			x0 += sx
		}
		if e2 < dx {
			err += dx
			y0 += sy
		}
	}
}
 
func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}",2151,105
60728,http://rosettacode.org/wiki/Doubly-linked_list/Element_insertion,Doubly-linked list/Element insertion,"Doubly-Linked List (element)
This is much like inserting into a Singly-Linked List, but with added assignments so that the backwards-pointing links remain correct.

See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack",#Go,Go,"package main
 
import ""fmt""
 
type dlNode struct {
    string
    next, prev *dlNode
}
 
type dlList struct {
    head, tail *dlNode
}
 
func (list *dlList) String() string {
    if list.head == nil {
        return fmt.Sprint(list.head)
    }
    r := ""["" + list.head.string
    for p := list.head.next; p != nil; p = p.next {
        r += "" "" + p.string
    }
    return r + ""]""
}
 
func (list *dlList) insertTail(node *dlNode) {
    if list.tail == nil {
        list.head = node
    } else {
        list.tail.next = node
    }
    node.next = nil
    node.prev = list.tail
    list.tail = node
}
 
func (list *dlList) insertAfter(existing, insert *dlNode) {
    insert.prev = existing
    insert.next = existing.next
    existing.next.prev = insert
    existing.next = insert
    if existing == list.tail {
        list.tail = insert
    }
}
 
func main() {
    dll := &dlList{}
    fmt.Println(dll)
    a := &dlNode{string: ""A""}
    dll.insertTail(a)
    dll.insertTail(&dlNode{string: ""B""})
    fmt.Println(dll)
    dll.insertAfter(a, &dlNode{string: ""C""})
    fmt.Println(dll)
}",1086,55
60783,http://rosettacode.org/wiki/Doubly-linked_list/Traversal,Doubly-linked list/Traversal,"Traverse from the beginning of a doubly-linked list to the end, and from the end to the beginning.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#Go,Go,"package main
 
import ""fmt""
 
type dlNode struct {
    string
    next, prev *dlNode
}
 
type dlList struct {
    head, tail *dlNode
}
 
func (list *dlList) String() string {
    if list.head == nil {
        return fmt.Sprint(list.head)
    }
    r := ""["" + list.head.string
    for p := list.head.next; p != nil; p = p.next {
        r += "" "" + p.string
    }
    return r + ""]""
}
 
func (list *dlList) insertTail(node *dlNode) {
    if list.tail == nil {
        list.head = node
    } else {
        list.tail.next = node
    }
    node.next = nil
    node.prev = list.tail
    list.tail = node
}
 
func (list *dlList) insertAfter(existing, insert *dlNode) {
    insert.prev = existing
    insert.next = existing.next
    existing.next.prev = insert
    existing.next = insert
    if existing == list.tail {
        list.tail = insert
    }
}
 
func main() {
    dll := &dlList{}
    fmt.Println(dll)
    a := &dlNode{string: ""A""}
    dll.insertTail(a)
    dll.insertTail(&dlNode{string: ""B""})
    fmt.Println(dll)
    dll.insertAfter(a, &dlNode{string: ""C""})
    fmt.Println(dll)
 
    // traverse from end to beginning
    fmt.Print(""From tail:"")
    for p := dll.tail; p != nil; p = p.prev {
        fmt.Print("" "", p.string)
    }
    fmt.Println("""")
}",1259,62
60813,http://rosettacode.org/wiki/Doubly-linked_list/Element_definition,Doubly-linked list/Element definition,"Task

Define the data structure for a doubly-linked list element.

The element should include a data member to hold its value and pointers to both the next element in the list and the previous element in the list.

The pointers should be mutable.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#Go,Go,"type dlNode struct {
    string
    next, prev *dlNode
}",56,4
60893,http://rosettacode.org/wiki/Dutch_national_flag_problem,Dutch national flag problem,"
The Dutch national flag is composed of three coloured bands in the order:

   red     (top)
   then white,   and
   lastly blue   (at the bottom). 


The problem posed by Edsger Dijkstra is:

Given a number of red, blue and white balls in random order, arrange them in the order of the colours in the Dutch national flag.
When the problem was first posed, Dijkstra then went on to successively refine a solution, minimising the number of swaps and the number of times the colour of a ball needed to determined and restricting the balls to end in an array, ...



Task
 Generate a randomized order of balls ensuring that they are not in the order of the Dutch national flag.
 Sort the balls in a way idiomatic to your language.
 Check the sorted balls are in the order of the Dutch national flag.


C.f.

 Dutch national flag problem
 Probabilistic analysis of algorithms for the Dutch national flag problem by Wei-Mei Chen. (pdf)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
// constants define order of colors in Dutch national flag
const (
    red = iota
    white
    blue
    nColors
)
 
// zero object of type is valid red ball.
type ball struct {
    color int
}
 
// order of balls based on DNF
func (b1 ball) lt(b2 ball) bool {
    return b1.color < b2.color
}
 
// type for arbitrary ordering of balls
type ordering []ball
 
// predicate tells if balls are ordered by DNF
func (o ordering) ordered() bool {
    var b0 ball
    for _, b := range o {
        if b.lt(b0) {
            return false
        }
        b0 = b
    }
    return true
}
 
func init() {
    rand.Seed(time.Now().Unix())
}
 
// constructor returns new ordering of balls which is randomized but
// guaranteed to be not in DNF order.  function panics for n < 2.
func outOfOrder(n int) ordering {
    if n < 2 {
        panic(fmt.Sprintf(""%d invalid"", n))
    }
    r := make(ordering, n)
    for {
        for i, _ := range r {
            r[i].color = rand.Intn(nColors)
        }
        if !r.ordered() {
            break
        }
    }
    return r
}
 
// O(n) algorithm
// http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Sort/Flag/
func (a ordering) sort3() {
    lo, mid, hi := 0, 0, len(a)-1
    for mid <= hi {
        switch a[mid].color {
        case red:
            a[lo], a[mid] = a[mid], a[lo]
            lo++
            mid++
        case white:
            mid++
        default:
            a[mid], a[hi] = a[hi], a[mid]
            hi--
        }
    }
}
 
func main() {
    f := outOfOrder(12)
    fmt.Println(f)
    f.sort3()
    fmt.Println(f)
}",1641,88
60972,http://rosettacode.org/wiki/Draw_a_cuboid,Draw a cuboid,"Task

Draw a   cuboid   with relative dimensions of    2 × 3 × 4. 



The cuboid can be represented graphically, or in   ASCII art,   depending on the language capabilities.

To fulfill the criteria of being a cuboid, three faces must be visible.

Either static or rotational projection is acceptable for this task.



Related tasks
 draw a sphere
 draw a rotating cube
 write language name in 3D ASCII
 draw a Deathstar

",#Go,Go,"package main
 
import ""fmt""
 
func cuboid(dx, dy, dz int) {
    fmt.Printf(""cuboid %d %d %d:\n"", dx, dy, dz)
    cubLine(dy+1, dx, 0, ""+-"")
    for i := 1; i <= dy; i++ {
        cubLine(dy-i+1, dx, i-1, ""/ |"")
    }
    cubLine(0, dx, dy, ""+-|"")
    for i := 4*dz - dy - 2; i > 0; i-- {
        cubLine(0, dx, dy, ""| |"")
    }
    cubLine(0, dx, dy, ""| +"")
    for i := 1; i <= dy; i++ {
        cubLine(0, dx, dy-i, ""| /"")
    }
    cubLine(0, dx, 0, ""+-\n"")
}
 
func cubLine(n, dx, dy int, cde string) {
    fmt.Printf(""%*s"", n+1, cde[:1])
    for d := 9*dx - 1; d > 0; d-- {
        fmt.Print(cde[1:2])
    }
    fmt.Print(cde[:1])
    fmt.Printf(""%*s\n"", dy+1, cde[2:])
}
 
func main() {
    cuboid(2, 3, 4)
    cuboid(1, 1, 1)
    cuboid(6, 2, 1)
}",754,35
61089,http://rosettacode.org/wiki/Draw_a_sphere,Draw a sphere,"Task

Draw a sphere.

The sphere can be represented graphically, or in ASCII art, depending on the language capabilities.

Either static or rotational projection is acceptable for this task.



Related tasks

 draw a cuboid
 draw a rotating cube
 write language name in 3D ASCII
 draw a Deathstar

",#Go,Go,"package main
 
import (
    ""fmt""
    ""image""
    ""image/color""
    ""image/png""
    ""math""
    ""os""
)
 
type vector [3]float64
 
func normalize(v *vector) {
    invLen := 1 / math.Sqrt(dot(v, v))
    v[0] *= invLen
    v[1] *= invLen
    v[2] *= invLen
}
 
func dot(x, y *vector) float64 {
    return x[0]*y[0] + x[1]*y[1] + x[2]*y[2]
}
 
func drawSphere(r int, k, amb float64, dir *vector) *image.Gray {
    w, h := r*4, r*3
    img := image.NewGray(image.Rect(-w/2, -h/2, w/2, h/2))
    vec := new(vector)
    for x := -r; x < r; x++ {
        for y := -r; y < r; y++ {
            if z := r*r - x*x - y*y; z >= 0 {
                vec[0] = float64(x)
                vec[1] = float64(y)
                vec[2] = math.Sqrt(float64(z))
                normalize(vec)
                s := dot(dir, vec)
                if s < 0 {
                    s = 0
                }
                lum := 255 * (math.Pow(s, k) + amb) / (1 + amb)
                if lum < 0 {
                    lum = 0
                } else if lum > 255 {
                    lum = 255
                }
                img.SetGray(x, y, color.Gray{uint8(lum)})
            }
        }
    }
    return img
}
 
func main() {
    dir := &vector{-30, -30, 50}
    normalize(dir)
    img := drawSphere(200, 1.5, .2, dir)
    f, err := os.Create(""sphere.png"")
    if err != nil {
        fmt.Println(err)
        return
    }
    if err = png.Encode(f, img); err != nil {
        fmt.Println(err)
    }
    if err = f.Close(); err != nil {
        fmt.Println(err)
    }
}",1545,68
61090,http://rosettacode.org/wiki/Draw_a_clock,Draw a clock,"Task

Draw a clock.



More specific:

 Draw a time keeping device. It can be a stopwatch, hourglass, sundial, a mouth counting ""one thousand and one"", anything. Only showing the seconds is required, e.g.: a watch with just a second hand will suffice. However, it must clearly change every second, and the change must cycle every so often (one minute, 30 seconds, etc.) It must be drawn; printing a string of numbers to your terminal doesn't qualify. Both text-based and graphical drawing are OK.
 The clock is unlikely to be used to control space flights, so it needs not be hyper-accurate, but it should be usable, meaning if one can read the seconds off the clock, it must agree with the system clock.
 A clock is rarely (never?) a major application: don't be a CPU hog and poll the system timer every microsecond, use a proper timer/signal/event from your system or language instead. For a bad example, many OpenGL programs update the frame-buffer in a busy loop even if no redraw is needed, which is very undesirable for this task.
 A clock is rarely (never?) a major application: try to keep your code simple and to the point. Don't write something too elaborate or convoluted, instead do whatever is natural, concise and clear in your language.


Key points
 animate simple object
 timed event 
 polling system resources 
 code clarity

",#Go,Go,"package main
 
import (
	""golang.org/x/net/websocket""
	""flag""
	""fmt""
	""html/template""
	""io""
	""math""
	""net/http""
	""time""
)
 
var (
	Portnum  string
	Hostsite string
)
 
type PageSettings struct {
	Host string
	Port string
}
 
const (
	Canvaswidth  = 512
	Canvasheight = 512
	//color constants
	HourColor   = ""#ff7373"" // pinkish
	MinuteColor = ""#00b7e4"" //light blue
	SecondColor = ""#b58900"" //gold
)
 
func main() {
	flag.StringVar(&Portnum, ""Port"", ""1234"", ""Port to host server."")
	flag.StringVar(&Hostsite, ""Site"", ""localhost"", ""Site hosting server"")
	flag.Parse()
	http.HandleFunc(""/"", webhandler)
	http.Handle(""/ws"", websocket.Handler(wshandle))
	err := http.ListenAndServe(Hostsite+"":""+Portnum, nil)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(""server running"")
}
 
func webhandler(w http.ResponseWriter, r *http.Request) {
	wsurl := PageSettings{Host: Hostsite, Port: Portnum}
	template, _ := template.ParseFiles(""clock.html"")
	template.Execute(w, wsurl)
}
 
//Given a websocket connection,
//serves updating time function
func wshandle(ws *websocket.Conn) {
	for {
		hour, min, sec := time.Now().Clock()
		hourx, houry := HourCords(hour, Canvasheight/2)
		minx, miny := MinSecCords(min, Canvasheight/2)
		secx, secy := MinSecCords(sec, Canvasheight/2)
		msg := ""CLEAR\n""
		msg += fmt.Sprintf(""HOUR %d %d %s\n"", hourx, houry, HourColor)
		msg += fmt.Sprintf(""MIN %d %d %s\n"", minx, miny, MinuteColor)
		msg += fmt.Sprintf(""SEC %d %d %s"", secx, secy, SecondColor)
		io.WriteString(ws, msg)
		time.Sleep(time.Second / 60.0)
	}
}
 
//Given current minute or second time(i.e 30 min, 60 minutes)
//and the radius, returns pair of cords to draw line to
func MinSecCords(ctime int, radius int) (int, int) {
	//converts min/sec to angle and then to radians
 
	theta := ((float64(ctime)*6 - 90) * (math.Pi / 180))
	x := float64(radius) * math.Cos(theta)
	y := float64(radius) * math.Sin(theta)
	return int(x) + 256, int(y) + 256
}
 
//Given current hour time(i.e. 12, 8) and the radius,
//returns pair of cords to draw line to
func HourCords(ctime int, radius int) (int, int) {
	//converts hours to angle and then to radians
	theta := ((float64(ctime)*30 - 90) * (math.Pi / 180))
	x := float64(radius) * math.Cos(theta)
	y := float64(radius) * math.Sin(theta)
	return int(x) + 256, int(y) + 256
}",2301,88
61169,http://rosettacode.org/wiki/Dragon_curve,Dragon curve,"

Create and display a dragon curve fractal.

(You may either display the curve directly or write it to an image file.)



Algorithms
Here are some brief notes the algorithms used and how they might suit various languages.

 Recursively a right curling dragon is a right dragon followed by a left dragon, at 90-degree angle. And a left dragon is a left followed by a right.
*---R----*     expands to     *       *
                               \     /
                                R   L
                                 \ /
                                  *

                                  *
                                 / \
                                L   R
                               /     \
*---L---*      expands to     *       *
 The co-routines dcl and dcr in various examples do this recursively to a desired expansion level.
 The curl direction right or left can be a parameter instead of two separate routines.
 Recursively, a curl direction can be eliminated by noting the dragon consists of two copies of itself drawn towards a central point at 45-degrees.
*------->*   becomes    *       *     Recursive copies drawn
                         \     /      from the ends towards
                          \   /       the centre.
                           v v
                            *
 This can be seen in the SVG example. This is best suited to off-line drawing since the reversal in the second half means the drawing jumps backward and forward (in binary reflected Gray code order) which is not very good for a plotter or for drawing progressively on screen.
 Successive approximation repeatedly re-writes each straight line as two new segments at a right angle,
                       *       
*-----*   becomes     / \      bend to left
                     /   \     if N odd
                    *     *

                    *     *   
*-----*   becomes    \   /     bend to right  
                      \ /      if N even 
                       *
 Numbering from the start of the curve built so far, if the segment is at an odd position then the bend introduced is on the right side. If the segment is an even position then on the left. The process is then repeated on the new doubled list of segments. This constructs a full set of line segments before any drawing.
 The effect of the splitting is a kind of bottom-up version of the recursions. See the Asymptote example for code doing this.
 Iteratively the curve always turns 90-degrees left or right at each point. The direction of the turn is given by the bit above the lowest 1-bit of n. Some bit-twiddling can extract that efficiently.
n = 1010110000
        ^
        bit above lowest 1-bit, turn left or right as 0 or 1

LowMask = n BITXOR (n-1)   # eg. giving 0000011111
AboveMask = LowMask + 1    # eg. giving 0000100000
BitAboveLowestOne = n BITAND AboveMask
 The first turn is at n=1, so reckon the curve starting at the origin as n=0 then a straight line segment to position n=1 and turn there.
 If you prefer to reckon the first turn as n=0 then take the bit above the lowest 0-bit instead. This works because ""...10000"" minus 1 is ""...01111"" so the lowest 0 in n-1 is where the lowest 1 in n is.
 Going by turns suits turtle graphics such as Logo or a plotter drawing with a pen and current direction.
 If a language doesn't maintain a ""current direction"" for drawing then you can always keep that separately and apply turns by bit-above-lowest-1.
 Absolute direction to move at point n can be calculated by the number of bit-transitions in n.
n = 11 00 1111 0 1
      ^  ^    ^ ^     4 places where change bit value
                      so direction=4*90degrees=East
 This can be calculated by counting the number of 1 bits in ""n XOR (n RIGHTSHIFT 1)"" since such a shift and xor leaves a single 1 bit at each position where two adjacent bits differ.
 Absolute X,Y coordinates of a point n can be calculated in complex numbers by some powers (i+1)^k and add/subtract/rotate. This is done in the gnuplot code. This might suit things similar to Gnuplot which want to calculate each point independently.
 Predicate test for whether a given X,Y point or segment is on the curve can be done. This might suit line-by-line output rather than building an entire image before printing. See M4 for an example of this.
 A predicate works by dividing out complex number i+1 until reaching the origin, so it takes roughly a bit at a time from X and Y is thus quite efficient. Why it works is slightly subtle but the calculation is not difficult. (Check segment by applying an offset to move X,Y to an ""even"" position before dividing i+1. Check vertex by whether the segment either East or West is on the curve.)
 The number of steps in the predicate corresponds to doublings of the curve, so stopping the check at say 8 steps can limit the curve drawn to 2^8=256 points. The offsets arising in the predicate are bits of n the segment number, so can note those bits to calculate n and limit to an arbitrary desired length or sub-section.
 As a Lindenmayer system of expansions. The simplest is two symbols F and S both straight lines, as used by the PGF code.
Axiom F, angle 90 degrees
F -> F+S
S -> F-S
This always has F at even positions and S at odd. Eg. after 3 levels F_S_F_S_F_S_F_S. The +/- turns in between bend to the left or right the same as the ""successive approximation"" method above. Read more at for instance Joel Castellanos' L-system page.

Variations are possible if you have only a single symbol for line draw, for example the Icon and Unicon and Xfractint code. The angles can also be broken into 45-degree parts to keep the expansion in a single direction rather than the endpoint rotating around.

The string rewrites can be done recursively without building the whole string, just follow its instructions at the target level. See for example C by IFS Drawing code. The effect is the same as ""recursive with parameter"" above but can draw other curves defined by L-systems. 


",#Go,Go,"package main
 
import (
    ""fmt""
    ""image""
    ""image/color""
    ""image/draw""
    ""image/png""
    ""math""
    ""os""
)
 
// separation of the the two endpoints
// make this a power of 2 for prettiest output
const sep = 512
// depth of recursion.  adjust as desired for different visual effects.
const depth = 14
 
var s = math.Sqrt2 / 2
var sin = []float64{0, s, 1, s, 0, -s, -1, -s}
var cos = []float64{1, s, 0, -s, -1, -s, 0, s}
var p = color.NRGBA{64, 192, 96, 255}
var b *image.NRGBA
 
func main() {
    width := sep * 11 / 6
    height := sep * 4 / 3
    bounds := image.Rect(0, 0, width, height)
    b = image.NewNRGBA(bounds)
    draw.Draw(b, bounds, image.NewUniform(color.White), image.ZP, draw.Src)
    dragon(14, 0, 1, sep, sep/2, sep*5/6)
    f, err := os.Create(""dragon.png"")
    if err != nil {
        fmt.Println(err)
        return
    }
    if err = png.Encode(f, b); err != nil {
        fmt.Println(err)
    }
    if err = f.Close(); err != nil {
        fmt.Println(err)
    }
}
 
func dragon(n, a, t int, d, x, y float64) {
    if n <= 1 {
        // Go packages used here do not have line drawing functions
        // so we implement a very simple line drawing algorithm here.
        // We take advantage of knowledge that we are always drawing
        // 45 degree diagonal lines.
        x1 := int(x + .5)
        y1 := int(y + .5)
        x2 := int(x + d*cos[a] + .5)
        y2 := int(y + d*sin[a] + .5)
        xInc := 1
        if x1 > x2 {
            xInc = -1
        }
        yInc := 1
        if y1 > y2 {
            yInc = -1
        }
        for x, y := x1, y1; ; x, y = x+xInc, y+yInc {
            b.Set(x, y, p)
            if x == x2 {
                break
            }
        }
        return
    }
    d *= s
    a1 := (a - t) & 7
    a2 := (a + t) & 7
    dragon(n-1, a1, 1, d, x, y)
    dragon(n-1, a2, -1, d, x+d*cos[a1], y+d*sin[a1])
}",1888,76
61287,http://rosettacode.org/wiki/Display_an_outline_as_a_nested_table,Display an outline as a nested table,"

 Display an outline as a nested table.


 Parse the outline to a tree,

 count the leaves descending from each node,

 and write out a table with 'colspan' values


 measuring the indent of each line,

 translating the indentation to a nested structure,

 and padding the tree to even depth.

 defining the width of a leaf as 1,

 and the width of a parent node as a sum.

 either as a wiki table,

 or as HTML.










 (The sum of the widths of its children)





The graphic representation of outlines is a staple of mind-mapping and the planning of papers, reports, and speeches.

Task

Given a outline with at least 3 levels of indentation, for example:

Display an outline as a nested table.
    Parse the outline to a tree,
        measuring the indent of each line,
        translating the indentation to a nested structure,
        and padding the tree to even depth.
    count the leaves descending from each node,
        defining the width of a leaf as 1,
        and the width of a parent node as a sum.
            (The sum of the widths of its children)
    and write out a table with 'colspan' values
        either as a wiki table,
        or as HTML.
write a program in your language which translates your outline into a nested table, with WikiTable or HTML colspan values attached (where needed) to parent nodes in the nested table.

The WikiTable at the top of this page was generated from the indented outline shown above, producing the following markup string:

{| class=""wikitable"" style=""text-align: center;""
|-
| style=""background: #ffffe6; "" colspan=7 | Display an outline as a nested table.
|-
| style=""background: #ffebd2; "" colspan=3 | Parse the outline to a tree,
| style=""background: #f0fff0; "" colspan=2 | count the leaves descending from each node,
| style=""background: #e6ffff; "" colspan=2 | and write out a table with 'colspan' values
|-
| style=""background: #ffebd2; "" | measuring the indent of each line,
| style=""background: #ffebd2; "" | translating the indentation to a nested structure,
| style=""background: #ffebd2; "" | and padding the tree to even depth.
| style=""background: #f0fff0; "" | defining the width of a leaf as 1,
| style=""background: #f0fff0; "" | and the width of a parent node as a sum.
| style=""background: #e6ffff; "" | either as a wiki table,
| style=""background: #e6ffff; "" | or as HTML.
|-
|  | 
|  | 
|  | 
|  | 
| style=""background: #f0fff0; "" | (The sum of the widths of its children)
|  | 
|  | 
|}
Extra credit

Use background color to distinguish the main stages of your outline, so that the subtree of each node at level two is consistently colored, and the edges between adjacent subtrees are immediately revealed.



Output

Display your nested table on this page.


",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
type nNode struct {
    name     string
    children []nNode
}
 
type iNode struct {
    level int
    name  string
}
 
func toNest(iNodes []iNode, start, level int, n *nNode) {
    if level == 0 {
        n.name = iNodes[0].name
    }
    for i := start + 1; i < len(iNodes); i++ {
        if iNodes[i].level == level+1 {
            c := nNode{iNodes[i].name, nil}
            toNest(iNodes, i, level+1, &c)
            n.children = append(n.children, c)
        } else if iNodes[i].level <= level {
            return
        }
    }
}
 
func makeIndent(outline string, tab int) []iNode {
    lines := strings.Split(outline, ""\n"")
    iNodes := make([]iNode, len(lines))
    for i, line := range lines {
        line2 := strings.TrimLeft(line, "" "")
        le, le2 := len(line), len(line2)
        level := (le - le2) / tab
        iNodes[i] = iNode{level, line2}
    }
    return iNodes
}
 
func toMarkup(n nNode, cols []string, depth int) string {
    var span int
 
    var colSpan func(nn nNode)
    colSpan = func(nn nNode) {
        for i, c := range nn.children {
            if i > 0 {
                span++
            }
            colSpan(c)
        }
    }
 
    for _, c := range n.children {
        span = 1
        colSpan(c)
    }
    var lines []string
    lines = append(lines, `{| class=""wikitable"" style=""text-align: center;""`)
    const l1, l2 = ""|-"", ""|  |""
    lines = append(lines, l1)
    span = 1
    colSpan(n)
    s := fmt.Sprintf(`| style=""background: %s "" colSpan=%d | %s`, cols[0], span, n.name)
    lines = append(lines, s, l1)
 
    var nestedFor func(nn nNode, level, maxLevel, col int)
    nestedFor = func(nn nNode, level, maxLevel, col int) {
        if level == 1 && maxLevel > level {
            for i, c := range nn.children {
                nestedFor(c, 2, maxLevel, i)
            }
        } else if level < maxLevel {
            for _, c := range nn.children {
                nestedFor(c, level+1, maxLevel, col)
            }
        } else {
            if len(nn.children) > 0 {
                for i, c := range nn.children {
                    span = 1
                    colSpan(c)
                    cn := col + 1
                    if maxLevel == 1 {
                        cn = i + 1
                    }
                    s := fmt.Sprintf(`| style=""background: %s "" colspan=%d | %s`, cols[cn], span, c.name)
                    lines = append(lines, s)
                }
            } else {
                lines = append(lines, l2)
            }
        }
    }
    for maxLevel := 1; maxLevel < depth; maxLevel++ {
        nestedFor(n, 1, maxLevel, 0)
        if maxLevel < depth-1 {
            lines = append(lines, l1)
        }
    }
    lines = append(lines, ""|}"")
    return strings.Join(lines, ""\n"")
}
 
func main() {
    const outline = `Display an outline as a nested table.
    Parse the outline to a tree,
        measuring the indent of each line,
        translating the indentation to a nested structure,
        and padding the tree to even depth.
    count the leaves descending from each node,
        defining the width of a leaf as 1,
        and the width of a parent node as a sum.
            (The sum of the widths of its children) 
    and write out a table with 'colspan' values
        either as a wiki table,
        or as HTML.`
    const (
        yellow = ""#ffffe6;""
        orange = ""#ffebd2;""
        green  = ""#f0fff0;""
        blue   = ""#e6ffff;""
        pink   = ""#ffeeff;""
    )
    cols := []string{yellow, orange, green, blue, pink}
    iNodes := makeIndent(outline, 4)
    var n nNode
    toNest(iNodes, 0, 0, &n)
    fmt.Println(toMarkup(n, cols, 4))
 
    fmt.Println(""\n"")
    const outline2 = `Display an outline as a nested table.
    Parse the outline to a tree,
        measuring the indent of each line,
        translating the indentation to a nested structure,
        and padding the tree to even depth.
    count the leaves descending from each node,
        defining the width of a leaf as 1,
        and the width of a parent node as a sum.
            (The sum of the widths of its children)
            Propagating the sums upward as necessary. 
    and write out a table with 'colspan' values
        either as a wiki table,
        or as HTML.
    Optionally add color to the nodes.`
    cols2 := []string{blue, yellow, orange, green, pink}
    var n2 nNode
    iNodes2 := makeIndent(outline2, 4)
    toNest(iNodes2, 0, 0, &n2)
    fmt.Println(toMarkup(n2, cols2, 4))
}",4552,154
61311,http://rosettacode.org/wiki/Diversity_prediction_theorem,Diversity prediction theorem,"The   wisdom of the crowd   is the collective opinion of a group of individuals rather than that of a single expert.

Wisdom-of-the-crowds research routinely attributes the superiority of crowd averages over individual judgments to the elimination of individual noise,   an explanation that assumes independence of the individual judgments from each other.

Thus the crowd tends to make its best decisions if it is made up of diverse opinions and ideologies.



Scott E. Page introduced the diversity prediction theorem:

 The squared error of the collective prediction equals the average squared error minus the predictive diversity. 


Therefore,   when the diversity in a group is large,   the error of the crowd is small.



Definitions

   Average Individual Error:   Average of the individual squared errors
   Collective Error:   Squared error of the collective prediction
   Prediction Diversity:   Average squared distance from the individual predictions to the collective prediction
   Diversity Prediction Theorem:   Given a crowd of predictive models,     then
   Collective Error   =   Average Individual Error   ─   Prediction Diversity
Task

For a given   true   value and a number of number of estimates (from a crowd),   show   (here on this page):

   the true value   and   the crowd estimates
   the average error
   the crowd error
   the prediction diversity


Use   (at least)   these two examples:

   a true value of   49   with crowd estimates of:    48   47   51
   a true value of   49   with crowd estimates of:    48   47   51   42


Also see

   Wikipedia entry:   Wisdom of the crowd
   University of Michigan: PDF paper         (exists on a web archive,   the Wayback Machine).

",#Go,Go,"package main
 
import ""fmt""
 
func averageSquareDiff(f float64, preds []float64) (av float64) {
    for _, pred := range preds {
        av += (pred - f) * (pred - f)
    }
    av /= float64(len(preds))
    return
}
 
func diversityTheorem(truth float64, preds []float64) (float64, float64, float64) {
    av := 0.0
    for _, pred := range preds {
        av += pred
    }
    av /= float64(len(preds))
    avErr := averageSquareDiff(truth, preds)
    crowdErr := (truth - av) * (truth - av)
    div := averageSquareDiff(av, preds)
    return avErr, crowdErr, div
}
 
func main() {
    predsArray := [2][]float64{{48, 47, 51}, {48, 47, 51, 42}}
    truth := 49.0
    for _, preds := range predsArray {
        avErr, crowdErr, div := diversityTheorem(truth, preds)
        fmt.Printf(""Average-error : %6.3f\n"", avErr)
        fmt.Printf(""Crowd-error   : %6.3f\n"", crowdErr)
        fmt.Printf(""Diversity     : %6.3f\n\n"", div)
    }
}",935,34
61316,http://rosettacode.org/wiki/Distributed_programming,Distributed programming,"Write two programs (or one program with two modes) which run on networked computers, and send some messages between them.

The protocol used may be language-specific or not, and should be suitable for general distributed programming; that is, the protocol should be generic (not designed just for the particular example application), readily capable of handling the independent communications of many different components of a single application, and the transferring of arbitrary data structures natural for the language.

This task is intended to demonstrate high-level communication facilities beyond just creating sockets.
",#Go,Go,"package main
 
import (
    ""errors""
    ""log""
    ""net""
    ""net/http""
    ""net/rpc""
)
 
type TaxComputer float64
 
func (taxRate TaxComputer) Tax(x float64, r *float64) error {
    if x < 0 {
        return errors.New(""Negative values not allowed"")
    }
    *r = x * float64(taxRate)
    return nil
}
 
func main() {
    c := TaxComputer(.05)
    rpc.Register(c)
    rpc.HandleHTTP()
    listener, err := net.Listen(""tcp"", "":1234"")
    if err != nil {
        log.Fatal(err)
    }
    http.Serve(listener, nil)
}",515,30
61324,http://rosettacode.org/wiki/Documentation,Documentation,"

See also

 Related task: Comments
 Related task: Here_document

",#Go,Go,"// Example serves as an example but does nothing useful.
//
// A package comment preceeds the package clause and explains the purpose
// of the package.
package example
 
// Exported variables.
var (
    // lookie
    X, Y, Z int // popular names
)
 
/* XP does nothing.
 
Here's a block comment. */
func XP() { // here we go!
    // comments inside
}
 
// Non-exported.
func nonXP() {}
 
// Doc not extracted.
 
var MEMEME int",427,25
61334,http://rosettacode.org/wiki/Display_a_linear_combination,Display a linear combination,"Task

Display a finite linear combination in an infinite vector basis 



(

e

1


,

e

2


,
…
)


{\displaystyle (e_{1},e_{2},\ldots )}

.

Write a function that, when given a finite list of scalars 



(

α

1


,

α

2


,
…
)


{\displaystyle (\alpha ^{1},\alpha ^{2},\ldots )}

, 
creates a string representing the linear combination 




∑

i



α

i



e

i




{\displaystyle \sum _{i}\alpha ^{i}e_{i}}

 in an explicit format often used in mathematics, that is:






α


i

1





e


i

1




±

|


α


i

2





|


e


i

2




±

|


α


i

3





|


e


i

3




±
…


{\displaystyle \alpha ^{i_{1}}e_{i_{1}}\pm |\alpha ^{i_{2}}|e_{i_{2}}\pm |\alpha ^{i_{3}}|e_{i_{3}}\pm \ldots }


where 




α


i

k




≠
0


{\displaystyle \alpha ^{i_{k}}\neq 0}







The output must comply to the following rules:

   don't show null terms, unless the whole combination is null. 
 e(1)     is fine,     e(1) + 0*e(3)     or     e(1) + 0     is wrong.
   don't show scalars when they are equal to one or minus one. 
 e(3)     is fine,     1*e(3)     is wrong.
   don't prefix by a minus sign if it follows a preceding term.   Instead you use subtraction. 
 e(4) - e(5)     is fine,     e(4) + -e(5)     is wrong.


Show here output for the following lists of scalars:

 1)    1,  2,  3
 2)    0,  1,  2,  3
 3)    1,  0,  3,  4
 4)    1,  2,  0
 5)    0,  0,  0
 6)    0
 7)    1,  1,  1
 8)   -1, -1, -1
 9)   -1, -2,  0, -3
10)   -1


",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func linearCombo(c []int) string {
    var sb strings.Builder
    for i, n := range c {
        if n == 0 {
            continue
        }
        var op string
        switch {
        case n < 0 && sb.Len() == 0:
            op = ""-""
        case n < 0:
            op = "" - ""
        case n > 0 && sb.Len() == 0:
            op = """"
        default:
            op = "" + ""
        }
        av := n
        if av < 0 {
            av = -av
        }
        coeff := fmt.Sprintf(""%d*"", av)
        if av == 1 {
            coeff = """"
        }
        sb.WriteString(fmt.Sprintf(""%s%se(%d)"", op, coeff, i+1))
    }
    if sb.Len() == 0 {
        return ""0""
    } else {
        return sb.String()
    }
}
 
func main() {
    combos := [][]int{
        {1, 2, 3},
        {0, 1, 2, 3},
        {1, 0, 3, 4},
        {1, 2, 0},
        {0, 0, 0},
        {0},
        {1, 1, 1},
        {-1, -1, -1},
        {-1, -2, 0, -3},
        {-1},
    }
    for _, c := range combos {
        t := strings.Replace(fmt.Sprint(c), "" "", "", "", -1)
        fmt.Printf(""%-15s  ->  %s\n"", t, linearCombo(c))
    }
}",1153,59
61349,http://rosettacode.org/wiki/DNS_query,DNS query,"DNS is an internet service that maps domain names, like rosettacode.org, to IP addresses, like 66.220.0.231.

Use DNS to resolve www.kame.net to both IPv4 and IPv6 addresses. Print these addresses.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""net""
)
 
func main() {
    if addrs, err := net.LookupHost(""www.kame.net""); err == nil {
        fmt.Println(addrs)
    } else {
        fmt.Println(err)
    }
}",200,14
61484,http://rosettacode.org/wiki/Disarium_numbers,Disarium numbers,"A Disarium number is an integer where the sum of each digit raised to the power of its position in the number, is equal to the number.



E.G.
135 is a Disarium number:

 11 + 32 + 53 == 1 + 9 + 125 == 135

There are a finite number of Disarium numbers.



Task
 Find and display the first 18 Disarium numbers.


Stretch
 Find and display all 20 Disarium numbers.


See also
 Geeks for Geeks - Disarium numbers
 OEIS:A032799 - Numbers n such that n equals the sum of its digits raised to the consecutive powers (1,2,3,...)
 Related task: Narcissistic decimal number
 Related task: Own digits power sum Which seems to be the same task as Narcissistic decimal number...



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
const DMAX = 20  // maximum digits
const LIMIT = 20 // maximum number of disariums to find
 
func main() {
    // Pre-calculated exponential and power serials
    EXP := make([][]uint64, 1+DMAX)
    POW := make([][]uint64, 1+DMAX)
 
    EXP[0] = make([]uint64, 11)
    EXP[1] = make([]uint64, 11)
    POW[0] = make([]uint64, 11)
    POW[1] = make([]uint64, 11)
    for i := uint64(1); i <= 10; i++ {
        EXP[1][i] = i
    }
    for i := uint64(1); i <= 9; i++ {
        POW[1][i] = i
    }
    POW[1][10] = 9
 
    for i := 2; i <= DMAX; i++ {
        EXP[i] = make([]uint64, 11)
        POW[i] = make([]uint64, 11)
    }
    for i := 1; i < DMAX; i++ {
        for j := 0; j <= 9; j++ {
            EXP[i+1][j] = EXP[i][j] * 10
            POW[i+1][j] = POW[i][j] * uint64(j)
        }
        EXP[i+1][10] = EXP[i][10] * 10
        POW[i+1][10] = POW[i][10] + POW[i+1][9]
    }
 
    // Digits of candidate and values of known low bits
    DIGITS := make([]int, 1+DMAX) // Digits form
    Exp := make([]uint64, 1+DMAX) // Number form
    Pow := make([]uint64, 1+DMAX) // Powers form
 
    var exp, pow, min, max uint64
    start := 1
    final := DMAX
    count := 0
    for digit := start; digit <= final; digit++ {
        fmt.Println(""# of digits:"", digit)
        level := 1
        DIGITS[0] = 0
        for {
            // Check limits derived from already known low bit values
            // to find the most possible candidates
            for 0 < level && level < digit {
                // Reset path to try next if checking in level is done
                if DIGITS[level] > 9 {
                    DIGITS[level] = 0
                    level--
                    DIGITS[level]++
                    continue
                }
 
                // Update known low bit values
                Exp[level] = Exp[level-1] + EXP[level][DIGITS[level]]
                Pow[level] = Pow[level-1] + POW[digit+1-level][DIGITS[level]]
 
                // Max possible value
                pow = Pow[level] + POW[digit-level][10]
 
                if pow < EXP[digit][1] { // Try next since upper limit is invalidly low
                    DIGITS[level]++
                    continue
                }
 
                max = pow % EXP[level][10]
                pow -= max
                if max < Exp[level] {
                    pow -= EXP[level][10]
                }
                max = pow + Exp[level]
 
                if max < EXP[digit][1] { // Try next since upper limit is invalidly low
                    DIGITS[level]++
                    continue
                }
 
                // Min possible value
                exp = Exp[level] + EXP[digit][1]
                pow = Pow[level] + 1
 
                if exp > max || max < pow { // Try next since upper limit is invalidly low
                    DIGITS[level]++
                    continue
                }
 
                if pow > exp {
                    min = pow % EXP[level][10]
                    pow -= min
                    if min > Exp[level] {
                        pow += EXP[level][10]
                    }
                    min = pow + Exp[level]
                } else {
                    min = exp
                }
 
                // Check limits existence
                if max < min {
                    DIGITS[level]++ // Try next number since current limits invalid
                } else {
                    level++ // Go for further level checking since limits available
                }
            }
 
            // All checking is done, escape from the main check loop
            if level < 1 {
                break
            }
 
            // Finally check last bit of the most possible candidates
            // Update known low bit values
            Exp[level] = Exp[level-1] + EXP[level][DIGITS[level]]
            Pow[level] = Pow[level-1] + POW[digit+1-level][DIGITS[level]]
 
            // Loop to check all last bits of candidates
            for DIGITS[level] < 10 {
                // Print out new Disarium number
                if Exp[level] == Pow[level] {
                    s := """"
                    for i := DMAX; i > 0; i-- {
                        s += fmt.Sprintf(""%d"", DIGITS[i])
                    }
                    n, _ := strconv.ParseUint(s, 10, 64)
                    fmt.Println(n)
                    count++
                    if count == LIMIT {
                        fmt.Println(""\nFound the first"", LIMIT, ""Disarium numbers."")
                        return
                    }
                }
 
                // Go to followed last bit candidate
                DIGITS[level]++
                Exp[level] += EXP[level][1]
                Pow[level]++
            }
 
            // Reset to try next path
            DIGITS[level] = 0
            level--
            DIGITS[level]++
        }
        fmt.Println()
    }
}",4969,158
61572,http://rosettacode.org/wiki/Doubly-linked_list/Definition,Doubly-linked list/Definition,"Define the data structure for a complete Doubly Linked List.

 The structure should support adding elements to the head, tail and middle of the list. 
 The structure should not allow circular loops


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#Go,Go,"type dlNode struct {
    int
    next, prev *dlNode
}
 
// Field 'members' allows loops to be prevented.  All nodes
// inserted should be added to members.  Code that operates
// on the list can check any pointer against members to
// find out if the pointer is already in the list.
type dlList struct {
    members map[*dlNode]int
    head, tail **dlNode
}",357,13
61631,http://rosettacode.org/wiki/Determine_sentence_type,Determine sentence type,"Use these sentences:
""hi there, how are you today? I'd like to present to you the washing machine 9001. You have been nominated to win one of these! Just make sure you don't break it.""

Task
 Search for the last used punctuation in a sentence, and determine its type according to its punctuation.
 Output one of these letters
 ""E"" (Exclamation!), ""Q"" (Question?), ""S"" (Serious.), ""N"" (Neutral). 
Extra
 Make your code able to determine multiple sentences.


Don't leave any errors!




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func sentenceType(s string) string {
    if len(s) == 0 {
        return """"
    }
    var types []string
    for _, c := range s {
        if c == '?' {
            types = append(types, ""Q"")
        } else if c == '!' {
            types = append(types, ""E"")
        } else if c == '.' {
            types = append(types, ""S"")
        }
    }
    if strings.IndexByte(""?!."", s[len(s)-1]) == -1 {
        types = append(types, ""N"")
    }
    return strings.Join(types, ""|"")
}
 
func main() {
    s := ""hi there, how are you today? I'd like to present to you the washing machine 9001. You have been nominated to win one of these! Just make sure you don't break it""
    fmt.Println(sentenceType(s))
}",750,31
61725,http://rosettacode.org/wiki/Dice_game_probabilities,Dice game probabilities,"Two players have a set of dice each. The first player has nine dice with four faces each, with numbers one to four. The second player has six normal dice with six faces each, each face has the usual numbers from one to six.

They roll their dice and sum the totals of the faces. The player with the highest total wins (it's a draw if the totals are the same). What's the probability of the first player beating the second player?

Later the two players use a different set of dice each. Now the first player has five dice with ten faces each, and the second player has six dice with seven faces each. Now what's the probability of the first player beating the second player?

This task was adapted from the Project Euler Problem n.205:
https://projecteuler.net/problem=205
",#Go,Go,"package main
 
import(
    ""math""
    ""fmt""
)
 
func minOf(x, y uint) uint {
    if x < y {
        return x
    }
    return y
}
 
func throwDie(nSides, nDice, s uint, counts []uint) {
    if nDice == 0 {
        counts[s]++
        return
    }
    for i := uint(1); i <= nSides; i++ {
        throwDie(nSides, nDice - 1, s + i, counts)
    }
}
 
func beatingProbability(nSides1, nDice1, nSides2, nDice2 uint) float64 {
    len1 := (nSides1 + 1) * nDice1
    c1 := make([]uint, len1)  // all elements zero by default
    throwDie(nSides1, nDice1, 0, c1)
 
    len2 := (nSides2 + 1) * nDice2
    c2 := make([]uint, len2)
    throwDie(nSides2, nDice2, 0, c2)
    p12 := math.Pow(float64(nSides1), float64(nDice1)) *
           math.Pow(float64(nSides2), float64(nDice2))
 
    tot := 0.0
    for i := uint(0); i < len1; i++ {
        for j := uint(0); j < minOf(i, len2); j++ {
            tot += float64(c1[i] * c2[j]) / p12
        }
    }
    return tot
}
 
func main() {
    fmt.Println(beatingProbability(4, 9, 6, 6))
    fmt.Println(beatingProbability(10, 5, 7, 6))
}",1073,48
61760,http://rosettacode.org/wiki/Digital_root/Multiplicative_digital_root,Digital root/Multiplicative digital root,"The multiplicative digital root (MDR) and multiplicative persistence (MP) of a number, 



n


{\displaystyle n}

, is calculated rather like the Digital root except digits are multiplied instead of being added:

 Set 



m


{\displaystyle m}

 to 



n


{\displaystyle n}

 and 



i


{\displaystyle i}

 to 



0


{\displaystyle 0}

.
 While 



m


{\displaystyle m}

 has more than one digit:
 Find a replacement 



m


{\displaystyle m}

 as the multiplication of the digits of the current value of 



m


{\displaystyle m}

.
 Increment 



i


{\displaystyle i}

.
 Return 



i


{\displaystyle i}

 (= MP) and 



m


{\displaystyle m}

 (= MDR)


Task

 Tabulate the MP and MDR of the numbers 123321, 7739, 893, 899998
 Tabulate MDR versus the first five numbers having that MDR, something like:
MDR: [n0..n4]
===  ========
  0: [0, 10, 20, 25, 30]
  1: [1, 11, 111, 1111, 11111]
  2: [2, 12, 21, 26, 34]
  3: [3, 13, 31, 113, 131]
  4: [4, 14, 22, 27, 39]
  5: [5, 15, 35, 51, 53]
  6: [6, 16, 23, 28, 32]
  7: [7, 17, 71, 117, 171]
  8: [8, 18, 24, 29, 36]
  9: [9, 19, 33, 91, 119]

Show all output on this page.

Similar

The Product of decimal digits of n page was redirected here, and had the following description


Find the product of the decimal digits of a positive integer   n,   where n <= 100

The three existing entries for Phix, REXX, and Ring have been moved here, under ===Similar=== headings, feel free to match or ignore them.



References

 Multiplicative Digital Root on Wolfram Mathworld.
 Multiplicative digital root on The On-Line Encyclopedia of Integer Sequences.
 What's special about 277777788888899? - Numberphile video

",#Go,Go,"package main
 
import ""fmt""
 
// Only valid for n > 0 && base >= 2
func mult(n uint64, base int) (mult uint64) {
	for mult = 1; mult > 0 && n > 0; n /= uint64(base) {
		mult *= n % uint64(base)
	}
	return
}
 
// Only valid for n >= 0 && base >= 2
func MultDigitalRoot(n uint64, base int) (mp, mdr int) {
	var m uint64
	for m = n; m >= uint64(base); mp++ {
		m = mult(m, base)
	}
	return mp, int(m)
}
 
func main() {
	const base = 10
	const size = 5
 
	const testFmt = ""%20v %3v %3v\n""
	fmt.Printf(testFmt, ""Number"", ""MDR"", ""MP"")
	for _, n := range [...]uint64{
		123321, 7739, 893, 899998,
		18446743999999999999,
		// From http://mathworld.wolfram.com/MultiplicativePersistence.html
		3778888999, 277777788888899,
	} {
		mp, mdr := MultDigitalRoot(n, base)
		fmt.Printf(testFmt, n, mdr, mp)
	}
	fmt.Println()
 
	var list [base][]uint64
	for i := range list {
		list[i] = make([]uint64, 0, size)
	}
	for cnt, n := size*base, uint64(0); cnt > 0; n++ {
		_, mdr := MultDigitalRoot(n, base)
		if len(list[mdr]) < size {
			list[mdr] = append(list[mdr], n)
			cnt--
		}
	}
	const tableFmt = ""%3v: %v\n""
	fmt.Printf(tableFmt, ""MDR"", ""First"")
	for i, l := range list {
		fmt.Printf(tableFmt, i, l)
	}
}",1196,55
61782,http://rosettacode.org/wiki/Determine_if_only_one_instance_is_running,Determine if only one instance is running,"This task is to determine if there is only one instance of an application running. If the program discovers that an instance of it is already running, then it should display a message indicating that it is already running and exit.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""net""
    ""time""
)
 
const lNet = ""tcp""
const lAddr = "":12345""
 
func main() {
    if _, err := net.Listen(lNet, lAddr); err != nil {
        fmt.Println(""an instance was already running"")
        return
    }
    fmt.Println(""single instance started"")
    time.Sleep(10 * time.Second)
}",325,19
61860,http://rosettacode.org/wiki/Dijkstra%27s_algorithm,Dijkstra's algorithm,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.

Dijkstra's algorithm, conceived by Dutch computer scientist Edsger Dijkstra in 1956 and published in 1959, is a graph search algorithm that solves the single-source shortest path problem for a graph with non-negative edge path costs, producing a shortest path tree.

This algorithm is often used in routing and as a subroutine in other graph algorithms.



For a given source vertex (node) in the graph, the algorithm finds the path with lowest cost (i.e. the shortest path) between that vertex and every other vertex.



For instance

If the vertices of the graph represent cities and edge path costs represent driving distances between pairs of cities connected by a direct road,   Dijkstra's algorithm can be used to find the shortest route between one city and all other cities.

As a result, the shortest path first is widely used in network routing protocols, most notably:

   IS-IS   (Intermediate System to Intermediate System)   and 
   OSPF   (Open Shortest Path First).


Important note
 
The inputs to Dijkstra's algorithm are a directed and weighted graph consisting of 2 or more nodes, generally represented by:

   an adjacency matrix or list,   and
   a start node. 


A destination node is not specified.

The output is a set of edges depicting the shortest path to each destination node.



An example, starting with

                                         a──►b,  cost=7,   lastNode=a  
                                         a──►c,  cost=9,   lastNode=a 
                                         a──►d,  cost=NA,  lastNode=a
                                         a──►e,  cost=NA,  lastNode=a 
                                         a──►f,  cost=14,  lastNode=a
 
    The lowest cost is    a──►b    so    a──►b    is added to the output. 
 
    There is a connection from   b──►d   so the input is updated to: 
                                         a──►c,  cost=9,   lastNode=a 
                                         a──►d,  cost=22,  lastNode=b 
                                         a──►e,  cost=NA,  lastNode=a 
                                         a──►f,  cost=14,  lastNode=a
 
    The lowest cost is    a──►c    so    a──►c    is added to the output. 
 
    Paths to    d    and    f    are cheaper via    c    so the input is updated to:
                                         a──►d,  cost=20,  lastNode=c 
                                         a──►e,  cost=NA,  lastNode=a 
                                         a──►f,  cost=11,  lastNode=c
 
    The lowest cost is    a──►f    so    c──►f    is added to the output. 
 
    The input is updated to:
                                         a──►d,  cost=20,  lastNode=c 
                                         a──►e,  cost=NA,  lastNode=a
 
    The lowest cost is    a──►d    so    c──►d    is added to the output. 
 
    There is a connection from    d──►e    so the input is updated to:
                                         a──►e,  cost=26,  lastNode=d
 
    Which just leaves adding    d──►e    to the output.
 
    The output should now be:
                                       [ d──►e
                                         c──►d
                                         c──►f
                                         a──►c
                                         a──►b ]   


Task

 Implement a version of Dijkstra's algorithm that outputs a set of edges depicting the shortest path to each reachable node from an origin.
 Run your program with the following directed graph starting at node    a.
 Write a program which interprets the output from the above and use it to output the shortest path from node    a    to nodes    e    and  f. 

 Vertices


 Number 
 Name


 1 
 a


 2 
 b


 3 
 c


 4 
 d


 5 
 e


 6 
 f


 Edges


 Start 
 End 
 Cost


 a 
 b 
 7


 a 
 c 
 9


 a 
 f 
 14


 b 
 c 
 10


 b 
 d 
 15


 c 
 d 
 11


 c 
 f 
 2


 d 
 e 
 6


 e 
 f 
 9



You can use numbers or names to identify vertices in your program.



See also
 Dijkstra's Algorithm vs. A* Search vs. Concurrent Dijkstra's Algorithm (youtube)

",#Go,Go,"package main
 
import (
	""container/heap""
	""fmt""
)
 
// A PriorityQueue implements heap.Interface and holds Items.
type PriorityQueue struct {
	items []Vertex
	m     map[Vertex]int // value to index
	pr    map[Vertex]int // value to priority
}
 
func (pq *PriorityQueue) Len() int           { return len(pq.items) }
func (pq *PriorityQueue) Less(i, j int) bool { return pq.pr[pq.items[i]] < pq.pr[pq.items[j]] }
func (pq *PriorityQueue) Swap(i, j int) {
	pq.items[i], pq.items[j] = pq.items[j], pq.items[i]
	pq.m[pq.items[i]] = i
	pq.m[pq.items[j]] = j
}
func (pq *PriorityQueue) Push(x interface{}) {
	n := len(pq.items)
	item := x.(Vertex)
	pq.m[item] = n
	pq.items = append(pq.items, item)
}
func (pq *PriorityQueue) Pop() interface{} {
	old := pq.items
	n := len(old)
	item := old[n-1]
	pq.m[item] = -1
	pq.items = old[0 : n-1]
	return item
}
 
// update modifies the priority of an item in the queue.
func (pq *PriorityQueue) update(item Vertex, priority int) {
	pq.pr[item] = priority
	heap.Fix(pq, pq.m[item])
}
func (pq *PriorityQueue) addWithPriority(item Vertex, priority int) {
	heap.Push(pq, item)
	pq.update(item, priority)
}
 
const (
	Infinity      = int(^uint(0) >> 1)
	Uninitialized = -1
)
 
func Dijkstra(g Graph, source Vertex) (dist map[Vertex]int, prev map[Vertex]Vertex) {
	vs := g.Vertices()
	dist = make(map[Vertex]int, len(vs))
	prev = make(map[Vertex]Vertex, len(vs))
	sid := source
	dist[sid] = 0
	q := &PriorityQueue{
		items: make([]Vertex, 0, len(vs)),
		m:     make(map[Vertex]int, len(vs)),
		pr:    make(map[Vertex]int, len(vs)),
	}
	for _, v := range vs {
		if v != sid {
			dist[v] = Infinity
		}
		prev[v] = Uninitialized
		q.addWithPriority(v, dist[v])
	}
	for len(q.items) != 0 {
		u := heap.Pop(q).(Vertex)
		for _, v := range g.Neighbors(u) {
			alt := dist[u] + g.Weight(u, v)
			if alt < dist[v] {
				dist[v] = alt
				prev[v] = u
				q.update(v, alt)
			}
		}
	}
	return dist, prev
}
 
// A Graph is the interface implemented by graphs that
// this algorithm can run on.
type Graph interface {
	Vertices() []Vertex
	Neighbors(v Vertex) []Vertex
	Weight(u, v Vertex) int
}
 
// Nonnegative integer ID of vertex
type Vertex int
 
// sg is a graph of strings that satisfies the Graph interface.
type sg struct {
	ids   map[string]Vertex
	names map[Vertex]string
	edges map[Vertex]map[Vertex]int
}
 
func newsg(ids map[string]Vertex) sg {
	g := sg{ids: ids}
	g.names = make(map[Vertex]string, len(ids))
	for k, v := range ids {
		g.names[v] = k
	}
	g.edges = make(map[Vertex]map[Vertex]int)
	return g
}
func (g sg) edge(u, v string, w int) {
	if _, ok := g.edges[g.ids[u]]; !ok {
		g.edges[g.ids[u]] = make(map[Vertex]int)
	}
	g.edges[g.ids[u]][g.ids[v]] = w
}
func (g sg) path(v Vertex, prev map[Vertex]Vertex) (s string) {
	s = g.names[v]
	for prev[v] >= 0 {
		v = prev[v]
		s = g.names[v] + s
	}
	return s
}
func (g sg) Vertices() []Vertex {
	vs := make([]Vertex, 0, len(g.ids))
	for _, v := range g.ids {
		vs = append(vs, v)
	}
	return vs
}
func (g sg) Neighbors(u Vertex) []Vertex {
	vs := make([]Vertex, 0, len(g.edges[u]))
	for v := range g.edges[u] {
		vs = append(vs, v)
	}
	return vs
}
func (g sg) Weight(u, v Vertex) int { return g.edges[u][v] }
 
func main() {
	g := newsg(map[string]Vertex{
		""a"": 1,
		""b"": 2,
		""c"": 3,
		""d"": 4,
		""e"": 5,
		""f"": 6,
	})
	g.edge(""a"", ""b"", 7)
	g.edge(""a"", ""c"", 9)
	g.edge(""a"", ""f"", 14)
	g.edge(""b"", ""c"", 10)
	g.edge(""b"", ""d"", 15)
	g.edge(""c"", ""d"", 11)
	g.edge(""c"", ""f"", 2)
	g.edge(""d"", ""e"", 6)
	g.edge(""e"", ""f"", 9)
 
	dist, prev := Dijkstra(g, g.ids[""a""])
	fmt.Printf(""Distance to %s: %d, Path: %s\n"", ""e"", dist[g.ids[""e""]], g.path(g.ids[""e""], prev))
	fmt.Printf(""Distance to %s: %d, Path: %s\n"", ""f"", dist[g.ids[""f""]], g.path(g.ids[""f""], prev))
}",3734,163
61883,http://rosettacode.org/wiki/Dinesman%27s_multiple-dwelling_problem,Dinesman's multiple-dwelling problem,"Task
Solve Dinesman's multiple dwelling problem but in a way that most naturally follows the problem statement given below.

Solutions are allowed (but not required) to parse and interpret the problem text, but should remain flexible and should state what changes to the problem text are allowed. Flexibility and ease of expression are valued.

Examples may be be split into ""setup"", ""problem statement"", and ""output"" sections where the ease and naturalness of stating the problem and getting an answer, as well as the ease and flexibility of modifying the problem are the primary concerns.

Example output should be shown here, as well as any comments on the examples flexibility.



The problem
Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an apartment house that contains only five floors.


   Baker does not live on the top floor.
   Cooper does not live on the bottom floor. 
   Fletcher does not live on either the top or the bottom floor.
   Miller lives on a higher floor than does Cooper.
   Smith does not live on a floor adjacent to Fletcher's. 
   Fletcher does not live on a floor adjacent to Cooper's.

Where does everyone live?
",#Go,Go,"package main
 
import ""fmt""
 
// The program here is restricted to finding assignments of tenants (or more
// generally variables with distinct names) to floors (or more generally
// integer values.)  It finds a solution assigning all tenants and assigning
// them to different floors.
 
// Change number and names of tenants here.  Adding or removing names is
// allowed but the names should be distinct; the code is not written to handle
// duplicate names.
var tenants = []string{""Baker"", ""Cooper"", ""Fletcher"", ""Miller"", ""Smith""}
 
// Change the range of floors here.  The bottom floor does not have to be 1.
// These should remain non-negative integers though.
const bottom = 1
const top = 5
 
// A type definition for readability.  Do not change.
type assignments map[string]int
 
// Change rules defining the problem here.  Change, add, or remove rules as
// desired.  Each rule should first be commented as human readable text, then
// coded as a function.  The function takes a tentative partial list of
// assignments of tenants to floors and is free to compute anything it wants
// with this information.  Other information available to the function are
// package level defintions, such as top and bottom.  A function returns false
// to say the assignments are invalid.
var rules = []func(assignments) bool{
    // Baker does not live on the top floor
    func(a assignments) bool {
        floor, assigned := a[""Baker""]
        return !assigned || floor != top
    },
    // Cooper does not live on the bottom floor
    func(a assignments) bool {
        floor, assigned := a[""Cooper""]
        return !assigned || floor != bottom
    },
    // Fletcher does not live on either the top or the bottom floor
    func(a assignments) bool {
        floor, assigned := a[""Fletcher""]
        return !assigned || (floor != top && floor != bottom)
    },
    // Miller lives on a higher floor than does Cooper
    func(a assignments) bool {
        if m, assigned := a[""Miller""]; assigned {
            c, assigned := a[""Cooper""]
            return !assigned || m > c
        }
        return true
    },
    // Smith does not live on a floor adjacent to Fletcher's
    func(a assignments) bool {
        if s, assigned := a[""Smith""]; assigned {
            if f, assigned := a[""Fletcher""]; assigned {
                d := s - f
                return d*d > 1
            }
        }
        return true
    },
    // Fletcher does not live on a floor adjacent to Cooper's
    func(a assignments) bool {
        if f, assigned := a[""Fletcher""]; assigned {
            if c, assigned := a[""Cooper""]; assigned {
                d := f - c
                return d*d > 1
            }
        }
        return true
    },
}
 
// Assignment program, do not change.  The algorithm is a depth first search,
// tentatively assigning each tenant in order, and for each tenant trying each
// unassigned floor in order.  For each tentative assignment, it evaluates all
// rules in the rules list and backtracks as soon as any one of them fails.
//
// This algorithm ensures that the tenative assignments have only names in the
// tenants list, only floor numbers from bottom to top, and that tentants are
// assigned to different floors.  These rules are hard coded here and do not
// need to be coded in the the rules list above.
func main() {
    a := assignments{}
    var occ [top + 1]bool
    var df func([]string) bool
    df = func(u []string) bool {
        if len(u) == 0 {
            return true
        }
        tn := u[0]
        u = u[1:]
    f:
        for f := bottom; f <= top; f++ {
            if !occ[f] {
                a[tn] = f
                for _, r := range rules {
                    if !r(a) {
                        delete(a, tn)
                        continue f
                    }
                }
                occ[f] = true
                if df(u) {
                    return true
                }
                occ[f] = false
                delete(a, tn)
            }
        }
        return false
    }
    if !df(tenants) {
        fmt.Println(""no solution"")
        return
    }
    for t, f := range a {
        fmt.Println(t, f)
    }
}",4189,122
61920,http://rosettacode.org/wiki/Dining_philosophers,Dining philosophers,"The dining philosophers problem illustrates non-composability of low-level synchronization primitives like semaphores. It is a modification of a problem posed by Edsger Dijkstra.

Five philosophers, Aristotle, Kant, Spinoza, Marx, and Russell (the tasks) spend their time thinking and eating spaghetti. They eat at a round table with five individual seats. For eating each philosopher needs two forks (the resources). There are five forks on the table, one left and one right of each seat. When a philosopher cannot grab both forks it sits and waits. Eating takes random time, then the philosopher puts the forks down and leaves the dining room. After spending some random time thinking about the nature of the universe, he again becomes hungry, and the circle repeats itself.

It can be observed that a straightforward solution, when forks are implemented by semaphores, is exposed to deadlock. There exist two deadlock states when all five philosophers are sitting at the table holding one fork each. One deadlock state is when each philosopher has grabbed the fork left of him, and another is when each has the fork on his right.

There are many solutions of the problem, program at least one, and explain how the deadlock is prevented.
",#Go,Go,"package main
 
import (
    ""hash/fnv""
    ""log""
    ""math/rand""
    ""os""
    ""time""
)
 
// Number of philosophers is simply the length of this list.
// It is not otherwise fixed in the program.
var ph = []string{""Aristotle"", ""Kant"", ""Spinoza"", ""Marx"", ""Russell""}
 
const hunger = 3                // number of times each philosopher eats
const think = time.Second / 100 // mean think time
const eat = time.Second / 100   // mean eat time
 
var fmt = log.New(os.Stdout, """", 0) // for thread-safe output
 
var done = make(chan bool)
 
// This solution uses channels to implement synchronization.
// Sent over channels are ""forks.""
type fork byte
 
// A fork object in the program models a physical fork in the simulation.
// A separate channel represents each fork place.  Two philosophers
// have access to each fork.  The channels are buffered with capacity = 1,
// representing a place for a single fork.
 
// Goroutine for philosopher actions.  An instance is run for each
// philosopher.  Instances run concurrently.
func philosopher(phName string,
    dominantHand, otherHand chan fork, done chan bool) {
    fmt.Println(phName, ""seated"")
    // each philosopher goroutine has a random number generator,
    // seeded with a hash of the philosopher's name.
    h := fnv.New64a()
    h.Write([]byte(phName))
    rg := rand.New(rand.NewSource(int64(h.Sum64())))
    // utility function to sleep for a randomized nominal time
    rSleep := func(t time.Duration) {
        time.Sleep(t/2 + time.Duration(rg.Int63n(int64(t))))
    }
    for h := hunger; h > 0; h-- {
        fmt.Println(phName, ""hungry"")
        <-dominantHand // pick up forks
        <-otherHand
        fmt.Println(phName, ""eating"")
        rSleep(eat)
        dominantHand <- 'f' // put down forks
        otherHand <- 'f'
        fmt.Println(phName, ""thinking"")
        rSleep(think)
    }
    fmt.Println(phName, ""satisfied"")
    done <- true
    fmt.Println(phName, ""left the table"")
}
 
func main() {
    fmt.Println(""table empty"")
    // Create fork channels and start philosopher goroutines,
    // supplying each goroutine with the appropriate channels
    place0 := make(chan fork, 1)
    place0 <- 'f' // byte in channel represents a fork on the table.
    placeLeft := place0
    for i := 1; i < len(ph); i++ {
        placeRight := make(chan fork, 1)
        placeRight <- 'f'
        go philosopher(ph[i], placeLeft, placeRight, done)
        placeLeft = placeRight
    }
    // Make one philosopher left handed by reversing fork place
    // supplied to philosopher's dominant hand.
    // This makes precedence acyclic, preventing deadlock.
    go philosopher(ph[0], place0, placeLeft, done)
    // they are all now busy eating
    for range ph {
        <-done // wait for philosphers to finish
    }
    fmt.Println(""table empty"")
}",2819,84
61972,http://rosettacode.org/wiki/Discordian_date,Discordian date,"

Task

Convert a given date from the   Gregorian calendar   to the   Discordian calendar.



",#Go,Go,"package ddate
 
import (
    ""strconv""
    ""strings"" 
    ""time""
)   
 
// Predefined formats for DiscDate.Format
const (
    DefaultFmt = ""Pungenday, Discord 5, 3131 YOLD""
    OldFmt     = `Today is Pungenday, the 5th day of Discord in the YOLD 3131
Celebrate Mojoday`
)
 
// Formats passed to DiscDate.Format are protypes for formated dates.
// Format replaces occurrences of prototype elements (the constant strings
// listed here) with values corresponding to the date being formatted.
// If the date is St. Tib's Day, the string from the first date element
// through the last is replaced with ""St. Tib's Day"".
const (
    protoLongSeason  = ""Discord""
    protoShortSeason = ""Dsc""
    protoLongDay     = ""Pungenday""
    protoShortDay    = ""PD""
    protoOrdDay      = ""5""
    protoCardDay     = ""5th""
    protoHolyday     = ""Mojoday""
    protoYear        = ""3131""
)
 
var (
    longDay = []string{""Sweetmorn"", ""Boomtime"", ""Pungenday"",
        ""Prickle-Prickle"", ""Setting Orange""}
    shortDay   = []string{""SM"", ""BT"", ""PD"", ""PP"", ""SO""}
    longSeason = []string{
        ""Chaos"", ""Discord"", ""Confusion"", ""Bureaucracy"", ""The Aftermath""}
    shortSeason = []string{""Chs"", ""Dsc"", ""Cfn"", ""Bcy"", ""Afm""}
    holyday     = [][]string{{""Mungday"", ""Chaoflux""}, {""Mojoday"", ""Discoflux""},
        {""Syaday"", ""Confuflux""}, {""Zaraday"", ""Bureflux""}, {""Maladay"", ""Afflux""}}
)   
 
type DiscDate struct {
    StTibs bool
    Dayy   int // zero based day of year, meaningless if StTibs is true
    Year   int // gregorian + 1166
}
 
func New(eris time.Time) DiscDate {
    t := time.Date(eris.Year(), 1, 1, eris.Hour(), eris.Minute(),
        eris.Second(), eris.Nanosecond(), eris.Location())
    bob := int(eris.Sub(t).Hours()) / 24
    raw := eris.Year()
    hastur := DiscDate{Year: raw + 1166}
    if raw%4 == 0 && (raw%100 != 0 || raw%400 == 0) {
        if bob > 59 {
            bob--
        } else if bob == 59 {
            hastur.StTibs = true
            return hastur
        }
    }
    hastur.Dayy = bob
    return hastur
}
 
func (dd DiscDate) Format(f string) (r string) {
    var st, snarf string
    var dateElement bool
    f6 := func(proto, wibble string) {
        if !dateElement {
            snarf = r
            dateElement = true
        }
        if st > """" {
            r = """"
        } else {
            r += wibble
        }
        f = f[len(proto):]
    }
    f4 := func(proto, wibble string) {
        if dd.StTibs {
            st = ""St. Tib's Day""
        }
        f6(proto, wibble)
    }
    season, day := dd.Dayy/73, dd.Dayy%73
    for f > """" {
        switch {
        case strings.HasPrefix(f, protoLongDay):
            f4(protoLongDay, longDay[dd.Dayy%5])
        case strings.HasPrefix(f, protoShortDay):
            f4(protoShortDay, shortDay[dd.Dayy%5])
        case strings.HasPrefix(f, protoCardDay):
            funkychickens := ""th""
            if day/10 != 1 {
                switch day % 10 {
                case 0:
                    funkychickens = ""st""
                case 1:
                    funkychickens = ""nd""
                case 2:
                    funkychickens = ""rd""
                }
            }
            f4(protoCardDay, strconv.Itoa(day+1)+funkychickens)
        case strings.HasPrefix(f, protoOrdDay):
            f4(protoOrdDay, strconv.Itoa(day+1))
        case strings.HasPrefix(f, protoLongSeason):
            f6(protoLongSeason, longSeason[season])
        case strings.HasPrefix(f, protoShortSeason):
            f6(protoShortSeason, shortSeason[season])
        case strings.HasPrefix(f, protoHolyday):
            if day == 4 {
                r += holyday[season][0]
            } else if day == 49 {
                r += holyday[season][1]
            }
            f = f[len(protoHolyday):]
        case strings.HasPrefix(f, protoYear):
            r += strconv.Itoa(dd.Year)
            f = f[4:]
        default:
            r += f[:1]
            f = f[1:]
        }
    }
    if st > """" { 
        r = snarf + st + r
    }
    return
}   ",4029,133
62055,http://rosettacode.org/wiki/Descending_primes,Descending primes,"Generate and show all primes with strictly descending decimal digits.

See also
 OEIS:A052014 - Primes with distinct digits in descending order
Related

Ascending primes

",#Go,Go,"package main
 
import (
    ""fmt""
    ""rcu""
    ""sort""
    ""strconv""
)
 
func combinations(a []int, k int) [][]int {
    n := len(a)
    c := make([]int, k)
    var combs [][]int
    var combine func(start, end, index int)
    combine = func(start, end, index int) {
        if index == k {
            t := make([]int, len(c))
            copy(t, c)
            combs = append(combs, t)
            return
        }
        for i := start; i <= end && end-i+1 >= k-index; i++ {
            c[index] = a[i]
            combine(i+1, end, index+1)
        }
    }
    combine(0, n-1, 0)
    return combs
}
 
func powerset(a []int) (res [][]int) {
    if len(a) == 0 {
        return
    }
    for i := 1; i <= len(a); i++ {
        res = append(res, combinations(a, i)...)
    }
    return
}
 
func main() {
    ps := powerset([]int{9, 8, 7, 6, 5, 4, 3, 2, 1})
    var descPrimes []int
    for i := 1; i < len(ps); i++ {
        s := """"
        for _, e := range ps[i] {
            s += string(e + '0')
        }
        p, _ := strconv.Atoi(s)
        if rcu.IsPrime(p) {
            descPrimes = append(descPrimes, p)
        }
    }
    sort.Ints(descPrimes)
    fmt.Println(""There are"", len(descPrimes), ""descending primes, namely:"")
    for i := 0; i < len(descPrimes); i++ {
        fmt.Printf(""%8d "", descPrimes[i])
        if (i+1)%10 == 0 {
            fmt.Println()
        }
    }
    fmt.Println()
}",1410,63
62135,http://rosettacode.org/wiki/Determine_if_a_string_is_squeezable,Determine if a string is squeezable,"Determine if a character string is   squeezable.

And if so,   squeeze the string   (by removing any number of
a   specified   immediately repeated   character).



This task is very similar to the task     Determine if a character string is collapsible     except
that only a specified character is   squeezed   instead of any character that is immediately repeated.



If a character string has a specified   immediately repeated   character(s),   the repeated characters are to be
deleted (removed),   but not the primary (1st) character(s).



A specified   immediately repeated   character is any specified character that is   immediately  
followed by an identical character (or characters).   Another word choice could've been   duplicated
character,   but that might have ruled out   (to some readers)   triplicated characters   ···   or more.



{This Rosetta Code task was inspired by a newly introduced   (as of around
November 2019)   PL/I   BIF:   squeeze.}



Examples

In the following character string with a specified   immediately repeated   character of   e:



 The better the 4-wheel drive, the further you'll be from help when ya get stuck! 



Only the 2nd   e   is an specified repeated character,   indicated by an underscore
(above),   even though they (the characters) appear elsewhere in the character string.



So, after squeezing the string, the result would be:

 The better the 4-whel drive, the further you'll be from help when ya get stuck! 





Another example:
In the following character string,   using a specified immediately repeated character   s:

 headmistressship 



The ""squeezed"" string would be:

 headmistreship 



Task

Write a subroutine/function/procedure/routine···   to locate a   specified immediately repeated   character
and   squeeze   (delete)   them from the character string.   The
character string can be processed from either direction.



Show all output here, on this page:

   the   specified repeated character   (to be searched for and possibly squeezed):
   the   original string and its length
   the resultant string and its length
   the above strings should be ""bracketed"" with   <<<   and   >>>   (to delineate blanks)
   «««Guillemets may be used instead for ""bracketing"" for the more artistic programmers,   shown used here»»»


Use (at least) the following five strings,   all strings are length seventy-two (characters, including blanks),   except
the 1st string:

                                                                                  immediately
 string                                                                            repeated
 number                                                                            character
                                                                                     ( ↓   a blank,  a minus,  a seven,  a period)
        ╔╗
   1    ║╚═══════════════════════════════════════════════════════════════════════╗    ' '    ◄■■■■■■  a null string  (length zero)
   2    ║""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln ║    '-'
   3    ║..1111111111111111111111111111111111111111111111111111111111111117777888║    '7'
   4    ║I never give 'em hell, I just tell the truth, and they think it's hell. ║    '.'
   5    ║                                                    --- Harry S Truman  ║  (below)  ◄■■■■■■  has many repeated blanks
        ╚════════════════════════════════════════════════════════════════════════╝     ↑
                                                                                       │
                                                                                       │
        For the 5th string  (Truman's signature line),  use each of these  specified immediately  repeated characters:
                                  •  a blank
                                  •  a minus
                                  •  a lowercase  r



Note:   there should be seven results shown,   one each for the 1st four strings,   and three results for
the 5th string.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import ""fmt""
 
// Returns squeezed string, original and new lengths in
// unicode code points (not normalized).
func squeeze(s string, c rune) (string, int, int) {
    r := []rune(s)
    le, del := len(r), 0
    for i := le - 2; i >= 0; i-- {
        if r[i] == c && r[i] == r[i+1] {
            copy(r[i:], r[i+1:])
            del++
        }
    }
    if del == 0 {
        return s, le, le
    }
    r = r[:le-del]
    return string(r), le, len(r)
}
 
func main() {
    strings := []string{
        """",
        `""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln `,
        ""..1111111111111111111111111111111111111111111111111111111111111117777888"",
        ""I never give 'em hell, I just tell the truth, and they think it's hell. "",
        ""                                                   ---  Harry S Truman  "",
        ""The better the 4-wheel drive, the further you'll be from help when ya get stuck!"",
        ""headmistressship"",
        ""aardvark"",
        ""😍😀🙌💃😍😍😍🙌"",
    }
    chars := [][]rune{{' '}, {'-'}, {'7'}, {'.'}, {' ', '-', 'r'}, {'e'}, {'s'}, {'a'}, {'😍'}}
 
    for i, s := range strings {
        for _, c := range chars[i] {
            ss, olen, slen := squeeze(s, c)
            fmt.Printf(""specified character = %q\n"", c)
            fmt.Printf(""original : length = %2d, string = «««%s»»»\n"", olen, s)
            fmt.Printf(""squeezed : length = %2d, string = «««%s»»»\n\n"", slen, ss)
        }
    }
}",1470,45
62136,http://rosettacode.org/wiki/Deming%27s_Funnel,Deming's Funnel,"W Edwards Deming was an American statistician and management guru who used physical demonstrations to illuminate his teachings. In one demonstration Deming repeatedly dropped marbles through a funnel at a target, marking where they landed, and observing the resulting pattern. He applied a sequence of ""rules"" to try to improve performance. In each case the experiment begins with the funnel positioned directly over the target.

 Rule 1: The funnel remains directly above the target.
 Rule 2: Adjust the funnel position by shifting the target to compensate after each drop. E.g. If the last drop missed 1 cm east, move the funnel 1 cm to the west of its current position.
 Rule 3: As rule 2, but first move the funnel back over the target, before making the adjustment. E.g. If the funnel is 2 cm north, and the marble lands 3 cm north, move the funnel 3 cm south of the target.
 Rule 4: The funnel is moved directly over the last place a marble landed.
Apply the four rules to the set of 50 pseudorandom displacements provided (e.g in the Racket solution) for the dxs and dys. Output: calculate the mean and standard-deviations of the resulting x and y values for each rule.

Note that rules 2, 3, and 4 give successively worse results. Trying to deterministically compensate for a random process is counter-productive, but -- according to Deming -- quite a popular pastime: see the Further Information, below for examples.

Stretch goal 1: Generate fresh pseudorandom data. The radial displacement of the drop from the funnel position is given by a Gaussian distribution (standard deviation is 1.0) and the angle of displacement is uniformly distributed.

Stretch goal 2: Show scatter plots of all four results.



Further information

 Further explanation and interpretation
 Video demonstration of the funnel experiment at the Mayo Clinic.",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
type rule func(float64, float64) float64
 
var dxs = []float64{
    -0.533,  0.270,  0.859, -0.043, -0.205, -0.127, -0.071,  0.275,
     1.251, -0.231, -0.401,  0.269,  0.491,  0.951,  1.150,  0.001,
    -0.382,  0.161,  0.915,  2.080, -2.337,  0.034, -0.126,  0.014,
     0.709,  0.129, -1.093, -0.483, -1.193,  0.020, -0.051,  0.047,
    -0.095,  0.695,  0.340, -0.182,  0.287,  0.213, -0.423, -0.021,
    -0.134,  1.798,  0.021, -1.099, -0.361,  1.636, -1.134,  1.315,
     0.201,  0.034,  0.097, -0.170,  0.054, -0.553, -0.024, -0.181,
    -0.700, -0.361, -0.789,  0.279, -0.174, -0.009, -0.323, -0.658,
     0.348, -0.528,  0.881,  0.021, -0.853,  0.157,  0.648,  1.774,
    -1.043,  0.051,  0.021,  0.247, -0.310,  0.171,  0.000,  0.106,
     0.024, -0.386,  0.962,  0.765, -0.125, -0.289,  0.521,  0.017,
     0.281, -0.749, -0.149, -2.436, -0.909,  0.394, -0.113, -0.598,
     0.443, -0.521, -0.799,  0.087,
}
 
var dys = []float64{
     0.136,  0.717,  0.459, -0.225,  1.392,  0.385,  0.121, -0.395,
     0.490, -0.682, -0.065,  0.242, -0.288,  0.658,  0.459,  0.000,
     0.426,  0.205, -0.765, -2.188, -0.742, -0.010,  0.089,  0.208,
     0.585,  0.633, -0.444, -0.351, -1.087,  0.199,  0.701,  0.096,
    -0.025, -0.868,  1.051,  0.157,  0.216,  0.162,  0.249, -0.007,
     0.009,  0.508, -0.790,  0.723,  0.881, -0.508,  0.393, -0.226,
     0.710,  0.038, -0.217,  0.831,  0.480,  0.407,  0.447, -0.295,
     1.126,  0.380,  0.549, -0.445, -0.046,  0.428, -0.074,  0.217,
    -0.822,  0.491,  1.347, -0.141,  1.230, -0.044,  0.079,  0.219,
     0.698,  0.275,  0.056,  0.031,  0.421,  0.064,  0.721,  0.104,
    -0.729,  0.650, -1.103,  0.154, -1.720,  0.051, -0.385,  0.477,
     1.537, -0.901,  0.939, -0.411,  0.341, -0.411,  0.106,  0.224,
    -0.947, -1.424, -0.542, -1.032,
}
 
func funnel(fa []float64, r rule) []float64 {
    x := 0.0
    result := make([]float64, len(fa))
    for i, f := range fa {
        result[i] = x + f
        x = r(x, f)
    }
    return result
}
 
func mean(fa []float64) float64 {
    sum := 0.0
    for _, f := range fa {
        sum += f
    }
    return sum / float64(len(fa))
}
 
func stdDev(fa []float64) float64 {
    m := mean(fa)
    sum := 0.0
    for _, f := range fa {
        sum += (f - m) * (f - m)
    }
    return math.Sqrt(sum / float64(len(fa)))
}
 
func experiment(label string, r rule) {
    rxs := funnel(dxs, r)
    rys := funnel(dys, r)
    fmt.Println(label, "" :      x        y"")
    fmt.Printf(""Mean    :  %7.4f, %7.4f\n"", mean(rxs), mean(rys))
    fmt.Printf(""Std Dev :  %7.4f, %7.4f\n"", stdDev(rxs), stdDev(rys))
    fmt.Println()
}
 
func main() {
    experiment(""Rule 1"", func(_, _ float64) float64 {
        return 0.0
    })
    experiment(""Rule 2"", func(_, dz float64) float64 {
        return -dz
    })
    experiment(""Rule 3"", func(z, dz float64) float64 {
        return -(z + dz)
    })
    experiment(""Rule 4"", func(z, dz float64) float64 {
        return z + dz
    })
}",3008,91
62155,http://rosettacode.org/wiki/Determine_if_a_string_is_collapsible,Determine if a string is collapsible,"Determine if a character string is   collapsible.

And if so,   collapse the string   (by removing   immediately repeated   characters).



If a character string has   immediately repeated   character(s),   the repeated characters are to be
deleted (removed),   but not the primary (1st) character(s).



An   immediately repeated   character is any character that is   immediately   followed by an
identical character (or characters).   Another word choice could've been   duplicated character,   but that
might have ruled out   (to some readers)   triplicated characters   ···   or more.



{This Rosetta Code task was inspired by a newly introduced   (as of around November 2019)   PL/I   BIF:   collapse.}



Examples

In the following character string:



 The better the 4-wheel drive, the further you'll be from help when ya get stuck! 



Only the 2nd   t,   e, and   l   are repeated characters,   indicated
by underscores (above),   even though they (those characters) appear elsewhere in the character string.



So, after collapsing the string, the result would be:

 The beter the 4-whel drive, the further you'l be from help when ya get stuck! 





Another example:
In the following character string:

 headmistressship 



The ""collapsed"" string would be:

 headmistreship 



Task

Write a subroutine/function/procedure/routine···   to
locate   repeated   characters and   collapse   (delete)   them from the character
string.   The character string can be processed from either direction.



Show all output here, on this page:

   the   original string and its length
   the resultant string and its length
   the above strings should be ""bracketed"" with   <<<   and   >>>   (to delineate blanks)
   «««Guillemets may be used instead for ""bracketing"" for the more artistic programmers,   shown used here»»»


Use (at least) the following five strings,   all strings are length seventy-two (characters, including blanks),   except
the 1st string:

 string
 number
        ╔╗
   1    ║╚═══════════════════════════════════════════════════════════════════════╗   ◄■■■■■■  a null string  (length zero)
   2    ║""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln ║
   3    ║..1111111111111111111111111111111111111111111111111111111111111117777888║
   4    ║I never give 'em hell, I just tell the truth, and they think it's hell. ║
   5    ║                                                    --- Harry S Truman  ║   ◄■■■■■■  has many repeated blanks
        ╚════════════════════════════════════════════════════════════════════════╝


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import ""fmt""
 
// Returns collapsed string, original and new lengths in
// unicode code points (not normalized).
func collapse(s string) (string, int, int) {
    r := []rune(s)
    le, del := len(r), 0
    for i := le - 2; i >= 0; i-- {
        if r[i] == r[i+1] {
            copy(r[i:], r[i+1:])
            del++
        }
    }
    if del == 0 {
        return s, le, le
    }
    r = r[:le-del]
    return string(r), le, len(r)
}
 
func main() {
    strings:= []string {
        """",
        `""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln `,
        ""..1111111111111111111111111111111111111111111111111111111111111117777888"",
        ""I never give 'em hell, I just tell the truth, and they think it's hell. "",
        ""                                                   ---  Harry S Truman  "",
        ""The better the 4-wheel drive, the further you'll be from help when ya get stuck!"",
        ""headmistressship"",
        ""aardvark"",
        ""😍😀🙌💃😍😍😍🙌"",
    }
    for _, s := range strings {
        cs, olen, clen := collapse(s)
        fmt.Printf(""original : length = %2d, string = «««%s»»»\n"", olen, s)
        fmt.Printf(""collapsed: length = %2d, string = «««%s»»»\n\n"", clen, cs)
    }
}",1237,40
62188,http://rosettacode.org/wiki/Digital_root,Digital root,"The digital root, 



X


{\displaystyle X}

, of a number, 



n


{\displaystyle n}

, is calculated:

 find 



X


{\displaystyle X}

 as the sum of the digits of 



n


{\displaystyle n}


 find a new 



X


{\displaystyle X}

 by summing the digits of 



X


{\displaystyle X}

, repeating until 



X


{\displaystyle X}

 has only one digit.
The additive persistence is the number of summations required to obtain the single digit.

The task is to calculate the additive persistence and the digital root of a number, e.g.:





627615


{\displaystyle 627615}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



9


{\displaystyle 9}

;




39390


{\displaystyle 39390}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



6


{\displaystyle 6}

;




588225


{\displaystyle 588225}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



3


{\displaystyle 3}

;




393900588225


{\displaystyle 393900588225}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



9


{\displaystyle 9}

;
The digital root may be calculated in bases other than 10.



See

 Casting out nines for this wiki's use of this procedure.
 Digital root/Multiplicative digital root
 Sum digits of an integer
 Digital root sequence on OEIS
 Additive persistence sequence on OEIS
 Iterated digits squaring

",#Go,Go,"package main
 
import (
	""fmt""
	""log""
	""strconv""
)
 
func Sum(i uint64, base int) (sum int) {
	b64 := uint64(base)
	for ; i > 0; i /= b64 {
		sum += int(i % b64)
	}
	return
}
 
func DigitalRoot(n uint64, base int) (persistence, root int) {
	root = int(n)
	for x := n; x >= uint64(base); x = uint64(root) {
		root = Sum(x, base)
		persistence++
	}
	return
}
 
// Normally the below would be moved to a *_test.go file and
// use the testing package to be runnable as a regular test.
 
var testCases = []struct {
	n           string
	base        int
	persistence int
	root        int
}{
	{""627615"", 10, 2, 9},
	{""39390"", 10, 2, 6},
	{""588225"", 10, 2, 3},
	{""393900588225"", 10, 2, 9},
	{""1"", 10, 0, 1},
	{""11"", 10, 1, 2},
	{""e"", 16, 0, 0xe},
	{""87"", 16, 1, 0xf},
	// From Applesoft BASIC example:
	{""DigitalRoot"", 30, 2, 26}, // 26 is Q base 30
	// From C++ example:
	{""448944221089"", 10, 3, 1},
	{""7e0"", 16, 2, 0x6},
	{""14e344"", 16, 2, 0xf},
	{""d60141"", 16, 2, 0xa},
	{""12343210"", 16, 2, 0x1},
	// From the D example:
	{""1101122201121110011000000"", 3, 3, 1},
}
 
func main() {
	for _, tc := range testCases {
		n, err := strconv.ParseUint(tc.n, tc.base, 64)
		if err != nil {
			log.Fatal(err)
		}
		p, r := DigitalRoot(n, tc.base)
		fmt.Printf(""%12v (base %2d) has additive persistence %d and digital root %s\n"",
			tc.n, tc.base, p, strconv.FormatInt(int64(r), tc.base))
		if p != tc.persistence || r != tc.root {
			log.Fatalln(""bad result:"", tc, p, r)
		}
	}
}",1461,68
62191,http://rosettacode.org/wiki/Dot_product,Dot product,"Task

Create a function/use an in-built function, to compute the   dot product,   also known as the   scalar product   of two vectors.

If possible, make the vectors of arbitrary length.



As an example, compute the dot product of the vectors:

     [1,  3, -5]       and 
     [4, -2, -1]   


If implementing the dot product of two vectors directly:

   each vector must be the same length
   multiply corresponding terms from each vector
   sum the products   (to produce the answer)


Related task

   Vector products

",#Go,Go,"package main
 
import (
    ""errors""
    ""fmt""
    ""log""
)
 
var (
    v1 = []int{1, 3, -5}
    v2 = []int{4, -2, -1}
)
 
func dot(x, y []int) (r int, err error) {
    if len(x) != len(y) {
        return 0, errors.New(""incompatible lengths"")
    }
    for i, xi := range x {
        r += xi * y[i]
    }
    return
}
 
func main() {
    d, err := dot([]int{1, 3, -5}, []int{4, -2, -1})
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(d)
}",456,30
62222,http://rosettacode.org/wiki/Determine_if_two_triangles_overlap,Determine if two triangles overlap,"Determining if two triangles in the same plane overlap is an important topic in collision detection.



Task

Determine which of these pairs of triangles overlap in 2D:

   (0,0),(5,0),(0,5)     and   (0,0),(5,0),(0,6)
   (0,0),(0,5),(5,0)     and   (0,0),(0,5),(5,0)
   (0,0),(5,0),(0,5)     and   (-10,0),(-5,0),(-1,6)
   (0,0),(5,0),(2.5,5)   and   (0,4),(2.5,-1),(5,4)
   (0,0),(1,1),(0,2)     and   (2,1),(3,0),(3,2)
   (0,0),(1,1),(0,2)     and   (2,1),(3,-2),(3,4)


Optionally, see what the result is when only a single corner is in contact (there is no definitive correct answer):

   (0,0),(1,0),(0,1)   and   (1,0),(2,0),(1,1)

",#Go,Go,"package main
 
import ""fmt""
 
type point struct {
    x, y float64
}
 
func (p point) String() string {
    return fmt.Sprintf(""(%.1f, %.1f)"", p.x, p.y)
}
 
type triangle struct {
    p1, p2, p3 point
}
 
func (t *triangle) String() string {
    return fmt.Sprintf(""Triangle %s, %s, %s"", t.p1, t.p2, t.p3)
}
 
func (t *triangle) det2D() float64 {
    return t.p1.x * (t.p2.y - t.p3.y) +
           t.p2.x * (t.p3.y - t.p1.y) +
           t.p3.x * (t.p1.y - t.p2.y) 
}
 
func (t *triangle) checkTriWinding(allowReversed bool) {
    detTri := t.det2D()
    if detTri < 0.0 {
        if allowReversed {
            a := t.p3
            t.p3 = t.p2
            t.p2 = a
        } else {
            panic(""Triangle has wrong winding direction."")
        }
    }
}
 
func boundaryCollideChk(t *triangle, eps float64) bool {
    return t.det2D() < eps
}
 
func boundaryDoesntCollideChk(t *triangle, eps float64) bool {
    return t.det2D() <= eps
}
 
func triTri2D(t1, t2 *triangle, eps float64, allowReversed, onBoundary bool) bool {
    // Triangles must be expressed anti-clockwise.
    t1.checkTriWinding(allowReversed)
    t2.checkTriWinding(allowReversed)
 
    // 'onBoundary' determines whether points on boundary are considered as colliding or not.
    var chkEdge func (*triangle, float64) bool
    if onBoundary {
        chkEdge = boundaryCollideChk
    } else {
        chkEdge = boundaryDoesntCollideChk
    }
    lp1 := [3]point{t1.p1, t1.p2, t1.p3}
    lp2 := [3]point{t2.p1, t2.p2, t2.p3}
 
    // for each edge E of t1
    for i := 0; i < 3; i++ {
        j := (i + 1) % 3
        // Check all points of t2 lay on the external side of edge E.
        // If they do, the triangles do not overlap.
        tri1 := &triangle{lp1[i], lp1[j], lp2[0]}
        tri2 := &triangle{lp1[i], lp1[j], lp2[1]}
        tri3 := &triangle{lp1[i], lp1[j], lp2[2]}
        if chkEdge(tri1, eps) && chkEdge(tri2, eps) && chkEdge(tri3, eps) {
            return false
        }
    }
 
    // for each edge E of t2
    for i := 0; i < 3; i++ {
        j := (i + 1) % 3
        // Check all points of t1 lay on the external side of edge E.
        // If they do, the triangles do not overlap.
        tri1 := &triangle{lp2[i], lp2[j], lp1[0]}
        tri2 := &triangle{lp2[i], lp2[j], lp1[1]}
        tri3 := &triangle{lp2[i], lp2[j], lp1[2]}
        if chkEdge(tri1, eps) && chkEdge(tri2, eps) && chkEdge(tri3, eps) {
            return false
        }
    }
 
    // The triangles overlap.
    return true
}
 
func iff(cond bool, s1, s2 string) string {
    if cond {
        return s1
    }
    return s2
}
 
func main() {
    t1 := &triangle{point{0.0, 0.0}, point{5.0, 0.0}, point{0.0, 5.0}}
    t2 := &triangle{point{0.0, 0.0}, point{5.0, 0.0}, point{0.0, 6.0}}
    fmt.Printf(""%s and\n%s\n"", t1, t2)
    overlapping := triTri2D(t1, t2, 0.0, false, true)
    fmt.Println(iff(overlapping, ""overlap"", ""do not overlap""))
 
    // Need to allow reversed for this pair to avoid panic.
    t1 = &triangle{point{0.0, 0.0}, point{0.0, 5.0}, point{5.0, 0.0}}
    t2 = t1
    fmt.Printf(""\n%s and\n%s\n"", t1, t2)
    overlapping = triTri2D(t1, t2, 0.0, true, true)
    fmt.Println(iff(overlapping, ""overlap (reversed)"", ""do not overlap""))
 
    t1 = &triangle{point{0.0, 0.0}, point{5.0, 0.0}, point{0.0, 5.0}}
    t2 = &triangle{point{-10.0, 0.0}, point{-5.0, 0.0}, point{-1.0, 6.0}}
    fmt.Printf(""\n%s and\n%s\n"", t1, t2)
    overlapping = triTri2D(t1, t2, 0.0, false, true)
    fmt.Println(iff(overlapping, ""overlap"", ""do not overlap""))
 
    t1.p3 = point{2.5, 5.0}
    t2 = &triangle{point{0.0, 4.0}, point{2.5, -1.0}, point{5.0, 4.0}}
    fmt.Printf(""\n%s and\n%s\n"", t1, t2)
    overlapping = triTri2D(t1, t2, 0.0, false, true)
    fmt.Println(iff(overlapping, ""overlap"", ""do not overlap""))
 
    t1 = &triangle{point{0.0, 0.0}, point{1.0, 1.0}, point{0.0, 2.0}}
    t2 = &triangle{point{2.0, 1.0}, point{3.0, 0.0}, point{3.0, 2.0}}
    fmt.Printf(""\n%s and\n%s\n"", t1, t2)
    overlapping = triTri2D(t1, t2, 0.0, false, true)
    fmt.Println(iff(overlapping, ""overlap"", ""do not overlap""))
 
    t2 = &triangle{point{2.0, 1.0}, point{3.0, -2.0}, point{3.0, 4.0}}
    fmt.Printf(""\n%s and\n%s\n"", t1, t2)
    overlapping = triTri2D(t1, t2, 0.0, false, true)
    fmt.Println(iff(overlapping, ""overlap"", ""do not overlap""))
 
    t1 = &triangle{point{0.0, 0.0}, point{1.0, 0.0}, point{0.0, 1.0}}
    t2 = &triangle{point{1.0, 0.0}, point{2.0, 0.0}, point{1.0, 1.1}}
    fmt.Printf(""\n%s and\n%s\n"", t1, t2)
    println(""which have only a single corner in contact, if boundary points collide"")
    overlapping = triTri2D(t1, t2, 0.0, false, true)
    fmt.Println(iff(overlapping, ""overlap"", ""do not overlap""))
 
    fmt.Printf(""\n%s and\n%s\n"", t1, t2)
    fmt.Println(""which have only a single corner in contact, if boundary points do not collide"")
    overlapping = triTri2D(t1, t2, 0.0, false, false)
    fmt.Println(iff(overlapping, ""overlap"", ""do not overlap""))
}",4959,148
62234,http://rosettacode.org/wiki/Determine_if_a_string_has_all_the_same_characters,Determine if a string has all the same characters,"Task

Given a character string   (which may be empty, or have a length of zero characters):

   create a function/procedure/routine to:
   determine if all the characters in the string are the same
   indicate if or which character is different from the previous character
   display each string and its length   (as the strings are being examined)
   a zero─length (empty) string shall be considered as all the same character(s)
   process the strings from left─to─right
   if       all the same character,   display a message saying such
   if not all the same character,   then:
   display a message saying such
   display what character is different
   only the 1st different character need be displayed
   display where the different character is in the string
   the above messages can be part of a single message
   display the hexadecimal value of the different character


Use (at least) these seven test values   (strings):

   a string of length   0   (an empty string)
   a string of length   3   which contains three blanks
   a string of length   1   which contains:   2
   a string of length   3   which contains:   333
   a string of length   3   which contains:   .55
   a string of length   6   which contains:   tttTTT
   a string of length   9   with a blank in the middle:   4444   444k


Show all output here on this page.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import ""fmt""
 
func analyze(s string) {
    chars := []rune(s)
    le := len(chars)
    fmt.Printf(""Analyzing %q which has a length of %d:\n"", s, le)
    if le > 1 {
        for i := 1; i < le; i++ {
            if chars[i] != chars[i-1] {
                fmt.Println(""  Not all characters in the string are the same."")
                fmt.Printf(""  %q (%#[1]x) is different at position %d.\n\n"", chars[i], i+1)
                return
            }
        }
    }
    fmt.Println(""  All characters in the string are the same.\n"")
}
 
func main() {
    strings := []string{
        """",
        ""   "",
        ""2"",
        ""333"",
        "".55"",
        ""tttTTT"",
        ""4444 444k"",
        ""pépé"",
        ""🐶🐶🐺🐶"",
        ""🎄🎄🎄🎄"",
    }
    for _, s := range strings {
        analyze(s)
    }
}",810,37
62253,http://rosettacode.org/wiki/Determinant_and_permanent,Determinant and permanent,"For a given matrix, return the determinant and the permanent of the matrix.

The determinant is given by

 



det
(
A
)
=

∑

σ


sgn
⁡
(
σ
)

∏

i
=
1


n



M

i
,

σ

i






{\displaystyle \det(A)=\sum _{\sigma }\operatorname {sgn}(\sigma )\prod _{i=1}^{n}M_{i,\sigma _{i}}}


while the permanent is given by

 



perm
⁡
(
A
)
=

∑

σ



∏

i
=
1


n



M

i
,

σ

i






{\displaystyle \operatorname {perm} (A)=\sum _{\sigma }\prod _{i=1}^{n}M_{i,\sigma _{i}}}


In both cases the sum is over the permutations 



σ


{\displaystyle \sigma }

 of the permutations of 1, 2, ..., n. (A permutation's sign is 1 if there are an even number of inversions and -1 otherwise; see parity of a permutation.)

More efficient algorithms for the determinant are known: LU decomposition, see for example wp:LU decomposition#Computing the determinant. Efficient methods for calculating the permanent are not known.



Related task

 Permutations by swapping

",#Go,Go,"package main
 
import (
    ""fmt""
    ""permute""
)
 
func determinant(m [][]float64) (d float64) {
    p := make([]int, len(m))
    for i := range p {
        p[i] = i
    }
    it := permute.Iter(p)
    for s := it(); s != 0; s = it() {
        pr := 1.
        for i, σ := range p {
            pr *= m[i][σ]
        }
        d += float64(s) * pr
    }
    return
}
 
func permanent(m [][]float64) (d float64) {
    p := make([]int, len(m))
    for i := range p {
        p[i] = i
    }
    it := permute.Iter(p)
    for s := it(); s != 0; s = it() {
        pr := 1.
        for i, σ := range p {
            pr *= m[i][σ]
        }
        d += pr
    }
    return
}
 
var m2 = [][]float64{
    {1, 2},
    {3, 4}}
 
var m3 = [][]float64{
    {2, 9, 4},
    {7, 5, 3},
    {6, 1, 8}}
 
func main() {
    fmt.Println(determinant(m2), permanent(m2))
    fmt.Println(determinant(m3), permanent(m3))
}",901,52
62370,http://rosettacode.org/wiki/Determine_if_a_string_has_all_unique_characters,Determine if a string has all unique characters,"Task

Given a character string   (which may be empty, or have a length of zero characters):

   create a function/procedure/routine to:
   determine if all the characters in the string are unique
   indicate if or which character is duplicated and where
   display each string and its length   (as the strings are being examined)
   a zero─length (empty) string shall be considered as unique
   process the strings from left─to─right
   if       unique,   display a message saying such
   if not unique,   then:
   display a message saying such
   display what character is duplicated
   only the 1st non─unique character need be displayed
   display where ""both"" duplicated characters are in the string
   the above messages can be part of a single message
   display the hexadecimal value of the duplicated character


Use (at least) these five test values   (strings):

   a string of length     0   (an empty string)
   a string of length     1   which is a single period   (.)
   a string of length     6   which contains:   abcABC
   a string of length     7   which contains a blank in the middle:   XYZ  ZYX
   a string of length   36   which   doesn't   contain the letter ""oh"":
 1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ


Show all output here on this page.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import ""fmt""
 
func analyze(s string) {
    chars := []rune(s)
    le := len(chars)
    fmt.Printf(""Analyzing %q which has a length of %d:\n"", s, le)
    if le > 1 {
        for i := 0; i < le-1; i++ {
            for j := i + 1; j < le; j++ {
                if chars[j] == chars[i] {
                    fmt.Println(""  Not all characters in the string are unique."")
                    fmt.Printf(""  %q (%#[1]x) is duplicated at positions %d and %d.\n\n"", chars[i], i+1, j+1)
                    return
                }
            }
        }
    }
    fmt.Println(""  All characters in the string are unique.\n"")
}
 
func main() {
    strings := []string{
        """",
        ""."",
        ""abcABC"",
        ""XYZ ZYX"",
        ""1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ"",
        ""01234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ0X"",
        ""hétérogénéité"",
        ""🎆🎃🎇🎈"",
        ""😍😀🙌💃😍🙌"",
        ""🐠🐟🐡🦈🐬🐳🐋🐡"",
    }
    for _, s := range strings {
        analyze(s)
    }
}",979,39
62385,http://rosettacode.org/wiki/Delegates,Delegates,"A delegate is a helper object used by another object. The delegator may send the delegate certain messages, and provide a default implementation when there is no delegate or the delegate does not respond to a message. This pattern is heavily used in Cocoa framework on Mac OS X. See also wp:Delegation pattern.

Objects responsibilities:

Delegator:

 Keep an optional delegate instance.
 Implement ""operation"" method, returning the delegate ""thing"" if the delegate respond to ""thing"", or the string ""default implementation"".
Delegate:

 Implement ""thing"" and return the string ""delegate implementation""
Show how objects are created and used. First, without a delegate, then with a delegate that does not implement ""thing"", and last with a delegate that implements ""thing"".
",#Go,Go,"package main
import ""fmt""
 
type Delegator struct {
    delegate interface{} // the delegate may be any type
}
 
// interface that represents anything that supports thing()
type Thingable interface {
    thing() string
}
 
func (self Delegator) operation() string {
    if v, ok := self.delegate.(Thingable); ok {
        return v.thing()
    }
    return ""default implementation""
}
 
type Delegate int // any dummy type
 
func (Delegate) thing() string {
    return ""delegate implementation""
}
 
func main() {
    // Without a delegate:
    a := Delegator{}
    fmt.Println(a.operation()) // prints ""default implementation""
 
    // With a delegate that does not implement ""thing""
    a.delegate = ""A delegate may be any object""
    fmt.Println(a.operation()) // prints ""default implementation""
 
    // With a delegate:
    var d Delegate
    a.delegate = d
    fmt.Println(a.operation()) // prints ""delegate implementation""
}",928,39
62474,http://rosettacode.org/wiki/Detect_division_by_zero,Detect division by zero,"Task

Write a function to detect a   divide by zero error   without checking if the denominator is zero.



",#Go,Go,"package main
 
import ""fmt""
 
func divCheck(x, y int) (q int, ok bool) {
    defer func() {
        recover()
    }()
    q = x / y
    return q, true
}
 
func main() {
    fmt.Println(divCheck(3, 2))
    fmt.Println(divCheck(3, 0))
}",234,16
62583,http://rosettacode.org/wiki/Delete_a_file,Delete a file,"Task

Delete a file called ""input.txt"" and delete a directory called ""docs"".

This should be done twice: once ""here"", i.e. in the current working directory and once in the filesystem root.



",#Go,Go,"package main
import ""os""
 
func main() {
  os.Remove(""input.txt"")
  os.Remove(""/input.txt"")
  os.Remove(""docs"")
  os.Remove(""/docs"")
  // recursively removes contents:
  os.RemoveAll(""docs"")
  os.RemoveAll(""/docs"")
}",216,12
62659,http://rosettacode.org/wiki/Determine_if_a_string_is_numeric,Determine if a string is numeric,"Task

Create a boolean function which takes in a string and tells whether it is a numeric string (floating point and negative numbers included) in the syntax the language uses for numeric literals or numbers converted from strings.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
func isNumeric(s string) bool {
    _, err := strconv.ParseFloat(s, 64)
    return err == nil
}
 
func main() {
    fmt.Println(""Are these strings numeric?"")
    strings := []string{""1"", ""3.14"", ""-100"", ""1e2"", ""NaN"", ""rose""}
    for _, s := range strings {
        fmt.Printf(""  %4s -> %t\n"", s, isNumeric(s))
    }
}",369,19
62815,http://rosettacode.org/wiki/Department_numbers,Department numbers,"There is a highly organized city that has decided to assign a number to each of their departments:

   police department
   sanitation department
   fire department 


Each department can have a number between   1   and   7   (inclusive).

The three department numbers are to be unique (different from each other) and must add up to   12.

The Chief of the Police doesn't like odd numbers and wants to have an even number for his department.



Task

Write a computer program which outputs all valid combinations.



Possible output   (for the 1st and 14th solutions):

 --police--  --sanitation--  --fire-- 
     2             3            7 
     6             5            1


",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    fmt.Println(""Police  Sanitation  Fire"")
    fmt.Println(""------  ----------  ----"")
    count := 0
    for i := 2; i < 7; i += 2 {
        for j := 1; j < 8; j++ {
            if j == i { continue }
            for k := 1; k < 8; k++ {
                if k == i || k == j { continue }
                if i + j + k != 12 { continue }
                fmt.Printf(""  %d         %d         %d\n"", i, j, k)
                count++
            }
        }
    }
    fmt.Printf(""\n%d valid combinations\n"", count)
}",555,21
63195,http://rosettacode.org/wiki/Deceptive_numbers,Deceptive numbers,"Repunits are numbers that consist entirely of repetitions of the digit one (unity). The notation Rn symbolizes the repunit made up of n ones.

Every prime p larger than 5, evenly divides the repunit Rp-1.



E.G.
The repunit R6 is evenly divisible by 7.

111111 / 7 = 15873

The repunit R42 is evenly divisible by 43.

111111111111111111111111111111111111111111 / 43 = 2583979328165374677002583979328165374677

And so on.



There are composite numbers that also have this same property. They are often referred to as deceptive non-primes or deceptive numbers.



The repunit R90 is evenly divisible by the composite number 91 (=7*13).

111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 / 91 = 1221001221001221001221001221001221001221001221001221001221001221001221001221001221001221


Task 
 Find and show at least the first 10 deceptive numbers; composite numbers n that evenly divide the repunit Rn-1


See also
 Numbers Aplenty - Deceptive numbers
 OEIS:A000864 - Deceptive nonprimes: composite numbers k that divide the repunit R_{k-1}



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""rcu""
)
 
func main() {
    count := 0
    limit := 25
    n := int64(17)
    repunit := big.NewInt(1111111111111111)
    t := new(big.Int)
    zero := new(big.Int)
    eleven := big.NewInt(11)
    hundred := big.NewInt(100)
    var deceptive []int64
    for count < limit {
        if !rcu.IsPrime(int(n)) && n%3 != 0 && n%5 != 0 {
            bn := big.NewInt(n)
            if t.Rem(repunit, bn).Cmp(zero) == 0 {
                deceptive = append(deceptive, n)
                count++
            }
        }
        n += 2
        repunit.Mul(repunit, hundred)
        repunit.Add(repunit, eleven)
    }
    fmt.Println(""The first"", limit, ""deceptive numbers are:"")
    fmt.Println(deceptive)
}",752,33
63224,http://rosettacode.org/wiki/Deepcopy,Deepcopy,"Task

Demonstrate how to copy data structures containing complex heterogeneous and cyclic semantics.

This is often referred to as deep copying, and is normally required where structures are mutable and to ensure that independent copies can be manipulated without side-effects.

If this facility is not built into the language, it is permissible to use functions from a common library, or a coded procedure.



The task should show:

 Relevant semantics of structures, such as their homogeneous or heterogeneous properties, or containment of (self- or mutual-reference) cycles.
 Any limitations of the method.
 That the structure and its copy are different.
 Suitable links to external documentation for common libraries.

",#Go,Go,"package main
 
import ""fmt""
 
// a complex data structure
type cds struct {
    i int            // no special handling needed for deep copy
    s string         // no special handling
    b []byte         // copied easily with append function
    m map[int]bool   // deep copy requires looping
}
 
// a method
func (c cds) deepcopy() *cds {
    // copy what you can in one line
    r := &cds{c.i, c.s, append([]byte{}, c.b...), make(map[int]bool)}
    // populate map with a loop
    for k, v := range c.m {
        r.m[k] = v
    }
    return r
}
 
// demo
func main() {
    // create and populate a structure 
    c1 := &cds{1, ""one"", []byte(""unit""), map[int]bool{1: true}}
    fmt.Println(c1)      // show it
    c2 := c1.deepcopy()  // copy it
    fmt.Println(c2)      // show copy
    c1.i = 0             // change original
    c1.s = ""nil""
    copy(c1.b, ""zero"")
    c1.m[1] = false
    fmt.Println(c1)      // show changes
    fmt.Println(c2)      // show copy unaffected
}",982,37
63249,http://rosettacode.org/wiki/Deconvolution/1D,Deconvolution/1D,"The convolution of two functions 





F




{\displaystyle {\mathit {F}}}

 and 





H




{\displaystyle {\mathit {H}}}

 of
an integer variable is defined as the function 





G




{\displaystyle {\mathit {G}}}


satisfying





G
(
n
)
=

∑

m
=
−
∞


∞


F
(
m
)
H
(
n
−
m
)


{\displaystyle G(n)=\sum _{m=-\infty }^{\infty }F(m)H(n-m)}


for all integers 





n




{\displaystyle {\mathit {n}}}

. Assume 



F
(
n
)


{\displaystyle F(n)}

 can be non-zero only for 



0


{\displaystyle 0}

 ≤ 





n




{\displaystyle {\mathit {n}}}

 ≤ 




|



F



|



{\displaystyle |{\mathit {F}}|}

, where 




|



F



|



{\displaystyle |{\mathit {F}}|}

 is the ""length"" of 





F




{\displaystyle {\mathit {F}}}

, and similarly for 





G




{\displaystyle {\mathit {G}}}

 and 





H




{\displaystyle {\mathit {H}}}

, so that the functions can be modeled as finite sequences by identifying 




f

0


,

f

1


,

f

2


,
…


{\displaystyle f_{0},f_{1},f_{2},\dots }

 with 



F
(
0
)
,
F
(
1
)
,
F
(
2
)
,
…


{\displaystyle F(0),F(1),F(2),\dots }

, etc.
Then for example, values of 




|



F



|

=
6


{\displaystyle |{\mathit {F}}|=6}

 and 




|



H



|

=
5


{\displaystyle |{\mathit {H}}|=5}

 would determine the following value of 





g




{\displaystyle {\mathit {g}}}

 by definition.










g

0




=



f

0



h

0







g

1




=



f

1



h

0




+



f

0



h

1







g

2




=



f

2



h

0




+



f

1



h

1




+



f

0



h

2







g

3




=



f

3



h

0




+



f

2



h

1




+



f

1



h

2




+



f

0



h

3







g

4




=



f

4



h

0




+



f

3



h

1




+



f

2



h

2




+



f

1



h

3




+



f

0



h

4







g

5




=



f

5



h

0




+



f

4



h

1




+



f

3



h

2




+



f

2



h

3




+



f

1



h

4







g

6




=





f

5



h

1




+



f

4



h

2




+



f

3



h

3




+



f

2



h

4







g

7




=







f

5



h

2




+



f

4



h

3




+



f

3



h

4







g

8




=









f

5



h

3




+



f

4



h

4







g

9




=











f

5



h

4








{\displaystyle {\begin{array}{lllllllllll}g_{0}&=&f_{0}h_{0}\\g_{1}&=&f_{1}h_{0}&+&f_{0}h_{1}\\g_{2}&=&f_{2}h_{0}&+&f_{1}h_{1}&+&f_{0}h_{2}\\g_{3}&=&f_{3}h_{0}&+&f_{2}h_{1}&+&f_{1}h_{2}&+&f_{0}h_{3}\\g_{4}&=&f_{4}h_{0}&+&f_{3}h_{1}&+&f_{2}h_{2}&+&f_{1}h_{3}&+&f_{0}h_{4}\\g_{5}&=&f_{5}h_{0}&+&f_{4}h_{1}&+&f_{3}h_{2}&+&f_{2}h_{3}&+&f_{1}h_{4}\\g_{6}&=&&&f_{5}h_{1}&+&f_{4}h_{2}&+&f_{3}h_{3}&+&f_{2}h_{4}\\g_{7}&=&&&&&f_{5}h_{2}&+&f_{4}h_{3}&+&f_{3}h_{4}\\g_{8}&=&&&&&&&f_{5}h_{3}&+&f_{4}h_{4}\\g_{9}&=&&&&&&&&&f_{5}h_{4}\end{array}}}


We can write this in matrix form as:






(





g

0







g

1







g

2







g

3







g

4







g

5







g

6







g

7







g

8







g

9






)

=

(





f

0







f

1





f

0







f

2





f

1





f

0







f

3





f

2





f

1





f

0







f

4





f

3





f

2





f

1





f

0







f

5





f

4





f

3





f

2





f

1








f

5





f

4





f

3





f

2









f

5





f

4





f

3










f

5





f

4











f

5






)



(





h

0







h

1







h

2







h

3







h

4






)



{\displaystyle \left({\begin{array}{l}g_{0}\\g_{1}\\g_{2}\\g_{3}\\g_{4}\\g_{5}\\g_{6}\\g_{7}\\g_{8}\\g_{9}\\\end{array}}\right)=\left({\begin{array}{lllll}f_{0}\\f_{1}&f_{0}\\f_{2}&f_{1}&f_{0}\\f_{3}&f_{2}&f_{1}&f_{0}\\f_{4}&f_{3}&f_{2}&f_{1}&f_{0}\\f_{5}&f_{4}&f_{3}&f_{2}&f_{1}\\&f_{5}&f_{4}&f_{3}&f_{2}\\&&f_{5}&f_{4}&f_{3}\\&&&f_{5}&f_{4}\\&&&&f_{5}\end{array}}\right)\;\left({\begin{array}{l}h_{0}\\h_{1}\\h_{2}\\h_{3}\\h_{4}\\\end{array}}\right)}


or





g
=
A

h


{\displaystyle g=A\;h}


For this task, implement a function (or method, procedure, subroutine, etc.) deconv to perform deconvolution (i.e., the inverse of convolution) by constructing and solving such a system of equations represented by the above matrix 



A


{\displaystyle A}

 for 





h




{\displaystyle {\mathit {h}}}

 given 





f




{\displaystyle {\mathit {f}}}

 and 





g




{\displaystyle {\mathit {g}}}

.

 The function should work for 





G




{\displaystyle {\mathit {G}}}

 of arbitrary length (i.e., not hard coded or constant) and 





F




{\displaystyle {\mathit {F}}}

 of any length up to that of 





G




{\displaystyle {\mathit {G}}}

. Note that 




|



H



|



{\displaystyle |{\mathit {H}}|}

 will be given by 




|



G



|

−

|



F



|

+
1


{\displaystyle |{\mathit {G}}|-|{\mathit {F}}|+1}

.
 There may be more equations than unknowns. If convenient, use a function from a library that finds the best fitting solution to an overdetermined system of linear equations (as in the Multiple regression task). Otherwise, prune the set of equations as needed and solve as in the Reduced row echelon form task.
 Test your solution on the following data. Be sure to verify both that deconv



(
g
,
f
)
=
h


{\displaystyle (g,f)=h}

 and deconv



(
g
,
h
)
=
f


{\displaystyle (g,h)=f}

 and display the results in a human readable form.

h = [-8,-9,-3,-1,-6,7]

f = [-3,-6,-1,8,-6,3,-1,-9,-9,3,-2,5,2,-2,-7,-1]

g = [24,75,71,-34,3,22,-45,23,245,25,52,25,-67,-96,96,31,55,36,29,-43,-7]

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    h := []float64{-8, -9, -3, -1, -6, 7}
    f := []float64{-3, -6, -1, 8, -6, 3, -1, -9, -9, 3, -2, 5, 2, -2, -7, -1}
    g := []float64{24, 75, 71, -34, 3, 22, -45, 23, 245, 25, 52, 25, -67, -96,
        96, 31, 55, 36, 29, -43, -7}
    fmt.Println(h)
    fmt.Println(deconv(g, f))
    fmt.Println(f)
    fmt.Println(deconv(g, h))
}
 
func deconv(g, f []float64) []float64 {
    h := make([]float64, len(g)-len(f)+1)
    for n := range h {
        h[n] = g[n]
        var lower int
        if n >= len(f) {
            lower = n - len(f) + 1
        }
        for i := lower; i < n; i++ {
            h[n] -= h[i] * f[n-i]
        }
        h[n] /= f[0]
    }
    return h
}",721,30
63323,http://rosettacode.org/wiki/Death_Star,Death Star," 
Task

Display a region that consists of a large sphere with part of a smaller sphere removed from it as a result of geometric subtraction.

(This will basically produce a shape like a ""death star"".)



Related tasks

 draw a sphere
 draw a cuboid
 draw a rotating cube
 write language name in 3D ASCII

",#Go,Go,"package main
 
import (
    ""fmt""
    ""image""
    ""image/color""
    ""image/png""
    ""math""
    ""os""
)
 
type vector [3]float64
 
func (v *vector) normalize() {
    invLen := 1 / math.Sqrt(dot(v, v))
    v[0] *= invLen
    v[1] *= invLen
    v[2] *= invLen
}
 
func dot(x, y *vector) float64 {
    return x[0]*y[0] + x[1]*y[1] + x[2]*y[2]
}
 
type sphere struct {
    cx, cy, cz int
    r          int
}
 
func (s *sphere) hit(x, y int) (z1, z2 float64, hit bool) {
    x -= s.cx
    y -= s.cy
    if zsq := s.r*s.r - (x*x + y*y); zsq >= 0 {
        zsqrt := math.Sqrt(float64(zsq))
        return float64(s.cz) - zsqrt, float64(s.cz) + zsqrt, true
    }
    return 0, 0, false
}
 
func deathStar(pos, neg *sphere, k, amb float64, dir *vector) *image.Gray {
    w, h := pos.r*4, pos.r*3
    bounds := image.Rect(pos.cx-w/2, pos.cy-h/2, pos.cx+w/2, pos.cy+h/2)
    img := image.NewGray(bounds)
    vec := new(vector)
    for y, yMax := pos.cy-pos.r, pos.cy+pos.r; y <= yMax; y++ {
        for x, xMax := pos.cx-pos.r, pos.cx+pos.r; x <= xMax; x++ {
            zb1, zb2, hit := pos.hit(x, y)
            if !hit {
                continue
            }
            zs1, zs2, hit := neg.hit(x, y)
            if hit {
                if zs1 > zb1 {
                    hit = false
                } else if zs2 > zb2 {
                    continue
                }
            }
            if hit {
                vec[0] = float64(neg.cx - x)
                vec[1] = float64(neg.cy - y)
                vec[2] = float64(neg.cz) - zs2
            } else {
                vec[0] = float64(x - pos.cx)
                vec[1] = float64(y - pos.cy)
                vec[2] = zb1 - float64(pos.cz)
            }
            vec.normalize()
            s := dot(dir, vec)
            if s < 0 {
                s = 0
            }
            lum := 255 * (math.Pow(s, k) + amb) / (1 + amb)
            if lum < 0 {
                lum = 0
            } else if lum > 255 {
                lum = 255
            }
            img.SetGray(x, y, color.Gray{uint8(lum)})
        }
    }
    return img
}
 
func main() {
    dir := &vector{20, -40, -10}
    dir.normalize()
    pos := &sphere{0, 0, 0, 120}
    neg := &sphere{-90, -90, -30, 100}
 
    img := deathStar(pos, neg, 1.5, .2, dir)
    f, err := os.Create(""dstar.png"")
    if err != nil {
        fmt.Println(err)
        return
    }
    if err = png.Encode(f, img); err != nil {
        fmt.Println(err)
    }
    if err = f.Close(); err != nil {
        fmt.Println(err)
    }
}",2532,103
63327,http://rosettacode.org/wiki/De_Bruijn_sequences,de Bruijn sequences,"The sequences are named after the Dutch mathematician   Nicolaas Govert de Bruijn.



A note on Dutch capitalization:   Nicolaas' last name is   de Bruijn,   the   de   isn't normally capitalized
unless it's the first word in a sentence.   Rosetta Code (more or less by default or by fiat) requires the first word in the task name to be
capitalized.



In combinatorial mathematics,   a   de Bruijn sequence   of order    n    on
a    size-k    alphabet (computer science)    A    is a cyclic sequence in which every
possible    length-n    string (computer science, formal theory)   on    A    occurs
exactly once as a contiguous substring.

Such a sequence is denoted by    B(k, n)    and has
length   kn,   which is also the number of distinct substrings of
length   n   on   A;    

de Bruijn sequences are therefore optimally short.

There are:

                         (k!)k(n-1)   ÷   kn

distinct de Bruijn sequences    B(k, n). 



Task

For this Rosetta Code task,   a   de Bruijn   sequence is to be generated that can be used to shorten a brute-force attack on
a   PIN-like   code lock that does not have an ""enter""
key and accepts the last    n    digits entered.



Note:   automated teller machines (ATMs)   used to work like
this,   but their software has been updated to not allow a brute-force attack.



Example

A   digital door lock   with a 4-digit code would
have B (10, 4) solutions,   with a length of   10,000   (digits).

Therefore, only at most     10,000 + 3     (as the solutions are cyclic or wrap-around)   presses are needed to
open the lock.

Trying all 4-digit codes separately would require   4 × 10,000   or   40,000   presses.



Task requirements

   Generate a de Bruijn sequence for a 4-digit (decimal) PIN code.
   Show the length of the generated de Bruijn sequence.
   (There are many possible de Bruijn sequences that solve this task,   one solution is shown on the discussion page).
   Show the first and last   130   digits of the de Bruijn sequence.
   Verify that all four-digit (decimal)   1,000   PIN codes are contained within the de Bruijn sequence.
   0000, 0001, 0002, 0003,   ...   9996, 9997, 9998, 9999   (note the leading zeros).
   Reverse the de Bruijn sequence.
   Again, perform the (above) verification test.
   Replace the 4,444th digit with a period (.) in the original de Bruijn sequence.
   Perform the verification test (again).   There should be four PIN codes missing.


(The last requirement is to ensure that the verification tests performs correctly.   The verification processes should list
any and all missing PIN codes.)

Show all output here, on this page.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




References

   Wikipedia entry:   de Bruijn sequence.
   MathWorld entry:   de Bruijn sequence.
   An  OEIS  entry:   A166315 lexicographically earliest binary de Bruijn sequences, B(2,n)     --- Not B(10,4),   but possibly relevant.

",#Go,Go,"package main
 
import (
    ""bytes""
    ""fmt""
    ""strconv""
    ""strings""
)
 
const digits = ""0123456789""
 
func deBruijn(k, n int) string {
    alphabet := digits[0:k]
    a := make([]byte, k*n)
    var seq []byte
    var db func(int, int) // recursive closure
    db = func(t, p int) {
        if t > n {
            if n%p == 0 {
                seq = append(seq, a[1:p+1]...)
            }
        } else {
            a[t] = a[t-p]
            db(t+1, p)
            for j := int(a[t-p] + 1); j < k; j++ {
                a[t] = byte(j)
                db(t+1, t)
            }
        }
    }
    db(1, 1)
    var buf bytes.Buffer
    for _, i := range seq {
        buf.WriteByte(alphabet[i])
    }
    b := buf.String()
    return b + b[0:n-1] // as cyclic append first (n-1) digits
}
 
func allDigits(s string) bool {
    for _, b := range s {
        if b < '0' || b > '9' {
            return false
        }
    }
    return true
}
 
func validate(db string) {
    le := len(db)
    found := make([]int, 10000)
    var errs []string
    // Check all strings of 4 consecutive digits within 'db'
    // to see if all 10,000 combinations occur without duplication.
    for i := 0; i < le-3; i++ {
        s := db[i : i+4]
        if allDigits(s) {
            n, _ := strconv.Atoi(s)
            found[n]++
        }
    }
    for i := 0; i < 10000; i++ {
        if found[i] == 0 {
            errs = append(errs, fmt.Sprintf(""    PIN number %04d missing"", i))
        } else if found[i] > 1 {
            errs = append(errs, fmt.Sprintf(""    PIN number %04d occurs %d times"", i, found[i]))
        }
    }
    lerr := len(errs)
    if lerr == 0 {
        fmt.Println(""  No errors found"")
    } else {
        pl := ""s""
        if lerr == 1 {
            pl = """"
        }
        fmt.Printf(""  %d error%s found:\n"", lerr, pl)
        fmt.Println(strings.Join(errs, ""\n""))
    }
}
 
func reverse(s string) string {
    bytes := []byte(s)
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        bytes[i], bytes[j] = bytes[j], bytes[i]
    }
    return string(bytes)
}
 
func main() {
    db := deBruijn(10, 4)
    le := len(db)
    fmt.Println(""The length of the de Bruijn sequence is"", le)
    fmt.Println(""\nThe first 130 digits of the de Bruijn sequence are:"")
    fmt.Println(db[0:130])
    fmt.Println(""\nThe last 130 digits of the de Bruijn sequence are:"")
    fmt.Println(db[le-130:])
    fmt.Println(""\nValidating the de Bruijn sequence:"")
    validate(db)
 
    fmt.Println(""\nValidating the reversed de Bruijn sequence:"")
    dbr := reverse(db)
    validate(dbr)
 
    bytes := []byte(db)
    bytes[4443] = '.'
    db = string(bytes)
    fmt.Println(""\nValidating the overlaid de Bruijn sequence:"")
    validate(db)
}",2742,110
63331,http://rosettacode.org/wiki/Deconvolution/2D%2B,Deconvolution/2D+,"This task is a straightforward generalization of Deconvolution/1D to higher dimensions. For example, the one dimensional case would be applicable to audio signals, whereas two dimensions would pertain to images. Define the discrete convolution in 





d




{\displaystyle {\mathit {d}}}

 dimensions of two functions





H
,
F
:


Z


d


→

R



{\displaystyle H,F:\mathbb {Z} ^{d}\rightarrow \mathbb {R} }

 
taking 





d




{\displaystyle {\mathit {d}}}

-tuples of integers to real numbers as the function





G
:


Z


d


→

R



{\displaystyle G:\mathbb {Z} ^{d}\rightarrow \mathbb {R} }


also taking 





d




{\displaystyle {\mathit {d}}}

-tuples of integers to reals and satisfying





G
(

n

0


,
…
,

n

d
−
1


)
=

∑


m

0


=
−
∞


∞


…

∑


m

d
−
1


=
−
∞


∞


F
(

m

0


,
…
,

m

d
−
1


)
H
(

n

0


−

m

0


,
…
,

n

d
−
1


−

m

d
−
1


)


{\displaystyle G(n_{0},\dots ,n_{d-1})=\sum _{m_{0}=-\infty }^{\infty }\dots \sum _{m_{d-1}=-\infty }^{\infty }F(m_{0},\dots ,m_{d-1})H(n_{0}-m_{0},\dots ,n_{d-1}-m_{d-1})}


for all 





d




{\displaystyle {\mathit {d}}}

-tuples of integers 



(

n

0


,
…
,

n

d
−
1


)
∈


Z


d




{\displaystyle (n_{0},\dots ,n_{d-1})\in \mathbb {Z} ^{d}}

. Assume






F




{\displaystyle {\mathit {F}}}

 and 





H




{\displaystyle {\mathit {H}}}

 (and therefore 





G




{\displaystyle {\mathit {G}}}

) are non-zero over only a finite domain bounded by the origin, hence possible to represent as finite multi-dimensional arrays or nested lists 





f




{\displaystyle {\mathit {f}}}

, 





h




{\displaystyle {\mathit {h}}}

, and 





g




{\displaystyle {\mathit {g}}}

.

For this task, implement a function (or method, procedure, subroutine, etc.) deconv to perform deconvolution (i.e., the inverse of convolution) by solving for 





h




{\displaystyle {\mathit {h}}}

 given 





f




{\displaystyle {\mathit {f}}}

 and 





g




{\displaystyle {\mathit {g}}}

. (See Deconvolution/1D for details.)

 The function should work for 





g




{\displaystyle {\mathit {g}}}

 of arbitrary length in each dimension (i.e., not hard coded or constant) and 





f




{\displaystyle {\mathit {f}}}

 of any length up to that of 





g




{\displaystyle {\mathit {g}}}

 in the corresponding dimension.
 The deconv function will need to be parameterized by the dimension 





d




{\displaystyle {\mathit {d}}}

 unless the dimension can be inferred from the data structures representing 





g




{\displaystyle {\mathit {g}}}

 and 





f




{\displaystyle {\mathit {f}}}

.
 There may be more equations than unknowns. If convenient, use a function from a library that finds the best fitting solution to an overdetermined system of linear equations (as in the Multiple regression task). Otherwise, prune the set of equations as needed and solve as in the Reduced row echelon form task.
 Debug your solution using this test data, of which a portion is shown below. Be sure to verify both that the deconvolution of 





g




{\displaystyle {\mathit {g}}}

 with 





f




{\displaystyle {\mathit {f}}}

 is 





h




{\displaystyle {\mathit {h}}}

 and that the deconvolution of 





g




{\displaystyle {\mathit {g}}}

 with 





h




{\displaystyle {\mathit {h}}}

 is 





f




{\displaystyle {\mathit {f}}}

. Display the results in a human readable form for the three dimensional case only.
dimension 1:

h: [-8, 2, -9, -2, 9, -8, -2]
f: [ 6, -9, -7, -5]
g: [-48, 84, -16, 95, 125, -70, 7, 29, 54, 10]

dimension 2:

h: [
      [-8, 1, -7, -2, -9, 4], 
      [4, 5, -5, 2, 7, -1], 
      [-6, -3, -3, -6, 9, 5]]
f: [
      [-5, 2, -2, -6, -7], 
      [9, 7, -6, 5, -7], 
      [1, -1, 9, 2, -7], 
      [5, 9, -9, 2, -5], 
      [-8, 5, -2, 8, 5]]
g: [
      [40, -21, 53, 42, 105, 1, 87, 60, 39, -28], 
      [-92, -64, 19, -167, -71, -47, 128, -109, 40, -21], 
      [58, 85, -93, 37, 101, -14, 5, 37, -76, -56], 
      [-90, -135, 60, -125, 68, 53, 223, 4, -36, -48], 
      [78, 16, 7, -199, 156, -162, 29, 28, -103, -10], 
      [-62, -89, 69, -61, 66, 193, -61, 71, -8, -30], 
      [48, -6, 21, -9, -150, -22, -56, 32, 85, 25]]

dimension 3:

h: [
      [[-6, -8, -5, 9], [-7, 9, -6, -8], [2, -7, 9, 8]], 
      [[7, 4, 4, -6], [9, 9, 4, -4], [-3, 7, -2, -3]]]
f: [
      [[-9, 5, -8], [3, 5, 1]], 
      [[-1, -7, 2], [-5, -6, 6]], 
      [[8, 5, 8],[-2, -6, -4]]]
g: [
      [
         [54, 42, 53, -42, 85, -72], 
         [45, -170, 94, -36, 48, 73], 
         [-39, 65, -112, -16, -78, -72], 
         [6, -11, -6, 62, 49, 8]], 
      [
         [-57, 49, -23, 52, -135, 66], 
         [-23, 127, -58, -5, -118, 64], 
         [87, -16, 121, 23, -41, -12], 
         [-19, 29, 35, -148, -11, 45]], 
      [
         [-55, -147, -146, -31, 55, 60], 
         [-88, -45, -28, 46, -26, -144], 
         [-12, -107, -34, 150, 249, 66], 
         [11, -15, -34, 27, -78, -50]], 
      [
         [56, 67, 108, 4, 2, -48], 
         [58, 67, 89, 32, 32, -8], 
         [-42, -31, -103, -30, -23, -8],
         [6, 4, -26, -10, 26, 12]]]
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/cmplx""
)
 
func fft(buf []complex128, n int) {
    out := make([]complex128, n)
    copy(out, buf)
    fft2(buf, out, n, 1)
}
 
func fft2(buf, out []complex128, n, step int) {
    if step < n {
        fft2(out, buf, n, step*2)
        fft2(out[step:], buf[step:], n, step*2)
        for j := 0; j < n; j += 2 * step {
            fj, fn := float64(j), float64(n)
            t := cmplx.Exp(-1i*complex(math.Pi, 0)*complex(fj, 0)/complex(fn, 0)) * out[j+step]
            buf[j/2] = out[j] + t
            buf[(j+n)/2] = out[j] - t
        }
    }
}
 
/* pad slice length to power of two */
func padTwo(g []float64, le int, ns *int) []complex128 {
    n := 1
    if *ns != 0 {
        n = *ns
    } else {
        for n < le {
            n *= 2
        }
    }
    buf := make([]complex128, n)
    for i := 0; i < le; i++ {
        buf[i] = complex(g[i], 0)
    }
    *ns = n
    return buf
}
 
func deconv(g []float64, lg int, f []float64, lf int, out []float64, rowLe int) {
    ns := 0
    g2 := padTwo(g, lg, &ns)
    f2 := padTwo(f, lf, &ns)
    fft(g2, ns)
    fft(f2, ns)
    h := make([]complex128, ns)
    for i := 0; i < ns; i++ {
        h[i] = g2[i] / f2[i]
    }
    fft(h, ns)
    for i := 0; i < ns; i++ {
        if math.Abs(real(h[i])) < 1e-10 {
            h[i] = 0
        }
    }
    for i := 0; i > lf-lg-rowLe; i-- {
        out[-i] = real(h[(i+ns)%ns] / 32)
    }
}
 
func unpack2(m [][]float64, rows, le, toLe int) []float64 {
    buf := make([]float64, rows*toLe)
    for i := 0; i < rows; i++ {
        for j := 0; j < le; j++ {
            buf[i*toLe+j] = m[i][j]
        }
    }
    return buf
}
 
func pack2(buf []float64, rows, fromLe, toLe int, out [][]float64) {
    for i := 0; i < rows; i++ {
        for j := 0; j < toLe; j++ {
            out[i][j] = buf[i*fromLe+j] / 4
        }
    }
}
 
func deconv2(g [][]float64, rowG, colG int, f [][]float64, rowF, colF int, out [][]float64) {
    g2 := unpack2(g, rowG, colG, colG)
    f2 := unpack2(f, rowF, colF, colG)
    ff := make([]float64, (rowG-rowF+1)*colG)
    deconv(g2, rowG*colG, f2, rowF*colG, ff, colG)
    pack2(ff, rowG-rowF+1, colG, colG-colF+1, out)
}
 
func unpack3(m [][][]float64, x, y, z, toY, toZ int) []float64 {
    buf := make([]float64, x*toY*toZ)
    for i := 0; i < x; i++ {
        for j := 0; j < y; j++ {
            for k := 0; k < z; k++ {
                buf[(i*toY+j)*toZ+k] = m[i][j][k]
            }
        }
    }
    return buf
}
 
func pack3(buf []float64, x, y, z, toY, toZ int, out [][][]float64) {
    for i := 0; i < x; i++ {
        for j := 0; j < toY; j++ {
            for k := 0; k < toZ; k++ {
                out[i][j][k] = buf[(i*y+j)*z+k] / 4
            }
        }
    }
}
 
func deconv3(g [][][]float64, gx, gy, gz int, f [][][]float64, fx, fy, fz int, out [][][]float64) {
    g2 := unpack3(g, gx, gy, gz, gy, gz)
    f2 := unpack3(f, fx, fy, fz, gy, gz)
    ff := make([]float64, (gx-fx+1)*gy*gz)
    deconv(g2, gx*gy*gz, f2, fx*gy*gz, ff, gy*gz)
    pack3(ff, gx-fx+1, gy, gz, gy-fy+1, gz-fz+1, out)
}
 
func main() {
    f := [][][]float64{
        {{-9, 5, -8}, {3, 5, 1}},
        {{-1, -7, 2}, {-5, -6, 6}},
        {{8, 5, 8}, {-2, -6, -4}},
    }
    fx, fy, fz := len(f), len(f[0]), len(f[0][0])
 
    g := [][][]float64{
        {{54, 42, 53, -42, 85, -72}, {45, -170, 94, -36, 48, 73},
            {-39, 65, -112, -16, -78, -72}, {6, -11, -6, 62, 49, 8}},
        {{-57, 49, -23, 52, -135, 66}, {-23, 127, -58, -5, -118, 64},
            {87, -16, 121, 23, -41, -12}, {-19, 29, 35, -148, -11, 45}},
        {{-55, -147, -146, -31, 55, 60}, {-88, -45, -28, 46, -26, -144},
            {-12, -107, -34, 150, 249, 66}, {11, -15, -34, 27, -78, -50}},
        {{56, 67, 108, 4, 2, -48}, {58, 67, 89, 32, 32, -8},
            {-42, -31, -103, -30, -23, -8}, {6, 4, -26, -10, 26, 12},
        },
    }
    gx, gy, gz := len(g), len(g[0]), len(g[0][0])
 
    h := [][][]float64{
        {{-6, -8, -5, 9}, {-7, 9, -6, -8}, {2, -7, 9, 8}},
        {{7, 4, 4, -6}, {9, 9, 4, -4}, {-3, 7, -2, -3}},
    }
    hx, hy, hz := gx-fx+1, gy-fy+1, gz-fz+1
 
    h2 := make([][][]float64, hx)
    for i := 0; i < hx; i++ {
        h2[i] = make([][]float64, hy)
        for j := 0; j < hy; j++ {
            h2[i][j] = make([]float64, hz)
        }
    }
    deconv3(g, gx, gy, gz, f, fx, fy, fz, h2)
    fmt.Println(""deconv3(g, f):\n"")
    for i := 0; i < hx; i++ {
        for j := 0; j < hy; j++ {
            for k := 0; k < hz; k++ {
                fmt.Printf(""% .10g  "", h2[i][j][k])
            }
            fmt.Println()
        }
        if i < hx-1 {
            fmt.Println()
        }
    }
 
    kx, ky, kz := gx-hx+1, gy-hy+1, gz-hz+1
    f2 := make([][][]float64, kx)
    for i := 0; i < kx; i++ {
        f2[i] = make([][]float64, ky)
        for j := 0; j < ky; j++ {
            f2[i][j] = make([]float64, kz)
        }
    }
    deconv3(g, gx, gy, gz, h, hx, hy, hz, f2)
    fmt.Println(""\ndeconv(g, h):\n"")
    for i := 0; i < kx; i++ {
        for j := 0; j < ky; j++ {
            for k := 0; k < kz; k++ {
                fmt.Printf(""% .10g  "", f2[i][j][k])
            }
            fmt.Println()
        }
        if i < kx-1 {
            fmt.Println()
        }
    }
}",5282,192
63336,http://rosettacode.org/wiki/Define_a_primitive_data_type,Define a primitive data type,"Demonstrate how to define a type that behaves like an integer but has a lowest valid value of 1 and a highest valid value of 10. Include all bounds checking you need to write, or explain how the compiler or interpreter creates those bounds checks for you.
",#Go,Go,"package main
 
import ""fmt""
 
type TinyInt int
 
func NewTinyInt(i int) TinyInt {
    if i < 1 {
        i = 1
    } else if i > 10 {
        i = 10
    }
    return TinyInt(i)
}
 
func (t1 TinyInt) Add(t2 TinyInt) TinyInt {
    return NewTinyInt(int(t1) + int(t2))
}
 
func (t1 TinyInt) Sub(t2 TinyInt) TinyInt {
    return NewTinyInt(int(t1) - int(t2))
}
 
func (t1 TinyInt) Mul(t2 TinyInt) TinyInt {
    return NewTinyInt(int(t1) * int(t2))
}
 
func (t1 TinyInt) Div(t2 TinyInt) TinyInt {
    return NewTinyInt(int(t1) / int(t2))
}
 
func (t1 TinyInt) Rem(t2 TinyInt) TinyInt {
    return NewTinyInt(int(t1) % int(t2))
}
 
func (t TinyInt) Inc() TinyInt {
    return t.Add(TinyInt(1))
}
 
func (t TinyInt) Dec() TinyInt {
    return t.Sub(TinyInt(1))
}
 
func main() {
    t1 := NewTinyInt(6)
    t2 := NewTinyInt(3)
    fmt.Println(""t1      ="", t1)
    fmt.Println(""t2      ="", t2)
    fmt.Println(""t1 + t2 ="", t1.Add(t2))
    fmt.Println(""t1 - t2 ="", t1.Sub(t2))
    fmt.Println(""t1 * t2 ="", t1.Mul(t2))
    fmt.Println(""t1 / t2 ="", t1.Div(t2))
    fmt.Println(""t1 % t2 ="", t1.Rem(t2))
    fmt.Println(""t1 + 1  ="", t1.Inc())
    fmt.Println(""t1 - 1  ="", t1.Dec())
}",1170,56
63410,http://rosettacode.org/wiki/Deal_cards_for_FreeCell,Deal cards for FreeCell,"Free Cell is the solitaire card game that Paul Alfille introduced to the PLATO system in 1978. Jim Horne, at Microsoft, changed the name to FreeCell and reimplemented the game for DOS, then Windows. 

This version introduced 32000 numbered deals. (The FreeCell FAQ tells this history.)

As the game became popular, Jim Horne disclosed the algorithm, and other implementations of FreeCell began to reproduce the Microsoft deals. 

These deals are numbered from 1 to 32000.
Newer versions from Microsoft have 1 million deals, numbered from 1 to 1000000; some implementations allow numbers outside that range.

The algorithm uses this linear congruential generator from Microsoft C:

 



s
t
a
t

e

n
+
1


≡
214013
×
s
t
a
t

e

n


+
2531011


(
mod


2

31


)



{\displaystyle state_{n+1}\equiv 214013\times state_{n}+2531011{\pmod {2^{31}}}}


 



r
a
n

d

n


=
s
t
a
t

e

n


÷

2

16




{\displaystyle rand_{n}=state_{n}\div 2^{16}}


 



r
a
n

d

n




{\displaystyle rand_{n}}

 is in range 0 to 32767.
 Rosetta Code has another task, linear congruential generator, with code for this RNG in several languages.


The algorithm follows:

 Seed the RNG with the number of the deal.
 Create an array of 52 cards: Ace of Clubs, Ace of Diamonds, Ace of Hearts, Ace of Spades, 2 of Clubs, 2 of Diamonds, and so on through the ranks: Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King. The array indexes are 0 to 51, with Ace of Clubs at 0, and King of Spades at 51.
 Until the array is empty:
 Choose a random card at index ≡ next random number (mod array length).
 Swap this random card with the last card of the array.
 Remove this random card from the array. (Array length goes down by 1.)
 Deal this random card.
 Deal all 52 cards, face up, across 8 columns. The first 8 cards go in 8 columns, the next 8 cards go on the first 8 cards, and so on.


 Order to deal cards

 Game #1

 Game #617


  1  2  3  4  5  6  7  8
 9 10 11 12 13 14 15 16
17 18 19 20 21 22 23 24
25 26 27 28 29 30 31 32
33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48
49 50 51 52

 JD 2D 9H JC 5D 7H 7C 5H
KD KC 9S 5S AD QC KH 3H
2S KS 9D QD JS AS AH 3C
4C 5C TS QH 4H AC 4D 7S
3S TD 4S TH 8H 2C JH 7D
6D 8S 8D QS 6C 3D 8C TC
6S 9C 2H 6H

 7D AD 5C 3S 5S 8C 2D AH
TD 7S QD AC 6D 8H AS KH
TH QC 3H 9D 6S 8D 3D TC
KD 5H 9S 3C 8S 7H 4D JS
4C QS 9C 9H 7C 6H 2C 2S
4S TS 2H 5D JC 6C JH QH
JD KS KC 4H

Deals can also be checked against FreeCell solutions to 1000000 games.
(Summon a video solution, and it displays the initial deal.)

Write a program to take a deal number and deal cards in the same order as this algorithm.
The program may display the cards with ASCII, with Unicode, by drawing graphics, or any other way.

Related tasks:

 Playing cards
 Card shuffles
 War Card_Game
 Poker hand_analyser
 Go Fish

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/rand""
    ""os""
    ""strconv""
    ""time""
)
 
const sSuits = ""CDHS""
const sNums = ""A23456789TJQK""
const rMax32 = math.MaxInt32
 
var seed = 1
 
func rnd() int {
    seed = (seed*214013 + 2531011) & rMax32
    return seed >> 16
}
 
func deal(s int) []int {
    seed = s
    t := make([]int, 52)
    for i := 0; i < 52; i++ {
        t[i] = 51 - i
    }
    for i := 0; i < 51; i++ {
        j := 51 - rnd()%(52-i)
        t[i], t[j] = t[j], t[i]
    }
    return t
}
 
func show(cs []int) {
    for i, c := range cs {
        fmt.Printf("" %c%c"", sNums[c/4], sSuits[c%4])
        if (i+1)%8 == 0 || i+1 == len(cs) {
            fmt.Println()
        }
    }
}
 
func main() {
    var game int
    switch len(os.Args) {
    case 1:
        rand.Seed(time.Now().UnixNano())
        game = 1 + rand.Intn(32000)
    case 2:
        var err error
        game, err = strconv.Atoi(os.Args[1])
        if err == nil && game >= 1 && game <= 32000 {
            break
        }
        fallthrough
    default:
        fmt.Println(""usage: deal [game]"")
        fmt.Println(""       where game is a number in the range 1 to 32000"")
        return
    }
    fmt.Printf(""\nGame #%d\n"", game)
    show(deal(game))
}",1252,65
63443,http://rosettacode.org/wiki/Cyclops_numbers,Cyclops numbers,"A cyclops number is a number with an odd number of digits that has a zero in the center, but nowhere else. They are named so in tribute to the one eyed giants Cyclops from Greek mythology.

Cyclops numbers can be found in any base. This task strictly is looking for cyclops numbers in base 10.

There are many different classifications of cyclops numbers with minor differences in characteristics. In an effort to head off a whole series of tasks with tiny variations, we will cover several variants here.



Task
 Find and display here on this page the first 50 cyclops numbers in base 10 (all of the sub tasks are restricted to base 10).
 Find and display here on this page the first 50 prime cyclops numbers. (cyclops numbers that are prime.)
 Find and display here on this page the first 50 blind prime cyclops numbers. (prime cyclops numbers that remain prime when ""blinded""; the zero is removed from the center.)
 Find and display here on this page the first 50 palindromic prime cyclops numbers. (prime cyclops numbers that are palindromes.)


Stretch
 Find and display the first cyclops number greater than ten million (10,000,000) and the index (place) in the series where it is found.
 Find and display the first prime cyclops number greater than ten million (10,000,000) and the index (place) in the series where it is found.
 Find and display the first blind prime cyclops number greater than ten million (10,000,000) and the index (place) in the series where it is found.
 Find and display the first palindromic prime cyclops number greater than ten million (10,000,000) and the index (place) in the series where it is found.
(Note: there are no cyclops numbers between ten million and one hundred million, they need to have an odd number of digits)



See also
 OEIS A134808 - Cyclops numbers
 OEIS A134809 - Cyclops primes
 OEIS A329737 - Cyclops primes that remain prime after being ""blinded""
 OEIS A136098 - Prime palindromic cyclops numbers



",#Go,Go,"package main
 
import (
    ""fmt""
    ""rcu""
    ""strconv""
    ""strings""
)
 
func findFirst(list []int) (int, int) {
    for i, n := range list {
        if n > 1e7 {
            return n, i
        }
    }
    return -1, -1
}
 
func reverse(s string) string {
    chars := []rune(s)
    for i, j := 0, len(chars)-1; i < j; i, j = i+1, j-1 {
        chars[i], chars[j] = chars[j], chars[i]
    }
    return string(chars)
}
 
func main() {
    ranges := [][2]int{
        {0, 0}, {101, 909}, {11011, 99099}, {1110111, 9990999}, {111101111, 119101111},
    }
    var cyclops []int
    for _, r := range ranges {
        numDigits := len(fmt.Sprint(r[0]))
        center := numDigits / 2
        for i := r[0]; i <= r[1]; i++ {
            digits := rcu.Digits(i, 10)
            if digits[center] == 0 {
                count := 0
                for _, d := range digits {
                    if d == 0 {
                        count++
                    }
                }
                if count == 1 {
                    cyclops = append(cyclops, i)
                }
            }
        }
    }
    fmt.Println(""The first 50 cyclops numbers are:"")
    for i, n := range cyclops[0:50] {
        fmt.Printf(""%6s "", rcu.Commatize(n))
        if (i+1)%10 == 0 {
            fmt.Println()
        }
    }
    n, i := findFirst(cyclops)
    ns, is := rcu.Commatize(n), rcu.Commatize(i)
    fmt.Printf(""\nFirst such number > 10 million is %s at zero-based index %s\n"", ns, is)
 
    var primes []int
    for _, n := range cyclops {
        if rcu.IsPrime(n) {
            primes = append(primes, n)
        }
    }
    fmt.Println(""\n\nThe first 50 prime cyclops numbers are:"")
    for i, n := range primes[0:50] {
        fmt.Printf(""%6s "", rcu.Commatize(n))
        if (i+1)%10 == 0 {
            fmt.Println()
        }
    }
    n, i = findFirst(primes)
    ns, is = rcu.Commatize(n), rcu.Commatize(i)
    fmt.Printf(""\nFirst such number > 10 million is %s at zero-based index %s\n"", ns, is)
 
    var bpcyclops []int
    var ppcyclops []int
    for _, p := range primes {
        ps := fmt.Sprint(p)
        split := strings.Split(ps, ""0"")
        noMiddle, _ := strconv.Atoi(split[0] + split[1])
        if rcu.IsPrime(noMiddle) {
            bpcyclops = append(bpcyclops, p)
        }
        if ps == reverse(ps) {
            ppcyclops = append(ppcyclops, p)
        }
    }
 
    fmt.Println(""\n\nThe first 50 blind prime cyclops numbers are:"")
    for i, n := range bpcyclops[0:50] {
        fmt.Printf(""%6s "", rcu.Commatize(n))
        if (i+1)%10 == 0 {
            fmt.Println()
        }
    }
    n, i = findFirst(bpcyclops)
    ns, is = rcu.Commatize(n), rcu.Commatize(i)
    fmt.Printf(""\nFirst such number > 10 million is %s at zero-based index %s\n"", ns, is)
 
    fmt.Println(""\n\nThe first 50 palindromic prime cyclops numbers are:\n"")
    for i, n := range ppcyclops[0:50] {
        fmt.Printf(""%9s "", rcu.Commatize(n))
        if (i+1)%8 == 0 {
            fmt.Println()
        }
    }
    n, i = findFirst(ppcyclops)
    ns, is = rcu.Commatize(n), rcu.Commatize(i)
    fmt.Printf(""\n\nFirst such number > 10 million is %s at zero-based index %s\n"", ns, is)
}",3186,113
63509,http://rosettacode.org/wiki/Curzon_numbers,Curzon numbers,"A Curzon number is defined to be a positive integer n for which 2n + 1 is evenly divisible by 2 × n + 1.

Generalized Curzon numbers are those where the positive integer n, using a base integer k, satisfy the condition that kn + 1 is evenly divisible by k × n + 1.

Base here does not imply the radix of the counting system; rather the integer the equation is based on. All calculations should be done in base 10.

Generalized Curzon numbers only exist for even base integers.



Task 
 Find and show the first 50 Generalized Curzon numbers for even base integers from 2 through 10.


Stretch
 Find and show the one thousandth.


See also
 Numbers Aplenty - Curzon numbers
 OEIS:A224486 - Numbers k such that 2*k+1 divides 2^k+1 (Curzon numbers)
and even though it is not specifically mentioned that they are Curzon numbers:

 OEIS:A230076 - (A007521(n)-1)/4 (Generalized Curzon numbers with a base 4)



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    zero := big.NewInt(0)
    one := big.NewInt(1)
    for k := int64(2); k <= 10; k += 2 {
        bk := big.NewInt(k)
        fmt.Println(""The first 50 Curzon numbers using a base of"", k, "":"")
        count := 0
        n := int64(1)
        pow := big.NewInt(k)
        z := new(big.Int)
        var curzon50 []int64
        for {
            z.Add(pow, one)
            d := k*n + 1
            bd := big.NewInt(d)
            if z.Rem(z, bd).Cmp(zero) == 0 {
                if count < 50 {
                    curzon50 = append(curzon50, n)
                }
                count++
                if count == 50 {
                    for i := 0; i < len(curzon50); i++ {
                        fmt.Printf(""%4d "", curzon50[i])
                        if (i+1)%10 == 0 {
                            fmt.Println()
                        }
                    }
                    fmt.Print(""\nOne thousandth: "")
                }
                if count == 1000 {
                    fmt.Println(n)
                    break
                }
            }
            n++
            pow.Mul(pow, bk)
        }
        fmt.Println()
    }
}",1217,47
63557,http://rosettacode.org/wiki/Cut_a_rectangle,Cut a rectangle,"A given rectangle is made from m × n squares. If m and n are not both odd, then it is possible to cut a path through the rectangle along the square edges such that the rectangle splits into two connected pieces with the same shape (after rotating one of the pieces by 180°). All such paths for 2 × 2 and 4 × 3 rectangles are shown below.



Write a program that calculates the number of different ways to cut an m × n rectangle. Optionally, show each of the cuts.

Possibly related task: Maze generation for depth-first search.
",#Go,Go,"package main
 
import ""fmt""
 
var grid []byte
var w, h, last int
var cnt int
var next [4]int
var dir = [4][2]int{{0, -1}, {-1, 0}, {0, 1}, {1, 0}}
 
func walk(y, x int) {
    if y == 0 || y == h || x == 0 || x == w {
        cnt += 2
        return
    }
    t := y*(w+1) + x
    grid[t]++
    grid[last-t]++
    for i, d := range dir {
        if grid[t+next[i]] == 0 {
            walk(y+d[0], x+d[1])
        }
    }
    grid[t]--
    grid[last-t]--
}
 
func solve(hh, ww, recur int) int {
    h = hh
    w = ww
 
    if h&1 != 0 {
        h, w = w, h
    }
    switch {
    case h&1 == 1:
        return 0
    case w == 1:
        return 1
    case w == 2:
        return h
    case h == 2:
        return w
    }
    cy := h / 2
    cx := w / 2
 
    grid = make([]byte, (h+1)*(w+1))
    last = len(grid) - 1
    next[0] = -1
    next[1] = -w - 1
    next[2] = 1
    next[3] = w + 1
 
    if recur != 0 {
        cnt = 0
    }
    for x := cx + 1; x < w; x++ {
        t := cy*(w+1) + x
        grid[t] = 1
        grid[last-t] = 1
        walk(cy-1, x)
    }
    cnt++
 
    if h == w {
        cnt *= 2
    } else if w&1 == 0 && recur != 0 {
        solve(w, h, 0)
    }
    return cnt
}
 
func main() {
    for y := 1; y <= 10; y++ {
        for x := 1; x <= y; x++ {
            if x&1 == 0 || y&1 == 0 {
                fmt.Printf(""%d x %d: %d\n"", y, x, solve(y, x, 1))
            }
        }
    }
}",1411,82
63598,http://rosettacode.org/wiki/Cyclotomic_polynomial,Cyclotomic polynomial,"The nth Cyclotomic polynomial, for any positive integer n, is the unique irreducible polynomial of largest degree with integer coefficients that is a divisor of x^n − 1, and is not a divisor of x^k − 1 for any k < n.



Task

 Find and print the first 30 cyclotomic polynomials.
 Find and print the order of the first 10 cyclotomic polynomials that have n or -n as a coefficient.


See also
 Wikipedia article, Cyclotomic polynomial, showing ways to calculate them.
 The sequence A013594 with the smallest order of cyclotomic polynomial containing n or -n as a coefficient.",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math""
    ""sort""
    ""strings""
)
 
const (
    algo          = 2
    maxAllFactors = 100000
)
 
func iabs(i int) int {
    if i < 0 {
        return -i
    }
    return i
}
 
type term struct{ coef, exp int }
 
func (t term) mul(t2 term) term {
    return term{t.coef * t2.coef, t.exp + t2.exp}
}
 
func (t term) add(t2 term) term {
    if t.exp != t2.exp {
        log.Fatal(""exponents unequal in term.add method"")
    }
    return term{t.coef + t2.coef, t.exp}
}
 
func (t term) negate() term { return term{-t.coef, t.exp} }
 
func (t term) String() string {
    switch {
    case t.coef == 0:
        return ""0""
    case t.exp == 0:
        return fmt.Sprintf(""%d"", t.coef)
    case t.coef == 1:
        if t.exp == 1 {
            return ""x""
        } else {
            return fmt.Sprintf(""x^%d"", t.exp)
        }
    case t.exp == 1:
        return fmt.Sprintf(""%dx"", t.coef)
    }
    return fmt.Sprintf(""%dx^%d"", t.coef, t.exp)
}
 
type poly struct{ terms []term }
 
// pass coef, exp in pairs as parameters
func newPoly(values ...int) poly {
    le := len(values)
    if le == 0 {
        return poly{[]term{term{0, 0}}}
    }
    if le%2 != 0 {
        log.Fatalf(""odd number of parameters (%d) passed to newPoly function"", le)
    }
    var terms []term
    for i := 0; i < le; i += 2 {
        terms = append(terms, term{values[i], values[i+1]})
    }
    p := poly{terms}.tidy()
    return p
}
 
func (p poly) hasCoefAbs(coef int) bool {
    for _, t := range p.terms {
        if iabs(t.coef) == coef {
            return true
        }
    }
    return false
}
 
func (p poly) add(p2 poly) poly {
    p3 := newPoly()
    le, le2 := len(p.terms), len(p2.terms)
    for le > 0 || le2 > 0 {
        if le == 0 {
            p3.terms = append(p3.terms, p2.terms[le2-1])
            le2--
        } else if le2 == 0 {
            p3.terms = append(p3.terms, p.terms[le-1])
            le--
        } else {
            t := p.terms[le-1]
            t2 := p2.terms[le2-1]
            if t.exp == t2.exp {
                t3 := t.add(t2)
                if t3.coef != 0 {
                    p3.terms = append(p3.terms, t3)
                }
                le--
                le2--
            } else if t.exp < t2.exp {
                p3.terms = append(p3.terms, t)
                le--
            } else {
                p3.terms = append(p3.terms, t2)
                le2--
            }
        }
    }
    return p3.tidy()
}
 
func (p poly) addTerm(t term) poly {
    q := newPoly()
    added := false
    for i := 0; i < len(p.terms); i++ {
        ct := p.terms[i]
        if ct.exp == t.exp {
            added = true
            if ct.coef+t.coef != 0 {
                q.terms = append(q.terms, ct.add(t))
            }
        } else {
            q.terms = append(q.terms, ct)
        }
    }
    if !added {
        q.terms = append(q.terms, t)
    }
    return q.tidy()
}
 
func (p poly) mulTerm(t term) poly {
    q := newPoly()
    for i := 0; i < len(p.terms); i++ {
        ct := p.terms[i]
        q.terms = append(q.terms, ct.mul(t))
    }
    return q.tidy()
}
 
func (p poly) div(v poly) poly {
    q := newPoly()
    lcv := v.leadingCoef()
    dv := v.degree()
    for p.degree() >= v.degree() {
        lcp := p.leadingCoef()
        s := lcp / lcv
        t := term{s, p.degree() - dv}
        q = q.addTerm(t)
        p = p.add(v.mulTerm(t.negate()))
    }
    return q.tidy()
}
 
func (p poly) leadingCoef() int {
    return p.terms[0].coef
}
 
func (p poly) degree() int {
    return p.terms[0].exp
}
 
func (p poly) String() string {
    var sb strings.Builder
    first := true
    for _, t := range p.terms {
        if first {
            sb.WriteString(t.String())
            first = false
        } else {
            sb.WriteString("" "")
            if t.coef > 0 {
                sb.WriteString(""+ "")
                sb.WriteString(t.String())
            } else {
                sb.WriteString(""- "")
                sb.WriteString(t.negate().String())
            }
        }
    }
    return sb.String()
}
 
// in place descending sort by term.exp
func (p poly) sortTerms() {
    sort.Slice(p.terms, func(i, j int) bool {
        return p.terms[i].exp > p.terms[j].exp
    })
}
 
// sort terms and remove any unnecesary zero terms
func (p poly) tidy() poly {
    p.sortTerms()
    if p.degree() == 0 {
        return p
    }
    for i := len(p.terms) - 1; i >= 0; i-- {
        if p.terms[i].coef == 0 {
            copy(p.terms[i:], p.terms[i+1:])
            p.terms[len(p.terms)-1] = term{0, 0}
            p.terms = p.terms[:len(p.terms)-1]
        }
    }
    if len(p.terms) == 0 {
        p.terms = append(p.terms, term{0, 0})
    }
    return p
}
 
func getDivisors(n int) []int {
    var divs []int
    sqrt := int(math.Sqrt(float64(n)))
    for i := 1; i <= sqrt; i++ {
        if n%i == 0 {
            divs = append(divs, i)
            d := n / i
            if d != i && d != n {
                divs = append(divs, d)
            }
        }
    }
    return divs
}
 
var (
    computed   = make(map[int]poly)
    allFactors = make(map[int]map[int]int)
)
 
func init() {
    f := map[int]int{2: 1}
    allFactors[2] = f
}
 
func getFactors(n int) map[int]int {
    if f, ok := allFactors[n]; ok {
        return f
    }
    factors := make(map[int]int)
    if n%2 == 0 {
        factorsDivTwo := getFactors(n / 2)
        for k, v := range factorsDivTwo {
            factors[k] = v
        }
        factors[2]++
        if n < maxAllFactors {
            allFactors[n] = factors
        }
        return factors
    }
    prime := true
    sqrt := int(math.Sqrt(float64(n)))
    for i := 3; i <= sqrt; i += 2 {
        if n%i == 0 {
            prime = false
            for k, v := range getFactors(n / i) {
                factors[k] = v
            }
            factors[i]++
            if n < maxAllFactors {
                allFactors[n] = factors
            }
            return factors
        }
    }
    if prime {
        factors[n] = 1
        if n < maxAllFactors {
            allFactors[n] = factors
        }
    }
    return factors
}
 
func cycloPoly(n int) poly {
    if p, ok := computed[n]; ok {
        return p
    }
    if n == 1 {
        // polynomial: x - 1
        p := newPoly(1, 1, -1, 0)
        computed[1] = p
        return p
    }
    factors := getFactors(n)
    cyclo := newPoly()
    if _, ok := factors[n]; ok {
        // n is prime
        for i := 0; i < n; i++ {
            cyclo.terms = append(cyclo.terms, term{1, i})
        }
    } else if len(factors) == 2 && factors[2] == 1 && factors[n/2] == 1 {
        // n == 2p
        prime := n / 2
        coef := -1
        for i := 0; i < prime; i++ {
            coef *= -1
            cyclo.terms = append(cyclo.terms, term{coef, i})
        }
    } else if len(factors) == 1 {
        if h, ok := factors[2]; ok {
            // n == 2^h
            cyclo.terms = append(cyclo.terms, term{1, 1 << (h - 1)}, term{1, 0})
        } else if _, ok := factors[n]; !ok {
            // n == p ^ k
            p := 0
            for prime := range factors {
                p = prime
            }
            k := factors[p]
            for i := 0; i < p; i++ {
                pk := int(math.Pow(float64(p), float64(k-1)))
                cyclo.terms = append(cyclo.terms, term{1, i * pk})
            }
        }
    } else if len(factors) == 2 && factors[2] != 0 {
        // n = 2^h * p^k
        p := 0
        for prime := range factors {
            if prime != 2 {
                p = prime
            }
        }
        coef := -1
        twoExp := 1 << (factors[2] - 1)
        k := factors[p]
        for i := 0; i < p; i++ {
            coef *= -1
            pk := int(math.Pow(float64(p), float64(k-1)))
            cyclo.terms = append(cyclo.terms, term{coef, i * twoExp * pk})
        }
    } else if factors[2] != 0 && ((n/2)%2 == 1) && (n/2) > 1 {
        //  CP(2m)[x] == CP(-m)[x], n odd integer > 1
        cycloDiv2 := cycloPoly(n / 2)
        for _, t := range cycloDiv2.terms {
            t2 := t
            if t.exp%2 != 0 {
                t2 = t.negate()
            }
            cyclo.terms = append(cyclo.terms, t2)
        }
    } else if algo == 0 {
        // slow - uses basic definition
        divs := getDivisors(n)
        // polynomial: x^n - 1
        cyclo = newPoly(1, n, -1, 0)
        for _, i := range divs {
            p := cycloPoly(i)
            cyclo = cyclo.div(p)
        }
    } else if algo == 1 {
        //  faster - remove max divisor (and all divisors of max divisor)
        //  only one divide for all divisors of max divisor
        divs := getDivisors(n)
        maxDiv := math.MinInt32
        for _, d := range divs {
            if d > maxDiv {
                maxDiv = d
            }
        }
        var divsExceptMax []int
        for _, d := range divs {
            if maxDiv%d != 0 {
                divsExceptMax = append(divsExceptMax, d)
            }
        }
        // polynomial:  ( x^n - 1 ) / ( x^m - 1 ), where m is the max divisor
        cyclo = newPoly(1, n, -1, 0)
        cyclo = cyclo.div(newPoly(1, maxDiv, -1, 0))
        for _, i := range divsExceptMax {
            p := cycloPoly(i)
            cyclo = cyclo.div(p)
        }
    } else if algo == 2 {
        //  fastest
        //  let p, q be primes such that p does not divide n, and q divides n
        //  then CP(np)[x] = CP(n)[x^p] / CP(n)[x]
        m := 1
        cyclo = cycloPoly(m)
        var primes []int
        for prime := range factors {
            primes = append(primes, prime)
        }
        sort.Ints(primes)
        for _, prime := range primes {
            //  CP(m)[x]
            cycloM := cyclo
            //  compute CP(m)[x^p]
            var terms []term
            for _, t := range cycloM.terms {
                terms = append(terms, term{t.coef, t.exp * prime})
            }
            cyclo = newPoly()
            cyclo.terms = append(cyclo.terms, terms...)
            cyclo = cyclo.tidy()
            cyclo = cyclo.div(cycloM)
            m *= prime
        }
        //  now, m is the largest square free divisor of n
        s := n / m
        //  Compute CP(n)[x] = CP(m)[x^s]
        var terms []term
        for _, t := range cyclo.terms {
            terms = append(terms, term{t.coef, t.exp * s})
        }
        cyclo = newPoly()
        cyclo.terms = append(cyclo.terms, terms...)
    } else {
        log.Fatal(""invalid algorithm"")
    }
    cyclo = cyclo.tidy()
    computed[n] = cyclo
    return cyclo
}
 
func main() {
    fmt.Println(""Task 1:  cyclotomic polynomials for n <= 30:"")
    for i := 1; i <= 30; i++ {
        p := cycloPoly(i)
        fmt.Printf(""CP[%2d] = %s\n"", i, p)
    }
 
    fmt.Println(""\nTask 2:  Smallest cyclotomic polynomial with n or -n as a coefficient:"")
    n := 0
    for i := 1; i <= 10; i++ {
        for {
            n++
            cyclo := cycloPoly(n)
            if cyclo.hasCoefAbs(i) {
                fmt.Printf(""CP[%d] has coefficient with magnitude = %d\n"", n, i)
                n--
                break
            }
        }
    }
}",11205,440
63645,http://rosettacode.org/wiki/Cullen_and_Woodall_numbers,Cullen and Woodall numbers,"A Cullen number is a number of the form n × 2n + 1 where n is a natural number.

A Woodall number is very similar. It is a number of the form n × 2n - 1 where n is a natural number.

So for each n the associated Cullen number and Woodall number differ by 2.

Woodall numbers are sometimes referred to as Riesel numbers or Cullen numbers of the second kind.


Cullen primes are Cullen numbers that are prime. Similarly, Woodall primes are Woodall numbers that are prime.

It is common to list the Cullen and Woodall primes by the value of n rather than the full evaluated expression. They tend to get very large very quickly. For example, the third Cullen prime, n == 4713, has 1423 digits when evaluated.



Task
 Write procedures to find Cullen numbers and Woodall numbers. 
 Use those procedures to find and show here, on this page the first 20 of each.


Stretch
 Find and show the first 5 Cullen primes in terms of n.
 Find and show the first 12 Woodall primes in terms of n.


See also
 OEIS:A002064 - Cullen numbers: a(n) = n*2^n + 1
 OEIS:A003261 - Woodall (or Riesel) numbers: n*2^n - 1
 OEIS:A005849 - Indices of prime Cullen numbers: numbers k such that k*2^k + 1 is prime
 OEIS:A002234 - Numbers k such that the Woodall number k*2^k - 1 is prime

",#Go,Go,"package main
 
import (
    ""fmt""
    big ""github.com/ncw/gmp""
)
 
func cullen(n uint) *big.Int {
    one := big.NewInt(1)
    bn := big.NewInt(int64(n))
    res := new(big.Int).Lsh(one, n)
    res.Mul(res, bn)
    return res.Add(res, one)
}
 
func woodall(n uint) *big.Int {
    res := cullen(n)
    return res.Sub(res, big.NewInt(2))
}
 
func main() {
    fmt.Println(""First 20 Cullen numbers (n * 2^n + 1):"")
    for n := uint(1); n <= 20; n++ {
        fmt.Printf(""%d "", cullen(n))
    }
 
    fmt.Println(""\n\nFirst 20 Woodall numbers (n * 2^n - 1):"")
    for n := uint(1); n <= 20; n++ {
        fmt.Printf(""%d "", woodall(n))
    }
 
    fmt.Println(""\n\nFirst 5 Cullen primes (in terms of n):"")
    count := 0
    for n := uint(1); count < 5; n++ {
        cn := cullen(n)
        if cn.ProbablyPrime(15) {
            fmt.Printf(""%d "", n)
            count++
        }
    }
 
    fmt.Println(""\n\nFirst 12 Woodall primes (in terms of n):"")
    count = 0
    for n := uint(1); count < 12; n++ {
        cn := woodall(n)
        if cn.ProbablyPrime(15) {
            fmt.Printf(""%d "", n)
            count++
        }
    }
    fmt.Println()
}",1150,52
63709,http://rosettacode.org/wiki/Date_manipulation,Date manipulation,"Task

Given the date string ""March 7 2009 7:30pm EST"", 

output the time 12 hours later in any human-readable format.

As extra credit, display the resulting time in a time zone different from your own.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""time""
)
 
const taskDate = ""March 7 2009 7:30pm EST""
const taskFormat = ""January 2 2006 3:04pm MST""
 
func main() {
    if etz, err := time.LoadLocation(""US/Eastern""); err == nil {
        time.Local = etz
    }
    fmt.Println(""Input:             "", taskDate)
    t, err := time.Parse(taskFormat, taskDate)
    if err != nil {
        fmt.Println(err)
        return
    }
    t = t.Add(12 * time.Hour)
    fmt.Println(""+12 hrs:           "", t)
    if _, offset := t.Zone(); offset == 0 {
        fmt.Println(""No time zone info."")
        return
    }
    atz, err := time.LoadLocation(""US/Arizona"")
    if err == nil {
        fmt.Println(""+12 hrs in Arizona:"", t.In(atz))
    }
}",721,31
63798,http://rosettacode.org/wiki/CUSIP,CUSIP,"

 This page uses content from Wikipedia. The original article was at CUSIP. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



A   CUSIP   is a nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades. The CUSIP was adopted as an American National Standard under Accredited Standards X9.6.



Task

Ensure the last digit   (i.e., the   check digit)   of the CUSIP code (the 1st column) is correct, against the following:

   037833100       Apple Incorporated 
   17275R102       Cisco Systems 
   38259P508       Google Incorporated 
   594918104       Microsoft Corporation 
   68389X106       Oracle Corporation   (incorrect)
   68389X105       Oracle Corporation 


Example pseudo-code below.
algorithm Cusip-Check-Digit(cusip) is
   Input: an 8-character CUSIP
 
   sum := 0
   for 1 ≤ i ≤ 8 do
      c := the ith character of cusip
      if c is a digit then
         v := numeric value of the digit c
      else if c is a letter then
         p := ordinal position of c in the alphabet (A=1, B=2...)
         v := p + 9
      else if c = ""*"" then
         v := 36
      else if c = ""@"" then
         v := 37
      else if' c = ""#"" then
         v := 38
      end if
      if i is even then
         v := v × 2
      end if
 
      sum := sum + int ( v div 10 ) + v mod 10
   repeat
 
   return (10 - (sum mod 10)) mod 10
end function
See related tasks
 
 SEDOL
 ISIN

",#Go,Go,"package main
 
import ""fmt""
 
func isCusip(s string) bool {
    if len(s) != 9 { return false }
    sum := 0
    for i := 0; i < 8; i++ {
        c := s[i]
        var v int
        switch {
            case c >= '0' && c <= '9':
                v = int(c) - 48
            case c >= 'A' && c <= 'Z':
                v = int(c) - 55
            case c == '*':
                v = 36
            case c == '@':
                v = 37
            case c == '#':
                v = 38
            default:
                return false
        }
        if i % 2 == 1 { v *= 2 }  // check if odd as using 0-based indexing
        sum += v/10 + v%10
    }
    return int(s[8]) - 48 == (10 - (sum%10)) % 10
}
 
func main() {
    candidates := []string {
        ""037833100"",
        ""17275R102"",
        ""38259P508"",
        ""594918104"",
        ""68389X106"",
        ""68389X105"",
    }
 
    for _, candidate := range candidates {
        var b string
        if isCusip(candidate) {
            b = ""correct""
        } else {
            b = ""incorrect""
        }
        fmt.Printf(""%s -> %s\n"", candidate, b)
    }
}
 ",1116,51
63811,http://rosettacode.org/wiki/Create_an_object_at_a_given_address,Create an object at a given address,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses




In systems programing it is sometimes required to place language objects at specific memory locations, like I/O registers, hardware interrupt vectors etc.



Task

Show how language objects can be allocated at a specific machine addresses.

Since most OSes prohibit access to the physical memory if it is not mapped by the application, as an example, rather than a physical address, take the address of some existing object (using suitable address operations if necessary).



For example:

   create an integer object
   print the machine address of the object
   take the address of the object and create another integer object at this address
   print the value of this object to verify that it is same as one of the origin
   change the value of the origin and verify it again

",#Go,Go,"package main
 
import(
	""fmt""
	""unsafe""
	""reflect""
)
 
func pointer() {
	fmt.Printf(""Pointer:\n"")
 
	// Create a *int and store the address of 'i' in it. To create a pointer to
	// an arbitrary memory location, use something like the following:
	//    p := (*int)(unsafe.Pointer(uintptr(0x100)))
	// And replace '0x100' with the desired address.
	var i int
	p := &i
 
	fmt.Printf(""Before:\n\t%v: %v, %v\n"", p, *p, i)
 
	*p = 3
 
	fmt.Printf(""After:\n\t%v: %v, %v\n"", p, *p, i)
}
 
func slice() {
	fmt.Printf(""Slice:\n"")
 
	var a [10]byte
 
	// reflect.SliceHeader is a runtime representation of the internal workings
	// of a slice. To make it point to a specific address, use something like
	// the following:
	//    h.Data = uintptr(0x100)
	// And replace '0x100' with the desired address.
	var h reflect.SliceHeader
	h.Data = uintptr(unsafe.Pointer(&a)) // The address of the first element of the underlying array.
	h.Len = len(a)
	h.Cap = len(a)
 
	// Create an actual slice from the SliceHeader.
	s := *(*[]byte)(unsafe.Pointer(&h))
 
	fmt.Printf(""Before:\n\ts: %v\n\ta: %v\n"", s, a)
 
	// Copy a string into the slice. This fills the underlying array, which in
	// this case has been manually set to 'a'.
	copy(s, ""A string."")
 
	fmt.Printf(""After:\n\ts: %v\n\ta: %v\n"", s, a)
}
 
func main() {
	pointer()
	fmt.Println()
 
	slice()
}",1339,58
63830,http://rosettacode.org/wiki/Currency,Currency,"Task

Show how to represent currency in a simple example, using a data type that represent exact values of dollars and cents.



Note

The IEEE 754 binary floating point representations of numbers like   2.86   and   .0765   are not exact.

For this example, data will be two items with prices in dollars and cents, a quantity for each, and a tax rate.

Use the values:

 4000000000000000 hamburgers at $5.50 each       (four quadrillion burgers)
 2 milkshakes at $2.86 each, and 
 a tax rate of 7.65%. 


(That number of hamburgers is a 4 with 15 zeros after it.   The number is contrived to exclude naïve task solutions using 64 bit floating point types.)

Compute and output (show results on this page):

 the total price before tax
 the tax
 the total with tax 


The tax value must be computed by rounding to the nearest whole cent and this exact value must be added to the total price before tax.

The output must show dollars and cents with a decimal point.

The three results displayed should be:

 22000000000000005.72
 1683000000000000.44 
 23683000000000006.16 


Dollar signs and thousands separators are optional.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math/big""
)
 
// DC for dollars and cents.  Value is an integer number of cents.
type DC int64
 
func (dc DC) String() string {
    d := dc / 100
    if dc < 0 {
        dc = -dc
    }
    return fmt.Sprintf(""%d.%02d"", d, dc%100)
}
 
// Extend returns extended price of a unit price.
func (dc DC) Extend(n int) DC {
    return dc * DC(n)
}
 
var one = big.NewInt(1)
var hundred = big.NewRat(100, 1)
 
// ParseDC parses dollars and cents as a string into a DC.
func ParseDC(s string) (DC, bool) {
    r, ok := new(big.Rat).SetString(s)
    if !ok {
        return 0, false
    }
    r.Mul(r, hundred)
    if r.Denom().Cmp(one) != 0 {
        return 0, false
    }
    return DC(r.Num().Int64()), true
}
 
// TR for tax rate.  Value is an an exact rational.
type TR struct {
    *big.Rat
}
func NewTR() TR {
    return TR{new(big.Rat)}
}
 
// SetString overrides Rat.SetString to return the TR type.
func (tr TR) SetString(s string) (TR, bool) {
    if _, ok := tr.Rat.SetString(s); !ok {
        return TR{}, false
    }
    return tr, true
}
 
var half = big.NewRat(1, 2)
 
// Tax computes a tax amount, rounding to the nearest cent.
func (tr TR) Tax(dc DC) DC {
    r := big.NewRat(int64(dc), 1)
    r.Add(r.Mul(r, tr.Rat), half)
    return DC(new(big.Int).Div(r.Num(), r.Denom()).Int64())
}
 
func main() {
    hamburgerPrice, ok := ParseDC(""5.50"")
    if !ok {
        log.Fatal(""Invalid hamburger price"")
    }
    milkshakePrice, ok := ParseDC(""2.86"")
    if !ok {
        log.Fatal(""Invalid milkshake price"")
    }
    taxRate, ok := NewTR().SetString(""0.0765"")
    if !ok {
        log.Fatal(""Invalid tax rate"")
    }
 
    totalBeforeTax := hamburgerPrice.Extend(4000000000000000) +
        milkshakePrice.Extend(2)
    tax := taxRate.Tax(totalBeforeTax)
    total := totalBeforeTax + tax
 
    fmt.Printf(""Total before tax: %22s\n"", totalBeforeTax)
    fmt.Printf(""             Tax: %22s\n"", tax)
    fmt.Printf(""           Total: %22s\n"", total)
}",2006,88
63831,http://rosettacode.org/wiki/Currying,Currying,"

 This page uses content from Wikipedia. The original article was at Currying. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Create a simple demonstrative example of Currying in a specific language.

Add any historic details as to how the feature made its way into the language.



",#Go,Go,"package main
 
import (
        ""fmt""
        ""math""
)
 
func PowN(b float64) func(float64) float64 {
        return func(e float64) float64 { return math.Pow(b, e) }
}
 
func PowE(e float64) func(float64) float64 {
        return func(b float64) float64 { return math.Pow(b, e) }
}
 
type Foo int
 
func (f Foo) Method(b int) int {
        return int(f) + b
}
 
func main() {
        pow2 := PowN(2)
        cube := PowE(3)
 
        fmt.Println(""2^8 ="", pow2(8))
        fmt.Println(""4³ ="", cube(4))
 
        var a Foo = 2
        fn1 := a.Method   // A ""method value"", like currying 'a'
        fn2 := Foo.Method // A ""method expression"", like uncurrying
 
        fmt.Println(""2 + 2 ="", a.Method(2)) // regular method call
        fmt.Println(""2 + 3 ="", fn1(3))
        fmt.Println(""2 + 4 ="", fn2(a, 4))
        fmt.Println(""3 + 5 ="", fn2(Foo(3), 5))
}",857,37
63846,http://rosettacode.org/wiki/Damm_algorithm,Damm algorithm,"The Damm algorithm is a checksum algorithm which detects all single digit errors and adjacent transposition errors.



The algorithm is named after H. Michael Damm.



Task

Verify the checksum, stored as last digit of an input.


",#Go,Go,"package main
 
import ""fmt""
 
var table = [10][10]byte{
    {0, 3, 1, 7, 5, 9, 8, 6, 4, 2},
    {7, 0, 9, 2, 1, 5, 4, 8, 6, 3},
    {4, 2, 0, 6, 8, 7, 1, 3, 5, 9},
    {1, 7, 5, 0, 9, 8, 3, 4, 2, 6},
    {6, 1, 2, 3, 0, 4, 5, 9, 7, 8},
    {3, 6, 7, 4, 2, 0, 9, 5, 8, 1},
    {5, 8, 6, 9, 7, 2, 0, 1, 3, 4},
    {8, 9, 4, 5, 3, 6, 2, 0, 1, 7},
    {9, 4, 3, 8, 6, 1, 7, 2, 0, 5},
    {2, 5, 8, 1, 4, 3, 6, 7, 9, 0},
}
 
func damm(input string) bool {
    var interim byte
    for _, c := range []byte(input) {
        interim = table[interim][c-'0']
    }
    return interim == 0
}
 
func main() {
    for _, s := range []string{""5724"", ""5727"", ""112946"", ""112949""} {
        fmt.Printf(""%6s  %t\n"", s, damm(s))
    }
}",718,30
63880,http://rosettacode.org/wiki/Create_a_file_on_magnetic_tape,Create a file on magnetic tape,"The task is to create a new file called ""TAPE.FILE"" of any size on Magnetic Tape.
",#Go,Go,"package main
 
import (
        ""archive/tar""
        ""compress/gzip""
        ""flag""
        ""io""
        ""log""
        ""os""
        ""time""
)
 
func main() {
        filename := flag.String(""file"", ""TAPE.FILE"", ""filename within TAR"")
        data := flag.String(""data"", """", ""data for file"")
        outfile := flag.String(""out"", """", ""output file or device (e.g. /dev/tape)"")
        gzipFlag := flag.Bool(""gzip"", false, ""use gzip compression"")
        flag.Parse()
 
        var w io.Writer = os.Stdout
        if *outfile != """" {
                f, err := os.Create(*outfile)
                if err != nil {
                        log.Fatalf(""opening/creating %q: %v"", *outfile, err)
                }
                defer f.Close()
                w = f
        }
 
        if *gzipFlag {
                zw := gzip.NewWriter(w)
                defer zw.Close()
                w = zw
        }
 
        tw := tar.NewWriter(w)
        defer tw.Close()
        w = tw
        tw.WriteHeader(&tar.Header{
                Name:     *filename,
                Mode:     0660,
                Size:     int64(len(*data)),
                ModTime:  time.Now(),
                Typeflag: tar.TypeReg,
                Uname:    ""guest"",
                Gname:    ""guest"",
        })
 
        _, err := w.Write([]byte(*data))
        if err != nil {
                log.Fatal(""writing data:"", err)
        }
}",1406,53
63942,http://rosettacode.org/wiki/Day_of_the_week,Day of the week,"A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).



Task

In what years between 2008 and 2121 will the 25th of December be a Sunday?

Using any standard date handling libraries of your programming language;
compare the dates calculated with the output of other languages to discover any anomalies in the handling of dates which may be due to, for example, overflow in types used to represent dates/times similar to   y2k   type problems.



",#Go,Go,"package main
 
import ""fmt""
import ""time""
 
func main() {
    for year := 2008; year <= 2121; year++ {
        if time.Date(year, 12, 25, 0, 0, 0, 0, time.UTC).Weekday() ==
            time.Sunday {
            fmt.Printf(""25 December %d is Sunday\n"", year)
        }
    }
}",275,13
64060,http://rosettacode.org/wiki/Date_format,Date format,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.


Task

Display the   current date   in the formats of:

   2007-11-23     and 
   Friday, November 23, 2007

",#Go,Go,"package main
 
import ""time""
import ""fmt""
 
func main() {
    fmt.Println(time.Now().Format(""2006-01-02""))
    fmt.Println(time.Now().Format(""Monday, January 2, 2006""))
}",170,9
64067,http://rosettacode.org/wiki/Cuban_primes,Cuban primes,"The name   cuban   has nothing to do with   Cuba  (the country),   but has to do with the
fact that cubes   (3rd powers)   play a role in its definition.



Some definitions of cuban primes

   primes which are the difference of two consecutive cubes.
   primes of the form:   (n+1)3 - n3.
   primes of the form:   n3 - (n-1)3.
   primes   p   such that   n2(p+n)   is a cube for some   n>0.
   primes   p   such that   4p = 1 + 3n2.


Cuban primes were named in 1923 by Allan Joseph Champneys Cunningham.



Task requirements

   show the first   200   cuban primes   (in a multi─line horizontal format).
   show the   100,000th   cuban prime.
   show all cuban primes with commas   (if appropriate).
   show all output here.


Note that   cuban prime   isn't capitalized   (as it doesn't refer to the nation of Cuba).



Also see

   Wikipedia entry:     cuban prime.
   MathWorld entry:   cuban prime.
   The OEIS entry:     A002407.     The   100,000th   cuban prime can be verified in the   2nd   example   on this OEIS web page.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func commatize(n uint64) string {
    s := fmt.Sprintf(""%d"", n)
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    return s
}
 
func main() {
    var z big.Int
    var cube1, cube2, cube100k, diff uint64
    cubans := make([]string, 200)
    cube1 = 1
    count := 0
    for i := 1; ; i++ {
        j := i + 1
        cube2 = uint64(j * j * j)
        diff = cube2 - cube1
        z.SetUint64(diff)
        if z.ProbablyPrime(0) { // 100% accurate for z < 2 ^ 64
            if count < 200 {
                cubans[count] = commatize(diff)
            }
            count++
            if count == 100000 {
                cube100k = diff
                break
            }
        }
        cube1 = cube2
    }
    fmt.Println(""The first 200 cuban primes are:-"")
    for i := 0; i < 20; i++ {
        j := i * 10 
        fmt.Printf(""%9s\n"", cubans[j : j+10]) // 10 per line say
    }
    fmt.Println(""\nThe 100,000th cuban prime is"", commatize(cube100k))
}",1059,46
64317,http://rosettacode.org/wiki/CSV_data_manipulation,CSV data manipulation,"CSV spreadsheet files are suitable for storing tabular data in a relatively portable way.

The CSV format is flexible but somewhat ill-defined.

For present purposes, authors may assume that the data fields contain no commas, backslashes, or quotation marks.



Task

Read a CSV file, change some values and save the changes back to a file.

For this task we will use the following CSV file:

C1,C2,C3,C4,C5
1,5,9,13,17
2,6,10,14,18
3,7,11,15,19
4,8,12,16,20

Suggestions


 Show how to add a column, headed 'SUM', of the sums of the rows.
 If possible, illustrate the use of built-in or standard functions, methods, or libraries, that handle generic CSV files.


",#Go,Go,"package main
 
import (
	""encoding/csv""
	""log""
	""os""
	""strconv""
)
 
func main() {
	rows := readSample()
	appendSum(rows)
	writeChanges(rows)
}
 
func readSample() [][]string {
	f, err := os.Open(""sample.csv"")
	if err != nil {
		log.Fatal(err)
	}
	rows, err := csv.NewReader(f).ReadAll()
	f.Close()
	if err != nil {
		log.Fatal(err)
	}
	return rows
}
 
func appendSum(rows [][]string) {
	rows[0] = append(rows[0], ""SUM"")
	for i := 1; i < len(rows); i++ {
		rows[i] = append(rows[i], sum(rows[i]))
	}
}
 
func sum(row []string) string {
	sum := 0
	for _, s := range row {
		x, err := strconv.Atoi(s)
		if err != nil {
			return ""NA""
		}
		sum += x
	}
	return strconv.Itoa(sum)
}
 
func writeChanges(rows [][]string) {
	f, err := os.Create(""output.csv"")
	if err != nil {
		log.Fatal(err)
	}
	err = csv.NewWriter(f).WriteAll(rows)
	f.Close()
	if err != nil {
		log.Fatal(err)
	}
}",876,58
64330,http://rosettacode.org/wiki/CRC-32,CRC-32,"

Task

Demonstrate a method of deriving the Cyclic Redundancy Check from within the language.



The result should be in accordance with ISO 3309, ITU-T V.42, Gzip and PNG.

Algorithms are described on Computation of CRC in Wikipedia.
This variant of CRC-32 uses LSB-first order, sets the initial CRC to FFFFFFFF16, and complements the final CRC.

For the purpose of this task, generate a CRC-32 checksum for the ASCII encoded string:

 The quick brown fox jumps over the lazy dog

",#Go,Go,"package main
 
import (
    ""fmt""
    ""hash/crc32""
)
 
func main() {
    s := []byte(""The quick brown fox jumps over the lazy dog"")
    result := crc32.ChecksumIEEE(s)
    fmt.Printf(""%X\n"", result)
}",200,12
64388,http://rosettacode.org/wiki/Cumulative_standard_deviation,Cumulative standard deviation,"Task[edit]
Write a stateful function, class, generator or co-routine that takes a series of floating point numbers, one at a time, and returns the running standard deviation of the series.

The task implementation should use the most natural programming style of those listed for the function in the implementation language; the task must state which is being used.

Do not apply Bessel's correction; the returned standard deviation should always be computed as if the sample seen so far is the entire population.



Test case

Use this to compute the standard deviation of this demonstration set, 



{
2
,
4
,
4
,
4
,
5
,
5
,
7
,
9
}


{\displaystyle \{2,4,4,4,5,5,7,9\}}

, which is 



2


{\displaystyle 2}

.



Related tasks

 Random numbers


Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func newRsdv() func(float64) float64 {
    var n, a, q  float64
    return func(x float64) float64 {
        n++
        a1 := a+(x-a)/n
        q, a = q+(x-a)*(x-a1), a1
        return math.Sqrt(q/n)
    }
}
 
func main() {
    r := newRsdv()
    for _, x := range []float64{2,4,4,4,5,5,7,9} {
        fmt.Println(r(x))
    }
}",377,23
64424,http://rosettacode.org/wiki/Cramer%27s_rule,Cramer's rule,"linear algebra
Cramer's rule
system of linear equations


Given


 




{





a

1


x
+

b

1


y
+

c

1


z


=



d

1









a

2


x
+

b

2


y
+

c

2


z


=



d

2









a

3


x
+

b

3


y
+

c

3


z


=



d

3












{\displaystyle \left\{{\begin{matrix}a_{1}x+b_{1}y+c_{1}z&={\color {red}d_{1}}\\a_{2}x+b_{2}y+c_{2}z&={\color {red}d_{2}}\\a_{3}x+b_{3}y+c_{3}z&={\color {red}d_{3}}\end{matrix}}\right.}




which in matrix format is



 





[




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





]




[



x




y




z



]


=


[






d

1











d

2











d

3







]


.


{\displaystyle {\begin{bmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{bmatrix}}{\begin{bmatrix}x\\y\\z\end{bmatrix}}={\begin{bmatrix}{\color {red}d_{1}}\\{\color {red}d_{2}}\\{\color {red}d_{3}}\end{bmatrix}}.}




Then the values of 



x
,
y


{\displaystyle x,y}

 and 



z


{\displaystyle z}

 can be found as follows:







x
=



|






d

1







b

1





c

1









d

2







b

2





c

2









d

3







b

3





c

3





|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



,

y
=



|




a

1







d

1







c

1







a

2







d

2







c

2







a

3







d

3







c

3





|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



,

 and 

z
=



|




a

1





b

1







d

1









a

2





b

2







d

2









a

3





b

3







d

3







|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



.


{\displaystyle x={\frac {\begin{vmatrix}{\color {red}d_{1}}&b_{1}&c_{1}\\{\color {red}d_{2}}&b_{2}&c_{2}\\{\color {red}d_{3}}&b_{3}&c_{3}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}},\quad y={\frac {\begin{vmatrix}a_{1}&{\color {red}d_{1}}&c_{1}\\a_{2}&{\color {red}d_{2}}&c_{2}\\a_{3}&{\color {red}d_{3}}&c_{3}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}},{\text{ and }}z={\frac {\begin{vmatrix}a_{1}&b_{1}&{\color {red}d_{1}}\\a_{2}&b_{2}&{\color {red}d_{2}}\\a_{3}&b_{3}&{\color {red}d_{3}}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}}.}






Task
Given the following system of equations:









{



2
w
−
x
+
5
y
+
z
=
−
3




3
w
+
2
x
+
2
y
−
6
z
=
−
32




w
+
3
x
+
3
y
−
z
=
−
47




5
w
−
2
x
−
3
y
+
3
z
=
49








{\displaystyle {\begin{cases}2w-x+5y+z=-3\\3w+2x+2y-6z=-32\\w+3x+3y-z=-47\\5w-2x-3y+3z=49\\\end{cases}}}




solve for 



w


{\displaystyle w}

, 



x


{\displaystyle x}

, 



y


{\displaystyle y}

 and 



z


{\displaystyle z}

, using Cramer's rule.



",#Go,Go,"package main
 
import (
    ""fmt""
 
    ""gonum.org/v1/gonum/mat""
)
 
var m = mat.NewDense(4, 4, []float64{
    2, -1, 5, 1,
    3, 2, 2, -6,
    1, 3, 3, -1,
    5, -2, -3, 3,
})
 
var v = []float64{-3, -32, -47, 49}
 
func main() {
    x := make([]float64, len(v))
    b := make([]float64, len(v))
    d := mat.Det(m)
    for c := range v {
        mat.Col(b, c, m)
        m.SetCol(c, v)
        x[c] = mat.Det(m) / d
        m.SetCol(c, b)
    }
    fmt.Println(x)
}",469,29
64624,http://rosettacode.org/wiki/Create_a_two-dimensional_array_at_runtime,Create a two-dimensional array at runtime,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
Get two integers from the user, then create a two-dimensional array where the two dimensions have the sizes given by those numbers, and which can be accessed in the most natural way possible. Write some element of that array, and then output that element. Finally destroy the array if not done by the language itself.
",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    var row, col int
    fmt.Print(""enter rows cols: "")
    fmt.Scan(&row, &col)
 
    // allocate composed 2d array
    a := make([][]int, row)
    for i := range a {
        a[i] = make([]int, col)
    }
 
    // array elements initialized to 0
    fmt.Println(""a[0][0] ="", a[0][0])
 
    // assign
    a[row-1][col-1] = 7
 
    // retrieve
    fmt.Printf(""a[%d][%d] = %d\n"", row-1, col-1, a[row-1][col-1])
 
    // remove only reference
    a = nil
    // memory allocated earlier with make can now be garbage collected.
}",569,28
64684,http://rosettacode.org/wiki/CSV_to_HTML_translation,CSV to HTML translation,"Consider a simplified CSV format where all rows are separated by a newline
and all columns are separated by commas.

No commas are allowed as field data, but the data may contain
other characters and character sequences that would
normally be   escaped   when converted to HTML



Task

Create a function that takes a string representation of the CSV data
and returns a text string of an HTML table representing the CSV data.

Use the following data as the CSV text to convert, and show your output.

 Character,Speech
 The multitude,The messiah! Show us the messiah!
 Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>
 The multitude,Who are you?
 Brians mother,I'm his mother; that's who!
 The multitude,Behold his mother! Behold his mother!


Extra credit

Optionally allow special formatting for the first row of the table as if it is the tables header row
(via <thead> preferably; CSS if you must).



",#Go,Go,"package main
 
import (
    ""bytes""
    ""encoding/csv""
    ""fmt""
    ""html/template""
    ""strings""
)
 
var c = `Character,Speech
The multitude,The messiah! Show us the messiah!
Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>
The multitude,Who are you?
Brians mother,I'm his mother; that's who!
The multitude,Behold his mother! Behold his mother!`
 
func main() {
    if h, err := csvToHtml(c); err != nil {
        fmt.Println(err)
    } else {
        fmt.Print(h)
    }
}
 
func csvToHtml(c string) (string, error) {
    data, err := csv.NewReader(bytes.NewBufferString(c)).ReadAll()
    if err != nil {
        return """", err
    }
    var b strings.Builder
    err = template.Must(template.New("""").Parse(`<table>
{{range .}}    <tr>{{range .}}<td>{{.}}</td>{{end}}</tr>
{{end}}</table>
`)).Execute(&b, data)
    return b.String(), err
}",902,37
64715,http://rosettacode.org/wiki/Count_the_coins,Count the coins,"There are four types of common coins in   US   currency:

   quarters   (25 cents)
   dimes   (10 cents)
   nickels   (5 cents),   and 
   pennies   (1 cent) 


There are six ways to make change for 15 cents:

   A dime and a nickel 
   A dime and 5 pennies
   3 nickels
   2 nickels and 5 pennies
   A nickel and 10 pennies
   15 pennies


Task

How many ways are there to make change for a dollar using these common coins?     (1 dollar = 100 cents).



Optional

Less common are dollar coins (100 cents);   and very rare are half dollars (50 cents).   With the addition of these two coins, how many ways are there to make change for $1000?

(Note:   the answer is larger than   232).



References

 an algorithm from the book Structure and Interpretation of Computer Programs.
 an article in the algorithmist.
 Change-making problem on Wikipedia.

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    amount := 100
    fmt.Println(""amount, ways to make change:"", amount, countChange(amount))
}
 
func countChange(amount int) int64 {
    return cc(amount, 4)
}
 
func cc(amount, kindsOfCoins int) int64 {
    switch {
    case amount == 0:
        return 1
    case amount < 0 || kindsOfCoins == 0:
        return 0
    }
    return cc(amount, kindsOfCoins-1) +
        cc(amount - firstDenomination(kindsOfCoins), kindsOfCoins)
}
 
func firstDenomination(kindsOfCoins int) int {
    switch kindsOfCoins {
    case 1:
        return 1
    case 2:
        return 5
    case 3:
        return 10
    case 4:
        return 25
    }
    panic(kindsOfCoins)
}",701,37
64726,http://rosettacode.org/wiki/Create_a_file,Create a file,"In this task, the job is to create a new empty file called ""output.txt"" of size 0 bytes
and an empty directory called ""docs"". This should be done twice: once ""here"", i.e. in the current working directory and once in the filesystem root.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""os""
)
 
func createFile(fn string) {
    f, err := os.Create(fn)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(""file"", fn, ""created!"")
    f.Close()
}
 
func createDir(dn string) {
    err := os.Mkdir(dn, 0666)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(""directory"", dn, ""created!"")
}
 
func main() {
    createFile(""input.txt"")
    createFile(""/input.txt"")
    createDir(""docs"")
    createDir(""/docs"")
}",518,32
64823,http://rosettacode.org/wiki/Count_occurrences_of_a_substring,Count occurrences of a substring,"Task

Create a function,   or show a built-in function,   to count the number of non-overlapping occurrences of a substring inside a string.

The function should take two arguments:

   the first argument being the string to search,   and 
   the second a substring to be searched for. 


It should return an integer count.

print countSubstring(""the three truths"",""th"")
3
 
// do not count substrings that overlap with previously-counted substrings:
print countSubstring(""ababababab"",""abab"")
2
The matching should yield the highest number of non-overlapping matches.

In general, this essentially means matching from left-to-right or right-to-left   (see proof on talk page).




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
import (
        ""fmt""
        ""strings""
)
 
func main() {
        fmt.Println(strings.Count(""the three truths"", ""th"")) // says: 3
        fmt.Println(strings.Count(""ababababab"", ""abab""))     // says: 2
}",217,10
64846,http://rosettacode.org/wiki/Count_in_octal,Count in octal,"Task

Produce a sequential count in octal,   starting at zero,   and using an increment of a one for each consecutive number.

Each number should appear on a single line,   and the program should count until terminated,   or until the maximum value of the numeric type in use is reached.



Related task

   Integer sequence   is a similar task without the use of octal numbers.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func main() {
    for i := int8(0); ; i++ {
        fmt.Printf(""%o\n"", i)
        if i == math.MaxInt8 {
            break
        }
    }
}",189,15
64873,http://rosettacode.org/wiki/Create_an_HTML_table,Create an HTML table,"Create an HTML table.

 The table body should have at least three rows of three columns.
 Each of these three columns should be labelled ""X"", ""Y"", and ""Z"". 
 An extra column should be added at either the extreme left or the extreme right of the table that has no heading, but is filled with sequential row numbers. 
 The rows of the ""X"", ""Y"", and ""Z"" columns should be filled with random or sequential integers having 4 digits or less. 
 The numbers should be aligned in the same fashion for all columns.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""html/template""
    ""os""
)
 
type row struct {
    X, Y, Z int
}
 
var tmpl = `<table>
    <tr><th></th><th>X</th><th>Y</th><th>Z</th></tr>
{{range $ix, $row := .}}    <tr><td>{{$ix}}</td>
        <td>{{$row.X}}</td>
        <td>{{$row.Y}}</td>
        <td>{{$row.Z}}</td></tr>
{{end}}</table>
`
 
func main() {
    // create template
    ct := template.Must(template.New("""").Parse(tmpl))
 
    // make up data
    data := make([]row, 4)
    for r := range data {
        data[r] = row{r*3, r*3+1, r*3+2}
    }
 
    // apply template to data
    if err := ct.Execute(os.Stdout, data); err != nil {
        fmt.Println(err)
    }
}",669,36
64893,http://rosettacode.org/wiki/Count_in_factors,Count in factors,"Task

Write a program which counts up from   1,   displaying each number as the multiplication of its prime factors.

For the purpose of this task,   1   (unity)   may be shown as itself.



Example

      2   is prime,   so it would be shown as itself.

      6   is not prime;   it would be shown as   



2
×
3


{\displaystyle 2\times 3}

.
2144   is not prime;   it would be shown as   



2
×
2
×
2
×
2
×
2
×
67


{\displaystyle 2\times 2\times 2\times 2\times 2\times 67}

.



Related tasks

   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    fmt.Println(""1: 1"")
    for i := 2; ; i++ {
        fmt.Printf(""%d: "", i)
        var x string
        for n, f := i, 2; n != 1; f++ {
            for m := n % f; m == 0; m = n % f {
                fmt.Print(x, f)
                x = ""×""
                n /= f
            }
        }
        fmt.Println()
    }
}",363,19
65501,http://rosettacode.org/wiki/Copy_stdin_to_stdout,Copy stdin to stdout,"Create an executable file that copies stdin to stdout, or else a script that does so through the invocation of an interpreter at the command line.
",#Go,Go,"package main
 
import (
    ""bufio""
    ""io""
    ""os""
)
 
func main() {
    r := bufio.NewReader(os.Stdin)
    w := bufio.NewWriter(os.Stdout)
    for {
        b, err := r.ReadByte()       
        if err == io.EOF {
            return
        }
        w.WriteByte(b)
        w.Flush()
    }   
}",298,20
65586,http://rosettacode.org/wiki/Continued_fraction/Arithmetic/Construct_from_rational_number,Continued fraction/Arithmetic/Construct from rational number,"Continued fraction arithmetic
The purpose of this task is to write a function 





r
2
c
f


(

i
n
t



{\displaystyle {\mathit {r2cf}}(\mathrm {int} }

 




N

1


,

i
n
t



{\displaystyle N_{1},\mathrm {int} }

 




N

2


)


{\displaystyle N_{2})}

, or 





r
2
c
f


(

F
r
a
c
t
i
o
n



{\displaystyle {\mathit {r2cf}}(\mathrm {Fraction} }

 



N
)


{\displaystyle N)}

, which will output a continued fraction assuming:






N

1




{\displaystyle N_{1}}

 is the numerator





N

2




{\displaystyle N_{2}}

 is the denominator
The function should output its results one digit at a time each time it is called, in a manner sometimes described as lazy evaluation.

To achieve this it must determine: the integer part; and remainder part, of 




N

1




{\displaystyle N_{1}}

 divided by 




N

2




{\displaystyle N_{2}}

. It then sets 




N

1




{\displaystyle N_{1}}

 to 




N

2




{\displaystyle N_{2}}

 and 




N

2




{\displaystyle N_{2}}

 to the determined remainder part. It then outputs the determined integer part. It does this until 




a
b
s

(

N

2


)


{\displaystyle \mathrm {abs} (N_{2})}

 is zero.

Demonstrate the function by outputing the continued fraction for:

 1/2
 3
 23/8
 13/11
 22/7
 -151/77






2




{\displaystyle {\sqrt {2}}}

 should approach 



[
1
;
2
,
2
,
2
,
2
,
…
]


{\displaystyle [1;2,2,2,2,\ldots ]}

 try ever closer rational approximations until boredom gets the better of you:

 14142,10000
 141421,100000
 1414214,1000000
 14142136,10000000
Try :

 31,10
 314,100
 3142,1000
 31428,10000
 314285,100000
 3142857,1000000
 31428571,10000000
 314285714,100000000
Observe how this rational number behaves differently to 





2




{\displaystyle {\sqrt {2}}}

 and convince yourself that, in the same way as 



3.7


{\displaystyle 3.7}

 may be represented as 



3.70


{\displaystyle 3.70}

 when an extra decimal place is required, 



[
3
;
7
]


{\displaystyle [3;7]}

 may be represented as 



[
3
;
7
,
∞
]


{\displaystyle [3;7,\infty ]}

 when an extra term is required.
",#Go,Go,"package cf
 
import (
	""fmt""
	""strings""
)
 
// ContinuedFraction is a regular continued fraction.
type ContinuedFraction func() NextFn
 
// NextFn is a function/closure that can return
// a posibly infinite sequence of values.
type NextFn func() (term int64, ok bool)
 
// String implements fmt.Stringer.
// It formats a maximum of 20 values, ending the
// sequence with "", ..."" if the sequence is longer.
func (cf ContinuedFraction) String() string {
	var buf strings.Builder
	buf.WriteByte('[')
	sep := ""; ""
	const maxTerms = 20
	next := cf()
	for n := 0; ; n++ {
		t, ok := next()
		if !ok {
			break
		}
		if n > 0 {
			buf.WriteString(sep)
			sep = "", ""
		}
		if n >= maxTerms {
			buf.WriteString(""..."")
			break
		}
		fmt.Fprint(&buf, t)
	}
	buf.WriteByte(']')
	return buf.String()
}
 
// Sqrt2 is the continued fraction for √2, [1; 2, 2, 2, ...].
func Sqrt2() NextFn {
	first := true
	return func() (int64, bool) {
		if first {
			first = false
			return 1, true
		}
		return 2, true
	}
}
 
// Phi is the continued fraction for ϕ, [1; 1, 1, 1, ...].
func Phi() NextFn {
	return func() (int64, bool) { return 1, true }
}
 
// E is the continued fraction for e,
// [2; 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, 1, 1, 10, 1, 1, 12, ...].
func E() NextFn {
	var i int
	return func() (int64, bool) {
		i++
		switch {
		case i == 1:
			return 2, true
		case i%3 == 0:
			return int64(i/3) * 2, true
		default:
			return 1, true
		}
	}
}",1429,75
65597,http://rosettacode.org/wiki/Convert_decimal_number_to_rational,Convert decimal number to rational,"This task has been flagged for clarification. Code on this page in its current state may be flagged incorrect once this task has been clarified. See this page's Talk page for discussion.


The task is to write a program to transform a decimal number into a fraction in lowest terms.

It is not always possible to do this exactly. For instance, while rational numbers can be converted to decimal representation, some of them need an infinite number of digits to be represented exactly in decimal form. Namely, repeating decimals such as 1/3 = 0.333...

Because of this, the following fractions cannot be obtained (reliably) unless the language has some way of representing repeating decimals:

 67 / 74 = 0.9(054) = 0.9054054...
 14 / 27 = 0.(518) = 0.518518...

Acceptable output:

 0.9054054 → 4527027 / 5000000
 0.518518 → 259259 / 500000

Finite decimals are of course no problem:

 0.75 → 3 / 4 

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    for _, d := range []string{""0.9054054"", ""0.518518"", ""0.75""} {
        if r, ok := new(big.Rat).SetString(d); ok {
            fmt.Println(d, ""="", r)
        } else {
            fmt.Println(d, ""invalid decimal number"")
        }
    }
}",307,16
65736,http://rosettacode.org/wiki/Constrained_genericity,Constrained genericity,"Constrained genericity or bounded quantification means
that a parametrized type or function (see parametric polymorphism)
can only be instantiated on types fulfilling some conditions,
even if those conditions are not used in that function.

Say a type is called ""eatable"" if you can call the function eat on it.
Write a generic type FoodBox which contains a collection of objects of
a type given as parameter, but can only be instantiated on eatable types.
The FoodBox shall not use the function eat in any way (i.e. without the explicit restriction, it could be instantiated on any type).
The specification of a type being eatable should be as generic as possible
in your language (i.e. the restrictions on the implementation of eatable types
should be as minimal as possible).
Also explain the restrictions, if any, on the implementation of eatable types,
and show at least one example of an eatable type.
",#Go,Go,"type eatable interface {
    eat()
}",36,3
65749,http://rosettacode.org/wiki/Consecutive_primes_with_ascending_or_descending_differences,Consecutive primes with ascending or descending differences,"Task




Find and display here on this page, the longest sequence of consecutive prime numbers where the differences between the primes are strictly ascending.


Do the same for sequences of primes where the differences are strictly descending.



In both cases, show the sequence for primes   <   1,000,000.



If there are multiple sequences of the same length, only the first need be shown.


",#Go,Go,"package main
 
import (
    ""fmt""
    ""rcu""
)
 
const LIMIT = 999999
 
var primes = rcu.Primes(LIMIT)
 
func longestSeq(dir string) {
    pd := 0
    longSeqs := [][]int{{2}}
    currSeq := []int{2}
    for i := 1; i < len(primes); i++ {
        d := primes[i] - primes[i-1]
        if (dir == ""ascending"" && d <= pd) || (dir == ""descending"" && d >= pd) {
            if len(currSeq) > len(longSeqs[0]) {
                longSeqs = [][]int{currSeq}
            } else if len(currSeq) == len(longSeqs[0]) {
                longSeqs = append(longSeqs, currSeq)
            }
            currSeq = []int{primes[i-1], primes[i]}
        } else {
            currSeq = append(currSeq, primes[i])
        }
        pd = d
    }
    if len(currSeq) > len(longSeqs[0]) {
        longSeqs = [][]int{currSeq}
    } else if len(currSeq) == len(longSeqs[0]) {
        longSeqs = append(longSeqs, currSeq)
    }
    fmt.Println(""Longest run(s) of primes with"", dir, ""differences is"", len(longSeqs[0]), "":"")
    for _, ls := range longSeqs {
        var diffs []int
        for i := 1; i < len(ls); i++ {
            diffs = append(diffs, ls[i]-ls[i-1])
        }
        for i := 0; i < len(ls)-1; i++ {
            fmt.Print(ls[i], "" ("", diffs[i], "") "")
        }
        fmt.Println(ls[len(ls)-1])
    }
    fmt.Println()
}
 
func main() {
    fmt.Println(""For primes < 1 million:\n"")
    for _, dir := range []string{""ascending"", ""descending""} {
        longestSeq(dir)
    }
}",1467,54
65823,http://rosettacode.org/wiki/Copy_a_string,Copy a string,"This task is about copying a string.



Task

Where it is relevant, distinguish between copying the contents of a string
versus making an additional reference to an existing string.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"src := ""Hello""
dst := src",25,2
65868,http://rosettacode.org/wiki/Composite_numbers_k_with_no_single_digit_factors_whose_factors_are_all_substrings_of_k,Composite numbers k with no single digit factors whose factors are all substrings of k,"Find the composite numbers k in base 10, that have no single digit prime factors and whose prime factors are all a substring of k.



Task
 Find and show here, on this page, the first ten elements of the sequence.


Stretch
 Find and show the next ten elements.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""rcu""
    ""strconv""
    ""strings""
)
 
func main() {
    count := 0
    k := 11 * 11
    var res []int
    for count < 20 {
        if k%3 == 0 || k%5 == 0 || k%7 == 0 {
            k += 2
            continue
        }
        factors := rcu.PrimeFactors(k)
        if len(factors) > 1 {
            s := strconv.Itoa(k)
            includesAll := true
            prev := -1
            for _, f := range factors {
                if f == prev {
                    continue
                }
                fs := strconv.Itoa(f)
                if strings.Index(s, fs) == -1 {
                    includesAll = false
                    break
                }
            }
            if includesAll {
                res = append(res, k)
                count++
            }
        }
        k += 2
    }
    for _, e := range res[0:10] {
        fmt.Printf(""%10s "", rcu.Commatize(e))
    }
    fmt.Println()
    for _, e := range res[10:20] {
        fmt.Printf(""%10s "", rcu.Commatize(e))
    }
    fmt.Println()
}",1061,49
65891,http://rosettacode.org/wiki/Convex_hull,Convex hull,"Find the points which form a convex hull from a set of arbitrary two dimensional points.

For example, given the points (16,3), (12,17), (0,6), (-4,-6), (16,6), (16,-7), (16,-3), (17,-4), (5,19), (19,-8), (3,16), (12,13), (3,-4), (17,5), (-3,15), (-3,-9), (0,11), (-9,-3), (-4,-2) and (12,10) the convex hull would be (-9,-3), (-3,-9), (19,-8), (17,5), (12,17), (5,19) and (-3,15).




See also
 Convex Hull (youtube)
 http://www.geeksforgeeks.org/convex-hull-set-2-graham-scan/

",#Go,Go,"package main
 
import (
	""fmt""
	""image""
	""sort""
)
 
 
// ConvexHull returns the set of points that define the
// convex hull of p in CCW order starting from the left most.
func (p points) ConvexHull() points {
	// From https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain
	// with only minor deviations.
	sort.Sort(p)
	var h points
 
	// Lower hull
	for _, pt := range p {
		for len(h) >= 2 && !ccw(h[len(h)-2], h[len(h)-1], pt) {
			h = h[:len(h)-1]
		}
		h = append(h, pt)
	}
 
	// Upper hull
	for i, t := len(p)-2, len(h)+1; i >= 0; i-- {
		pt := p[i]
		for len(h) >= t && !ccw(h[len(h)-2], h[len(h)-1], pt) {
			h = h[:len(h)-1]
		}
		h = append(h, pt)
	}
 
	return h[:len(h)-1]
}
 
// ccw returns true if the three points make a counter-clockwise turn
func ccw(a, b, c image.Point) bool {
	return ((b.X - a.X) * (c.Y - a.Y)) > ((b.Y - a.Y) * (c.X - a.X))
}
 
type points []image.Point
 
func (p points) Len() int      { return len(p) }
func (p points) Swap(i, j int) { p[i], p[j] = p[j], p[i] }
func (p points) Less(i, j int) bool {
	if p[i].X == p[j].X {
		return p[i].Y < p[i].Y
	}
	return p[i].X < p[j].X
}
 
func main() {
	pts := points{
		{16, 3}, {12, 17}, {0, 6}, {-4, -6}, {16, 6},
		{16, -7}, {16, -3}, {17, -4}, {5, 19}, {19, -8},
		{3, 16}, {12, 13}, {3, -4}, {17, 5}, {-3, 15},
		{-3, -9}, {0, 11}, {-9, -3}, {-4, -2}, {12, 10},
	}
	hull := pts.ConvexHull()
	fmt.Println(""Convex Hull:"", hull)
}",1449,63
65892,http://rosettacode.org/wiki/Convert_seconds_to_compound_duration,Convert seconds to compound duration,"Task

Write a function or program which:

   takes a positive integer representing a duration in seconds as input (e.g., 100), and
   returns a string which shows the same duration decomposed into:
   weeks,
   days, 
   hours, 
   minutes,   and 
   seconds.
This is detailed below (e.g., ""2 hr, 59 sec"").



Demonstrate that it passes the following three test-cases:

Test Cases


 input number

 output string


 7259

 2 hr, 59 sec


 86400

 1 d


 6000000

 9 wk, 6 d, 10 hr, 40 min

Details
The following five units should be used:



 unit

 suffix used in output

 conversion


 week

 wk

 1 week = 7 days


 day

 d

 1 day = 24 hours


 hour

 hr

 1 hour = 60 minutes


 minute

 min

 1 minute = 60 seconds


 second

 sec



However, only include quantities with non-zero values in the output (e.g., return ""1 d"" and not ""0 wk, 1 d, 0 hr, 0 min, 0 sec"").

Give larger units precedence over smaller ones as much as possible (e.g., return 2 min, 10 sec and not 1 min, 70 sec or 130 sec)

Mimic the formatting shown in the test-cases (quantities sorted from largest unit to smallest and separated by comma+space; value and unit of each quantity separated by space).



",#Go,Go,"package main
 
import ""fmt""
 
func main(){
	fmt.Println(TimeStr(7259))
	fmt.Println(TimeStr(86400))
	fmt.Println(TimeStr(6000000))
}
 
func TimeStr(sec int)(res string){
	wks, sec := sec / 604800,sec % 604800
	ds, sec := sec / 86400, sec % 86400
	hrs, sec := sec / 3600, sec % 3600
	mins, sec := sec / 60, sec % 60
	CommaRequired := false
	if wks != 0 {
		res += fmt.Sprintf(""%d wk"",wks)
		CommaRequired = true
	}
	if ds != 0 {
		if CommaRequired {
			res += "", ""
		}
		res += fmt.Sprintf(""%d d"",ds)
		CommaRequired = true
	}
	if hrs != 0 {
		if CommaRequired {
			res += "", ""
		}
		res += fmt.Sprintf(""%d hr"",hrs)
		CommaRequired = true
	}
	if mins != 0 {
		if CommaRequired {
			res += "", ""
		}
		res += fmt.Sprintf(""%d min"",mins)
		CommaRequired = true
	}
	if sec != 0 {
		if CommaRequired {
			res += "", ""
		}
		res += fmt.Sprintf(""%d sec"",sec)
	}
	return
}
 ",863,50
65895,http://rosettacode.org/wiki/Continued_fraction,Continued fraction,"continued fraction
Mathworld





a

0


+









b

1












a

1


+









b

2












a

2


+









b

3












a

3


+
⋱

















{\displaystyle a_{0}+{\cfrac {b_{1}}{a_{1}+{\cfrac {b_{2}}{a_{2}+{\cfrac {b_{3}}{a_{3}+\ddots }}}}}}}


The task is to write a program which generates such a number and prints a real representation of it. The code should be tested by calculating and printing the square root of 2, Napier's Constant, and Pi, using the following coefficients:

For the square root of 2, use 




a

0


=
1


{\displaystyle a_{0}=1}

 then 




a

N


=
2


{\displaystyle a_{N}=2}

. 




b

N




{\displaystyle b_{N}}

 is always 



1


{\displaystyle 1}

.







2


=
1
+








1









2
+








1









2
+








1









2
+
⋱

















{\displaystyle {\sqrt {2}}=1+{\cfrac {1}{2+{\cfrac {1}{2+{\cfrac {1}{2+\ddots }}}}}}}


For Napier's Constant, use 




a

0


=
2


{\displaystyle a_{0}=2}

, then 




a

N


=
N


{\displaystyle a_{N}=N}

. 




b

1


=
1


{\displaystyle b_{1}=1}

 then 




b

N


=
N
−
1


{\displaystyle b_{N}=N-1}

.





e
=
2
+








1









1
+








1









2
+








2









3
+








3









4
+
⋱






















{\displaystyle e=2+{\cfrac {1}{1+{\cfrac {1}{2+{\cfrac {2}{3+{\cfrac {3}{4+\ddots }}}}}}}}}


For Pi, use 




a

0


=
3


{\displaystyle a_{0}=3}

 then 




a

N


=
6


{\displaystyle a_{N}=6}

. 




b

N


=
(
2
N
−
1

)

2




{\displaystyle b_{N}=(2N-1)^{2}}

.





π
=
3
+








1









6
+








9









6
+








25









6
+
⋱

















{\displaystyle \pi =3+{\cfrac {1}{6+{\cfrac {9}{6+{\cfrac {25}{6+\ddots }}}}}}}




See also

   Continued fraction/Arithmetic for tasks that do arithmetic over continued fractions.

",#Go,Go,"package main
 
import ""fmt""
 
type cfTerm struct {
    a, b int
}
 
// follows subscript convention of mathworld and WP where there is no b(0).
// cf[0].b is unused in this representation.
type cf []cfTerm
 
func cfSqrt2(nTerms int) cf {
    f := make(cf, nTerms)
    for n := range f {
        f[n] = cfTerm{2, 1}
    }
    f[0].a = 1
    return f
}
 
func cfNap(nTerms int) cf {
    f := make(cf, nTerms)
    for n := range f {
        f[n] = cfTerm{n, n - 1}
    }
    f[0].a = 2
    f[1].b = 1
    return f
}
 
func cfPi(nTerms int) cf {
    f := make(cf, nTerms)
    for n := range f {
        g := 2*n - 1
        f[n] = cfTerm{6, g * g}
    }
    f[0].a = 3
    return f
}
 
func (f cf) real() (r float64) {
    for n := len(f) - 1; n > 0; n-- {
        r = float64(f[n].b) / (float64(f[n].a) + r)
    }
    return r + float64(f[0].a)
}
 
func main() {
    fmt.Println(""sqrt2:"", cfSqrt2(20).real())
    fmt.Println(""nap:  "", cfNap(20).real())
    fmt.Println(""pi:   "", cfPi(20).real())
}",994,53
66004,http://rosettacode.org/wiki/Conjugate_transpose,Conjugate transpose,"Suppose that a matrix 



M


{\displaystyle M}

 contains complex numbers. Then the conjugate transpose of 



M


{\displaystyle M}

 is a matrix 




M

H




{\displaystyle M^{H}}

 containing the complex conjugates of the matrix transposition of 



M


{\displaystyle M}

.

 



(

M

H



)

j
i


=



M

i
j


¯




{\displaystyle (M^{H})_{ji}={\overline {M_{ij}}}}




This means that row 



j


{\displaystyle j}

, column 



i


{\displaystyle i}

 of the conjugate transpose equals the

complex conjugate of row 



i


{\displaystyle i}

, column 



j


{\displaystyle j}

 of the original matrix.



In the next list, 



M


{\displaystyle M}

 must also be a square matrix.

 A Hermitian matrix equals its own conjugate transpose: 




M

H


=
M


{\displaystyle M^{H}=M}

.
 A normal matrix is commutative in multiplication with its conjugate transpose: 




M

H


M
=
M

M

H




{\displaystyle M^{H}M=MM^{H}}

.
 A unitary matrix has its inverse equal to its conjugate transpose: 




M

H


=

M

−
1




{\displaystyle M^{H}=M^{-1}}

. 
 This is true iff 




M

H


M
=

I

n




{\displaystyle M^{H}M=I_{n}}

 and iff 



M

M

H


=

I

n




{\displaystyle MM^{H}=I_{n}}

, where 




I

n




{\displaystyle I_{n}}

 is the identity matrix.


Task

Given some matrix of complex numbers, find its conjugate transpose.

Also determine if the matrix is a:

 Hermitian matrix,
 normal matrix, or 
 unitary matrix.


See also

 MathWorld entry: conjugate transpose
 MathWorld entry: Hermitian matrix
 MathWorld entry: normal matrix
 MathWorld entry: unitary matrix

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/cmplx""
)
 
// a type to represent matrices
type matrix struct {
    ele  []complex128
    cols int
}
 
// conjugate transpose, implemented here as a method on the matrix type.
func (m *matrix) conjTranspose() *matrix {
    r := &matrix{make([]complex128, len(m.ele)), len(m.ele) / m.cols}
    rx := 0
    for _, e := range m.ele {
        r.ele[rx] = cmplx.Conj(e)
        rx += r.cols
        if rx >= len(r.ele) {
            rx -= len(r.ele) - 1
        }
    }
    return r
}
 
// program to demonstrate capabilites on example matricies
func main() {
    show(""h"", matrixFromRows([][]complex128{
        {3, 2 + 1i},
        {2 - 1i, 1}}))
 
    show(""n"", matrixFromRows([][]complex128{
        {1, 1, 0},
        {0, 1, 1},
        {1, 0, 1}}))
 
    show(""u"", matrixFromRows([][]complex128{
        {math.Sqrt2 / 2, math.Sqrt2 / 2, 0},
        {math.Sqrt2 / -2i, math.Sqrt2 / 2i, 0},
        {0, 0, 1i}}))
}
 
func show(name string, m *matrix) {
    m.print(name)
    ct := m.conjTranspose()
    ct.print(name + ""_ct"")
 
    fmt.Println(""Hermitian:"", m.equal(ct, 1e-14))
 
    mct := m.mult(ct)
    ctm := ct.mult(m)
    fmt.Println(""Normal:"", mct.equal(ctm, 1e-14))
 
    i := eye(m.cols)
    fmt.Println(""Unitary:"", mct.equal(i, 1e-14) && ctm.equal(i, 1e-14))
}
 
// two constructors
func matrixFromRows(rows [][]complex128) *matrix {
    m := &matrix{make([]complex128, len(rows)*len(rows[0])), len(rows[0])}
    for rx, row := range rows {
        copy(m.ele[rx*m.cols:(rx+1)*m.cols], row)
    }
    return m
}
 
func eye(n int) *matrix {
    r := &matrix{make([]complex128, n*n), n}
    n++
    for x := 0; x < len(r.ele); x += n {
        r.ele[x] = 1
    }
    return r
}
 
// print method outputs matrix to stdout
func (m *matrix) print(heading string) {
    fmt.Print(""\n"", heading, ""\n"")
    for e := 0; e < len(m.ele); e += m.cols {
        fmt.Printf(""%6.3f "", m.ele[e:e+m.cols])
        fmt.Println()
    }
}
 
// equal method uses ε to allow for floating point error.
func (a *matrix) equal(b *matrix, ε float64) bool {
    for x, aEle := range a.ele {
        if math.Abs(real(aEle)-real(b.ele[x])) > math.Abs(real(aEle))*ε ||
            math.Abs(imag(aEle)-imag(b.ele[x])) > math.Abs(imag(aEle))*ε {
            return false
        }
    }
    return true
}
 
// mult method taken from matrix multiply task
func (m1 *matrix) mult(m2 *matrix) (m3 *matrix) {
    m3 = &matrix{make([]complex128, (len(m1.ele)/m1.cols)*m2.cols), m2.cols}
    for m1c0, m3x := 0, 0; m1c0 < len(m1.ele); m1c0 += m1.cols {
        for m2r0 := 0; m2r0 < m2.cols; m2r0++ {
            for m1x, m2x := m1c0, m2r0; m2x < len(m2.ele); m2x += m2.cols {
                m3.ele[m3x] += m1.ele[m1x] * m2.ele[m2x]
                m1x++
            }
            m3x++
        }
    }
    return m3
}",2844,112
66011,http://rosettacode.org/wiki/Constrained_random_points_on_a_circle,Constrained random points on a circle,"Task

Generate 100 <x,y> coordinate pairs such that x and y are integers sampled from the uniform distribution with the condition that 




10
≤



x

2


+

y

2




≤
15


{\displaystyle 10\leq {\sqrt {x^{2}+y^{2}}}\leq 15}

. 
Then display/plot them. The outcome should be a ""fuzzy"" circle. The actual number of points plotted may be less than 100, given that some pairs may be generated more than once.

There are several possible approaches to accomplish this. Here are two possible algorithms.

1) Generate random pairs of integers and filter out those that don't satisfy this condition:





10
≤



x

2


+

y

2




≤
15


{\displaystyle 10\leq {\sqrt {x^{2}+y^{2}}}\leq 15}

.
2) Precalculate the set of all possible points (there are 404 of them) and select randomly from this set.



",#Go,Go,"package main
 
import (
    ""bytes""
    ""fmt""
    ""math/rand""
    ""time""
)
 
const (
    nPts = 100
    rMin = 10
    rMax = 15
)
 
func main() {
    rand.Seed(time.Now().Unix())
    span := rMax + 1 + rMax
    rows := make([][]byte, span)
    for r := range rows {
        rows[r] = bytes.Repeat([]byte{' '}, span*2)
    }
    u := 0 // count unique points
    min2 := rMin * rMin
    max2 := rMax * rMax
    for n := 0; n < nPts; {
        x := rand.Intn(span) - rMax
        y := rand.Intn(span) - rMax
        // x, y is the generated coordinate pair
        rs := x*x + y*y
        if rs < min2 || rs > max2 {
            continue
        }
        n++ // count pair as meeting condition
        r := y + rMax
        c := (x + rMax) * 2
        if rows[r][c] == ' ' {
            rows[r][c] = '*'
            u++
        }
    }
    for _, row := range rows {
        fmt.Println(string(row))
    }
    fmt.Println(u, ""unique points"")
}",942,46
66122,http://rosettacode.org/wiki/Concurrent_computing,Concurrent computing,"Task

Using either native language concurrency syntax or freely available libraries, write a program to display the strings ""Enjoy"" ""Rosetta"" ""Code"", one string per line, in random order.

Concurrency syntax must use threads, tasks, co-routines, or whatever concurrency is called in your language.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""golang.org/x/exp/rand""
    ""time""
)
 
func main() {
    words := []string{""Enjoy"", ""Rosetta"", ""Code""}
    seed := uint64(time.Now().UnixNano())
    q := make(chan string)
    for i, w := range words {
        go func(w string, seed uint64) {
            r := rand.New(rand.NewSource(seed))
            time.Sleep(time.Duration(r.Int63n(1e9)))
            q <- w
        }(w, seed+uint64(i))
    }
    for i := 0; i < len(words); i++ {
        fmt.Println(<-q)
    }
}",506,23
66224,http://rosettacode.org/wiki/Compound_data_type,Compound data type,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.


Task

Create a compound data type:

  Point(x,y) 



A compound data type is one that holds multiple independent values.



Related task

   Enumeration


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#Go,Go,"type point struct {
    x, y float64
}
 ",40,4
66248,http://rosettacode.org/wiki/Compile-time_calculation,Compile-time calculation,"Some programming languages allow calculation of values at compile time.



Task

Calculate    10!    (ten factorial)   at compile time.

Print the result when the program is run.

Discuss what limitations apply to compile-time calculations in your language.



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    fmt.Println(2*3*4*5*6*7*8*9*10)
}",81,7
66438,http://rosettacode.org/wiki/Compiler/AST_interpreter,Compiler/AST interpreter,"An AST interpreter interprets an Abstract Syntax Tree (AST)
produced by a Syntax Analyzer.

Task[edit]
Take the AST output from the Syntax analyzer task, and interpret it as appropriate.
Refer to the Syntax analyzer task for details of the AST.

Loading the AST from the syntax analyzer is as simple as (pseudo code)

def load_ast()
    line = readline()
    # Each line has at least one token
    line_list = tokenize the line, respecting double quotes
 
    text = line_list[0] # first token is always the node type
 
    if text == "";""   # a terminal node
        return NULL
 
    node_type = text # could convert to internal form if desired
 
    # A line with two tokens is a leaf node
    # Leaf nodes are: Identifier, Integer, String
    # The 2nd token is the value
    if len(line_list) > 1
        return make_leaf(node_type, line_list[1])
 
    left = load_ast()
    right = load_ast()
    return make_node(node_type, left, right)
 The interpreter algorithm is relatively simple

interp(x)
    if x == NULL return NULL
    elif x.node_type == Integer return x.value converted to an integer
    elif x.node_type == Ident   return the current value of variable x.value
    elif x.node_type == String  return x.value
    elif x.node_type == Assign
                    globals[x.left.value] = interp(x.right)
                    return NULL
    elif x.node_type is a binary operator return interp(x.left) operator interp(x.right)
    elif x.node_type is a unary operator, return return operator interp(x.left)
    elif x.node_type ==  If
                    if (interp(x.left)) then interp(x.right.left)
                    else interp(x.right.right)
                    return NULL
    elif x.node_type == While
                    while (interp(x.left)) do interp(x.right)
                    return NULL
    elif x.node_type == Prtc
                    print interp(x.left) as a character, no newline
                    return NULL
    elif x.node_type == Prti
                    print interp(x.left) as an integer, no newline
                    return NULL
    elif x.node_type == Prts
                    print interp(x.left) as a string, respecting newlines (""\n"")
                    return NULL
    elif x.node_type == Sequence
                    interp(x.left)
                    interp(x.right)
                    return NULL
    else
        error(""unknown node type"")
Notes:

Because of the simple nature of our tiny language, Semantic analysis is not needed.

Your interpreter should use C like division semantics, for both division and modulus. For division of positive operands, only the non-fractional portion of the result should be returned. In other words, the result should be truncated towards 0.

This means, for instance, that 3 / 2 should result in 1.

For division when one of the operands is negative, the result should be truncated towards 0.

This means, for instance, that 3 / -2 should result in -1.

 Test program


 prime.t

 lex <prime.t | parse | interp



/*
 Simple prime number generator
 */
count = 1;
n = 1;
limit = 100;
while (n < limit) {
    k=3;
    p=1;
    n=n+2;
    while ((k*k<=n) && (p)) {
        p=n/k*k!=n;
        k=k+2;
    }
    if (p) {
        print(n, "" is prime\n"");
        count = count + 1;
    }
}
print(""Total primes found: "", count, ""\n""); 


3 is prime
5 is prime
7 is prime
11 is prime
13 is prime
17 is prime
19 is prime
23 is prime
29 is prime
31 is prime
37 is prime
41 is prime
43 is prime
47 is prime
53 is prime
59 is prime
61 is prime
67 is prime
71 is prime
73 is prime
79 is prime
83 is prime
89 is prime
97 is prime
101 is prime
Total primes found: 26


 Additional examples
Your solution should pass all the test cases above and the additional tests found Here.

Reference
The C and Python versions can be considered reference implementations.

Related Tasks
 Lexical Analyzer task
 Syntax Analyzer task
 Code Generator task
 Virtual Machine Interpreter task
",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""log""
    ""os""
    ""strconv""
    ""strings""
)
 
type NodeType int
 
const (
    ndIdent NodeType = iota
    ndString
    ndInteger
    ndSequence
    ndIf
    ndPrtc
    ndPrts
    ndPrti
    ndWhile
    ndAssign
    ndNegate
    ndNot
    ndMul
    ndDiv
    ndMod
    ndAdd
    ndSub
    ndLss
    ndLeq
    ndGtr
    ndGeq
    ndEql
    ndNeq
    ndAnd
    ndOr
)
 
type Tree struct {
    nodeType NodeType
    left     *Tree
    right    *Tree
    value    int
}
 
// dependency: Ordered by NodeType, must remain in same order as NodeType enum
type atr struct {
    enumText string
    nodeType NodeType
}
 
var atrs = []atr{
    {""Identifier"", ndIdent},
    {""String"", ndString},
    {""Integer"", ndInteger},
    {""Sequence"", ndSequence},
    {""If"", ndIf},
    {""Prtc"", ndPrtc},
    {""Prts"", ndPrts},
    {""Prti"", ndPrti},
    {""While"", ndWhile},
    {""Assign"", ndAssign},
    {""Negate"", ndNegate},
    {""Not"", ndNot},
    {""Multiply"", ndMul},
    {""Divide"", ndDiv},
    {""Mod"", ndMod},
    {""Add"", ndAdd},
    {""Subtract"", ndSub},
    {""Less"", ndLss},
    {""LessEqual"", ndLeq},
    {""Greater"", ndGtr},
    {""GreaterEqual"", ndGeq},
    {""Equal"", ndEql},
    {""NotEqual"", ndNeq},
    {""And"", ndAnd},
    {""Or"", ndOr},
}
 
var (
    stringPool   []string
    globalNames  []string
    globalValues = make(map[int]int)
)
 
var (
    err     error
    scanner *bufio.Scanner
)
 
func reportError(msg string) {
    log.Fatalf(""error : %s\n"", msg)
}
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func btoi(b bool) int {
    if b {
        return 1
    }
    return 0
}
 
func itob(i int) bool {
    if i == 0 {
        return false
    }
    return true
}
 
func makeNode(nodeType NodeType, left *Tree, right *Tree) *Tree {
    return &Tree{nodeType, left, right, 0}
}
 
func makeLeaf(nodeType NodeType, value int) *Tree {
    return &Tree{nodeType, nil, nil, value}
}
 
func interp(x *Tree) int { // interpret the parse tree
    if x == nil {
        return 0
    }
    switch x.nodeType {
    case ndInteger:
        return x.value
    case ndIdent:
        return globalValues[x.value]
    case ndString:
        return x.value
    case ndAssign:
        n := interp(x.right)
        globalValues[x.left.value] = n
        return n
    case ndAdd:
        return interp(x.left) + interp(x.right)
    case ndSub:
        return interp(x.left) - interp(x.right)
    case ndMul:
        return interp(x.left) * interp(x.right)
    case ndDiv:
        return interp(x.left) / interp(x.right)
    case ndMod:
        return interp(x.left) % interp(x.right)
    case ndLss:
        return btoi(interp(x.left) < interp(x.right))
    case ndGtr:
        return btoi(interp(x.left) > interp(x.right))
    case ndLeq:
        return btoi(interp(x.left) <= interp(x.right))
    case ndEql:
        return btoi(interp(x.left) == interp(x.right))
    case ndNeq:
        return btoi(interp(x.left) != interp(x.right))
    case ndAnd:
        return btoi(itob(interp(x.left)) && itob(interp(x.right)))
    case ndOr:
        return btoi(itob(interp(x.left)) || itob(interp(x.right)))
    case ndNegate:
        return -interp(x.left)
    case ndNot:
        if interp(x.left) == 0 {
            return 1
        }
        return 0
    case ndIf:
        if interp(x.left) != 0 {
            interp(x.right.left)
        } else {
            interp(x.right.right)
        }
        return 0
    case ndWhile:
        for interp(x.left) != 0 {
            interp(x.right)
        }
        return 0
    case ndPrtc:
        fmt.Printf(""%c"", interp(x.left))
        return 0
    case ndPrti:
        fmt.Printf(""%d"", interp(x.left))
        return 0
    case ndPrts:
        fmt.Print(stringPool[interp(x.left)])
        return 0
    case ndSequence:
        interp(x.left)
        interp(x.right)
        return 0
    default:
        reportError(fmt.Sprintf(""interp: unknown tree type %d\n"", x.nodeType))
    }
    return 0
}
 
func getEnumValue(name string) NodeType {
    for _, atr := range atrs {
        if atr.enumText == name {
            return atr.nodeType
        }
    }
    reportError(fmt.Sprintf(""Unknown token %s\n"", name))
    return -1
}
 
func fetchStringOffset(s string) int {
    var d strings.Builder
    s = s[1 : len(s)-1]
    for i := 0; i < len(s); i++ {
        if s[i] == '\\' && (i+1) < len(s) {
            if s[i+1] == 'n' {
                d.WriteByte('\n')
                i++
            } else if s[i+1] == '\\' {
                d.WriteByte('\\')
                i++
            }
        } else {
            d.WriteByte(s[i])
        }
    }
    s = d.String()
    for i := 0; i < len(stringPool); i++ {
        if s == stringPool[i] {
            return i
        }
    }
    stringPool = append(stringPool, s)
    return len(stringPool) - 1
}
 
func fetchVarOffset(name string) int {
    for i := 0; i < len(globalNames); i++ {
        if globalNames[i] == name {
            return i
        }
    }
    globalNames = append(globalNames, name)
    return len(globalNames) - 1
}
 
func loadAst() *Tree {
    var nodeType NodeType
    var s string
    if scanner.Scan() {
        line := strings.TrimRight(scanner.Text(), "" \t"")
        tokens := strings.Fields(line)
        first := tokens[0]
        if first[0] == ';' {
            return nil
        }
        nodeType = getEnumValue(first)
        le := len(tokens)
        if le == 2 {
            s = tokens[1]
        } else if le > 2 {
            idx := strings.Index(line, `""`)
            s = line[idx:]
        }
    }
    check(scanner.Err())
    if s != """" {
        var n int
        switch nodeType {
        case ndIdent:
            n = fetchVarOffset(s)
        case ndInteger:
            n, err = strconv.Atoi(s)
            check(err)
        case ndString:
            n = fetchStringOffset(s)
        default:
            reportError(fmt.Sprintf(""Unknown node type: %s\n"", s))
        }
        return makeLeaf(nodeType, n)
    }    
    left := loadAst()
    right := loadAst()
    return makeNode(nodeType, left, right)
}
 
func main() {
    ast, err := os.Open(""ast.txt"")
    check(err)
    defer ast.Close()
    scanner = bufio.NewScanner(ast)
    x := loadAst()
    interp(x)
}",6265,296
66498,http://rosettacode.org/wiki/Compiler/syntax_analyzer,Compiler/syntax analyzer,"A Syntax analyzer transforms a token stream (from the Lexical analyzer)
into a Syntax tree, based on a grammar.

Task[edit]
Take the output from the Lexical analyzer task,
and convert it to an Abstract Syntax Tree (AST),
based on the grammar below. The output should be in a flattened format.

The program should read input from a file and/or stdin, and write output to a file and/or
stdout. If the language being used has a parser module/library/class, it would be great
if two versions of the solution are provided: One without the parser module, and one
with.

Grammar
The simple programming language to be analyzed is more or less a (very tiny) subset of
C. The formal grammar in
Extended Backus-Naur Form (EBNF):

 
    stmt_list           =   {stmt} ;
 
    stmt                =   ';'
                          | Identifier '=' expr ';'
                          | 'while' paren_expr stmt
                          | 'if' paren_expr stmt ['else' stmt]
                          | 'print' '(' prt_list ')' ';'
                          | 'putc' paren_expr ';'
                          | '{' stmt_list '}'
                          ;
 
    paren_expr          =   '(' expr ')' ;
 
    prt_list            =   (string | expr) {',' (String | expr)} ;
 
    expr                =   and_expr            {'||' and_expr} ;
    and_expr            =   equality_expr       {'&&' equality_expr} ;
    equality_expr       =   relational_expr     [('==' | '!=') relational_expr] ;
    relational_expr     =   addition_expr       [('<' | '<=' | '>' | '>=') addition_expr] ;
    addition_expr       =   multiplication_expr {('+' | '-') multiplication_expr} ;
    multiplication_expr =   primary             {('*' | '/' | '%') primary } ;
    primary             =   Identifier
                          | Integer
                          | '(' expr ')'
                          | ('+' | '-' | '!') primary
                          ;
The resulting AST should be formulated as a Binary Tree.

Example - given the simple program (below), stored in a file called while.t, create the list of tokens, using one of the Lexical analyzer solutions
lex < while.t > while.lex

Run one of the Syntax analyzer solutions

parse < while.lex > while.ast

The following table shows the input to lex, lex output, and the AST produced by the parser



 Input to lex

 Output from lex, input to parse

 Output from parse



count = 1;
 while (count < 10) {
     print(""count is: "", count, ""\n"");
     count = count + 1;
 }


    1      1 Identifier      count
    1      7 Op_assign
    1      9 Integer             1
    1     10 Semicolon
    2      1 Keyword_while
    2      7 LeftParen
    2      8 Identifier      count
    2     14 Op_less
    2     16 Integer            10
    2     18 RightParen
    2     20 LeftBrace
    3      5 Keyword_print
    3     10 LeftParen
    3     11 String          ""count is: ""
    3     23 Comma
    3     25 Identifier      count
    3     30 Comma
    3     32 String          ""\n""
    3     36 RightParen
    3     37 Semicolon
    4      5 Identifier      count
    4     11 Op_assign
    4     13 Identifier      count
    4     19 Op_add
    4     21 Integer             1
    4     22 Semicolon
    5      1 RightBrace
    6      1 End_of_input



Sequence
Sequence
;
Assign
Identifier    count
Integer       1
While
Less
Identifier    count
Integer       10
Sequence
Sequence
;
Sequence
Sequence
Sequence
;
Prts
String        ""count is: ""
;
Prti
Identifier    count
;
Prts
String        ""\n""
;
Assign
Identifier    count
Add
Identifier    count
Integer       1


Specifications
List of node type names

Identifier String Integer Sequence If Prtc Prts Prti While Assign Negate Not Multiply Divide Mod
Add Subtract Less LessEqual Greater GreaterEqual Equal NotEqual And Or

In the text below, Null/Empty nodes are represented by "";"".

Non-terminal (internal) nodes

For Operators, the following nodes should be created:

Multiply Divide Mod Add Subtract Less LessEqual Greater GreaterEqual Equal NotEqual And Or

For each of the above nodes, the left and right sub-nodes are the operands of the
respective operation.

In pseudo S-Expression format:

(Operator expression expression)

Negate, Not

For these node types, the left node is the operand, and the right node is null.

(Operator expression ;)

Sequence - sub-nodes are either statements or Sequences.

If - left node is the expression, the right node is If node, with it's left node being the
if-true statement part, and the right node being the if-false (else) statement part.

(If expression (If statement else-statement))

If there is not an else, the tree becomes:

(If expression (If statement ;))

Prtc

(Prtc (expression) ;)

Prts

(Prts (String ""the string"") ;)

Prti

(Prti (Integer 12345) ;)

While - left node is the expression, the right node is the statement.

(While expression statement)

Assign - left node is the left-hand side of the assignment, the right node is the
right-hand side of the assignment.

(Assign Identifier expression)

Terminal (leaf) nodes:

Identifier: (Identifier ident_name)
Integer:    (Integer 12345)
String:     (String ""Hello World!"")
"";"":        Empty node

Some simple examples
Sequences denote a list node; they are used to represent a list. semicolon's represent a null node, e.g., the end of this path.

This simple program:

   a=11;

Produces the following AST, encoded as a binary tree:

Under each non-leaf node are two '|' lines. The first represents the left sub-node, the second represents the right sub-node:

   (1) Sequence
   (2)     |-- ;
   (3)     |-- Assign
   (4)         |-- Identifier: a
   (5)         |-- Integer: 11

In flattened form:

   (1) Sequence
   (2) ;
   (3) Assign
   (4) Identifier    a
   (5) Integer       11



This program:

   a=11;
   b=22;
   c=33;

Produces the following AST:

   ( 1) Sequence
   ( 2)     |-- Sequence
   ( 3)     |   |-- Sequence
   ( 4)     |   |   |-- ;
   ( 5)     |   |   |-- Assign
   ( 6)     |   |       |-- Identifier: a
   ( 7)     |   |       |-- Integer: 11
   ( 8)     |   |-- Assign
   ( 9)     |       |-- Identifier: b
   (10)     |       |-- Integer: 22
   (11)     |-- Assign
   (12)         |-- Identifier: c
   (13)         |-- Integer: 33

In flattened form:

   ( 1) Sequence
   ( 2) Sequence
   ( 3) Sequence
   ( 4) ;
   ( 5) Assign
   ( 6) Identifier    a
   ( 7) Integer       11
   ( 8) Assign
   ( 9) Identifier    b
   (10) Integer       22
   (11) Assign
   (12) Identifier    c
   (13) Integer       33

Pseudo-code for the parser. 
Uses Precedence Climbing for expression parsing, and
Recursive Descent for statement parsing. The AST is also built:

def expr(p)
    if tok is ""(""
        x = paren_expr()
    elif tok in [""-"", ""+"", ""!""]
        gettok()
        y = expr(precedence of operator)
        if operator was ""+""
            x = y
        else
            x = make_node(operator, y)
    elif tok is an Identifier
        x = make_leaf(Identifier, variable name)
        gettok()
    elif tok is an Integer constant
        x = make_leaf(Integer, integer value)
        gettok()
    else
        error()
 
    while tok is a binary operator and precedence of tok >= p
        save_tok = tok
        gettok()
        q = precedence of save_tok
        if save_tok is not right associative
            q += 1
        x = make_node(Operator save_tok represents, x, expr(q))
 
    return x
 
def paren_expr()
    expect(""("")
    x = expr(0)
    expect("")"")
    return x
 
def stmt()
    t = NULL
    if accept(""if"")
        e = paren_expr()
        s = stmt()
        t = make_node(If, e, make_node(If, s, accept(""else"") ? stmt() : NULL))
    elif accept(""putc"")
        t = make_node(Prtc, paren_expr())
        expect("";"")
    elif accept(""print"")
        expect(""("")
        repeat
            if tok is a string
                e = make_node(Prts, make_leaf(String, the string))
                gettok()
            else
                e = make_node(Prti, expr(0))
 
            t = make_node(Sequence, t, e)
        until not accept("","")
        expect("")"")
        expect("";"")
    elif tok is "";""
        gettok()
    elif tok is an Identifier
        v = make_leaf(Identifier, variable name)
        gettok()
        expect(""="")
        t = make_node(Assign, v, expr(0))
        expect("";"")
    elif accept(""while"")
        e = paren_expr()
        t = make_node(While, e, stmt()
    elif accept(""{"")
        while tok not equal ""}"" and tok not equal end-of-file
            t = make_node(Sequence, t, stmt())
        expect(""}"")
    elif tok is end-of-file
        pass
    else
        error()
    return t
 
def parse()
    t = NULL
    gettok()
    repeat
        t = make_node(Sequence, t, stmt())
    until tok is end-of-file
    return t
Once the AST is built, it should be output in a flattened format. This can be as simple as the following

def prt_ast(t)
    if t == NULL
        print("";\n"")
    else
        print(t.node_type)
        if t.node_type in [Identifier, Integer, String]     # leaf node
            print the value of the Ident, Integer or String, ""\n""
        else
            print(""\n"")
            prt_ast(t.left)
            prt_ast(t.right)
If the AST is correctly built, loading it into a subsequent program should be as simple as

def load_ast()
    line = readline()
    # Each line has at least one token
    line_list = tokenize the line, respecting double quotes
 
    text = line_list[0] # first token is always the node type
 
    if text == "";""   # a terminal node
        return NULL
 
    node_type = text # could convert to internal form if desired
 
    # A line with two tokens is a leaf node
    # Leaf nodes are: Identifier, Integer, String
    # The 2nd token is the value
    if len(line_list) > 1
        return make_leaf(node_type, line_list[1])
 
    left = load_ast()
    right = load_ast()
    return make_node(node_type, left, right)
Finally, the AST can also be tested by running it against one of the AST Interpreter solutions.

Test program, assuming this is in a file called prime.t
 lex <prime.t | parse


 Input to lex

 Output from lex, input to parse

 Output from parse



/*
 Simple prime number generator
 */
count = 1;
n = 1;
limit = 100;
while (n < limit) {
    k=3;
    p=1;
    n=n+2;
    while ((k*k<=n) && (p)) {
        p=n/k*k!=n;
        k=k+2;
    }
    if (p) {
        print(n, "" is prime\n"");
        count = count + 1;
    }
}
print(""Total primes found: "", count, ""\n"");


    4      1 Identifier      count
    4      7 Op_assign
    4      9 Integer             1
    4     10 Semicolon
    5      1 Identifier      n
    5      3 Op_assign
    5      5 Integer             1
    5      6 Semicolon
    6      1 Identifier      limit
    6      7 Op_assign
    6      9 Integer           100
    6     12 Semicolon
    7      1 Keyword_while
    7      7 LeftParen
    7      8 Identifier      n
    7     10 Op_less
    7     12 Identifier      limit
    7     17 RightParen
    7     19 LeftBrace
    8      5 Identifier      k
    8      6 Op_assign
    8      7 Integer             3
    8      8 Semicolon
    9      5 Identifier      p
    9      6 Op_assign
    9      7 Integer             1
    9      8 Semicolon
   10      5 Identifier      n
   10      6 Op_assign
   10      7 Identifier      n
   10      8 Op_add
   10      9 Integer             2
   10     10 Semicolon
   11      5 Keyword_while
   11     11 LeftParen
   11     12 LeftParen
   11     13 Identifier      k
   11     14 Op_multiply
   11     15 Identifier      k
   11     16 Op_lessequal
   11     18 Identifier      n
   11     19 RightParen
   11     21 Op_and
   11     24 LeftParen
   11     25 Identifier      p
   11     26 RightParen
   11     27 RightParen
   11     29 LeftBrace
   12      9 Identifier      p
   12     10 Op_assign
   12     11 Identifier      n
   12     12 Op_divide
   12     13 Identifier      k
   12     14 Op_multiply
   12     15 Identifier      k
   12     16 Op_notequal
   12     18 Identifier      n
   12     19 Semicolon
   13      9 Identifier      k
   13     10 Op_assign
   13     11 Identifier      k
   13     12 Op_add
   13     13 Integer             2
   13     14 Semicolon
   14      5 RightBrace
   15      5 Keyword_if
   15      8 LeftParen
   15      9 Identifier      p
   15     10 RightParen
   15     12 LeftBrace
   16      9 Keyword_print
   16     14 LeftParen
   16     15 Identifier      n
   16     16 Comma
   16     18 String          "" is prime\n""
   16     31 RightParen
   16     32 Semicolon
   17      9 Identifier      count
   17     15 Op_assign
   17     17 Identifier      count
   17     23 Op_add
   17     25 Integer             1
   17     26 Semicolon
   18      5 RightBrace
   19      1 RightBrace
   20      1 Keyword_print
   20      6 LeftParen
   20      7 String          ""Total primes found: ""
   20     29 Comma
   20     31 Identifier      count
   20     36 Comma
   20     38 String          ""\n""
   20     42 RightParen
   20     43 Semicolon
   21      1 End_of_input



Sequence
Sequence
Sequence
Sequence
Sequence
;
Assign
Identifier    count
Integer       1
Assign
Identifier    n
Integer       1
Assign
Identifier    limit
Integer       100
While
Less
Identifier    n
Identifier    limit
Sequence
Sequence
Sequence
Sequence
Sequence
;
Assign
Identifier    k
Integer       3
Assign
Identifier    p
Integer       1
Assign
Identifier    n
Add
Identifier    n
Integer       2
While
And
LessEqual
Multiply
Identifier    k
Identifier    k
Identifier    n
Identifier    p
Sequence
Sequence
;
Assign
Identifier    p
NotEqual
Multiply
Divide
Identifier    n
Identifier    k
Identifier    k
Identifier    n
Assign
Identifier    k
Add
Identifier    k
Integer       2
If
Identifier    p
If
Sequence
Sequence
;
Sequence
Sequence
;
Prti
Identifier    n
;
Prts
String        "" is prime\n""
;
Assign
Identifier    count
Add
Identifier    count
Integer       1
;
Sequence
Sequence
Sequence
;
Prts
String        ""Total primes found: ""
;
Prti
Identifier    count
;
Prts
String        ""\n""
;


 Additional examples
Your solution should pass all the test cases above and the additional tests found Here.

Reference
The C and Python versions can be considered reference implementations.

Related Tasks
 Lexical Analyzer task
 Code Generator task
 Virtual Machine Interpreter task
 AST Interpreter task
",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""log""
    ""os""
    ""strconv""
    ""strings""
)
 
type TokenType int
 
const (
    tkEOI TokenType = iota
    tkMul
    tkDiv
    tkMod
    tkAdd
    tkSub
    tkNegate
    tkNot
    tkLss
    tkLeq
    tkGtr
    tkGeq
    tkEql
    tkNeq
    tkAssign
    tkAnd
    tkOr
    tkIf
    tkElse
    tkWhile
    tkPrint
    tkPutc
    tkLparen
    tkRparen
    tkLbrace
    tkRbrace
    tkSemi
    tkComma
    tkIdent
    tkInteger
    tkString
)
 
type NodeType int
 
const (
    ndIdent NodeType = iota
    ndString
    ndInteger
    ndSequence
    ndIf
    ndPrtc
    ndPrts
    ndPrti
    ndWhile
    ndAssign
    ndNegate
    ndNot
    ndMul
    ndDiv
    ndMod
    ndAdd
    ndSub
    ndLss
    ndLeq
    ndGtr
    ndGeq
    ndEql
    ndNeq
    ndAnd
    ndOr
)
 
type tokS struct {
    tok    TokenType
    errLn  int
    errCol int
    text   string // ident or string literal or integer value
}
 
type Tree struct {
    nodeType NodeType
    left     *Tree
    right    *Tree
    value    string
}
 
// dependency: Ordered by tok, must remain in same order as TokenType consts
type atr struct {
    text             string
    enumText         string
    tok              TokenType
    rightAssociative bool
    isBinary         bool
    isUnary          bool
    precedence       int
    nodeType         NodeType
}
 
var atrs = []atr{
    {""EOI"", ""End_of_input"", tkEOI, false, false, false, -1, -1},
    {""*"", ""Op_multiply"", tkMul, false, true, false, 13, ndMul},
    {""/"", ""Op_divide"", tkDiv, false, true, false, 13, ndDiv},
    {""%"", ""Op_mod"", tkMod, false, true, false, 13, ndMod},
    {""+"", ""Op_add"", tkAdd, false, true, false, 12, ndAdd},
    {""-"", ""Op_subtract"", tkSub, false, true, false, 12, ndSub},
    {""-"", ""Op_negate"", tkNegate, false, false, true, 14, ndNegate},
    {""!"", ""Op_not"", tkNot, false, false, true, 14, ndNot},
    {""<"", ""Op_less"", tkLss, false, true, false, 10, ndLss},
    {""<="", ""Op_lessequal"", tkLeq, false, true, false, 10, ndLeq},
    {"">"", ""Op_greater"", tkGtr, false, true, false, 10, ndGtr},
    {"">="", ""Op_greaterequal"", tkGeq, false, true, false, 10, ndGeq},
    {""=="", ""Op_equal"", tkEql, false, true, false, 9, ndEql},
    {""!="", ""Op_notequal"", tkNeq, false, true, false, 9, ndNeq},
    {""="", ""Op_assign"", tkAssign, false, false, false, -1, ndAssign},
    {""&&"", ""Op_and"", tkAnd, false, true, false, 5, ndAnd},
    {""||"", ""Op_or"", tkOr, false, true, false, 4, ndOr},
    {""if"", ""Keyword_if"", tkIf, false, false, false, -1, ndIf},
    {""else"", ""Keyword_else"", tkElse, false, false, false, -1, -1},
    {""while"", ""Keyword_while"", tkWhile, false, false, false, -1, ndWhile},
    {""print"", ""Keyword_print"", tkPrint, false, false, false, -1, -1},
    {""putc"", ""Keyword_putc"", tkPutc, false, false, false, -1, -1},
    {""("", ""LeftParen"", tkLparen, false, false, false, -1, -1},
    {"")"", ""RightParen"", tkRparen, false, false, false, -1, -1},
    {""{"", ""LeftBrace"", tkLbrace, false, false, false, -1, -1},
    {""}"", ""RightBrace"", tkRbrace, false, false, false, -1, -1},
    {"";"", ""Semicolon"", tkSemi, false, false, false, -1, -1},
    {"","", ""Comma"", tkComma, false, false, false, -1, -1},
    {""Ident"", ""Identifier"", tkIdent, false, false, false, -1, ndIdent},
    {""Integer literal"", ""Integer"", tkInteger, false, false, false, -1, ndInteger},
    {""String literal"", ""String"", tkString, false, false, false, -1, ndString},
}
 
var displayNodes = []string{
    ""Identifier"", ""String"", ""Integer"", ""Sequence"", ""If"", ""Prtc"", ""Prts"", ""Prti"",
    ""While"", ""Assign"", ""Negate"", ""Not"", ""Multiply"", ""Divide"", ""Mod"", ""Add"",
    ""Subtract"", ""Less"", ""LessEqual"", ""Greater"", ""GreaterEqual"", ""Equal"",
    ""NotEqual"", ""And"", ""Or"",
}
 
var (
    err     error
    token   tokS
    scanner *bufio.Scanner
)
 
func reportError(errLine, errCol int, msg string) {
    log.Fatalf(""(%d, %d) error : %s\n"", errLine, errCol, msg)
}
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func getEum(name string) TokenType { // return internal version of name#
    for _, atr := range atrs {
        if atr.enumText == name {
            return atr.tok
        }
    }
    reportError(0, 0, fmt.Sprintf(""Unknown token %s\n"", name))
    return tkEOI
}
 
func getTok() tokS {
    tok := tokS{}
    if scanner.Scan() {
        line := strings.TrimRight(scanner.Text(), "" \t"")
        fields := strings.Fields(line)
        // [ ]*{lineno}[ ]+{colno}[ ]+token[ ]+optional
        tok.errLn, err = strconv.Atoi(fields[0])
        check(err)
        tok.errCol, err = strconv.Atoi(fields[1])
        check(err)
        tok.tok = getEum(fields[2])
        le := len(fields)
        if le == 4 {
            tok.text = fields[3]
        } else if le > 4 {
            idx := strings.Index(line, `""`)
            tok.text = line[idx:]
        }
    }
    check(scanner.Err())
    return tok
}
 
func makeNode(nodeType NodeType, left *Tree, right *Tree) *Tree {
    return &Tree{nodeType, left, right, """"}
}
 
func makeLeaf(nodeType NodeType, value string) *Tree {
    return &Tree{nodeType, nil, nil, value}
}
 
func expect(msg string, s TokenType) {
    if token.tok == s {
        token = getTok()
        return
    }
    reportError(token.errLn, token.errCol,
        fmt.Sprintf(""%s: Expecting '%s', found '%s'\n"", msg, atrs[s].text, atrs[token.tok].text))
}
 
func expr(p int) *Tree {
    var x, node *Tree
    switch token.tok {
    case tkLparen:
        x = parenExpr()
    case tkSub, tkAdd:
        op := token.tok
        token = getTok()
        node = expr(atrs[tkNegate].precedence)
        if op == tkSub {
            x = makeNode(ndNegate, node, nil)
        } else {
            x = node
        }
    case tkNot:
        token = getTok()
        x = makeNode(ndNot, expr(atrs[tkNot].precedence), nil)
    case tkIdent:
        x = makeLeaf(ndIdent, token.text)
        token = getTok()
    case tkInteger:
        x = makeLeaf(ndInteger, token.text)
        token = getTok()
    default:
        reportError(token.errLn, token.errCol,
            fmt.Sprintf(""Expecting a primary, found: %s\n"", atrs[token.tok].text))
    }
 
    for atrs[token.tok].isBinary && atrs[token.tok].precedence >= p {
        op := token.tok
        token = getTok()
        q := atrs[op].precedence
        if !atrs[op].rightAssociative {
            q++
        }
        node = expr(q)
        x = makeNode(atrs[op].nodeType, x, node)
    }
    return x
}
 
func parenExpr() *Tree {
    expect(""parenExpr"", tkLparen)
    t := expr(0)
    expect(""parenExpr"", tkRparen)
    return t
}
 
func stmt() *Tree {
    var t, v, e, s, s2 *Tree
    switch token.tok {
    case tkIf:
        token = getTok()
        e = parenExpr()
        s = stmt()
        s2 = nil
        if token.tok == tkElse {
            token = getTok()
            s2 = stmt()
        }
        t = makeNode(ndIf, e, makeNode(ndIf, s, s2))
    case tkPutc:
        token = getTok()
        e = parenExpr()
        t = makeNode(ndPrtc, e, nil)
        expect(""Putc"", tkSemi)
    case tkPrint: // print '(' expr {',' expr} ')'
        token = getTok()
        for expect(""Print"", tkLparen); ; expect(""Print"", tkComma) {
            if token.tok == tkString {
                e = makeNode(ndPrts, makeLeaf(ndString, token.text), nil)
                token = getTok()
            } else {
                e = makeNode(ndPrti, expr(0), nil)
            }
            t = makeNode(ndSequence, t, e)
            if token.tok != tkComma {
                break
            }
        }
        expect(""Print"", tkRparen)
        expect(""Print"", tkSemi)
    case tkSemi:
        token = getTok()
    case tkIdent:
        v = makeLeaf(ndIdent, token.text)
        token = getTok()
        expect(""assign"", tkAssign)
        e = expr(0)
        t = makeNode(ndAssign, v, e)
        expect(""assign"", tkSemi)
    case tkWhile:
        token = getTok()
        e = parenExpr()
        s = stmt()
        t = makeNode(ndWhile, e, s)
    case tkLbrace: // {stmt}
        for expect(""Lbrace"", tkLbrace); token.tok != tkRbrace && token.tok != tkEOI; {
            t = makeNode(ndSequence, t, stmt())
        }
        expect(""Lbrace"", tkRbrace)
    case tkEOI:
        // do nothing
    default:
        reportError(token.errLn, token.errCol,
            fmt.Sprintf(""expecting start of statement, found '%s'\n"", atrs[token.tok].text))
    }
    return t
}
 
func parse() *Tree {
    var t *Tree
    token = getTok()
    for {
        t = makeNode(ndSequence, t, stmt())
        if t == nil || token.tok == tkEOI {
            break
        }
    }
    return t
}
 
func prtAst(t *Tree) {
    if t == nil {
        fmt.Print("";\n"")
    } else {
        fmt.Printf(""%-14s "", displayNodes[t.nodeType])
        if t.nodeType == ndIdent || t.nodeType == ndInteger || t.nodeType == ndString {
            fmt.Printf(""%s\n"", t.value)
        } else {
            fmt.Println()
            prtAst(t.left)
            prtAst(t.right)
        }
    }
}
 
func main() {
    source, err := os.Open(""source.txt"")
    check(err)
    defer source.Close()
    scanner = bufio.NewScanner(source)
    prtAst(parse())
}",9119,354
66544,http://rosettacode.org/wiki/Compare_sorting_algorithms%27_performance,Compare sorting algorithms' performance,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Measure a relative performance of sorting algorithms implementations.

Plot execution time vs. input sequence length dependencies for various implementation of sorting algorithm and different input sequence types (example figures).

Consider three type of input sequences:

   ones: sequence of all 1's.   Example: {1, 1, 1, 1, 1}
   range: ascending sequence, i.e. already sorted.   Example: {1, 2, 3, 10, 15}
   shuffled range: sequence with elements randomly distributed.   Example: {5, 3, 9, 6, 8}


Consider at least two different sorting functions (different algorithms or/and different implementation of the same algorithm).

For example, consider Bubble Sort, Insertion sort, Quicksort or/and implementations of Quicksort with different pivot selection mechanisms.   Where possible, use existing implementations.

Preliminary subtask:

   Bubble Sort, Insertion sort, Quicksort, Radix sort, Shell sort
   Query Performance
   Write float arrays to a text file
   Plot x, y arrays
   Polynomial Fitting


General steps:

   Define sorting routines to be considered.
   Define appropriate sequence generators and write timings.
   Plot timings.
   What conclusions about relative performance of the sorting routines could be made based on the plots?

",#Go,Go,"package main
 
import (
    ""log""
    ""math/rand""
    ""testing""
    ""time""
 
    ""github.com/gonum/plot""
    ""github.com/gonum/plot/plotter""
    ""github.com/gonum/plot/plotutil""
    ""github.com/gonum/plot/vg""
)
 
// Step 1, sort routines.
// These functions are copied without changes from the RC tasks Bubble Sort,
// Insertion sort, and Quicksort.
 
func bubblesort(a []int) {
    for itemCount := len(a) - 1; ; itemCount-- {
        hasChanged := false
        for index := 0; index < itemCount; index++ {
            if a[index] > a[index+1] {
                a[index], a[index+1] = a[index+1], a[index]
                hasChanged = true
            }
        }
        if hasChanged == false {
            break
        }
    }
}
 
func insertionsort(a []int) {
    for i := 1; i < len(a); i++ {
        value := a[i]
        j := i - 1
        for j >= 0 && a[j] > value {
            a[j+1] = a[j]
            j = j - 1
        }
        a[j+1] = value
    }
}
 
func quicksort(a []int) {
    var pex func(int, int)
    pex = func(lower, upper int) {
        for {
            switch upper - lower {
            case -1, 0:
                return
            case 1:
                if a[upper] < a[lower] {
                    a[upper], a[lower] = a[lower], a[upper]
                }
                return
            }
            bx := (upper + lower) / 2
            b := a[bx]
            lp := lower
            up := upper
        outer:
            for {
                for lp < upper && !(b < a[lp]) {
                    lp++
                }
                for {
                    if lp > up {
                        break outer
                    }
                    if a[up] < b {
                        break
                    }
                    up--
                }
                a[lp], a[up] = a[up], a[lp]
                lp++
                up--
            }
            if bx < lp {
                if bx < lp-1 {
                    a[bx], a[lp-1] = a[lp-1], b
                }
                up = lp - 2
            } else {
                if bx > lp {
                    a[bx], a[lp] = a[lp], b
                }
                up = lp - 1
                lp++
            }
            if up-lower < upper-lp {
                pex(lower, up)
                lower = lp
            } else {
                pex(lp, upper)
                upper = up
            }
        }
    }
    pex(0, len(a)-1)
}
 
// Step 2.0 sequence routines.  2.0 is the easy part.  2.5, timings, follows.
 
func ones(n int) []int {
    s := make([]int, n)
    for i := range s {
        s[i] = 1
    }
    return s
}
 
func ascending(n int) []int {
    s := make([]int, n)
    v := 1
    for i := 0; i < n; {
        if rand.Intn(3) == 0 {
            s[i] = v
            i++
        }
        v++
    }
    return s
}
 
func shuffled(n int) []int {
    return rand.Perm(n)
}
 
// Steps 2.5 write timings, and 3 plot timings are coded together.
// If write means format and output human readable numbers, step 2.5
// is satisfied with the log output as the program runs.  The timings
// are plotted immediately however for step 3, not read and parsed from
// any formated output.
const (
    nPts = 7    // number of points per test
    inc  = 1000 // data set size increment per point
)
 
var (
    p        *plot.Plot
    sortName = []string{""Bubble sort"", ""Insertion sort"", ""Quicksort""}
    sortFunc = []func([]int){bubblesort, insertionsort, quicksort}
    dataName = []string{""Ones"", ""Ascending"", ""Shuffled""}
    dataFunc = []func(int) []int{ones, ascending, shuffled}
)
 
func main() {
    rand.Seed(time.Now().Unix())
    var err error
    p, err = plot.New()
    if err != nil {
        log.Fatal(err)
    }
    p.X.Label.Text = ""Data size""
    p.Y.Label.Text = ""microseconds""
    p.Y.Scale = plot.LogScale{}
    p.Y.Tick.Marker = plot.LogTicks{}
    p.Y.Min = .5 // hard coded to make enough room for legend
 
    for dx, name := range dataName {
        s, err := plotter.NewScatter(plotter.XYs{})
        if err != nil {
            log.Fatal(err)
        }
        s.Shape = plotutil.DefaultGlyphShapes[dx]
        p.Legend.Add(name, s)
    }
    for sx, name := range sortName {
        l, err := plotter.NewLine(plotter.XYs{})
        if err != nil {
            log.Fatal(err)
        }
        l.Color = plotutil.DarkColors[sx]
        p.Legend.Add(name, l)
    }
    for sx := range sortFunc {
        bench(sx, 0, 1) // for ones, a single timing is sufficient.
        bench(sx, 1, 5) // ascending and shuffled have some randomness though,
        bench(sx, 2, 5) // so average timings on 5 different random sets.
    }
 
    if err := p.Save(5*vg.Inch, 5*vg.Inch, ""comp.png""); err != nil {
        log.Fatal(err)
    }
}
 
func bench(sx, dx, rep int) {
    log.Println(""bench"", sortName[sx], dataName[dx], ""x"", rep)
    pts := make(plotter.XYs, nPts)
    sf := sortFunc[sx]
    for i := range pts {
        x := (i + 1) * inc
        // to avoid timing sequence creation, create sequence before timing
        // then just copy the data inside the timing loop.  copy time should
        // be the same regardless of sequence data.
        s0 := dataFunc[dx](x) // reference sequence
        s := make([]int, x)   // working copy
        var tSort int64
        for j := 0; j < rep; j++ {
            tSort += testing.Benchmark(func(b *testing.B) {
                for i := 0; i < b.N; i++ {
                    copy(s, s0)
                    sf(s)
                }
            }).NsPerOp()
        }
        tSort /= int64(rep)
        log.Println(x, ""items"", tSort, ""ns"") // step 2.5, write timings
        pts[i] = struct{ X, Y float64 }{float64(x), float64(tSort) * .001}
    }
    pl, ps, err := plotter.NewLinePoints(pts) // step 3, plot timings
    if err != nil {
        log.Fatal(err)
    }
    pl.Color = plotutil.DarkColors[sx]
    ps.Color = plotutil.DarkColors[sx]
    ps.Shape = plotutil.DefaultGlyphShapes[dx]
    p.Add(pl, ps)
}",6000,222
66564,http://rosettacode.org/wiki/Compiler/virtual_machine_interpreter,Compiler/virtual machine interpreter,"A virtual machine implements a computer in software.

Task[edit]
Write a virtual machine interpreter. This interpreter should be able to run virtual
assembly language programs created via the task. This is a
byte-coded, 32-bit word stack based virtual machine.

The program should read input from a file and/or stdin, and write output to a file and/or
stdout.

Input format:

Given the following program:

count = 1;
while (count < 10) {
    print(""count is: "", count, ""\n"");
    count = count + 1;
}

The output from the Code generator is a virtual assembly code program:



 Output from gen, input to VM



Datasize: 1 Strings: 2
""count is: ""
""\n""
    0 push  1
    5 store [0]
   10 fetch [0]
   15 push  10
   20 lt
   21 jz     (43) 65
   26 push  0
   31 prts
   32 fetch [0]
   37 prti
   38 push  1
   43 prts
   44 fetch [0]
   49 push  1
   54 add
   55 store [0]
   60 jmp    (-51) 10
   65 halt

The first line of the input specifies the datasize required and the number of constant
strings, in the order that they are reference via the code.

The data can be stored in a separate array, or the data can be stored at the beginning of
the stack. Data is addressed starting at 0. If there are 3 variables, the 3rd one if
referenced at address 2.

If there are one or more constant strings, they come next. The code refers to these
strings by their index. The index starts at 0. So if there are 3 strings, and the code
wants to reference the 3rd string, 2 will be used.

Next comes the actual virtual assembly code. The first number is the code address of that
instruction. After that is the instruction mnemonic, followed by optional operands,
depending on the instruction.

Registers:

sp:

   the stack pointer - points to the next top of stack.  The stack is a 32-bit integer
   array.

pc:

   the program counter - points to the current instruction to be performed.  The code is an
   array of bytes.

Data:

   data
   string pool

Instructions:

Each instruction is one byte. The following instructions also have a 32-bit integer
operand:

fetch [index]

where index is an index into the data array.

store [index]

where index is an index into the data array.

push n

where value is a 32-bit integer that will be pushed onto the stack.

jmp (n) addr

where (n) is a 32-bit integer specifying the distance between the current location and the
desired location. addr is an unsigned value of the actual code address.

jz (n) addr

where (n) is a 32-bit integer specifying the distance between the current location and the
desired location. addr is an unsigned value of the actual code address.

The following instructions do not have an operand. They perform their operation directly
against the stack:

For the following instructions, the operation is performed against the top two entries in
the stack:

add
sub
mul
div
mod
lt
gt
le
ge
eq
ne
and
or

For the following instructions, the operation is performed against the top entry in the
stack:

neg
not

Print the word at stack top as a character.

prtc

Print the word at stack top as an integer.

prti

Stack top points to an index into the string pool. Print that entry.

prts

Unconditional stop.

halt

 A simple example virtual machine

def run_vm(data_size)
    int stack[data_size + 1000]
    set stack[0..data_size - 1] to 0
    int pc = 0
    while True:
        op = code[pc]
        pc += 1
 
        if op == FETCH:
            stack.append(stack[bytes_to_int(code[pc:pc+word_size])[0]]);
            pc += word_size
        elif op == STORE:
            stack[bytes_to_int(code[pc:pc+word_size])[0]] = stack.pop();
            pc += word_size
        elif op == PUSH:
            stack.append(bytes_to_int(code[pc:pc+word_size])[0]);
            pc += word_size
        elif op == ADD:   stack[-2] += stack[-1]; stack.pop()
        elif op == SUB:   stack[-2] -= stack[-1]; stack.pop()
        elif op == MUL:   stack[-2] *= stack[-1]; stack.pop()
        elif op == DIV:   stack[-2] /= stack[-1]; stack.pop()
        elif op == MOD:   stack[-2] %= stack[-1]; stack.pop()
        elif op == LT:    stack[-2] = stack[-2] <  stack[-1]; stack.pop()
        elif op == GT:    stack[-2] = stack[-2] >  stack[-1]; stack.pop()
        elif op == LE:    stack[-2] = stack[-2] <= stack[-1]; stack.pop()
        elif op == GE:    stack[-2] = stack[-2] >= stack[-1]; stack.pop()
        elif op == EQ:    stack[-2] = stack[-2] == stack[-1]; stack.pop()
        elif op == NE:    stack[-2] = stack[-2] != stack[-1]; stack.pop()
        elif op == AND:   stack[-2] = stack[-2] and stack[-1]; stack.pop()
        elif op == OR:    stack[-2] = stack[-2] or  stack[-1]; stack.pop()
        elif op == NEG:   stack[-1] = -stack[-1]
        elif op == NOT:   stack[-1] = not stack[-1]
        elif op == JMP:   pc += bytes_to_int(code[pc:pc+word_size])[0]
        elif op == JZ:    if stack.pop() then pc += word_size else pc += bytes_to_int(code[pc:pc+word_size])[0]
        elif op == PRTC:  print stack[-1] as a character; stack.pop()
        elif op == PRTS:  print the constant string referred to by stack[-1]; stack.pop()
        elif op == PRTI:  print stack[-1] as an integer; stack.pop()
        elif op == HALT:  break
 Additional examples
Your solution should pass all the test cases above and the additional tests found Here.

Reference
The C and Python versions can be considered reference implementations.

Related Tasks
 Lexical Analyzer task
 Syntax Analyzer task
 Code Generator task
 AST Interpreter task
",#Go,Go,"package main
 
import (
    ""bufio""
    ""encoding/binary""
    ""fmt""
    ""log""
    ""math""
    ""os""
    ""strconv""
    ""strings""
)
 
type code = byte
 
const (
    fetch code = iota
    store
    push
    add
    sub
    mul
    div
    mod
    lt
    gt
    le
    ge
    eq
    ne
    and
    or
    neg
    not
    jmp
    jz
    prtc
    prts
    prti
    halt
)
 
var codeMap = map[string]code{
    ""fetch"": fetch,
    ""store"": store,
    ""push"":  push,
    ""add"":   add,
    ""sub"":   sub,
    ""mul"":   mul,
    ""div"":   div,
    ""mod"":   mod,
    ""lt"":    lt,
    ""gt"":    gt,
    ""le"":    le,
    ""ge"":    ge,
    ""eq"":    eq,
    ""ne"":    ne,
    ""and"":   and,
    ""or"":    or,
    ""neg"":   neg,
    ""not"":   not,
    ""jmp"":   jmp,
    ""jz"":    jz,
    ""prtc"":  prtc,
    ""prts"":  prts,
    ""prti"":  prti,
    ""halt"":  halt,
}
 
var (
    err        error
    scanner    *bufio.Scanner
    object     []code
    stringPool []string
)
 
func reportError(msg string) {
    log.Fatalf(""error : %s\n"", msg)
}
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func btoi(b bool) int32 {
    if b {
        return 1
    }
    return 0
}
 
func itob(i int32) bool {
    if i != 0 {
        return true
    }
    return false
}
 
func emitByte(c code) {
    object = append(object, c)
}
 
func emitWord(n int) {
    bs := make([]byte, 4)
    binary.LittleEndian.PutUint32(bs, uint32(n))
    for _, b := range bs {
        emitByte(code(b))
    }
}
 
/*** Virtual Machine interpreter ***/
func runVM(dataSize int) {
    stack := make([]int32, dataSize+1)
    pc := int32(0)
    for {
        op := object[pc]
        pc++
        switch op {
        case fetch:
            x := int32(binary.LittleEndian.Uint32(object[pc : pc+4]))
            stack = append(stack, stack[x])
            pc += 4
        case store:
            x := int32(binary.LittleEndian.Uint32(object[pc : pc+4]))
            ln := len(stack)
            stack[x] = stack[ln-1]
            stack = stack[:ln-1]
            pc += 4
        case push:
            x := int32(binary.LittleEndian.Uint32(object[pc : pc+4]))
            stack = append(stack, x)
            pc += 4
        case add:
            ln := len(stack)
            stack[ln-2] += stack[ln-1]
            stack = stack[:ln-1]
        case sub:
            ln := len(stack)
            stack[ln-2] -= stack[ln-1]
            stack = stack[:ln-1]
        case mul:
            ln := len(stack)
            stack[ln-2] *= stack[ln-1]
            stack = stack[:ln-1]
        case div:
            ln := len(stack)
            stack[ln-2] = int32(float64(stack[ln-2]) / float64(stack[ln-1]))
            stack = stack[:ln-1]
        case mod:
            ln := len(stack)
            stack[ln-2] = int32(math.Mod(float64(stack[ln-2]), float64(stack[ln-1])))
            stack = stack[:ln-1]
        case lt:
            ln := len(stack)
            stack[ln-2] = btoi(stack[ln-2] < stack[ln-1])
            stack = stack[:ln-1]
        case gt:
            ln := len(stack)
            stack[ln-2] = btoi(stack[ln-2] > stack[ln-1])
            stack = stack[:ln-1]
        case le:
            ln := len(stack)
            stack[ln-2] = btoi(stack[ln-2] <= stack[ln-1])
            stack = stack[:ln-1]
        case ge:
            ln := len(stack)
            stack[ln-2] = btoi(stack[ln-2] >= stack[ln-1])
            stack = stack[:ln-1]
        case eq:
            ln := len(stack)
            stack[ln-2] = btoi(stack[ln-2] == stack[ln-1])
            stack = stack[:ln-1]
        case ne:
            ln := len(stack)
            stack[ln-2] = btoi(stack[ln-2] != stack[ln-1])
            stack = stack[:ln-1]
        case and:
            ln := len(stack)
            stack[ln-2] = btoi(itob(stack[ln-2]) && itob(stack[ln-1]))
            stack = stack[:ln-1]
        case or:
            ln := len(stack)
            stack[ln-2] = btoi(itob(stack[ln-2]) || itob(stack[ln-1]))
            stack = stack[:ln-1]
        case neg:
            ln := len(stack)
            stack[ln-1] = -stack[ln-1]
        case not:
            ln := len(stack)
            stack[ln-1] = btoi(!itob(stack[ln-1]))
        case jmp:
            x := int32(binary.LittleEndian.Uint32(object[pc : pc+4]))
            pc += x
        case jz:
            ln := len(stack)
            v := stack[ln-1]
            stack = stack[:ln-1]
            if v != 0 {
                pc += 4
            } else {
                x := int32(binary.LittleEndian.Uint32(object[pc : pc+4]))
                pc += x
            }
        case prtc:
            ln := len(stack)
            fmt.Printf(""%c"", stack[ln-1])
            stack = stack[:ln-1]
        case prts:
            ln := len(stack)
            fmt.Printf(""%s"", stringPool[stack[ln-1]])
            stack = stack[:ln-1]
        case prti:
            ln := len(stack)
            fmt.Printf(""%d"", stack[ln-1])
            stack = stack[:ln-1]
        case halt:
            return
        default:
            reportError(fmt.Sprintf(""Unknown opcode %d\n"", op))
        }
    }
}
 
func translate(s string) string {
    var d strings.Builder
    for i := 0; i < len(s); i++ {
        if s[i] == '\\' && (i+1) < len(s) {
            if s[i+1] == 'n' {
                d.WriteByte('\n')
                i++
            } else if s[i+1] == '\\' {
                d.WriteByte('\\')
                i++
            }
        } else {
            d.WriteByte(s[i])
        }
    }
    return d.String()
}
 
func loadCode() int {
    var dataSize int
    firstLine := true
    for scanner.Scan() {
        line := strings.TrimRight(scanner.Text(), "" \t"")
        if len(line) == 0 {
            if firstLine {
                reportError(""empty line"")
            } else {
                break
            }
        }
        lineList := strings.Fields(line)
        if firstLine {
            dataSize, err = strconv.Atoi(lineList[1])
            check(err)
            nStrings, err := strconv.Atoi(lineList[3])
            check(err)
            for i := 0; i < nStrings; i++ {
                scanner.Scan()
                s := strings.Trim(scanner.Text(), ""\""\n"")
                stringPool = append(stringPool, translate(s))
            }
            firstLine = false
            continue
        }
        offset, err := strconv.Atoi(lineList[0])
        check(err)
        instr := lineList[1]
        opCode, ok := codeMap[instr]
        if !ok {
            reportError(fmt.Sprintf(""Unknown instruction %s at %d"", instr, opCode))
        }
        emitByte(opCode)
        switch opCode {
        case jmp, jz:
            p, err := strconv.Atoi(lineList[3])
            check(err)
            emitWord(p - offset - 1)
        case push:
            value, err := strconv.Atoi(lineList[2])
            check(err)
            emitWord(value)
        case fetch, store:
            value, err := strconv.Atoi(strings.Trim(lineList[2], ""[]""))
            check(err)
            emitWord(value)
        }
    }
    check(scanner.Err())
    return dataSize
}
 
func main() {
    codeGen, err := os.Open(""codegen.txt"")
    check(err)
    defer codeGen.Close()
    scanner = bufio.NewScanner(codeGen)
    runVM(loadCode())
}",7222,303
66602,http://rosettacode.org/wiki/Commatizing_numbers,Commatizing numbers,"Commatizing   numbers (as used here, is a handy expedient made-up word) is the act of adding commas to a number (or string), or to the numeric part of a larger string.



Task

Write a function that takes a string as an argument with optional arguments or parameters (the format of parameters/options is left to the programmer) that in general, adds commas (or some
other characters, including blanks or tabs) to the first numeric part of a string (if it's suitable for commatizing as per the rules below), and returns that newly commatized string.

Some of the commatizing rules (specified below) are arbitrary, but they'll be a part of this task requirements, if only to make the results consistent amongst national preferences and other disciplines.

The number may be part of a larger (non-numeric) string such as:

   «US$1744 millions»       ──or──
   ±25000 motes.


The string may possibly not have a number suitable for commatizing, so it should be untouched and no error generated.

If any argument (option) is invalid, nothing is changed and no error need be generated (quiet execution, no fail execution).   Error message generation is optional.

The exponent part of a number is never commatized.   The following string isn't suitable for commatizing:   9.7e+12000

Leading zeroes are never commatized.   The string   0000000005714.882   after commatization is:   0000000005,714.882

Any   period   (.)   in a number is assumed to be a   decimal point.

The original string is never changed   except   by the addition of commas   [or whatever character(s) is/are used for insertion], if at all.

To wit, the following should be preserved:

   leading signs (+, -)       ── even superfluous signs
   leading/trailing/embedded blanks, tabs, and other whitespace 
   the case (upper/lower) of the exponent indicator, e.g.:   4.8903d-002


Any exponent character(s) should be supported:

   1247e12
   57256.1D-4
   4444^60
   7500∙10**35
   8500x10**35
   9500↑35
   +55000↑3
   1000**100
   2048²
   409632
   10000pow(pi)

Numbers may be terminated with any non-digit character, including subscripts and/or superscript:   41421356243   or   7320509076(base 24).

The character(s) to be used for the comma can be specified, and may contain blanks, tabs, and other whitespace characters, as well as multiple characters.   The default is the comma (,) character.

The   period length   can be specified   (sometimes referred to as ""thousands"" or ""thousands separators"").   The   period length   can be defined as the length (or number) of the decimal digits between commas.   The default period length is   3.

 E.G.:   in this example, the   period length   is five:   56789,12340,14148
The location of where to start the scanning for the target field (the numeric part) should be able to be specified.   The default is   1.

The character strings below may be placed in a file (and read) or stored as simple strings within the program.



Strings to be used as a minimum

The value of   pi   (expressed in base 10)   should be separated with blanks every   5   places past the decimal point,

the Zimbabwe dollar amount should use a decimal point for the ""comma"" separator:

   pi=3.14159265358979323846264338327950288419716939937510582097494459231
   The author has two Z$100000000000000 Zimbabwe notes (100 trillion).
   ""-in Aus$+1411.8millions""
   ===US$0017440 millions=== (in 2000 dollars)
   123.e8000 is pretty big.
   The land area of the earth is 57268900(29% of the surface) square miles.
   Ain't no numbers in this here words, nohow, no way, Jose.
   James was never known as 0000000007
   Arthur Eddington wrote: I believe there are 15747724136275002577605653961181555468044717914527116709366231425076185631031296 protons in the universe.
   ␢␢␢$-140000±100 millions.
   6/9/1946 was a good year for some.

where the penultimate string has three leading blanks   (real blanks are to be used).



Also see

 The Wiki entry:   (sir) Arthur Eddington's number of protons in the universe. 

",#Go,Go,"package main
 
import (
    ""fmt""
    ""regexp""
    ""strings""
)
 
var reg = regexp.MustCompile(`(\.[0-9]+|[1-9]([0-9]+)?(\.[0-9]+)?)`)
 
func reverse(s string) string {
    r := []rune(s)
    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {
        r[i], r[j] = r[j], r[i]
    }
    return string(r)
}
 
func commatize(s string, startIndex, period int, sep string) string {
    if startIndex < 0 || startIndex >= len(s) || period < 1 || sep == """" {
        return s
    }
    m := reg.FindString(s[startIndex:]) // this can only contain ASCII characters
    if m == """" {
        return s
    }
    splits := strings.Split(m, ""."")
    ip := splits[0]
    if len(ip) > period {
        pi := reverse(ip)
        for i := (len(ip) - 1) / period * period; i >= period; i -= period {
            pi = pi[:i] + sep + pi[i:]
        }
        ip = reverse(pi)
    }
    if strings.Contains(m, ""."") {
        dp := splits[1]
        if len(dp) > period {
            for i := (len(dp) - 1) / period * period; i >= period; i -= period {
                dp = dp[:i] + sep + dp[i:]
            }
        }
        ip += ""."" + dp
    }
    return s[:startIndex] + strings.Replace(s[startIndex:], m, ip, 1)
}
 
func main() {
    tests := [...]string{
        ""123456789.123456789"",
        "".123456789"",
        ""57256.1D-4"",
        ""pi=3.14159265358979323846264338327950288419716939937510582097494459231"",
        ""The author has two Z$100000000000000 Zimbabwe notes (100 trillion)."",
        ""-in Aus$+1411.8millions"",
        ""===US$0017440 millions=== (in 2000 dollars)"",
        ""123.e8000 is pretty big."",
        ""The land area of the earth is 57268900(29% of the surface) square miles."",
        ""Ain't no numbers in this here words, nohow, no way, Jose."",
        ""James was never known as 0000000007"",
        ""Arthur Eddington wrote: I believe there are "" +
            ""15747724136275002577605653961181555468044717914527116709366231425076185631031296"" +
            "" protons in the universe."",
        ""   $-140000±100 millions."",
        ""6/9/1946 was a good year for some."",
    }
    fmt.Println(commatize(tests[0], 0, 2, ""*""))
    fmt.Println(commatize(tests[1], 0, 3, ""-""))
    fmt.Println(commatize(tests[2], 0, 4, ""__""))
    fmt.Println(commatize(tests[3], 0, 5, "" ""))
    fmt.Println(commatize(tests[4], 0, 3, "".""))
    for _, test := range tests[5:] {
        fmt.Println(commatize(test, 0, 3, "",""))
    }
}",2424,75
66614,http://rosettacode.org/wiki/Compiler/code_generator,Compiler/code generator,"A code generator translates the output of the syntax analyzer and/or semantic analyzer
into lower level code, either assembly, object, or virtual.

Task[edit]
Take the output of the Syntax analyzer task - which is a flattened Abstract Syntax Tree (AST) - and convert it to virtual machine code, that can be run by the
Virtual machine interpreter. The output is in text format, and represents virtual assembly code.

The program should read input from a file and/or stdin, and write output to a file and/or
stdout.

Example - given the simple program (below), stored in a file called while.t, create the list of tokens, using one of the Lexical analyzer solutions
lex < while.t > while.lex

Run one of the Syntax analyzer solutions

parse < while.lex > while.ast

while.ast can be input into the code generator.
The following table shows the input to lex, lex output, the AST produced by the parser, and the generated virtual assembly code.
Run as:  lex < while.t | parse | gen



 Input to lex

 Output from lex, input to parse

 Output from parse

 Output from gen, input to VM



count = 1;
while (count < 10) {
    print(""count is: "", count, ""\n"");
    count = count + 1;
}


    1      1   Identifier      count
    1      7   Op_assign
    1      9   Integer              1
    1     10   Semicolon
    2      1   Keyword_while
    2      7   LeftParen
    2      8   Identifier      count
    2     14   Op_less
    2     16   Integer             10
    2     18   RightParen
    2     20   LeftBrace
    3      5   Keyword_print
    3     10   LeftParen
    3     11   String          ""count is: ""
    3     23   Comma
    3     25   Identifier      count
    3     30   Comma
    3     32   String          ""\n""
    3     36   RightParen
    3     37   Semicolon
    4      5   Identifier      count
    4     11   Op_assign
    4     13   Identifier      count
    4     19   Op_add
    4     21   Integer              1
    4     22   Semicolon
    5      1   RightBrace
    6      1   End_of_input


Sequence
Sequence
;
Assign
Identifier    count
Integer       1
While
Less
Identifier    count
Integer       10
Sequence
Sequence
;
Sequence
Sequence
Sequence
;
Prts
String        ""count is: ""
;
Prti
Identifier    count
;
Prts
String        ""\n""
;
Assign
Identifier    count
Add
Identifier    count
Integer       1


Datasize: 1 Strings: 2
""count is: ""
""\n""
   0 push  1
   5 store [0]
  10 fetch [0]
  15 push  10
  20 lt
  21 jz     (43) 65
  26 push  0
  31 prts
  32 fetch [0]
  37 prti
  38 push  1
  43 prts
  44 fetch [0]
  49 push  1
  54 add
  55 store [0]
  60 jmp    (-51) 10
  65 halt

 Input format

As shown in the table, above, the output from the syntax analyzer is a flattened AST.

In the AST, Identifier, Integer, and String, are terminal nodes, e.g, they do not have child nodes.

Loading this data into an internal parse tree should be as simple as:

 
def load_ast()
    line = readline()
    # Each line has at least one token
    line_list = tokenize the line, respecting double quotes
 
    text = line_list[0] # first token is always the node type
 
    if text == "";""
        return None
 
    node_type = text # could convert to internal form if desired
 
    # A line with two tokens is a leaf node
    # Leaf nodes are: Identifier, Integer String
    # The 2nd token is the value
    if len(line_list) > 1
        return make_leaf(node_type, line_list[1])
 
    left = load_ast()
    right = load_ast()
    return make_node(node_type, left, right)
 
 Output format - refer to the table above
 The first line is the header: Size of data, and number of constant strings.
 size of data is the number of 32-bit unique variables used. In this example, one variable, count
 number of constant strings is just that - how many there are
 After that, the constant strings
 Finally, the assembly code
Registers

 sp: the stack pointer - points to the next top of stack. The stack is a 32-bit integer array.
 pc: the program counter - points to the current instruction to be performed. The code is an array of bytes.
Data
 
32-bit integers and strings

Instructions

Each instruction is one byte. The following instructions also have a 32-bit integer operand:

fetch [index]

where index is an index into the data array.

store [index]

where index is an index into the data array.

push n

where value is a 32-bit integer that will be pushed onto the stack.

jmp (n) addr

where (n) is a 32-bit integer specifying the distance between the current location and the
desired location. addr is an unsigned value of the actual code address.

jz (n) addr

where (n) is a 32-bit integer specifying the distance between the current location and the
desired location. addr is an unsigned value of the actual code address.

The following instructions do not have an operand. They perform their operation directly
against the stack:

For the following instructions, the operation is performed against the top two entries in
the stack:

add
sub
mul
div
mod
lt
gt
le
ge
eq
ne
and
or

For the following instructions, the operation is performed against the top entry in the
stack:

neg
not

prtc

Print the word at stack top as a character.

prti

Print the word at stack top as an integer.

prts

Stack top points to an index into the string pool. Print that entry.

halt

Unconditional stop.

 Additional examples
Your solution should pass all the test cases above and the additional tests found Here.

Reference
The C and Python versions can be considered reference implementations.

Related Tasks
 Lexical Analyzer task
 Syntax Analyzer task
 Virtual Machine Interpreter task
 AST Interpreter task
",#Go,Go,"package main
 
import (
    ""bufio""
    ""encoding/binary""
    ""fmt""
    ""log""
    ""os""
    ""strconv""
    ""strings""
)
 
type NodeType int
 
const (
    ndIdent NodeType = iota
    ndString
    ndInteger
    ndSequence
    ndIf
    ndPrtc
    ndPrts
    ndPrti
    ndWhile
    ndAssign
    ndNegate
    ndNot
    ndMul
    ndDiv
    ndMod
    ndAdd
    ndSub
    ndLss
    ndLeq
    ndGtr
    ndGeq
    ndEql
    ndNeq
    ndAnd
    ndOr
)
 
type code = byte
 
const (
    fetch code = iota
    store
    push
    add
    sub
    mul
    div
    mod
    lt
    gt
    le
    ge
    eq
    ne
    and
    or
    neg
    not
    jmp
    jz
    prtc
    prts
    prti
    halt
)
 
type Tree struct {
    nodeType NodeType
    left     *Tree
    right    *Tree
    value    string
}
 
// dependency: Ordered by NodeType, must remain in same order as NodeType enum
type atr struct {
    enumText string
    nodeType NodeType
    opcode   code
}
 
var atrs = []atr{
    {""Identifier"", ndIdent, 255},
    {""String"", ndString, 255},
    {""Integer"", ndInteger, 255},
    {""Sequence"", ndSequence, 255},
    {""If"", ndIf, 255},
    {""Prtc"", ndPrtc, 255},
    {""Prts"", ndPrts, 255},
    {""Prti"", ndPrti, 255},
    {""While"", ndWhile, 255},
    {""Assign"", ndAssign, 255},
    {""Negate"", ndNegate, neg},
    {""Not"", ndNot, not},
    {""Multiply"", ndMul, mul},
    {""Divide"", ndDiv, div},
    {""Mod"", ndMod, mod},
    {""Add"", ndAdd, add},
    {""Subtract"", ndSub, sub},
    {""Less"", ndLss, lt},
    {""LessEqual"", ndLeq, le},
    {""Greater"", ndGtr, gt},
    {""GreaterEqual"", ndGeq, ge},
    {""Equal"", ndEql, eq},
    {""NotEqual"", ndNeq, ne},
    {""And"", ndAnd, and},
    {""Or"", ndOr, or},
}
 
var (
    stringPool []string
    globals    []string
    object     []code
)
 
var (
    err     error
    scanner *bufio.Scanner
)
 
func reportError(msg string) {
    log.Fatalf(""error : %s\n"", msg)
}
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func nodeType2Op(nodeType NodeType) code {
    return atrs[nodeType].opcode
}
 
func makeNode(nodeType NodeType, left *Tree, right *Tree) *Tree {
    return &Tree{nodeType, left, right, """"}
}
 
func makeLeaf(nodeType NodeType, value string) *Tree {
    return &Tree{nodeType, nil, nil, value}
}
 
/*** Code generator ***/
 
func emitByte(c code) {
    object = append(object, c)
}
 
func emitWord(n int) {
    bs := make([]byte, 4)
    binary.LittleEndian.PutUint32(bs, uint32(n))
    for _, b := range bs {
        emitByte(code(b))
    }
}
 
func emitWordAt(at, n int) {
    bs := make([]byte, 4)
    binary.LittleEndian.PutUint32(bs, uint32(n))
    for i := at; i < at+4; i++ {
        object[i] = code(bs[i-at])
    }
}
 
func hole() int {
    t := len(object)
    emitWord(0)
    return t
}
 
func fetchVarOffset(id string) int {
    for i := 0; i < len(globals); i++ {
        if globals[i] == id {
            return i
        }
    }
    globals = append(globals, id)
    return len(globals) - 1
}
 
func fetchStringOffset(st string) int {
    for i := 0; i < len(stringPool); i++ {
        if stringPool[i] == st {
            return i
        }
    }
    stringPool = append(stringPool, st)
    return len(stringPool) - 1
}
 
func codeGen(x *Tree) {
    if x == nil {
        return
    }
    var n, p1, p2 int
    switch x.nodeType {
    case ndIdent:
        emitByte(fetch)
        n = fetchVarOffset(x.value)
        emitWord(n)
    case ndInteger:
        emitByte(push)
        n, err = strconv.Atoi(x.value)
        check(err)
        emitWord(n)
    case ndString:
        emitByte(push)
        n = fetchStringOffset(x.value)
        emitWord(n)
    case ndAssign:
        n = fetchVarOffset(x.left.value)
        codeGen(x.right)
        emitByte(store)
        emitWord(n)
    case ndIf:
        codeGen(x.left)       // if expr
        emitByte(jz)          // if false, jump
        p1 = hole()           // make room forjump dest
        codeGen(x.right.left) // if true statements
        if x.right.right != nil {
            emitByte(jmp)
            p2 = hole()
        }
        emitWordAt(p1, len(object)-p1)
        if x.right.right != nil {
            codeGen(x.right.right)
            emitWordAt(p2, len(object)-p2)
        }
    case ndWhile:
        p1 = len(object)
        codeGen(x.left)                // while expr
        emitByte(jz)                   // if false, jump
        p2 = hole()                    // make room for jump dest
        codeGen(x.right)               // statements
        emitByte(jmp)                  // back to the top
        emitWord(p1 - len(object))     // plug the top
        emitWordAt(p2, len(object)-p2) // plug the 'if false, jump'
    case ndSequence:
        codeGen(x.left)
        codeGen(x.right)
    case ndPrtc:
        codeGen(x.left)
        emitByte(prtc)
    case ndPrti:
        codeGen(x.left)
        emitByte(prti)
    case ndPrts:
        codeGen(x.left)
        emitByte(prts)
    case ndLss, ndGtr, ndLeq, ndGeq, ndEql, ndNeq,
        ndAnd, ndOr, ndSub, ndAdd, ndDiv, ndMul, ndMod:
        codeGen(x.left)
        codeGen(x.right)
        emitByte(nodeType2Op(x.nodeType))
    case ndNegate, ndNot:
        codeGen(x.left)
        emitByte(nodeType2Op(x.nodeType))
    default:
        msg := fmt.Sprintf(""error in code generator - found %d, expecting operator\n"", x.nodeType)
        reportError(msg)
    }
}
 
func codeFinish() {
    emitByte(halt)
}
 
func listCode() {
    fmt.Printf(""Datasize: %d Strings: %d\n"", len(globals), len(stringPool))
    for _, s := range stringPool {
        fmt.Println(s)
    }
    pc := 0
    for pc < len(object) {
        fmt.Printf(""%5d "", pc)
        op := object[pc]
        pc++
        switch op {
        case fetch:
            x := int32(binary.LittleEndian.Uint32(object[pc : pc+4]))
            fmt.Printf(""fetch [%d]\n"", x)
            pc += 4
        case store:
            x := int32(binary.LittleEndian.Uint32(object[pc : pc+4]))
            fmt.Printf(""store [%d]\n"", x)
            pc += 4
        case push:
            x := int32(binary.LittleEndian.Uint32(object[pc : pc+4]))
            fmt.Printf(""push  %d\n"", x)
            pc += 4
        case add:
            fmt.Println(""add"")
        case sub:
            fmt.Println(""sub"")
        case mul:
            fmt.Println(""mul"")
        case div:
            fmt.Println(""div"")
        case mod:
            fmt.Println(""mod"")
        case lt:
            fmt.Println(""lt"")
        case gt:
            fmt.Println(""gt"")
        case le:
            fmt.Println(""le"")
        case ge:
            fmt.Println(""ge"")
        case eq:
            fmt.Println(""eq"")
        case ne:
            fmt.Println(""ne"")
        case and:
            fmt.Println(""and"")
        case or:
            fmt.Println(""or"")
        case neg:
            fmt.Println(""neg"")
        case not:
            fmt.Println(""not"")
        case jmp:
            x := int32(binary.LittleEndian.Uint32(object[pc : pc+4]))
            fmt.Printf(""jmp    (%d) %d\n"", x, int32(pc)+x)
            pc += 4
        case jz:
            x := int32(binary.LittleEndian.Uint32(object[pc : pc+4]))
            fmt.Printf(""jz     (%d) %d\n"", x, int32(pc)+x)
            pc += 4
        case prtc:
            fmt.Println(""prtc"")
        case prti:
            fmt.Println(""prti"")
        case prts:
            fmt.Println(""prts"")
        case halt:
            fmt.Println(""halt"")
        default:
            reportError(fmt.Sprintf(""listCode: Unknown opcode %d"", op))
        }
    }
}
 
func getEnumValue(name string) NodeType {
    for _, atr := range atrs {
        if atr.enumText == name {
            return atr.nodeType
        }
    }
    reportError(fmt.Sprintf(""Unknown token %s\n"", name))
    return -1
}
 
func loadAst() *Tree {
    var nodeType NodeType
    var s string
    if scanner.Scan() {
        line := strings.TrimRight(scanner.Text(), "" \t"")
        tokens := strings.Fields(line)
        first := tokens[0]
        if first[0] == ';' {
            return nil
        }
        nodeType = getEnumValue(first)
        le := len(tokens)
        if le == 2 {
            s = tokens[1]
        } else if le > 2 {
            idx := strings.Index(line, `""`)
            s = line[idx:]
        }
    }
    check(scanner.Err())
    if s != """" {
        return makeLeaf(nodeType, s)
    }
    left := loadAst()
    right := loadAst()
    return makeNode(nodeType, left, right)
}
 
func main() {
    ast, err := os.Open(""ast.txt"")
    check(err)
    defer ast.Close()
    scanner = bufio.NewScanner(ast)
    codeGen(loadAst())
    codeFinish()
    listCode()
}",8602,393
66820,http://rosettacode.org/wiki/Combinations_and_permutations,Combinations and permutations,"

 This page uses content from Wikipedia. The original article was at Combination. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



 This page uses content from Wikipedia. The original article was at Permutation. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

Task

Implement the combination    (nCk)    and permutation    (nPk)    operators in the target language:

 






n



C

k


=



(


n
k


)



=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle ^{n}\operatorname {C} _{k}={\binom {n}{k}}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}


 






n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




See the Wikipedia articles for a more detailed description.

To test, generate and print examples of:

   A sample of permutations from 1 to 12 and Combinations from 10 to 60 using exact Integer arithmetic.
   A sample of permutations from 5 to 15000 and Combinations from 100 to 1000 using approximate Floating point arithmetic.
 This 'floating point' code could be implemented using an approximation, e.g., by calling the Gamma function.


Related task

   Evaluate binomial coefficients



 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",#Go,Go," 
package main
 
import (
	""fmt""
	""math/big""
)
 
func main() {
	var n, p int64
	fmt.Printf(""A sample of permutations from 1 to 12:\n"")
	for n = 1; n < 13; n++ {
		p = n / 3
		fmt.Printf(""P(%d,%d) = %d\n"", n, p, perm(big.NewInt(n), big.NewInt(p)))
	}
	fmt.Printf(""\nA sample of combinations from 10 to 60:\n"")
	for n = 10; n < 61; n += 10 {
		p = n / 3
		fmt.Printf(""C(%d,%d) = %d\n"", n, p, comb(big.NewInt(n), big.NewInt(p)))
	}
	fmt.Printf(""\nA sample of permutations from 5 to 15000:\n"")
	nArr := [...]int64{5, 50, 500, 1000, 5000, 15000}
	for _, n = range nArr {
		p = n / 3
		fmt.Printf(""P(%d,%d) = %d\n"", n, p, perm(big.NewInt(n), big.NewInt(p)))
	}
	fmt.Printf(""\nA sample of combinations from 100 to 1000:\n"")
	for n = 100; n < 1001; n += 100 {
		p = n / 3
		fmt.Printf(""C(%d,%d) = %d\n"", n, p, comb(big.NewInt(n), big.NewInt(p)))
	}
}
 
func fact(n *big.Int) *big.Int {
	if n.Sign() < 1 {
		return big.NewInt(0)
	}
	r := big.NewInt(1)
	i := big.NewInt(2)
	for i.Cmp(n) < 1 {
		r.Mul(r, i)
		i.Add(i, big.NewInt(1))
	}
	return r
}
 
func perm(n, k *big.Int) *big.Int {
	r := fact(n)
	r.Div(r, fact(n.Sub(n, k)))
	return r
}
 
func comb(n, r *big.Int) *big.Int {
	if r.Cmp(n) == 1 {
		return big.NewInt(0)
	}
	if r.Cmp(n) == 0 {
		return big.NewInt(1)
	}
	c := fact(n)
	den := fact(n.Sub(n, r))
	den.Mul(den, fact(r))
	c.Div(c, den)
	return c
}
 ",1352,66
66873,http://rosettacode.org/wiki/Compare_a_list_of_strings,Compare a list of strings,"Task

Given a   list   of arbitrarily many strings, show how to:

   test if they are all lexically equal
   test if every string is lexically less than the one after it (i.e. whether the list is in strict ascending order)


Each of those two tests should result in a single true or false value, which could be used as the condition of an    if    statement or similar.

If the input list has less than two elements, the tests should always return true.

There is no need to provide a complete program and output.

Assume that the strings are already stored in an array/list/sequence/tuple variable (whatever is most idiomatic) with the name   strings,   and just show the expressions for performing those two tests on it (plus of course any includes and custom functions etc. that it needs),   with as little distractions as possible.

Try to write your solution in a way that does not modify the original list,   but if it does then please add a note to make that clear to readers.

If you need further guidance/clarification,   see #Perl and #Python for solutions that use implicit short-circuiting loops,   and #Raku for a solution that gets away with simply using a built-in language feature. 




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package cmp
 
func AllEqual(strings []string) bool {
	for _, s := range strings {
		if s != strings[0] {
			return false
		}
	}
	return true
}
 
func AllLessThan(strings []string) bool {
	for i := 1; i < len(strings); i++ {
		if !(strings[i - 1] < s) {
			return false
		}
	}
	return true
}",290,19
66959,http://rosettacode.org/wiki/Compiler/lexical_analyzer,Compiler/lexical analyzer,"Definition from Wikipedia:

 Lexical analysis is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of tokens (strings with an identified ""meaning""). A program that performs lexical analysis may be called a lexer, tokenizer, or scanner (though ""scanner"" is also used to refer to the first stage of a lexer).
Task[edit]
Create a lexical analyzer for the simple programming language specified below. The
program should read input from a file and/or stdin, and write output to a file and/or
stdout. If the language being used has a lexer module/library/class, it would be great
if two versions of the solution are provided: One without the lexer module, and one with.

Input Specification
The simple programming language to be analyzed is more or less a subset of C. It supports the following tokens:

Operators


 Name 
 Common name 
 Character sequence


 Op_multiply 
 multiply 
 *


 Op_divide 
 divide 
 /


 Op_mod 
 mod 
 %


 Op_add 
 plus 
 +


 Op_subtract 
 minus 
 -


 Op_negate 
 unary minus 
 -


 Op_less 
 less than 
 <


 Op_lessequal 
 less than or equal 
 <=


 Op_greater 
 greater than 
 >


 Op_greaterequal 
 greater than or equal 
 >=


 Op_equal 
 equal 
 ==


 Op_notequal 
 not equal 
 !=


 Op_not 
 unary not 
 !


 Op_assign 
 assignment 
 =


 Op_and 
 logical and 
 &&


 Op_or 
 logical or 
 ¦¦

 The - token should always be interpreted as Op_subtract by the lexer. Turning some Op_subtract into Op_negate will be the job of the syntax analyzer, which is not part of this task.
Symbols


 Name 
 Common name 
 Character


 LeftParen 
 left parenthesis 
 (


 RightParen 
 right parenthesis 
 )


 LeftBrace 
 left brace 
 {


 RightBrace 
 right brace 
 }


 Semicolon 
 semi-colon 
 ;


 Comma 
 comma 
 ,

Keywords


 Name 
 Character sequence


 Keyword_if 
 if


 Keyword_else 
 else


 Keyword_while 
 while


 Keyword_print 
 print


 Keyword_putc 
 putc

Identifiers and literals
These differ from the the previous tokens, in that each occurrence of them has a value associated with it.



 Name

 Common name

 Format description

 Format regex

 Value


 Identifier

 identifier

 one or more letter/number/underscore characters, but not starting with a number

 [_a-zA-Z][_a-zA-Z0-9]*

 as is


 Integer

 integer literal

 one or more digits

 [0-9]+

 as is, interpreted as a number


 Integer

 char literal

 exactly one character (anything except newline or single quote) or one of the allowed escape sequences, enclosed by single quotes

 '([^'\n]|\\n|\\\\)'

 the ASCII code point number of the character, e.g. 65 for 'A' and 10 for '\n'


 String

 string literal

 zero or more characters (anything except newline or double quote), enclosed by double quotes

 ""[^""\n]*""

 the characters without the double quotes and with escape sequences converted

 For char and string literals, the \n escape sequence is supported to represent a new-line character.
 For char and string literals, to represent a backslash, use \\.
 No other special sequences are supported. This means that:
 Char literals cannot represent a single quote character (value 39).
 String literals cannot represent strings containing double quote characters.
Zero-width tokens


 Name 
 Location


 End_of_input 
 when the end of the input stream is reached

White space
 Zero or more whitespace characters, or comments enclosed in /* ... */, are allowed between any two tokens, with the exceptions noted below.
 ""Longest token matching"" is used to resolve conflicts (e.g., in order to match <= as a single token rather than the two tokens < and =).
 Whitespace is required between two tokens that have an alphanumeric character or underscore at the edge.
 This means: keywords, identifiers, and integer literals.
 e.g. ifprint is recognized as an identifier, instead of the keywords if and print.
 e.g. 42fred is invalid, and neither recognized as a number nor an identifier.
 Whitespace is not allowed inside of tokens (except for chars and strings where they are part of the value).
 e.g. & & is invalid, and not interpreted as the && operator.
For example, the following two program fragments are equivalent, and should produce the same token stream except for the line and column positions:

 if ( p /* meaning n is prime */ ) {
    print ( n , "" "" ) ;
    count = count + 1 ; /* number of primes found so far */
}
 if(p){print(n,"" "");count=count+1;}
Complete list of token names
End_of_input  Op_multiply   Op_divide     Op_mod       Op_add     Op_subtract
Op_negate     Op_not        Op_less       Op_lessequal Op_greater Op_greaterequal
Op_equal      Op_notequal   Op_assign     Op_and       Op_or      Keyword_if
Keyword_else  Keyword_while Keyword_print Keyword_putc LeftParen  RightParen
LeftBrace     RightBrace    Semicolon     Comma        Identifier Integer
String

Output Format
The program output should be a sequence of lines, each consisting of the following whitespace-separated fields:

 the line number where the token starts
 the column number where the token starts
 the token name
 the token value (only for Identifier, Integer, and String tokens)
 the number of spaces between fields is up to you. Neatly aligned is nice, but not a requirement.


This task is intended to be used as part of a pipeline, with the other compiler tasks - for example:

lex < hello.t | parse | gen | vm

Or possibly:

lex hello.t lex.out
parse lex.out parse.out
gen parse.out gen.out
vm gen.out



This implies that the output of this task (the lexical analyzer) should be suitable as input to any of the Syntax Analyzer task programs.

Diagnostics
The following error conditions should be caught:



 Error

 Example


 Empty character constant

 ''


 Unknown escape sequence.

 \r


 Multi-character constant.

 'xx'


 End-of-file in comment. Closing comment characters not found.


 End-of-file while scanning string literal. Closing string character not found.


 End-of-line while scanning string literal. Closing string character not found before end-of-line.


 Unrecognized character.

 |


 Invalid number. Starts like a number, but ends in non-numeric characters.

 123abc

Test Cases


 Input

 Output



Test Case 1:

/*
  Hello world
 */
print(""Hello, World!\n"");


    4      1 Keyword_print
    4      6 LeftParen
    4      7 String         ""Hello, World!\n""
    4     24 RightParen
    4     25 Semicolon
    5      1 End_of_input




Test Case 2:

/*
  Show Ident and Integers
 */
phoenix_number = 142857;
print(phoenix_number, ""\n"");


    4      1 Identifier     phoenix_number
    4     16 Op_assign
    4     18 Integer         142857
    4     24 Semicolon
    5      1 Keyword_print
    5      6 LeftParen
    5      7 Identifier     phoenix_number
    5     21 Comma
    5     23 String         ""\n""
    5     27 RightParen
    5     28 Semicolon
    6      1 End_of_input




Test Case 3:

/*
  All lexical tokens - not syntactically correct, but that will
  have to wait until syntax analysis
 */
/* Print   */  print    /* Sub     */  -
/* Putc    */  putc     /* Lss     */  <
/* If      */  if       /* Gtr     */  >
/* Else    */  else     /* Leq     */  <=
/* While   */  while    /* Geq     */  >=
/* Lbrace  */  {        /* Eq      */  ==
/* Rbrace  */  }        /* Neq     */  !=
/* Lparen  */  (        /* And     */  &&
/* Rparen  */  )        /* Or      */  ||
/* Uminus  */  -        /* Semi    */  ;
/* Not     */  !        /* Comma   */  ,
/* Mul     */  *        /* Assign  */  =
/* Div     */  /        /* Integer */  42
/* Mod     */  %        /* String  */  ""String literal""
/* Add     */  +        /* Ident   */  variable_name
/* character literal */  '\n'
/* character literal */  '\\'
/* character literal */  ' '


    5     16   Keyword_print
    5     40   Op_subtract
    6     16   Keyword_putc
    6     40   Op_less
    7     16   Keyword_if
    7     40   Op_greater
    8     16   Keyword_else
    8     40   Op_lessequal
    9     16   Keyword_while
    9     40   Op_greaterequal
   10     16   LeftBrace
   10     40   Op_equal
   11     16   RightBrace
   11     40   Op_notequal
   12     16   LeftParen
   12     40   Op_and
   13     16   RightParen
   13     40   Op_or
   14     16   Op_subtract
   14     40   Semicolon
   15     16   Op_not
   15     40   Comma
   16     16   Op_multiply
   16     40   Op_assign
   17     16   Op_divide
   17     40   Integer             42
   18     16   Op_mod
   18     40   String          ""String literal""
   19     16   Op_add
   19     40   Identifier      variable_name
   20     26   Integer             10
   21     26   Integer             92
   22     26   Integer             32
   23      1   End_of_input




Test Case 4:

/*** test printing, embedded \n and comments with lots of '*' ***/
print(42);
print(""\nHello World\nGood Bye\nok\n"");
print(""Print a slash n - \\n.\n"");


    2      1 Keyword_print
    2      6 LeftParen
    2      7 Integer            42
    2      9 RightParen
    2     10 Semicolon
    3      1 Keyword_print
    3      6 LeftParen
    3      7 String          ""\nHello World\nGood Bye\nok\n""
    3     38 RightParen
    3     39 Semicolon
    4      1 Keyword_print
    4      6 LeftParen
    4      7 String          ""Print a slash n - \\n.\n""
    4     33 RightParen
    4     34 Semicolon
    5      1 End_of_input


Additional examples
Your solution should pass all the test cases above and the additional tests found Here.



Reference
The C and Python versions can be considered reference implementations.



Related Tasks
 Syntax Analyzer task
 Code Generator task
 Virtual Machine Interpreter task
 AST Interpreter task


",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""log""
    ""os""
)
 
type TokenType int
 
const (
    tkEOI TokenType = iota
    tkMul
    tkDiv
    tkMod
    tkAdd
    tkSub
    tkNegate
    tkNot
    tkLss
    tkLeq
    tkGtr
    tkGeq
    tkEq
    tkNeq
    tkAssign
    tkAnd
    tkOr
    tkIf
    tkElse
    tkWhile
    tkPrint
    tkPutc
    tkLparen
    tkRparen
    tkLbrace
    tkRbrace
    tkSemi
    tkComma
    tkIdent
    tkInteger
    tkString
)
 
type Symbol struct {
    name string
    tok  TokenType
}
 
// symbol table
var symtab []Symbol
 
var scanner *bufio.Scanner
 
var (
    curLine = """"
    curCh   byte
    lineNum = 0
    colNum  = 0
)
 
const etx byte = 4 // used to signify EOI
 
func isDigit(ch byte) bool {
    return ch >= '0' && ch <= '9'
}
 
func isAlnum(ch byte) bool {
    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || isDigit(ch)
}
 
func errorMsg(eline, ecol int, msg string) {
    log.Fatalf(""(%d:%d) %s"", eline, ecol, msg)
}
 
// add an identifier to the symbol table
func install(name string, tok TokenType) {
    sym := Symbol{name, tok}
    symtab = append(symtab, sym)
}
 
// search for an identifier in the symbol table
func lookup(name string) int {
    for i := 0; i < len(symtab); i++ {
        if symtab[i].name == name {
            return i
        }
    }
    return -1
}
 
// read the next line of input from the source file
func nextLine() {
    if scanner.Scan() {
        curLine = scanner.Text()
        lineNum++
        colNum = 0
        if curLine == """" { // skip blank lines
            nextLine()
        }
    } else {
        err := scanner.Err()
        if err == nil { // EOF
            curCh = etx
            curLine = """"
            lineNum++
            colNum = 1
        } else {
            log.Fatal(err)
        }
    }
}
 
// get the next char
func nextChar() {
    if colNum >= len(curLine) {
        nextLine()
    }
    if colNum < len(curLine) {
        curCh = curLine[colNum]
        colNum++
    }
}
 
func follow(eline, ecol int, expect byte, ifyes, ifno TokenType) TokenType {
    if curCh == expect {
        nextChar()
        return ifyes
    }
    if ifno == tkEOI {
        errorMsg(eline, ecol, ""follow unrecognized character: ""+string(curCh))
    }
    return ifno
}
 
func gettok() (eline, ecol int, tok TokenType, v string) {
    // skip whitespace
    for curCh == ' ' || curCh == '\t' || curCh == '\n' {
        nextChar()
    }
    eline = lineNum
    ecol = colNum
    switch curCh {
    case etx:
        tok = tkEOI
        return
    case '{':
        tok = tkLbrace
        nextChar()
        return
    case '}':
        tok = tkRbrace
        nextChar()
        return
    case '(':
        tok = tkLparen
        nextChar()
        return
    case ')':
        tok = tkRparen
        nextChar()
        return
    case '+':
        tok = tkAdd
        nextChar()
        return
    case '-':
        tok = tkSub
        nextChar()
        return
    case '*':
        tok = tkMul
        nextChar()
        return
    case '%':
        tok = tkMod
        nextChar()
        return
    case ';':
        tok = tkSemi
        nextChar()
        return
    case ',':
        tok = tkComma
        nextChar()
        return
    case '/': // div or comment
        nextChar()
        if curCh != '*' {
            tok = tkDiv
            return
        }
        // skip comments
        nextChar()
        for {
            if curCh == '*' {
                nextChar()
                if curCh == '/' {
                    nextChar()
                    eline, ecol, tok, v = gettok()
                    return
                }
            } else if curCh == etx {
                errorMsg(eline, ecol, ""EOF in comment"")
            } else {
                nextChar()
            }
        }
    case '\'': // single char literals
        nextChar()
        v = fmt.Sprintf(""%d"", curCh)
        if curCh == '\'' {
            errorMsg(eline, ecol, ""Empty character constant"")
        }
        if curCh == '\\' {
            nextChar()
            if curCh == 'n' {
                v = ""10""
            } else if curCh == '\\' {
                v = ""92""
            } else {
                errorMsg(eline, ecol, ""unknown escape sequence: ""+string(curCh))
            }
        }
        nextChar()
        if curCh != '\'' {
            errorMsg(eline, ecol, ""multi-character constant"")
        }
        nextChar()
        tok = tkInteger
        return
    case '<':
        nextChar()
        tok = follow(eline, ecol, '=', tkLeq, tkLss)
        return
    case '>':
        nextChar()
        tok = follow(eline, ecol, '=', tkGeq, tkGtr)
        return
    case '!':
        nextChar()
        tok = follow(eline, ecol, '=', tkNeq, tkNot)
        return
    case '=':
        nextChar()
        tok = follow(eline, ecol, '=', tkEq, tkAssign)
        return
    case '&':
        nextChar()
        tok = follow(eline, ecol, '&', tkAnd, tkEOI)
        return
    case '|':
        nextChar()
        tok = follow(eline, ecol, '|', tkOr, tkEOI)
        return
    case '""': // string
        v = string(curCh)
        nextChar()
        for curCh != '""' {
            if curCh == '\n' {
                errorMsg(eline, ecol, ""EOL in string"")
            }
            if curCh == etx {
                errorMsg(eline, ecol, ""EOF in string"")
            }
            v += string(curCh)
            nextChar()
        }
        v += string(curCh)
        nextChar()
        tok = tkString
        return
    default: // integers or identifiers
        isNumber := isDigit(curCh)
        v = """"
        for isAlnum(curCh) || curCh == '_' {
            if !isDigit(curCh) {
                isNumber = false
            }
            v += string(curCh)
            nextChar()
        }
        if len(v) == 0 {
            errorMsg(eline, ecol, ""unknown character: ""+string(curCh))
        }
        if isDigit(v[0]) {
            if !isNumber {
                errorMsg(eline, ecol, ""invalid number: ""+string(curCh))
            }
            tok = tkInteger
            return
        }
        index := lookup(v)
        if index == -1 {
            tok = tkIdent
        } else {
            tok = symtab[index].tok
        }
        return
    }
}
 
func initLex() {
    install(""else"", tkElse)
    install(""if"", tkIf)
    install(""print"", tkPrint)
    install(""putc"", tkPutc)
    install(""while"", tkWhile)
    nextChar()
}
 
func process() {
    tokMap := make(map[TokenType]string)
    tokMap[tkEOI] = ""End_of_input""
    tokMap[tkMul] = ""Op_multiply""
    tokMap[tkDiv] = ""Op_divide""
    tokMap[tkMod] = ""Op_mod""
    tokMap[tkAdd] = ""Op_add""
    tokMap[tkSub] = ""Op_subtract""
    tokMap[tkNegate] = ""Op_negate""
    tokMap[tkNot] = ""Op_not""
    tokMap[tkLss] = ""Op_less""
    tokMap[tkLeq] = ""Op_lessequal""
    tokMap[tkGtr] = ""Op_greater""
    tokMap[tkGeq] = ""Op_greaterequal""
    tokMap[tkEq] = ""Op_equal""
    tokMap[tkNeq] = ""Op_notequal""
    tokMap[tkAssign] = ""Op_assign""
    tokMap[tkAnd] = ""Op_and""
    tokMap[tkOr] = ""Op_or""
    tokMap[tkIf] = ""Keyword_if""
    tokMap[tkElse] = ""Keyword_else""
    tokMap[tkWhile] = ""Keyword_while""
    tokMap[tkPrint] = ""Keyword_print""
    tokMap[tkPutc] = ""Keyword_putc""
    tokMap[tkLparen] = ""LeftParen""
    tokMap[tkRparen] = ""RightParen""
    tokMap[tkLbrace] = ""LeftBrace""
    tokMap[tkRbrace] = ""RightBrace""
    tokMap[tkSemi] = ""Semicolon""
    tokMap[tkComma] = ""Comma""
    tokMap[tkIdent] = ""Identifier""
    tokMap[tkInteger] = ""Integer""
    tokMap[tkString] = ""String""
 
    for {
        eline, ecol, tok, v := gettok()
        fmt.Printf(""%5d  %5d %-16s"", eline, ecol, tokMap[tok])
        if tok == tkInteger || tok == tkIdent || tok == tkString {
            fmt.Println(v)
        } else {
            fmt.Println()
        }
        if tok == tkEOI {
            return
        }
    }
}
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func main() {
    if len(os.Args) < 2 {
        fmt.Println(""Filename required"")
        return
    }
    f, err := os.Open(os.Args[1])
    check(err)
    defer f.Close()
    scanner = bufio.NewScanner(f)
    initLex()
    process()
}",8184,378
66972,http://rosettacode.org/wiki/Combinations_with_repetitions,Combinations with repetitions,"The set of combinations with repetitions is computed from a set, 



S


{\displaystyle S}

 (of cardinality 



n


{\displaystyle n}

), and a size of resulting selection, 



k


{\displaystyle k}

, by reporting the sets of cardinality 



k


{\displaystyle k}

 where each member of those sets is chosen from 



S


{\displaystyle S}

.
In the real world, it is about choosing sets where there is a “large” supply of each type of element and where the order of choice does not matter.
For example:

Q: How many ways can a person choose two doughnuts from a store selling three types of doughnut: iced, jam, and plain? (i.e., 



S


{\displaystyle S}

 is 



{

i
c
e
d

,

j
a
m

,

p
l
a
i
n

}


{\displaystyle \{\mathrm {iced} ,\mathrm {jam} ,\mathrm {plain} \}}

, 




|

S

|

=
3


{\displaystyle |S|=3}

, and 



k
=
2


{\displaystyle k=2}

.)
A: 6: {iced, iced}; {iced, jam}; {iced, plain}; {jam, jam}; {jam, plain}; {plain, plain}.
Note that both the order of items within a pair, and the order of the pairs given in the answer is not significant; the pairs represent multisets.
Also note that doughnut can also be spelled donut.



Task

 Write a function/program/routine/.. to generate all the combinations with repetitions of 



n


{\displaystyle n}

 types of things taken 



k


{\displaystyle k}

 at a time and use it to show an answer to the doughnut example above.
 For extra credit, use the function to compute and show just the number of ways of choosing three doughnuts from a choice of ten types of doughnut. Do not show the individual choices for this part.


References

 k-combination with repetitions


See also


 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",#Go,Go,"package main
 
import ""fmt""
 
func combrep(n int, lst []string) [][]string {
    if n == 0 {
        return [][]string{nil}
    }
    if len(lst) == 0 {
        return nil
    }
    r := combrep(n, lst[1:])
    for _, x := range combrep(n-1, lst) {
        r = append(r, append(x, lst[0]))
    }
    return r
}
 
func main() {
    fmt.Println(combrep(2, []string{""iced"", ""jam"", ""plain""}))
    fmt.Println(len(combrep(3,
        []string{""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9"", ""10""})))
}",492,23
67044,http://rosettacode.org/wiki/Command-line_arguments,Command-line arguments,"Command-line arguments is part of Short Circuit's Console Program Basics selection.
Scripted main
See also Program name.

For parsing command line arguments intelligently, see Parsing command-line arguments.

Example command line:

myprogram -c ""alpha beta"" -h ""gamma""
",#Go,Go," 
package main
import (
	""fmt""
	""os""
)
 
func main() {
	for i, x := range os.Args[1:] {
		fmt.Printf(""the argument #%d is %s\n"", i, x)
	}
}
 ",141,13
67048,http://rosettacode.org/wiki/Conway%27s_Game_of_Life,Conway's Game of Life,"The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.

Conway's game of life is described   here:

A cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.

We calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:

   C   N                 new C
   1   0,1             ->  0  # Lonely
   1   4,5,6,7,8       ->  0  # Overcrowded
   1   2,3             ->  1  # Lives
   0   3               ->  1  # It takes three to give birth!
   0   0,1,2,4,5,6,7,8 ->  0  # Barren

Assume cells beyond the boundary are always dead.

The ""game"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.



Task

Although you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.



References

   Its creator John Conway, explains   the game of life.   Video from numberphile on youtube.
   John Conway   Inventing Game of Life   - Numberphile video.


Related task

   Langton's ant   - another well known cellular automaton.

",#Go,Go,"package main
 
import (
	""bytes""
	""fmt""
	""math/rand""
	""time""
)
 
type Field struct {
	s    [][]bool
	w, h int
}
 
func NewField(w, h int) Field {
	s := make([][]bool, h)
	for i := range s {
		s[i] = make([]bool, w)
	}
	return Field{s: s, w: w, h: h}
}
 
func (f Field) Set(x, y int, b bool) {
	f.s[y][x] = b
}
 
func (f Field) Next(x, y int) bool {
	on := 0
	for i := -1; i <= 1; i++ {
		for j := -1; j <= 1; j++ {
			if f.State(x+i, y+j) && !(j == 0 && i == 0) {
				on++
			}
		}
	}
	return on == 3 || on == 2 && f.State(x, y)
}
 
func (f Field) State(x, y int) bool {
	for y < 0 {
		y += f.h
	}
	for x < 0 {
		x += f.w
	}
	return f.s[y%f.h][x%f.w]
}
 
type Life struct {
	w, h int
	a, b Field
}
 
func NewLife(w, h int) *Life {
	a := NewField(w, h)
	for i := 0; i < (w * h / 2); i++ {
		a.Set(rand.Intn(w), rand.Intn(h), true)
	}
	return &Life{
		a: a,
		b: NewField(w, h),
		w: w, h: h,
	}
}
 
func (l *Life) Step() {
	for y := 0; y < l.h; y++ {
		for x := 0; x < l.w; x++ {
			l.b.Set(x, y, l.a.Next(x, y))
		}
	}
	l.a, l.b = l.b, l.a
}
 
func (l *Life) String() string {
	var buf bytes.Buffer
	for y := 0; y < l.h; y++ {
		for x := 0; x < l.w; x++ {
			b := byte(' ')
			if l.a.State(x, y) {
				b = '*'
			}
			buf.WriteByte(b)
		}
		buf.WriteByte('\n')
	}
	return buf.String()
}
 
func main() {
	l := NewLife(80, 15)
	for i := 0; i < 300; i++ {
		l.Step()
		fmt.Print(""\x0c"")
		fmt.Println(l)
		time.Sleep(time.Second / 30)
	}
}",1436,98
67117,http://rosettacode.org/wiki/Comma_quibbling,Comma quibbling,"Comma quibbling is a task originally set by Eric Lippert in his blog.



Task

Write a function to generate a string output which is the concatenation of input words from a list/sequence where:

 An input of no words produces the output string of just the two brace characters ""{}"".
 An input of just one word, e.g. [""ABC""], produces the output string of the word inside the two braces, e.g. ""{ABC}"".
 An input of two words, e.g. [""ABC"", ""DEF""], produces the output string of the two words inside the two braces with the words separated by the string "" and "", e.g. ""{ABC and DEF}"".
 An input of three or more words, e.g. [""ABC"", ""DEF"", ""G"", ""H""], produces the output string of all but the last word separated by "", "" with the last word separated by "" and "" and all within braces; e.g. ""{ABC, DEF, G and H}"".


Test your function with the following series of inputs showing your output here on this page:

 [] # (No input words).
 [""ABC""]
 [""ABC"", ""DEF""]
 [""ABC"", ""DEF"", ""G"", ""H""]


Note: Assume words are non-empty strings of uppercase characters for this task.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func q(s []string) string {
    switch len(s) {
    case 0:
        return ""{}""
    case 1:
        return ""{"" + s[0] + ""}""
    case 2:
        return ""{"" + s[0] + "" and "" + s[1] + ""}""
    default:
        return ""{"" +
            strings.Join(s[:len(s)-1], "", "") +
            "" and "" +
            s[len(s)-1] +
            ""}""
    }
}
 
func main() {
    fmt.Println(q([]string{}))
    fmt.Println(q([]string{""ABC""}))
    fmt.Println(q([]string{""ABC"", ""DEF""}))
    fmt.Println(q([]string{""ABC"", ""DEF"", ""G"", ""H""}))
}",570,30
67364,http://rosettacode.org/wiki/Comments,Comments,"Task

Show all ways to include text in a language source file
that's completely ignored by the compiler or interpreter.



Related tasks

   Documentation
   Here_document


See also

   Wikipedia
   xkcd (Humor: hand gesture denoting // for ""commenting out"" people.)

",#Go,Go,"// this is a single line comment
/* this is
   a multi-line
   block comment.
/* It does not nest */",100,5
67400,http://rosettacode.org/wiki/Conditional_structures,Conditional structures,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops

Task

List the conditional structures offered by a programming language. See Wikipedia: conditionals for descriptions.

Common conditional structures include if-then-else and switch.

Less common are arithmetic if, ternary operator and Hash-based conditionals.

Arithmetic if allows tight control over computed gotos, which optimizers have a hard time to figure out.


",#Go,Go,"if booleanExpression {
    statements
}",39,3
67518,http://rosettacode.org/wiki/Colorful_numbers,Colorful numbers,"A colorful number is a non-negative base 10 integer where the product of every sub group of consecutive digits is unique.



E.G.
24753 is a colorful number. 2, 4, 7, 5, 3, (2×4)8, (4×7)28, (7×5)35, (5×3)15, (2×4×7)56, (4×7×5)140, (7×5×3)105, (2×4×7×5)280, (4×7×5×3)420, (2×4×7×5×3)840

Every product is unique.



2346 is not a colorful number. 2, 3, 4, 6, (2×3)6, (3×4)12, (4×6)24, (2×3×4)48, (3×4×6)72, (2×3×4×6)144

The product 6 is repeated.



Single digit numbers are considered to be colorful. A colorful number larger than 9 cannot contain a repeated digit, the digit 0 or the digit 1. As a consequence, there is a firm upper limit for colorful numbers; no colorful number can have more than 8 digits.



Task
 Write a routine (subroutine, function, procedure, whatever it may be called in your language) to test if a number is a colorful number or not.
 Use that routine to find all of the colorful numbers less than 100.
 Use that routine to find the largest possible colorful number.


Stretch
 Find and display the count of colorful numbers in each order of magnitude.
 Find and show the total count of all colorful numbers.

Colorful numbers have no real number theory application. They are more a recreational math puzzle than a useful tool.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""rcu""
    ""strconv""
)
 
func isColorful(n int) bool {
    if n < 0 {
        return false
    }
    if n < 10 {
        return true
    }
    digits := rcu.Digits(n, 10)
    for _, d := range digits {
        if d == 0 || d == 1 {
            return false
        }
    }
    set := make(map[int]bool)
    for _, d := range digits {
        set[d] = true
    }
    dc := len(digits)
    if len(set) < dc {
        return false
    }
    for k := 2; k <= dc; k++ {
        for i := 0; i <= dc-k; i++ {
            prod := 1
            for j := i; j <= i+k-1; j++ {
                prod *= digits[j]
            }
            if ok := set[prod]; ok {
                return false
            }
            set[prod] = true
        }
    }
    return true
}
 
var count = make([]int, 9)
var used = make([]bool, 11)
var largest = 0
 
func countColorful(taken int, n string) {
    if taken == 0 {
        for digit := 0; digit < 10; digit++ {
            dx := digit + 1
            used[dx] = true
            t := 1
            if digit < 2 {
                t = 9
            }
            countColorful(t, string(digit+48))
            used[dx] = false
        }
    } else {
        nn, _ := strconv.Atoi(n)
        if isColorful(nn) {
            ln := len(n)
            count[ln]++
            if nn > largest {
                largest = nn
            }
        }
        if taken < 9 {
            for digit := 2; digit < 10; digit++ {
                dx := digit + 1
                if !used[dx] {
                    used[dx] = true
                    countColorful(taken+1, n+string(digit+48))
                    used[dx] = false
                }
            }
        }
    }
}
 
func main() {
    var cn []int
    for i := 0; i < 100; i++ {
        if isColorful(i) {
            cn = append(cn, i)
        }
    }
    fmt.Println(""The"", len(cn), ""colorful numbers less than 100 are:"")
    for i := 0; i < len(cn); i++ {
        fmt.Printf(""%2d "", cn[i])
        if (i+1)%10 == 0 {
            fmt.Println()
        }
    }
 
    countColorful(0, """")
    fmt.Println(""\n\nThe largest possible colorful number is:"")
    fmt.Println(rcu.Commatize(largest))
 
    fmt.Println(""\nCount of colorful numbers for each order of magnitude:"")
    pow := 10
    for dc := 1; dc < len(count); dc++ {
        cdc := rcu.Commatize(count[dc])
        pc := 100 * float64(count[dc]) / float64(pow)
        fmt.Printf(""  %d digit colorful number count: %6s - %7.3f%%\n"", dc, cdc, pc)
        if pow == 10 {
            pow = 90
        } else {
            pow *= 10
        }
    }
 
    sum := 0
    for _, c := range count {
        sum += c
    }
    fmt.Printf(""\nTotal colorful numbers: %s\n"", rcu.Commatize(sum))
}",2756,120
67542,http://rosettacode.org/wiki/Colour_pinstripe/Printer,Colour pinstripe/Printer,"The task is to create 1 point wide colour vertical pinstripes with a sufficient number of pinstripes to span the entire width of the colour graphics printer. The pinstripes should alternate between each individual cartridge ink and ink pair and black and white pinstripes should be included. A typical pinstripe sequence woud be black, red, green, blue, magenta, cyan, yellow, white.

After the first inch of printing, we switch to a wider 2 pixel wide vertical pinstripe pattern. and to 3 point wide vertical for the next inch, and then 4 point wide, etc. This trend continues for the entire length of the page (or for 12 inches of run length in the case of a printer using continuous roll stationery). After printing the test pattern the page is ejected (or the test pattern is rolled clear of the printer enclosure, in the case of continuous roll printers).

Note that it is an acceptable solution to use the smallest marks that the language provides, rather than working at native printer resolution, where this is not achievable from within the language.

Optionally, on systems where the printer resolution cannot be determined, it is permissible to prompt the user for printer resolution, and to calculate point size based on user input, enabling fractional point sizes to be used.
",#Go,Go,"package main
 
import (
    ""github.com/fogleman/gg""
    ""log""
    ""os/exec""
    ""runtime""
)
 
var palette = [8]string{
    ""000000"", // black
    ""FF0000"", // red
    ""00FF00"", // green
    ""0000FF"", // blue
    ""FF00FF"", // magenta
    ""00FFFF"", // cyan
    ""FFFF00"", // yellow
    ""FFFFFF"", // white
}
 
func pinstripe(dc *gg.Context) {
    w := dc.Width()
    h := dc.Height() / 7
    for b := 1; b <= 11; b++ {
        for x, ci := 0, 0; x < w; x, ci = x+b, ci+1 {
            dc.SetHexColor(palette[ci%8])
            y := h * (b - 1)
            dc.DrawRectangle(float64(x), float64(y), float64(b), float64(h))
            dc.Fill()
        }
    }
}
 
func main() {
    dc := gg.NewContext(842, 595)
    pinstripe(dc)
    fileName := ""color_pinstripe.png""
    dc.SavePNG(fileName)
    var cmd *exec.Cmd
    if runtime.GOOS == ""windows"" {
        cmd = exec.Command(""mspaint"", ""/pt"", fileName)
    } else {
        cmd = exec.Command(""lp"", fileName)
    }
    if err := cmd.Run(); err != nil {
        log.Fatal(err)
    }   
}",1034,48
67613,http://rosettacode.org/wiki/Color_wheel,Color wheel,"Task

Write a function to draw a HSV color wheel completely with code.

This is strictly for learning purposes only. It's highly recommended that you use an image in an actual application to actually draw the color wheel   (as procedurally drawing is super slow). This does help you understand how color wheels work and this can easily be used to determine a color value based on a position within a circle.


",#Go,Go,"package main
 
import (
    ""github.com/fogleman/gg""
    ""math""
)
 
const tau = 2 * math.Pi
 
func hsb2rgb(hue, sat, bri float64) (r, g, b int) {
    u := int(bri*255 + 0.5)
    if sat == 0 {
        r, g, b = u, u, u
    } else {
        h := (hue - math.Floor(hue)) * 6
        f := h - math.Floor(h)
        p := int(bri*(1-sat)*255 + 0.5)
        q := int(bri*(1-sat*f)*255 + 0.5)
        t := int(bri*(1-sat*(1-f))*255 + 0.5)
        switch int(h) {
        case 0:
            r, g, b = u, t, p
        case 1:
            r, g, b = q, u, p
        case 2:
            r, g, b = p, u, t
        case 3:
            r, g, b = p, q, u
        case 4:
            r, g, b = t, p, u
        case 5:
            r, g, b = u, p, q
        }
    }
    return
}
 
func colorWheel(dc *gg.Context) {
    width, height := dc.Width(), dc.Height()
    centerX, centerY := width/2, height/2
    radius := centerX
    if centerY < radius {
        radius = centerY
    }
    for y := 0; y < height; y++ {
        dy := float64(y - centerY)
        for x := 0; x < width; x++ {
            dx := float64(x - centerX)
            dist := math.Sqrt(dx*dx + dy*dy)
            if dist <= float64(radius) {
                theta := math.Atan2(dy, dx)
                hue := (theta + math.Pi) / tau
                r, g, b := hsb2rgb(hue, 1, 1)
                dc.SetRGB255(r, g, b)
                dc.SetPixel(x, y)
            }
        }
    }
}
 
func main() {
    const width, height = 480, 480
    dc := gg.NewContext(width, height)
    dc.SetRGB(1, 1, 1) // set background color to white
    dc.Clear()
    colorWheel(dc)
    dc.SavePNG(""color_wheel.png"")
}",1649,68
67632,http://rosettacode.org/wiki/Color_of_a_screen_pixel,Color of a screen pixel,"Task

Get color information from an arbitrary pixel on the screen, such as the current location of the mouse cursor.

The mouse cursor may or may not have to be active in a GUI created by your program. These functions are OS related.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""github.com/go-vgo/robotgo""
)
 
func main() {
    // get position of mouse cursor
    x, y := robotgo.GetMousePos()
 
    // get color of pixel at that position
    color := robotgo.GetPixelColor(x, y)
    fmt.Printf(""Color of pixel at (%d, %d) is 0x%s\n"", x, y, color)   
}",312,15
67673,http://rosettacode.org/wiki/Color_quantization,Color quantization," full color
 Example: Gimp 16 color
Color quantization is the process of reducing number of colors used in an image while trying to maintain the visual appearance of the original image. In general, it is a form of cluster analysis, if each RGB color value is considered as a coordinate triple in the 3D colorspace. There are some well know algorithms [1], each with its own advantages and drawbacks.

Task: Take an RGB color image and reduce its colors to some smaller number (< 256). For this task, use the frog as input and reduce colors to 16, and output the resulting colors. The chosen colors should be adaptive to the input image, meaning you should not use a fixed palette such as Web colors or Windows system palette. Dithering is not required.

Note: the funny color bar on top of the frog image is intentional.

",#Go,Go,"package main
 
import (
    ""container/heap""
    ""image""
    ""image/color""
    ""image/png""
    ""log""
    ""math""
    ""os""
    ""sort""
)
 
func main() {
    f, err := os.Open(""Quantum_frog.png"")
    if err != nil {
        log.Fatal(err)
    }
    img, err := png.Decode(f)
    if ec := f.Close(); err != nil {
        log.Fatal(err)
    } else if ec != nil {
        log.Fatal(ec)
    }
    fq, err := os.Create(""frog16.png"")
    if err != nil {
        log.Fatal(err)
    }
    if err = png.Encode(fq, quant(img, 16)); err != nil {
        log.Fatal(err)
    }
}
 
// Organize quatization in some logical steps.
func quant(img image.Image, nq int) image.Image {
    qz := newQuantizer(img, nq) // set up a work space
    qz.cluster()                // cluster pixels by color
    return qz.Paletted()        // generate paletted image from clusters
}
 
// A workspace with members that can be accessed by methods.
type quantizer struct {
    img image.Image // original image
    cs  []cluster   // len is the desired number of colors
    px  []point     // list of all points in the image
    ch  chValues    // buffer for computing median
    eq  []point     // additional buffer used when splitting cluster
}
 
type cluster struct {
    px       []point // list of points in the cluster
    widestCh int     // rx, gx, bx const for channel with widest value range
    chRange  uint32  // value range (vmax-vmin) of widest channel
}
 
type point struct{ x, y int }
type chValues []uint32
type queue []*cluster
 
const (
    rx = iota
    gx
    bx
)
 
func newQuantizer(img image.Image, nq int) *quantizer {
    b := img.Bounds()
    npx := (b.Max.X - b.Min.X) * (b.Max.Y - b.Min.Y)
    // Create work space.
    qz := &quantizer{
        img: img,
        ch:  make(chValues, npx),
        cs:  make([]cluster, nq),
    }
    // Populate initial cluster with all pixels from image.
    c := &qz.cs[0]
    px := make([]point, npx)
    c.px = px
    i := 0
    for y := b.Min.Y; y < b.Max.Y; y++ {
        for x := b.Min.X; x < b.Max.X; x++ {
            px[i].x = x
            px[i].y = y
            i++
        }
    }
    return qz
}
 
func (qz *quantizer) cluster() {
    // Cluster by repeatedly splitting clusters.
    // Use a heap as priority queue for picking clusters to split.
    // The rule will be to spilt the cluster with the most pixels.
    // Terminate when the desired number of clusters has been populated
    // or when clusters cannot be further split.
    pq := new(queue)
    // Initial cluster.  populated at this point, but not analyzed.
    c := &qz.cs[0]
    for i := 1; ; {
        qz.setColorRange(c)
        // Cluster cannot be split if all pixels are the same color.
        // Only enqueue clusters that can be split.
        if c.chRange > 0 {
            heap.Push(pq, c) // add new cluster to queue
        }
        // If no clusters have any color variation, mark the end of the
        // cluster list and quit early.
        if len(*pq) == 0 {
            qz.cs = qz.cs[:i]
            break
        }
        s := heap.Pop(pq).(*cluster) // get cluster to split
        c = &qz.cs[i]                // set c to new cluster
        i++
        m := qz.Median(s)
        qz.Split(s, c, m) // split s into c and s
        // If that was the last cluster, we're done.
        if i == len(qz.cs) {
            break
        }
        qz.setColorRange(s)
        if s.chRange > 0 {
            heap.Push(pq, s) // return to queue
        }
    }
}
 
func (q *quantizer) setColorRange(c *cluster) {
    // Find extents of color values in each channel.
    var maxR, maxG, maxB uint32
    minR := uint32(math.MaxUint32)
    minG := uint32(math.MaxUint32)
    minB := uint32(math.MaxUint32) 
    for _, p := range c.px {
        r, g, b, _ := q.img.At(p.x, p.y).RGBA()
        if r < minR { 
            minR = r
        }
        if r > maxR {
            maxR = r
        }
        if g < minG {
            minG = g 
        }
        if g > maxG {
            maxG = g
        }
        if b < minB {
            minB = b
        }
        if b > maxB {
            maxB = b
        }
    }
    // See which channel had the widest range.
    s := gx
    min := minG
    max := maxG
    if maxR-minR > max-min {
        s = rx
        min = minR
        max = maxR
    }
    if maxB-minB > max-min {
        s = bx
        min = minB
        max = maxB
    }
    c.widestCh = s
    c.chRange = max - min // also store the range of that channel
}
 
func (q *quantizer) Median(c *cluster) uint32 {
    px := c.px
    ch := q.ch[:len(px)]
    // Copy values from appropriate channel to buffer for computing median.
    switch c.widestCh {
    case rx:
        for i, p := range c.px {
            ch[i], _, _, _ = q.img.At(p.x, p.y).RGBA()
        }
    case gx:
        for i, p := range c.px {
            _, ch[i], _, _ = q.img.At(p.x, p.y).RGBA()
        }
    case bx:
        for i, p := range c.px {
            _, _, ch[i], _ = q.img.At(p.x, p.y).RGBA()
        }
    }
    // Median algorithm.
    sort.Sort(ch)
    half := len(ch) / 2
    m := ch[half]
    if len(ch)%2 == 0 {
        m = (m + ch[half-1]) / 2
    }
    return m
}
 
func (q *quantizer) Split(s, c *cluster, m uint32) {
    px := s.px
    var v uint32
    i := 0
    lt := 0
    gt := len(px) - 1
    eq := q.eq[:0] // reuse any existing buffer
    for i <= gt {
        // Get pixel value of appropriate channel.
        r, g, b, _ := q.img.At(px[i].x, px[i].y).RGBA()
        switch s.widestCh {
        case rx:
            v = r
        case gx:
            v = g
        case bx:
            v = b
        } 
        // Categorize each pixel as either <, >, or == median.
        switch {
        case v < m:
            px[lt] = px[i]
            lt++
            i++
        case v > m:
            px[gt], px[i] = px[i], px[gt]
            gt--
        default:
            eq = append(eq, px[i])
            i++
        }
    }
    // Handle values equal to the median.
    if len(eq) > 0 {
        copy(px[lt:], eq) // move them back between the lt and gt values.
        // Then, if the number of gt values is < the number of lt values,
        // fix up i so that the split will include the eq values with
        // the gt values.
        if len(px)-i < lt {
            i = lt
        }
        q.eq = eq // squirrel away (possibly expanded) buffer for reuse
    }
    // Split the pixel list.
    s.px = px[:i]
    c.px = px[i:]
}   
 
func (qz *quantizer) Paletted() *image.Paletted {
    cp := make(color.Palette, len(qz.cs))
    pi := image.NewPaletted(qz.img.Bounds(), cp)
    for i := range qz.cs {
        px := qz.cs[i].px
        // Average values in cluster to get palette color.
        var rsum, gsum, bsum int64
        for _, p := range px {
            r, g, b, _ := qz.img.At(p.x, p.y).RGBA()
            rsum += int64(r)
            gsum += int64(g)
            bsum += int64(b)
        } 
        n64 := int64(len(px))
        cp[i] = color.NRGBA64{
            uint16(rsum / n64),
            uint16(gsum / n64),
            uint16(bsum / n64),
            0xffff,
        }
        // set image pixels
        for _, p := range px {
            pi.SetColorIndex(p.x, p.y, uint8(i))
        }
    }
    return pi
}
 
// Implement sort.Interface for sort in median algorithm.
func (c chValues) Len() int           { return len(c) }
func (c chValues) Less(i, j int) bool { return c[i] < c[j] }
func (c chValues) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }
 
// Implement heap.Interface for priority queue of clusters.
func (q queue) Len() int { return len(q) }
 
// Less implements rule to select cluster with greatest number of pixels.
func (q queue) Less(i, j int) bool {
    return len(q[j].px) < len(q[i].px)
}
 
func (q queue) Swap(i, j int) {
    q[i], q[j] = q[j], q[i]
}
func (pq *queue) Push(x interface{}) {
    c := x.(*cluster)
    *pq = append(*pq, c)
}
func (pq *queue) Pop() interface{} {
    q := *pq
    n := len(q) - 1
    c := q[n]
    *pq = q[:n]
    return c
}",8028,303
67675,http://rosettacode.org/wiki/Colour_pinstripe/Display,Colour pinstripe/Display,"The task is to create 1 pixel wide coloured vertical pinstripes with a sufficient number of pinstripes to span the entire width of the graphics display.



The pinstripes should either follow the system palette sequence,   or a sequence that includes:

black,   red,   green,   blue,   magenta,   cyan,   yellow,   and   white:

   after filling the top quarter, switch to a wider 2 pixel wide vertical pinstripe pattern,
   halfway down the display, switch to 3 pixel wide vertical pinstripe,
   finally to a 4 pixels wide vertical pinstripe for the last quarter of the display.


See also

   display black and white 
   print colour

",#Go,Go,"package main
 
import ""github.com/fogleman/gg""
 
var palette = [8]string{
    ""000000"", // black
    ""FF0000"", // red
    ""00FF00"", // green
    ""0000FF"", // blue
    ""FF00FF"", // magenta
    ""00FFFF"", // cyan
    ""FFFF00"", // yellow
    ""FFFFFF"", // white
}
 
func pinstripe(dc *gg.Context) {
    w := dc.Width()
    h := dc.Height() / 4
    for b := 1; b <= 4; b++ {
        for x, ci := 0, 0; x < w; x, ci = x+b, ci+1 {
            dc.SetHexColor(palette[ci%8])
            y := h * (b - 1)
            dc.DrawRectangle(float64(x), float64(y), float64(b), float64(h))
            dc.Fill()
        }
    }
}
 
func main() {
    dc := gg.NewContext(900, 600)
    pinstripe(dc)
    dc.SavePNG(""color_pinstripe.png"")
}",718,33
67867,http://rosettacode.org/wiki/Colour_bars/Display,Colour bars/Display,"Task

Display a series of vertical color bars across the width of the display.

The color bars should either use:

   the system palette,   or 
   the sequence of colors: 
   black
   red
   green
   blue
   magenta
   cyan
   yellow
   white

",#Go,Go,"package main
 
import ""github.com/fogleman/gg""
 
var colors = [8]string{
    ""000000"", // black
    ""FF0000"", // red
    ""00FF00"", // green
    ""0000FF"", // blue
    ""FF00FF"", // magenta
    ""00FFFF"", // cyan
    ""FFFF00"", // yellow
    ""FFFFFF"", // white
}
 
func drawBars(dc *gg.Context) {
    w := float64(dc.Width() / len(colors))
    h := float64(dc.Height())
    for i := range colors {
        dc.SetHexColor(colors[i])
        dc.DrawRectangle(w*float64(i), 0, w, h)
        dc.Fill()
    }
}
 
func main() {
    dc := gg.NewContext(400, 400)
    drawBars(dc)
    dc.SavePNG(""color_bars.png"")
}",602,30
67993,http://rosettacode.org/wiki/Circular_primes,Circular primes,"Definitions
A circular prime is a prime number with the property that the number generated at each intermediate step when cyclically permuting its (base 10) digits will also be prime.

For example:
1193 is a circular prime, since 1931, 9311 and 3119 are all also prime.

Note that a number which is a cyclic permutation of a smaller circular prime is not considered to be itself a circular prime. So 13 is a circular prime, but 31 is not.



A repunit (denoted by R) is a number whose base 10 representation contains only the digit 1.

For example:
R(2) = 11 and R(5) = 11111 are repunits.



Task
 Find the first 19 circular primes.


 If your language has access to arbitrary precision integer arithmetic, given that they are all repunits, find the next 4 circular primes.


 (Stretch) Determine which of the following repunits are probably circular primes: R(5003), R(9887), R(15073), R(25031), R(35317) and R(49081). The larger ones may take a long time to process so just do as many as you reasonably can.


See also
 Wikipedia article - Circular primes.
 Wikipedia article - Repunit.
 OEIS sequence A016114 - Circular primes.

",#Go,Go,"package main
 
import (
    ""fmt""
    big ""github.com/ncw/gmp""
    ""strings""
)
 
// OK for 'small' numbers.
func isPrime(n int) bool {
    switch {
    case n < 2:
        return false
    case n%2 == 0:
        return n == 2
    case n%3 == 0:
        return n == 3
    default:
        d := 5
        for d*d <= n {
            if n%d == 0 {
                return false
            }
            d += 2
            if n%d == 0 {
                return false
            }
            d += 4
        }
        return true
    }
}
 
func repunit(n int) *big.Int {
    ones := strings.Repeat(""1"", n)
    b, _ := new(big.Int).SetString(ones, 10)
    return b
}
 
var circs = []int{}
 
// binary search is overkill for a small number of elements
func alreadyFound(n int) bool {
    for _, i := range circs {
        if i == n {
            return true
        }
    }
    return false
}
 
func isCircular(n int) bool {
    nn := n
    pow := 1 // will eventually contain 10 ^ d where d is number of digits in n
    for nn > 0 {
        pow *= 10
        nn /= 10
    }
    nn = n
    for {
        nn *= 10
        f := nn / pow // first digit
        nn += f * (1 - pow)
        if alreadyFound(nn) {
            return false
        }
        if nn == n {
            break
        }
        if !isPrime(nn) {
            return false
        }
    }
    return true
}
 
func main() {
    fmt.Println(""The first 19 circular primes are:"")
    digits := [4]int{1, 3, 7, 9}
    q := []int{1, 2, 3, 5, 7, 9}  // queue the numbers to be examined
    fq := []int{1, 2, 3, 5, 7, 9} // also queue the corresponding first digits
    count := 0
    for {
        f := q[0]   // peek first element
        fd := fq[0] // peek first digit
        if isPrime(f) && isCircular(f) {
            circs = append(circs, f)
            count++
            if count == 19 {
                break
            }
        }
        copy(q, q[1:])   // pop first element
        q = q[:len(q)-1] // reduce length by 1
        copy(fq, fq[1:]) // ditto for first digit queue
        fq = fq[:len(fq)-1]
        if f == 2 || f == 5 { // if digits > 1 can't contain a 2 or 5
            continue
        }
        // add numbers with one more digit to queue
        // only numbers whose last digit >= first digit need be added
        for _, d := range digits {
            if d >= fd {
                q = append(q, f*10+d)
                fq = append(fq, fd)
            }
        }
    }
    fmt.Println(circs)
    fmt.Println(""\nThe next 4 circular primes, in repunit format, are:"")
    count = 0
    var rus []string
    for i := 7; count < 4; i++ {
        if repunit(i).ProbablyPrime(10) {
            count++
            rus = append(rus, fmt.Sprintf(""R(%d)"", i))
        }
    }
    fmt.Println(rus)
    fmt.Println(""\nThe following repunits are probably circular primes:"")
    for _, i := range []int{5003, 9887, 15073, 25031, 35317, 49081} {
        fmt.Printf(""R(%-5d) : %t\n"", i, repunit(i).ProbablyPrime(10))
    }
}",3003,124
68024,http://rosettacode.org/wiki/Combinations,Combinations,"Task

Given non-negative integers    m    and    n,   generate all size    m    combinations   of the integers from    0   (zero)   to    n-1    in sorted order   (each combination is sorted and the entire table is sorted).



Example

3   comb    5      is:

0 1 2
0 1 3
0 1 4
0 2 3
0 2 4
0 3 4
1 2 3
1 2 4
1 3 4
2 3 4

If it is more ""natural"" in your language to start counting from    1   (unity) instead of    0   (zero),

the combinations can be of the integers from    1   to    n. 



See also


 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",#Go,Go,"package main
 
import (
    ""fmt""
)
 
func main() {
    comb(5, 3, func(c []int) {
        fmt.Println(c)
    })
}
 
func comb(n, m int, emit func([]int)) {
    s := make([]int, m)
    last := m - 1
    var rc func(int, int)
    rc = func(i, next int) {
        for j := next; j < n; j++ {
            s[i] = j
            if i == last {
                emit(s)
            } else {
                rc(i+1, j+1)
            }
        }
        return
    }
    rc(0, 0)
}",471,29
68036,http://rosettacode.org/wiki/Closures/Value_capture,Closures/Value capture,"Task

Create a list of ten functions, in the simplest manner possible   (anonymous functions are encouraged),   such that the function at index    i     (you may choose to start     i     from either    0    or    1),    when run, should return the square of the index,   that is,     i  2.

Display the result of running any but the last function, to demonstrate that the function indeed remembers its value.



Goal

Demonstrate how to create a series of independent closures based on the same template but maintain separate copies of the variable closed over.

In imperative languages, one would generally use a loop with a mutable counter variable.

For each function to maintain the correct number, it has to capture the value of the variable at the time it was created, rather than just a reference to the variable, which would have a different value by the time the function was run.

See also: Multiple distinct objects
",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    fs := make([]func() int, 10)
    for i := range fs {
        i := i
        fs[i] = func() int {
            return i * i
        }
    }
    fmt.Println(""func #0:"", fs[0]())
    fmt.Println(""func #3:"", fs[3]())
}",261,15
68060,http://rosettacode.org/wiki/Cistercian_numerals,Cistercian numerals,"Cistercian numerals were used across Europe by Cistercian monks during the Late Medieval Period as an alternative to Roman numerals. They were used to represent base 10 integers from 0 to 9999.

How they work
All Cistercian numerals begin with a vertical line segment, which by itself represents the number 0. Then, glyphs representing the digits 1 through 9 are optionally added to the four quadrants surrounding the vertical line segment. These glyphs are drawn with vertical and horizontal symmetry about the initial line segment. Each quadrant corresponds to a digit place in the number:

 The upper-right quadrant represents the ones place.
 The upper-left quadrant represents the tens place.
 The lower-right quadrant represents the hundreds place.
 The lower-left quadrant represents the thousands place.
Please consult the following image for examples of Cistercian numerals showing each glyph: [1]

Task
 Write a function/procedure/routine to display any given Cistercian numeral. This could be done by drawing to the display, creating an image, or even as text (as long as it is a reasonable facsimile).
 Use the routine to show the following Cistercian numerals:
 0
 1
 20
 300
 4000
 5555
 6789
 And a number of your choice!
Notes
Due to the inability to upload images to Rosetta Code as of this task's creation, showing output here on this page is not required. However, it is welcomed — especially for text output.

See also
 Numberphile - The Forgotten Number System
 dcode.fr - Online Cistercian numeral converter

",#Go,Go,"package main
 
import ""fmt""
 
var n = make([][]string, 15)
 
func initN() {
    for i := 0; i < 15; i++ {
        n[i] = make([]string, 11)
        for j := 0; j < 11; j++ {
            n[i][j] = "" ""
        }
        n[i][5] = ""x""
    }
}
 
func horiz(c1, c2, r int) {
    for c := c1; c <= c2; c++ {
        n[r][c] = ""x""
    }
}
 
func verti(r1, r2, c int) {
    for r := r1; r <= r2; r++ {
        n[r][c] = ""x""
    }
}
 
func diagd(c1, c2, r int) {
    for c := c1; c <= c2; c++ {
        n[r+c-c1][c] = ""x""
    }
}
 
func diagu(c1, c2, r int) {
    for c := c1; c <= c2; c++ {
        n[r-c+c1][c] = ""x""
    }
}
 
var draw map[int]func() // map contains recursive closures
 
func initDraw() {
    draw = map[int]func(){
        1: func() { horiz(6, 10, 0) },
        2: func() { horiz(6, 10, 4) },
        3: func() { diagd(6, 10, 0) },
        4: func() { diagu(6, 10, 4) },
        5: func() { draw[1](); draw[4]() },
        6: func() { verti(0, 4, 10) },
        7: func() { draw[1](); draw[6]() },
        8: func() { draw[2](); draw[6]() },
        9: func() { draw[1](); draw[8]() },
 
        10: func() { horiz(0, 4, 0) },
        20: func() { horiz(0, 4, 4) },
        30: func() { diagu(0, 4, 4) },
        40: func() { diagd(0, 4, 0) },
        50: func() { draw[10](); draw[40]() },
        60: func() { verti(0, 4, 0) },
        70: func() { draw[10](); draw[60]() },
        80: func() { draw[20](); draw[60]() },
        90: func() { draw[10](); draw[80]() },
 
        100: func() { horiz(6, 10, 14) },
        200: func() { horiz(6, 10, 10) },
        300: func() { diagu(6, 10, 14) },
        400: func() { diagd(6, 10, 10) },
        500: func() { draw[100](); draw[400]() },
        600: func() { verti(10, 14, 10) },
        700: func() { draw[100](); draw[600]() },
        800: func() { draw[200](); draw[600]() },
        900: func() { draw[100](); draw[800]() },
 
        1000: func() { horiz(0, 4, 14) },
        2000: func() { horiz(0, 4, 10) },
        3000: func() { diagd(0, 4, 10) },
        4000: func() { diagu(0, 4, 14) },
        5000: func() { draw[1000](); draw[4000]() },
        6000: func() { verti(10, 14, 0) },
        7000: func() { draw[1000](); draw[6000]() },
        8000: func() { draw[2000](); draw[6000]() },
        9000: func() { draw[1000](); draw[8000]() },
    }
}
 
func printNumeral() {
    for i := 0; i < 15; i++ {
        for j := 0; j < 11; j++ {
            fmt.Printf(""%s "", n[i][j])
        }
        fmt.Println()
    }
    fmt.Println()
}
 
func main() {
    initDraw()
    numbers := []int{0, 1, 20, 300, 4000, 5555, 6789, 9999}
    for _, number := range numbers {
        initN()
        fmt.Printf(""%d:\n"", number)
        thousands := number / 1000
        number %= 1000
        hundreds := number / 100
        number %= 100
        tens := number / 10
        ones := number % 10
        if thousands > 0 {
            draw[thousands*1000]()
        }
        if hundreds > 0 {
            draw[hundreds*100]()
        }
        if tens > 0 {
            draw[tens*10]()
        }
        if ones > 0 {
            draw[ones]()
        }
        printNumeral()
    }
}",3150,123
68153,http://rosettacode.org/wiki/Church_numerals,Church numerals,"Task

In the Church encoding of natural numbers, the number N is encoded by a function that applies its first argument N times to its second argument.

 Church zero always returns the identity function, regardless of its first argument. In other words, the first argument is not applied to the second argument at all.
 Church one applies its first argument f just once to its second argument x, yielding f(x)
 Church two applies its first argument f twice to its second argument x, yielding f(f(x))
 and each successive Church numeral applies its first argument one additional time to its second argument, f(f(f(x))), f(f(f(f(x)))) ... The Church numeral 4, for example, returns a quadruple composition of the function supplied as its first argument.


Arithmetic operations on natural numbers can be similarly represented as functions on Church numerals.

In your language define:

 Church Zero,
 a Church successor function (a function on a Church numeral which returns the next Church numeral in the series),
 functions for Addition, Multiplication and Exponentiation over Church numerals,
 a function to convert integers to corresponding Church numerals,
 and a function to convert Church numerals to corresponding integers.


You should:

 Derive Church numerals three and four in terms of Church zero and a Church successor function.
 use Church numeral arithmetic to obtain the the sum and the product of Church 3 and Church 4,
 similarly obtain 4^3 and 3^4 in terms of Church numerals, using a Church numeral exponentiation function,
 convert each result back to an integer, and return it or print it to the console.

",#Go,Go,"package main
 
import ""fmt""
 
type any = interface{}
 
type fn func(any) any
 
type church func(fn) fn
 
func zero(f fn) fn {
    return func(x any) any {
        return x
    }
}
 
func (c church) succ() church {
    return func(f fn) fn {
        return func(x any) any {
            return f(c(f)(x))
        }
    }
}
 
func (c church) add(d church) church {
    return func(f fn) fn {
        return func(x any) any {
            return c(f)(d(f)(x))
        }
    }
}
 
func (c church) mul(d church) church {
    return func(f fn) fn {
        return func(x any) any {
            return c(d(f))(x)
        }
    }
}
 
func (c church) pow(d church) church {
    di := d.toInt()
    prod := c
    for i := 1; i < di; i++ {
        prod = prod.mul(c)
    }
    return prod
}
 
func (c church) toInt() int {
    return c(incr)(0).(int)
}
 
func intToChurch(i int) church {
    if i == 0 {
        return zero
    } else {
        return intToChurch(i - 1).succ()
    }
}
 
func incr(i any) any {
    return i.(int) + 1
}
 
func main() {
    z := church(zero)
    three := z.succ().succ().succ()
    four := three.succ()
 
    fmt.Println(""three        ->"", three.toInt())
    fmt.Println(""four         ->"", four.toInt())
    fmt.Println(""three + four ->"", three.add(four).toInt())
    fmt.Println(""three * four ->"", three.mul(four).toInt())
    fmt.Println(""three ^ four ->"", three.pow(four).toInt())
    fmt.Println(""four ^ three ->"", four.pow(three).toInt())
    fmt.Println(""5 -> five    ->"", intToChurch(5).toInt())
}",1524,78
68188,http://rosettacode.org/wiki/Chernick%27s_Carmichael_numbers,Chernick's Carmichael numbers,"In 1939, Jack Chernick proved that, for n ≥ 3 and m ≥ 1:

   U(n, m) = (6m + 1) * (12m + 1) * Product_{i=1..n-2} (2^i * 9m + 1)

is a Carmichael number if all the factors are primes and, for n > 4, m is a multiple of 2^(n-4).



Example
   U(3, m) = (6m + 1) * (12m + 1) * (18m + 1)
   U(4, m) = U(3, m) * (2^2 * 9m + 1)
   U(5, m) = U(4, m) * (2^3 * 9m + 1)
   ...
   U(n, m) = U(n-1, m) * (2^(n-2) * 9m + 1)

 The smallest Chernick's Carmichael number with 3 prime factors, is: U(3, 1) = 1729.
 The smallest Chernick's Carmichael number with 4 prime factors, is: U(4, 1) = 63973.
 The smallest Chernick's Carmichael number with 5 prime factors, is: U(5, 380) = 26641259752490421121.


For n = 5, the smallest number m that satisfy Chernick's conditions, is m = 380, therefore U(5, 380) is the smallest Chernick's Carmichael number with 5 prime factors.

U(5, 380) is a Chernick's Carmichael number because m = 380 is a multiple of 2^(n-4), where n = 5, and the factors { (6*380 + 1), (12*380 + 1), (18*380 + 1), (36*380 + 1), (72*380 + 1) } are all prime numbers.



Task
For n ≥ 3, let a(n) be the smallest Chernick's Carmichael number with n prime factors.

 Compute a(n) for n = 3..9.
 Optional: find a(10).

Note: it's perfectly acceptable to show the terms in factorized form:

 a(3) = 7 * 13 * 19
 a(4) = 7 * 13 * 19 * 37
 a(5) = 2281 * 4561 * 6841 * 13681 * 27361
 ...



See also
 Jack Chernick, On Fermat's simple theorem (PDF)
 OEIS A318646: The least Chernick's ""universal form"" Carmichael number with n prime factors


 Related tasks
 Carmichael 3 strong pseudoprimes

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
var (
    zero = new(big.Int)
    prod = new(big.Int)
    fact = new(big.Int)
)
 
func ccFactors(n, m uint64) (*big.Int, bool) {
    prod.SetUint64(6*m + 1)
    if !prod.ProbablyPrime(0) {
        return zero, false
    }
    fact.SetUint64(12*m + 1)
    if !fact.ProbablyPrime(0) { // 100% accurate up to 2 ^ 64
        return zero, false
    }
    prod.Mul(prod, fact)
    for i := uint64(1); i <= n-2; i++ {
        fact.SetUint64((1<<i)*9*m + 1)
        if !fact.ProbablyPrime(0) {
            return zero, false
        }
        prod.Mul(prod, fact)
    }
    return prod, true
}
 
func ccNumbers(start, end uint64) {
    for n := start; n <= end; n++ {
        m := uint64(1)
        if n > 4 {
            m = 1 << (n - 4)
        }
        for {
            num, ok := ccFactors(n, m)
            if ok {
                fmt.Printf(""a(%d) = %d\n"", n, num)
                break
            }
            if n <= 4 {
                m++
            } else {
                m += 1 << (n - 4)
            }
        }
    }
}
 
func main() {
    ccNumbers(3, 9)
}",1122,57
68245,http://rosettacode.org/wiki/Closest-pair_problem,Closest-pair problem,"

 This page uses content from Wikipedia. The original article was at Closest pair of points problem. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Provide a function to find the closest two points among a set of given points in two dimensions,   i.e. to solve the   Closest pair of points problem   in the   planar   case.

The straightforward solution is a   O(n2)   algorithm   (which we can call brute-force algorithm);   the pseudo-code (using indexes) could be simply:

bruteForceClosestPair of P(1), P(2), ... P(N)
if N < 2 then
  return ∞
else
  minDistance ← |P(1) - P(2)|
  minPoints ← { P(1), P(2) }
  foreach i ∈ [1, N-1]
    foreach j ∈ [i+1, N]
      if |P(i) - P(j)| < minDistance then
        minDistance ← |P(i) - P(j)|
        minPoints ← { P(i), P(j) } 
      endif
    endfor
  endfor
  return minDistance, minPoints
 endif

A better algorithm is based on the recursive divide&conquer approach,   as explained also at   Wikipedia's Closest pair of points problem,   which is   O(n log n);   a pseudo-code could be:

closestPair of (xP, yP)
               where xP is P(1) .. P(N) sorted by x coordinate, and
                     yP is P(1) .. P(N) sorted by y coordinate (ascending order)
if N ≤ 3 then
  return closest points of xP using brute-force algorithm
else
  xL ← points of xP from 1 to ⌈N/2⌉
  xR ← points of xP from ⌈N/2⌉+1 to N
  xm ← xP(⌈N/2⌉)x
  yL ← { p ∈ yP : px ≤ xm }
  yR ← { p ∈ yP : px > xm }
  (dL, pairL) ← closestPair of (xL, yL)
  (dR, pairR) ← closestPair of (xR, yR)
  (dmin, pairMin) ← (dR, pairR)
  if dL < dR then
    (dmin, pairMin) ← (dL, pairL)
  endif
  yS ← { p ∈ yP : |xm - px| < dmin }
  nS ← number of points in yS
  (closest, closestPair) ← (dmin, pairMin)
  for i from 1 to nS - 1
    k ← i + 1
    while k ≤ nS and yS(k)y - yS(i)y < dmin
      if |yS(k) - yS(i)| < closest then
        (closest, closestPair) ← (|yS(k) - yS(i)|, {yS(k), yS(i)})
      endif
      k ← k + 1
    endwhile
  endfor
  return closest, closestPair
endif



References and further readings

   Closest pair of points problem
   Closest Pair (McGill)
   Closest Pair (UCSB)
   Closest pair (WUStL)
   Closest pair (IUPUI) 

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/rand""
    ""time""
)
 
type xy struct {
    x, y float64
}
 
const n = 1000
const scale = 100.
 
func d(p1, p2 xy) float64 {
    return math.Hypot(p2.x-p1.x, p2.y-p1.y)
}
 
func main() {
    rand.Seed(time.Now().Unix())
    points := make([]xy, n)
    for i := range points {
        points[i] = xy{rand.Float64() * scale, rand.Float64() * scale}
    }
    p1, p2 := closestPair(points)
    fmt.Println(p1, p2)
    fmt.Println(""distance:"", d(p1, p2))
}
 
func closestPair(points []xy) (p1, p2 xy) {
    if len(points) < 2 {
        panic(""at least two points expected"")
    }
    min := 2 * scale
    for i, q1 := range points[:len(points)-1] {
        for _, q2 := range points[i+1:] {
            if dq := d(q1, q2); dq < min {
                p1, p2 = q1, q2
                min = dq
            }
        }
    }
    return
}",882,46
68314,http://rosettacode.org/wiki/Check_output_device_is_a_terminal,Check output device is a terminal,"Task

Demonstrate how to check whether the output device is a terminal or not.



Related task

   Check input device is a terminal

",#Go,Go,"package main
 
import (
    ""os""
    ""fmt""
)
 
func main() {
    if fileInfo, _ := os.Stdout.Stat(); (fileInfo.Mode() & os.ModeCharDevice) != 0 {
        fmt.Println(""Hello terminal"")
    } else {
        fmt.Println(""Who are you? You're not a terminal"")
    }
}",262,14
68318,http://rosettacode.org/wiki/Check_input_device_is_a_terminal,Check input device is a terminal,"Task

Demonstrate how to check whether the input device is a terminal or not.



Related task

   Check output device is a terminal

",#Go,Go,"package main
 
import (
    ""golang.org/x/crypto/ssh/terminal""
    ""fmt""
    ""os""
)
 
func main() {
    if terminal.IsTerminal(int(os.Stdin.Fd())) {
        fmt.Println(""Hello terminal"")
    } else {
        fmt.Println(""Who are you?  You're not a terminal."")
    }
}",267,15
68396,http://rosettacode.org/wiki/Chowla_numbers,Chowla numbers,"Chowla numbers are also known as:

   Chowla's function
   chowla numbers 
   the chowla function
   the chowla number
   the chowla sequence




The chowla number of   n   is   (as defined by Chowla's function):

   the sum of the divisors of   n     excluding unity and   n
   where   n   is a positive integer


The sequence is named after   Sarvadaman D. S. Chowla,   (22 October 1907 ──► 10 December 1995),

a London born Indian American mathematician specializing in number theory.



German mathematician Carl Friedrich Gauss (1777─1855) said:

   ""Mathematics is the queen of the sciences ─ and number theory is the queen of mathematics"".



Definitions

Chowla numbers can also be expressed as:

   
   chowla(n) = sum of divisors of  n  excluding unity and  n
   chowla(n) = sum(       divisors(n))   - 1  -  n 
   chowla(n) = sum( properDivisors(n))   - 1       
   chowla(n) = sum(aliquotDivisors(n))   - 1        
   chowla(n) = aliquot(n)                - 1       
   chowla(n) = sigma(n)                  - 1  -  n 
   chowla(n) = sigmaProperDivisiors(n)   - 1       
 
   chowla(a*b) =  a + b,    if  a  and  b  are distinct primes
   if  chowla(n) =  0,       and n > 1,  then   n   is prime
   if  chowla(n) =  n - 1,  and n > 1,  then   n   is a perfect number
    

Task

   create a   chowla   function that returns the   chowla number   for a positive integer   n
   Find and display   (1 per line)   for the 1st   37   integers:
   the integer   (the index)
   the chowla number for that integer
   For finding primes, use the   chowla   function to find values of zero
   Find and display the   count   of the primes up to              100
   Find and display the   count   of the primes up to           1,000
   Find and display the   count   of the primes up to         10,000
   Find and display the   count   of the primes up to       100,000
   Find and display the   count   of the primes up to    1,000,000
   Find and display the   count   of the primes up to  10,000,000
   For finding perfect numbers, use the   chowla   function to find values of   n - 1
   Find and display all   perfect numbers   up to   35,000,000
   use commas within appropriate numbers
   show all output here




Related tasks

    totient function
    perfect numbers
   Proper divisors
   Sieve of Eratosthenes


See also

   the OEIS entry for   A48050 Chowla's function.

",#Go,Go,"package main
 
import ""fmt""
 
func chowla(n int) int {
    if n < 1 {
        panic(""argument must be a positive integer"")
    }
    sum := 0
    for i := 2; i*i <= n; i++ {
        if n%i == 0 {
            j := n / i
            if i == j {
                sum += i
            } else {
                sum += i + j
            }
        }
    }
    return sum
}
 
func sieve(limit int) []bool {
    // True denotes composite, false denotes prime.
    // Only interested in odd numbers >= 3
    c := make([]bool, limit)
    for i := 3; i*3 < limit; i += 2 {
        if !c[i] && chowla(i) == 0 {
            for j := 3 * i; j < limit; j += 2 * i {
                c[j] = true
            }
        }
    }
    return c
}
 
func commatize(n int) string {
    s := fmt.Sprintf(""%d"", n)
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    return s
}
 
func main() {
    for i := 1; i <= 37; i++ {
        fmt.Printf(""chowla(%2d) = %d\n"", i, chowla(i))
    }
    fmt.Println()
 
    count := 1
    limit := int(1e7)
    c := sieve(limit)
    power := 100
    for i := 3; i < limit; i += 2 {
        if !c[i] {
            count++
        }
        if i == power-1 {
            fmt.Printf(""Count of primes up to %-10s = %s\n"", commatize(power), commatize(count))
            power *= 10
        }
    }
 
    fmt.Println()
    count = 0
    limit = 35000000
    for i := uint(2); ; i++ {
        p := 1 << (i - 1) * (1<<i - 1) // perfect numbers must be of this form
        if p > limit {
            break
        }
        if chowla(p) == p-1 {
            fmt.Printf(""%s is a perfect number\n"", commatize(p))
            count++
        }
    }
    fmt.Println(""There are"", count, ""perfect numbers <= 35,000,000"")
}",1762,80
68423,http://rosettacode.org/wiki/Checkpoint_synchronization,Checkpoint synchronization,"The checkpoint synchronization is a problem of synchronizing multiple tasks. Consider a workshop where several workers (tasks) assembly details of some mechanism. When each of them completes his work they put the details together. There is no store, so a worker who finished its part first must wait for others before starting another one. Putting details together is the checkpoint at which tasks synchronize themselves before going their paths apart.

The task

Implement checkpoint synchronization in your language.

Make sure that the solution is race condition-free. Note that a straightforward solution based on events is exposed to race condition. Let two tasks A and B need to be synchronized at a checkpoint. Each signals its event (EA and EB correspondingly), then waits for the AND-combination of the events (EA&EB) and resets its event. Consider the following scenario: A signals EA first and gets blocked waiting for EA&EB. Then B signals EB and loses the processor. Then A is released (both events are signaled) and resets EA. Now if B returns and enters waiting for EA&EB, it gets lost.

When a worker is ready it shall not continue before others finish. A typical implementation bug is when a worker is counted twice within one working cycle causing its premature completion. This happens when the quickest worker serves its cycle two times while the laziest one is lagging behind.

If you can, implement workers joining and leaving.
",#Go,Go,"package main
 
import (
    ""log""
    ""math/rand""
    ""sync""
    ""time""
)
 
func worker(part string) {
    log.Println(part, ""worker begins part"")
    time.Sleep(time.Duration(rand.Int63n(1e6)))
    log.Println(part, ""worker completes part"")
    wg.Done()
}
 
var (
    partList    = []string{""A"", ""B"", ""C"", ""D""}
    nAssemblies = 3
    wg          sync.WaitGroup
)
 
func main() {
    rand.Seed(time.Now().UnixNano())
    for c := 1; c <= nAssemblies; c++ {
        log.Println(""begin assembly cycle"", c)
        wg.Add(len(partList))
        for _, part := range partList {
            go worker(part)
        }
        wg.Wait()
        log.Println(""assemble.  cycle"", c, ""complete"")
    }
}",694,34
68485,http://rosettacode.org/wiki/Collections,Collections,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.


Collections are abstractions to represent sets of values. 

In statically-typed languages, the values are typically of a common data type.



Task

Create a collection, and add a few values to it.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    var a []interface{}
    a = append(a, 3)
    a = append(a, ""apples"", ""oranges"")
    fmt.Println(a)
}",148,10
68530,http://rosettacode.org/wiki/Check_Machin-like_formulas,Check Machin-like formulas,"Machin-like formulas   are useful for efficiently computing numerical approximations for 



π


{\displaystyle \pi }





Task

Verify the following Machin-like formulas are correct by calculating the value of tan   (right hand side) for each equation using exact arithmetic and showing they equal 1:

 





π
4


=
arctan
⁡


1
2


+
arctan
⁡


1
3




{\displaystyle {\pi \over 4}=\arctan {1 \over 2}+\arctan {1 \over 3}}

 
 





π
4


=
2
arctan
⁡


1
3


+
arctan
⁡


1
7




{\displaystyle {\pi \over 4}=2\arctan {1 \over 3}+\arctan {1 \over 7}}


 





π
4


=
4
arctan
⁡


1
5


−
arctan
⁡


1
239




{\displaystyle {\pi \over 4}=4\arctan {1 \over 5}-\arctan {1 \over 239}}


 





π
4


=
5
arctan
⁡


1
7


+
2
arctan
⁡


3
79




{\displaystyle {\pi \over 4}=5\arctan {1 \over 7}+2\arctan {3 \over 79}}


 





π
4


=
5
arctan
⁡


29
278


+
7
arctan
⁡


3
79




{\displaystyle {\pi \over 4}=5\arctan {29 \over 278}+7\arctan {3 \over 79}}


 





π
4


=
arctan
⁡


1
2


+
arctan
⁡


1
5


+
arctan
⁡


1
8




{\displaystyle {\pi \over 4}=\arctan {1 \over 2}+\arctan {1 \over 5}+\arctan {1 \over 8}}

 
 





π
4


=
4
arctan
⁡


1
5


−
arctan
⁡


1
70


+
arctan
⁡


1
99




{\displaystyle {\pi \over 4}=4\arctan {1 \over 5}-\arctan {1 \over 70}+\arctan {1 \over 99}}

 
 





π
4


=
5
arctan
⁡


1
7


+
4
arctan
⁡


1
53


+
2
arctan
⁡


1
4443




{\displaystyle {\pi \over 4}=5\arctan {1 \over 7}+4\arctan {1 \over 53}+2\arctan {1 \over 4443}}


 





π
4


=
6
arctan
⁡


1
8


+
2
arctan
⁡


1
57


+
arctan
⁡


1
239




{\displaystyle {\pi \over 4}=6\arctan {1 \over 8}+2\arctan {1 \over 57}+\arctan {1 \over 239}}


 





π
4


=
8
arctan
⁡


1
10


−
arctan
⁡


1
239


−
4
arctan
⁡


1
515




{\displaystyle {\pi \over 4}=8\arctan {1 \over 10}-\arctan {1 \over 239}-4\arctan {1 \over 515}}


 





π
4


=
12
arctan
⁡


1
18


+
8
arctan
⁡


1
57


−
5
arctan
⁡


1
239




{\displaystyle {\pi \over 4}=12\arctan {1 \over 18}+8\arctan {1 \over 57}-5\arctan {1 \over 239}}


 





π
4


=
16
arctan
⁡


1
21


+
3
arctan
⁡


1
239


+
4
arctan
⁡


3
1042




{\displaystyle {\pi \over 4}=16\arctan {1 \over 21}+3\arctan {1 \over 239}+4\arctan {3 \over 1042}}


 





π
4


=
22
arctan
⁡


1
28


+
2
arctan
⁡


1
443


−
5
arctan
⁡


1
1393


−
10
arctan
⁡


1
11018




{\displaystyle {\pi \over 4}=22\arctan {1 \over 28}+2\arctan {1 \over 443}-5\arctan {1 \over 1393}-10\arctan {1 \over 11018}}


 





π
4


=
22
arctan
⁡


1
38


+
17
arctan
⁡


7
601


+
10
arctan
⁡


7
8149




{\displaystyle {\pi \over 4}=22\arctan {1 \over 38}+17\arctan {7 \over 601}+10\arctan {7 \over 8149}}


 





π
4


=
44
arctan
⁡


1
57


+
7
arctan
⁡


1
239


−
12
arctan
⁡


1
682


+
24
arctan
⁡


1
12943




{\displaystyle {\pi \over 4}=44\arctan {1 \over 57}+7\arctan {1 \over 239}-12\arctan {1 \over 682}+24\arctan {1 \over 12943}}


 





π
4


=
88
arctan
⁡


1
172


+
51
arctan
⁡


1
239


+
32
arctan
⁡


1
682


+
44
arctan
⁡


1
5357


+
68
arctan
⁡


1
12943




{\displaystyle {\pi \over 4}=88\arctan {1 \over 172}+51\arctan {1 \over 239}+32\arctan {1 \over 682}+44\arctan {1 \over 5357}+68\arctan {1 \over 12943}}


and confirm that the following formula is incorrect by showing   tan   (right hand side)   is not   1:

 





π
4


=
88
arctan
⁡


1
172


+
51
arctan
⁡


1
239


+
32
arctan
⁡


1
682


+
44
arctan
⁡


1
5357


+
68
arctan
⁡


1
12944




{\displaystyle {\pi \over 4}=88\arctan {1 \over 172}+51\arctan {1 \over 239}+32\arctan {1 \over 682}+44\arctan {1 \over 5357}+68\arctan {1 \over 12944}}


These identities are useful in calculating the values:

 



tan
⁡
(
a
+
b
)
=



tan
⁡
(
a
)
+
tan
⁡
(
b
)


1
−
tan
⁡
(
a
)
tan
⁡
(
b
)





{\displaystyle \tan(a+b)={\tan(a)+\tan(b) \over 1-\tan(a)\tan(b)}}


 



tan
⁡

(
arctan
⁡


a
b


)

=


a
b




{\displaystyle \tan \left(\arctan {a \over b}\right)={a \over b}}


 



tan
⁡
(
−
a
)
=
−
tan
⁡
(
a
)


{\displaystyle \tan(-a)=-\tan(a)}




You can store the equations in any convenient data structure, but for extra credit parse them from human-readable text input.

Note: to formally prove the formula correct, it would have to be shown that 






−
3
p
i

4




{\displaystyle {-3pi \over 4}}

 < right hand side < 






5
p
i

4




{\displaystyle {5pi \over 4}}

 due to 



tan
⁡
(
)


{\displaystyle \tan()}

 periodicity.


",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
type mTerm struct {
    a, n, d int64
}
 
var testCases = [][]mTerm{
    {{1, 1, 2}, {1, 1, 3}},
    {{2, 1, 3}, {1, 1, 7}},
    {{4, 1, 5}, {-1, 1, 239}},
    {{5, 1, 7}, {2, 3, 79}},
    {{1, 1, 2}, {1, 1, 5}, {1, 1, 8}},
    {{4, 1, 5}, {-1, 1, 70}, {1, 1, 99}},
    {{5, 1, 7}, {4, 1, 53}, {2, 1, 4443}},
    {{6, 1, 8}, {2, 1, 57}, {1, 1, 239}},
    {{8, 1, 10}, {-1, 1, 239}, {-4, 1, 515}},
    {{12, 1, 18}, {8, 1, 57}, {-5, 1, 239}},
    {{16, 1, 21}, {3, 1, 239}, {4, 3, 1042}},
    {{22, 1, 28}, {2, 1, 443}, {-5, 1, 1393}, {-10, 1, 11018}},
    {{22, 1, 38}, {17, 7, 601}, {10, 7, 8149}},
    {{44, 1, 57}, {7, 1, 239}, {-12, 1, 682}, {24, 1, 12943}},
    {{88, 1, 172}, {51, 1, 239}, {32, 1, 682}, {44, 1, 5357}, {68, 1, 12943}},
    {{88, 1, 172}, {51, 1, 239}, {32, 1, 682}, {44, 1, 5357}, {68, 1, 12944}},
}
 
func main() {
    for _, m := range testCases {
        fmt.Printf(""tan %v = %v\n"", m, tans(m))
    }
}
 
var one = big.NewRat(1, 1)
 
func tans(m []mTerm) *big.Rat {
    if len(m) == 1 {
        return tanEval(m[0].a, big.NewRat(m[0].n, m[0].d))
    }
    half := len(m) / 2
    a := tans(m[:half])
    b := tans(m[half:])
    r := new(big.Rat)
    return r.Quo(new(big.Rat).Add(a, b), r.Sub(one, r.Mul(a, b)))
}
 
func tanEval(coef int64, f *big.Rat) *big.Rat {
    if coef == 1 {
        return f
    }
    if coef < 0 {
        r := tanEval(-coef, f)
        return r.Neg(r)
    }
    ca := coef / 2
    cb := coef - ca
    a := tanEval(ca, f)
    b := tanEval(cb, f)
    r := new(big.Rat)
    return r.Quo(new(big.Rat).Add(a, b), r.Sub(one, r.Mul(a, b)))
}",1639,64
68544,http://rosettacode.org/wiki/Classes,Classes,"In object-oriented programming class is a set (a transitive closure) of types bound by the relation of inheritance. It is said that all types derived from some base type T and the type T itself form a class T.

The first type T from the class T sometimes is called the root type of the class.

A class of types itself, as a type, has the values and operations of its own.
The operations of are usually called methods of the root type.
Both operations and values are called  polymorphic.

A polymorphic operation (method) selects an implementation depending on the actual specific type of the polymorphic argument.

The action of choice the type-specific implementation of a polymorphic operation is called dispatch. Correspondingly, polymorphic operations are often called dispatching or virtual.
Operations with multiple arguments and/or the results of the class are called multi-methods.
A further generalization of is the operation with arguments and/or results from different classes.

 single-dispatch languages are those that allow only one argument or result to control the dispatch. Usually it is the first parameter, often hidden, so that a prefix notation x.f() is used instead of mathematical f(x).
 multiple-dispatch languages allow many arguments and/or results to control the dispatch.


A polymorphic value has a type tag indicating its specific type from the class and the corresponding specific value of that type.
This type is sometimes called the most specific type of a [polymorphic] value.
The type tag of the value is used in order to resolve the dispatch.
The set of polymorphic values of a class is a transitive closure of the sets of values of all types from that class.

In many  OO languages
the type of the class of T and T itself are considered equivalent.
In some languages they are distinct (like in Ada).
When class T and T are equivalent, there is no way to distinguish
polymorphic and specific values.



Task

Create a basic class with a method, a constructor, an instance variable and how to instantiate it.



",#Go,Go,"package main
 
import ""fmt""
 
// a basic ""class.""
// In quotes because Go does not use that term or have that exact concept.
// Go simply has types that can have methods.
type picnicBasket struct {
    nServings int // ""instance variables""
    corkscrew bool
}
 
// a method (yes, Go uses the word method!)
func (b *picnicBasket) happy() bool {
    return b.nServings > 1 && b.corkscrew
}
 
// a ""constructor.""
// Also in quotes as Go does not have that exact mechanism as part of the
// language.  A common idiom however, is a function with the name new<Type>,
// that returns a new object of the type, fully initialized as needed and
// ready to use.  It makes sense to use this kind of constructor function when
// non-trivial initialization is needed.  In cases where the concise syntax
// shown is sufficient however, it is not idiomatic to define the function.
// Rather, code that needs a new object would simply contain &picnicBasket{...
func newPicnicBasket(nPeople int) *picnicBasket {
    // arbitrary code to interpret arguments, check resources, etc.
    // ...
    // return data new object.
    // this is the concise syntax.  there are other ways of doing it.
    return &picnicBasket{nPeople, nPeople > 0}
}
 
// how to instantiate it.
func main() {
    var pb picnicBasket          // create on stack (probably)
    pbl := picnicBasket{}        // equivalent to above
    pbp := &picnicBasket{}       // create on heap.  pbp is pointer to object.
    pbn := new(picnicBasket)     // equivalent to above
    forTwo := newPicnicBasket(2) // using constructor
    // equivalent to above.  field names, called keys, are optional.
    forToo := &picnicBasket{nServings: 2, corkscrew: true}
 
    fmt.Println(pb.nServings, pb.corkscrew)
    fmt.Println(pbl.nServings, pbl.corkscrew)
    fmt.Println(pbp)
    fmt.Println(pbn)
    fmt.Println(forTwo)
    fmt.Println(forToo)
}",1886,50
68558,http://rosettacode.org/wiki/Cholesky_decomposition,Cholesky decomposition,"Every symmetric, positive definite matrix A can be decomposed into a product of a unique lower triangular matrix L and its transpose:





A
=
L

L

T




{\displaystyle A=LL^{T}}






L


{\displaystyle L}

 is called the Cholesky factor of 



A


{\displaystyle A}

, and can be interpreted as a generalized square root of 



A


{\displaystyle A}

, as described in Cholesky decomposition.

In a 3x3 example, we have to solve the following system of equations:









A



=


(




a

11





a

21





a

31







a

21





a

22





a

32







a

31





a

32





a

33





)








=


(




l

11




0


0





l

21





l

22




0





l

31





l

32





l

33





)




(




l

11





l

21





l

31






0



l

22





l

32






0


0



l

33





)


≡
L

L

T








=


(




l

11


2





l

21



l

11





l

31



l

11







l

21



l

11





l

21


2


+

l

22


2





l

31



l

21


+

l

32



l

22







l

31



l

11





l

31



l

21


+

l

32



l

22





l

31


2


+

l

32


2


+

l

33


2





)








{\displaystyle {\begin{aligned}A&={\begin{pmatrix}a_{11}&a_{21}&a_{31}\\a_{21}&a_{22}&a_{32}\\a_{31}&a_{32}&a_{33}\\\end{pmatrix}}\\&={\begin{pmatrix}l_{11}&0&0\\l_{21}&l_{22}&0\\l_{31}&l_{32}&l_{33}\\\end{pmatrix}}{\begin{pmatrix}l_{11}&l_{21}&l_{31}\\0&l_{22}&l_{32}\\0&0&l_{33}\end{pmatrix}}\equiv LL^{T}\\&={\begin{pmatrix}l_{11}^{2}&l_{21}l_{11}&l_{31}l_{11}\\l_{21}l_{11}&l_{21}^{2}+l_{22}^{2}&l_{31}l_{21}+l_{32}l_{22}\\l_{31}l_{11}&l_{31}l_{21}+l_{32}l_{22}&l_{31}^{2}+l_{32}^{2}+l_{33}^{2}\end{pmatrix}}\end{aligned}}}


We can see that for the diagonal elements (




l

k
k




{\displaystyle l_{kk}}

) of 



L


{\displaystyle L}

 there is a calculation pattern:






l

11


=



a

11






{\displaystyle l_{11}={\sqrt {a_{11}}}}







l

22


=



a

22


−

l

21


2






{\displaystyle l_{22}={\sqrt {a_{22}-l_{21}^{2}}}}







l

33


=



a

33


−
(

l

31


2


+

l

32


2


)




{\displaystyle l_{33}={\sqrt {a_{33}-(l_{31}^{2}+l_{32}^{2})}}}


or in general:






l

k
k


=



a

k
k


−

∑

j
=
1


k
−
1



l

k
j


2






{\displaystyle l_{kk}={\sqrt {a_{kk}-\sum _{j=1}^{k-1}l_{kj}^{2}}}}


For the elements below the diagonal (




l

i
k




{\displaystyle l_{ik}}

, where 



i
>
k


{\displaystyle i>k}

) there is also a calculation pattern:






l

21


=


1

l

11





a

21




{\displaystyle l_{21}={\frac {1}{l_{11}}}a_{21}}







l

31


=


1

l

11





a

31




{\displaystyle l_{31}={\frac {1}{l_{11}}}a_{31}}







l

32


=


1

l

22




(

a

32


−

l

31



l

21


)


{\displaystyle l_{32}={\frac {1}{l_{22}}}(a_{32}-l_{31}l_{21})}


which can also be expressed in a general formula:






l

i
k


=


1

l

k
k





(

a

i
k


−

∑

j
=
1


k
−
1



l

i
j



l

k
j


)



{\displaystyle l_{ik}={\frac {1}{l_{kk}}}\left(a_{ik}-\sum _{j=1}^{k-1}l_{ij}l_{kj}\right)}


Task description

The task is to implement a routine which will return a lower Cholesky factor 



L


{\displaystyle L}

 for every given symmetric, positive definite nxn matrix 



A


{\displaystyle A}

. You should then test it on the following two examples and include your output.

Example 1:

25  15  -5                 5   0   0
15  18   0         -->     3   3   0
-5   0  11                -1   1   3

Example 2:

18  22   54   42           4.24264    0.00000    0.00000    0.00000
22  70   86   62   -->     5.18545    6.56591    0.00000    0.00000
54  86  174  134          12.72792    3.04604    1.64974    0.00000
42  62  134  106           9.89949    1.62455    1.84971    1.39262



Note

 The Cholesky decomposition of a Pascal upper-triangle matrix is the Identity matrix of the same size. 
 The Cholesky decomposition of a Pascal symmetric matrix is the Pascal lower-triangle matrix of the same size.",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
// symmetric and lower use a packed representation that stores only
// the lower triangle.
 
type symmetric struct {
    order int
    ele   []float64
}
 
type lower struct {
    order int
    ele   []float64
}
 
// symmetric.print prints a square matrix from the packed representation,
// printing the upper triange as a transpose of the lower.
func (s *symmetric) print() {
    const eleFmt = ""%10.5f ""
    row, diag := 1, 0
    for i, e := range s.ele {
        fmt.Printf(eleFmt, e)
        if i == diag {
            for j, col := diag+row, row; col < s.order; j += col {
                fmt.Printf(eleFmt, s.ele[j])
                col++
            }
            fmt.Println()
            row++
            diag += row
        }
    }
}
 
// lower.print prints a square matrix from the packed representation,
// printing the upper triangle as all zeros.
func (l *lower) print() {
    const eleFmt = ""%10.5f ""
    row, diag := 1, 0
    for i, e := range l.ele {
        fmt.Printf(eleFmt, e)
        if i == diag {
            for j := row; j < l.order; j++ {
                fmt.Printf(eleFmt, 0.)
            }
            fmt.Println()
            row++
            diag += row
        }
    }
}
 
// choleskyLower returns the cholesky decomposition of a symmetric real
// matrix.  The matrix must be positive definite but this is not checked.
func (a *symmetric) choleskyLower() *lower {
    l := &lower{a.order, make([]float64, len(a.ele))}
    row, col := 1, 1
    dr := 0 // index of diagonal element at end of row
    dc := 0 // index of diagonal element at top of column
    for i, e := range a.ele {
        if i < dr {
            d := (e - l.ele[i]) / l.ele[dc]
            l.ele[i] = d
            ci, cx := col, dc
            for j := i + 1; j <= dr; j++ {
                cx += ci
                ci++
                l.ele[j] += d * l.ele[cx]
            }
            col++
            dc += col
        } else {
            l.ele[i] = math.Sqrt(e - l.ele[i])
            row++
            dr += row
            col = 1
            dc = 0
        }
    }
    return l
}
 
func main() {
    demo(&symmetric{3, []float64{
        25,
        15, 18,
        -5, 0, 11}})
    demo(&symmetric{4, []float64{
        18,
        22, 70,
        54, 86, 174,
        42, 62, 134, 106}})
}
 
func demo(a *symmetric) {
    fmt.Println(""A:"")
    a.print()
    fmt.Println(""L:"")
    a.choleskyLower().print()
}",2472,105
68560,http://rosettacode.org/wiki/Cheryl%27s_birthday,Cheryl's birthday,"Albert and Bernard just became friends with Cheryl, and they want to know when her birthday is.

Cheryl gave them a list of ten possible dates:

     May 15,     May 16,     May 19
     June 17,    June 18
     July 14,    July 16
     August 14,  August 15,  August 17

Cheryl then tells Albert the   month   of birth,   and Bernard the   day   (of the month)   of birth.

 1)  Albert:   I don't know when Cheryl's birthday is, but I know that Bernard does not know too.
 2)  Bernard:  At first I don't know when Cheryl's birthday is, but I know now.
 3)  Albert:   Then I also know when Cheryl's birthday is.



Task
Write a computer program to deduce, by successive elimination, Cheryl's birthday.



Related task

 Sum and Product Puzzle


References
 Wikipedia article of the same name.
 Tuple Relational Calculus

",#Go,Go,"package main
 
import (
    ""fmt""
    ""time""
)
 
type birthday struct{ month, day int }
 
func (b birthday) String() string {
    return fmt.Sprintf(""%s %d"", time.Month(b.month), b.day)
}
 
func (b birthday) monthUniqueIn(bds []birthday) bool {
    count := 0
    for _, bd := range bds {
        if bd.month == b.month {
            count++
        }
    }
    if count == 1 {
        return true
    }
    return false
}
 
func (b birthday) dayUniqueIn(bds []birthday) bool {
    count := 0
    for _, bd := range bds {
        if bd.day == b.day {
            count++
        }
    }
    if count == 1 {
        return true
    }
    return false
}
 
func (b birthday) monthWithUniqueDayIn(bds []birthday) bool {
    for _, bd := range bds {
        if bd.month == b.month && bd.dayUniqueIn(bds) {
            return true
        }
    }
    return false
}
 
func main() {
    choices := []birthday{
        {5, 15}, {5, 16}, {5, 19}, {6, 17}, {6, 18},
        {7, 14}, {7, 16}, {8, 14}, {8, 15}, {8, 17},
    }
 
    // Albert knows the month but doesn't know the day.
    // So the month can't be unique within the choices.
    var filtered []birthday
    for _, bd := range choices {
        if !bd.monthUniqueIn(choices) {
            filtered = append(filtered, bd)
        }
    }
 
    // Albert also knows that Bernard doesn't know the answer.
    // So the month can't have a unique day.
    var filtered2 []birthday
    for _, bd := range filtered {
        if !bd.monthWithUniqueDayIn(filtered) {
            filtered2 = append(filtered2, bd)
        }
    }
 
    // Bernard now knows the answer.
    // So the day must be unique within the remaining choices.
    var filtered3 []birthday
    for _, bd := range filtered2 {
        if bd.dayUniqueIn(filtered2) {
            filtered3 = append(filtered3, bd)
        }
    }
 
    // Albert now knows the answer too.
    // So the month must be unique within the remaining choices.
    var filtered4 []birthday
    for _, bd := range filtered3 {
        if bd.monthUniqueIn(filtered3) {
            filtered4 = append(filtered4, bd)
        }
    }
 
    if len(filtered4) == 1 {
        fmt.Println(""Cheryl's birthday is"", filtered4[0])
    } else {
        fmt.Println(""Something went wrong!"")
    }
}",2268,96
68597,http://rosettacode.org/wiki/Circles_of_given_radius_through_two_points,Circles of given radius through two points,"
Given two points on a plane and a radius, usually two circles of given radius can be drawn through the points.

Exceptions

 r==0.0 should be treated as never describing circles (except in the case where the points are coincident).
 If the points are coincident then an infinite number of circles with the point on their circumference can be drawn, unless r==0.0 as well which then collapses the circles to a point.
 If the points form a diameter then return two identical circles or return a single circle, according to which is the most natural mechanism for the implementation language.
 If the points are too far apart then no circles can be drawn.


Task detail

 Write a function/subroutine/method/... that takes two points and a radius and returns the two circles through those points, or some indication of special cases where two, possibly equal, circles cannot be returned.
 Show here the output for the following inputs:
      p1                p2           r
0.1234, 0.9876    0.8765, 0.2345    2.0
0.0000, 2.0000    0.0000, 0.0000    1.0
0.1234, 0.9876    0.1234, 0.9876    2.0
0.1234, 0.9876    0.8765, 0.2345    0.5
0.1234, 0.9876    0.1234, 0.9876    0.0



Related task

   Total circles area.


See also

   Finding the Center of a Circle from 2 Points and Radius from Math forum @ Drexel

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
var (
    Two  = ""Two circles.""
    R0   = ""R==0.0 does not describe circles.""
    Co   = ""Coincident points describe an infinite number of circles.""
    CoR0 = ""Coincident points with r==0.0 describe a degenerate circle.""
    Diam = ""Points form a diameter and describe only a single circle.""
    Far  = ""Points too far apart to form circles.""
)
 
type point struct{ x, y float64 }
 
func circles(p1, p2 point, r float64) (c1, c2 point, Case string) {
    if p1 == p2 {
        if r == 0 {
            return p1, p1, CoR0
        }
        Case = Co
        return
    }
    if r == 0 {
        return p1, p2, R0
    }
    dx := p2.x - p1.x
    dy := p2.y - p1.y
    q := math.Hypot(dx, dy)
    if q > 2*r {
        Case = Far
        return
    }
    m := point{(p1.x + p2.x) / 2, (p1.y + p2.y) / 2}
    if q == 2*r {
        return m, m, Diam
    }
    d := math.Sqrt(r*r - q*q/4)
    ox := d * dx / q
    oy := d * dy / q
    return point{m.x - oy, m.y + ox}, point{m.x + oy, m.y - ox}, Two
}
 
var td = []struct {
    p1, p2 point
    r      float64
}{
    {point{0.1234, 0.9876}, point{0.8765, 0.2345}, 2.0},
    {point{0.0000, 2.0000}, point{0.0000, 0.0000}, 1.0},
    {point{0.1234, 0.9876}, point{0.1234, 0.9876}, 2.0},
    {point{0.1234, 0.9876}, point{0.8765, 0.2345}, 0.5},
    {point{0.1234, 0.9876}, point{0.1234, 0.9876}, 0.0},
}
 
func main() {
    for _, tc := range td {
        fmt.Println(""p1: "", tc.p1)
        fmt.Println(""p2: "", tc.p2)
        fmt.Println(""r: "", tc.r)
        c1, c2, Case := circles(tc.p1, tc.p2, tc.r)
        fmt.Println(""  "", Case)
        switch Case {
        case CoR0, Diam:
            fmt.Println(""   Center: "", c1)
        case Two:
            fmt.Println(""   Center 1: "", c1)
            fmt.Println(""   Center 2: "", c2)
        }
        fmt.Println()
    }
}",1862,74
68648,http://rosettacode.org/wiki/Chinese_zodiac,Chinese zodiac,"Traditionally, the Chinese have counted years using two simultaneous cycles, one of length 10 (the ""celestial stems"") and one of length 12 (the ""terrestrial branches""); the combination results in a repeating 60-year pattern. Mapping the branches to twelve traditional animal deities results in the well-known ""Chinese zodiac"", assigning each year to a given animal. For example, Tuesday, February 1, 2022 CE (in the common Gregorian calendar) will begin the lunisolar Year of the Tiger.

The celestial stems have no one-to-one mapping like that of the branches to animals; however, the five pairs of consecutive stems each belong to one of the five traditional Chinese elements (Wood, Fire, Earth, Metal, and Water). Further, one of the two years within each element's governance is associated with yin, the other with yang.

Thus, 2022 is also the yang year of Water. Note that since 12 is an even number, the association between animals and yin/yang doesn't change. Consecutive Years of the Rooster will cycle through the five elements, but will always be yin, despite the apparent conceptual mismatch between the specifically-male English animal name and the female aspect denoted by yin.

Task
 Create a subroutine or program that will return or output the animal, yin/yang association, and element for the lunisolar year that begins in a given CE year.
You may optionally provide more information in the form of the year's numerical position within the 60-year cycle and/or its actual Chinese stem-branch name (in Han characters or Pinyin transliteration).

Requisite information

 The animal cycle runs in this order: Rat, Ox, Tiger, Rabbit, Dragon, Snake, Horse, Goat, Monkey, Rooster, Dog, Pig.
 The element cycle runs in this order: Wood, Fire, Earth, Metal, Water.
 The yang year precedes the yin year within each element.
 The current 60-year cycle began in 1984 CE; the first cycle of the Common Era began in 4 CE.
Thus, 1984 was the year of the Wood Rat (yang), 1985 was the year of the Wood Ox (yin), and 1986 the year of the Fire Tiger (yang); 2022 - which, as already noted, is the year of the Water Tiger (yang) - is the 39th year of the current cycle.

Information for optional task

 The ten celestial stems are 甲 jiă, 乙 yĭ, 丙 bĭng, 丁 dīng, 戊 wù, 己 jĭ, 庚 gēng, 辛 xīn, 壬 rén, and 癸 gŭi. With the ASCII version of Pinyin tones, the names are written ""jia3"", ""yi3"", ""bing3"", ""ding1"", ""wu4"", ""ji3"", ""geng1"", ""xin1"", ""ren2"", and ""gui3"".
 The twelve terrestrial branches are 子 zĭ, 丑 chŏu, 寅 yín, 卯 măo, 辰 chén, 巳 sì, 午 wŭ, 未 wèi, 申 shēn, 酉 yŏu, 戌 xū, 亥 hài. In ASCII Pinyin, those are ""zi3"", ""chou3"", ""yin2"", ""mao3"", ""chen2"", ""si4"", ""wu3"", ""wei4"", ""shen1"", ""you3"", ""xu1"", and ""hai4"".
Therefore 1984 was 甲子 (jiă-zĭ, or jia3-zi3). 2022 is 壬寅 (rén-yín or ren2-yin2).
",#Go,Go,"package main
 
import ""fmt""
 
var (
    animalString = []string{""Rat"", ""Ox"", ""Tiger"", ""Rabbit"", ""Dragon"", ""Snake"",
        ""Horse"", ""Goat"", ""Monkey"", ""Rooster"", ""Dog"", ""Pig""}
    stemYYString  = []string{""Yang"", ""Yin""}
    elementString = []string{""Wood"", ""Fire"", ""Earth"", ""Metal"", ""Water""}
    stemCh        = []rune(""甲乙丙丁戊己庚辛壬癸"")
    branchCh      = []rune(""子丑寅卯辰巳午未申酉戌亥"")
)
 
func cz(yr int) (animal, yinYang, element, stemBranch string, cycleYear int) {
    yr -= 4
    stem := yr % 10
    branch := yr % 12
    return animalString[branch],
        stemYYString[stem%2],
        elementString[stem/2],
        string([]rune{stemCh[stem], branchCh[branch]}),
        yr%60 + 1
}
 
func main() {
    for _, yr := range []int{1935, 1938, 1968, 1972, 1976} {
        a, yy, e, sb, cy := cz(yr)
        fmt.Printf(""%d: %s %s, %s, Cycle year %d %s\n"",
            yr, e, a, yy, cy, sb)
    }
}",891,31
68651,http://rosettacode.org/wiki/Chat_server,Chat server,"Task

Write a server for a minimal text based chat.

People should be able to connect via ‘telnet’, sign on with a nickname, and type messages which will then be seen by all other connected users. Arrivals and departures of chat members should generate appropriate notification messages.



",#Go,Go,"package main
 
import (
	""bufio""
	""flag""
	""fmt""
	""log""
	""net""
	""strings""
	""time""
)
 
func main() {
	log.SetPrefix(""chat: "")
	addr := flag.String(""addr"", ""localhost:4000"", ""listen address"")
	flag.Parse()
	log.Fatal(ListenAndServe(*addr))
}
 
// A Server represents a chat server that accepts incoming connections.
type Server struct {
	add  chan *conn  // To add a connection
	rem  chan string // To remove a connection by name
	msg  chan string // To send a message to all connections
	stop chan bool   // To stop early
}
 
// ListenAndServe listens on the TCP network address addr for
// new chat client connections.
func ListenAndServe(addr string) error {
	ln, err := net.Listen(""tcp"", addr)
	if err != nil {
		return err
	}
	log.Println(""Listening for connections on"", addr)
	defer ln.Close()
	s := &Server{
		add:  make(chan *conn),
		rem:  make(chan string),
		msg:  make(chan string),
		stop: make(chan bool),
	}
	go s.handleConns()
	for {
		// TODO use AcceptTCP() so that we can get a TCPConn on which
		// we can call SetKeepAlive() and SetKeepAlivePeriod()
		rwc, err := ln.Accept()
		if err != nil {
			// TODO Could handle err.(net.Error).Temporary()
			// here by adding a backoff delay.
			close(s.stop)
			return err
		}
		log.Println(""New connection from"", rwc.RemoteAddr())
		go newConn(s, rwc).welcome()
	}
}
 
// handleConns is run as a go routine to handle adding and removal of
// chat client connections as well as broadcasting messages to them.
func (s *Server) handleConns() {
	// We define the `conns` map here rather than within Server,
	// and we use local function literals rather than methods to be
	// extra sure that the only place that touches this map is this
	// method. In this way we forgo any explicit locking needed as
	// we're the only go routine that can see or modify this.
	conns := make(map[string]*conn)
 
	var dropConn func(string)
	writeAll := func(str string) {
		log.Printf(""Broadcast: %q"", str)
		// TODO handle blocked connections
		for name, c := range conns {
			c.SetWriteDeadline(time.Now().Add(500 * time.Millisecond))
			_, err := c.Write([]byte(str))
			if err != nil {
				log.Printf(""Error writing to %q: %v"", name, err)
				c.Close()
				delete(conns, name)
				// Defer all the disconnect messages until after
				// we've closed all currently problematic conns.
				defer dropConn(name)
			}
		}
	}
 
	dropConn = func(name string) {
		if c, ok := conns[name]; ok {
			log.Printf(""Closing connection with %q from %v"",
				name, c.RemoteAddr())
			c.Close()
			delete(conns, name)
		} else {
			log.Printf(""Dropped connection with %q"", name)
		}
		str := fmt.Sprintf(""--- %q disconnected ---\n"", name)
		writeAll(str)
	}
 
	defer func() {
		writeAll(""Server stopping!\n"")
		for _, c := range conns {
			c.Close()
		}
	}()
 
	for {
		select {
		case c := <-s.add:
			if _, exists := conns[c.name]; exists {
				fmt.Fprintf(c, ""Name %q is not available\n"", c.name)
				go c.welcome()
				continue
			}
			str := fmt.Sprintf(""+++ %q connected +++\n"", c.name)
			writeAll(str)
			conns[c.name] = c
			go c.readloop()
		case str := <-s.msg:
			writeAll(str)
		case name := <-s.rem:
			dropConn(name)
		case <-s.stop:
			return
		}
	}
}
 
// A conn represents the server side of a single chat connection.
// Note we embed the bufio.Reader and net.Conn (and specifically in
// that order) so that a conn gets the appropriate methods from each
// to be a full io.ReadWriteCloser.
type conn struct {
	*bufio.Reader         // buffered input
	net.Conn              // raw connection
	server        *Server // the Server on which the connection arrived
	name          string
}
 
func newConn(s *Server, rwc net.Conn) *conn {
	return &conn{
		Reader: bufio.NewReader(rwc),
		Conn:   rwc,
		server: s,
	}
}
 
// welcome requests a name from the client before attempting to add the
// named connect to the set handled by the server.
func (c *conn) welcome() {
	var err error
	for c.name = """"; c.name == """"; {
		fmt.Fprint(c, ""Enter your name: "")
		c.name, err = c.ReadString('\n')
		if err != nil {
			log.Printf(""Reading name from %v: %v"", c.RemoteAddr(), err)
			c.Close()
			return
		}
		c.name = strings.TrimSpace(c.name)
	}
	// The server will take this *conn and do a final check
	// on the name, possibly starting c.welcome() again.
	c.server.add <- c
}
 
// readloop is started as a go routine by the server once the initial
// welcome phase has completed successfully. It reads single lines from
// the client and passes them to the server for broadcast to all chat
// clients (including us).
// Once done, we ask the server to remove (and close) our connection.
func (c *conn) readloop() {
	for {
		msg, err := c.ReadString('\n')
		if err != nil {
			break
		}
		//msg = strings.TrimSpace(msg)
		c.server.msg <- c.name + ""> "" + msg
	}
	c.server.rem <- c.name
}",4818,182
68689,http://rosettacode.org/wiki/Chinese_remainder_theorem,Chinese remainder theorem,"Suppose   




n

1




{\displaystyle n_{1}}

,   




n

2




{\displaystyle n_{2}}

,   



…


{\displaystyle \ldots }

,   




n

k




{\displaystyle n_{k}}

   are positive integers that are pairwise co-prime.  

Then, for any given sequence of integers   




a

1




{\displaystyle a_{1}}

,   




a

2




{\displaystyle a_{2}}

,   



…


{\displaystyle \dots }

,   




a

k




{\displaystyle a_{k}}

,   there exists an integer   



x


{\displaystyle x}

   solving the following system of simultaneous congruences:

 







x



≡

a

1




(
mod


n

1


)





x



≡

a

2




(
mod


n

2


)








 
 
⋮




x



≡

a

k




(
mod


n

k


)







{\displaystyle {\begin{aligned}x&\equiv a_{1}{\pmod {n_{1}}}\\x&\equiv a_{2}{\pmod {n_{2}}}\\&{}\ \ \vdots \\x&\equiv a_{k}{\pmod {n_{k}}}\end{aligned}}}


Furthermore, all solutions   



x


{\displaystyle x}

   of this system are congruent modulo the product,   



N
=

n

1



n

2


…

n

k




{\displaystyle N=n_{1}n_{2}\ldots n_{k}}

.



Task

Write a program to solve a system of linear congruences by applying the   Chinese Remainder Theorem.

If the system of equations cannot be solved, your program must somehow indicate this.

(It may throw an exception or return a special false value.)

Since there are infinitely many solutions, the program should return the unique solution   



s


{\displaystyle s}

   where   



0
≤
s
≤

n

1



n

2


…

n

k




{\displaystyle 0\leq s\leq n_{1}n_{2}\ldots n_{k}}

.


Show the functionality of this program by printing the result such that the   



n


{\displaystyle n}

's   are   



[
3
,
5
,
7
]


{\displaystyle [3,5,7]}

   and the   



a


{\displaystyle a}

's   are   



[
2
,
3
,
2
]


{\displaystyle [2,3,2]}

.


Algorithm:   The following algorithm only applies if the   




n

i




{\displaystyle n_{i}}

's   are pairwise co-prime.

Suppose, as above, that a solution is required for the system of congruences:

 



x
≡

a

i




(
mod


n

i


)



f
o
r


i
=
1
,
…
,
k


{\displaystyle x\equiv a_{i}{\pmod {n_{i}}}\quad \mathrm {for} \;i=1,\ldots ,k}


Again, to begin, the product   



N
=

n

1



n

2


…

n

k




{\displaystyle N=n_{1}n_{2}\ldots n_{k}}

   is defined.

Then a solution   



x


{\displaystyle x}

   can be found as follows:

For each   



i


{\displaystyle i}

,   the integers   




n

i




{\displaystyle n_{i}}

   and   



N

/


n

i




{\displaystyle N/n_{i}}

   are co-prime.

Using the   Extended Euclidean algorithm,   we can find integers   




r

i




{\displaystyle r_{i}}

   and   




s

i




{\displaystyle s_{i}}

   such that   




r

i



n

i


+

s

i


N

/


n

i


=
1


{\displaystyle r_{i}n_{i}+s_{i}N/n_{i}=1}

.

Then, one solution to the system of simultaneous congruences is:

 



x
=

∑

i
=
1


k



a

i



s

i


N

/


n

i




{\displaystyle x=\sum _{i=1}^{k}a_{i}s_{i}N/n_{i}}


and the minimal solution,

 



x


(
mod

N
)



{\displaystyle x{\pmod {N}}}

.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
var one = big.NewInt(1)
 
func crt(a, n []*big.Int) (*big.Int, error) {
    p := new(big.Int).Set(n[0])
    for _, n1 := range n[1:] {
        p.Mul(p, n1)
    }
    var x, q, s, z big.Int
    for i, n1 := range n {
        q.Div(p, n1)
        z.GCD(nil, &s, n1, &q)
        if z.Cmp(one) != 0 {
            return nil, fmt.Errorf(""%d not coprime"", n1)
        }
        x.Add(&x, s.Mul(a[i], s.Mul(&s, &q)))
    }
    return x.Mod(&x, p), nil
}
 
func main() {
    n := []*big.Int{
        big.NewInt(3),
        big.NewInt(5),
        big.NewInt(7),
    }
    a := []*big.Int{
        big.NewInt(2),
        big.NewInt(3),
        big.NewInt(2),
    }
    fmt.Println(crt(a, n))
}",736,39
68832,http://rosettacode.org/wiki/Chaos_game,Chaos game,"The Chaos Game is a method of generating the attractor of an iterated function system (IFS).

One of the best-known and simplest examples creates a fractal, using a polygon and an initial point selected at random.



Task
Play the Chaos Game using the corners of an equilateral triangle as the reference points.   Add a starting point at random (preferably inside the triangle).   Then add the next point halfway between the starting point and one of the reference points.   This reference point is chosen at random.

After a sufficient number of iterations, the image of a Sierpinski Triangle should emerge.



See also
 The Game of Chaos

",#Go,Go,"package main
 
import (
	""fmt""
	""image""
	""image/color""
	""image/draw""
	""image/gif""
	""log""
	""math""
	""math/rand""
	""os""
	""time""
)
 
var bwPalette = color.Palette{
	color.Transparent,
	color.White,
	color.RGBA{R: 0xff, A: 0xff},
	color.RGBA{G: 0xff, A: 0xff},
	color.RGBA{B: 0xff, A: 0xff},
}
 
func main() {
	const (
		width          = 160
		frames         = 100
		pointsPerFrame = 50
		delay          = 100 * time.Millisecond
		filename       = ""chaos_anim.gif""
	)
 
	var tan60 = math.Sin(math.Pi / 3)
	height := int(math.Round(float64(width) * tan60))
	b := image.Rect(0, 0, width, height)
	vertices := [...]image.Point{
		{0, height}, {width, height}, {width / 2, 0},
	}
 
	// Make a filled triangle.
	m := image.NewPaletted(b, bwPalette)
	for y := b.Min.Y; y < b.Max.Y; y++ {
		bg := int(math.Round(float64(b.Max.Y-y) / 2 / tan60))
		for x := b.Min.X + bg; x < b.Max.X-bg; x++ {
			m.SetColorIndex(x, y, 1)
		}
	}
 
	// Pick starting point
	var p image.Point
	rand.Seed(time.Now().UnixNano())
	p.Y = rand.Intn(height) + b.Min.Y
	p.X = rand.Intn(width) + b.Min.X // TODO: make within triangle
 
	anim := newAnim(frames, delay)
	addFrame(anim, m)
	for i := 1; i < frames; i++ {
		for j := 0; j < pointsPerFrame; j++ {
			// Pick a random vertex
			vi := rand.Intn(len(vertices))
			v := vertices[vi]
			// Move p halfway there
			p.X = (p.X + v.X) / 2
			p.Y = (p.Y + v.Y) / 2
			m.SetColorIndex(p.X, p.Y, uint8(2+vi))
		}
		addFrame(anim, m)
	}
	if err := writeAnim(anim, filename); err != nil {
		log.Fatal(err)
	}
	fmt.Printf(""wrote to %q\n"", filename)
}
 
// Stuff for making a simple GIF animation.
 
func newAnim(frames int, delay time.Duration) *gif.GIF {
	const gifDelayScale = 10 * time.Millisecond
	g := &gif.GIF{
		Image: make([]*image.Paletted, 0, frames),
		Delay: make([]int, 1, frames),
	}
	g.Delay[0] = int(delay / gifDelayScale)
	return g
}
func addFrame(anim *gif.GIF, m *image.Paletted) {
	b := m.Bounds()
	dst := image.NewPaletted(b, m.Palette)
	draw.Draw(dst, b, m, image.ZP, draw.Src)
	anim.Image = append(anim.Image, dst)
	if len(anim.Delay) < len(anim.Image) {
		anim.Delay = append(anim.Delay, anim.Delay[0])
	}
}
func writeAnim(anim *gif.GIF, filename string) error {
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	err = gif.EncodeAll(f, anim)
	if cerr := f.Close(); err == nil {
		err = cerr
	}
	return err
}",2351,105
68987,http://rosettacode.org/wiki/Check_that_file_exists,Check that file exists,"Task

Verify that a file called     input.txt     and   a directory called     docs     exist.



This should be done twice:  

   once for the current working directory,   and
   once for a file and a directory in the filesystem root.


Optional criteria (May 2015):   verify it works with:

   zero-length files
   an unusual filename:     `Abdu'l-Bahá.txt  

",#Go,Go,"package main
 
import (
    ""fmt""
    ""os""
)
 
func printStat(p string) {
    switch i, err := os.Stat(p); {
    case err != nil:
        fmt.Println(err)
    case i.IsDir():
        fmt.Println(p, ""is a directory"")
    default:
        fmt.Println(p, ""is a file"")
    }
}
 
func main() {
    printStat(""input.txt"")
    printStat(""/input.txt"")
    printStat(""docs"")
    printStat(""/docs"")
}",390,24
69130,http://rosettacode.org/wiki/Character_codes,Character codes,"

Task

Given a character value in your language, print its code   (could be ASCII code, Unicode code, or whatever your language uses).



Example

The character   'a'   (lowercase letter A)   has a code of 97 in ASCII   (as well as Unicode, as ASCII forms the beginning of Unicode).

Conversely, given a code, print out the corresponding character.



",#Go,Go,"fmt.Println('a') // prints ""97""
fmt.Println('π') // prints ""960""",64,2
69578,http://rosettacode.org/wiki/Chaocipher,Chaocipher,"Description

The Chaocipher was invented by J.F.Byrne in 1918 and, although simple by modern cryptographic standards, does not appear to have been broken until the algorithm was finally disclosed by his family in 2010.

The algorithm is described in this paper by M.Rubin in 2010 and there is a C# implementation here.



Task

Code the algorithm in your language and to test that it works with the plaintext 'WELLDONEISBETTERTHANWELLSAID' used in the paper itself.



",#Go,Go,"package main
 
import(
    ""fmt""
    ""strings""
    ""unicode/utf8""
)
 
type Mode int
 
const(
    Encrypt Mode = iota
    Decrypt
)
 
const(
    lAlphabet = ""HXUCZVAMDSLKPEFJRIGTWOBNYQ""
    rAlphabet = ""PTLNBQDEOYSFAVZKGJRIHWXUMC""
)
 
func Chao(text string, mode Mode, showSteps bool) string {
    len := len(text)
    if utf8.RuneCountInString(text) != len {
        fmt.Println(""Text contains non-ASCII characters"")
        return """"
    }
    left  := lAlphabet
    right := rAlphabet
    eText := make([]byte, len)
    temp  := make([]byte, 26)
 
    for i := 0; i < len; i++ {
        if showSteps {
            fmt.Println(left, "" "", right)
        }
        var index int
        if mode == Encrypt {
            index = strings.IndexByte(right, text[i])
            eText[i] = left[index]
        } else {
            index = strings.IndexByte(left, text[i])
            eText[i] = right[index]
        }
        if i == len - 1 {
            break
        }
 
        // permute left
        for j := index; j < 26; j++ {
            temp[j - index] = left[j]
        }
        for j := 0; j < index; j++ {
            temp[26 - index + j] = left[j]
        }
        store := temp[1]
        for j := 2; j < 14; j++ {
            temp[j - 1] = temp[j]
        }
        temp[13] = store
        left = string(temp[:])
 
        // permute right
 
        for j := index; j < 26; j++ {
            temp[j - index] = right[j]
        }
        for j := 0; j < index; j++ {
            temp[26 - index + j] = right[j]
        }
        store = temp[0]
        for j := 1; j < 26; j++ {
            temp[j - 1] = temp[j]
        }
        temp[25] = store
        store = temp[2]
        for j := 3; j < 14; j++ {
            temp[j - 1] = temp[j]
        }
        temp[13] = store
        right = string(temp[:])
    }
 
    return string(eText[:])
}
 
func main() {
    plainText := ""WELLDONEISBETTERTHANWELLSAID""
    fmt.Println(""The original plaintext is :"", plainText)
    fmt.Print(""\nThe left and right alphabets after each permutation "")
    fmt.Println(""during encryption are :\n"")
    cipherText := Chao(plainText, Encrypt, true)
    fmt.Println(""\nThe ciphertext is :"",  cipherText)
    plainText2 := Chao(cipherText, Decrypt, false)
    fmt.Println(""\nThe recovered plaintext is :"", plainText2)
}",2314,95
69628,http://rosettacode.org/wiki/Catalan_numbers/Pascal%27s_triangle,Catalan numbers/Pascal's triangle,"Task

Print out the first   15   Catalan numbers by extracting them from Pascal's triangle.



See

   Catalan Numbers and the Pascal Triangle.     This method enables calculation of Catalan Numbers using only addition and subtraction.
   Catalan's Triangle for a Number Triangle that generates Catalan Numbers using only addition.
   Sequence A000108 on OEIS has a lot of information on Catalan Numbers.
Related Tasks

Pascal's triangle
",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    const n = 15
    t := [n + 2]uint64{0, 1}
    for i := 1; i <= n; i++ {
        for j := i; j > 1; j-- {
            t[j] += t[j-1]
        }
        t[i+1] = t[i]
        for j := i + 1; j > 1; j-- {
            t[j] += t[j-1]
        }
        fmt.Printf(""%2d : %d\n"", i, t[i+1]-t[i])
    }
}",342,18
69652,http://rosettacode.org/wiki/Catmull%E2%80%93Clark_subdivision_surface,Catmull–Clark subdivision surface,"Implement the Catmull-Clark surface subdivision (description on Wikipedia), which is an algorithm that maps from a surface (described as a set of points and a set of polygons with vertices at those points) to another more refined surface. The resulting surface will always consist of a mesh of quadrilaterals.

The process for computing the new locations of the points works as follows when the surface is free of holes:

 Starting cubic mesh; the meshes below are derived from this.
 After one round of the Catmull-Clark algorithm applied to a cubic mesh.
 After two rounds of the Catmull-Clark algorithm. As can be seen, this is converging to a surface that looks nearly spherical.
 for each face, a face point is created which is the average of all the points of the face.
 for each edge, an edge point is created which is the average between the center of the edge and the center of the segment made with the face points of the two adjacent faces.
 for each vertex point, its coordinates are updated from (new_coords):
 the old coordinates (old_coords),
 the average of the face points of the faces the point belongs to (avg_face_points),
 the average of the centers of edges the point belongs to (avg_mid_edges),
 how many faces a point belongs to (n), then use this formula:
     m1 = (n - 3) / n
     m2 = 1 / n
     m3 = 2 / n
     new_coords = (m1 * old_coords)
                + (m2 * avg_face_points)
                + (m3 * avg_mid_edges)

Then each face is replaced by new faces made with the new points,

 for a triangle face (a,b,c):
   (a, edge_pointab, face_pointabc, edge_pointca)
   (b, edge_pointbc, face_pointabc, edge_pointab)
   (c, edge_pointca, face_pointabc, edge_pointbc)

 for a quad face (a,b,c,d):
   (a, edge_pointab, face_pointabcd, edge_pointda)
   (b, edge_pointbc, face_pointabcd, edge_pointab)
   (c, edge_pointcd, face_pointabcd, edge_pointbc)
   (d, edge_pointda, face_pointabcd, edge_pointcd)

When there is a hole, we can detect it as follows:

 an edge is the border of a hole if it belongs to only one face,
 a point is on the border of a hole if nfaces != nedges with nfaces the number of faces the point belongs to, and nedges the number of edges a point belongs to.
On the border of a hole the subdivision occurs as follows:

 for the edges that are on the border of a hole, the edge point is just the middle of the edge.
 for the vertex points that are on the border of a hole, the new coordinates are calculated as follows:
 in all the edges the point belongs to, only take in account the middles of the edges that are on the border of the hole
 calculate the average between these points (on the hole boundary) and the old coordinates (also on the hole boundary).
For edges and vertices not next to a hole, the standard algorithm from above is used.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
type (
    Point [3]float64
    Face  []int
 
    Edge struct {
        pn1 int   // point number 1
        pn2 int   // point number 2
        fn1 int   // face number 1
        fn2 int   // face number 2
        cp  Point // center point
    }
 
    PointEx struct {
        p Point
        n int
    }
)
 
func sumPoint(p1, p2 Point) Point {
    sp := Point{}
    for i := 0; i < 3; i++ {
        sp[i] = p1[i] + p2[i]
    }
    return sp
}
 
func mulPoint(p Point, m float64) Point {
    mp := Point{}
    for i := 0; i < 3; i++ {
        mp[i] = p[i] * m
    }
    return mp
}
 
func divPoint(p Point, d float64) Point {
    return mulPoint(p, 1.0/d)
}
 
func centerPoint(p1, p2 Point) Point {
    return divPoint(sumPoint(p1, p2), 2)
}
 
func getFacePoints(inputPoints []Point, inputFaces []Face) []Point {
    facePoints := make([]Point, len(inputFaces))
    for i, currFace := range inputFaces {
        facePoint := Point{}
        for _, cpi := range currFace {
            currPoint := inputPoints[cpi]
            facePoint = sumPoint(facePoint, currPoint)
        }
        facePoint = divPoint(facePoint, float64(len(currFace)))
        facePoints[i] = facePoint
    }
    return facePoints
}
 
func getEdgesFaces(inputPoints []Point, inputFaces []Face) []Edge {
    var edges [][3]int
    for faceNum, face := range inputFaces {
        numPoints := len(face)
        for pointIndex := 0; pointIndex < numPoints; pointIndex++ {
            pointNum1 := face[pointIndex]
            var pointNum2 int
            if pointIndex < numPoints-1 {
                pointNum2 = face[pointIndex+1]
            } else {
                pointNum2 = face[0]
            }
            if pointNum1 > pointNum2 {
                pointNum1, pointNum2 = pointNum2, pointNum1
            }
            edges = append(edges, [3]int{pointNum1, pointNum2, faceNum})
        }
    }
    sort.Slice(edges, func(i, j int) bool {
        if edges[i][0] == edges[j][0] {
            if edges[i][1] == edges[j][1] {
                return edges[i][2] < edges[j][2]
            }
            return edges[i][1] < edges[j][1]
        }
        return edges[i][0] < edges[j][0]
    })
    numEdges := len(edges)
    eIndex := 0
    var mergedEdges [][4]int
    for eIndex < numEdges {
        e1 := edges[eIndex]
        if eIndex < numEdges-1 {
            e2 := edges[eIndex+1]
            if e1[0] == e2[0] && e1[1] == e2[1] {
                mergedEdges = append(mergedEdges, [4]int{e1[0], e1[1], e1[2], e2[2]})
                eIndex += 2
            } else {
                mergedEdges = append(mergedEdges, [4]int{e1[0], e1[1], e1[2], -1})
                eIndex++
            }
        } else {
            mergedEdges = append(mergedEdges, [4]int{e1[0], e1[1], e1[2], -1})
            eIndex++
        }
    }
    var edgesCenters []Edge
    for _, me := range mergedEdges {
        p1 := inputPoints[me[0]]
        p2 := inputPoints[me[1]]
        cp := centerPoint(p1, p2)
        edgesCenters = append(edgesCenters, Edge{me[0], me[1], me[2], me[3], cp})
    }
    return edgesCenters
}
 
func getEdgePoints(inputPoints []Point, edgesFaces []Edge, facePoints []Point) []Point {
    edgePoints := make([]Point, len(edgesFaces))
    for i, edge := range edgesFaces {
        cp := edge.cp
        fp1 := facePoints[edge.fn1]
        var fp2 Point
        if edge.fn2 == -1 {
            fp2 = fp1
        } else {
            fp2 = facePoints[edge.fn2]
        }
        cfp := centerPoint(fp1, fp2)
        edgePoints[i] = centerPoint(cp, cfp)
    }
    return edgePoints
}
 
func getAvgFacePoints(inputPoints []Point, inputFaces []Face, facePoints []Point) []Point {
    numPoints := len(inputPoints)
    tempPoints := make([]PointEx, numPoints)
    for faceNum := range inputFaces {
        fp := facePoints[faceNum]
        for _, pointNum := range inputFaces[faceNum] {
            tp := tempPoints[pointNum].p
            tempPoints[pointNum].p = sumPoint(tp, fp)
            tempPoints[pointNum].n++
        }
    }
    avgFacePoints := make([]Point, numPoints)
    for i, tp := range tempPoints {
        avgFacePoints[i] = divPoint(tp.p, float64(tp.n))
    }
    return avgFacePoints
}
 
func getAvgMidEdges(inputPoints []Point, edgesFaces []Edge) []Point {
    numPoints := len(inputPoints)
    tempPoints := make([]PointEx, numPoints)
    for _, edge := range edgesFaces {
        cp := edge.cp
        for _, pointNum := range []int{edge.pn1, edge.pn2} {
            tp := tempPoints[pointNum].p
            tempPoints[pointNum].p = sumPoint(tp, cp)
            tempPoints[pointNum].n++
        }
    }
    avgMidEdges := make([]Point, len(tempPoints))
    for i, tp := range tempPoints {
        avgMidEdges[i] = divPoint(tp.p, float64(tp.n))
    }
    return avgMidEdges
}
 
func getPointsFaces(inputPoints []Point, inputFaces []Face) []int {
    numPoints := len(inputPoints)
    pointsFaces := make([]int, numPoints)
    for faceNum := range inputFaces {
        for _, pointNum := range inputFaces[faceNum] {
            pointsFaces[pointNum]++
        }
    }
    return pointsFaces
}
 
func getNewPoints(inputPoints []Point, pointsFaces []int, avgFacePoints, avgMidEdges []Point) []Point {
    newPoints := make([]Point, len(inputPoints))
    for pointNum := range inputPoints {
        n := float64(pointsFaces[pointNum])
        m1, m2, m3 := (n-3)/n, 1.0/n, 2.0/n
        oldCoords := inputPoints[pointNum]
        p1 := mulPoint(oldCoords, m1)
        afp := avgFacePoints[pointNum]
        p2 := mulPoint(afp, m2)
        ame := avgMidEdges[pointNum]
        p3 := mulPoint(ame, m3)
        p4 := sumPoint(p1, p2)
        newPoints[pointNum] = sumPoint(p4, p3)
    }
    return newPoints
}
 
func switchNums(pointNums [2]int) [2]int {
    if pointNums[0] < pointNums[1] {
        return pointNums
    }
    return [2]int{pointNums[1], pointNums[0]}
}
 
func cmcSubdiv(inputPoints []Point, inputFaces []Face) ([]Point, []Face) {
    facePoints := getFacePoints(inputPoints, inputFaces)
    edgesFaces := getEdgesFaces(inputPoints, inputFaces)
    edgePoints := getEdgePoints(inputPoints, edgesFaces, facePoints)
    avgFacePoints := getAvgFacePoints(inputPoints, inputFaces, facePoints)
    avgMidEdges := getAvgMidEdges(inputPoints, edgesFaces)
    pointsFaces := getPointsFaces(inputPoints, inputFaces)
    newPoints := getNewPoints(inputPoints, pointsFaces, avgFacePoints, avgMidEdges)
    var facePointNums []int
    nextPointNum := len(newPoints)
    for _, facePoint := range facePoints {
        newPoints = append(newPoints, facePoint)
        facePointNums = append(facePointNums, nextPointNum)
        nextPointNum++
    }
    edgePointNums := make(map[[2]int]int)
    for edgeNum := range edgesFaces {
        pointNum1 := edgesFaces[edgeNum].pn1
        pointNum2 := edgesFaces[edgeNum].pn2
        edgePoint := edgePoints[edgeNum]
        newPoints = append(newPoints, edgePoint)
        edgePointNums[[2]int{pointNum1, pointNum2}] = nextPointNum
        nextPointNum++
    }
    var newFaces []Face
    for oldFaceNum, oldFace := range inputFaces {
        if len(oldFace) == 4 {
            a, b, c, d := oldFace[0], oldFace[1], oldFace[2], oldFace[3]
            facePointAbcd := facePointNums[oldFaceNum]
            edgePointAb := edgePointNums[switchNums([2]int{a, b})]
            edgePointDa := edgePointNums[switchNums([2]int{d, a})]
            edgePointBc := edgePointNums[switchNums([2]int{b, c})]
            edgePointCd := edgePointNums[switchNums([2]int{c, d})]
            newFaces = append(newFaces, Face{a, edgePointAb, facePointAbcd, edgePointDa})
            newFaces = append(newFaces, Face{b, edgePointBc, facePointAbcd, edgePointAb})
            newFaces = append(newFaces, Face{c, edgePointCd, facePointAbcd, edgePointBc})
            newFaces = append(newFaces, Face{d, edgePointDa, facePointAbcd, edgePointCd})
        }
    }
    return newPoints, newFaces
}
 
func main() {
    inputPoints := []Point{
        {-1.0, 1.0, 1.0},
        {-1.0, -1.0, 1.0},
        {1.0, -1.0, 1.0},
        {1.0, 1.0, 1.0},
        {1.0, -1.0, -1.0},
        {1.0, 1.0, -1.0},
        {-1.0, -1.0, -1.0},
        {-1.0, 1.0, -1.0},
    }
 
    inputFaces := []Face{
        {0, 1, 2, 3},
        {3, 2, 4, 5},
        {5, 4, 6, 7},
        {7, 0, 3, 5},
        {7, 6, 1, 0},
        {6, 1, 2, 4},
    }
 
    outputPoints := make([]Point, len(inputPoints))
    outputFaces := make([]Face, len(inputFaces))
    copy(outputPoints, inputPoints)
    copy(outputFaces, inputFaces)
    iterations := 1
    for i := 0; i < iterations; i++ {
        outputPoints, outputFaces = cmcSubdiv(outputPoints, outputFaces)
    }
    for _, p := range outputPoints {
        fmt.Printf(""% .4f\n"", p)
    }
    fmt.Println()
    for _, f := range outputFaces {
        fmt.Printf(""%2d\n"", f)
    }
}",8873,286
69694,http://rosettacode.org/wiki/Case-sensitivity_of_identifiers,Case-sensitivity of identifiers,"Three dogs (Are there three dogs or one dog?) is a code snippet used to illustrate the lettercase sensitivity of the programming language. For a case-sensitive language, the identifiers dog, Dog and DOG are all different and we should get the output:

The three dogs are named Benjamin, Samba and Bernie.

For a language that is lettercase insensitive, we get the following output:

There is just one dog named Bernie.



Related task

 Unicode variable names

",#Go,Go,"package dogs
 
import ""fmt""
 
// Three variables, three different names.
// (It wouldn't compile if the compiler saw the variable names as the same.)
var dog = ""Salt""
var Dog = ""Pepper""
var DOG = ""Mustard""
 
func PackageSees() map[*string]int {
    // Print dogs visible from here.
    fmt.Println(""Package sees:"", dog, Dog, DOG)
    // Return addresses of the variables visible from here.
    // The point of putting them in a map is that maps store only
    // unique keys, so it will end up with three items only if
    // the variables really represent different places in memory.
    return map[*string]int{&dog: 1, &Dog: 1, &DOG: 1}
}",640,19
69716,http://rosettacode.org/wiki/Canny_edge_detector,Canny edge detector,"Task

Write a program that performs so-called canny edge detection on an image.



A possible algorithm consists of the following steps:

 Noise reduction.   May be performed by Gaussian filter. 
  
 Compute intensity gradient   (matrices 




G

x




{\displaystyle G_{x}}

 and 




G

y




{\displaystyle G_{y}}

)   and its magnitude   



G


{\displaystyle G}

:
           



G
=



G

x


2


+

G

y


2






{\displaystyle G={\sqrt {G_{x}^{2}+G_{y}^{2}}}}


May be performed by convolution of an image with Sobel operators. 
  
 Non-maximum suppression.   
For each pixel compute the orientation of intensity gradient vector:   



θ
=


a
t
a
n
2



(

G

y


,


G

x


)



{\displaystyle \theta ={\rm {atan2}}\left(G_{y},\,G_{x}\right)}

.     
Transform   angle 



θ


{\displaystyle \theta }

   to one of four directions:   0, 45, 90, 135 degrees.     
Compute new array   



N


{\displaystyle N}

:     if         



G

(

p

a


)

<
G

(
p
)

<
G

(

p

b


)



{\displaystyle G\left(p_{a}\right)<G\left(p\right)<G\left(p_{b}\right)}


where   



p


{\displaystyle p}

   is the current pixel,   




p

a




{\displaystyle p_{a}}

   and   




p

b




{\displaystyle p_{b}}

   are the two neighbour pixels in the direction of gradient,   
then     



N
(
p
)
=
G
(
p
)


{\displaystyle N(p)=G(p)}

,       otherwise   



N
(
p
)
=
0


{\displaystyle N(p)=0}

.   
Nonzero pixels in resulting array correspond to local maxima of   



G


{\displaystyle G}

   in direction   



θ
(
p
)


{\displaystyle \theta (p)}

. 
  
 Tracing edges with hysteresis.   
At this stage two thresholds for the values of   



G


{\displaystyle G}

   are introduced:   




T

m
i
n




{\displaystyle T_{min}}

   and   




T

m
a
x




{\displaystyle T_{max}}

.   
Starting from pixels with   



N
(
p
)
⩾

T

m
a
x




{\displaystyle N(p)\geqslant T_{max}}

,   
find all paths of pixels with   



N
(
p
)
⩾

T

m
i
n




{\displaystyle N(p)\geqslant T_{min}}

   and put them to the resulting image.

",#Go,Go,"package main
 
import (
    ed ""github.com/Ernyoke/Imger/edgedetection""
    ""github.com/Ernyoke/Imger/imgio""
    ""log""
)
 
func main() {
    img, err := imgio.ImreadRGBA(""Valve_original_(1).png"")
    if err != nil {
        log.Fatal(""Could not read image"", err)
    }
 
    cny, err := ed.CannyRGBA(img, 15, 45, 5)
    if err != nil {
        log.Fatal(""Could not perform Canny Edge detection"")
    }
 
    err = imgio.Imwrite(cny, ""Valve_canny_(1).png"")
    if err != nil {
        log.Fatal(""Could not write Canny image to disk"")
    }
}",540,24
69752,http://rosettacode.org/wiki/Canonicalize_CIDR,Canonicalize CIDR,"Task

Implement a function or program that, given a range of IPv4 addresses in CIDR notation (dotted-decimal/network-bits), will return/output the same range in canonical form.

That is, the IP address portion of the output CIDR block must not contain any set (1) bits in the host part of the address.



Example

Given   87.70.141.1/22,   your code should output   87.70.140.0/22



Explanation

An Internet Protocol version 4 address is a 32-bit value, conventionally represented as a number in base 256 using dotted-decimal notation, where each base-256 ""digit"" is represented by the digit value in decimal and the digits are separated by periods. Logically, this 32-bit value represents two components: the leftmost (most-significant) bits determine the ""network"" portion of the address, while the rightmost (least-significant) bits determine the ""host"" portion. Classless Internet Domain Routing block notation indicates where the boundary between these two components is for a given address by adding a slash followed by the number of bits in the network portion.

In general, CIDR blocks stand in for the entire set of IP addresses sharing the same ""network"" component; it's common to see access control lists specify a single IP address using CIDR with /32 to indicate that only the one address is included. Often, the tools using this notation expect the address to be entered in canonical form, in which the ""host"" bits are all zeroes in the binary representation. But careless network admins may provide CIDR blocks without canonicalizing them first. This task handles the canonicalization.

The example address, 87.70.141.1, translates into 01010111010001101000110100000001 in binary notation zero-padded to 32 bits. The /22 means that the first 22 of those bits determine the match; the final 10 bits should be 0. But they instead include two 1 bits: 0100000001. So to canonicalize the address, change those 1's to 0's to yield 01010111010001101000110000000000, which in dotted-decimal is 87.70.140.0.



More examples for testing
        36.18.154.103/12    →  36.16.0.0/12
        62.62.197.11/29     →  62.62.197.8/29
        67.137.119.181/4    →  64.0.0.0/4
        161.214.74.21/24    →  161.214.74.0/24
        184.232.176.184/18  →  184.232.128.0/18


",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""strconv""
    ""strings""
)
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
// canonicalize a CIDR block: make sure none of the host bits are set
func canonicalize(cidr string) string {
    // dotted-decimal / bits in network part
    split := strings.Split(cidr, ""/"")
    dotted := split[0]
    size, err := strconv.Atoi(split[1])
    check(err)
 
    // get IP as binary string
    var bin []string
    for _, n := range strings.Split(dotted, ""."") {
        i, err := strconv.Atoi(n)
        check(err)
        bin = append(bin, fmt.Sprintf(""%08b"", i))
    }
    binary := strings.Join(bin, """")
 
    // replace the host part with all zeros
    binary = binary[0:size] + strings.Repeat(""0"", 32-size)
 
    // convert back to dotted-decimal
    var canon []string
    for i := 0; i < len(binary); i += 8 {
        num, err := strconv.ParseInt(binary[i:i+8], 2, 64)
        check(err)
        canon = append(canon, fmt.Sprintf(""%d"", num))
    }
 
    // and return
    return strings.Join(canon, ""."") + ""/"" + split[1]
}
 
func main() {
    tests := []string{
        ""87.70.141.1/22"",
        ""36.18.154.103/12"",
        ""62.62.197.11/29"",
        ""67.137.119.181/4"",
        ""161.214.74.21/24"",
        ""184.232.176.184/18"",
    }
 
    for _, test := range tests {
        fmt.Printf(""%-18s -> %s\n"", test, canonicalize(test))
    }
}",1413,61
69753,http://rosettacode.org/wiki/Casting_out_nines,Casting out nines,"Task   (in three parts)



Part 1
Write a procedure (say 





c
o
9


(
x
)


{\displaystyle {\mathit {co9}}(x)}

) which implements Casting Out Nines as described by returning the checksum for 



x


{\displaystyle x}

. Demonstrate the procedure using the examples given there, or others you may consider lucky.

Part 2
Notwithstanding past Intel microcode errors, checking computer calculations like this would not be sensible. To find a computer use for your procedure:

 Consider the statement ""318682 is 101558 + 217124 and squared is 101558217124"" (see: Kaprekar numbers#Casting Out Nines (fast)).
 note that 



318682


{\displaystyle 318682}

 has the same checksum as (



101558
+
217124


{\displaystyle 101558+217124}

);
 note that 



101558217124


{\displaystyle 101558217124}

 has the same checksum as (



101558
+
217124


{\displaystyle 101558+217124}

) because for a Kaprekar they are made up of the same digits (sometimes with extra zeroes);
 note that this implies that for Kaprekar numbers the checksum of 



k


{\displaystyle k}

 equals the checksum of 




k

2




{\displaystyle k^{2}}

.
Demonstrate that your procedure can be used to generate or filter a range of numbers with the property 





c
o
9


(
k
)
=


c
o
9


(

k

2


)


{\displaystyle {\mathit {co9}}(k)={\mathit {co9}}(k^{2})}

 and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.

Part 3
Considering this MathWorld page, produce a efficient algorithm based on the more mathematical treatment of Casting Out Nines, and realizing:

 





c
o
9


(
x
)


{\displaystyle {\mathit {co9}}(x)}

 is the residual of 



x


{\displaystyle x}

 mod 



9


{\displaystyle 9}

;
 the procedure can be extended to bases other than 9.
Demonstrate your algorithm by generating or filtering a range of numbers with the property 



k
%
(


B
a
s
e


−
1
)
==
(

k

2


)
%
(


B
a
s
e


−
1
)


{\displaystyle k\%({\mathit {Base}}-1)==(k^{2})\%({\mathit {Base}}-1)}

 and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.



related tasks
 First perfect square in base N with N unique digits
 Kaprekar numbers

",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""strconv""
)
 
// A casting out nines algorithm.
 
// Quoting from: http://mathforum.org/library/drmath/view/55926.html
/*
First, for any number we can get a single digit, which I will call the 
""check digit,"" by repeatedly adding the digits. That is, we add the 
digits of the number, then if there is more than one digit in the 
result we add its digits, and so on until there is only one digit 
left.
 
...
 
You may notice that when you add the digits of 6395, if you just 
ignore the 9, and the 6+3 = 9, you still end up with 5 as your check 
digit. This is because any 9's make no difference in the result. 
That's why the process is called ""casting out"" nines. Also, at any 
step in the process, you can add digits, not just at the end: to do 
8051647, I can say 8 + 5 = 13, which gives 4; plus 1 is 5, plus 6 is 
11, which gives 2, plus 4 is 6, plus 7 is 13 which gives 4. I never 
have to work with numbers bigger than 18.
*/
// The twist is that co9Peterson returns a function to do casting out nines
// in any specified base from 2 to 36.
func co9Peterson(base int) (cob func(string) (byte, error), err error) {
    if base < 2 || base > 36 {
        return nil, fmt.Errorf(""co9Peterson: %d invalid base"", base)
    }
    // addDigits adds two digits in the specified base.
    // People perfoming casting out nines by hand would usually have their
    // addition facts memorized.  In a program, a lookup table might be
    // analogous, but we expediently use features of the programming language
    // to add digits in the specified base.
    addDigits := func(a, b byte) (string, error) {
        ai, err := strconv.ParseInt(string(a), base, 64)
        if err != nil {
            return """", err
        }
        bi, err := strconv.ParseInt(string(b), base, 64)
        if err != nil {
            return """", err
        }
        return strconv.FormatInt(ai+bi, base), nil
    }
    // a '9' in the specified base.  that is, the greatest digit.
    s9 := strconv.FormatInt(int64(base-1), base)
    b9 := s9[0]
    // define result function.  The result function may return an error
    // if n is not a valid number in the specified base.
    cob = func(n string) (r byte, err error) {
        r = '0'
        for i := 0; i < len(n); i++ { // for each digit of the number
            d := n[i]
            switch {
            case d == b9: // if the digit is '9' of the base, cast it out
                continue
            // if the result so far is 0, the digit becomes the result
            case r == '0':
                r = d
                continue
            }
            // otherwise, add the new digit to the result digit
            s, err := addDigits(r, d)
            if err != nil {
                return 0, err
            }
            switch {
            case s == s9: // if the sum is ""9"" of the base, cast it out
                r = '0'
                continue
            // if the sum is a single digit, it becomes the result
            case len(s) == 1:
                r = s[0]
                continue
            }
            // otherwise, reduce this two digit intermediate result before
            // continuing.
            r, err = cob(s)
            if err != nil {
                return 0, err
            }
        }
        return
    }
    return
}
 
// Subset code required by task.  Given a base and a range specified with
// beginning and ending number in that base, return candidate Kaprekar numbers
// based on the observation that k%(base-1) must equal (k*k)%(base-1).
// For the % operation, rather than the language built-in operator, use
// the method of casting out nines, which in fact implements %(base-1).
func subset(base int, begin, end string) (s []string, err error) {
    // convert begin, end to native integer types for easier iteration
    begin64, err := strconv.ParseInt(begin, base, 64)
    if err != nil {
        return nil, fmt.Errorf(""subset begin: %v"", err)
    }
    end64, err := strconv.ParseInt(end, base, 64)
    if err != nil {
        return nil, fmt.Errorf(""subset end: %v"", err)
    }
    // generate casting out nines function for specified base
    cob, err := co9Peterson(base)
    if err != nil {
        return
    }
    for k := begin64; k <= end64; k++ {
        ks := strconv.FormatInt(k, base)
        rk, err := cob(ks)
        if err != nil { // assertion
            panic(err) // this would indicate a bug in subset
        }
        rk2, err := cob(strconv.FormatInt(k*k, base))
        if err != nil { // assertion
            panic(err) // this would indicate a bug in subset
        }
        // test for candidate Kaprekar number
        if rk == rk2 {
            s = append(s, ks)
        }
    }
    return
}
 
var testCases = []struct {
    base       int
    begin, end string
    kaprekar   []string
}{
    {10, ""1"", ""100"", []string{""1"", ""9"", ""45"", ""55"", ""99""}},
    {17, ""10"", ""gg"", []string{""3d"", ""d4"", ""gg""}},
}
 
func main() {
    for _, tc := range testCases {
        fmt.Printf(""\nTest case base = %d, begin = %s, end = %s:\n"",
            tc.base, tc.begin, tc.end)
        s, err := subset(tc.base, tc.begin, tc.end)
        if err != nil {
            log.Fatal(err)
        }
        fmt.Println(""Subset:  "", s)
        fmt.Println(""Kaprekar:"", tc.kaprekar)
        sx := 0
        for _, k := range tc.kaprekar {
            for {
                if sx == len(s) {
                    fmt.Printf(""Fail:"", k, ""not in subset"")
                    return
                }
                if s[sx] == k {
                    sx++
                    break
                }
                sx++
            }
        }
        fmt.Println(""Valid subset."")
    }
}",5747,168
69829,http://rosettacode.org/wiki/Cartesian_product_of_two_or_more_lists,Cartesian product of two or more lists,"Task

Show one or more idiomatic ways of generating the Cartesian product of two arbitrary lists in your language.

Demonstrate that your function/method correctly returns:

{1, 2} × {3, 4} = {(1, 3), (1, 4), (2, 3), (2, 4)}
and, in contrast:

{3, 4} × {1, 2} = {(3, 1), (3, 2), (4, 1), (4, 2)}
Also demonstrate, using your function/method, that the product of an empty list with any other list is empty.

 {1, 2} × {} = {}
 {} × {1, 2} = {}
For extra credit, show or write a function returning the n-ary product of an arbitrary number of lists, each of arbitrary length. Your function might, for example, accept a single argument which is itself a list of lists, and return the n-ary product of those lists.

Use your n-ary Cartesian product function to show the following products:

 {1776, 1789} × {7, 12} × {4, 14, 23} × {0, 1}
 {1, 2, 3} × {30} × {500, 100}
 {1, 2, 3} × {} × {500, 100}

",#Go,Go,"package main
 
import ""fmt""
 
type pair [2]int
 
func cart2(a, b []int) []pair {
    p := make([]pair, len(a)*len(b))
    i := 0
    for _, a := range a {
        for _, b := range b {
            p[i] = pair{a, b}
            i++
        }
    }
    return p
}
 
func main() {
    fmt.Println(cart2([]int{1, 2}, []int{3, 4}))
    fmt.Println(cart2([]int{3, 4}, []int{1, 2}))
    fmt.Println(cart2([]int{1, 2}, nil))
    fmt.Println(cart2(nil, []int{1, 2}))
}",459,24
69844,http://rosettacode.org/wiki/Carmichael_3_strong_pseudoprimes,Carmichael 3 strong pseudoprimes,"A lot of composite numbers can be separated from primes by Fermat's Little Theorem, but there are some that completely confound it.

The   Miller Rabin Test   uses a combination of Fermat's Little Theorem and Chinese Division Theorem to overcome this.

The purpose of this task is to investigate such numbers using a method based on   Carmichael numbers,   as suggested in   Notes by G.J.O Jameson March 2010.



Task

Find Carmichael numbers of the form:

  Prime1 × Prime2 × Prime3 
where    (Prime1 < Prime2 < Prime3)    for all    Prime1    up to   61.

(See page 7 of   Notes by G.J.O Jameson March 2010   for solutions.)



Pseudocode

For a given   



P
r
i
m

e

1




{\displaystyle Prime_{1}}



for 1 < h3 < Prime1
    for 0 < d < h3+Prime1
         if (h3+Prime1)*(Prime1-1) mod d == 0 and -Prime1 squared mod h3 == d mod h3
         then
               Prime2 = 1 + ((Prime1-1) * (h3+Prime1)/d)
               next d if Prime2 is not prime
               Prime3 = 1 + (Prime1*Prime2/h3)
               next d if Prime3 is not prime
               next d if (Prime2*Prime3) mod (Prime1-1) not equal 1
               Prime1 * Prime2 * Prime3 is a Carmichael Number



related task
Chernick's Carmichael numbers
",#Go,Go,"package main
 
import ""fmt""
 
// Use this rather than % for negative integers
func mod(n, m int) int {
    return ((n % m) + m) % m
}
 
func isPrime(n int) bool {
    if n < 2 { return false }
    if n % 2 == 0 { return n == 2 }
    if n % 3 == 0 { return n == 3 }
    d := 5
    for d * d <= n {
        if n % d == 0 { return false }
        d += 2
        if n % d == 0 { return false }
        d += 4
    }
    return true
}
 
func carmichael(p1 int) {
    for h3 := 2; h3 < p1; h3++ {
        for d := 1; d < h3 + p1; d++ {
            if (h3 + p1) * (p1 - 1) % d == 0 && mod(-p1 * p1, h3) == d % h3 {
                p2 := 1 + (p1 - 1) * (h3 + p1) / d
                if !isPrime(p2) { continue }
                p3 := 1 + p1 * p2 / h3
                if !isPrime(p3) { continue }
                if p2 * p3 % (p1 - 1) != 1 { continue }
                c := p1 * p2 * p3
                fmt.Printf(""%2d   %4d   %5d     %d\n"", p1, p2, p3, c)
            }
        }
    }
}
 
func main() {
    fmt.Println(""The following are Carmichael munbers for p1 <= 61:\n"")
    fmt.Println(""p1     p2      p3     product"")
    fmt.Println(""==     ==      ==     ======="")
 
    for p1 := 2; p1 <= 61; p1++ {
        if isPrime(p1) { carmichael(p1) }
    }
}",1250,48
69923,http://rosettacode.org/wiki/Call_an_object_method,Call an object method,"In object-oriented programming a method is a function associated with a particular class or object. In most forms of object oriented implementations methods can be static, associated with the class itself; or instance, associated with an instance of a class.

Show how to call a static or class method, and an instance method of a class.
",#Go,Go,"type Foo int // some custom type
 
// method on the type itself; can be called on that type or its pointer
func (self Foo) ValueMethod(x int) { }
 
// method on the pointer to the type; can be called on pointers
func (self *Foo) PointerMethod(x int) { }
 
 
var myValue Foo
var myPointer *Foo = new(Foo)
 
// Calling value method on value
myValue.ValueMethod(someParameter)
// Calling pointer method on pointer
myPointer.PointerMethod(someParameter)
 
// Value methods can always be called on pointers
// equivalent to (*myPointer).ValueMethod(someParameter)
myPointer.ValueMethod(someParameter)
 
// In a special case, pointer methods can be called on values that are addressable (i.e. lvalues)
// equivalent to (&myValue).PointerMethod(someParameter)
myValue.PointerMethod(someParameter)
 
// You can get the method out of the type as a function, and then explicitly call it on the object
Foo.ValueMethod(myValue, someParameter)
(*Foo).PointerMethod(myPointer, someParameter)
(*Foo).ValueMethod(myPointer, someParameter)",1022,29
69936,http://rosettacode.org/wiki/Catamorphism,Catamorphism,"Reduce is a function or method that is used to take the values in an array or a list and apply a function to successive members of the list to produce (or reduce them to), a single value.



Task

Show how reduce (or foldl or foldr etc), work (or would be implemented) in your language.



See also

 Wikipedia article:   Fold
 Wikipedia article:   Catamorphism

",#Go,Go,"package main
 
import (
	""fmt""
)
 
func main() {
	n := []int{1, 2, 3, 4, 5}
 
	fmt.Println(reduce(add, n))
	fmt.Println(reduce(sub, n))
	fmt.Println(reduce(mul, n))
}
 
func add(a int, b int) int { return a + b }
func sub(a int, b int) int { return a - b }
func mul(a int, b int) int { return a * b }
 
func reduce(rf func(int, int) int, m []int) int {
	r := m[0]
	for _, v := range m[1:] {
		r = rf(r, v)
	}
	return r
}",420,25
69944,http://rosettacode.org/wiki/Call_a_function_in_a_shared_library,Call a function in a shared library,"Show how to call a function in a shared library (without dynamically linking to it at compile-time). In particular, show how to call the shared library function if the library is available, otherwise use an internal equivalent function.

This is a special case of calling a foreign language function where the focus is close to the ABI level and not at the normal API level.



Related task

 OpenGL -- OpenGL is usually maintained as a shared library.

",#Go,Go,"#include <stdio.h>
/* gcc -shared -fPIC -nostartfiles fakeimglib.c -o fakeimglib.so */
int openimage(const char *s)
{
    static int handle = 100;
    fprintf(stderr, ""opening %s\n"", s);
    return handle++;
}",209,8
69950,http://rosettacode.org/wiki/Calkin-Wilf_sequence,Calkin-Wilf sequence,"The Calkin-Wilf sequence contains every nonnegative rational number exactly once.

It can be calculated recursively as follows:

       a1   =  1 
       an+1  =  1/(2⌊an⌋+1-an) for n > 1 



Task part 1

 Show on this page terms 1 through 20 of the Calkin-Wilf sequence.

To avoid floating point error, you may want to use a rational number data type.



It is also possible, given a non-negative rational number, to determine where it appears in the sequence without calculating the sequence. The procedure is to get the continued fraction representation of the rational and use it as the run-length encoding of the binary representation of the term number, beginning from the end of the continued fraction.
It only works if the number of terms in the continued fraction is odd- use either of the two equivalent representations to achieve this:

       [a0; a1, a2, ..., an]  =  [a0; a1, a2 ,..., an-1, 1] 



Example

The fraction   9/4   has odd continued fraction representation      2; 3, 1,     giving a binary representation of   100011,

which means   9/4   appears as the   35th   term of the sequence.



Task part 2

 Find the position of the number   83116/51639   in the Calkin-Wilf sequence.


See also

 Wikipedia entry: Calkin-Wilf tree
 Continued fraction
 Continued fraction/Arithmetic/Construct from rational number

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/big""
    ""strconv""
    ""strings""
)
 
func calkinWilf(n int) []*big.Rat {
    cw := make([]*big.Rat, n+1)
    cw[0] = big.NewRat(1, 1)
    one := big.NewRat(1, 1)
    two := big.NewRat(2, 1)
    for i := 1; i < n; i++ {
        t := new(big.Rat).Set(cw[i-1])
        f, _ := t.Float64()
        f = math.Floor(f)
        t.SetFloat64(f)
        t.Mul(t, two)
        t.Sub(t, cw[i-1])
        t.Add(t, one)
        t.Inv(t)
        cw[i] = new(big.Rat).Set(t)
    }
    return cw
}
 
func toContinued(r *big.Rat) []int {
    a := r.Num().Int64()
    b := r.Denom().Int64()
    var res []int
    for {
        res = append(res, int(a/b))
        t := a % b
        a, b = b, t
        if a == 1 {
            break
        }
    }
    le := len(res)
    if le%2 == 0 { // ensure always odd
        res[le-1]--
        res = append(res, 1)
    }
    return res
}
 
func getTermNumber(cf []int) int {
    b := """"
    d := ""1""
    for _, n := range cf {
        b = strings.Repeat(d, n) + b
        if d == ""1"" {
            d = ""0""
        } else {
            d = ""1""
        }
    }
    i, _ := strconv.ParseInt(b, 2, 64)
    return int(i)
}
 
func commatize(n int) string {
    s := fmt.Sprintf(""%d"", n)
    if n < 0 {
        s = s[1:]
    }
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    if n >= 0 {
        return s
    }
    return ""-"" + s
}
 
func main() {
    cw := calkinWilf(20)
    fmt.Println(""The first 20 terms of the Calkin-Wilf sequnence are:"")
    for i := 1; i <= 20; i++ {
        fmt.Printf(""%2d: %s\n"", i, cw[i-1].RatString())
    }
    fmt.Println()
    r := big.NewRat(83116, 51639)
    cf := toContinued(r)
    tn := getTermNumber(cf)
    fmt.Printf(""%s is the %sth term of the sequence.\n"", r.RatString(), commatize(tn))
}",1850,91
70036,http://rosettacode.org/wiki/Cantor_set,Cantor set,"Task

Draw a Cantor set.



See details at this Wikipedia webpage:   Cantor set
",#Go,Go,"package main
 
import ""fmt""
 
const (
    width = 81
    height = 5
)
 
var lines [height][width]byte
 
func init() {
    for i := 0; i < height; i++ {
        for j := 0; j < width; j++ {
            lines[i][j] = '*'
        }
    }
}
 
func cantor(start, len, index int) {
    seg := len / 3
    if seg == 0 {
        return
    }
    for i := index; i < height; i++ {
        for j := start + seg; j < start + 2 * seg; j++ {
            lines[i][j] = ' '
        }
    }
    cantor(start, seg, index + 1)
    cantor(start + seg * 2, seg, index + 1)
}
 
func main() {
    cantor(0, width, 1)
    for _, line := range lines {
        fmt.Println(string(line[:]))
    }
}",672,39
70183,http://rosettacode.org/wiki/Call_a_foreign-language_function,Call a foreign-language function,"Task

Show how a foreign language function can be called from the language.



As an example, consider calling functions defined in the C language. Create a string containing ""Hello World!"" of the string type typical to the language. Pass the string content to C's strdup. The content can be copied if necessary. Get the result from strdup and print it using language means. Do not forget to free the result of strdup (allocated in the heap).



Notes

 It is not mandated if the C run-time library is to be loaded statically or dynamically. You are free to use either way.
 C++ and C solutions can take some other language to communicate with.
 It is not mandatory to use strdup, especially if the foreign function interface being demonstrated makes that uninformative.


See also

   Use another language to call a function

",#Go,Go,"package main
 
// #include <string.h>
// #include <stdlib.h>
import ""C""
import (
    ""fmt""
    ""unsafe""
)
 
func main() {
    // a go string
    go1 := ""hello C""
    // allocate in C and convert from Go representation to C representation
    c1 := C.CString(go1)
    // go string can now be garbage collected
    go1 = """"
    // strdup, per task. this calls the function in the C library.
    c2 := C.strdup(c1)
    // free the source C string.  again, this is free() in the C library.
    C.free(unsafe.Pointer(c1))
    // create a new Go string from the C copy
    go2 := C.GoString(c2)
    // free the C copy
    C.free(unsafe.Pointer(c2))
    // demonstrate we have string contents intact
    fmt.Println(go2)
}",715,28
70237,http://rosettacode.org/wiki/Burrows%E2%80%93Wheeler_transform,Burrows–Wheeler transform,"

 This page uses content from Wikipedia. The original article was at Burrows–Wheeler_transform. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The Burrows–Wheeler transform (BWT, also called block-sorting compression) rearranges a character string into runs of similar characters.

This is useful for compression, since it tends to be easy to compress a string that has runs of repeated characters by techniques such as move-to-front transform and run-length encoding.

More importantly, the transformation is reversible, without needing to store any additional data.

The BWT is thus a ""free"" method of improving the efficiency of text compression algorithms, costing only some extra computation.



Source: Burrows–Wheeler transform
",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
    ""strings""
)
 
const stx = ""\002""
const etx = ""\003""
 
func bwt(s string) (string, error) {
    if strings.Index(s, stx) >= 0 || strings.Index(s, etx) >= 0 {
        return """", fmt.Errorf(""String can't contain STX or ETX"")
    }
    s = stx + s + etx
    le := len(s)
    table := make([]string, le)
    table[0] = s
    for i := 1; i < le; i++ {
        table[i] = s[i:] + s[:i]
    }
    sort.Strings(table)
    lastBytes := make([]byte, le)
    for i := 0; i < le; i++ {
        lastBytes[i] = table[i][le-1]
    }
    return string(lastBytes), nil
}
 
func ibwt(r string) string {
    le := len(r)
    table := make([]string, le)
    for range table {
        for i := 0; i < le; i++ {
            table[i] = r[i:i+1] + table[i]
        }
        sort.Strings(table)
    }
    for _, row := range table {
        if strings.HasSuffix(row, etx) {
            return row[1 : le-1]
        }
    }
    return """"
}
 
func makePrintable(s string) string {
    // substitute ^ for STX and | for ETX to print results
    t := strings.Replace(s, stx, ""^"", 1)
    return strings.Replace(t, etx, ""|"", 1)
}
 
func main() {
    tests := []string{
        ""banana"",
        ""appellee"",
        ""dogwood"",
        ""TO BE OR NOT TO BE OR WANT TO BE OR NOT?"",
        ""SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES"",
        ""\002ABC\003"",
    }
    for _, test := range tests {
        fmt.Println(makePrintable(test))
        fmt.Print("" --> "")
        t, err := bwt(test)
        if err != nil {
            fmt.Println(""ERROR:"", err)
        } else {
            fmt.Println(makePrintable(t))
        }
        r := ibwt(t)
        fmt.Println("" -->"", r, ""\n"")
    }
}",1707,75
70263,http://rosettacode.org/wiki/Brilliant_numbers,Brilliant numbers,"Brilliant numbers are a subset of semiprime numbers. Specifically, they are numbers that are the product of exactly two prime numbers that both have the same number of digits when expressed in base 10.

Brilliant numbers are useful in cryptography and when testing prime factoring algorithms.



E.G.
 3 × 3 (9) is a brilliant number. 
 2 × 7 (14) is a brilliant number.
 113 × 691 (78083) is a brilliant number.
 2 × 31 (62) is semiprime, but is not a brilliant number (different number of digits in the two factors).


Task
 Find and display the first 100 brilliant numbers.
 For the orders of magnitude 1 through 6, find and show the first brilliant number greater than or equal to the order of magnitude, and, its position in the series (or the count of brilliant numbers up to that point).


Stretch
 Continue for larger orders of magnitude.


See also
 Numbers Aplenty - Brilliant numbers
 OEIS:A078972 - Brilliant numbers: semiprimes whose prime factors have the same number of decimal digits

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""rcu""
    ""sort""
)
 
var primes = rcu.Primes(1e8 - 1)
 
type res struct {
    bc   interface{}
    next int
}
 
func getBrilliant(digits, limit int, countOnly bool) res {
    var brilliant []int
    count := 0
    pow := 1
    next := math.MaxInt
    for k := 1; k <= digits; k++ {
        var s []int
        for _, p := range primes {
            if p >= pow*10 {
                break
            }
            if p > pow {
                s = append(s, p)
            }
        }
        for i := 0; i < len(s); i++ {
            for j := i; j < len(s); j++ {
                prod := s[i] * s[j]
                if prod < limit {
                    if countOnly {
                        count++
                    } else {
                        brilliant = append(brilliant, prod)
                    }
                } else {
                    if next > prod {
                        next = prod
                    }
                    break
                }
            }
        }
        pow *= 10
    }
    if countOnly {
        return res{count, next}
    }
    return res{brilliant, next}
}
 
func main() {
    fmt.Println(""First 100 brilliant numbers:"")
    brilliant := getBrilliant(2, 10000, false).bc.([]int)
    sort.Ints(brilliant)
    brilliant = brilliant[0:100]
    for i := 0; i < len(brilliant); i++ {
        fmt.Printf(""%4d "", brilliant[i])
        if (i+1)%10 == 0 {
            fmt.Println()
        }
    }
    fmt.Println()
    for k := 1; k <= 13; k++ {
        limit := int(math.Pow(10, float64(k)))
        r := getBrilliant(k, limit, true)
        total := r.bc.(int)
        next := r.next
        climit := rcu.Commatize(limit)
        ctotal := rcu.Commatize(total + 1)
        cnext := rcu.Commatize(next)
        fmt.Printf(""First >= %18s is %14s in the series: %18s\n"", climit, ctotal, cnext)
    }
}",1900,79
70391,http://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers,"Calendar - for ""REAL"" programmers","Task

Provide an algorithm as per the Calendar task, except the entire code for the algorithm must be presented   entirely without lowercase.

Also - as per many 1969 era line printers - format the calendar to nicely fill a page that is 132 characters wide.

(Hint: manually convert the code from the Calendar task to all UPPERCASE)

This task also is inspired by Real Programmers Don't Use PASCAL by Ed Post, Datamation, volume 29 number 7, July 1983.

THE REAL PROGRAMMER'S NATURAL HABITAT
""Taped to the wall is a line-printer Snoopy calender for the year 1969.""

Moreover this task is further inspired by the long lost corollary article titled:

""Real programmers think in UPPERCASE""!

Note: Whereas today we only need to worry about ASCII, UTF-8, UTF-16, UTF-32, UTF-7 and UTF-EBCDIC encodings, in the 1960s having code in UPPERCASE was often mandatory as characters were often stuffed into 36-bit words as 6 lots of 6-bit characters. More extreme words sizes include 60-bit words of the CDC 6000 series computers. The Soviets even had a national character set that was inclusive of all
4-bit,
5-bit,
6-bit &
7-bit depending on how the file was opened... And one rogue Soviet university went further and built a 1.5-bit based computer.

Of course... as us Boomers have turned into Geezers we have become HARD OF HEARING,
and suffer from chronic Presbyopia, hence programming in UPPERCASE
is less to do with computer architecture and more to do with practically. :-)

For economy of size, do not actually include Snoopy generation
in either the code or the output, instead just output a place-holder.

FYI: a nice ASCII art file of Snoopy can be found at textfiles.com. Save with a .txt extension.

Trivia: The terms uppercase and lowercase date back to the early days of the mechanical printing press. Individual metal alloy casts of each needed letter, or punctuation symbol, were meticulously added to a press block, by hand, before rolling out copies of a page. These metal casts were stored and organized in wooden cases. The more often needed minuscule letters were placed closer to hand, in the lower cases of the work bench. The less often needed, capitalized, majuscule letters, ended up in the harder to reach upper cases.



",#Go,Go,"PACKAGE MAIN
 
IMPORT (
    ""FMT""
    ""TIME""
)
 
CONST PAGEWIDTH = 80
 
FUNC MAIN() {
    PRINTCAL(1969)
}
 
FUNC PRINTCAL(YEAR INT) {
    THISDATE := TIME.DATE(YEAR, 1, 1, 1, 1, 1, 1, TIME.UTC)
    VAR (
        DAYARR                  [12][7][6]INT // MONTH, WEEKDAY, WEEK
        MONTH, LASTMONTH        TIME.MONTH
        WEEKINMONTH, DAYINMONTH INT
    )
    FOR THISDATE.YEAR() == YEAR {
        IF MONTH = THISDATE.MONTH(); MONTH != LASTMONTH {
            WEEKINMONTH = 0
            DAYINMONTH = 1
        }
        WEEKDAY := THISDATE.WEEKDAY()
        IF WEEKDAY == 0 && DAYINMONTH > 1 {
            WEEKINMONTH++
        }
        DAYARR[INT(MONTH)-1][WEEKDAY][WEEKINMONTH] = THISDATE.DAY()
        LASTMONTH = MONTH
        DAYINMONTH++
        THISDATE = THISDATE.ADD(TIME.HOUR * 24)
    }
    CENTRE := FMT.SPRINTF(""%D"", PAGEWIDTH/2)
    FMT.PRINTF(""%""+CENTRE+""S\N\N"", ""[SNOOPY]"")
    CENTRE = FMT.SPRINTF(""%D"", PAGEWIDTH/2-2)
    FMT.PRINTF(""%""+CENTRE+""D\N\N"", YEAR)
    MONTHS := [12]STRING{
        "" JANUARY "", "" FEBRUARY"", ""  MARCH  "", ""  APRIL  "",
        ""   MAY   "", ""   JUNE  "", ""   JULY  "", ""  AUGUST "",
        ""SEPTEMBER"", "" OCTOBER "", "" NOVEMBER"", "" DECEMBER""}
    DAYS := [7]STRING{""SU"", ""MO"", ""TU"", ""WE"", ""TH"", ""FR"", ""SA""}
    FOR QTR := 0; QTR < 4; QTR++ {
        FOR MONTHINQTR := 0; MONTHINQTR < 3; MONTHINQTR++ { // MONTH NAMES
            FMT.PRINTF(""      %S           "", MONTHS[QTR*3+MONTHINQTR])
        }
        FMT.PRINTLN()
        FOR MONTHINQTR := 0; MONTHINQTR < 3; MONTHINQTR++ { // DAY NAMES
            FOR DAY := 0; DAY < 7; DAY++ {
                FMT.PRINTF("" %S"", DAYS[DAY])
            }
            FMT.PRINTF(""     "")
        }
        FMT.PRINTLN()
        FOR WEEKINMONTH = 0; WEEKINMONTH < 6; WEEKINMONTH++ {
            FOR MONTHINQTR := 0; MONTHINQTR < 3; MONTHINQTR++ {
                FOR DAY := 0; DAY < 7; DAY++ {
                    IF DAYARR[QTR*3+MONTHINQTR][DAY][WEEKINMONTH] == 0 {
                        FMT.PRINTF(""   "")
                    } ELSE {
                        FMT.PRINTF(""%3D"", DAYARR[QTR*3+MONTHINQTR][DAY][WEEKINMONTH])
                    }
                }
                FMT.PRINTF(""     "")
            }
            FMT.PRINTLN()
        }
        FMT.PRINTLN()
    }
}",2264,71
70451,http://rosettacode.org/wiki/Bulls_and_cows/Player,Bulls and cows/Player,"Task

Write a player of the Bulls and Cows game, rather than a scorer. The player should give intermediate answers that respect the scores to previous attempts.

One method is to generate a list of all possible numbers that could be the answer, then to prune the list by keeping only those numbers that would give an equivalent score to how your last guess was scored. Your next guess can be any number from the pruned list.

Either you guess correctly or run out of numbers to guess, which indicates a problem with the scoring.



Related tasks

   Bulls and cows
   Guess the number
   Guess the number/With Feedback (Player)

",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""os""
    ""strconv""
    ""strings""
)
 
func main() {
    fmt.Println(`Cows and bulls/player
You think of four digit number of unique digits in the range 1 to 9.
I guess.  You score my guess:
    A correct digit but not in the correct place is a cow.
    A correct digit in the correct place is a bull.
You give my score as two numbers separated with a space.`)
 
    // generate possible patterns, store in map
    m := make(map[string]int)
    var g func([]byte, int)
    g = func(digits []byte, fixed int) {
        if fixed == 4 {
            m[string(digits[:4])] = 0
            return
        }
        for i := fixed; i < len(digits); i++ {
            digits[fixed], digits[i] = digits[i], digits[fixed]
            g(digits, fixed+1)
            digits[fixed], digits[i] = digits[i], digits[fixed]
        }
    }
    g([]byte(""123456789""), 0)
 
    // guess/score/eliminate loop
    for in := bufio.NewReader(os.Stdin);; {
        // pick a value, ie, guess
        var guess string
        for guess = range m {
            delete(m, guess)
            break
        }
 
        // get and parse score
        var c, b uint
        for ;; fmt.Println(""Score guess as two numbers: cows bulls"") {
            fmt.Printf(""My guess: %s.  Score? (c b) "", guess)
            score, err := in.ReadString('\n')
            if err != nil {
                fmt.Println(""\nSo, bye."")
                return
            }
            s2 := strings.Fields(score)
            if len(s2) == 2 {
                c2, err := strconv.ParseUint(s2[0], 10, 0)
                if err == nil && c2 <= 4 {
                    b2, err := strconv.ParseUint(s2[1], 10, 0)
                    if err == nil && c2+b2 <= 4 {
                        c = uint(c2)
                        b = uint(b2)
                        break
                    }
                }
            }
        }
 
        // check for win
        if b == 4 {
            fmt.Println(""I did it. :)"")
            return
        }
 
        // eliminate patterns with non-matching scores
        for pat := range m {
            var cows, bulls uint
            for ig, cg := range guess {
                switch strings.IndexRune(pat, cg) {
                case -1:
                default: // I just think cows should go first
                    cows++
                case ig:
                    bulls++
                }
            }
            if cows != c || bulls != b {
                delete(m, pat)
            }
        }
 
        // check for inconsistency
        if len(m) == 0 {
            fmt.Println(""Oops, check scoring."")
            return
        }
    }
}",2690,96
70469,http://rosettacode.org/wiki/Break_OO_privacy,Break OO privacy,"Show how to access private or protected members of a class in an object-oriented language from outside an instance of the class, without calling non-private or non-protected members of the class as a proxy.
The intent is to show how a debugger, serializer, or other meta-programming tool might access information that is barred by normal access methods to the object but can nevertheless be accessed from within the language by some provided escape hatch or reflection mechanism.
The intent is specifically not to demonstrate heroic measures such as peeking and poking raw memory.

Note that cheating on your type system is almost universally regarded
as unidiomatic at best, and poor programming practice at worst.
Nonetheless, if your language intentionally maintains a double-standard for OO privacy, here's where you can show it off.
",#Go,Go,"package main
 
import (
	""bufio""
	""errors""
	""fmt""
	""os""
	""reflect""
	""unsafe""
)
 
type foobar struct {
	Exported   int // In Go identifiers that are capitalized are exported,
	unexported int // while lowercase identifiers are not.
}
 
func main() {
	obj := foobar{12, 42}
	fmt.Println(""obj:"", obj)
 
	examineAndModify(&obj)
	fmt.Println(""obj:"", obj)
 
	anotherExample()
}
 
// For simplicity this skips several checks. It assumes the thing in the
// interface is a pointer without checking (v.Kind()==reflect.Ptr),
// it then assumes it is a structure type with two int fields
// (v.Kind()==reflect.Struct, f.Type()==reflect.TypeOf(int(0))).
func examineAndModify(any interface{}) {
	v := reflect.ValueOf(any) // get a reflect.Value
	v = v.Elem()              // dereference the pointer
	fmt.Println("" v:"", v, ""="", v.Interface())
	t := v.Type()
	// Loop through the struct fields
	fmt.Printf(""    %3s %-10s %-4s %s\n"", ""Idx"", ""Name"", ""Type"", ""CanSet"")
	for i := 0; i < v.NumField(); i++ {
		f := v.Field(i) // reflect.Value of the field
		fmt.Printf(""    %2d: %-10s %-4s %t\n"", i,
			t.Field(i).Name, f.Type(), f.CanSet())
	}
 
	// ""Exported"", field 0, has CanSet==true so we can do:
	v.Field(0).SetInt(16)
	// ""unexported"", field 1, has CanSet==false so the following
	// would fail at run-time with:
	//   panic: reflect: reflect.Value.SetInt using value obtained using unexported field
	//v.Field(1).SetInt(43)
 
	// However, we can bypass this restriction with the unsafe
	// package once we know what type it is (so we can use the
	// correct pointer type, here *int):
	vp := v.Field(1).Addr()            // Take the fields's address
	up := unsafe.Pointer(vp.Pointer()) // … get an int value of the address and convert it ""unsafely""
	p := (*int)(up)                    // … and end up with what we want/need
	fmt.Printf(""  vp has type %-14T = %v\n"", vp, vp)
	fmt.Printf(""  up has type %-14T = %#0x\n"", up, up)
	fmt.Printf(""   p has type %-14T = %v pointing at %v\n"", p, p, *p)
	*p = 43 // effectively obj.unexported = 43
	// or an incr all on one ulgy line:
	*(*int)(unsafe.Pointer(v.Field(1).Addr().Pointer()))++
 
	// Note that as-per the package ""unsafe"" documentation,
	// the return value from vp.Pointer *must* be converted to
	// unsafe.Pointer in the same expression; the result is fragile.
	//
	// I.e. it is invalid to do:
	//	thisIsFragile := vp.Pointer()
	//	up := unsafe.Pointer(thisIsFragile)
}
 
// This time we'll use an external package to demonstrate that it's not
// restricted to things defined locally. We'll mess with bufio.Reader's
// interal workings by happening to know they have a non-exported
// ""err error"" field. Of course future versions of Go may not have this
// field or use it in the same way :).
func anotherExample() {
	r := bufio.NewReader(os.Stdin)
 
	// Do the dirty stuff in one ugly and unsafe statement:
	errp := (*error)(unsafe.Pointer(
		reflect.ValueOf(r).Elem().FieldByName(""err"").Addr().Pointer()))
	*errp = errors.New(""unsafely injected error value into bufio inner workings"")
 
	_, err := r.ReadByte()
	fmt.Println(""bufio.ReadByte returned error:"", err)
}",3109,88
70573,http://rosettacode.org/wiki/Catalan_numbers,Catalan numbers,"Catalan numbers

You are encouraged to solve this task according to the task description, using any language you may know.


Catalan numbers are a sequence of numbers which can be defined directly:






C

n


=


1

n
+
1






(



2
n

n


)



=



(
2
n
)
!


(
n
+
1
)
!

n
!





 for 

n
≥
0.


{\displaystyle C_{n}={\frac {1}{n+1}}{2n \choose n}={\frac {(2n)!}{(n+1)!\,n!}}\qquad {\mbox{ for }}n\geq 0.}


Or recursively:






C

0


=
1


and



C

n
+
1


=

∑

i
=
0


n



C

i




C

n
−
i




for 

n
≥
0
;


{\displaystyle C_{0}=1\quad {\mbox{and}}\quad C_{n+1}=\sum _{i=0}^{n}C_{i}\,C_{n-i}\quad {\text{for }}n\geq 0;}


Or alternatively (also recursive):






C

0


=
1


and



C

n


=



2
(
2
n
−
1
)


n
+
1




C

n
−
1


,


{\displaystyle C_{0}=1\quad {\mbox{and}}\quad C_{n}={\frac {2(2n-1)}{n+1}}C_{n-1},}




Task

Implement at least one of these algorithms and print out the first 15 Catalan numbers with each.

Memoization   is not required, but may be worth the effort when using the second method above.



Related tasks

Catalan numbers/Pascal's triangle
Evaluate binomial coefficients

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    var b, c big.Int
    for n := int64(0); n < 15; n++ {
        fmt.Println(c.Div(b.Binomial(n*2, n), c.SetInt64(n+1)))
    }
}",196,13
70575,http://rosettacode.org/wiki/Brace_expansion,Brace expansion,"Brace expansion is a type of parameter expansion made popular by Unix shells, where it allows users to specify multiple similar string parameters without having to type them all out. E.g. the parameter enable_{audio,video} would be interpreted as if both enable_audio and enable_video had been specified.



Task[edit]
Write a function that can perform brace expansion on any input string, according to the following specification.

Demonstrate how it would be used, and that it passes the four test cases given below.

Specification
In the input string, balanced pairs of braces containing comma-separated substrings (details below) represent alternations that specify multiple alternatives which are to appear at that position in the output. In general, one can imagine the information conveyed by the input string as a tree of nested alternations interspersed with literal substrings, as shown in the middle part of the following diagram:


It{{em,alic}iz,erat}e{d,}

parse 
―――――▶
‌



It




⎧
⎨
⎩





⎧
⎨
⎩

em

⎫
⎬
⎭


alic



iz


⎫
⎬
⎭


erat


e




⎧
⎨
⎩

d

⎫
⎬
⎭


‌





expand 
―――――▶
‌
Itemized
Itemize
Italicized
Italicize
Iterated
Iterate


input string

alternation tree

output (list of strings)

This tree can in turn be transformed into the intended list of output strings by, colloquially speaking, determining all the possible ways to walk through it from left to right while only descending into one branch of each alternation one comes across (see the right part of the diagram). When implementing it, one can of course combine the parsing and expansion into a single algorithm, but this specification discusses them separately for the sake of clarity.

Expansion of alternations can be more rigorously described by these rules:





a




⎧
⎨
⎩

2

⎫
⎬
⎭


1


b




⎧
⎨
⎩

X

⎫
⎬
⎭


Y
X


c



⟶

a2bXc
a2bYc
a2bXc
a1bXc
a1bYc
a1bXc




An alternation causes the list of alternatives that will be produced by its parent branch to be increased 𝑛-fold, each copy featuring one of the 𝑛 alternatives produced by the alternation's child branches, in turn, at that position.


This means that multiple alternations inside the same branch are cumulative  (i.e. the complete list of alternatives produced by a branch is the string-concatenating ""Cartesian product"" of its parts).


All alternatives (even duplicate and empty ones) are preserved, and they are ordered like the examples demonstrate  (i.e. ""lexicographically"" with regard to the alternations).


The alternatives produced by the root branch constitute the final output.


Parsing the input string involves some additional complexity to deal with escaped characters and ""incomplete"" brace pairs:


a\\{\\\{b,c\,d}
⟶


a\\




⎧
⎨
⎩

\\\{b

⎫
⎬
⎭


c\,d





{a,b{c{,{d}}e}f
⟶


{a,b{c




⎧
⎨
⎩

‌

⎫
⎬
⎭


{d}


e}f





An unescaped backslash which precedes another character, escapes that character (to force it to be treated as literal). The backslashes are passed along to the output unchanged.


Balanced brace pairs are identified by, conceptually, going through the string from left to right and associating each unescaped closing brace that is encountered with the nearest still unassociated unescaped opening brace to its left (if any). Furthermore, each unescaped comma is associated with the innermost brace pair that contains it (if any). With that in mind:


Each brace pair that has at least one comma associated with it, forms an alternation (whose branches are the brace pair's contents split at its commas). The associated brace and comma characters themselves do not become part of the output.


Brace characters from pairs without any associated comma, as well as unassociated brace and comma characters, as well as all characters that are not covered by the preceding rules, are instead treated as literals.




For every possible input string, your implementation should produce exactly the output which this specification mandates. Please comply with this even when it's inconvenient, to ensure that all implementations are comparable. However, none of the above should be interpreted as instructions (or even recommendations) for how to implement it. Try to come up with a solution that is idiomatic in your programming language. (See #Perl for a reference implementation.)

Test Cases


 Input
(single string)

 Ouput
(list/array of strings)



~/{Downloads,Pictures}/*.{jpg,gif,png}



~/Downloads/*.jpg
~/Downloads/*.gif
~/Downloads/*.png
~/Pictures/*.jpg
~/Pictures/*.gif
~/Pictures/*.png




It{{em,alic}iz,erat}e{d,}, please.



Itemized, please.
Itemize, please.
Italicized, please.
Italicize, please.
Iterated, please.
Iterate, please.




{,{,gotta have{ ,\, again\, }}more }cowbell!



cowbell!
more cowbell!
gotta have more cowbell!
gotta have\, again\, more cowbell!




{}} some }{,{\\{ edge, edge} \,}{ cases, {here} \\\\\}



{}} some }{,{\\ edge \,}{ cases, {here} \\\\\}
{}} some }{,{\\ edge \,}{ cases, {here} \\\\\}




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




   Brace_expansion_using_ranges

",#Go,Go,"package expand
 
// Expander is anything that can be expanded into a slice of strings.
type Expander interface {
	Expand() []string
}
 
// Text is a trivial Expander that expands to a slice with just itself.
type Text string
 
func (t Text) Expand() []string { return []string{string(t)} }
 
// Alternation is an Expander that expands to the union of its
// members' expansions.
type Alternation []Expander
 
func (alt Alternation) Expand() []string {
	var out []string
	for _, e := range alt {
		out = append(out, e.Expand()...)
	}
	return out
}
 
// Sequence is an Expander that expands to the combined sequence of its
// members' expansions.
type Sequence []Expander
 
func (seq Sequence) Expand() []string {
	if len(seq) == 0 {
		return nil
	}
	out := seq[0].Expand()
	for _, e := range seq[1:] {
		out = combine(out, e.Expand())
	}
	return out
}
 
func combine(al, bl []string) []string {
	out := make([]string, 0, len(al)*len(bl))
	for _, a := range al {
		for _, b := range bl {
			out = append(out, a+b)
		}
	}
	return out
}
 
// Currently only single byte runes are supported for these.
const (
	escape   = '\\'
	altStart = '{'
	altEnd   = '}'
	altSep   = ','
)
 
type piT struct{ pos, cnt, depth int }
 
type Brace string
 
// Expand takes an input string and returns the expanded list of
// strings. The input string can contain any number of nested
// alternation specifications of the form ""{A,B}"" which is expanded to
// the strings ""A"", then ""B"".
//
// E.g. Expand(""a{2,1}b{X,Y,X}c"") returns [""a2bXc"", ""a2bYc"", ""a2bXc"",
// ""a1bXc"", ""a1bYc"", ""a1bXc""].
//
// Unmatched '{', ',', and '}' characters are passed through to the
// output. The special meaning of these characters can be escaped with
// '\', (which itself can be escaped).
// Escape characters are not removed, but passed through to the output.
func Expand(s string) []string   { return Brace(s).Expand() }
func (b Brace) Expand() []string { return b.Expander().Expand() }
func (b Brace) Expander() Expander {
	s := string(b)
	//log.Printf(""Exapand(%#q)\n"", s)
	var posInfo []piT
	var stack []int // indexes into posInfo
	removePosInfo := func(i int) {
		end := len(posInfo) - 1
		copy(posInfo[i:end], posInfo[i+1:])
		posInfo = posInfo[:end]
	}
 
	inEscape := false
	for i, r := range s {
		if inEscape {
			inEscape = false
			continue
		}
		switch r {
		case escape:
			inEscape = true
		case altStart:
			stack = append(stack, len(posInfo))
			posInfo = append(posInfo, piT{i, 0, len(stack)})
		case altEnd:
			if len(stack) == 0 {
				continue
			}
			si := len(stack) - 1
			pi := stack[si]
			if posInfo[pi].cnt == 0 {
				removePosInfo(pi)
				for pi < len(posInfo) {
					if posInfo[pi].depth == len(stack) {
						removePosInfo(pi)
					} else {
						pi++
					}
				}
			} else {
				posInfo = append(posInfo, piT{i, -2, len(stack)})
			}
			stack = stack[:si]
		case altSep:
			if len(stack) == 0 {
				continue
			}
			posInfo = append(posInfo, piT{i, -1, len(stack)})
			posInfo[stack[len(stack)-1]].cnt++
		}
	}
	//log.Println(""stack:"", stack)
	for len(stack) > 0 {
		si := len(stack) - 1
		pi := stack[si]
		depth := posInfo[pi].depth
		removePosInfo(pi)
		for pi < len(posInfo) {
			if posInfo[pi].depth == depth {
				removePosInfo(pi)
			} else {
				pi++
			}
		}
		stack = stack[:si]
	}
	return buildExp(s, 0, posInfo)
}
 
func buildExp(s string, off int, info []piT) Expander {
	if len(info) == 0 {
		return Text(s)
	}
	//log.Printf(""buildExp(%#q, %d, %v)\n"", s, off, info)
	var seq Sequence
	i := 0
	var dj, j, depth int
	for dk, piK := range info {
		k := piK.pos - off
		switch s[k] {
		case altStart:
			if depth == 0 {
				dj = dk
				j = k
				depth = piK.depth
			}
		case altEnd:
			if piK.depth != depth {
				continue
			}
			if j > i {
				seq = append(seq, Text(s[i:j]))
			}
			alt := buildAlt(s[j+1:k], depth, j+1+off, info[dj+1:dk])
			seq = append(seq, alt)
			i = k + 1
			depth = 0
		}
	}
	if j := len(s); j > i {
		seq = append(seq, Text(s[i:j]))
	}
	if len(seq) == 1 {
		return seq[0]
	}
	return seq
}
 
func buildAlt(s string, depth, off int, info []piT) Alternation {
	//log.Printf(""buildAlt(%#q, %d, %d, %v)\n"", s, depth, off, info)
	var alt Alternation
	i := 0
	var di int
	for dk, piK := range info {
		if piK.depth != depth {
			continue
		}
		if k := piK.pos - off; s[k] == altSep {
			sub := buildExp(s[i:k], i+off, info[di:dk])
			alt = append(alt, sub)
			i = k + 1
			di = dk + 1
		}
	}
	sub := buildExp(s[i:], i+off, info[di:])
	alt = append(alt, sub)
	return alt
}",4494,202
70584,http://rosettacode.org/wiki/Calculating_the_value_of_e,Calculating the value of e,"Task

Calculate the value of   e.



(e   is also known as   Euler's number   and   Napier's constant.)



See details: Calculating the value of e
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
const epsilon = 1.0e-15
 
func main() {
    fact := uint64(1)
    e := 2.0
    n := uint64(2)
    for {
        e0 := e
        fact *= n
        n++
        e += 1.0 / float64(fact)
        if math.Abs(e - e0) < epsilon {
            break
        }
    }
    fmt.Printf(""e = %.15f\n"", e)
}",340,24
70725,http://rosettacode.org/wiki/Brownian_tree,Brownian tree,"Brownian tree

You are encouraged to solve this task according to the task description, using any language you may know.



Task

Generate and draw a   Brownian Tree.



A Brownian Tree is generated as a result of an initial seed, followed by the interaction of two processes.

 The initial ""seed"" is placed somewhere within the field. Where is not particularly important; it could be randomized, or it could be a fixed point.
 Particles are injected into the field, and are individually given a (typically random) motion pattern.
 When a particle collides with the seed or tree, its position is fixed, and it's considered to be part of the tree.

Because of the lax rules governing the random nature of the particle's placement and motion, no two resulting trees are really expected to be the same, or even necessarily have the same general shape. 


",#Go,Go,"package main
 
import (
    ""fmt""
    ""image""
    ""image/color""
    ""image/png""
    ""math/rand""
    ""os""
)
 
const w = 400     // image width
const h = 300     // image height
const n = 15000   // number of particles to add
const frost = 255 // white
 
var g *image.Gray
 
func main() {
    g = image.NewGray(image.Rectangle{image.Point{0, 0}, image.Point{w, h}})
    // off center seed position makes pleasingly asymetrical tree
    g.SetGray(w/3, h/3, color.Gray{frost})
generate:
    for a := 0; a < n; {
        // generate random position for new particle
        rp := image.Point{rand.Intn(w), rand.Intn(h)}
        if g.At(rp.X, rp.Y).(color.Gray).Y == frost {
            // position is already set.  find a nearby free position.
            for {
                rp.X += rand.Intn(3) - 1
                rp.Y += rand.Intn(3) - 1
                // execpt if we run out of bounds, consider the particle lost.
                if !rp.In(g.Rect) {
                    continue generate
                }
                if g.At(rp.X, rp.Y).(color.Gray).Y != frost {
                    break
                }
            }
        } else {
            // else particle is in free space.  let it wander
            // until it touches tree
            for !hasNeighbor(rp) {
                rp.X += rand.Intn(3) - 1
                rp.Y += rand.Intn(3) - 1
                // but again, if it wanders out of bounds consider it lost.
                if !rp.In(g.Rect) {
                    continue generate
                }
            }
        }
        // x, y now specify a free position toucing the tree.
        g.SetGray(rp.X, rp.Y, color.Gray{frost})
        a++
        // progress indicator
        if a%100 == 0 {
            fmt.Println(a, ""of"", n)
        }
    }
    f, err := os.Create(""tree.png"")
    if err != nil {
        fmt.Println(err)
        return
    }
    err = png.Encode(f, g)
    if err != nil {
        fmt.Println(err)
    }
    f.Close()
}
 
var n8 = []image.Point{
    {-1, -1}, {-1, 0}, {-1, 1},
    {0, -1}, {0, 1},
    {1, -1}, {1, 0}, {1, 1}}
 
func hasNeighbor(p image.Point) bool { 
    for _, n := range n8 {
        o := p.Add(n)
        if o.In(g.Rect) && g.At(o.X, o.Y).(color.Gray).Y == frost {
            return true
        }
    }
    return false
}",2305,85
70772,http://rosettacode.org/wiki/Brazilian_numbers,Brazilian numbers,"Brazilian numbers are so called as they were first formally presented at the 1994 math Olympiad Olimpiada Iberoamericana de Matematica in Fortaleza, Brazil.

Brazilian numbers are defined as:

The set of positive integer numbers where each number N has at least one natural number B where 1 < B < N-1 where the representation of N in base B has all equal digits.



E.G.

 1, 2 & 3 can not be Brazilian; there is no base B that satisfies the condition 1 < B < N-1.
 4 is not Brazilian; 4 in base 2 is 100. The digits are not all the same.
 5 is not Brazilian; 5 in base 2 is 101, in base 3 is 12. There is no representation where the digits are the same.
 6 is not Brazilian; 6 in base 2 is 110, in base 3 is 20, in base 4 is 12. There is no representation where the digits are the same.
 7 is Brazilian; 7 in base 2 is 111. There is at least one representation where the digits are all the same.
 8 is Brazilian; 8 in base 3 is 22. There is at least one representation where the digits are all the same.
 and so on...


All even integers 2P >= 8 are Brazilian because 2P = 2(P-1) + 2, which is 22 in base P-1 when P-1 > 2. That becomes true when P >= 4.

More common: for all all integers R and S, where R > 1 and also S-1 > R, then R*S is Brazilian because R*S = R(S-1) + R, which is RR in base S-1

The only problematic numbers are squares of primes, where R = S. Only 11^2 is brazilian to base 3.

All prime integers, that are brazilian, can only have the digit 1. Otherwise one could factor out the digit, therefore it cannot be a prime number. Mostly in form of 111 to base Integer(sqrt(prime number)). Must be an odd count of 1 to stay odd like primes > 2


Task

Write a routine (function, whatever) to determine if a number is Brazilian and use the routine to show here, on this page;

 the first 20 Brazilian numbers;
 the first 20 odd Brazilian numbers;
 the first 20 prime Brazilian numbers;


See also

 OEIS:A125134 - Brazilian numbers
 OEIS:A257521 - Odd Brazilian numbers
 OEIS:A085104 - Prime Brazilian numbers

",#Go,Go,"package main
 
import ""fmt""
 
func sameDigits(n, b int) bool {
    f := n % b
    n /= b
    for n > 0 {
        if n%b != f {
            return false
        }
        n /= b
    }
    return true
}
 
func isBrazilian(n int) bool {
    if n < 7 {
        return false
    }
    if n%2 == 0 && n >= 8 {
        return true
    }
    for b := 2; b < n-1; b++ {
        if sameDigits(n, b) {
            return true
        }
    }
    return false
}
 
func isPrime(n int) bool {
    switch {
    case n < 2:
        return false
    case n%2 == 0:
        return n == 2
    case n%3 == 0:
        return n == 3
    default:
        d := 5
        for d*d <= n {
            if n%d == 0 {
                return false
            }
            d += 2
            if n%d == 0 {
                return false
            }
            d += 4
        }
        return true
    }
}
 
func main() {
    kinds := []string{"" "", "" odd "", "" prime ""}
    for _, kind := range kinds {
        fmt.Printf(""First 20%sBrazilian numbers:\n"", kind)
        c := 0
        n := 7
        for {
            if isBrazilian(n) {
                fmt.Printf(""%d "", n)
                c++
                if c == 20 {
                    fmt.Println(""\n"")
                    break
                }
            }
            switch kind {
            case "" "":
                n++
            case "" odd "":
                n += 2
            case "" prime "":
                for {
                    n += 2
                    if isPrime(n) {
                        break
                    }
                }
            }
        }
    }
 
    n := 7
    for c := 0; c < 100000; n++ {
        if isBrazilian(n) {
            c++
        }
    }
    fmt.Println(""The 100,000th Brazilian number:"", n-1)
}",1783,94
70837,http://rosettacode.org/wiki/Calendar,Calendar,"Create a routine that will generate a text calendar for any year.
Test the calendar by generating a calendar for the year 1969, on a device of the time.
Choose one of the following devices:

 A line printer with a width of 132 characters.
 An IBM 3278 model 4 terminal (80×43 display with accented characters). Target formatting the months of the year to fit nicely across the 80 character width screen. Restrict number of lines in test output to 43.


(Ideally, the program will generate well-formatted calendars for any page width from 20 characters up.)

Kudos (κῦδος) for routines that also transition from Julian to Gregorian calendar.

This task is inspired by Real Programmers Don't Use PASCAL by Ed Post, Datamation, volume 29 number 7, July 1983.

THE REAL PROGRAMMER'S NATURAL HABITAT
""Taped to the wall is a line-printer Snoopy calender for the year 1969.""

For further Kudos see task CALENDAR, where all code is to be in UPPERCASE.

For economy of size, do not actually include Snoopy generation in either the code or the output, instead just output a place-holder.



Related task

   Five weekends

",#Go,Go,"package main
 
import (
	""fmt""
	""time""
)
 
const pageWidth = 80
 
func main() {
	printCal(1969)
}
 
func printCal(year int) {
	thisDate := time.Date(year, 1, 1, 1, 1, 1, 1, time.UTC)
	var (
		dayArr                  [12][7][6]int // month, weekday, week
		month, lastMonth        time.Month
		weekInMonth, dayInMonth int
	)
	for thisDate.Year() == year {
		if month = thisDate.Month(); month != lastMonth {
			weekInMonth = 0
			dayInMonth = 1
		}
		weekday := thisDate.Weekday()
		if weekday == 0 && dayInMonth > 1 {
			weekInMonth++
		}
		dayArr[int(month)-1][weekday][weekInMonth] = thisDate.Day()
		lastMonth = month
		dayInMonth++
		thisDate = thisDate.Add(time.Hour * 24)
	}
	centre := fmt.Sprintf(""%d"", pageWidth/2)
	fmt.Printf(""%""+centre+""s\n\n"", ""[SNOOPY]"")
	centre = fmt.Sprintf(""%d"", pageWidth/2-2)
	fmt.Printf(""%""+centre+""d\n\n"", year)
	months := [12]string{
		"" January "", "" February"", ""  March  "", ""  April  "",
		""   May   "", ""   June  "", ""   July  "", ""  August "",
		""September"", "" October "", "" November"", "" December""}
	days := [7]string{""Su"", ""Mo"", ""Tu"", ""We"", ""Th"", ""Fr"", ""Sa""}
	for qtr := 0; qtr < 4; qtr++ {
		for monthInQtr := 0; monthInQtr < 3; monthInQtr++ { // Month names
			fmt.Printf(""      %s           "", months[qtr*3+monthInQtr])
		}
		fmt.Println()
		for monthInQtr := 0; monthInQtr < 3; monthInQtr++ { // Day names
			for day := 0; day < 7; day++ {
				fmt.Printf("" %s"", days[day])
			}
			fmt.Printf(""     "")
		}
		fmt.Println()
		for weekInMonth = 0; weekInMonth < 6; weekInMonth++ {
			for monthInQtr := 0; monthInQtr < 3; monthInQtr++ {
				for day := 0; day < 7; day++ {
					if dayArr[qtr*3+monthInQtr][day][weekInMonth] == 0 {
						fmt.Printf(""   "")
					} else {
						fmt.Printf(""%3d"", dayArr[qtr*3+monthInQtr][day][weekInMonth])
					}
				}
				fmt.Printf(""     "")
			}
			fmt.Println()
		}
		fmt.Println()
	}
}",1853,71
70870,http://rosettacode.org/wiki/Call_a_function,Call a function,"Task

Demonstrate the different syntax and semantics provided for calling a function.



This may include:

   Calling a function that requires no arguments
   Calling a function with a fixed number of arguments
   Calling a function with optional arguments
   Calling a function with a variable number of arguments
   Calling a function with named arguments
   Using a function in statement context
   Using a function in first-class context within an expression
   Obtaining the return value of a function
   Distinguishing built-in functions and user-defined functions
   Distinguishing subroutines and functions
   Stating whether arguments are passed by value or by reference
   Is partial application possible and how


This task is not about defining functions.



",#Go,Go,noArgs(),8,1
70990,http://rosettacode.org/wiki/Bulls_and_cows,Bulls and cows,"Bulls and Cows


Task

Create a four digit random number from the digits   1   to   9,   without duplication.

The program should:

   ask for guesses to this number
   reject guesses that are malformed
   print the score for the guess


The score is computed as:

 The player wins if the guess is the same as the randomly chosen number, and the program ends.
 A score of one bull is accumulated for each digit in the guess that equals the corresponding digit in the randomly chosen initial number.
 A score of one cow is accumulated for each digit in the guess that also appears in the randomly chosen number, but in the wrong position.


Related tasks

   Bulls and cows/Player
   Guess the number
   Guess the number/With Feedback
   Mastermind

",#Go,Go,"package main
 
import (
    ""bufio""
    ""bytes""
    ""fmt""
    ""math/rand""
    ""os""
    ""strings""
    ""time""
)
 
func main() {
    fmt.Println(`Cows and Bulls
Guess four digit number of unique digits in the range 1 to 9.
A correct digit but not in the correct place is a cow.
A correct digit in the correct place is a bull.`)
    // generate pattern
    pat := make([]byte, 4)
    rand.Seed(time.Now().Unix())
    r := rand.Perm(9)
    for i := range pat {
        pat[i] = '1' + byte(r[i])
    }
 
    // accept and score guesses
    valid := []byte(""123456789"")
guess:
    for in := bufio.NewReader(os.Stdin); ; {
        fmt.Print(""Guess: "")
        guess, err := in.ReadString('\n')
        if err != nil {
            fmt.Println(""\nSo, bye."")
            return
        }
        guess = strings.TrimSpace(guess)
        if len(guess) != 4 {
            // malformed:  not four characters
            fmt.Println(""Please guess a four digit number."")
            continue
        }
        var cows, bulls int
        for ig, cg := range guess {
            if strings.IndexRune(guess[:ig], cg) >= 0 {
                // malformed:  repeated digit
                fmt.Printf(""Repeated digit: %c\n"", cg)
                continue guess
            }
            switch bytes.IndexByte(pat, byte(cg)) {
            case -1:
                if bytes.IndexByte(valid, byte(cg)) == -1 {
                    // malformed:  not a digit
                    fmt.Printf(""Invalid digit: %c\n"", cg)
                    continue guess
                }
            default: // I just think cows should go first
                cows++
            case ig:
                bulls++
            }
        }
        fmt.Printf(""Cows: %d, bulls: %d\n"", cows, bulls)
        if bulls == 4 {
            fmt.Println(""You got it."")
            return
        }
    }
}",1849,68
71095,http://rosettacode.org/wiki/Caesar_cipher,Caesar cipher,"

Task

Implement a Caesar cipher, both encoding and decoding. 

The key is an integer from 1 to 25.

This cipher rotates (either towards left or right) the letters of the alphabet (A to Z).

The encoding replaces each letter with the 1st to 25th next letter in the alphabet (wrapping Z to A).

So key 2 encrypts ""HI"" to ""JK"", but key 20 encrypts ""HI"" to ""BC"".

This simple ""mono-alphabetic substitution cipher"" provides almost no security, because an attacker who has the encoded message can either use frequency analysis to guess the key, or just try all 25 keys.

Caesar cipher is identical to Vigenère cipher with a key of length 1. 

Also, Rot-13 is identical to Caesar cipher with key 13.



Related tasks

 Rot-13
 Substitution Cipher
 Vigenère Cipher/Cryptanalysis

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
type ckey struct {
    enc, dec func(rune) rune
}
 
func newCaesar(k int) (*ckey, bool) {
    if k < 1 || k > 25 {
        return nil, false
    }
    rk := rune(k)
    return &ckey{
        enc: func(c rune) rune {
            if c >= 'a' && c <= 'z'-rk || c >= 'A' && c <= 'Z'-rk {
                return c + rk
            } else if c > 'z'-rk && c <= 'z' || c > 'Z'-rk && c <= 'Z' {
                return c + rk - 26
            }
            return c
        },
        dec: func(c rune) rune {
            if c >= 'a'+rk && c <= 'z' || c >= 'A'+rk && c <= 'Z' {
                return c - rk
            } else if c >= 'a' && c < 'a'+rk || c >= 'A' && c < 'A'+rk {
                return c - rk + 26
            }
            return c
        },
    }, true
}
 
func (ck ckey) encipher(pt string) string {
    return strings.Map(ck.enc, pt)
}
 
func (ck ckey) decipher(ct string) string {
    return strings.Map(ck.dec, ct)
}
 
func main() {
    pt := ""The five boxing wizards jump quickly""
    fmt.Println(""Plaintext:"", pt)
    for _, key := range []int{0, 1, 7, 25, 26} {
        ck, ok := newCaesar(key)
        if !ok {
            fmt.Println(""Key"", key, ""invalid"")
            continue
        }
        ct := ck.encipher(pt)
        fmt.Println(""Key"", key)
        fmt.Println(""  Enciphered:"", ct)
        fmt.Println(""  Deciphered:"", ck.decipher(ct))
    }
}",1425,59
71253,http://rosettacode.org/wiki/Bitmap/PPM_conversion_through_a_pipe,Bitmap/PPM conversion through a pipe,"Using the data storage type defined on this page for raster images, delegate writing a JPEG file through a pipe using the output_ppm function defined on this other page.

There are various utilities that can be used for this task, for example: cjpeg (package ""jpeg-progs"" on Linux), ppmtojpeg (package ""netpbm"" on Linux), convert (from ImageMagick, multi-platform).
",#Go,Go,"package main
 
// Files required to build supporting package raster are found in:
// * Bitmap
// * Write a PPM file
 
import (
    ""fmt""
    ""math/rand""
    ""os/exec""
    ""raster""
)
 
func main() {
    b := raster.NewBitmap(400, 300)
    // a little extravagant, this draws a design of dots and lines
    b.FillRgb(0xc08040)
    for i := 0; i < 2000; i++ {
        b.SetPxRgb(rand.Intn(400), rand.Intn(300), 0x804020)
    }
    for x := 0; x < 400; x++ {
        for y := 240; y < 245; y++ {
            b.SetPxRgb(x, y, 0x804020)
        }
        for y := 260; y < 265; y++ {
            b.SetPxRgb(x, y, 0x804020)
        }
    }
    for y := 0; y < 300; y++ {
        for x := 80; x < 85; x++ {
            b.SetPxRgb(x, y, 0x804020)
        }
        for x := 95; x < 100; x++ {
            b.SetPxRgb(x, y, 0x804020)
        }
    }
 
    // pipe logic
    c := exec.Command(""cjpeg"", ""-outfile"", ""pipeout.jpg"")
    pipe, err := c.StdinPipe()
    if err != nil {
        fmt.Println(err)
        return
    }
    err = c.Start()
    if err != nil {
        fmt.Println(err)
        return
    }
    err = b.WritePpmTo(pipe)
    if err != nil {
        fmt.Println(err)
        return
    }
    err = pipe.Close()
    if err != nil {
        fmt.Println(err)
    }
}",1270,59
71286,http://rosettacode.org/wiki/Bitmap/Read_an_image_through_a_pipe,Bitmap/Read an image through a pipe,"This task is the opposite of the PPM conversion through a pipe. In this task, using a delegate tool (like cjpeg, one of the netpbm package, or convert of the ImageMagick package) we read an image file and load it into the data storage type defined here. We can also use the code from Read ppm file, so that we can use PPM format like a (natural) bridge between the foreign image format and our simple data storage.
",#Go,Go,"package main
 
// Files required to build supporting package raster are found in:
// * Bitmap
// * Read a PPM file
// * Write a PPM file
 
import (
    ""log""
    ""os/exec""
    ""raster""
)
 
func main() {
    c := exec.Command(""convert"", ""Unfilledcirc.png"", ""-depth"", ""1"", ""ppm:-"")
    pipe, err := c.StdoutPipe()
    if err != nil {
        log.Fatal(err)
    }
    if err = c.Start(); err != nil {
        log.Fatal(err)
    }
    b, err := raster.ReadPpmFrom(pipe)
    if err != nil {
        log.Fatal(err)
    }
    if err = b.WritePpmFile(""Unfilledcirc.ppm""); err != nil {
        log.Fatal(err)
    }
}",607,30
71390,http://rosettacode.org/wiki/Bitmap/Read_a_PPM_file,Bitmap/Read a PPM file,"Using the data storage type defined on this page for raster images, read an image from a PPM file (binary P6 prefered).
(Read the definition of PPM file on Wikipedia.)

Task: Use write ppm file solution and grayscale image solution with this one in order to convert a color image to grayscale one.
",#Go,Go,"package raster
 
import (
    ""errors""
    ""io""
    ""io/ioutil""
    ""os""
    ""regexp""
    ""strconv""
)
 
// ReadFrom constructs a Bitmap object from an io.Reader.
func ReadPpmFrom(r io.Reader) (b *Bitmap, err error) {
    var all []byte
    all, err = ioutil.ReadAll(r)
    if err != nil {
        return
    }
    bss := rxHeader.FindSubmatch(all)
    if bss == nil {
        return nil, errors.New(""unrecognized ppm header"")
    }
    x, _ := strconv.Atoi(string(bss[3]))
    y, _ := strconv.Atoi(string(bss[6]))
    maxval, _ := strconv.Atoi(string(bss[9]))
    if maxval > 255 {
        return nil, errors.New(""16 bit ppm not supported"")
    }
    allCmts := append(append(append(bss[1], bss[4]...), bss[7]...), bss[10]...)
    b = NewBitmap(x, y)
    b.Comments = rxComment.FindAllString(string(allCmts), -1)
    b3 := all[len(bss[0]):]
    var n1 int
    for i := range b.px {
        b.px[i].R = byte(int(b3[n1]) * 255 / maxval)
        b.px[i].G = byte(int(b3[n1+1]) * 255 / maxval)
        b.px[i].B = byte(int(b3[n1+2]) * 255 / maxval)
        n1 += 3
    }
    return
}
 
const (
    // single whitespace character
    ws = ""[ \n\r\t\v\f]""
    // isolated comment
    cmt = ""#[^\n\r]*""
    // comment sub expression
    cmts = ""("" + ws + ""*"" + cmt + ""[\n\r])""
    // number with leading comments
    num = ""("" + cmts + ""+"" + ws + ""*|"" + ws + ""+)([0-9]+)""
)
 
var rxHeader = regexp.MustCompile(""^P6"" + num + num + num +
    ""("" + cmts + ""*"" + "")"" + ws)
var rxComment = regexp.MustCompile(cmt)
 
// ReadFile writes binary P6 format PPM from the specified filename.
func ReadPpmFile(fn string) (b *Bitmap, err error) {
    var f *os.File
    if f, err = os.Open(fn); err != nil {
        return
    }
    if b, err = ReadPpmFrom(f); err != nil {
        return
    }
    return b, f.Close()
}",1799,68
71421,http://rosettacode.org/wiki/Bitwise_IO,Bitwise IO,"The aim of this task is to write functions (or create a class if your
language is Object Oriented and you prefer) for reading and writing sequences of
bits, most significant bit first. While the output of a asciiprint ""STRING"" is the ASCII byte sequence
""S"", ""T"", ""R"", ""I"", ""N"", ""G"", the output of a ""print"" of the bits sequence
0101011101010 (13 bits) must be 0101011101010; real I/O is performed always
quantized by byte (avoiding endianness issues and relying on underlying
buffering for performance), therefore you must obtain as output the bytes
0101 0111 0101 0000 (bold bits are padding bits), i.e. in hexadecimal 57 50.

As test, you can implement a rough (e.g. don't care about error handling or
other issues) compression/decompression program for ASCII sequences
of bytes, i.e. bytes for which the most significant bit is always unused, so that you can write
seven bits instead of eight (each 8 bytes of input, we write 7 bytes of output).

These bit oriented I/O functions can be used to implement compressors and
decompressors; e.g. Dynamic and Static Huffman encodings use variable length
bits sequences, while LZW (see LZW compression) use fixed or variable words
nine (or more) bits long.

 Limits in the maximum number of bits that can be written/read in a single read/write operation are allowed.
 Errors handling is not mandatory

",#Go,Go,"// Package bit provides bit-wise IO to an io.Writer and from an io.Reader.
package bit
 
import (
    ""bufio""
    ""errors""
    ""io""
)
 
// Order specifies the bit ordering within a byte stream.
type Order int
 
const (
    // LSB is for Least Significant Bits first
    LSB Order = iota
    // MSB is for Most  Significant Bits first
    MSB
)
 
// ==== Writing / Encoding ====
 
type writer interface {
    io.ByteWriter
    Flush() error
}
 
// Writer implements bit-wise writing to an io.Writer.
type Writer struct {
    w     writer
    order Order
    write func(uint32, uint) error // writeLSB or writeMSB
    bits  uint32
    nBits uint
    err   error
}
 
// writeLSB writes `width` bits of `c` in LSB order.
func (w *Writer) writeLSB(c uint32, width uint) error {
    w.bits |= c << w.nBits
    w.nBits += width
    for w.nBits >= 8 {
        if err := w.w.WriteByte(uint8(w.bits)); err != nil {
            return err
        }
        w.bits >>= 8
        w.nBits -= 8
    }
    return nil
}
 
// writeMSB writes `width` bits of `c` in MSB order.
func (w *Writer) writeMSB(c uint32, width uint) error {
    w.bits |= c << (32 - width - w.nBits)
    w.nBits += width
    for w.nBits >= 8 {
        if err := w.w.WriteByte(uint8(w.bits >> 24)); err != nil {
            return err
        }
        w.bits <<= 8
        w.nBits -= 8
    }
    return nil
}
 
// WriteBits writes up to 16 bits of `c` to the underlying writer.
// Even for MSB ordering the bits are taken from the lower bits of `c`.
// (e.g. WriteBits(0x0f,4) writes four 1 bits).
func (w *Writer) WriteBits(c uint16, width uint) error {
    if w.err == nil {
        w.err = w.write(uint32(c), width)
    }
    return w.err
}
 
var errClosed = errors.New(""bit reader/writer is closed"")
 
// Close closes the writer, flushing any pending output.
// It does not close the underlying writer.
func (w *Writer) Close() error {
    if w.err != nil {
        if w.err == errClosed {
            return nil
        }
        return w.err
    }
    // Write the final bits (zero padded).
    if w.nBits > 0 {
        if w.order == MSB {
            w.bits >>= 24
        }
        if w.err = w.w.WriteByte(uint8(w.bits)); w.err != nil {
            return w.err
        }
    }
    w.err = w.w.Flush()
    if w.err != nil {
        return w.err
    }
 
    // Make any future calls to Write return errClosed.
    w.err = errClosed
    return nil
}
 
// NewWriter returns a new bit Writer that writes completed bytes to `w`.
func NewWriter(w io.Writer, order Order) *Writer {
    bw := &Writer{order: order}
    switch order {
    case LSB:
        bw.write = bw.writeLSB
    case MSB:
        bw.write = bw.writeMSB
    default:
        bw.err = errors.New(""bit writer: unknown order"")
        return bw
    }
    if byteWriter, ok := w.(writer); ok {
        bw.w = byteWriter
    } else {
        bw.w = bufio.NewWriter(w)
    }
    return bw
}
 
// ==== Reading / Decoding ====
 
// Reader implements bit-wise reading from an io.Reader.
type Reader struct {
    r     io.ByteReader
    bits  uint32
    nBits uint
    read  func(width uint) (uint16, error) // readLSB or readMSB
    err   error
}
 
func (r *Reader) readLSB(width uint) (uint16, error) {
    for r.nBits < width {
        x, err := r.r.ReadByte()
        if err != nil {
            return 0, err
        }
        r.bits |= uint32(x) << r.nBits
        r.nBits += 8
    }
    bits := uint16(r.bits & (1<<width - 1))
    r.bits >>= width
    r.nBits -= width
    return bits, nil
}
 
func (r *Reader) readMSB(width uint) (uint16, error) {
    for r.nBits < width {
        x, err := r.r.ReadByte()
        if err != nil {
            return 0, err
        }
        r.bits |= uint32(x) << (24 - r.nBits)
        r.nBits += 8
    }
    bits := uint16(r.bits >> (32 - width))
    r.bits <<= width
    r.nBits -= width
    return bits, nil
}
 
// ReadBits reads up to 16 bits from the underlying reader.
func (r *Reader) ReadBits(width uint) (uint16, error) {
    var bits uint16
    if r.err == nil {
        bits, r.err = r.read(width)
    }
    return bits, r.err
}
 
// Close closes the reader.
// It does not close the underlying reader.
func (r *Reader) Close() error {
    if r.err != nil && r.err != errClosed {
        return r.err
    }
    r.err = errClosed
    return nil
}
 
// NewReader returns a new bit Reader that reads bytes from `r`.
func NewReader(r io.Reader, order Order) *Reader {
    br := new(Reader)
    switch order {
    case LSB:
        br.read = br.readLSB
    case MSB:
        br.read = br.readMSB
    default:
        br.err = errors.New(""bit writer: unknown order"")
        return br
    }
    if byteReader, ok := r.(io.ByteReader); ok {
        br.r = byteReader
    } else {
        br.r = bufio.NewReader(r)
    }
    return br
}",4799,203
71423,http://rosettacode.org/wiki/Bitmap/Write_a_PPM_file,Bitmap/Write a PPM file,"Using the data storage type defined on this page for raster images, write the image to a PPM file (binary P6 prefered).

(Read the definition of PPM file on Wikipedia.)



",#Go,Go,"package raster
 
import (
    ""fmt""
    ""io""
    ""os""
)
 
// WriteTo outputs 8-bit P6 PPM format to an io.Writer.
func (b *Bitmap) WritePpmTo(w io.Writer) (err error) {
    // magic number
    if _, err = fmt.Fprintln(w, ""P6""); err != nil {
        return
    }
 
    // comments
    for _, c := range b.Comments {
        if _, err = fmt.Fprintln(w, c); err != nil {
            return
        }
    }
 
    // x, y, depth
    _, err = fmt.Fprintf(w, ""%d %d\n255\n"", b.cols, b.rows)
    if err != nil {
        return
    }
 
    // raster data in a single write
    b3 := make([]byte, 3*len(b.px))
    n1 := 0
    for _, px := range b.px {
        b3[n1] = px.R
        b3[n1+1] = px.G
        b3[n1+2] = px.B
        n1 += 3
    }
    if _, err = w.Write(b3); err != nil {
        return
    }
    return
}
 
// WriteFile writes to the specified filename.
func (b *Bitmap) WritePpmFile(fn string) (err error) {
    var f *os.File
    if f, err = os.Create(fn); err != nil {
        return
    }
    if err = b.WritePpmTo(f); err != nil {
        return
    }
    return f.Close()
}",1084,54
71553,http://rosettacode.org/wiki/Bitmap/Histogram,Bitmap/Histogram,"Extend the basic bitmap storage defined on this page to support dealing with image histograms. The image histogram contains for each luminance the count of image pixels having this luminance. Choosing a histogram representation take care about the data type used for the counts. It must have range of at least 0..NxM, where N is the image width and M is the image height.

Test task

Histogram is useful for many image processing operations. As an example, use it to convert an image into black and white art. The method works as follows:

 Convert image to grayscale;
 Compute the histogram
 Find the median: defined as the luminance such that the image has an approximately equal number of pixels with lesser and greater luminance.
 Replace each pixel of luminance lesser than the median to black, and others to white.
Use  read/write ppm file, and grayscale image solutions.
",#Go,Go,"package raster
 
import ""math""
 
func (g *Grmap) Histogram(bins int) []int {
    if bins <= 0 {
        bins = g.cols
    }
    h := make([]int, bins)
    for _, p := range g.px {
        h[int(p)*(bins-1)/math.MaxUint16]++
    }
    return h
}
 
func (g *Grmap) Threshold(t uint16) {
    for i, p := range g.px {
        if p < t {
            g.px[i] = 0
        } else {
            g.px[i] = math.MaxUint16
        }
    }
}",428,24
71585,http://rosettacode.org/wiki/Bitmap/B%C3%A9zier_curves/Quadratic,Bitmap/Bézier curves/Quadratic,"Using the data storage type defined on this page for raster images, and the draw_line function defined in this one, draw a quadratic bezier curve
(definition on Wikipedia).
",#Go,Go,"package raster
 
const b2Seg = 20
 
func (b *Bitmap) Bézier2(x1, y1, x2, y2, x3, y3 int, p Pixel) {
    var px, py [b2Seg + 1]int
    fx1, fy1 := float64(x1), float64(y1)
    fx2, fy2 := float64(x2), float64(y2)
    fx3, fy3 := float64(x3), float64(y3)
    for i := range px {
        c := float64(i) / b2Seg
        a := 1 - c
        a, b, c := a*a, 2 * c * a, c*c
        px[i] = int(a*fx1 + b*fx2 + c*fx3)
        py[i] = int(a*fy1 + b*fy2 + c*fy3)
    }
    x0, y0 := px[0], py[0]
    for i := 1; i <= b2Seg; i++ {
        x1, y1 := px[i], py[i]
        b.Line(x0, y0, x1, y1, p)
        x0, y0 = x1, y1
    }
}
 
func (b *Bitmap) Bézier2Rgb(x1, y1, x2, y2, x3, y3 int, c Rgb) {
    b.Bézier2(x1, y1, x2, y2, x3, y3, c.Pixel())
}",734,27
71651,http://rosettacode.org/wiki/Bitmap/Midpoint_circle_algorithm,Bitmap/Midpoint circle algorithm,"Task

Using the data storage type defined on this page for raster images,
write an implementation of the midpoint circle algorithm   (also known as Bresenham's circle algorithm).

(definition on Wikipedia).



",#Go,Go,"package raster
 
// Circle plots a circle with center x, y and radius r.
// Limiting behavior:
// r < 0 plots no pixels.
// r = 0 plots a single pixel at x, y.
// r = 1 plots four pixels in a diamond shape around the center pixel at x, y.
func (b *Bitmap) Circle(x, y, r int, p Pixel) {
    if r < 0 {
        return
    }
    // Bresenham algorithm
    x1, y1, err := -r, 0, 2-2*r
    for {
        b.SetPx(x-x1, y+y1, p)
        b.SetPx(x-y1, y-x1, p)
        b.SetPx(x+x1, y-y1, p)
        b.SetPx(x+y1, y+x1, p)
        r = err
        if r > x1 {
            x1++
            err += x1*2 + 1
        }
        if r <= y1 {
            y1++
            err += y1*2 + 1
        }
        if x1 >= 0 {
            break
        }
    }
}
 
func (b *Bitmap) CircleRgb(x, y, r int, c Rgb) {
    b.Circle(x, y, r, c.Pixel())
}",825,36
71698,http://rosettacode.org/wiki/Bitcoin/public_point_to_address,Bitcoin/public point to address,"Bitcoin uses a specific encoding format to encode the digest of an elliptic curve public point into a short ASCII string. The purpose of this task is to perform such a conversion.

The encoding steps are:

 take the X and Y coordinates of the given public point, and concatenate them in order to have a 64 byte-longed string ;
 add one byte prefix equal to 4 (it is a convention for this way of encoding a public point) ;
 compute the SHA-256 of this string ;
 compute the RIPEMD-160 of this SHA-256 digest ;
 compute the checksum of the concatenation of the version number digit (a single zero byte) and this RIPEMD-160 digest, as described in bitcoin/address validation ;
 Base-58 encode (see below) the concatenation of the version number (zero in this case), the ripemd digest and the checksum
The base-58 encoding is based on an alphabet of alphanumeric characters (numbers, upper case and lower case, in that order) but without the four characters 0, O, l and I.

Here is an example public point:

X = 0x50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352
Y = 0x2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6
The corresponding address should be:
16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM

Nb. The leading '1' is not significant as 1 is zero in base-58. It is however often added to the bitcoin address for various reasons. There can actually be several of them. You can ignore this and output an address without the leading 1.

Extra credit: add a verification procedure about the public point, making sure it belongs to the secp256k1 elliptic curve
",#Go,Go,"package main
 
import (
    ""crypto/sha256""
    ""encoding/hex""
    ""errors""
    ""fmt""
 
    ""golang.org/x/crypto/ripemd160""
)
 
// Point is a type for a bitcoin public point.
type Point struct {
    x, y [32]byte
}
 
// SetHex takes two hexidecimal strings and decodes them into the receiver.
func (p *Point) SetHex(x, y string) error {
    if len(x) != 64 || len(y) != 64 {
        return errors.New(""invalid hex string length"")
    }
    if _, err := hex.Decode(p.x[:], []byte(x)); err != nil {
        return err
    }
    _, err := hex.Decode(p.y[:], []byte(y))
    return err
}
 
// A25 type in common with Bitcoin/address validation task.
type A25 [25]byte
 
// doubleSHA256 method in common with Bitcoin/address validation task.
func (a *A25) doubleSHA256() []byte {
    h := sha256.New()
    h.Write(a[:21])
    d := h.Sum([]byte{})
    h = sha256.New()
    h.Write(d)
    return h.Sum(d[:0])
}
 
// UpdateChecksum computes the address checksum on the first 21 bytes and
// stores the result in the last 4 bytes.
func (a *A25) UpdateChecksum() {
    copy(a[21:], a.doubleSHA256())
}
 
// SetPoint takes a public point and generates the corresponding address
// into the receiver, complete with valid checksum.
func (a *A25) SetPoint(p *Point) {
    c := [65]byte{4}
    copy(c[1:], p.x[:])
    copy(c[33:], p.y[:])
    h := sha256.New()
    h.Write(c[:])
    s := h.Sum([]byte{})
    h = ripemd160.New()
    h.Write(s)
    h.Sum(a[1:1])
    a.UpdateChecksum()
}
 
// Tmpl in common with Bitcoin/address validation task.
var tmpl = []byte(""123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"")
 
// A58 returns a base58 encoded bitcoin address corresponding to the receiver.
// Code adapted from the C solution to this task.
func (a *A25) A58() []byte {
    var out [34]byte
    for n := 33; n >= 0; n-- {
        c := 0
        for i := 0; i < 25; i++ {
            c = c*256 + int(a[i])
            a[i] = byte(c / 58)
            c %= 58
        }
        out[n] = tmpl[c]
    }
    i := 1
    for i < 34 && out[i] == '1' {
        i++
    }
    return out[i-1:]
}
 
func main() {
    // parse hex into point object
    var p Point
    err := p.SetHex(
        ""50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352"",
        ""2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6"")
    if err != nil {
        fmt.Println(err)
        return
    }
    // generate address object from point
    var a A25
    a.SetPoint(&p)
    // show base58 representation
    fmt.Println(string(a.A58()))
}",2531,101
71732,http://rosettacode.org/wiki/Bitmap/B%C3%A9zier_curves/Cubic,Bitmap/Bézier curves/Cubic,"Using the data storage type defined on this page for raster images, and the draw_line function defined in this other one, draw a cubic bezier curve
(definition on Wikipedia).
",#Go,Go,"package raster
 
const b3Seg = 30
 
func (b *Bitmap) Bézier3(x1, y1, x2, y2, x3, y3, x4, y4 int, p Pixel) {
    var px, py [b3Seg + 1]int
    fx1, fy1 := float64(x1), float64(y1)
    fx2, fy2 := float64(x2), float64(y2)
    fx3, fy3 := float64(x3), float64(y3)
    fx4, fy4 := float64(x4), float64(y4)
    for i := range px {
        d := float64(i) / b3Seg
        a := 1 - d
        b, c := a * a, d * d
        a, b, c, d = a*b, 3*b*d, 3*a*c, c*d
        px[i] = int(a*fx1 + b*fx2 + c*fx3 + d*fx4)
        py[i] = int(a*fy1 + b*fy2 + c*fy3 + d*fy4)
    }
    x0, y0 := px[0], py[0]
    for i := 1; i <= b3Seg; i++ {
        x1, y1 := px[i], py[i]
        b.Line(x0, y0, x1, y1, p)
        x0, y0 = x1, y1
    }
}
 
func (b *Bitmap) Bézier3Rgb(x1, y1, x2, y2, x3, y3, x4, y4 int, c Rgb) {
    b.Bézier3(x1, y1, x2, y2, x3, y3, x4, y4, c.Pixel())
}",849,29
71821,http://rosettacode.org/wiki/Bitcoin/address_validation,Bitcoin/address validation,"Bitcoin/address validation

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Write a program that takes a bitcoin address as argument,
and checks whether or not this address is valid.

A bitcoin address uses a base58 encoding, which uses an alphabet of the characters 0 .. 9, A ..Z, a .. z, but without the four characters:

   0   zero
   O   uppercase oh
   I   uppercase eye
   l   lowercase ell


With this encoding, a bitcoin address encodes 25 bytes:

 the first byte is the version number, which will be zero for this task ;
 the next twenty bytes are a RIPEMD-160 digest, but you don't have to know that for this task: you can consider them a pure arbitrary data ;
 the last four bytes are a checksum check. They are the first four bytes of a double SHA-256 digest of the previous 21 bytes.


To check the bitcoin address, you must read the first twenty-one bytes, compute the checksum, and check that it corresponds to the last four bytes.

The program can either return a boolean value or throw an exception when not valid.

You can use a digest library for SHA-256.



Example of a bitcoin address



1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i



It doesn't belong to anyone and is part of the test suite of the bitcoin software.

You can change a few characters in this string and check that it'll fail the test.



",#Go,Go,"package main
 
import (
    ""bytes""
    ""crypto/sha256""
    ""errors""
    ""os""
)
 
// With at least one other bitcoin RC task, this source is styled more like
// a package to show how functions of the two tasks might be combined into
// a single package.  It turns out there's not really that much shared code,
// just the A25 type and doubleSHA256 method, but it's enough to suggest how
// the code might be organized.  Types, methods, and functions are capitalized
// where they might be exported from a package.
 
// A25 is a type for a 25 byte (not base58 encoded) bitcoin address.
type A25 [25]byte
 
func (a *A25) Version() byte {
    return a[0]
}
 
func (a *A25) EmbeddedChecksum() (c [4]byte) {
    copy(c[:], a[21:])
    return
}
 
// DoubleSHA256 computes a double sha256 hash of the first 21 bytes of the
// address.  This is the one function shared with the other bitcoin RC task.
// Returned is the full 32 byte sha256 hash.  (The bitcoin checksum will be
// the first four bytes of the slice.)
func (a *A25) doubleSHA256() []byte {
    h := sha256.New()
    h.Write(a[:21])
    d := h.Sum([]byte{})
    h = sha256.New()
    h.Write(d)
    return h.Sum(d[:0])
}
 
// ComputeChecksum returns a four byte checksum computed from the first 21
// bytes of the address.  The embedded checksum is not updated.
func (a *A25) ComputeChecksum() (c [4]byte) {
    copy(c[:], a.doubleSHA256())
    return
}/* {{header|Go}} */ 
 
// Tmpl and Set58 are adapted from the C solution.
// Go has big integers but this techinique seems better.
var tmpl = []byte(""123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"")
 
// Set58 takes a base58 encoded address and decodes it into the receiver.
// Errors are returned if the argument is not valid base58 or if the decoded
// value does not fit in the 25 byte address.  The address is not otherwise
// checked for validity.
func (a *A25) Set58(s []byte) error {
    for _, s1 := range s {
        c := bytes.IndexByte(tmpl, s1)
        if c < 0 {
            return errors.New(""bad char"")
        }
        for j := 24; j >= 0; j-- {
            c += 58 * int(a[j])
            a[j] = byte(c % 256)
            c /= 256
        }
        if c > 0 {
            return errors.New(""too long"")
        }
    }
    return nil
}
 
// ValidA58 validates a base58 encoded bitcoin address.  An address is valid
// if it can be decoded into a 25 byte address, the version number is 0,
// and the checksum validates.  Return value ok will be true for valid
// addresses.  If ok is false, the address is invalid and the error value
// may indicate why.
func ValidA58(a58 []byte) (ok bool, err error) {
    var a A25
    if err := a.Set58(a58); err != nil {
        return false, err
    }
    if a.Version() != 0 {
        return false, errors.New(""not version 0"")
    }
    return a.EmbeddedChecksum() == a.ComputeChecksum(), nil
}
 
// Program returns exit code 0 with valid address and produces no output.
// Otherwise exit code is 1 and a message is written to stderr.
func main() {
    if len(os.Args) != 2 {
        errorExit(""Usage: valid <base58 address>"")
    }
    switch ok, err := ValidA58([]byte(os.Args[1])); {
    case ok:
    case err == nil:
        errorExit(""Invalid"")
    default:
        errorExit(err.Error())
    }
}
 
func errorExit(m string) {
    os.Stderr.WriteString(m + ""\n"")
    os.Exit(1)
}",3358,109
71835,http://rosettacode.org/wiki/Biorhythms,Biorhythms,"For a while in the late 70s, the pseudoscience of biorhythms was popular enough to rival astrology, with kiosks in malls that would give you your weekly printout. It was also a popular entry in ""Things to Do with your Pocket Calculator"" lists. You can read up on the history at Wikipedia, but the main takeaway is that unlike astrology, the math behind biorhythms is dead simple.

It's based on the number of days since your birth. The premise is that three cycles of unspecified provenance govern certain aspects of everyone's lives – specifically, how they're feeling physically, emotionally, and mentally. The best part is that not only do these cycles somehow have the same respective lengths for all humans of any age, gender, weight, genetic background, etc, but those lengths are an exact number of days. And the pattern is in each case a perfect sine curve. Absolutely miraculous!

To compute your biorhythmic profile for a given day, the first thing you need is the number of days between that day and your birth, so the answers in Days between dates are probably a good starting point. (Strictly speaking, the biorhythms start at 0 at the moment of your birth, so if you know time of day you can narrow things down further, but in general these operate at whole-day granularity.) Then take the residue of that day count modulo each of the the cycle lengths to calculate where the day falls on each of the three sinusoidal journeys.

The three cycles and their lengths are as follows:



 Cycle

 Length


Physical

 23 days


Emotional

 28 days


Mental

 33 days

The first half of each cycle is in ""plus"" territory, with a peak at the quarter-way point; the second half in ""minus"" territory, with a valley at the three-quarters mark. You can calculate a specific value between -1 and +1 for the kth day of an n-day cycle by computing sin( 2πk / n ). The days where a cycle crosses the axis in either direction are called ""critical"" days, although with a cycle value of 0 they're also said to be the most neutral, which seems contradictory.

The task: write a subroutine, function, or program that will, given a birthdate and a target date, output the three biorhythmic values for the day. You may optionally include a text description of the position and the trend (e.g. ""up and rising"", ""peak"", ""up but falling"", ""critical"", ""down and falling"", ""valley"", ""down but rising""), an indication of the date on which the next notable event (peak, valley, or crossing) falls, or even a graph of the cycles around the target date. Demonstrate the functionality for dates of your choice.

Example run of my Raku implementation:

raku br.raku 1943-03-09 1972-07-11

Output:
Day 10717:
Physical day 22: -27% (down but rising, next transition 1972-07-12)
Emotional day 21: valley
Mental day 25: valley

Double valley! This was apparently not a good day for Mr. Fischer to begin a chess tournament...
",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math""
    ""time""
)
 
const layout = ""2006-01-02"" // template for time.Parse
 
var cycles = [3]string{""Physical day "", ""Emotional day"", ""Mental day   ""}
var lengths = [3]int{23, 28, 33}
var quadrants = [4][2]string{
    {""up and rising"", ""peak""},
    {""up but falling"", ""transition""},
    {""down and falling"", ""valley""},
    {""down but rising"", ""transition""},
}
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
// Parameters assumed to be in YYYY-MM-DD format.
func biorhythms(birthDate, targetDate string) {
    bd, err := time.Parse(layout, birthDate)
    check(err)
    td, err := time.Parse(layout, targetDate)
    check(err)
    days := int(td.Sub(bd).Hours() / 24)
    fmt.Printf(""Born %s, Target %s\n"", birthDate, targetDate)
    fmt.Println(""Day"", days)
    for i := 0; i < 3; i++ {
        length := lengths[i]
        cycle := cycles[i]
        position := days % length
        quadrant := position * 4 / length
        percent := math.Sin(2 * math.Pi * float64(position) / float64(length))
        percent = math.Floor(percent*1000) / 10
        descript := """"
        if percent > 95 {
            descript = "" peak""
        } else if percent < -95 {
            descript = "" valley""
        } else if math.Abs(percent) < 5 {
            descript = "" critical transition""
        } else {
            daysToAdd := (quadrant+1)*length/4 - position
            transition := td.Add(time.Hour * 24 * time.Duration(daysToAdd))
            trend := quadrants[quadrant][0]
            next := quadrants[quadrant][1]
            transStr := transition.Format(layout)
            descript = fmt.Sprintf(""%5.1f%% (%s, next %s %s)"", percent, trend, next, transStr)
        }
        fmt.Printf(""%s %2d : %s\n"", cycle, position, descript)
    }
    fmt.Println()
}
 
func main() {
    datePairs := [][2]string{
        {""1943-03-09"", ""1972-07-11""},
        {""1809-01-12"", ""1863-11-19""},
        {""1809-02-12"", ""1863-11-19""}, // correct DOB for Abraham Lincoln
    }
    for _, datePair := range datePairs {
        biorhythms(datePair[0], datePair[1])
    }
}",2139,72
71843,http://rosettacode.org/wiki/Bitmap/Flood_fill,Bitmap/Flood fill,"Implement a flood fill.

A flood fill is a way of filling an area using color banks to define the contained area or a target color which ""determines"" the area (the valley that can be flooded; Wikipedia uses the term target color). It works almost like a water flooding from a point towards the banks (or: inside the valley): if there's a hole in the banks, the flood is not contained and all the image (or all the ""connected valleys"") get filled.

To accomplish the task, you need to implement just one of the possible algorithms (examples are on Wikipedia). Variations on the theme are allowed (e.g. adding a tolerance parameter or argument for color-matching of the banks or target color).

 
Testing: the basic algorithm is not suitable for truecolor images; a possible test image is the one shown on the right box; you can try to fill the white area, or the black inner circle.
",#Go,Go,"package raster
 
func (b *Bitmap) Flood(x, y int, repl Pixel) {
    targ, _ := b.GetPx(x, y)
    var ff func(x, y int)
    ff = func(x, y int) {
        p, ok := b.GetPx(x, y)
        if ok && p.R == targ.R && p.G == targ.G && p.B == targ.B {
            b.SetPx(x, y, repl)
            ff(x-1, y)
            ff(x+1, y)
            ff(x, y-1)
            ff(x, y+1)
        }
    }
    ff(x, y)
}",397,17
71859,http://rosettacode.org/wiki/Bioinformatics/Sequence_mutation,Bioinformatics/Sequence mutation,"Task

Given a string of characters A, C, G, and T representing a DNA sequence write a routine to mutate the sequence, (string) by:

 Choosing a random base position in the sequence.
 Mutate the sequence by doing one of either:
 Swap the base at that position by changing it to one of A, C, G, or T. (which has a chance of swapping the base for the same base)
 Delete the chosen base at the position.
 Insert another base randomly chosen from A,C, G, or T into the sequence at that position.
 Randomly generate a test DNA sequence of at least 200 bases
 ""Pretty print"" the sequence and a count of its size, and the count of each base in the sequence
 Mutate the sequence ten times.
 ""Pretty print"" the sequence after all mutations, and a count of its size, and the count of each base in the sequence.
Extra credit

 Give more information on the individual mutations applied.
 Allow mutations to be weighted and/or chosen.",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""sort""
    ""time""
)
 
const bases = ""ACGT""
 
// 'w' contains the weights out of 300 for each
// of swap, delete or insert in that order.
func mutate(dna string, w [3]int) string {
    le := len(dna)
    // get a random position in the dna to mutate
    p := rand.Intn(le)
    // get a random number between 0 and 299 inclusive
    r := rand.Intn(300)
    bytes := []byte(dna)
    switch {
    case r < w[0]: // swap
        base := bases[rand.Intn(4)]
        fmt.Printf(""  Change @%3d %q to %q\n"", p, bytes[p], base)
        bytes[p] = base
    case r < w[0]+w[1]: // delete
        fmt.Printf(""  Delete @%3d %q\n"", p, bytes[p])
        copy(bytes[p:], bytes[p+1:])
        bytes = bytes[0 : le-1]
    default: // insert
        base := bases[rand.Intn(4)]
        bytes = append(bytes, 0)
        copy(bytes[p+1:], bytes[p:])
        fmt.Printf(""  Insert @%3d %q\n"", p, base)
        bytes[p] = base
    }
    return string(bytes)
}
 
// Generate a random dna sequence of given length.
func generate(le int) string {
    bytes := make([]byte, le)
    for i := 0; i < le; i++ {
        bytes[i] = bases[rand.Intn(4)]
    }
    return string(bytes)
}
 
// Pretty print dna and stats.
func prettyPrint(dna string, rowLen int) {
    fmt.Println(""SEQUENCE:"")
    le := len(dna)
    for i := 0; i < le; i += rowLen {
        k := i + rowLen
        if k > le {
            k = le
        }
        fmt.Printf(""%5d: %s\n"", i, dna[i:k])
    }
    baseMap := make(map[byte]int) // allows for 'any' base
    for i := 0; i < le; i++ {
        baseMap[dna[i]]++
    }
    var bases []byte
    for k := range baseMap {
        bases = append(bases, k)
    }
    sort.Slice(bases, func(i, j int) bool { // get bases into alphabetic order
        return bases[i] < bases[j]
    })
 
    fmt.Println(""\nBASE COUNT:"")
    for _, base := range bases {
        fmt.Printf(""    %c: %3d\n"", base, baseMap[base])
    }
    fmt.Println(""    ------"")
    fmt.Println(""    Σ:"", le)
    fmt.Println(""    ======\n"")
}
 
// Express weights as a string.
func wstring(w [3]int) string {
    return fmt.Sprintf(""  Change: %d\n  Delete: %d\n  Insert: %d\n"", w[0], w[1], w[2])
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    dna := generate(250)
    prettyPrint(dna, 50)
    muts := 10
    w := [3]int{100, 100, 100} // use e.g. {0, 300, 0} to choose only deletions
    fmt.Printf(""WEIGHTS (ex 300):\n%s\n"", wstring(w))
    fmt.Printf(""MUTATIONS (%d):\n"", muts)
    for i := 0; i < muts; i++ {
        dna = mutate(dna, w)
    }
    fmt.Println()
    prettyPrint(dna, 50)
}",2607,99
71864,http://rosettacode.org/wiki/Boolean_values,Boolean values,"Task

Show how to represent the boolean states ""true"" and ""false"" in a language.

If other objects represent ""true"" or ""false"" in conditionals, note it.



Related tasks

   Logical operations

",#Go,Go," 
package main
 
import (
	""fmt""
	""reflect""
	""strconv""
)
 
func main() {
	var n bool = true
	fmt.Println(n)        // prt true
	fmt.Printf(""%T\n"", n) // prt bool
	n = !n
	fmt.Println(n) // prt false
 
	x := 5
	y := 8
	fmt.Println(""x == y:"", x == y) // prt x == y: false
	fmt.Println(""x < y:"", x < y)   // prt x < y: true
 
	fmt.Println(""\nConvert String into Boolean Data type\n"")
	str1 := ""japan""
	fmt.Println(""Before :"", reflect.TypeOf(str1)) // prt Before : string
	bolStr, _ := strconv.ParseBool(str1)
	fmt.Println(""After :"", reflect.TypeOf(bolStr)) // prt After : bool
}",575,27
71940,http://rosettacode.org/wiki/Box_the_compass,Box the compass,"There be many a land lubber that knows naught of the pirate ways and gives direction by degree!
They know not how to box the compass!



Task description

 Create a function that takes a heading in degrees and returns the correct 32-point compass heading.
 Use the function to print and display a table of Index, Compass point, and Degree; rather like the corresponding columns from, the first table of the wikipedia article, but use only the following 33 headings as input:
[0.0, 16.87, 16.88, 33.75, 50.62, 50.63, 67.5, 84.37, 84.38, 101.25, 118.12, 118.13, 135.0, 151.87, 151.88, 168.75, 185.62, 185.63, 202.5, 219.37, 219.38, 236.25, 253.12, 253.13, 270.0, 286.87, 286.88, 303.75, 320.62, 320.63, 337.5, 354.37, 354.38]. (They should give the same order of points but are spread throughout the ranges of acceptance).


Notes;
 The headings and indices can be calculated from this pseudocode:
for i in 0..32 inclusive:
    heading = i * 11.25
    case i %3:
      if 1: heading += 5.62; break
      if 2: heading -= 5.62; break
    end
    index = ( i mod 32) + 1
 The column of indices can be thought of as an enumeration of the thirty two cardinal points (see talk page)..

",#Go,Go,"package main
 
import ""fmt""
 
// function required by task
func degrees2compasspoint(h float32) string {
    return compassPoint[cpx(h)]
}
 
// cpx returns integer index from 0 to 31 corresponding to compass point.
// input heading h is in degrees.  Note this index is a zero-based index
// suitable for indexing into the table of printable compass points,
// and is not the same as the index specified to be printed in the output.
func cpx(h float32) int {
    x := int(h/11.25+.5) % 32
    if x < 0 {
        x += 32
    }
    return x
}
 
// printable compass points
var compassPoint = []string{
    ""North"",
    ""North by east"",
    ""North-northeast"",
    ""Northeast by north"",
    ""Northeast"",
    ""Northeast by east"",
    ""East-northeast"",
    ""East by north"",
    ""East"",
    ""East by south"",
    ""East-southeast"",
    ""Southeast by east"",
    ""Southeast"",
    ""Southeast by south"",
    ""South-southeast"",
    ""South by east"",
    ""South"",
    ""South by west"",
    ""South-southwest"",
    ""Southwest by south"",
    ""Southwest"",
    ""Southwest by west"",
    ""West-southwest"",
    ""West by south"",
    ""West"",
    ""West by north"",
    ""West-northwest"",
    ""Northwest by west"",
    ""Northwest"",
    ""Northwest by north"",
    ""North-northwest"",
    ""North by west"",
}
 
func main() {
    fmt.Println(""Index  Compass point         Degree"")
    for i, h := range []float32{0.0, 16.87, 16.88, 33.75, 50.62, 50.63, 67.5,
        84.37, 84.38, 101.25, 118.12, 118.13, 135.0, 151.87, 151.88, 168.75,
        185.62, 185.63, 202.5, 219.37, 219.38, 236.25, 253.12, 253.13, 270.0,
        286.87, 286.88, 303.75, 320.62, 320.63, 337.5, 354.37, 354.38} {
        index := i%32 + 1 // printable index computed per pseudocode
        fmt.Printf(""%4d   %-19s %7.2f°\n"", index, degrees2compasspoint(h), h)
    }
}",1802,67
72013,http://rosettacode.org/wiki/Bioinformatics/base_count,Bioinformatics/base count,"Given this string representing ordered DNA bases:

CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG
CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG
AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT
GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT
CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG
TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA
TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT
CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG
TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC
GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT



Task

   ""Pretty print"" the sequence followed by a summary of the counts of each of the bases:   (A, C, G, and T)   in the sequence 
   print the total count of each base in the string.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
func main() {
    dna := """" +
        ""CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG"" +
        ""CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG"" +
        ""AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT"" +
        ""GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT"" +
        ""CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG"" +
        ""TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA"" +
        ""TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT"" +
        ""CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG"" +
        ""TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC"" +
        ""GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT""
 
    fmt.Println(""SEQUENCE:"")
    le := len(dna)
    for i := 0; i < le; i += 50 {
        k := i + 50
        if k > le {
            k = le
        }
        fmt.Printf(""%5d: %s\n"", i, dna[i:k])
    }
    baseMap := make(map[byte]int) // allows for 'any' base
    for i := 0; i < le; i++ {
        baseMap[dna[i]]++
    }
    var bases []byte
    for k := range baseMap {
        bases = append(bases, k)
    }
    sort.Slice(bases, func(i, j int) bool { // get bases into alphabetic order
        return bases[i] < bases[j]
    })
 
    fmt.Println(""\nBASE COUNT:"")
    for _, base := range bases {
        fmt.Printf(""    %c: %3d\n"", base, baseMap[base])
    }
    fmt.Println(""    ------"")
    fmt.Println(""    Σ:"", le)
    fmt.Println(""    ======"")
}",1464,49
72118,http://rosettacode.org/wiki/Bin_given_limits,Bin given limits,"You are given a list of n ascending, unique numbers which are to form limits
for n+1 bins which count how many of a large set of input numbers fall in the
range of each bin.

(Assuming zero-based indexing)

   bin[0] counts how many inputs are < limit[0]
   bin[1] counts how many inputs are >= limit[0] and < limit[1]
   ..
   bin[n-1] counts how many inputs are >= limit[n-2] and < limit[n-1]
   bin[n] counts how many inputs are >= limit[n-1]

Task

The task is to create a function that given the ascending limits and a stream/
list of numbers, will return the bins; together with another function that
given the same list of limits and the binning will print the limit of each bin
together with the count of items that fell in the range.

Assume the numbers to bin are too large to practically sort.

Task examples

Part 1: Bin using the following limits the given input data

   limits  = [23, 37, 43, 53, 67, 83]
   data = [95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,
           16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55]

Part 2: Bin using the following limits the given input data

   limits = [14, 18, 249, 312, 389, 392, 513, 591, 634, 720]
   data = [445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,
           416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,
           655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,
           346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,
           345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,
           854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,
           787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,
           698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,
           605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,
           466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749]

Show output here, on this page.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
func getBins(limits, data []int) []int {
    n := len(limits)
    bins := make([]int, n+1)
    for _, d := range data {
        index := sort.SearchInts(limits, d) // uses binary search
        if index < len(limits) && d == limits[index] {
            index++
        }
        bins[index]++
    }
    return bins
}
 
func printBins(limits, bins []int) {
    n := len(limits)
    fmt.Printf(""           < %3d = %2d\n"", limits[0], bins[0])
    for i := 1; i < n; i++ {
        fmt.Printf("">= %3d and < %3d = %2d\n"", limits[i-1], limits[i], bins[i])
    }
    fmt.Printf("">= %3d           = %2d\n"", limits[n-1], bins[n])
    fmt.Println()
}
 
func main() {
    limitsList := [][]int{
        {23, 37, 43, 53, 67, 83},
        {14, 18, 249, 312, 389, 392, 513, 591, 634, 720},
    }
 
    dataList := [][]int{
        {
            95, 21, 94, 12, 99, 4, 70, 75, 83, 93, 52, 80, 57, 5, 53, 86, 65, 17, 92, 83, 71, 61, 54, 58, 47,
            16,  8,  9, 32, 84, 7, 87, 46, 19, 30, 37, 96, 6, 98, 40, 79, 97, 45, 64, 60, 29, 49, 36, 43, 55,
        },
        {
            445, 814, 519, 697, 700, 130, 255, 889, 481, 122, 932,  77, 323, 525, 570, 219, 367, 523, 442, 933,
            416, 589, 930, 373, 202, 253, 775,  47, 731, 685, 293, 126, 133, 450, 545, 100, 741, 583, 763, 306,
            655, 267, 248, 477, 549, 238,  62, 678,  98, 534, 622, 907, 406, 714, 184, 391, 913,  42, 560, 247,
            346, 860,  56, 138, 546,  38, 985, 948,  58, 213, 799, 319, 390, 634, 458, 945, 733, 507, 916, 123,
            345, 110, 720, 917, 313, 845, 426,   9, 457, 628, 410, 723, 354, 895, 881, 953, 677, 137, 397,  97,
            854, 740,  83, 216, 421,  94, 517, 479, 292, 963, 376, 981, 480,  39, 257, 272, 157,   5, 316, 395,
            787, 942, 456, 242, 759, 898, 576,  67, 298, 425, 894, 435, 831, 241, 989, 614, 987, 770, 384, 692,
            698, 765, 331, 487, 251, 600, 879, 342, 982, 527, 736, 795, 585,  40,  54, 901, 408, 359, 577, 237,
            605, 847, 353, 968, 832, 205, 838, 427, 876, 959, 686, 646, 835, 127, 621, 892, 443, 198, 988, 791,
            466,  23, 707, 467,  33, 670, 921, 180, 991, 396, 160, 436, 717, 918,   8, 374, 101, 684, 727, 749,
        },
    }
 
    for i := 0; i < len(limitsList); i++ {
        fmt.Println(""Example"", i+1, ""\b\n"")
        bins := getBins(limitsList[i], dataList[i])
        printBins(limitsList[i], bins)
    }
}",2432,61
72265,http://rosettacode.org/wiki/Binary_strings,Binary strings,"Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.

This task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them.

If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.

In particular the functions you need to create are:

 String creation and destruction (when needed and if there's no garbage collection or similar mechanism)
 String assignment
 String comparison
 String cloning and copying
 Check if a string is empty
 Append a byte to a string
 Extract a substring from a string
 Replace every occurrence of a byte (or a string) in a string with another string
 Join strings


Possible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.



",#Go,Go,"package main
 
import (
    ""bytes""
    ""fmt""
)
 
// Strings in Go allow arbitrary bytes.  They are implemented basically as
// immutable byte slices and syntactic sugar.  This program shows functions
// required by the task on byte slices, thus it mostly highlights what
// happens behind the syntactic sugar.  The program does not attempt to
// reproduce the immutability property of strings, as that does not seem
// to be the intent of the task.
 
func main() {
    // Task point: String creation and destruction.
    // Strings are most often constructed from literals as in s := ""binary""
    // With byte slices,
    b := []byte{'b', 'i', 'n', 'a', 'r', 'y'}
    fmt.Println(b) // output shows numeric form of bytes.
    // Go is garbage collected.  There are no destruction operations.
 
    // Task point: String assignment.
    // t = s assigns strings.  Since strings are immutable, it is irrelevant
    // whether the string is copied or not.
    // With byte slices, the same works,
    var c []byte
    c = b
    fmt.Println(c)
 
    // Task point: String comparison.
    // operators <, <=, ==, >=, and > work directly on strings comparing them
    // by lexicographic order.
    // With byte slices, there are standard library functions, bytes.Equal
    // and bytes.Compare.
    fmt.Println(bytes.Equal(b, c)) // prints true
 
    // Task point: String cloning and copying.
    // The immutable property of Go strings makes cloning and copying
    // meaningless for strings.
    // With byte slices though, it is relevant.  The assignment c = b shown
    // above does a reference copy, leaving both c and b based on the same
    // underlying data.  To clone or copy the underlying data,
    d := make([]byte, len(b)) // allocate new space
    copy(d, b)                // copy the data
    // The data can be manipulated independently now:
    d[1] = 'a'
    d[4] = 'n'
    fmt.Println(string(b)) // convert to string for readable output
    fmt.Println(string(d))
 
    // Task point: Check if a string is empty.
    // Most typical for strings is s == """", but len(s) == 0 works too.
    // For byte slices, """" does not work, len(b) == 0 is correct.
    fmt.Println(len(b) == 0)
 
    // Task point: Append a byte to a string.
    // The language does not provide a way to do this directly with strings.
    // Instead, the byte must be converted to a one-byte string first, as in,
    // s += string('z')
    // For byte slices, the language provides the append function,
    z := append(b, 'z')
    fmt.Printf(""%s\n"", z) // another way to get readable output
 
    // Task point: Extract a substring from a string.
    // Slicing syntax is the for both strings and slices.
    sub := b[1:3]
    fmt.Println(string(sub))
 
    // Task point: Replace every occurrence of a byte (or a string)
    // in a string with another string.
    // Go supports this with similar library functions for strings and
    // byte slices.  Strings:  t = strings.Replace(s, ""n"", ""m"", -1).
    // The byte slice equivalent returns a modified copy, leaving the
    // original byte slice untouched,
    f := bytes.Replace(d, []byte{'n'}, []byte{'m'}, -1)
    fmt.Printf(""%s -> %s\n"", d, f)
 
    // Task point: Join strings.
    // Using slicing syntax again, with strings,
    // rem := s[:1] + s[3:] leaves rem == ""bary"".
    // Only the concatenation of the parts is different with byte slices,
    rem := append(append([]byte{}, b[:1]...), b[3:]...)
    fmt.Println(string(rem))
}",3485,85
72276,http://rosettacode.org/wiki/Bell_numbers,Bell numbers,"Bell or exponential numbers are enumerations of the number of different ways to partition a set that has exactly n elements. Each element of the sequence Bn is the number of partitions of a set of size n where order of the elements and order of the partitions are non-significant. E.G.: {a b} is the same as {b a} and {a} {b} is the same as {b} {a}.



So

B0 = 1 trivially. There is only one way to partition a set with zero elements. { }
B1 = 1 There is only one way to partition a set with one element. {a}
B2 = 2 Two elements may be partitioned in two ways. {a} {b}, {a b}
B3 = 5 Three elements may be partitioned in five ways {a} {b} {c}, {a b} {c}, {a} {b c}, {a c} {b}, {a b c}
 and so on.


A simple way to find the Bell numbers is construct a Bell triangle, also known as an Aitken's array or Peirce triangle, and read off the numbers in the first column of each row. There are other generating algorithms though, and you are free to choose the best / most appropriate for your case.



Task

Write a routine (function, generator, whatever) to generate the Bell number sequence and call the routine to show here, on this page at least the first 15 and (if your language supports big Integers) 50th elements of the sequence.

If you do use the Bell triangle method to generate the numbers, also show the first ten rows of the Bell triangle.



See also

 OEIS:A000110 Bell or exponential numbers
 OEIS:A011971 Aitken's array",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func bellTriangle(n int) [][]*big.Int {
    tri := make([][]*big.Int, n)
    for i := 0; i < n; i++ {
        tri[i] = make([]*big.Int, i)
        for j := 0; j < i; j++ {
            tri[i][j] = new(big.Int)
        }
    }
    tri[1][0].SetUint64(1)
    for i := 2; i < n; i++ {
        tri[i][0].Set(tri[i-1][i-2])
        for j := 1; j < i; j++ {
            tri[i][j].Add(tri[i][j-1], tri[i-1][j-1])
        }
    }
    return tri
}
 
func main() {
    bt := bellTriangle(51)
    fmt.Println(""First fifteen and fiftieth Bell numbers:"")
    for i := 1; i <= 15; i++ {
        fmt.Printf(""%2d: %d\n"", i, bt[i][0])
    }
    fmt.Println(""50:"", bt[50][0])
    fmt.Println(""\nThe first ten rows of Bell's triangle:"")
    for i := 1; i <= 10; i++ {
        fmt.Println(bt[i])
    }    
}",839,37
72304,http://rosettacode.org/wiki/Bitmap/Bresenham%27s_line_algorithm,Bitmap/Bresenham's line algorithm,"Task

Using the data storage type defined on the Bitmap page for raster graphics images,

draw a line given two points with Bresenham's line algorithm.



",#Go,Go,"package raster
 
// Line draws line by Bresenham's algorithm.
func (b *Bitmap) Line(x0, y0, x1, y1 int, p Pixel) {
    // implemented straight from WP pseudocode
    dx := x1 - x0
    if dx < 0 {
        dx = -dx
    }
    dy := y1 - y0
    if dy < 0 {
        dy = -dy
    }
    var sx, sy int
    if x0 < x1 {
        sx = 1
    } else {
        sx = -1
    }
    if y0 < y1 {
        sy = 1
    } else {
        sy = -1
    }
    err := dx - dy
 
    for {
        b.SetPx(x0, y0, p)
        if x0 == x1 && y0 == y1 {
            break
        }
        e2 := 2 * err
        if e2 > -dy {
            err -= dy
            x0 += sx
        }
        if e2 < dx {
            err += dx
            y0 += sy
        }
    }
}
 
func (b *Bitmap) LineRgb(x0, y0, x1, y1 int, c Rgb) {
    b.Line(x0, y0, x1, y1, c.Pixel())
}",823,46
72346,http://rosettacode.org/wiki/Bitmap,Bitmap,"Show a basic storage type to handle a simple RGB raster graphics image,
and some primitive associated functions.

If possible provide a function to allocate an uninitialised image,
given its width and height, and provide 3 additional functions:

   one to fill an image with a plain RGB color,
   one to set a given pixel with a color,
   one to get the color of a pixel.


(If there are specificities about the storage or the allocation, explain those.)

These functions are used as a base for the articles in the category raster graphics operations, 
and a basic output function to check the results
is available in the article write ppm file.



",#Go,Go,"package main
 
import (
	""bytes""
	""fmt""
	""image""
	""image/color""
	""image/draw""
	""image/png""
)
 
func main() {
	// A rectangle from 0,0 to 300,240.
	r := image.Rect(0, 0, 300, 240)
 
	// Create an image
	im := image.NewNRGBA(r)
 
	// set some color variables for convience
	var (
		red  = color.RGBA{0xff, 0x00, 0x00, 0xff}
		blue = color.RGBA{0x00, 0x00, 0xff, 0xff}
	)
 
	// Fill with a uniform color
	draw.Draw(im, r, &image.Uniform{red}, image.ZP, draw.Src)
 
	// Set individual pixels
	im.Set(10, 20, blue)
	im.Set(20, 30, color.Black)
	im.Set(30, 40, color.RGBA{0x10, 0x20, 0x30, 0xff})
 
	// Get the values of specific pixels as color.Color types.
	// The color will be in the color.Model of the image (in this
	// case color.NRGBA) but color models can convert their values
	// to other models.
	c1 := im.At(0, 0)
	c2 := im.At(10, 20)
 
	// or directly as RGB components (scaled values)
	redc, greenc, bluec, _ := c1.RGBA()
	redc, greenc, bluec, _ = im.At(30, 40).RGBA()
 
	// Images can be read and writen in various formats
	var buf bytes.Buffer
	err := png.Encode(&buf, im)
	if err != nil {
		fmt.Println(err)
	}
 
	fmt.Println(""Image size:"", im.Bounds().Dx(), ""×"", im.Bounds().Dy())
	fmt.Println(buf.Len(), ""bytes when encoded as PNG."")
	fmt.Printf(""Pixel at %7v is %v\n"", image.Pt(0, 0), c1)
	fmt.Printf(""Pixel at %7v is %#v\n"", image.Pt(10, 20), c2) // %#v shows type details
	fmt.Printf(""Pixel at %7v has R=%d, G=%d, B=%d\n"",
		image.Pt(30, 40), redc, greenc, bluec)
}",1481,57
72386,http://rosettacode.org/wiki/Benford%27s_law,Benford's law,"

 This page uses content from Wikipedia. The original article was at Benford's_law. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Benford's law, also called the first-digit law, refers to the frequency distribution of digits in many (but not all) real-life sources of data.

In this distribution, the number 1 occurs as the first digit about 30% of the time, while larger numbers occur in that position less frequently: 9 as the first digit less than 5% of the time. This distribution of first digits is the same as the widths of gridlines on a logarithmic scale.

Benford's law also concerns the expected distribution for digits beyond the first, which approach a uniform distribution.

This result has been found to apply to a wide variety of data sets, including electricity bills, street addresses, stock prices, population numbers, death rates, lengths of rivers, physical and mathematical constants, and processes described by power laws (which are very common in nature). It tends to be most accurate when values are distributed across multiple orders of magnitude.

A set of numbers is said to satisfy Benford's law if the leading digit 



d


{\displaystyle d}

  (



d
∈
{
1
,
…
,
9
}


{\displaystyle d\in \{1,\ldots ,9\}}

) occurs with probability

 



P
(
d
)
=

log

10


⁡
(
d
+
1
)
−

log

10


⁡
(
d
)
=

log

10


⁡

(
1
+


1
d


)



{\displaystyle P(d)=\log _{10}(d+1)-\log _{10}(d)=\log _{10}\left(1+{\frac {1}{d}}\right)}


For this task, write (a) routine(s) to calculate the distribution of first significant (non-zero) digits in a collection of numbers, then display the actual vs. expected distribution in the way most convenient for your language (table / graph / histogram / whatever).

Use the first 1000 numbers from the Fibonacci sequence as your data set. No need to show how the Fibonacci numbers are obtained.

You can generate them or load them from a file; whichever is easiest.

Display your actual vs expected distribution.


For extra credit: Show the distribution for one other set of numbers from a page on Wikipedia. State which Wikipedia page it can be obtained from and what the set enumerates. Again, no need to display the actual list of numbers or the code to load them.



See also:
 numberphile.com.
 A starting page on Wolfram Mathworld is Benfords Law .

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func Fib1000() []float64 {
    a, b, r := 0., 1., [1000]float64{}
    for i := range r {
        r[i], a, b = b, b, b+a
    }
    return r[:]
}
 
func main() {
    show(Fib1000(), ""First 1000 Fibonacci numbers"")
}
 
func show(c []float64, title string) {
    var f [9]int
    for _, v := range c {
        f[fmt.Sprintf(""%g"", v)[0]-'1']++
    }
    fmt.Println(title)
    fmt.Println(""Digit  Observed  Predicted"")
    for i, n := range f {
        fmt.Printf(""  %d  %9.3f  %8.3f\n"", i+1, float64(n)/float64(len(c)),
            math.Log10(1+1/float64(i+1)))
    }
}",614,31
72409,http://rosettacode.org/wiki/Best_shuffle,Best shuffle,"Task

Shuffle the characters of a string in such a way that as many of the character values are in a different position as possible.

A shuffle that produces a randomized result among the best choices is to be preferred. A deterministic approach that produces the same sequence every time is acceptable as an alternative.

Display the result as follows:

original string, shuffled string, (score) 

The score gives the number of positions whose character value did not change.



Example

tree, eetr, (0)



Test cases

abracadabra
seesaw
elk
grrrrrr
up
a



Related tasks
   Anagrams/Deranged anagrams
   Permutations/Derangements



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
var ts = []string{""abracadabra"", ""seesaw"", ""elk"", ""grrrrrr"", ""up"", ""a""}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    for _, s := range ts {
        // create shuffled byte array of original string
        t := make([]byte, len(s))
        for i, r := range rand.Perm(len(s)) {
            t[i] = s[r]
        }
        // algorithm of Icon solution
        for i := range t {
            for j := range t {
                if i != j && t[i] != s[j] && t[j] != s[i] {
                    t[i], t[j] = t[j], t[i]
                    break
                }
            }
        }
        // count unchanged and output
        var count int
        for i, ic := range t {
            if ic == s[i] {
                count++
            }
        }
        fmt.Printf(""%s -> %s (%d)\n"", s, string(t), count)
    }
}",889,37
72435,http://rosettacode.org/wiki/Bitwise_operations,Bitwise operations,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses




Task

Write a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.

All shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.

If any operation is not available in your language, note it.



",#Go,Go,"package main
 
import ""fmt""
 
func bitwise(a, b int16) {
	fmt.Printf(""a:   %016b\n"", uint16(a))
	fmt.Printf(""b:   %016b\n"", uint16(b))
 
	// Bitwise logical operations
	fmt.Printf(""and: %016b\n"", uint16(a&b))
	fmt.Printf(""or:  %016b\n"", uint16(a|b))
	fmt.Printf(""xor: %016b\n"", uint16(a^b))
	fmt.Printf(""not: %016b\n"", uint16(^a))
 
	if b < 0 {
		fmt.Println(""Right operand is negative, but all shifts require an unsigned right operand (shift distance)."")
		return
	}
	ua := uint16(a)
	ub := uint32(b)
 
	// Logical shifts (unsigned left operand)
	fmt.Printf(""shl: %016b\n"", uint16(ua<<ub))
	fmt.Printf(""shr: %016b\n"", uint16(ua>>ub))
 
	// Arithmetic shifts (signed left operand)
	fmt.Printf(""las: %016b\n"", uint16(a<<ub))
	fmt.Printf(""ras: %016b\n"", uint16(a>>ub))
 
	// Rotations
	fmt.Printf(""rol: %016b\n"", uint16(a<<ub|int16(uint16(a)>>(16-ub))))
	fmt.Printf(""ror: %016b\n"", uint16(int16(uint16(a)>>ub)|a<<(16-ub)))
}
 
func main() {
	var a, b int16 = -460, 6
	bitwise(a, b)
}",981,38
72469,http://rosettacode.org/wiki/Bernoulli_numbers,Bernoulli numbers,"Bernoulli numbers are used in some series expansions of several functions   (trigonometric, hyperbolic, gamma, etc.),   and are extremely important in number theory and analysis.

Note that there are two definitions of Bernoulli numbers;   this task will be using the modern usage   (as per   The National Institute of Standards and Technology convention).

The   nth   Bernoulli number is expressed as   Bn.



Task
   show the Bernoulli numbers   B0   through   B60.
   suppress the output of values which are equal to zero.   (Other than   B1 , all   odd   Bernoulli numbers have a value of zero.)
   express the Bernoulli numbers as fractions  (most are improper fractions).
   the fractions should be reduced.
   index each number in some way so that it can be discerned which Bernoulli number is being displayed.
   align the solidi   (/)   if used  (extra credit).


An algorithm
The Akiyama–Tanigawa algorithm for the ""second Bernoulli numbers"" as taken from wikipedia is as follows:

 for m from 0 by 1 to n do
    A[m] ← 1/(m+1)
    for j from m by -1 to 1 do
      A[j-1] ← j×(A[j-1] - A[j])
  return A[0] (which is Bn)

See also
 Sequence A027641 Numerator of Bernoulli number B_n on The On-Line Encyclopedia of Integer Sequences.
 Sequence A027642 Denominator of Bernoulli number B_n on The On-Line Encyclopedia of Integer Sequences.
 Entry Bernoulli number on The Eric Weisstein's World of Mathematics (TM).
 Luschny's The Bernoulli Manifesto for a discussion on    B1   =   -½   versus   +½. 

",#Go,Go,"package main
 
import (
	""fmt""
	""math/big""
)
 
func b(n int) *big.Rat {
	var f big.Rat
	a := make([]big.Rat, n+1)
	for m := range a {
		a[m].SetFrac64(1, int64(m+1))
		for j := m; j >= 1; j-- {
			d := &a[j-1]
			d.Mul(f.SetInt64(int64(j)), d.Sub(d, &a[j]))
		}
	}
	return f.Set(&a[0])
}
 
func main() {
	for n := 0; n <= 60; n++ {
		if b := b(n); b.Num().BitLen() > 0 {
			fmt.Printf(""B(%2d) =%45s/%s\n"", n, b.Num(), b.Denom())
		}
	}
}",437,27
72804,http://rosettacode.org/wiki/Binary_search,Binary search,"A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a ""divide and conquer"" algorithm.

As an analogy, consider the children's game ""guess a number."" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.

As the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.



Task

Given the starting point of a range, the ending point of a range, and the ""secret value"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.

There are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.

All of the following code examples use an ""inclusive"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using ""exclusive"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):

 change high = N-1 to high = N
 change high = mid-1 to high = mid
 (for recursive algorithm) change if (high < low) to if (high <= low)
 (for iterative algorithm) change while (low <= high) to while (low < high)
Traditional algorithm
The algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the ""insertion point"" for it (the index that the value would have if it were inserted into the array).

Recursive Pseudocode:

  // initially called with low = 0, high = N-1
  BinarySearch(A[0..N-1], value, low, high) {
      // invariants: value > A[i] for all i < low
                     value < A[i] for all i > high
      if (high < low)
          return not_found // value would be inserted at index ""low""
      mid = (low + high) / 2
      if (A[mid] > value)
          return BinarySearch(A, value, low, mid-1)
      else if (A[mid] < value)
          return BinarySearch(A, value, mid+1, high)
      else
          return mid
  }

Iterative Pseudocode:

  BinarySearch(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value > A[i] for all i < low
                         value < A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] > value)
              high = mid - 1
          else if (A[mid] < value)
              low = mid + 1
          else
              return mid
      }
      return not_found // value would be inserted at index ""low""
  }

Leftmost insertion point
The following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.

Recursive Pseudocode:

  // initially called with low = 0, high = N - 1
  BinarySearch_Left(A[0..N-1], value, low, high) {
      // invariants: value > A[i] for all i < low
                     value <= A[i] for all i > high
      if (high < low)
          return low
      mid = (low + high) / 2
      if (A[mid] >= value)
          return BinarySearch_Left(A, value, low, mid-1)
      else
          return BinarySearch_Left(A, value, mid+1, high)
  }

Iterative Pseudocode:

  BinarySearch_Left(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value > A[i] for all i < low
                         value <= A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] >= value)
              high = mid - 1
          else
              low = mid + 1
      }
      return low
  }

Rightmost insertion point
The following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.

Recursive Pseudocode:

  // initially called with low = 0, high = N - 1
  BinarySearch_Right(A[0..N-1], value, low, high) {
      // invariants: value >= A[i] for all i < low
                     value < A[i] for all i > high
      if (high < low)
          return low
      mid = (low + high) / 2
      if (A[mid] > value)
          return BinarySearch_Right(A, value, low, mid-1)
      else
          return BinarySearch_Right(A, value, mid+1, high)
  }

Iterative Pseudocode:

  BinarySearch_Right(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value >= A[i] for all i < low
                         value < A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] > value)
              high = mid - 1
          else
              low = mid + 1
      }
      return low
  }

Extra credit
Make sure it does not have overflow bugs.

The line in the pseudo-code above to calculate the mean of two integers:

mid = (low + high) / 2
could produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.

One way to fix it is to manually add half the range to the low number:

mid = low + (high - low) / 2
Even though this is mathematically equivalent to the above, it is not susceptible to overflow.

Another way for signed integers, possibly faster, is the following:

mid = (low + high) >>> 1
where  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.



Related task

 Guess the number/With Feedback (Player)


See also

 wp:Binary search algorithm
 Extra, Extra - Read All About It: Nearly All Binary Searches and Mergesorts are Broken.

",#Go,Go,"func binarySearch(a []float64, value float64, low int, high int) int {
    if high < low {
        return -1
    }
    mid := (low + high) / 2
    if a[mid] > value {
        return binarySearch(a, value, low, mid-1)
    } else if a[mid] < value {
        return binarySearch(a, value, mid+1, high)
    }
    return mid
}",321,12
72920,http://rosettacode.org/wiki/Binary_digits,Binary digits,"Task

Create and display the sequence of binary digits for a given   non-negative integer.

   The decimal value      5   should produce an output of               101
   The decimal value     50   should produce an output of            110010
   The decimal value   9000   should produce an output of    10001100101000

The results can be achieved using built-in radix functions within the language   (if these are available),   or alternatively a user defined function can be used.

The output produced should consist just of the binary digits of each number followed by a   newline.

There should be no other whitespace, radix or sign markers in the produced output, and leading zeros should not appear in the results.



",#Go,Go,"package main
 
import (
	""fmt""
)
 
func main() {
	for i := 0; i < 16; i++ {
		fmt.Printf(""%b\n"", i)
	}
}",104,11
73146,http://rosettacode.org/wiki/Base64_decode_data,Base64 decode data,"See Base64 encode data.

Now write a program that takes the output of the Base64 encode data task as input and regenerate the original file.

When working on the VBA implementation I found several 'solutions' on the net, including one from the software maker himself, that showed output with incorrect padding. Obviously with incorrect padding in the output you can not decode correctly to the original file again.
",#Go,Go,"package main
 
import (
    ""encoding/base64""
    ""fmt""
)
 
func main() {
    msg := ""Rosetta Code Base64 decode data task""
    fmt.Println(""Original :"", msg)
    encoded := base64.StdEncoding.EncodeToString([]byte(msg))
    fmt.Println(""\nEncoded  :"", encoded)
    decoded, err := base64.StdEncoding.DecodeString(encoded)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(""\nDecoded  :"", string(decoded))
}",439,19
73251,http://rosettacode.org/wiki/Averages/Root_mean_square,Averages/Root mean square,"Task[edit]
Compute the   Root mean square   of the numbers 1..10.



The   root mean square   is also known by its initials RMS (or rms), and as the quadratic mean.

The RMS is calculated as the mean of the squares of the numbers, square-rooted:



 




x


r
m
s



=







x

1




2


+



x

2




2


+
⋯
+



x

n




2



n



.


{\displaystyle x_{\mathrm {rms} }={\sqrt {{{x_{1}}^{2}+{x_{2}}^{2}+\cdots +{x_{n}}^{2}} \over n}}.}




See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func main() {
    const n = 10
    sum := 0.
    for x := 1.; x <= n; x++ {
        sum += x * x
    }
    fmt.Println(math.Sqrt(sum / n))
}",189,15
73284,http://rosettacode.org/wiki/Barnsley_fern,Barnsley fern,"
A Barnsley fern is a fractal named after British mathematician Michael Barnsley and can be created using an iterated function system (IFS).



Task

Create this fractal fern, using the following transformations:

 ƒ1   (chosen 1% of the time)
        xn + 1 = 0
        yn + 1 = 0.16 yn

 ƒ2   (chosen 85% of the time)
        xn + 1 = 0.85 xn + 0.04 yn
        yn + 1 = −0.04 xn + 0.85 yn + 1.6

 ƒ3   (chosen 7% of the time)
        xn + 1 = 0.2 xn − 0.26 yn
        yn + 1 = 0.23 xn + 0.22 yn + 1.6

 ƒ4   (chosen 7% of the time)
        xn + 1 = −0.15 xn + 0.28 yn
        yn + 1 = 0.26 xn + 0.24 yn + 0.44.

Starting position: x = 0, y = 0



",#Go,Go,"package main
 
import (
    ""image""
    ""image/color""
    ""image/draw""
    ""image/png""
    ""log""
    ""math/rand""
    ""os""
)
 
// values from WP
const (
    xMin = -2.1820
    xMax = 2.6558
    yMin = 0.
    yMax = 9.9983
)
 
// parameters
var (
    width = 200
    n     = int(1e6)
    c     = color.RGBA{34, 139, 34, 255} // forest green
)
 
func main() {
    dx := xMax - xMin
    dy := yMax - yMin
    fw := float64(width)
    fh := fw * dy / dx
    height := int(fh)
    r := image.Rect(0, 0, width, height)
    img := image.NewRGBA(r)
    draw.Draw(img, r, &image.Uniform{color.White}, image.ZP, draw.Src)
    var x, y float64
    plot := func() {
        // transform computed float x, y to integer image coordinates
        ix := int(fw * (x - xMin) / dx)
        iy := int(fh * (yMax - y) / dy)
        img.SetRGBA(ix, iy, c)
    }
    plot()
    for i := 0; i < n; i++ {
        switch s := rand.Intn(100); {
        case s < 85:
            x, y =
                .85*x+.04*y,
                -.04*x+.85*y+1.6
        case s < 85+7:
            x, y =
                .2*x-.26*y,
                .23*x+.22*y+1.6
        case s < 85+7+7:
            x, y =
                -.15*x+.28*y,
                .26*x+.24*y+.44
        default:
            x, y = 0, .16*y
        }
        plot()
    }
    // write img to png file
    f, err := os.Create(""bf.png"")
    if err != nil {
        log.Fatal(err)
    }
    if err := png.Encode(f, img); err != nil {
        log.Fatal(err)
    }
}",1493,72
73413,http://rosettacode.org/wiki/Averages/Simple_moving_average,Averages/Simple moving average,"Computing the simple moving average of a series of numbers.

Task[edit]
Create a stateful function/class/instance that takes a period and returns a routine that takes a number as argument and returns a simple moving average of its arguments so far.

Description
A simple moving average is a method for computing an average of a stream of numbers by only averaging the last   P   numbers from the stream,   where   P   is known as the period.

It can be implemented by calling an initialing routine with   P   as its argument,   I(P),   which should then return a routine that when called with individual, successive members of a stream of numbers, computes the mean of (up to), the last   P   of them, lets call this   SMA().

The word   stateful   in the task description refers to the need for   SMA()   to remember certain information between calls to it:

   The period,   P
   An ordered container of at least the last   P   numbers from each of its individual calls.

Stateful   also means that successive calls to   I(),   the initializer,   should return separate routines that do   not   share saved state so they could be used on two independent streams of data.

Pseudo-code for an implementation of   SMA   is:

function SMA(number: N):
    stateful integer: P
    stateful list:    stream
    number:           average

    stream.append_last(N)
    if stream.length() > P:
        # Only average the last P elements of the stream
        stream.delete_first()
    if stream.length() == 0:
        average = 0
    else:    
        average = sum( stream.values() ) / stream.length()
    return average

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",#Go,Go,"package main
 
import ""fmt""
 
func sma(period int) func(float64) float64 {
    var i int
    var sum float64
    var storage = make([]float64, 0, period)
 
    return func(input float64) (avrg float64) {
        if len(storage) < period {
            sum += input
            storage = append(storage, input)
        }
 
	sum += input - storage[i]
        storage[i], i = input, (i+1)%period
	avrg = sum / float64(len(storage))
 
	return
    }
}
 
func main() {
    sma3 := sma(3)
    sma5 := sma(5)
    fmt.Println(""x       sma3   sma5"")
    for _, x := range []float64{1, 2, 3, 4, 5, 5, 4, 3, 2, 1} {
        fmt.Printf(""%5.3f  %5.3f  %5.3f\n"", x, sma3(x), sma5(x))
    }
}",675,31
73509,http://rosettacode.org/wiki/Babbage_problem,Babbage problem,"

Charles Babbage, looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:

 What is the smallest positive integer whose square ends in the digits 269,696?

— Babbage, letter to Lord Bowden, 1837; see Hollingdale and Tootill, Electronic Computers, second edition, 1970, p. 125.

He thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.



Task[edit]
The task is to find out if Babbage had the right answer — and to do so, as far as your language allows it, in code that Babbage himself would have been able to read and understand.
As Babbage evidently solved the task with pencil and paper, a similar efficient solution is preferred.

For these purposes, Charles Babbage may be taken to be an intelligent person, familiar with mathematics and with the idea of a computer; he has written the first drafts of simple computer programmes in tabular form. [Babbage Archive Series L].



Motivation
The aim of the task is to write a program that is sufficiently clear and well-documented for such a person to be able to read it and be confident that it does indeed solve the specified problem.



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
	const (
		target  = 269696
		modulus = 1000000
	)
	for n := 1; ; n++ { // Repeat with n=1, n=2, n=3, ...
		square := n * n
		ending := square % modulus
		if ending == target {
			fmt.Println(""The smallest number whose square ends with"",
				target, ""is"", n,
			)
			return
		}
	}
}",326,20
73682,http://rosettacode.org/wiki/Balanced_ternary,Balanced ternary,"Balanced ternary is a way of representing numbers. Unlike the prevailing binary representation, a balanced ternary integer is in base 3, and each digit can have the values 1, 0, or −1.



Examples

Decimal 11 = 32 + 31 − 30, thus it can be written as ""++−""

Decimal 6 = 32 − 31 + 0 × 30, thus it can be written as ""+−0""



Task

Implement balanced ternary representation of integers with the following:

 Support arbitrarily large integers, both positive and negative;
 Provide ways to convert to and from text strings, using digits '+', '-' and '0' (unless you are already using strings to represent balanced ternary; but see requirement 5).
 Provide ways to convert to and from native integer type (unless, improbably, your platform's native integer type is balanced ternary). If your native integers can't support arbitrary length, overflows during conversion must be indicated.
 Provide ways to perform addition, negation and multiplication directly on balanced ternary integers; do not convert to native integers first.
 Make your implementation efficient, with a reasonable definition of ""efficient"" (and with a reasonable definition of ""reasonable"").

Test case With balanced ternaries a from string ""+-0++0+"", b from native integer -436, c ""+-++-"":

 write out a, b and c in decimal notation;
 calculate a × (b − c), write out the result in both ternary and decimal notations.

Note: The pages generalised floating point addition and generalised floating point multiplication have code implementing arbitrary precision floating point balanced ternary.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
// R1: representation is a slice of int8 digits of -1, 0, or 1.
// digit at index 0 is least significant.  zero value of type is
// representation of the number 0.
type bt []int8
 
// R2: string conversion:
 
// btString is a constructor.  valid input is a string of any length
// consisting of only '+', '-', and '0' characters.
// leading zeros are allowed but are trimmed and not represented.
// false return means input was invalid.
func btString(s string) (*bt, bool) {
    s = strings.TrimLeft(s, ""0"")
    b := make(bt, len(s))
    for i, last := 0, len(s)-1; i < len(s); i++ {
        switch s[i] {
        case '-':
            b[last-i] = -1
        case '0':
            b[last-i] = 0
        case '+':
            b[last-i] = 1
        default:
            return nil, false
        }
    }
    return &b, true
}
 
// String method converts the other direction, returning a string of
// '+', '-', and '0' characters representing the number.
func (b bt) String() string {
    if len(b) == 0 {
        return ""0""
    }
    last := len(b) - 1
    r := make([]byte, len(b))
    for i, d := range b {
        r[last-i] = ""-0+""[d+1]
    }
    return string(r)
}
 
// R3: integer conversion
// int chosen as ""native integer""
 
// btInt is a constructor like btString.
func btInt(i int) *bt {
    if i == 0 {
        return new(bt)
    }
    var b bt
    var btDigit func(int)
    btDigit = func(digit int) {
        m := int8(i % 3)
        i /= 3
        switch m {
        case 2:
            m = -1
            i++
        case -2:
            m = 1
            i--
        }
        if i == 0 {
            b = make(bt, digit+1)
        } else {
            btDigit(digit + 1)
        }
        b[digit] = m
    }
    btDigit(0)
    return &b
}
 
// Int method converts the other way, returning the value as an int type.
// !ok means overflow occurred during conversion, not necessarily that the
// value is not representable as an int.  (Of course there are other ways
// of doing it but this was chosen as ""reasonable."")
func (b bt) Int() (r int, ok bool) {
    pt := 1
    for _, d := range b {
        dp := int(d) * pt
        neg := r < 0
        r += dp
        if neg {
            if r > dp {
                return 0, false
            }
        } else {
            if r < dp {
                return 0, false
            }
        }
        pt *= 3
    }
    return r, true
}
 
// R4: negation, addition, and multiplication
 
func (z *bt) Neg(b *bt) *bt {
    if z != b {
        if cap(*z) < len(*b) {
            *z = make(bt, len(*b))
        } else {
            *z = (*z)[:len(*b)]
        } 
    }
    for i, d := range *b {
        (*z)[i] = -d
    }
    return z 
}
 
func (z *bt) Add(a, b *bt) *bt {
    if len(*a) < len(*b) {
        a, b = b, a
    }
    r := *z
    r = r[:cap(r)]
    var carry int8 
    for i, da := range *a {
        if i == len(r) {
            n := make(bt, len(*a)+4)
            copy(n, r)
            r = n
        }
        sum := da + carry
        if i < len(*b) {
            sum += (*b)[i]
        }
        carry = sum / 3
        sum %= 3
        switch {
        case sum > 1:
            sum -= 3
            carry++
        case sum < -1:
            sum += 3
            carry--
        } 
        r[i] = sum 
    }
    last := len(*a)
    if carry != 0 {
        if len(r) == last {
            n := make(bt, last+4)
            copy(n, r)
            r = n
        }
        r[last] = carry
        *z = r[:last+1]
        return z
    }
    for {
        if last == 0 {
            *z = nil
            break
        }
        last--
        if r[last] != 0 {
            *z = r[:last+1]
            break
        }
    }
    return z
}
 
func (z *bt) Mul(a, b *bt) *bt {
    if len(*a) < len(*b) {
        a, b = b, a
    }
    var na bt
    for _, d := range *b {
        if d == -1 {
            na.Neg(a)
            break
        }
    }
    r := make(bt, len(*a)+len(*b))
    for i := len(*b) - 1; i >= 0; i-- {
        switch (*b)[i] {
        case 1:
            p := r[i:]
            p.Add(&p, a)
        case -1:
            p := r[i:]
            p.Add(&p, &na)
        }
    }
    i := len(r)
    for i > 0 && r[i-1] == 0 {
        i--
    }
    *z = r[:i]
    return z
}
 
func main() {
    a, _ := btString(""+-0++0+"")
    b := btInt(-436)
    c, _ := btString(""+-++-"")
    show(""a:"", a) 
    show(""b:"", b)
    show(""c:"", c)
    show(""a(b-c):"", a.Mul(a, b.Add(b, c.Neg(c))))
}   
 
func show(label string, b *bt) {
    fmt.Printf(""%7s %12v "", label, b)
    if i, ok := b.Int(); ok {
        fmt.Printf(""%7d\n"", i)
    } else {
        fmt.Println(""int overflow"")
    }
}",4707,224
73725,http://rosettacode.org/wiki/Averages/Mode,Averages/Mode,"Task[edit]
Write a program to find the mode value of a collection.

The case where the collection is empty may be ignored. Care must be taken to handle the case where the mode is non-unique.

If it is not appropriate or possible to support a general collection, use a vector (array), if possible. If it is not appropriate or possible to support an unspecified value type, use integers.

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    fmt.Println(mode([]int{2, 7, 1, 8, 2}))
    fmt.Println(mode([]int{2, 7, 1, 8, 2, 8}))
}
 
func mode(a []int) []int {
    m := make(map[int]int)
    for _, v := range a {
        m[v]++
    }
    var mode []int
    var n int
    for k, v := range m {
        switch {
        case v < n:
        case v > n:
            n = v
            mode = append(mode[:0], k)
        default:
            mode = append(mode, k)
        }
    }
    return mode
}",498,28
73755,http://rosettacode.org/wiki/Averages/Mean_time_of_day,Averages/Mean time of day,"Task[edit]
A particular activity of bats occurs at these times of the day:

23:00:17, 23:40:20, 00:12:45, 00:17:19
Using the idea that there are twenty-four hours in a day,
which is analogous to there being 360 degrees in a circle,
map times of day to and from angles;
and using the ideas of Averages/Mean angle
compute and show the average time of the nocturnal activity
to an accuracy of one second of time.

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",#Go,Go,"package main
 
import (
    ""errors""
    ""fmt""
    ""log""
    ""math""
    ""time""
)
 
var inputs = []string{""23:00:17"", ""23:40:20"", ""00:12:45"", ""00:17:19""}
 
func main() {
    tList := make([]time.Time, len(inputs))
    const clockFmt = ""15:04:05""
    var err error
    for i, s := range inputs {
        tList[i], err = time.Parse(clockFmt, s)
        if err != nil {
            log.Fatal(err)
        }
    }
    mean, err := meanTime(tList)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(mean.Format(clockFmt))
}
 
func meanTime(times []time.Time) (mean time.Time, err error) {
    if len(times) == 0 {
        err = errors.New(""meanTime: no times specified"")
        return
    }
    var ssum, csum float64
    for _, t := range times {
        h, m, s := t.Clock()
        n := t.Nanosecond()
        fSec := (float64((h*60+m)*60+s) + float64(n)*1e-9)
        sin, cos := math.Sincos(fSec * math.Pi / (12 * 60 * 60))
        ssum += sin
        csum += cos
    }
    if ssum == 0 && csum == 0 {
        err = errors.New(""meanTime: mean undefined"")
        return
    }
    _, dayFrac := math.Modf(1 + math.Atan2(ssum, csum)/(2*math.Pi))
    return mean.Add(time.Duration(dayFrac * 24 * float64(time.Hour))), nil
}",1234,50
73756,http://rosettacode.org/wiki/AVL_tree,AVL tree,"

 This page uses content from Wikipedia. The original article was at AVL tree. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In computer science, an AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; at no time do they differ by more than one because rebalancing is done ensure this is the case. Lookup, insertion, and deletion all take O(log n) time in both the average and worst cases, where n is the number of nodes in the tree prior to the operation. Insertions and deletions may require the tree to be rebalanced by one or more tree rotations. Note the tree of nodes comprise a set, so duplicate node keys are not allowed.

AVL trees are often compared with red-black trees because they support the same set of operations and because red-black trees also take O(log n) time for the basic operations. Because AVL trees are more rigidly balanced, they are faster than red-black trees for lookup-intensive applications. Similar to red-black trees, AVL trees are height-balanced, but in general not weight-balanced nor μ-balanced; that is, sibling nodes can have hugely differing numbers of descendants.



Task

Implement an AVL tree in the language of choice, and provide at least basic operations.



",#Go,Go,"package avl
 
// AVL tree adapted from Julienne Walker's presentation at
// http://eternallyconfuzzled.com/tuts/datastructures/jsw_tut_avl.aspx.
// This port uses similar indentifier names.
 
// The Key interface must be supported by data stored in the AVL tree.
type Key interface {
    Less(Key) bool
    Eq(Key) bool
}
 
// Node is a node in an AVL tree.
type Node struct {
    Data    Key      // anything comparable with Less and Eq.
    Balance int      // balance factor
    Link    [2]*Node // children, indexed by ""direction"", 0 or 1.
}
 
// A little readability function for returning the opposite of a direction,
// where a direction is 0 or 1.  Go inlines this.
// Where JW writes !dir, this code has opp(dir).
func opp(dir int) int {
    return 1 - dir
}
 
// single rotation
func single(root *Node, dir int) *Node {
    save := root.Link[opp(dir)]
    root.Link[opp(dir)] = save.Link[dir]
    save.Link[dir] = root
    return save
}
 
// double rotation
func double(root *Node, dir int) *Node {
    save := root.Link[opp(dir)].Link[dir]
 
    root.Link[opp(dir)].Link[dir] = save.Link[opp(dir)]
    save.Link[opp(dir)] = root.Link[opp(dir)]
    root.Link[opp(dir)] = save
 
    save = root.Link[opp(dir)]
    root.Link[opp(dir)] = save.Link[dir]
    save.Link[dir] = root
    return save
}
 
// adjust valance factors after double rotation
func adjustBalance(root *Node, dir, bal int) {
    n := root.Link[dir]
    nn := n.Link[opp(dir)]
    switch nn.Balance {
    case 0:
        root.Balance = 0
        n.Balance = 0
    case bal:
        root.Balance = -bal
        n.Balance = 0
    default:
        root.Balance = 0
        n.Balance = bal
    }
    nn.Balance = 0
}
 
func insertBalance(root *Node, dir int) *Node {
    n := root.Link[dir]
    bal := 2*dir - 1
    if n.Balance == bal {
        root.Balance = 0
        n.Balance = 0
        return single(root, opp(dir))
    }
    adjustBalance(root, dir, bal)
    return double(root, opp(dir))
}
 
func insertR(root *Node, data Key) (*Node, bool) {
    if root == nil {
        return &Node{Data: data}, false
    }
    dir := 0
    if root.Data.Less(data) {
        dir = 1
    }
    var done bool
    root.Link[dir], done = insertR(root.Link[dir], data)
    if done {
        return root, true
    }
    root.Balance += 2*dir - 1
    switch root.Balance {
    case 0:
        return root, true
    case 1, -1:
        return root, false
    }
    return insertBalance(root, dir), true
}
 
// Insert a node into the AVL tree.
// Data is inserted even if other data with the same key already exists.
func Insert(tree **Node, data Key) {
    *tree, _ = insertR(*tree, data)
}
 
func removeBalance(root *Node, dir int) (*Node, bool) {
    n := root.Link[opp(dir)]
    bal := 2*dir - 1
    switch n.Balance {
    case -bal:
        root.Balance = 0
        n.Balance = 0
        return single(root, dir), false
    case bal:
        adjustBalance(root, opp(dir), -bal)
        return double(root, dir), false
    }
    root.Balance = -bal
    n.Balance = bal
    return single(root, dir), true
}
 
func removeR(root *Node, data Key) (*Node, bool) {
    if root == nil {
        return nil, false
    }
    if root.Data.Eq(data) {
        switch {
        case root.Link[0] == nil:
            return root.Link[1], false
        case root.Link[1] == nil:
            return root.Link[0], false
        }
        heir := root.Link[0]
        for heir.Link[1] != nil {
            heir = heir.Link[1]
        }
        root.Data = heir.Data
        data = heir.Data
    }
    dir := 0
    if root.Data.Less(data) {
        dir = 1
    }
    var done bool
    root.Link[dir], done = removeR(root.Link[dir], data)
    if done {
        return root, true
    }
    root.Balance += 1 - 2*dir
    switch root.Balance {
    case 1, -1:
        return root, true
    case 0:
        return root, false
    }
    return removeBalance(root, dir)
}
 
// Remove a single item from an AVL tree.
// If key does not exist, function has no effect.
func Remove(tree **Node, data Key) {
    *tree, _ = removeR(*tree, data)
}",4075,166
73836,http://rosettacode.org/wiki/Averages/Mean_angle,Averages/Mean angle,"When calculating the average or mean of an angle one has to take into account how angles wrap around so that any angle in degrees plus any integer multiple of 360 degrees is a measure of the same angle.

If one wanted an average direction of the wind over two readings where the first reading was of 350 degrees and the second was of 10 degrees then the average of the numbers is 180 degrees, whereas if you can note that 350 degrees is equivalent to -10 degrees and so you have two readings at 10 degrees either side of zero degrees leading to a more fitting mean angle of zero degrees.

To calculate the mean angle of several angles:

 Assume all angles are on the unit circle and convert them to complex numbers expressed in real and imaginary form.
 Compute the mean of the complex numbers.
 Convert the complex mean to polar coordinates whereupon the phase of the complex mean is the required angular mean.


(Note that, since the mean is the sum divided by the number of numbers, and division by a positive real number does not affect the angle, you can also simply compute the sum for step 2.)

You can alternatively use this formula:

 Given the angles 




α

1


,
…
,

α

n




{\displaystyle \alpha _{1},\dots ,\alpha _{n}}

 the mean is computed by







α
¯



=
atan2
⁡

(


1
n


⋅

∑

j
=
1


n


sin
⁡

α

j


,


1
n


⋅

∑

j
=
1


n


cos
⁡

α

j


)



{\displaystyle {\bar {\alpha }}=\operatorname {atan2} \left({\frac {1}{n}}\cdot \sum _{j=1}^{n}\sin \alpha _{j},{\frac {1}{n}}\cdot \sum _{j=1}^{n}\cos \alpha _{j}\right)}


Task[edit]
 write a function/method/subroutine/... that given a list of angles in degrees returns their mean angle. 
 (You should use a built-in function if you have one that does this for degrees or radians). 
 Use the function to compute the means of these lists of angles (in degrees):
   [350, 10] 
   [90, 180, 270, 360] 
   [10, 20, 30]
 Show your output here.
See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",#Go,Go,"package main
 
import (
	""fmt""
	""math""
	""math/cmplx""
)
 
func deg2rad(d float64) float64 { return d * math.Pi / 180 }
func rad2deg(r float64) float64 { return r * 180 / math.Pi }
 
func mean_angle(deg []float64) float64 {
	sum := 0i
	for _, x := range deg {
		sum += cmplx.Rect(1, deg2rad(x))
	}
	return rad2deg(cmplx.Phase(sum))
}
 
func main() {
	for _, angles := range [][]float64{
		{350, 10},
		{90, 180, 270, 360},
		{10, 20, 30},
	} {
		fmt.Printf(""The mean angle of %v is: %f degrees\n"", angles, mean_angle(angles))
	}
}",528,28
73860,http://rosettacode.org/wiki/Average_loop_length,Average loop length,"Let f be a uniformly-randomly chosen mapping from the numbers 1..N to the numbers 1..N (note: not necessarily a permutation of 1..N; the mapping could produce a number in more than one way or not at all). At some point, the sequence 1, f(1), f(f(1))... will contain a repetition, a number that occurring for the second time in the sequence.



Task

Write a program or a script that estimates, for each N, the average length until the first such repetition.

Also calculate this expected length using an analytical formula, and optionally compare the simulated result with the theoretical one.



This problem comes from the end of Donald Knuth's Christmas tree lecture 2011.

Example of expected output:

 N    average    analytical    (error)
===  =========  ============  =========
  1     1.0000        1.0000  (  0.00%)
  2     1.4992        1.5000  (  0.05%)
  3     1.8784        1.8889  (  0.56%)
  4     2.2316        2.2188  (  0.58%)
  5     2.4982        2.5104  (  0.49%)
  6     2.7897        2.7747  (  0.54%)
  7     3.0153        3.0181  (  0.09%)
  8     3.2429        3.2450  (  0.07%)
  9     3.4536        3.4583  (  0.14%)
 10     3.6649        3.6602  (  0.13%)
 11     3.8091        3.8524  (  1.12%)
 12     3.9986        4.0361  (  0.93%)
 13     4.2074        4.2123  (  0.12%)
 14     4.3711        4.3820  (  0.25%)
 15     4.5275        4.5458  (  0.40%)
 16     4.6755        4.7043  (  0.61%)
 17     4.8877        4.8579  (  0.61%)
 18     4.9951        5.0071  (  0.24%)
 19     5.1312        5.1522  (  0.41%)
 20     5.2699        5.2936  (  0.45%)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/rand""
)
 
const nmax = 20
 
func main() {
    fmt.Println("" N    average    analytical    (error)"")
    fmt.Println(""===  =========  ============  ========="")
    for n := 1; n <= nmax; n++ {
        a := avg(n)
        b := ana(n)
        fmt.Printf(""%3d  %9.4f  %12.4f  (%6.2f%%)\n"",
            n, a, b, math.Abs(a-b)/b*100)
    }
}
 
func avg(n int) float64 {
    const tests = 1e4
    sum := 0
    for t := 0; t < tests; t++ {
        var v [nmax]bool
        for x := 0; !v[x]; x = rand.Intn(n) {
            v[x] = true
            sum++
        }
    }
    return float64(sum) / tests
}
 
func ana(n int) float64 {
    nn := float64(n)
    term := 1.
    sum := 1.
    for i := nn - 1; i >= 1; i-- {
        term *= i / nn
        sum += term
    }
    return sum
}",828,44
73888,http://rosettacode.org/wiki/Associative_array/Merging,Associative array/Merging,"Task

Define two associative arrays, where one represents the following ""base"" data:





 Key 
 Value


 ""name"" 
 ""Rocket Skates""


 ""price"" 
 12.75


 ""color"" 
 ""yellow""

And the other represents ""update"" data:





 Key 
 Value


 ""price"" 
 15.25


 ""color"" 
 ""red""


 ""year"" 
 1974

Merge these into a new associative array that contains every key found in either of the source ones. Each key should map to the value in the second (update) table if that exists, or else to the value in the first (base) table. If possible, do this in a way that does not mutate the original two associative arrays. Obviously this should be done in a way that would work for any data, not just the specific data given here, but in this example the result should be:





 Key 
 Value


 ""name"" 
 ""Rocket Skates""


 ""price"" 
 15.25


 ""color"" 
 ""red""


 ""year"" 
 1974


",#Go,Go,"package main
 
import ""fmt""
 
type assoc map[string]interface{}
 
func merge(base, update assoc) assoc {
    result := make(assoc)
    for k, v := range base {
        result[k] = v
    }
    for k, v := range update {
        result[k] = v
    }
    return result
}
 
func main() {
    base := assoc{""name"": ""Rocket Skates"", ""price"": 12.75, ""color"": ""yellow""}
    update := assoc{""price"": 15.25, ""color"": ""red"", ""year"": 1974}
    result := merge(base, update)
    fmt.Println(result)
}",486,23
73900,http://rosettacode.org/wiki/Averages/Pythagorean_means,Averages/Pythagorean means,"Task[edit]
Compute all three of the Pythagorean means of the set of integers 1 through 10 (inclusive).

Show that 



A
(

x

1


,
…
,

x

n


)
≥
G
(

x

1


,
…
,

x

n


)
≥
H
(

x

1


,
…
,

x

n


)


{\displaystyle A(x_{1},\ldots ,x_{n})\geq G(x_{1},\ldots ,x_{n})\geq H(x_{1},\ldots ,x_{n})}

 for this set of positive integers.

 The most common of the three means, the arithmetic mean, is the sum of the list divided by its length:
 



A
(

x

1


,
…
,

x

n


)
=




x

1


+
⋯
+

x

n



n




{\displaystyle A(x_{1},\ldots ,x_{n})={\frac {x_{1}+\cdots +x_{n}}{n}}}


 The geometric mean is the 



n


{\displaystyle n}

th root of the product of the list:
 



G
(

x

1


,
…
,

x

n


)
=




x

1


⋯

x

n




n





{\displaystyle G(x_{1},\ldots ,x_{n})={\sqrt[{n}]{x_{1}\cdots x_{n}}}}


 The harmonic mean is 



n


{\displaystyle n}

 divided by the sum of the reciprocal of each item in the list:
 



H
(

x

1


,
…
,

x

n


)
=


n



1

x

1




+
⋯
+


1

x

n









{\displaystyle H(x_{1},\ldots ,x_{n})={\frac {n}{{\frac {1}{x_{1}}}+\cdots +{\frac {1}{x_{n}}}}}}




See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func main() {
    sum, sumr, prod := 0., 0., 1.
    for n := 1.; n <= 10; n++ {
        sum += n
        sumr += 1 / n
        prod *= n
    }
    a, g, h := sum/10, math.Pow(prod, .1), 10/sumr
    fmt.Println(""A:"", a, ""G:"", g, ""H:"", h)
    fmt.Println(""A >= G >= H:"", a >= g && g >= h)
}",337,18
73971,http://rosettacode.org/wiki/Approximate_equality,Approximate equality,"Sometimes, when testing whether the solution to a task (for example, here on Rosetta Code) is correct, the
difference in floating point calculations between different language implementations becomes significant.

For example, a difference between 32 bit and 64 bit floating point calculations may appear by
about the 8th significant digit in base 10 arithmetic.



Task

Create a function which returns true if two floating point numbers are approximately equal.



The function should allow for differences in the magnitude of numbers, so that, for example,

100000000000000.01   may be approximately equal to   100000000000000.011,

even though   100.01   is not approximately equal to   100.011.

If the language has such a feature in its standard library, this may be used instead of a custom function.

Show the function results with comparisons on the following pairs of values:

     100000000000000.01,   100000000000000.011     (note: should return true)
     100.01,   100.011                                                     (note: should return false)
     10000000000000.001 / 10000.0,   1000000000.0000001000
     0.001,   0.0010000001
     0.000000000000000000000101,   0.0
      sqrt(2) * sqrt(2),    2.0
     -sqrt(2) * sqrt(2),   -2.0
     3.14159265358979323846,   3.14159265358979324


Answers should be true for the first example and false in the second, so that just rounding the numbers to a fixed number of decimals should not be enough. Otherwise answers may vary and still be correct. See the Python code for one type of solution.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math/big""
)
 
func max(a, b *big.Float) *big.Float {
    if a.Cmp(b) > 0 {
        return a
    }
    return b
}
 
func isClose(a, b *big.Float) bool {
    relTol := big.NewFloat(1e-9) // same as default for Python's math.isclose() function
    t := new(big.Float)
    t.Sub(a, b)
    t.Abs(t)
    u, v, w := new(big.Float), new(big.Float), new(big.Float)
    u.Mul(relTol, max(v.Abs(a), w.Abs(b)))
    return t.Cmp(u) <= 0
}
 
func nbf(s string) *big.Float {
    n, ok := new(big.Float).SetString(s)
    if !ok {
        log.Fatal(""invalid floating point number"")
    }
    return n
}
 
func main() {
    root2 := big.NewFloat(2.0)
    root2.Sqrt(root2)
    pairs := [][2]*big.Float{
        {nbf(""100000000000000.01""), nbf(""100000000000000.011"")},
        {nbf(""100.01""), nbf(""100.011"")},
        {nbf(""0"").Quo(nbf(""10000000000000.001""), nbf(""10000.0"")), nbf(""1000000000.0000001000"")},
        {nbf(""0.001""), nbf(""0.0010000001"")},
        {nbf(""0.000000000000000000000101""), nbf(""0.0"")},
        {nbf(""0"").Mul(root2, root2), nbf(""2.0"")},
        {nbf(""0"").Mul(nbf(""0"").Neg(root2), root2), nbf(""-2.0"")},
        {nbf(""100000000000000003.0""), nbf(""100000000000000004.0"")},
        {nbf(""3.14159265358979323846""), nbf(""3.14159265358979324"")},
    }
    for _, pair := range pairs {
        s := ""≉""
        if isClose(pair[0], pair[1]) {
            s = ""≈""
        }
        fmt.Printf(""% 21.19g %s %- 21.19g\n"", pair[0], s, pair[1])
    }
}",1490,55
74029,http://rosettacode.org/wiki/Attractive_numbers,Attractive numbers,"A number is an   attractive number   if the number of its prime factors (whether distinct or not) is also prime.



Example

The number   20,   whose prime decomposition is   2 × 2 × 5,   is an   attractive number   because the number of its prime factors   (3)   is also prime.



Task

Show sequence items up to   120.



Reference

   The OEIS entry:   A063989: Numbers with a prime number of prime divisors.

",#Go,Go,"package main
 
import ""fmt""
 
func isPrime(n int) bool {
    switch {
    case n < 2:
        return false
    case n%2 == 0:
        return n == 2
    case n%3 == 0:
        return n == 3
    default:
        d := 5
        for d*d <= n {
            if n%d == 0 {
                return false
            }
            d += 2
            if n%d == 0 {
                return false
            }
            d += 4
        }
        return true
    }
}
 
func countPrimeFactors(n int) int {
    switch {
    case n == 1:
        return 0
    case isPrime(n):
        return 1
    default:
        count, f := 0, 2
        for {
            if n%f == 0 {
                count++
                n /= f
                if n == 1 {
                    return count
                }
                if isPrime(n) {
                    f = n
                }
            } else if f >= 3 {
                f += 2
            } else {
                f = 3
            }
        }
        return count
    }
}
 
func main() {
    const max = 120
    fmt.Println(""The attractive numbers up to and including"", max, ""are:"")
    count := 0
    for i := 1; i <= max; i++ {
        n := countPrimeFactors(i)
        if isPrime(n) {
            fmt.Printf(""%4d"", i)
            count++
            if count % 20 == 0 {
                fmt.Println()
            }
        }       
    }
    fmt.Println()
}",1395,72
74046,http://rosettacode.org/wiki/Atomic_updates,Atomic updates,"

Task

Define a data type consisting of a fixed number of 'buckets', each containing a nonnegative integer value, which supports operations to:

 get the current value of any bucket
 remove a specified amount from one specified bucket and add it to another, preserving the total of all bucket values, and clamping the transferred amount to ensure the values remain non-negative

In order to exercise this data type, create one set of buckets, and start three concurrent tasks:

 As often as possible, pick two buckets and make their values closer to equal.
 As often as possible, pick two buckets and arbitrarily redistribute their values.
 At whatever rate is convenient, display (by any means) the total value and, optionally, the individual values of each bucket.


The display task need not be explicit; use of e.g. a debugger or trace tool is acceptable provided it is simple to set up to provide the display.


This task is intended as an exercise in atomic operations.   The sum of the bucket values must be preserved even if the two tasks attempt to perform transfers simultaneously, and a straightforward solution is to ensure that at any time, only one transfer is actually occurring — that the transfer operation is atomic.



",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""sync""
    ""time""
)
 
const nBuckets = 10
 
type bucketList struct {
    b [nBuckets]int // bucket data specified by task
 
    // transfer counts for each updater, not strictly required by task but
    // useful to show that the two updaters get fair chances to run.
    tc [2]int
 
    sync.Mutex // synchronization
}
 
// Updater ids, to track number of transfers by updater.
// these can index bucketlist.tc for example.
const (
    idOrder = iota
    idChaos
)
 
const initialSum = 1000 // sum of all bucket values
 
// Constructor.
func newBucketList() *bucketList {
    var bl bucketList
    // Distribute initialSum across buckets.
    for i, dist := nBuckets, initialSum; i > 0; {
        v := dist / i
        i--
        bl.b[i] = v
        dist -= v
    }
    return &bl
}
 
// method 1 required by task, get current value of a bucket
func (bl *bucketList) bucketValue(b int) int {
    bl.Lock() // lock before accessing data
    r := bl.b[b]
    bl.Unlock()
    return r
}
 
// method 2 required by task
func (bl *bucketList) transfer(b1, b2, a int, ux int) {
    // Get access.
    bl.Lock()
    // Clamping maintains invariant that bucket values remain nonnegative.
    if a > bl.b[b1] {
        a = bl.b[b1]
    }
    // Transfer.
    bl.b[b1] -= a
    bl.b[b2] += a
    bl.tc[ux]++ // increment transfer count
    bl.Unlock()
}
 
// additional useful method
func (bl *bucketList) snapshot(s *[nBuckets]int, tc *[2]int) {
    bl.Lock()
    *s = bl.b
    *tc = bl.tc
    bl.tc = [2]int{} // clear transfer counts
    bl.Unlock()
}
 
var bl = newBucketList()
 
func main() {
    // Three concurrent tasks.
    go order() // make values closer to equal
    go chaos() // arbitrarily redistribute values
    buddha()   // display total value and individual values of each bucket
}
 
// The concurrent tasks exercise the data operations by calling bucketList
// methods.  The bucketList methods are ""threadsafe"", by which we really mean
// goroutine-safe.  The conconcurrent tasks then do no explicit synchronization
// and are not responsible for maintaining invariants.
 
// Exercise 1 required by task: make values more equal.
func order() {
    r := rand.New(rand.NewSource(time.Now().UnixNano()))
    for {
        b1 := r.Intn(nBuckets)
        b2 := r.Intn(nBuckets - 1)
        if b2 >= b1 {
            b2++
        }
        v1 := bl.bucketValue(b1)
        v2 := bl.bucketValue(b2)
        if v1 > v2 {
            bl.transfer(b1, b2, (v1-v2)/2, idOrder)
        } else {
            bl.transfer(b2, b1, (v2-v1)/2, idOrder)
        }
    }
}
 
// Exercise 2 required by task: redistribute values.
func chaos() {
    r := rand.New(rand.NewSource(time.Now().Unix()))
    for {
        b1 := r.Intn(nBuckets)
        b2 := r.Intn(nBuckets - 1)
        if b2 >= b1 {
            b2++
        }
        bl.transfer(b1, b2, r.Intn(bl.bucketValue(b1)+1), idChaos)
    }
}
 
// Exercise 3 requred by task: display total.
func buddha() {
    var s [nBuckets]int
    var tc [2]int
    var total, nTicks int
 
    fmt.Println(""sum  ---updates---    mean  buckets"")
    tr := time.Tick(time.Second / 10)
    for {
        <-tr
        bl.snapshot(&s, &tc)
        var sum int
        for _, l := range s {
            if l < 0 {
                panic(""sob"") // invariant not preserved
            }
            sum += l
        }
        // Output number of updates per tick and cummulative mean
        // updates per tick to demonstrate ""as often as possible""
        // of task exercises 1 and 2.
        total += tc[0] + tc[1]
        nTicks++
        fmt.Printf(""%d %6d %6d %7d  %3d\n"", sum, tc[0], tc[1], total/nTicks, s)
        if sum != initialSum {
            panic(""weep"") // invariant not preserved
        }
    }
}",3793,150
74091,http://rosettacode.org/wiki/Apply_a_digital_filter_(direct_form_II_transposed),Apply a digital filter (direct form II transposed),"Digital filters are used to apply a mathematical operation to a sampled signal. One of the common formulations is the ""direct form II transposed"" which can represent both infinite impulse response (IIR) and finite impulse response (FIR) filters, as well as being more numerically stable than other forms. [1]

Task

Filter a signal using an order 3 low-pass Butterworth filter. The coefficients for the filter are a=[1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17] and b = [0.16666667, 0.5, 0.5, 0.16666667]

The signal that needs filtering is the following vector: [-0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412, -0.662370894973, -1.00700480494, -0.404707073677 ,0.800482325044, 0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195, 0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293, 0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589]
",#Go,Go,"package main
 
import ""fmt""
 
type filter struct {
    b, a []float64
}
 
func (f filter) filter(in []float64) []float64 {
    out := make([]float64, len(in))
    s := 1. / f.a[0]
    for i := range in {
        tmp := 0.
        b := f.b
        if i+1 < len(b) {
            b = b[:i+1]
        }
        for j, bj := range b {
            tmp += bj * in[i-j]
        }
        a := f.a[1:]
        if i < len(a) {
            a = a[:i]
        }
        for j, aj := range a {
            tmp -= aj * out[i-j-1]
        }
        out[i] = tmp * s
    }
    return out
}
 
//Constants for a Butterworth filter (order 3, low pass)
var bwf = filter{
    a: []float64{1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17},
    b: []float64{0.16666667, 0.5, 0.5, 0.16666667},
}
 
var sig = []float64{
    -0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412,
    -0.662370894973, -1.00700480494, -0.404707073677, 0.800482325044,
    0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195,
    0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293,
    0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589,
}
 
func main() {
    for _, v := range bwf.filter(sig) {
        fmt.Printf(""%9.6f\n"", v)
    }
}",1246,51
74188,http://rosettacode.org/wiki/Assertions,Assertions,"Assertions are a way of breaking out of code when there is an error or an unexpected input.

Some languages throw exceptions and some treat it as a break point.



Task

Show an assertion in your language by asserting that an integer variable is equal to 42.



",#Go,Go,"package main
 
func main() {
    x := 43
    if x != 42 {
        panic(42)
    }
}",83,8
74324,http://rosettacode.org/wiki/Append_a_record_to_the_end_of_a_text_file,Append a record to the end of a text file,"Many systems offer the ability to open a file for writing, such that any data written will be appended to the end of the file. Further, the file operations will always adjust the position pointer to guarantee the end of the file, even in a multitasking environment.

This feature is most useful in the case of log files, where many jobs may be appending to the log file at the same time, or where care must be taken to avoid concurrently overwriting the same record from another job.



Task

Given a two record sample for a mythical ""passwd"" file:

 Write these records out in the typical system format.
 Ideally these records will have named fields of various types.
 Close the file, then reopen the file for append.
 Append a new record to the file and close the file again.
 Take appropriate care to avoid concurrently overwrites from another job.
 Open the file and demonstrate the new record has indeed written to the end.

 Source record field types and contents.


account
password
UID
GID
fullname,office,extension,homephone,email
directory
shell


string
string
int
int
struct(string,string,string,string,string)
string
string


jsmith
x
1001
1000
Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org
/home/jsmith
/bin/bash


jdoe
x
1002
1000
Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org
/home/jdoe
/bin/bash


 Record to be appended.


account
password
UID
GID
fullname,office,extension,homephone,email
directory
shell


string
string
int
int
struct(string,string,string,string,string)
string
string


xyz
x
1003
1000
X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org
/home/xyz
/bin/bash

Resulting file format: should mimic Linux's /etc/passwd file format with particular attention to the "","" separator used in the GECOS field. But if the specific language has a particular or unique format of storing records in text file, then this format should be named and demonstrated with an additional example.

Expected output:

Appended record: xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash

Finally: Provide a summary of the language's ""append record"" capabilities in a table. eg.


 Append Capabilities.


 Data Representation

 IO
Library

 Append
Possible

 Automatic
Append

 Multi-tasking
Safe


 In core 
 On disk


 C struct 
 CSV text file 
 glibc/stdio 
 ☑ 
 ☑ 
 ☑ (Not all, eg NFS)

Alternatively: If the language's appends can not guarantee its writes will always append, then note this restriction in the table. If possible, provide an actual code example (possibly using file/record locking) to guarantee correct concurrent appends.



",#Go,Go,"package main
 
import (
    ""bytes""
    ""fmt""
    ""io""
    ""io/ioutil""
    ""os""
)
 
type pw struct {
    account, password string
    uid, gid          uint
    gecos
    directory, shell string
}
 
type gecos struct {
    fullname, office, extension, homephone, email string
}
 
func (p *pw) encode(w io.Writer) (int, error) {
    return fmt.Fprintf(w, ""%s:%s:%d:%d:%s,%s,%s,%s,%s:%s:%s\n"",
        p.account, p.password, p.uid, p.gid,
        p.fullname, p.office, p.extension, p.homephone, p.email,
        p.directory, p.shell)
}
 
// data cut and pasted from task description
var p2 = []pw{
    {""jsmith"", ""x"", 1001, 1000, gecos{""Joe Smith"", ""Room 1007"",
        ""(234)555-8917"", ""(234)555-0077"", ""jsmith@rosettacode.org""},
        ""/home/jsmith"", ""/bin/bash""},
    {""jdoe"", ""x"", 1002, 1000, gecos{""Jane Doe"", ""Room 1004"",
        ""(234)555-8914"", ""(234)555-0044"", ""jdoe@rosettacode.org""},
        ""/home/jsmith"", ""/bin/bash""},
}
 
var pa = pw{""xyz"", ""x"", 1003, 1000, gecos{""X Yz"", ""Room 1003"",
    ""(234)555-8913"", ""(234)555-0033"", ""xyz@rosettacode.org""},
    ""/home/xyz"", ""/bin/bash""}
 
var expected = ""xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,"" +
    ""(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash""
 
const pfn = ""mythical""
 
func main() {
    writeTwo()
    appendOneMore()
    checkResult()
}
 
func writeTwo() {
    // overwrites any existing file
    f, err := os.Create(pfn)
    if err != nil {
        fmt.Println(err)
        return
    }
    defer func() {
        if cErr := f.Close(); cErr != nil && err == nil {
            fmt.Println(cErr)
        }
    }()
    for _, p := range p2 {
        if _, err = p.encode(f); err != nil {
            fmt.Println(err)
            return
        }
    }
}
 
func appendOneMore() {
    // file must already exist
    f, err := os.OpenFile(pfn, os.O_RDWR|os.O_APPEND, 0)
    if err != nil {
        fmt.Println(err)
        return
    }
    if _, err := pa.encode(f); err != nil {
        fmt.Println(err)
    }
    if cErr := f.Close(); cErr != nil && err == nil {
        fmt.Println(cErr)
    }
}
 
func checkResult() {
    // reads entire file then closes it
    b, err := ioutil.ReadFile(pfn)
    if err != nil {
        fmt.Println(err)
        return
    }
    if string(bytes.Split(b, []byte{'\n'})[2]) == expected {
        fmt.Println(""append okay"")
    } else {
        fmt.Println(""it didn't work"")
    }
}",2390,101
74352,http://rosettacode.org/wiki/Averages/Median,Averages/Median,"Task[edit]
Write a program to find the   median   value of a vector of floating-point numbers.

The program need not handle the case where the vector is empty, but must handle the case where there are an even number of elements.   In that case, return the average of the two middle values.

There are several approaches to this.   One is to sort the elements, and then pick the element(s) in the middle.

Sorting would take at least   O(n logn).   Another approach would be to build a priority queue from the elements, and then extract half of the elements to get to the middle element(s).   This would also take   O(n logn).   The best solution is to use the   selection algorithm   to find the median in   O(n)   time.

See also
Quickselect_algorithm

Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",#Go,Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
func main() {
    fmt.Println(median([]float64{3, 1, 4, 1}))    // prints 2
    fmt.Println(median([]float64{3, 1, 4, 1, 5})) // prints 3
}
 
func median(a []float64) float64 {
    sort.Float64s(a)
    half := len(a) / 2
    m := a[half]
    if len(a)%2 == 0 {
        m = (m + a[half-1]) / 2
    }
    return m
}",362,21
74557,http://rosettacode.org/wiki/Anti-primes,Anti-primes,"The anti-primes
(or highly composite numbers, sequence A002182 in the OEIS)
are the natural numbers with more factors than any smaller than itself.



Task

Generate and show here, the first twenty anti-primes.



Related tasks

   Factors of an integer
   Sieve of Eratosthenes

",#Go,Go,"package main
 
import ""fmt""
 
func countDivisors(n int) int {
    if n < 2 {
        return 1
    }
    count := 2 // 1 and n
    for i := 2; i <= n/2; i++ {
        if n%i == 0 {
            count++
        }
    }
    return count
}
 
func main() {
    fmt.Println(""The first 20 anti-primes are:"")
    maxDiv := 0
    count := 0
    for n := 1; count < 20; n++ {
        d := countDivisors(n)
        if d > maxDiv {
            fmt.Printf(""%d "", n)
            maxDiv = d
            count++
        }
    }
    fmt.Println()
}",530,31
74676,http://rosettacode.org/wiki/Associative_array/Iteration,Associative array/Iteration,"Show how to iterate over the key-value pairs of an associative array, and print each pair out.

Also show how to iterate just over the keys, or the values, if there is a separate way to do that in your language.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#Go,Go,"myMap := map[string]int {
	   ""hello"": 13,
	   ""world"": 31,
	   ""!""    : 71 }
 
// iterating over key-value pairs:
for key, value := range myMap {
    fmt.Printf(""key = %s, value = %d\n"", key, value)
}
 
// iterating over keys:
for key := range myMap {
    fmt.Printf(""key = %s\n"", key)
}
 
// iterating over values:
for _, value := range myMap {
    fmt.Printf(""value = %d\n"", value)
}",386,19
74678,http://rosettacode.org/wiki/Averages/Arithmetic_mean,Averages/Arithmetic mean,"Task[edit]
Write a program to find the mean (arithmetic average) of a numeric vector.

In case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func mean(v []float64) (m float64, ok bool) {
    if len(v) == 0 {
        return
    }
    // an algorithm that attempts to retain accuracy
    // with widely different values.
    var parts []float64
    for _, x := range v {
        var i int
        for _, p := range parts {
            sum := p + x
            var err float64
            switch ax, ap := math.Abs(x), math.Abs(p); {
            case ax < ap:
                err = x - (sum - p)
            case ap < ax:
                err = p - (sum - x)
            }
            if err != 0 {
                parts[i] = err
                i++
            }
            x = sum
        }
        parts = append(parts[:i], x)
    }
    var sum float64
    for _, x := range parts {
        sum += x
    }
    return sum / float64(len(v)), true
}
 
func main() {
    for _, v := range [][]float64{
        []float64{},                         // mean returns ok = false
        []float64{math.Inf(1), math.Inf(1)}, // answer is +Inf
 
        // answer is NaN, and mean returns ok = true, indicating NaN
        // is the correct result
        []float64{math.Inf(1), math.Inf(-1)},
 
        []float64{3, 1, 4, 1, 5, 9},
 
        // large magnitude numbers cancel. answer is mean of small numbers.
        []float64{1e20, 3, 1, 4, 1, 5, 9, -1e20},
 
        []float64{10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, .11},
        []float64{10, 20, 30, 40, 50, -100, 4.7, -11e2},
    } {
        fmt.Println(""Vector:"", v)
        if m, ok := mean(v); ok {
            fmt.Printf(""Mean of %d numbers is %g\n\n"", len(v), m)
        } else {
            fmt.Println(""Mean undefined\n"")
        }
    }
}",1704,65
74743,http://rosettacode.org/wiki/Balanced_brackets,Balanced brackets,"Task:

 Generate a string with   N   opening brackets   [   and with   N   closing brackets   ],   in some arbitrary order. 
 Determine whether the generated string is balanced; that is, whether it consists entirely of pairs of opening/closing brackets (in that order), none of which mis-nest.


Examples

   (empty)      OK
   []           OK   
   [][]         OK   
   [[][]]       OK 
   ][         NOT OK
   ][][       NOT OK
   []][[]     NOT OK


",#Go,Go,"package main
 
import (
    ""bytes""
    ""fmt""
    ""math/rand""
    ""time""
)
 
func init() {
    rand.Seed(time.Now().UnixNano())
}
 
func generate(n uint) string {
    a := bytes.Repeat([]byte(""[]""), int(n))
    for i := len(a) - 1; i >= 1; i-- {
        j := rand.Intn(i + 1)
        a[i], a[j] = a[j], a[i]
    }
    return string(a)
}
 
func testBalanced(s string) {
    fmt.Print(s + "": "")
    open := 0
    for _,c := range s {
        switch c {
        case '[':
            open++
        case ']':
            if open == 0 {
                fmt.Println(""not ok"")
                return
            }
            open--
        default:
            fmt.Println(""not ok"")
            return
        }
    }
    if open == 0 {
        fmt.Println(""ok"")
    } else {
        fmt.Println(""not ok"")
    }
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    for i := uint(0); i < 10; i++ {
        testBalanced(generate(i))
    }
    testBalanced(""()"")
}",962,54
74840,http://rosettacode.org/wiki/Apply_a_callback_to_an_array,Apply a callback to an array,"Task

Take a combined set of elements and apply a function to each element.



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    for _, i := range []int{1, 2, 3, 4, 5} {
        fmt.Println(i * i)
    }
}",123,9
75112,http://rosettacode.org/wiki/Associative_array/Creation,Associative array/Creation,"Task

The goal is to create an associative array (also known as a dictionary, map, or hash).



Related tasks:

 Associative arrays/Iteration
 Hash from two arrays


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",#Go,Go,"// declare a nil map variable, for maps from string to int
var x map[string]int
 
// make an empty map
x = make(map[string]int)
 
// make an empty map with an initial capacity
x = make(map[string]int, 42)
 
// set a value
x[""foo""] = 3
 
// getting values
y1 := x[""bar""]     // zero value returned if no map entry exists for the key
y2, ok := x[""bar""] // ok is a boolean, true if key exists in the map
 
// removing keys
delete(x, ""foo"")
 
// make a map with a literal
x = map[string]int{
	""foo"": 2, ""bar"": 42, ""baz"": -1,
}",522,23
75613,"http://rosettacode.org/wiki/Angles_(geometric),_normalization_and_conversion","Angles (geometric), normalization and conversion","This task is about the normalization and/or conversion of (geometric) angles using
some common scales.



The angular scales that will be used in this task are:

   degree
   gradian
   mil
   radian


Definitions

The angular scales used or referenced here:

   turn   is a full turn or 360 degrees, also shown as 360º
   degree   is   1/360   of a turn
   gradian   is   1/400   of a turn
   mil   is   1/6400   of a turn
   radian   is   1/2



π


{\displaystyle \pi }

   of a turn   (or   0.5/



π


{\displaystyle \pi }

   of a turn)


Or, to put it another way,   for a full circle:

   there are   360   degrees
   there are   400   gradians
   there are   6,400   mils
   there are   2



π


{\displaystyle \pi }

   radians   (roughly equal to 6.283+)


A   mil   is approximately equal to a   milliradian   (which is   1/1000   of a radian).

There is another definition of a   mil   which
is   1/1000   of a radian   ─── this
definition won't be used in this Rosetta Code task.


Turns   are sometimes known or shown as:

   turn(s)
   360 degrees
   unit circle
   a (full) circle

Degrees   are sometimes known or shown as:

   degree(s)
   deg
   º       (a symbol)
   °       (another symbol)

Gradians   are sometimes known or shown as:

   gradian(s)
   grad(s)
   grade(s)
   gon(s)
   metric degree(s)
   (Note that   centigrade   was used for 1/100th of a grade, see the note below.)

Mils   are sometimes known or shown as:

   mil(s)
   NATO mil(s)

Radians   are sometimes known or shown as:

   radian(s)
   rad(s)


Notes

In continental Europe, the French term   centigrade   was used
for   1/100   of a grad (grade);   this was
one reason for the adoption of the term   Celsius   to
replace   centigrade   as the name of a temperature scale.

Gradians were commonly used in civil engineering.

Mils were normally used for artillery   (elevations of the gun barrel for ranging).



Positive and negative angles

Although the definition of the measurement of an angle doesn't support the
concept of a negative angle,   it's frequently useful to impose a convention that
allows positive and negative angular values to represent orientations and/or rotations
in opposite directions relative to some reference.   It is this reason that
negative angles will keep their sign and not be normalized to positive angles.



Normalization

Normalization   (for this Rosetta Code task)   will keep the same
sign,   but it will reduce the magnitude to less than a full circle;   in
other words, less than 360º.

Normalization   shouldn't   change   -45º   to   315º,

An angle of   0º,   +0º,   0.000000,   or   -0º   should be
shown as   0º.



Task

   write a function (or equivalent) to do the normalization for each scale
 Suggested names:
 d2d,   g2g,   m2m,   and  r2r
   write a function (or equivalent) to convert one scale to another
 Suggested names for comparison of different computer language function names:
 d2g,   d2m,   and   d2r   for degrees
 g2d,   g2m,   and   g2r   for gradians
 m2d,   m2g,   and   m2r   for mils
 r2d,   r2g,   and   r2m   for radians
   normalize all angles used   (except for the ""original"" or ""base"" angle)
   show the angles in every scale and convert them to all other scales
   show all output here on this page


For the (above) conversions,   use these dozen numbers   (in the order shown):

   -2   -1   0   1   2   6.2831853   16   57.2957795   359   399   6399   1000000

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""strconv""
    ""strings""
)
 
func d2d(d float64) float64 { return math.Mod(d, 360) }
 
func g2g(g float64) float64 { return math.Mod(g, 400) }
 
func m2m(m float64) float64 { return math.Mod(m, 6400) }
 
func r2r(r float64) float64 { return math.Mod(r, 2*math.Pi) }
 
func d2g(d float64) float64 { return d2d(d) * 400 / 360 }
 
func d2m(d float64) float64 { return d2d(d) * 6400 / 360 }
 
func d2r(d float64) float64 { return d2d(d) * math.Pi / 180 }
 
func g2d(g float64) float64 { return g2g(g) * 360 / 400 }
 
func g2m(g float64) float64 { return g2g(g) * 6400 / 400 }
 
func g2r(g float64) float64 { return g2g(g) * math.Pi / 200 }
 
func m2d(m float64) float64 { return m2m(m) * 360 / 6400 }
 
func m2g(m float64) float64 { return m2m(m) * 400 / 6400 }
 
func m2r(m float64) float64 { return m2m(m) * math.Pi / 3200 }
 
func r2d(r float64) float64 { return r2r(r) * 180 / math.Pi }
 
func r2g(r float64) float64 { return r2r(r) * 200 / math.Pi }
 
func r2m(r float64) float64 { return r2r(r) * 3200 / math.Pi }
 
// Aligns number to decimal point assuming 7 characters before and after.
func s(f float64) string {
    wf := strings.Split(strconv.FormatFloat(f, 'g', 15, 64), ""."")
    if len(wf) == 1 {
        return fmt.Sprintf(""%7s        "", wf[0])
    }
    le := len(wf[1])
    if le > 7 {
        le = 7
    }
    return fmt.Sprintf(""%7s.%-7s"", wf[0], wf[1][:le])
}
 
func main() {
    angles := []float64{-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795,
        359, 399, 6399, 1000000}
    ft := ""%s %s %s %s %s\n""
    fmt.Printf(ft, ""    degrees    "", ""normalized degs"", ""    gradians   "", ""     mils      "", ""     radians"")
    for _, a := range angles {
        fmt.Printf(ft, s(a), s(d2d(a)), s(d2g(a)), s(d2m(a)), s(d2r(a)))
    }
    fmt.Printf(ft, ""\n   gradians    "", ""normalized grds"", ""    degrees    "", ""     mils      "", ""     radians"")
    for _, a := range angles {
        fmt.Printf(ft, s(a), s(g2g(a)), s(g2d(a)), s(g2m(a)), s(g2r(a)))
    }
    fmt.Printf(ft, ""\n     mils      "", ""normalized mils"", ""    degrees    "", ""   gradians    "", ""     radians"")
    for _, a := range angles {
        fmt.Printf(ft, s(a), s(m2m(a)), s(m2d(a)), s(m2g(a)), s(m2r(a)))
    }
    fmt.Printf(ft, ""\n    radians    "", ""normalized rads"", ""    degrees    "", ""   gradians    "", ""      mils  "")
    for _, a := range angles {
        fmt.Printf(ft, s(a), s(r2r(a)), s(r2d(a)), s(r2g(a)), s(r2m(a)))
    }
}",2461,75
75661,http://rosettacode.org/wiki/Animation,Animation,"
Animation is integral to many parts of GUIs, including both the fancy effects when things change used in window managers, and of course games.   The core of any animation system is a scheme for periodically changing the display while still remaining responsive to the user.   This task demonstrates this.



Task

Create a window containing the string ""Hello World! "" (the trailing space is significant).

Make the text appear to be rotating right by periodically removing one letter from the end of the string and attaching it to the front.

When the user clicks on the (windowed) text, it should reverse its direction.



",#Go,Go,"package main
 
import (
    ""log""
    ""time""
 
    ""github.com/gdamore/tcell""
)
 
const (
    msg             = ""Hello World! ""
    x0, y0          = 8, 3
    shiftsPerSecond = 4
    clicksToExit    = 5
)
 
func main() {
    s, err := tcell.NewScreen()
    if err != nil {
        log.Fatal(err)
    }
    if err = s.Init(); err != nil {
        log.Fatal(err)
    }
    s.Clear()
    s.EnableMouse()
    tick := time.Tick(time.Second / shiftsPerSecond)
    click := make(chan bool)
    go func() {
        for {
            em, ok := s.PollEvent().(*tcell.EventMouse)
            if !ok || em.Buttons()&0xFF == tcell.ButtonNone {
                continue
            }
            mx, my := em.Position()
            if my == y0 && mx >= x0 && mx < x0+len(msg) {
                click <- true
            }
        }
    }()
    for inc, shift, clicks := 1, 0, 0; ; {
        select {
        case <-tick:
            shift = (shift + inc) % len(msg)
            for i, r := range msg {
                s.SetContent(x0+((shift+i)%len(msg)), y0, r, nil, 0)
            }
            s.Show()
        case <-click:
            clicks++
            if clicks == clicksToExit {
                s.Fini()
                return
            }
            inc = len(msg) - inc
        }
    }
}",1287,58
75682,http://rosettacode.org/wiki/Anagrams/Deranged_anagrams,Anagrams/Deranged anagrams,"Two or more words are said to be anagrams if they have the same characters, but in a different order.

By analogy with derangements we define a deranged anagram as two words with the same characters, but in which the same character does not appear in the same position in both words.

Task[edit]
Use the word list at unixdict to find and display the longest deranged anagram.



Related tasks
 Permutations/Derangements
 Best shuffle
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
import (
	""fmt""
	""io/ioutil""
	""strings""
	""sort""
)
 
func deranged(a, b string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range(a) {
		if a[i] == b[i] { return false }
	}
	return true
}
 
func main() {
	/* read the whole thing in. how big can it be? */
	buf, _ := ioutil.ReadFile(""unixdict.txt"")
	words := strings.Split(string(buf), ""\n"")
 
	m := make(map[string] []string)
	best_len, w1, w2 := 0, """", """"
 
	for _, w := range(words) {
		// don't bother: too short to beat current record
		if len(w) <= best_len { continue }
 
		// save strings in map, with sorted string as key
		letters := strings.Split(w, """")
		sort.Strings(letters)
		k := strings.Join(letters, """")
 
		if _, ok := m[k]; !ok {
			m[k] = []string { w }
			continue
		}
 
		for _, c := range(m[k]) {
			if deranged(w, c) {
				best_len, w1, w2 = len(w), c, w
				break
			}
		}
 
		m[k] = append(m[k], w)
	}
 
	fmt.Println(w1, w2, "": Length"", best_len)
}",950,52
75729,http://rosettacode.org/wiki/Almkvist-Giullera_formula_for_pi,Almkvist-Giullera formula for pi,"The Almkvist-Giullera formula for calculating   1/π2   is based on the Calabi-Yau
differential equations of order 4 and 5,   which were originally used to describe certain manifolds
in string theory.



The formula is:

 1/π2 = (25/3) ∑0∞ ((6n)! / (n!6))(532n2 + 126n + 9) / 10002n+1


This formula can be used to calculate the constant   π-2,   and thus to calculate   π.

Note that, because the product of all terms but the power of 1000 can be calculated as an integer,
the terms in the series can be separated into a large integer term:

  (25) (6n)! (532n2 + 126n + 9) / (3(n!)6)      (***)
multiplied by a negative integer power of 10:

  10-(6n + 3) 


Task

 Print the integer portions (the starred formula, which is without the power of 1000 divisor) of the first 10 terms of the series.
 Use the complete formula to calculate and print π to 70 decimal digits of precision.


Reference

  Gert Almkvist and Jesús Guillera, Ramanujan-like series for 1/π2 and string theory, Experimental Mathematics, 21 (2012), page 2, formula 1.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""strings""
)
 
func factorial(n int64) *big.Int {
    var z big.Int
    return z.MulRange(1, n)
}
 
var one = big.NewInt(1)
var three = big.NewInt(3)
var six = big.NewInt(6)
var ten = big.NewInt(10)
var seventy = big.NewInt(70)
 
func almkvistGiullera(n int64, print bool) *big.Rat {
    t1 := big.NewInt(32)
    t1.Mul(factorial(6*n), t1)
    t2 := big.NewInt(532*n*n + 126*n + 9)
    t3 := new(big.Int)
    t3.Exp(factorial(n), six, nil)
    t3.Mul(t3, three)
    ip := new(big.Int)
    ip.Mul(t1, t2)
    ip.Quo(ip, t3)
    pw := 6*n + 3
    t1.SetInt64(pw)
    tm := new(big.Rat).SetFrac(ip, t1.Exp(ten, t1, nil))
    if print {
        fmt.Printf(""%d  %44d  %3d  %-35s\n"", n, ip, -pw, tm.FloatString(33))
    }
    return tm
}
 
func main() {
    fmt.Println(""N                               Integer Portion  Pow  Nth Term (33 dp)"")
    fmt.Println(strings.Repeat(""-"", 89))
    for n := int64(0); n < 10; n++ {
        almkvistGiullera(n, true)
    }
 
    sum := new(big.Rat)
    prev := new(big.Rat)
    pow70 := new(big.Int).Exp(ten, seventy, nil)
    prec := new(big.Rat).SetFrac(one, pow70)
    n := int64(0)
    for {
        term := almkvistGiullera(n, false)
        sum.Add(sum, term)
        z := new(big.Rat).Sub(sum, prev)
        z.Abs(z)
        if z.Cmp(prec) < 0 {
            break
        }
        prev.Set(sum)
        n++
    }
    sum.Inv(sum)
    pi := new(big.Float).SetPrec(256).SetRat(sum)
    pi.Sqrt(pi)
    fmt.Println(""\nPi to 70 decimal places is:"")
    fmt.Println(pi.Text('f', 70))
}",1573,67
75733,http://rosettacode.org/wiki/Anonymous_recursion,Anonymous recursion,"While implementing a recursive function, it often happens that we must resort to a separate   helper function   to handle the actual recursion.

This is usually the case when directly calling the current function would waste too many resources (stack space, execution time), causing unwanted side-effects,   and/or the function doesn't have the right arguments and/or return values.

So we end up inventing some silly name like   foo2   or   foo_helper.   I have always found it painful to come up with a proper name, and see some disadvantages:

   You have to think up a name, which then pollutes the namespace
   Function is created which is called from nowhere else
   The program flow in the source code is interrupted
Some languages allow you to embed recursion directly in-place.   This might work via a label, a local gosub instruction, or some special keyword.

Anonymous recursion can also be accomplished using the   Y combinator.



Task

If possible, demonstrate this by writing the recursive version of the fibonacci function   (see Fibonacci sequence)   which checks for a negative argument before doing the actual recursion.



",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    for _, n := range []int{0, 1, 2, 3, 4, 5, 10, 40, -1} {
        f, ok := arFib(n)
        if ok {
            fmt.Printf(""fib %d = %d\n"", n, f)
        } else {
            fmt.Println(""fib undefined for negative numbers"")
        }
    }
}
 
func arFib(n int) (int, bool) {
    switch {
    case n < 0:
        return 0, false
    case n < 2:
        return n, true
    }
    return yc(func(recurse fn) fn {
        return func(left, term1, term2 int) int {
            if left == 0 {
                return term1+term2
            }
            return recurse(left-1, term1+term2, term1)
        }
    })(n-2, 1, 0), true
}
 
type fn func(int, int, int) int
type ff func(fn) fn
type fx func(fx) fn
 
func yc(f ff) fn {
    return func(x fx) fn {
        return x(x)
    }(func(x fx) fn {
        return f(func(a1, a2, a3 int) int {
            return x(x)(a1, a2, a3)
        })
    })
}",937,45
75752,http://rosettacode.org/wiki/Angle_difference_between_two_bearings,Angle difference between two bearings,"Finding the angle between two bearings is often confusing.[1]



Task

Find the angle which is the result of the subtraction b2 - b1, where b1 and b2 are the bearings.


Input bearings are expressed in the range   -180   to   +180   degrees.

The  result  is also expressed in the range   -180   to   +180   degrees.



Compute the angle for the following pairs:

 20 degrees (b1) and 45 degrees (b2)
 -45 and 45
 -85 and 90
 -95 and 90
 -45 and 125
 -45 and 145
 29.4803 and -88.6381
 -78.3251 and -159.036


Optional extra
 
Allow the input bearings to be any (finite) value.



Test cases

 -70099.74233810938 and 29840.67437876723
 -165313.6666297357 and 33693.9894517456
 1174.8380510598456 and -154146.66490124757
 60175.77306795546 and 42213.07192354373

",#Go,Go,"package main
 
import ""fmt""
 
type bearing float64
 
var testCases = []struct{ b1, b2 bearing }{
    {20, 45},
    {-45, 45},
    {-85, 90},
    {-95, 90},
    {-45, 125},
    {-45, 145},
    {29.4803, -88.6381},
    {-78.3251, -159.036},
}
 
func main() {
    for _, tc := range testCases {
        fmt.Println(tc.b2.Sub(tc.b1))
    }
}
 
func (b2 bearing) Sub(b1 bearing) bearing {
    switch d := b2 - b1; {
    case d < -180:
        return d + 360
    case d > 180:
        return d - 360
    default:
        return d
    }
}",531,33
75785,http://rosettacode.org/wiki/Animate_a_pendulum,Animate a pendulum,"
One good way of making an animation is by simulating a physical system and illustrating the variables in that system using a dynamically changing graphical display.

The classic such physical system is a simple gravity pendulum.



Task

Create a simple physical model of a pendulum and animate it.



",#Go,Go,"package main
 
import (
	""github.com/google/gxui""
	""github.com/google/gxui/drivers/gl""
	""github.com/google/gxui/math""
	""github.com/google/gxui/themes/dark""
	omath ""math""
	""time""
)
 
//Two pendulums animated
//Top: Mathematical pendulum with small-angle approxmiation (not appropiate with PHI_ZERO=pi/2)
//Bottom: Simulated with differential equation phi'' = g/l * sin(phi)
 
const (
	ANIMATION_WIDTH  int     = 480
	ANIMATION_HEIGHT int     = 320
	BALL_RADIUS      float32 = 25.0
	METER_PER_PIXEL  float64 = 1.0 / 20.0
	PHI_ZERO         float64 = omath.Pi * 0.5
)
 
var (
	l    float64 = float64(ANIMATION_HEIGHT) * 0.5
	freq float64 = omath.Sqrt(9.81 / (l * METER_PER_PIXEL))
)
 
type Pendulum interface {
	GetPhi() float64
}
 
type mathematicalPendulum struct {
	start time.Time
}
 
func (p *mathematicalPendulum) GetPhi() float64 {
	if (p.start == time.Time{}) {
		p.start = time.Now()
	}
	t := float64(time.Since(p.start).Nanoseconds()) / omath.Pow10(9)
	return PHI_ZERO * omath.Cos(t*freq)
}
 
type numericalPendulum struct {
	currentPhi float64
	angAcc     float64
	angVel     float64
	lastTime   time.Time
}
 
func (p *numericalPendulum) GetPhi() float64 {
	dt := 0.0
	if (p.lastTime != time.Time{}) {
		dt = float64(time.Since(p.lastTime).Nanoseconds()) / omath.Pow10(9)
	}
	p.lastTime = time.Now()
 
	p.angAcc = -9.81 / (float64(l) * METER_PER_PIXEL) * omath.Sin(p.currentPhi)
	p.angVel += p.angAcc * dt
	p.currentPhi += p.angVel * dt
 
	return p.currentPhi
}
 
func draw(p Pendulum, canvas gxui.Canvas, x, y int) {
	attachment := math.Point{X: ANIMATION_WIDTH/2 + x, Y: y}
 
	phi := p.GetPhi()
	ball := math.Point{X: x + ANIMATION_WIDTH/2 + math.Round(float32(l*omath.Sin(phi))), Y: y + math.Round(float32(l*omath.Cos(phi)))}
 
	line := gxui.Polygon{gxui.PolygonVertex{attachment, 0}, gxui.PolygonVertex{ball, 0}}
 
	canvas.DrawLines(line, gxui.DefaultPen)
 
	m := math.Point{int(BALL_RADIUS), int(BALL_RADIUS)}
	rect := math.Rect{ball.Sub(m), ball.Add(m)}
	canvas.DrawRoundedRect(rect, BALL_RADIUS, BALL_RADIUS, BALL_RADIUS, BALL_RADIUS, gxui.TransparentPen, gxui.CreateBrush(gxui.Yellow))
}
 
func appMain(driver gxui.Driver) {
	theme := dark.CreateTheme(driver)
 
	window := theme.CreateWindow(ANIMATION_WIDTH, 2*ANIMATION_HEIGHT, ""Pendulum"")
	window.SetBackgroundBrush(gxui.CreateBrush(gxui.Gray50))
 
	image := theme.CreateImage()
 
	ticker := time.NewTicker(time.Millisecond * 15)
	pendulum := &mathematicalPendulum{}
	pendulum2 := &numericalPendulum{PHI_ZERO, 0.0, 0.0, time.Time{}}
 
	go func() {
		for _ = range ticker.C {
			canvas := driver.CreateCanvas(math.Size{ANIMATION_WIDTH, 2 * ANIMATION_HEIGHT})
			canvas.Clear(gxui.White)
 
			draw(pendulum, canvas, 0, 0)
			draw(pendulum2, canvas, 0, ANIMATION_HEIGHT)
 
			canvas.Complete()
			driver.Call(func() {
				image.SetCanvas(canvas)
			})
		}
	}()
 
	window.AddChild(image)
 
	window.OnClose(ticker.Stop)
	window.OnClose(driver.Terminate)
}
 
func main() {
	gl.StartDriver(appMain)
}",2960,116
75918,http://rosettacode.org/wiki/Algebraic_data_types,Algebraic data types,"Some languages offer direct support for algebraic data types and pattern matching on them. While this of course can always be simulated with manual tagging and conditionals, it allows for terse code which is easy to read, and can represent the algorithm directly.



Task

As an example, implement insertion in a red-black-tree.

A red-black-tree is a binary tree where each internal node has a color attribute red or black. Moreover, no red node can have a red child, and every path from the root to an empty node must contain the same number of black nodes. As a consequence, the tree is balanced, and must be re-balanced after an insertion.




Reference

Red-Black Trees in a Functional Setting
",#Go,Go,"package main
 
import ""fmt""
 
type Color string
 
const (
    R Color = ""R""
    B       = ""B""
)
 
type Tree interface {
    ins(x int) Tree
}
 
type E struct{}
 
func (_ E) ins(x int) Tree {
    return T{R, E{}, x, E{}}
}
 
func (_ E) String() string {
    return ""E""
}
 
type T struct {
    cl Color
    le Tree
    aa int
    ri Tree
}
 
func (t T) balance() Tree {
    if t.cl != B {
        return t
    }
    le, leIsT := t.le.(T)
    ri, riIsT := t.ri.(T)
    var lele, leri, rile, riri T
    var leleIsT, leriIsT, rileIsT, ririIsT bool
    if leIsT {
        lele, leleIsT = le.le.(T)
    }
    if leIsT {
        leri, leriIsT = le.ri.(T)
    }
    if riIsT {
        rile, rileIsT = ri.le.(T)
    }
    if riIsT {
        riri, ririIsT = ri.ri.(T)
    }
    switch {
    case leIsT && leleIsT && le.cl == R && lele.cl == R:
        _, t2, z, d := t.destruct()
        _, t3, y, c := t2.(T).destruct()
        _, a, x, b := t3.(T).destruct()
        return T{R, T{B, a, x, b}, y, T{B, c, z, d}}
    case leIsT && leriIsT && le.cl == R && leri.cl == R:
        _, t2, z, d := t.destruct()
        _, a, x, t3 := t2.(T).destruct()
        _, b, y, c := t3.(T).destruct()
        return T{R, T{B, a, x, b}, y, T{B, c, z, d}}
    case riIsT && rileIsT && ri.cl == R && rile.cl == R:
        _, a, x, t2 := t.destruct()
        _, t3, z, d := t2.(T).destruct()
        _, b, y, c := t3.(T).destruct()
        return T{R, T{B, a, x, b}, y, T{B, c, z, d}}
    case riIsT && ririIsT && ri.cl == R && riri.cl == R:
        _, a, x, t2 := t.destruct()
        _, b, y, t3 := t2.(T).destruct()
        _, c, z, d := t3.(T).destruct()
        return T{R, T{B, a, x, b}, y, T{B, c, z, d}}
    default:
        return t
    }
}
 
func (t T) ins(x int) Tree {
    switch {
    case x < t.aa:
        return T{t.cl, t.le.ins(x), t.aa, t.ri}.balance()
    case x > t.aa:
        return T{t.cl, t.le, t.aa, t.ri.ins(x)}.balance()
    default:
        return t
    }
}
 
func (t T) destruct() (Color, Tree, int, Tree) {
    return t.cl, t.le, t.aa, t.ri
}
 
func (t T) String() string {
    return fmt.Sprintf(""T(%s, %v, %d, %v)"", t.cl, t.le, t.aa, t.ri)
}
 
func insert(tr Tree, x int) Tree {
    t := tr.ins(x)
    switch t.(type) {
    case T:
        tt := t.(T)
        _, a, y, b := tt.destruct()
        return T{B, a, y, b}
    case E:
        return E{}
    default:
        return nil
    }
}
 
func main() {
    var tr Tree = E{}
    for i := 1; i <= 16; i++ {
        tr = insert(tr, i)
    }
    fmt.Println(tr)
}",2515,118
75924,http://rosettacode.org/wiki/Amicable_pairs,Amicable pairs,"Two integers 



N


{\displaystyle N}

 and 



M


{\displaystyle M}

 are said to be amicable pairs if 



N
≠
M


{\displaystyle N\neq M}

 and the sum of the proper divisors of 



N


{\displaystyle N}

 (




s
u
m

(

p
r
o
p
D
i
v
s

(
N
)
)


{\displaystyle \mathrm {sum} (\mathrm {propDivs} (N))}

) 



=
M


{\displaystyle =M}

 as well as 




s
u
m

(

p
r
o
p
D
i
v
s

(
M
)
)
=
N


{\displaystyle \mathrm {sum} (\mathrm {propDivs} (M))=N}

.



Example

1184 and 1210 are an amicable pair, with proper divisors:

   1, 2, 4, 8, 16, 32, 37, 74, 148, 296, 592   and 
   1, 2, 5, 10, 11, 22, 55, 110, 121, 242, 605   respectively.


Task

Calculate and show here the Amicable pairs below 20,000; (there are eight).



Related tasks
 Proper divisors
 Abundant, deficient and perfect number classifications
 Aliquot sequence classifications and its amicable classification. 

",#Go,Go,"package main
 
import ""fmt""
 
func pfacSum(i int) int {
    sum := 0
    for p := 1; p <= i/2; p++ {
        if i%p == 0 {
            sum += p
        }
    }
    return sum
}
 
func main() {
    var a[20000]int
    for i := 1; i < 20000; i++ {
        a[i] = pfacSum(i)
    }
    fmt.Println(""The amicable pairs below 20,000 are:"")
    for n := 2; n < 19999; n++ {
        m := a[n]
        if m > n && m < 20000 && n == a[m] {
            fmt.Printf(""  %5d and %5d\n"", n, m)
        } 
    }
}",496,27
75952,http://rosettacode.org/wiki/Active_Directory/Search_for_a_user,Active Directory/Search for a user,"Make sure you Connect to Active Directory
",#Go,Go,"package main
 
import (
    ""log""
    ""github.com/jtblin/go-ldap-client""
)
 
func main() {
    client := &ldap.LDAPClient{
        Base:        ""dc=example,dc=com"",
        Host:        ""ldap.example.com"",
        Port:        389,
        GroupFilter: ""(memberUid=%s)"",
    }
    defer client.Close()
    err := client.Connect()
    if err != nil { 
        log.Fatalf(""Failed to connect : %+v"", err)
    }
    groups, err := client.GetGroupsOfUser(""username"")
    if err != nil {
        log.Fatalf(""Error getting groups for user %s: %+v"", ""username"", err)
    }
    log.Printf(""Groups: %+v"", groups) 
}",605,25
76049,http://rosettacode.org/wiki/Active_Directory/Connect,Active Directory/Connect,"The task is to establish a connection to an Active Directory or Lightweight Directory Access Protocol server.
",#Go,Go,"package main
 
import (
    ""log""
    ""github.com/jtblin/go-ldap-client""
)
 
func main() {
    client := &ldap.LDAPClient{
        Base:         ""dc=example,dc=com"",
        Host:         ""ldap.example.com"",
        Port:         389,
        UseSSL:       false,
        BindDN:       ""uid=readonlyuser,ou=People,dc=example,dc=com"",
        BindPassword: ""readonlypassword"",
        UserFilter:   ""(uid=%s)"",
        GroupFilter:  ""(memberUid=%s)"",
        Attributes:   []string{""givenName"", ""sn"", ""mail"", ""uid""},
    }
    defer client.Close()
    err := client.Connect()
    if err != nil { 
        log.Fatalf(""Failed to connect : %+v"", err)
    }
    // Do something
}",674,26
76088,http://rosettacode.org/wiki/Add_a_variable_to_a_class_instance_at_runtime,Add a variable to a class instance at runtime,"Demonstrate how to dynamically add variables to an object (a class instance) at runtime.

This is useful when the methods/variables of an instance are based on a data file that isn't available until runtime. Hal Fulton gives an example of creating an OO CSV parser at An Exercise in Metaprogramming with Ruby. This is referred to as ""monkeypatching"" by Pythonistas and some others.
",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""log""
    ""os""
)
 
type SomeStruct struct {
    runtimeFields map[string]string
}
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
func main() {
    ss := SomeStruct{make(map[string]string)}
    scanner := bufio.NewScanner(os.Stdin)
    fmt.Println(""Create two fields at runtime: "")
    for i := 1; i <= 2; i++ {
        fmt.Printf(""  Field #%d:\n"", i)
        fmt.Print(""       Enter name  : "")
        scanner.Scan()
        name := scanner.Text()
        fmt.Print(""       Enter value : "")
        scanner.Scan()
        value := scanner.Text()
        check(scanner.Err())
        ss.runtimeFields[name] = value
        fmt.Println()
    }
    for {
        fmt.Print(""Which field do you want to inspect ? "")
        scanner.Scan()
        name := scanner.Text()
        check(scanner.Err())
        value, ok := ss.runtimeFields[name]
        if !ok {
            fmt.Println(""There is no field of that name, try again"")
        } else {
            fmt.Printf(""Its value is '%s'\n"", value)
            return
        }
    }
}",1112,49
76090,http://rosettacode.org/wiki/Address_of_a_variable,Address of a variable,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses




Task

Demonstrate how to get the address of a variable and how to set the address of a variable.



",#Go,Go,"package main
 
import (
	""fmt""
	""unsafe""
)
 
func main() {
	myVar := 3.14
	myPointer := &myVar
	fmt.Println(""Address:"", myPointer, &myVar)
	fmt.Printf(""Address: %p %p\n"", myPointer, &myVar)
 
	var addr64 int64
	var addr32 int32
	ptr := unsafe.Pointer(myPointer)
	if unsafe.Sizeof(ptr) <= unsafe.Sizeof(addr64) {
		addr64 = int64(uintptr(ptr))
		fmt.Printf(""Pointer stored in   int64: %#016x\n"", addr64)
	}
	if unsafe.Sizeof(ptr) <= unsafe.Sizeof(addr32) {
		// Only runs on architectures where a pointer is <= 32 bits
		addr32 = int32(uintptr(ptr))
		fmt.Printf(""Pointer stored in   int32: %#08x\n"", addr32)
	}
	addr := uintptr(ptr)
	fmt.Printf(""Pointer stored in uintptr: %#08x\n"", addr)
 
	fmt.Println(""value as float:"", myVar)
	i := (*int32)(unsafe.Pointer(&myVar))
	fmt.Printf(""value as int32: %#08x\n"", *i)
}",813,32
76193,http://rosettacode.org/wiki/Almost_prime,Almost prime,"A   k-Almost-prime   is a natural number   



n


{\displaystyle n}

   that is the product of   



k


{\displaystyle k}

   (possibly identical) primes.



Example

1-almost-primes,   where   



k
=
1


{\displaystyle k=1}

,   are the prime numbers themselves.

2-almost-primes,   where   



k
=
2


{\displaystyle k=2}

,   are the   semiprimes.



Task

Write a function/method/subroutine/... that generates k-almost primes and use it to create a table here of the first ten members of k-Almost primes for   



1
<=
K
<=
5


{\displaystyle 1<=K<=5}

.



Related tasks

   Semiprime
   Category:Prime Numbers

",#Go,Go,"package main
 
import ""fmt""
 
func kPrime(n, k int) bool {
    nf := 0
    for i := 2; i <= n; i++ {
        for n%i == 0 {
            if nf == k {
                return false
            }
            nf++
            n /= i
        }
    }
    return nf == k
}
 
func gen(k, n int) []int {
    r := make([]int, n)
    n = 2
    for i := range r {
        for !kPrime(n, k) {
            n++
        }
        r[i] = n
        n++
    }
    return r
}
 
func main() {
    for k := 1; k <= 5; k++ {
        fmt.Println(k, gen(k, 10))
    }
}",543,36
76236,http://rosettacode.org/wiki/Achilles_numbers,Achilles numbers,"

 This page uses content from Wikipedia. The original article was at Achilles number. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



An Achilles number is a number that is powerful but imperfect. Named after Achilles, a hero of the Trojan war, who was also powerful but imperfect.



A positive integer n is a powerful number if, for every prime factor p of n, p2 is also a divisor.

In other words, every prime factor appears at least squared in the factorization.

All Achilles numbers are powerful. However, not all powerful numbers are Achilles numbers: only those that cannot be represented as mk, where m and k are positive integers greater than 1.



A strong Achilles number is an Achilles number whose Euler totient (𝜑) is also an Achilles number.



E.G.
108 is a powerful number. Its prime factorization is 22 × 33, and thus its prime factors are 2 and 3. Both 22 = 4 and 32 = 9 are divisors of 108. However, 108 cannot be represented as mk, where m and k are positive integers greater than 1, so 108 is an Achilles number.

360 is not an Achilles number because it is not powerful. One of its prime factors is 5 but 360 is not divisible by 52 = 25.

Finally, 784 is not an Achilles number. It is a powerful number, because not only are 2 and 7 its only prime factors, but also 22 = 4 and 72 = 49 are divisors of it. Nonetheless, it is a perfect power; its square root is an even integer, so it is not an Achilles number.


500 = 22 × 53 is a strong Achilles number as its Euler totient, 𝜑(500), is 200 = 23 × 52 which is also an Achilles number.



Task
 Find and show the first 50 Achilles numbers.
 Find and show at least the first 20 strong Achilles numbers.
 For at least 2 through 5, show the count of Achilles numbers with that many digits.


See also
 Wikipedia: Achilles number
 OEIS:A052486 - Achilles numbers - powerful but imperfect numbers
 OEIS:A194085 - Strong Achilles numbers: Achilles numbers m such that phi(m) is also an Achilles number
 Related task: Powerful numbers
 Related task: Totient function

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""sort""
)
 
func totient(n int) int {
    tot := n
    i := 2
    for i*i <= n {
        if n%i == 0 {
            for n%i == 0 {
                n /= i
            }
            tot -= tot / i
        }
        if i == 2 {
            i = 1
        }
        i += 2
    }
    if n > 1 {
        tot -= tot / n
    }
    return tot
}
 
var pps = make(map[int]bool)
 
func getPerfectPowers(maxExp int) {
    upper := math.Pow(10, float64(maxExp))
    for i := 2; i <= int(math.Sqrt(upper)); i++ {
        fi := float64(i)
        p := fi
        for {
            p *= fi
            if p >= upper {
                break
            }
            pps[int(p)] = true
        }
    }
}
 
func getAchilles(minExp, maxExp int) map[int]bool {
    lower := math.Pow(10, float64(minExp))
    upper := math.Pow(10, float64(maxExp))
    achilles := make(map[int]bool)
    for b := 1; b <= int(math.Cbrt(upper)); b++ {
        b3 := b * b * b
        for a := 1; a <= int(math.Sqrt(upper)); a++ {
            p := b3 * a * a
            if p >= int(upper) {
                break
            }
            if p >= int(lower) {
                if _, ok := pps[p]; !ok {
                    achilles[p] = true
                }
            }
        }
    }
    return achilles
}
 
func main() {
    maxDigits := 15
    getPerfectPowers(maxDigits)
    achillesSet := getAchilles(1, 5) // enough for first 2 parts
    achilles := make([]int, len(achillesSet))
    i := 0
    for k := range achillesSet {
        achilles[i] = k
        i++
    }
    sort.Ints(achilles)
 
    fmt.Println(""First 50 Achilles numbers:"")
    for i = 0; i < 50; i++ {
        fmt.Printf(""%4d "", achilles[i])
        if (i+1)%10 == 0 {
            fmt.Println()
        }
    }
 
    fmt.Println(""\nFirst 30 strong Achilles numbers:"")
    var strongAchilles []int
    count := 0
    for n := 0; count < 30; n++ {
        tot := totient(achilles[n])
        if _, ok := achillesSet[tot]; ok {
            strongAchilles = append(strongAchilles, achilles[n])
            count++
        }
    }
    for i = 0; i < 30; i++ {
        fmt.Printf(""%5d "", strongAchilles[i])
        if (i+1)%10 == 0 {
            fmt.Println()
        }
    }
 
    fmt.Println(""\nNumber of Achilles numbers with:"")
    for d := 2; d <= maxDigits; d++ {
        ac := len(getAchilles(d-1, d))
        fmt.Printf(""%2d digits: %d\n"", d, ac)
    }
}",2436,110
76257,http://rosettacode.org/wiki/Amb,Amb,"Define and give an example of the Amb operator.

The Amb operator (short for ""ambiguous"") expresses nondeterminism. This doesn't refer to randomness (as in ""nondeterministic universe"") but is closely related to the term as it is used in automata theory (""non-deterministic finite automaton"").

The Amb operator takes a variable number of expressions (or values if that's simpler in the language) and yields a correct one which will satisfy a constraint in some future computation, thereby avoiding failure.

Problems whose solution the Amb operator naturally expresses can be approached with other tools, such as explicit nested iterations over data sets, or with pattern matching. By contrast, the Amb operator appears integrated into the language. Invocations of Amb are not wrapped in any visible loops or other search patterns; they appear to be independent.

Essentially Amb(x, y, z) splits the computation into three possible futures: a future in which the value x is yielded, a future in which the value y is yielded and a future in which the value z is yielded. The future which leads to a successful subsequent computation is chosen. The other ""parallel universes"" somehow go away. Amb called with no arguments fails.

For simplicity, one of the domain values usable with Amb may denote failure, if that is convenient. For instance, it is convenient if a Boolean false denotes failure, so that Amb(false) fails, and thus constraints can be expressed using Boolean expressions like Amb(x * y == 8) which unless x and y add to four.

A pseudo-code program which satisfies this constraint might look like:

let x = Amb(1, 2, 3)
let y = Amb(7, 6, 4, 5)
Amb(x * y = 8)
print x, y
The output is 2 4 because Amb(1, 2, 3) correctly chooses the future in which x has value 2, Amb(7, 6, 4, 5) chooses 4 and consequently Amb(x * y = 8) produces a success.

Alternatively, failure could be represented using strictly Amb():

unless x * y = 8 do Amb()
Or else Amb could take the form of two operators or functions: one for producing values and one for enforcing constraints:

let x = Ambsel(1, 2, 3)
let y = Ambsel(4, 5, 6)
Ambassert(x * y = 8)
print x, y
where Ambassert behaves like Amb() if the Boolean expression is false, otherwise it allows the future computation to take place, without yielding any value.

The task is to somehow implement Amb, and demonstrate it with a program which chooses one word from each of the following four sets of character strings to generate a four-word sentence:

""the"" ""that"" ""a""
""frog"" ""elephant"" ""thing""
""walked"" ""treaded"" ""grows""
""slowly"" ""quickly""
The constraint to be satisfied is that the last character of each word (other than the last) is the same as the first character of its successor.

The only successful sentence is ""that thing grows slowly""; other combinations do not satisfy the constraint and thus fail.

The goal of this task isn't to simply process the four lists of words with explicit, deterministic program flow such as nested iteration, to trivially demonstrate the correct output. The goal is to implement the Amb operator, or a facsimile thereof that is possible within the language limitations.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""sync""
)
 
func ambStrings(ss []string) chan []string {
    c := make(chan []string)
    go func() {
        for _, s := range ss {
            c <- []string{s}
        }
        close(c)
    }()
    return c
}
 
func ambChain(ss []string, cIn chan []string) chan []string {
    cOut := make(chan []string)
    go func() {
        var w sync.WaitGroup
        for chain := range cIn {
            w.Add(1)
            go func(chain []string) {
                for s1 := range ambStrings(ss) {
                    if s1[0][len(s1[0])-1] == chain[0][0] {
                        cOut <- append(s1, chain...)
                    }
                }
                w.Done()
            }(chain)
        }
        w.Wait()
        close(cOut)
    }()
    return cOut
}
 
func main() {
    s1 := []string{""the"", ""that"", ""a""}
    s2 := []string{""frog"", ""elephant"", ""thing""}
    s3 := []string{""walked"", ""treaded"", ""grows""}
    s4 := []string{""slowly"", ""quickly""}
    c := ambChain(s1, ambChain(s2, ambChain(s3, ambStrings(s4))))
    for s := range c {
        fmt.Println(s)
    }
}",1114,49
76295,http://rosettacode.org/wiki/Aliquot_sequence_classifications,Aliquot sequence classifications,"An aliquot sequence of a positive integer K is defined recursively as the first member
being K and subsequent members being the sum of the Proper divisors of the previous term.

 If the terms eventually reach 0 then the series for K is said to terminate.

There are several classifications for non termination:
 If the second term is K then all future terms are also K and so the sequence repeats from the first term with period 1 and K is called perfect.
 If the third term would be repeating K then the sequence repeats with period 2 and K is called amicable.
 If the Nth term would be repeating K for the first time, with N > 3 then the sequence repeats with period N - 1 and K is called sociable.

Perfect, amicable and sociable numbers eventually repeat the original number K; there are other repetitions...
 Some K have a sequence that eventually forms a periodic repetition of period 1 but of a number other than K, for example 95 which forms the sequence 95, 25, 6, 6, 6, ... such K are called aspiring.
 K that have a sequence that eventually forms a periodic repetition of period >= 2 but of a number other than K, for example 562 which forms the sequence 562, 284, 220, 284, 220, ... such K are called cyclic.

And finally:
 Some K form aliquot sequences that are not known to be either terminating or periodic; these K are to be called non-terminating. 
For the purposes of this task, K is to be classed as non-terminating if it has not been otherwise classed after generating 16 terms or if any term of the sequence is greater than 2**47 = 140,737,488,355,328. 


Task

 Create routine(s) to generate the aliquot sequence of a positive integer enough to classify it according to the classifications given above.
 Use it to display the classification and sequences of the numbers one to ten inclusive.
 Use it to show the classification and sequences of the following integers, in order:
 11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488, and optionally 15355717786080.
Show all output on this page.



Related tasks

   Abundant, deficient and perfect number classifications. (Classifications from only the first two members of the whole sequence).
   Proper divisors
   Amicable pairs

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""strings""
)
 
const threshold = uint64(1) << 47
 
func indexOf(s []uint64, search uint64) int {
    for i, e := range s {
        if e == search {
            return i
        }
    }
    return -1
}
 
func contains(s []uint64, search uint64) bool {
    return indexOf(s, search) > -1
}
 
func maxOf(i1, i2 int) int {
    if i1 > i2 {
        return i1
    }
    return i2
}
 
func sumProperDivisors(n uint64) uint64 {
    if n < 2 {
        return 0
    }
    sqrt := uint64(math.Sqrt(float64(n)))
    sum := uint64(1)
    for i := uint64(2); i <= sqrt; i++ {
        if n % i != 0 {
            continue
        }
        sum += i + n / i
    }
    if sqrt * sqrt == n {
        sum -= sqrt
    }
    return sum
}
 
func classifySequence(k uint64) ([]uint64, string) {
    if k == 0 {
        panic(""Argument must be positive."")
    }
    last := k
    var seq []uint64
    seq = append(seq, k)
    for {
        last = sumProperDivisors(last)
        seq = append(seq, last)
        n := len(seq)
        aliquot := """"
        switch {
        case last == 0:
            aliquot = ""Terminating""
        case n == 2 && last == k:
            aliquot = ""Perfect""
        case n == 3 && last == k:
            aliquot = ""Amicable""
        case n >= 4 && last == k:
            aliquot = fmt.Sprintf(""Sociable[%d]"", n - 1)
        case last == seq[n - 2]:
            aliquot = ""Aspiring""
        case contains(seq[1 : maxOf(1, n - 2)], last):
            aliquot = fmt.Sprintf(""Cyclic[%d]"", n - 1 - indexOf(seq[:], last))
        case n == 16 || last > threshold:
            aliquot = ""Non-Terminating""
        }
        if aliquot != """" {
            return seq, aliquot
        }
    }
}
 
func joinWithCommas(seq []uint64) string {
    res := fmt.Sprint(seq)
    res = strings.Replace(res, "" "", "", "", -1)
    return res
}
 
func main() {
    fmt.Println(""Aliquot classifications - periods for Sociable/Cyclic in square brackets:\n"")
    for k := uint64(1); k <= 10; k++ {
        seq, aliquot := classifySequence(k)
        fmt.Printf(""%2d: %-15s %s\n"", k, aliquot, joinWithCommas(seq))
    }
    fmt.Println()
 
    s := []uint64{
        11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488,
    }
    for _, k := range s {
        seq, aliquot := classifySequence(k)
        fmt.Printf(""%7d: %-15s %s\n"",  k, aliquot, joinWithCommas(seq))
    }
    fmt.Println()
 
    k := uint64(15355717786080)
    seq, aliquot := classifySequence(k)
    fmt.Printf(""%d: %-15s %s\n"", k, aliquot, joinWithCommas(seq))
}",2578,109
76332,http://rosettacode.org/wiki/Additive_primes,Additive primes,"Definitions
In mathematics, additive primes are prime numbers for which the sum of their decimal digits are also primes.



Task
Write a program to determine (and show here) all additive primes less than 500.

Optionally, show the number of additive primes.



Also see

   the OEIS entry:   A046704 additive primes.
   the prime-numbers entry:   additive primes.
   the geeks for geeks entry: additive prime number.
   the prime-numbers fandom: additive primes.

",#Go,Go,"package main
 
import ""fmt""
 
func isPrime(n int) bool {
    switch {
    case n < 2:
        return false
    case n%2 == 0:
        return n == 2
    case n%3 == 0:
        return n == 3
    default:
        d := 5
        for d*d <= n {
            if n%d == 0 {
                return false
            }
            d += 2
            if n%d == 0 {
                return false
            }
            d += 4
        }
        return true
    }
}
 
func sumDigits(n int) int {
    sum := 0
    for n > 0 {
        sum += n % 10
        n /= 10
    }
    return sum
}
 
func main() {
    fmt.Println(""Additive primes less than 500:"")
    i := 2
    count := 0
    for {
        if isPrime(i) && isPrime(sumDigits(i)) {
            count++
            fmt.Printf(""%3d  "", i)
            if count%10 == 0 {
                fmt.Println()
            }
        }
        if i > 2 {
            i += 2
        } else {
            i++
        }
        if i > 499 {
            break
        }
    }
    fmt.Printf(""\n\n%d additive primes found.\n"", count)
}",1059,60
76480,http://rosettacode.org/wiki/Active_object,Active object,"In object-oriented programming an object is active when its state depends on clock. Usually an active object encapsulates a task that updates the object's state. To the outer world the object looks like a normal object with methods that can be called from outside. Implementation of such methods must have a certain synchronization mechanism with the encapsulated task in order to prevent object's state corruption.

A typical instance of an active object is an animation widget. The widget state changes with the time, while as an object it has all properties of a normal widget.

The task

Implement an active integrator object. The object has an input and output. The input can be set using the method Input. The input is a function of time. The output can be queried using the method Output. The object integrates its input over the time and the result becomes the object's output. So if the input is K(t) and the output is S, the object state S is changed to S + (K(t1) + K(t0)) * (t1 - t0) / 2, i.e. it integrates K using the trapeze method. Initially K is constant 0 and S is 0.

In order to test the object:

 set its input to sin (2π f t), where the frequency f=0.5Hz. The phase is irrelevant.
 wait 2s
 set the input to constant 0
 wait 0.5s
Verify that now the object's output is approximately 0 (the sine has the period of 2s). The accuracy of the result will depend on the OS scheduler time slicing and the accuracy of the clock.
",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""time""
)
 
// type for input function, k.
// input is duration since an arbitrary start time t0.
type tFunc func(time.Duration) float64
 
// active integrator object.  state variables are not here, but in
// function aif, started as a goroutine in the constructor.
type aio struct {
    iCh chan tFunc        // channel for setting input function
    oCh chan chan float64 // channel for requesting output
}
 
// constructor
func newAio() *aio {
    var a aio
    a.iCh = make(chan tFunc)
    a.oCh = make(chan chan float64)
    go aif(&a)
    return &a
}
 
// input method required by task description.  in practice, this method is
// unnecessary; you would just put that single channel send statement in
// your code wherever you wanted to set the input function.
func (a aio) input(f tFunc) {
    a.iCh <- f
}
 
// output method required by task description.  in practice, this method too
// would not likely be best.  instead any client interested in the value would
// likely make a return channel sCh once, and then reuse it as needed.
func (a aio) output() float64 {
    sCh := make(chan float64)
    a.oCh <- sCh
    return <-sCh
}
 
// integration function that returns constant 0
func zeroFunc(time.Duration) float64 { return 0 }
 
// goroutine serializes access to integrated function k and state variable s
func aif(a *aio) {
    var k tFunc = zeroFunc // integration function
    s := 0.                // ""object state"" initialized to 0
    t0 := time.Now()       // initial time
    k0 := k(0)             // initial sample value
    t1 := t0               // t1, k1 used for trapezoid formula
    k1 := k0
 
    tk := time.Tick(10 * time.Millisecond) // 10 ms -> 100 Hz
    for {
        select {
        case t2 := <-tk: // timer tick event
            k2 := k(t2.Sub(t0))                        // new sample value
            s += (k1 + k2) * .5 * t2.Sub(t1).Seconds() // trapezoid formula
            t1, k1 = t2, k2                            // save time and value
        case k = <-a.iCh: // input method event: function change
        case sCh := <-a.oCh: // output method event: sample object state
            sCh <- s
        }
    }
}
 
func main() {
    a := newAio()                           // create object
    a.input(func(t time.Duration) float64 { // 1. set input to sin function
        return math.Sin(t.Seconds() * math.Pi)
    })
    time.Sleep(2 * time.Second) // 2. sleep 2 sec
    a.input(zeroFunc)           // 3. set input to zero function
    time.Sleep(time.Second / 2) // 4. sleep .5 sec
    fmt.Println(a.output())     // output should be near zero
}",2649,80
76531,http://rosettacode.org/wiki/AKS_test_for_primes,AKS test for primes,"The AKS algorithm for testing whether a number is prime is a polynomial-time algorithm based on an elementary theorem about Pascal triangles.

The theorem on which the test is based can be stated as follows:

   a number   



p


{\displaystyle p}

   is prime   if and only if   all the coefficients of the polynomial expansion of
 



(
x
−
1

)

p


−
(

x

p


−
1
)


{\displaystyle (x-1)^{p}-(x^{p}-1)}


are divisible by   



p


{\displaystyle p}

.



Example

Using   



p
=
3


{\displaystyle p=3}

:

         (x-1)^3 - (x^3 - 1)
            = (x^3 - 3x^2 + 3x - 1) - (x^3 - 1)
            = -3x^2 + 3x



And all the coefficients are divisible by 3,   so 3 is prime.





 Note:
This task is not the AKS primality test.   It is an inefficient exponential time algorithm discovered in the late 1600s and used as an introductory lemma in the AKS derivation.



Task



 Create a function/subroutine/method that given   



p


{\displaystyle p}

   generates the coefficients of the expanded polynomial representation of   



(
x
−
1

)

p




{\displaystyle (x-1)^{p}}

.
 Use the function to show here the polynomial expansions of   



(
x
−
1

)

p




{\displaystyle (x-1)^{p}}

   for   



p


{\displaystyle p}

   in the range   0   to at least   7,   inclusive.
 Use the previous function in creating another function that when given   



p


{\displaystyle p}

   returns whether   



p


{\displaystyle p}

   is prime using the theorem.
 Use your test to generate a list of all primes under   35.
 As a stretch goal,   generate all primes under   50   (needs integers larger than 31-bit).


References

 Agrawal-Kayal-Saxena (AKS) primality test (Wikipedia) 
 Fool-Proof Test for Primes - Numberphile (Video). The accuracy of this video is disputed -- at best it is an oversimplification.

",#Go,Go,"package main
 
import ""fmt""
 
func bc(p int) []int64 {
    c := make([]int64, p+1)
    r := int64(1)
    for i, half := 0, p/2; i <= half; i++ {
        c[i] = r
        c[p-i] = r
        r = r * int64(p-i) / int64(i+1)
    }
    for i := p - 1; i >= 0; i -= 2 {
        c[i] = -c[i]
    }
    return c
}
 
func main() {
    for p := 0; p <= 7; p++ {
        fmt.Printf(""%d:  %s\n"", p, pp(bc(p)))
    }
    for p := 2; p < 50; p++ {
        if aks(p) {
            fmt.Print(p, "" "")
        }
    }
    fmt.Println()
}
 
var e = []rune(""²³⁴⁵⁶⁷"")
 
func pp(c []int64) (s string) {
    if len(c) == 1 {
        return fmt.Sprint(c[0])
    }
    p := len(c) - 1
    if c[p] != 1 {
        s = fmt.Sprint(c[p])
    }
    for i := p; i > 0; i-- {
        s += ""x""
        if i != 1 {
            s += string(e[i-2])
        }
        if d := c[i-1]; d < 0 {
            s += fmt.Sprintf("" - %d"", -d)
        } else {
            s += fmt.Sprintf("" + %d"", d)
        }
    }
    return
}
 
func aks(p int) bool {
    c := bc(p)
    c[p]--
    c[0]++
    for _, d := range c {
        if d%int64(p) != 0 {
            return false
        }
    }
    return true
}",1158,65
76679,http://rosettacode.org/wiki/Accumulator_factory,Accumulator factory,"A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).



Rules

The detailed rules are at http://paulgraham.com/accgensub.html and are reproduced here for simplicity (with additions in small italic text).

Before you submit an example, make sure the function
 Takes a number n and returns a function (lets call it g), that takes a number i, and returns n incremented by the accumulation of i from every call of function g(i).
Although these exact function and parameter names need not be used
 Works for any numeric type-- i.e. can take both ints and floats and returns functions that can take both ints and floats. (It is not enough simply to convert all input to floats. An accumulator that has only seen integers must return integers.) (i.e., if the language doesn't allow for numeric polymorphism, you have to use overloading or something like that)
 Generates functions that return the sum of every number ever passed to them, not just the most recent. (This requires a piece of state to hold the accumulated value, which in turn means that pure functional languages can't be used for this task.)
 Returns a real function, meaning something that you can use wherever you could use a function you had defined in the ordinary way in the text of your program. (Follow your language's conventions here.)
 Doesn't store the accumulated value or the returned functions in a way that could cause them to be inadvertently modified by other code. (No global variables or other such things.)
 E.g. if after the example, you added the following code (in a made-up language) where the factory function is called foo:
 x = foo(1); 
x(5); 
foo(3);
print x(2.3);
 It should print 8.3. (There is no need to print the form of the accumulator function returned by foo(3); it's not part of the task at all.)


Task

Create a function that implements the described rules.



It need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a closure, providing the language supports them.

Where it is not possible to hold exactly to the constraints above, describe the deviations.



",#Go,Go,"package main
 
import ""fmt""
 
func accumulator(sum interface{}) func(interface{}) interface{} {
    return func(nv interface{}) interface{} {
        switch s := sum.(type) {
        case int:
            switch n := nv.(type) {
            case int:
                sum = s + n
            case float64:
                sum = float64(s) + n
            }
        case float64:
            switch n := nv.(type) {
            case int:
                sum = s + float64(n)
            case float64:
                sum = s + n
            }
        default:
            sum = nv
        }
        return sum
    }
}
 
func main() {
    x := accumulator(1)
    x(5)
    accumulator(3)
    fmt.Println(x(2.3))
}",709,34
76746,http://rosettacode.org/wiki/Anagrams,Anagrams,"When two or more words are composed of the same characters, but in a different order, they are called anagrams.

Task[edit]
Using the word list at   http://wiki.puzzlers.org/pub/wordlists/unixdict.txt,

find the sets of words that share the same characters that contain the most words in them.

Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""bytes""
    ""fmt""
    ""io/ioutil""
    ""net/http""
    ""sort""
)
 
func main() {
    r, err := http.Get(""http://wiki.puzzlers.org/pub/wordlists/unixdict.txt"")
    if err != nil {
        fmt.Println(err)
        return
    }
    b, err := ioutil.ReadAll(r.Body)
    r.Body.Close()
    if err != nil {
        fmt.Println(err)
        return
    }
    var ma int
    var bs byteSlice
    m := make(map[string][][]byte)
    for _, word := range bytes.Fields(b) {
        bs = append(bs[:0], byteSlice(word)...)
        sort.Sort(bs)
        k := string(bs)
        a := append(m[k], word)
        if len(a) > ma {
            ma = len(a)
        }
        m[k] = a
    }
    for _, a := range m {
        if len(a) == ma {
            fmt.Printf(""%s\n"", a)
        }
    }
}
 
type byteSlice []byte
 
func (b byteSlice) Len() int           { return len(b) }
func (b byteSlice) Swap(i, j int)      { b[i], b[j] = b[j], b[i] }
func (b byteSlice) Less(i, j int) bool { return b[i] < b[j] }",1009,47
76953,http://rosettacode.org/wiki/Align_columns,Align columns,"Given a text file of many lines, where fields within a line
are delineated by a single 'dollar' character, write a program
that aligns each column of fields by ensuring that words in each
column are separated by at least one space.
Further, allow for each word in a column to be either left
justified, right justified, or center justified within its column.

Use the following text to test your programs:

Given$a$text$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.


Note that:

   The example input texts lines may, or may not, have trailing dollar characters.
   All columns should share the same alignment.
   Consecutive space characters produced adjacent to the end of lines are insignificant for the purposes of the task.
   Output text will be viewed in a mono-spaced font on a plain text editor or basic terminal.
   The minimum space between columns should be computed from the text and not hard-coded.
   It is not a requirement to add separating characters between or around columns.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
const text = `Given$a$text$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.`
 
type formatter struct {
    text  [][]string
    width []int
}
 
func newFormatter(text string) *formatter {
    var f formatter
    for _, line := range strings.Split(text, ""\n"") {
        words := strings.Split(line, ""$"")
        for words[len(words)-1] == """" {
            words = words[:len(words)-1]
        }
        f.text = append(f.text, words)
        for i, word := range words {
            if i == len(f.width) {
                f.width = append(f.width, len(word))
            } else if len(word) > f.width[i] {
                f.width[i] = len(word)
            }
        }
    }
    return &f
}
 
const (
    left = iota
    middle
    right
)
 
func (f formatter) print(j int) {
    for _, line := range f.text {
        for i, word := range line {
            fmt.Printf(""%-*s "", f.width[i], fmt.Sprintf(""%*s"",
                len(word)+(f.width[i]-len(word))*j/2, word))
        }
        fmt.Println("""")
    }
    fmt.Println("""")
}
 
func main() {
    f := newFormatter(text)
    f.print(left)
    f.print(middle)
    f.print(right)
}",1484,61
77019,"http://rosettacode.org/wiki/Abundant,_deficient_and_perfect_number_classifications","Abundant, deficient and perfect number classifications","These define three classifications of positive integers based on their   proper divisors.

Let   P(n)   be the sum of the proper divisors of   n   where the proper divisors are all positive divisors of   n   other than   n   itself.

   if    P(n) <  n    then  n  is classed as  deficient  (OEIS A005100).
   if    P(n) == n    then  n  is classed as  perfect    (OEIS A000396).
   if    P(n) >  n    then  n  is classed as  abundant   (OEIS A005101).



Example

6   has proper divisors of   1,   2,   and   3.

1 + 2 + 3 = 6,   so   6   is classed as a perfect number.



Task

Calculate how many of the integers   1   to   20,000   (inclusive) are in each of the three classes.

Show the results here.



Related tasks

   Aliquot sequence classifications.   (The whole series from which this task is a subset.)
   Proper divisors
   Amicable pairs

",#Go,Go,"package main
 
import ""fmt""
 
func pfacSum(i int) int {
    sum := 0
    for p := 1; p <= i/2; p++ {
        if i%p == 0 {
            sum += p
        }
    }
    return sum
}
 
func main() {
    var d, a, p = 0, 0, 0
    for i := 1; i <= 20000; i++ {
        j := pfacSum(i)
        if j < i {
            d++
        } else if j == i {
            p++
        } else {
            a++
        }
    }
    fmt.Printf(""There are %d deficient numbers between 1 and 20000\n"", d)
    fmt.Printf(""There are %d abundant numbers  between 1 and 20000\n"", a)
    fmt.Printf(""There are %d perfect numbers between 1 and 20000\n"", p)
}",625,30
77284,http://rosettacode.org/wiki/Ackermann_function,Ackermann function,"The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.



The Ackermann function is usually defined as follows:







A
(
m
,
n
)
=


{



n
+
1



if 

m
=
0




A
(
m
−
1
,
1
)



if 

m
>
0

 and 

n
=
0




A
(
m
−
1
,
A
(
m
,
n
−
1
)
)



if 

m
>
0

 and 

n
>
0.








{\displaystyle A(m,n)={\begin{cases}n+1&{\mbox{if }}m=0\\A(m-1,1)&{\mbox{if }}m>0{\mbox{ and }}n=0\\A(m-1,A(m,n-1))&{\mbox{if }}m>0{\mbox{ and }}n>0.\end{cases}}}






Its arguments are never negative and it always terminates.



Task

Write a function which returns the value of 



A
(
m
,
n
)


{\displaystyle A(m,n)}

. Arbitrary precision is preferred (since the function grows so quickly), but not required.



See also

 Conway chained arrow notation for the Ackermann function.

",#Go,Go,"func Ackermann(m, n uint) uint {
	switch 0 {
	case m:
		return n + 1
	case n:
		return Ackermann(m - 1, 1)
	}
	return Ackermann(m - 1, Ackermann(m, n - 1))
}",157,9
77429,http://rosettacode.org/wiki/Abelian_sandpile_model,Abelian sandpile model,"

 This page uses content from Wikipedia. The original article was at Abelian sandpile model. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Implement the Abelian sandpile model also known as Bak–Tang–Wiesenfeld model. Its history, mathematical definition and properties can be found under its wikipedia article.

The task requires the creation of a 2D grid of arbitrary size on which ""piles of sand"" can be placed. Any ""pile"" that has 4 or more sand particles on it collapses, resulting in four particles being subtracted from the pile and distributed among its neighbors.

It is recommended to display the output in some kind of image format, as terminal emulators are usually too small to display images larger than a few dozen characters tall. As an example of how to accomplish this, see the Bitmap/Write a PPM file task.

Examples up to 2^30, wow!
javascript running on web
Examples:

0 0 0 0 0    0 0 0 0 0
0 0 0 0 0    0 0 1 0 0
0 0 4 0 0 -> 0 1 0 1 0
0 0 0 0 0    0 0 1 0 0
0 0 0 0 0    0 0 0 0 0

0 0 0 0 0    0 0 0 0 0
0 0 0 0 0    0 0 1 0 0
0 0 6 0 0 -> 0 1 2 1 0
0 0 0 0 0    0 0 1 0 0
0 0 0 0 0    0 0 0 0 0

0  0 0  0  0    0 0 1 0 0
0  0 0  0  0    0 2 1 2 0
0  0 16 0  0 -> 1 1 0 1 1
0  0 0  0  0    0 2 1 2 0
0  0 0  0  0    0 0 1 0 0
",#Go,Go,"package main
 
import (
    ""fmt""
    ""log""
    ""os""
    ""strings""
)
 
const dim = 16 // image size
 
func check(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
 
// Outputs the result to the terminal using UTF-8 block characters.
func drawPile(pile [][]uint) {
    chars:= []rune("" ░▓█"")
    for _, row := range pile {
        line := make([]rune, len(row))
        for i, elem := range row {
            if elem > 3 { // only possible when algorithm not yet completed.
                elem = 3
            }
            line[i] = chars[elem]
        }
        fmt.Println(string(line))
    }
}
 
// Creates a .ppm file in the current directory, which contains
// a colored image of the pile.
func writePile(pile [][]uint) {
    file, err := os.Create(""output.ppm"")
    check(err)
    defer file.Close()
    // Write the signature, image dimensions and maximum color value to the file.
    fmt.Fprintf(file, ""P3\n%d %d\n255\n"", dim, dim)
    bcolors := []string{""125 0 25 "", ""125 80 0 "", ""186 118 0 "", ""224 142 0 ""}
    var line strings.Builder
    for _, row := range pile {        
        for _, elem := range row {
            line.WriteString(bcolors[elem])
        }
        file.WriteString(line.String() + ""\n"")
        line.Reset() 
    }
}
 
// Main part of the algorithm, a simple, recursive implementation of the model.
func handlePile(x, y uint, pile [][]uint) {
    if pile[y][x] >= 4 {
        pile[y][x] -= 4
        // Check each neighbor, whether they have enough ""sand"" to collapse and if they do,
        // recursively call handlePile on them.
        if y > 0 {
            pile[y-1][x]++
            if pile[y-1][x] >= 4 {
                handlePile(x, y-1, pile)
            }
        }
        if x > 0 {
            pile[y][x-1]++
            if pile[y][x-1] >= 4 {
                handlePile(x-1, y, pile)
            }
        }
        if y < dim-1 {
            pile[y+1][x]++
            if pile[y+1][x] >= 4 {
                handlePile(x, y+1, pile)
            }
        }
        if x < dim-1 {
            pile[y][x+1]++
            if pile[y][x+1] >= 4 {
                handlePile(x+1, y, pile)
            }
        }
 
        // Uncomment this line to show every iteration of the program.
        // Not recommended with large input values.
        // drawPile(pile)
 
        // Finally call the function on the current cell again,
        // in case it had more than 4 particles.
        handlePile(x, y, pile)
    }
}
 
func main() {
    // Create 2D grid and set size using the 'dim' constant.
    pile := make([][]uint, dim)
    for i := 0; i < dim; i++ {
        pile[i] = make([]uint, dim)
    }
 
    // Place some sand particles in the center of the grid and start the algorithm.
    hdim := uint(dim/2 - 1)
    pile[hdim][hdim] = 16
    handlePile(hdim, hdim, pile)
    drawPile(pile)
 
    // Uncomment this to save the final image to a file
    // after the recursive algorithm has ended.
    // writePile(pile)
}",2983,109
77439,"http://rosettacode.org/wiki/Abbreviations,_easy","Abbreviations, easy","This task is an easier (to code) variant of the Rosetta Code task:    Abbreviations, simple.



For this task, the following   command table   will be used:

   Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy
   COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find
   NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput
   Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO
   MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT
   READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT
   RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up



Notes concerning the above   command table:

   it can be thought of as one long literal string   (with blanks at end-of-lines)
   it may have superfluous blanks
   it may be in any case (lower/upper/mixed)
   the order of the words in the   command table   must be preserved as shown
   the user input(s) may be in any case (upper/lower/mixed)
   commands will be restricted to the Latin alphabet   (A ──► Z,   a ──► z)
   A valid abbreviation is a word that has:
   at least the minimum length of the number of capital letters of the word in the command table
   compares equal (regardless of case) to the leading characters of the word in the command table
   a length not longer than the word in the command table
   ALT,   aLt,   ALTE,   and   ALTER   are all abbreviations of   ALTer
   AL,   ALF,   ALTERS,   TER,   and   A   aren't valid abbreviations of   ALTer
   The number of capital letters in   ALTer   indicates that any abbreviation for   ALTer   must be at least three letters
   Any word longer than five characters can't be an abbreviation for   ALTer
   o,   ov,   oVe,   over,   overL,   overla   are all acceptable abbreviations for   Overlay
   if there isn't any lowercase letters in the word in the command table,   then there isn't an abbreviation permitted


Task

   The command table needn't be verified/validated.
   Write a function to validate if the user ""words""   (given as input)   are valid   (in the command table).
   If the word   is   valid,   then return the full uppercase version of that ""word"".
   If the word isn't valid,   then return the lowercase string:    *error*        (7 characters).
   A blank input   (or a null input)   should return a null string.
   Show all output here.


An example test case to be used for this task

For a user string of:

 riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin

the computer program should return the string:

 RIGHT REPEAT *error* PUT MOVE RESTORE *error* *error* *error* POWERINPUT


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
var table =
    ""Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy "" +
    ""COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find "" +
    ""NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput "" +
     ""Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO "" +
    ""MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT "" +
    ""READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT "" +
    ""RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up ""
 
func validate(commands, words []string, minLens []int) []string {
    results := make([]string, 0)
    if len(words) == 0 {
        return results
    }
    for _, word := range words {
        matchFound := false
        wlen := len(word)
        for i, command := range commands {
            if minLens[i] == 0 || wlen < minLens[i] || wlen > len(command) {
                continue
            }
            c := strings.ToUpper(command)
            w := strings.ToUpper(word)
            if strings.HasPrefix(c, w) {
                results = append(results, c)
                matchFound = true
                break
            }
        }
        if !matchFound {
            results = append(results, ""*error*"")
        }
    }
    return results
}
 
func main() {
    table = strings.TrimSpace(table)
    commands := strings.Fields(table)
    clen := len(commands)
    minLens := make([]int, clen)
    for i := 0; i < clen; i++ {
        count := 0
        for _, c := range commands[i] {
            if c >= 'A' && c <= 'Z' {
                count++
            }
        }
        minLens[i] = count
    }
    sentence :=  ""riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin""
    words := strings.Fields(sentence)
    results := validate(commands, words, minLens)
    fmt.Print(""user words:  "")
    for j := 0; j < len(words); j++ {
        fmt.Printf(""%-*s "", len(results[j]), words[j])
    }
    fmt.Print(""\nfull words:  "")
    fmt.Println(strings.Join(results, "" ""))
}",2176,67
77446,"http://rosettacode.org/wiki/Abbreviations,_simple","Abbreviations, simple","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an

easy way to add flexibility when specifying or using commands, sub─commands, options, etc.



For this task, the following   command table   will be used:

   add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3
   compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate
   3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2
   forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load
   locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2
   msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3
   refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left
   2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1



Notes concerning the above   command table:

   it can be thought of as one long literal string   (with blanks at end-of-lines)
   it may have superfluous blanks
   it may be in any case (lower/upper/mixed)
   the order of the words in the   command table   must be preserved as shown
   the user input(s) may be in any case (upper/lower/mixed)
   commands will be restricted to the Latin alphabet   (A ──► Z,   a ──► z)
   a command is followed by an optional number, which indicates the minimum abbreviation
   A valid abbreviation is a word that has:
   at least the minimum length of the word's minimum number in the command table
   compares equal (regardless of case) to the leading characters of the word in the command table
   a length not longer than the word in the command table
   ALT,   aLt,   ALTE,   and   ALTER   are all abbreviations of   ALTER 3
   AL,   ALF,   ALTERS,   TER,   and   A   aren't valid abbreviations of   ALTER 3
   The   3   indicates that any abbreviation for   ALTER   must be at least three characters
   Any word longer than five characters can't be an abbreviation for   ALTER
   o,   ov,   oVe,   over,   overL,   overla   are all acceptable abbreviations for   overlay 1
   if there isn't a number after the command,   then there isn't an abbreviation permitted


Task

   The command table needn't be verified/validated.
   Write a function to validate if the user ""words""   (given as input)   are valid   (in the command table).
   If the word   is   valid,   then return the full uppercase version of that ""word"".
   If the word isn't valid,   then return the lowercase string:    *error*        (7 characters).
   A blank input   (or a null input)   should return a null string.
   Show all output here.


An example test case to be used for this task

For a user string of:

 riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin

the computer program should return the string:

 RIGHT REPEAT *error* PUT MOVE RESTORE *error* *error* *error* POWERINPUT


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
	""io""
	""os""
	""strconv""
	""strings""
	""text/tabwriter""
)
 
func readTable(table string) ([]string, []int) {
	fields := strings.Fields(table)
	var commands []string
	var minLens []int
 
	for i, max := 0, len(fields); i < max; {
		cmd := fields[i]
		cmdLen := len(cmd)
		i++
 
		if i < max {
			num, err := strconv.Atoi(fields[i])
			if err == nil && 1 <= num && num < cmdLen {
				cmdLen = num
				i++
			}
		}
 
		commands = append(commands, cmd)
		minLens = append(minLens, cmdLen)
	}
 
	return commands, minLens
}
 
func validateCommands(commands []string, minLens []int, words []string) []string {
	var results []string
	for _, word := range words {
		matchFound := false
		wlen := len(word)
		for i, command := range commands {
			if minLens[i] == 0 || wlen < minLens[i] || wlen > len(command) {
				continue
			}
			c := strings.ToUpper(command)
			w := strings.ToUpper(word)
			if strings.HasPrefix(c, w) {
				results = append(results, c)
				matchFound = true
				break
			}
		}
		if !matchFound {
			results = append(results, ""*error*"")
		}
	}
	return results
}
 
func printResults(words []string, results []string) {
	wr := tabwriter.NewWriter(os.Stdout, 0, 1, 1, ' ', 0)
	io.WriteString(wr, ""user words:"")
	for _, word := range words {
		io.WriteString(wr, ""\t""+word)
	}
	io.WriteString(wr, ""\n"")
	io.WriteString(wr, ""full words:\t""+strings.Join(results, ""\t"")+""\n"")
	wr.Flush()
}
 
func main() {
	const table = """" +
		""add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 "" +
		""compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate "" +
		""3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 "" +
		""forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load "" +
		""locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 "" +
		""msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 "" +
		""refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left "" +
		""2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 ""
 
	const sentence = ""riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin""
 
	commands, minLens := readTable(table)
	words := strings.Fields(sentence)
 
	results := validateCommands(commands, minLens, words)
 
	printResults(words, results)
}
 ",2443,91
77448,http://rosettacode.org/wiki/Abelian_sandpile_model/Identity,Abelian sandpile model/Identity,"Our sandpiles are based on a 3 by 3 rectangular grid giving nine areas that
contain a number from 0 to 3 inclusive. (The numbers are said to represent
grains of sand in each area of the sandpile).

E.g. s1 =

    
    1 2 0
    2 1 1
    0 1 3

and s2 =

    2 1 3
    1 0 1
    0 1 0

Addition on sandpiles is done by adding numbers in corresponding grid areas,
so for the above:

              1 2 0     2 1 3     3 3 3
    s1 + s2 = 2 1 1  +  1 0 1  =  3 1 2
              0 1 3     0 1 0     0 2 3

If the addition would result in more than 3 ""grains of sand"" in any area then
those areas cause the whole sandpile to become ""unstable"" and the sandpile
areas are ""toppled"" in an ""avalanche"" until the ""stable"" result is obtained.

Any unstable area (with a number >= 4), is ""toppled"" by loosing one grain of
sand to each of its four horizontal or vertical neighbours. Grains are lost
at the edge of the grid, but otherwise increase the number in neighbouring
cells by one, whilst decreasing the count in the toppled cell by four in each
toppling.

A toppling may give an adjacent area more than four grains of sand leading to
a chain of topplings called an ""avalanche"".
E.g.

    
    4 3 3     0 4 3     1 0 4     1 1 0     2 1 0
    3 1 2 ==> 4 1 2 ==> 4 2 2 ==> 4 2 3 ==> 0 3 3
    0 2 3     0 2 3     0 2 3     0 2 3     1 2 3

The final result is the stable sandpile on the right.

Note: The order in which cells are toppled does not affect the final result.

Task

 Create a class or datastructure and functions to represent and operate on sandpiles. 
 Confirm the result of the avalanche of topplings shown above
 Confirm that s1 + s2 == s2 + s1 # Show the stable results
 If s3 is the sandpile with number 3 in every grid area, and s3_id is the following sandpile:
    2 1 2  
    1 0 1  
    2 1 2

 Show that s3 + s3_id == s3
 Show that s3_id + s3_id == s3_id


Show confirming output here, with your examples.



References

 https://www.youtube.com/watch?v=1MtEUErz7Gg
 https://en.wikipedia.org/wiki/Abelian_sandpile_model

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
    ""strings""
)
 
type sandpile struct{ a [9]int }
 
var neighbors = [][]int{
    {1, 3}, {0, 2, 4}, {1, 5}, {0, 4, 6}, {1, 3, 5, 7}, {2, 4, 8}, {3, 7}, {4, 6, 8}, {5, 7},
}
 
// 'a' is in row order
func newSandpile(a [9]int) *sandpile { return &sandpile{a} }
 
func (s *sandpile) plus(other *sandpile) *sandpile {
    b := [9]int{}
    for i := 0; i < 9; i++ {
        b[i] = s.a[i] + other.a[i]
    }
    return &sandpile{b}
}
 
func (s *sandpile) isStable() bool {
    for _, e := range s.a {
        if e > 3 {
            return false
        }
    }
    return true
}
 
// just topples once so we can observe intermediate results
func (s *sandpile) topple() {
    for i := 0; i < 9; i++ {
        if s.a[i] > 3 {
            s.a[i] -= 4
            for _, j := range neighbors[i] {
                s.a[j]++
            }
            return
        }
    }
}
 
func (s *sandpile) String() string {
    var sb strings.Builder
    for i := 0; i < 3; i++ {
        for j := 0; j < 3; j++ {
            sb.WriteString(strconv.Itoa(s.a[3*i+j]) + "" "")
        }
        sb.WriteString(""\n"")
    }
    return sb.String()
}
 
func main() {
    fmt.Println(""Avalanche of topplings:\n"")
    s4 := newSandpile([9]int{4, 3, 3, 3, 1, 2, 0, 2, 3})
    fmt.Println(s4)
    for !s4.isStable() {
        s4.topple()
        fmt.Println(s4)
    }
 
    fmt.Println(""Commutative additions:\n"")
    s1 := newSandpile([9]int{1, 2, 0, 2, 1, 1, 0, 1, 3})
    s2 := newSandpile([9]int{2, 1, 3, 1, 0, 1, 0, 1, 0})
    s3_a := s1.plus(s2)
    for !s3_a.isStable() {
        s3_a.topple()
    }
    s3_b := s2.plus(s1)
    for !s3_b.isStable() {
        s3_b.topple()
    }
    fmt.Printf(""%s\nplus\n\n%s\nequals\n\n%s\n"", s1, s2, s3_a)
    fmt.Printf(""and\n\n%s\nplus\n\n%s\nalso equals\n\n%s\n"", s2, s1, s3_b)
 
    fmt.Println(""Addition of identity sandpile:\n"")
    s3 := newSandpile([9]int{3, 3, 3, 3, 3, 3, 3, 3, 3})
    s3_id := newSandpile([9]int{2, 1, 2, 1, 0, 1, 2, 1, 2})
    s4 = s3.plus(s3_id)
    for !s4.isStable() {
        s4.topple()
    }
    fmt.Printf(""%s\nplus\n\n%s\nequals\n\n%s\n"", s3, s3_id, s4)
 
    fmt.Println(""Addition of identities:\n"")
    s5 := s3_id.plus(s3_id)
    for !s5.isStable() {
        s5.topple()
    }
    fmt.Printf(""%s\nplus\n\n%s\nequals\n\n%s"", s3_id, s3_id, s5)
}",2340,97
77550,http://rosettacode.org/wiki/Abstract_type,Abstract type,"Abstract type is a type without instances or without definition.

For example in object-oriented programming using some languages, abstract types can be partial implementations of other types, which are to be derived there-from. An abstract type may provide implementation of some operations and/or components. Abstract types without any implementation are called interfaces. In the languages that do not support multiple inheritance (Ada, Java), classes can, nonetheless, inherit from multiple interfaces. The languages with multiple inheritance (like C++) usually make no distinction between partially implementable abstract types and interfaces. Because the abstract type's implementation is incomplete,  OO languages normally prevent instantiation from them (instantiation must derived from one of their descendant classes).

The term abstract datatype also may denote a type, with an implementation provided by the programmer rather than directly by the language (a built-in or an inferred type). Here the word abstract means that the implementation is abstracted away, irrelevant for the user of the type. Such implementation can and should be hidden if the language supports separation of implementation and specification. This hides complexity while allowing the implementation to change without repercussions on the usage. The corresponding software design practice is said to follow the information hiding principle.

It is important not to confuse this abstractness (of implementation) with one of the abstract type. The latter is abstract in the sense that the set of its values is empty. In the sense of implementation abstracted away, all user-defined types are abstract.

In some languages, like for example in Objective Caml which is strongly statically typed, it is also possible to have abstract types that are not OO related and are not an abstractness too. These are pure abstract types without any definition even in the implementation and can be used for example for the type algebra, or for some consistence of the type inference. For example in this area, an abstract type can be used as a phantom type to augment another type as its parameter.

Task: show how an abstract type can be declared in the language. If the language makes a distinction between interfaces and partially implemented types illustrate both.
",#Go,Go,"package main
 
import ""fmt""
 
type Beast interface {
    Kind() string
    Name() string
    Cry() string
}
 
type Dog struct {
    kind string
    name string
}
 
func (d Dog) Kind() string { return d.kind }
 
func (d Dog) Name() string { return d.name }
 
func (d Dog) Cry() string { return ""Woof"" }
 
type Cat struct {
    kind string
    name string
}
 
func (c Cat) Kind() string { return c.kind }
 
func (c Cat) Name() string { return c.name }
 
func (c Cat) Cry() string { return ""Meow"" }
 
func bprint(b Beast) {
    fmt.Printf(""%s, who's a %s, cries: %q.\n"", b.Name(), b.Kind(), b.Cry())
}
 
func main() {
    d := Dog{""labrador"", ""Max""}
    c := Cat{""siamese"", ""Sammy""}
    bprint(d)
    bprint(c)
}",709,42
77627,"http://rosettacode.org/wiki/Abbreviations,_automatic","Abbreviations, automatic","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an

easy way to add flexibility when specifying or using commands, sub─commands, options, etc.



It would make a list of words easier to maintain   (as words are added, changed, and/or deleted)   if
the minimum abbreviation length of that list could be automatically (programmatically) determined.



For this task, use the list (below) of the days-of-the-week names that are expressed in about a hundred languages   (note that there is a blank line in the list).

Sunday Monday Tuesday Wednesday Thursday Friday Saturday
Sondag Maandag Dinsdag Woensdag Donderdag Vrydag Saterdag
E_djelë E_hënë E_martë E_mërkurë E_enjte E_premte E_shtunë
Ehud Segno Maksegno Erob Hamus Arbe Kedame
Al_Ahad Al_Ithinin Al_Tholatha'a Al_Arbia'a Al_Kamis Al_Gomia'a Al_Sabit
Guiragui Yergou_shapti Yerek_shapti Tchorek_shapti Hink_shapti Ourpat Shapat
domingu llunes martes miércoles xueves vienres sábadu
Bazar_gÜnÜ Birinci_gÜn Çkinci_gÜn ÜçÜncÜ_gÜn DÖrdÜncÜ_gÜn Bes,inci_gÜn Altòncò_gÜn
Igande Astelehen Astearte Asteazken Ostegun Ostiral Larunbat
Robi_bar Shom_bar Mongal_bar Budhh_bar BRihashpati_bar Shukro_bar Shoni_bar
Nedjelja Ponedeljak Utorak Srijeda Cxetvrtak Petak Subota
Disul Dilun Dimeurzh Dimerc'her Diriaou Digwener Disadorn
nedelia ponedelnik vtornik sriada chetvartak petak sabota
sing_kei_yaht sing_kei_yat sing_kei_yee sing_kei_saam sing_kei_sie sing_kei_ng sing_kei_luk
Diumenge Dilluns Dimarts Dimecres Dijous Divendres Dissabte
Dzeenkk-eh Dzeehn_kk-ehreh Dzeehn_kk-ehreh_nah_kay_dzeeneh Tah_neesee_dzeehn_neh Deehn_ghee_dzee-neh Tl-oowey_tts-el_dehlee Dzeentt-ahzee
dy_Sul dy_Lun dy_Meurth dy_Mergher dy_You dy_Gwener dy_Sadorn
Dimanch Lendi Madi Mèkredi Jedi Vandredi Samdi
nedjelja ponedjeljak utorak srijeda cxetvrtak petak subota
nede^le ponde^lí úterÿ str^eda c^tvrtek pátek sobota
Sondee Mondee Tiisiday Walansedee TOOsedee Feraadee Satadee
s0ndag mandag tirsdag onsdag torsdag fredag l0rdag
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
Diman^co Lundo Mardo Merkredo ^Jaùdo Vendredo Sabato
pÜhapäev esmaspäev teisipäev kolmapäev neljapäev reede laupäev

Diu_prima Diu_sequima Diu_tritima Diu_quartima Diu_quintima Diu_sextima Diu_sabbata
sunnudagur mánadagur tÿsdaguy mikudagur hósdagur friggjadagur leygardagur
Yek_Sham'beh Do_Sham'beh Seh_Sham'beh Cha'har_Sham'beh Panj_Sham'beh Jom'eh Sham'beh
sunnuntai maanantai tiistai keskiviiko torsktai perjantai lauantai
dimanche lundi mardi mercredi jeudi vendredi samedi
Snein Moandei Tiisdei Woansdei Tonersdei Freed Sneon
Domingo Segunda_feira Martes Mércores Joves Venres Sábado
k'vira orshabati samshabati otkhshabati khutshabati p'arask'evi shabati
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag
Kiriaki' Defte'ra Tri'ti Teta'rti Pe'mpti Paraskebi' Sa'bato
ravivaar somvaar mangalvaar budhvaar guruvaar shukravaar shanivaar
pópule pó`akahi pó`alua pó`akolu pó`ahá pó`alima pó`aono
Yom_rishon Yom_sheni Yom_shlishi Yom_revi'i Yom_chamishi Yom_shishi Shabat
ravivara somavar mangalavar budhavara brahaspativar shukravara shanivar
vasárnap hétfö kedd szerda csütörtök péntek szombat
Sunnudagur Mánudagur ╞riδjudagur Miδvikudagar Fimmtudagur FÖstudagur Laugardagur
sundio lundio mardio merkurdio jovdio venerdio saturdio
Minggu Senin Selasa Rabu Kamis Jumat Sabtu
Dominica Lunedi Martedi Mercuridi Jovedi Venerdi Sabbato
Dé_Domhnaigh Dé_Luain Dé_Máirt Dé_Ceadaoin Dé_ardaoin Dé_hAoine Dé_Sathairn
domenica lunedí martedí mercoledí giovedí venerdí sabato
Nichiyou_bi Getzuyou_bi Kayou_bi Suiyou_bi Mokuyou_bi Kin'you_bi Doyou_bi
Il-yo-il Wol-yo-il Hwa-yo-il Su-yo-il Mok-yo-il Kum-yo-il To-yo-il
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
sve-tdien pirmdien otrdien tresvdien ceturtdien piektdien sestdien
Sekmadienis Pirmadienis Antradienis Trec^iadienis Ketvirtadienis Penktadienis S^es^tadienis
Wangu Kazooba Walumbe Mukasa Kiwanuka Nnagawonye Wamunyi
xing-_qi-_rì xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
Jedoonee Jelune Jemayrt Jecrean Jardaim Jeheiney Jesam
Jabot Manre Juje Wonje Taije Balaire Jarere
geminrongo minòmishi mártes mièrkoles misheushi bèrnashi mishábaro
Ahad Isnin Selasa Rabu Khamis Jumaat Sabtu
sφndag mandag tirsdag onsdag torsdag fredag lφrdag
lo_dimenge lo_diluns lo_dimarç lo_dimèrcres lo_dijòus lo_divendres lo_dissabte
djadomingo djaluna djamars djarason djaweps djabièrna djasabra
Niedziela Poniedzial/ek Wtorek S,roda Czwartek Pia,tek Sobota
Domingo segunda-feire terça-feire quarta-feire quinta-feire sexta-feira såbado
Domingo Lunes martes Miercoles Jueves Viernes Sabado
Duminicª Luni Mart'i Miercuri Joi Vineri Sâmbªtª
voskresenie ponedelnik vtornik sreda chetverg pyatnitsa subbota
Sunday Di-luain Di-màirt Di-ciadain Di-ardaoin Di-haoine Di-sathurne
nedjelja ponedjeljak utorak sreda cxetvrtak petak subota
Sontaha Mmantaha Labobedi Laboraro Labone Labohlano Moqebelo
Iridha- Sandhudha- Anga.haruwa-dha- Badha-dha- Brahaspa.thindha- Sikura-dha- Sena.sura-dha-
nedel^a pondelok utorok streda s^tvrtok piatok sobota
Nedelja Ponedeljek Torek Sreda Cxetrtek Petek Sobota
domingo lunes martes miércoles jueves viernes sábado
sonde mundey tude-wroko dride-wroko fode-wroko freyda Saturday
Jumapili Jumatatu Jumanne Jumatano Alhamisi Ijumaa Jumamosi
söndag måndag tisdag onsdag torsdag fredag lordag
Linggo Lunes Martes Miyerkoles Huwebes Biyernes Sabado
Lé-pài-jít Pài-it Pài-jï Pài-sañ Pài-sì Pài-gÖ. Pài-lák
wan-ar-tit wan-tjan wan-ang-kaan wan-phoet wan-pha-ru-hat-sa-boh-die wan-sook wan-sao
Tshipi Mosupologo Labobedi Laboraro Labone Labotlhano Matlhatso
Pazar Pazartesi Sali Çar,samba Per,sembe Cuma Cumartesi
nedilya ponedilok vivtorok sereda chetver pyatnytsya subota
Chu?_Nhâ.t Thú*_Hai Thú*_Ba Thú*_Tu* Thú*_Na'm Thú*_Sáu Thú*_Ba?y
dydd_Sul dyds_Llun dydd_Mawrth dyds_Mercher dydd_Iau dydd_Gwener dyds_Sadwrn
Dibeer Altine Talaata Allarba Al_xebes Aljuma Gaaw
iCawa uMvulo uLwesibini uLwesithathu uLuwesine uLwesihlanu uMgqibelo
zuntik montik dinstik mitvokh donershtik fraytik shabes
iSonto uMsombuluko uLwesibili uLwesithathu uLwesine uLwesihlanu uMgqibelo
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
Bazar_gÜnÜ Bazar_ærtæsi Çærs,ænbæ_axs,amò Çærs,ænbæ_gÜnÜ CÜmæ_axs,amò CÜmæ_gÜnÜ CÜmæ_Senbæ
Sun Moon Mars Mercury Jove Venus Saturn
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
KoseEraa GyoOraa BenEraa Kuoraa YOwaaraa FeEraa Memenaa
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Sonnabend
Domingo Luns Terza_feira Corta_feira Xoves Venres Sábado
Dies_Solis Dies_Lunae Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Sabbatum
xing-_qi-_tiàn xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
djadomingu djaluna djamars djarason djaweps djabièrnè djasabra
Killachau Atichau Quoyllurchau Illapachau Chaskachau Kuychichau Intichau

Caveat:   The list (above) most surely contains errors (or, at the least, differences) of what the actual (or true) names for the days-of-the-week.



To make this Rosetta Code task page as small as possible, if processing the complete list, read the days-of-the-week from a file (that is created from the above list).



Notes concerning the above list of words

   each line has a list of days-of-the-week for a language, separated by at least one blank
   the words on each line happen to be in order, from Sunday ──► Saturday
   most lines have words in mixed case and some have all manner of accented words and other characters
   some words were translated to the nearest character that was available to code page   437
   the characters in the words are not restricted except that they may not have imbedded blanks
   for this example, the use of an underscore (_) was used to indicate a blank in a word


Task

   The list of words   (days of the week)   needn't be verified/validated.
   Write a function to find the (numeric) minimum length abbreviation for each line that would make abbreviations unique.
   A blank line   (or a null line)   should return a null string.
   Process and show the output for at least the first five lines of the file.
   Show all output here.

Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import(
    ""bufio""
    ""fmt""
    ""os""
    ""strings""
)
 
func distinctStrings(strs []string) []string {
    len := len(strs)
    set := make(map[string]bool, len)
    distinct := make([]string, 0, len)
    for _, str := range strs {
        if !set[str] {
            distinct = append(distinct, str)
            set[str] = true
        }
    }
    return distinct
}
 
func takeRunes(s string, n int) string {
    i := 0
    for j := range s {
        if i == n {
            return s[:j]
        }
        i++
    }
    return s
}
 
func main() {
    file, err := os.Open(""days_of_week.txt"")
    if err != nil {
        fmt.Println(""Unable to open file."")
        return
    }
    defer file.Close()
    reader := bufio.NewReader(file)
    lineCount := 0
    for {
        line, err := reader.ReadString('\n')
        if err != nil { // end of file reached
            return
        }
        line = strings.TrimSpace(line)
        lineCount++
        if line == """" {
            fmt.Println()
            continue
        }
        days := strings.Fields(line)
        daysLen := len(days)
        if (len(days) != 7) {
            fmt.Println(""There aren't 7 days in line"", lineCount)
            return
        }
        if len(distinctStrings(days)) != 7 { // implies some days have the same name
            fmt.Println("" ∞ "", line)
            continue
        }
        for abbrevLen := 1; ; abbrevLen++ {
            abbrevs := make([]string, daysLen)
            for i := 0; i < daysLen; i++ {
                abbrevs[i] = takeRunes(days[i], abbrevLen)
            }
            if len(distinctStrings(abbrevs)) == 7 {
                fmt.Printf(""%2d  %s\n"", abbrevLen, line)
                break
            }
        }
    }
}",1755,75
77712,http://rosettacode.org/wiki/Abundant_odd_numbers,Abundant odd numbers,"An Abundant number is a number n for which the   sum of divisors   σ(n) > 2n,

or,   equivalently,   the   sum of proper divisors   (or aliquot sum)       s(n) > n.



E.G.

12   is abundant, it has the proper divisors     1,2,3,4 & 6     which sum to   16   ( > 12 or n);

       or alternately,   has the sigma sum of   1,2,3,4,6 & 12   which sum to   28   ( > 24 or 2n).



Abundant numbers are common, though even abundant numbers seem to be much more common than odd abundant numbers.

To make things more interesting, this task is specifically about finding   odd abundant numbers.



Task
Find and display here: at least the first 25 abundant odd numbers and either their proper divisor sum or sigma sum.
Find and display here: the one thousandth abundant odd number and either its proper divisor sum or sigma sum.
Find and display here: the first abundant odd number greater than one billion (109) and either its proper divisor sum or sigma sum.


References

   OEIS:A005231: Odd abundant numbers (odd numbers n whose sum of divisors exceeds 2n)
   American Journal of Mathematics, Vol. 35, No. 4 (Oct., 1913), pp. 413-422 - Finiteness of the Odd Perfect and Primitive Abundant Numbers with n Distinct Prime Factors (LE Dickson)

",#Go,Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
func divisors(n int) []int {
    divs := []int{1}
    divs2 := []int{}
    for i := 2; i*i <= n; i++ {
        if n%i == 0 {
            j := n / i
            divs = append(divs, i)
            if i != j {
                divs2 = append(divs2, j)
            }
        }
    }
    for i := len(divs2) - 1; i >= 0; i-- {
        divs = append(divs, divs2[i])
    }
    return divs
}
 
func sum(divs []int) int {
    tot := 0
    for _, div := range divs {
        tot += div
    }
    return tot
}
 
func sumStr(divs []int) string {
    s := """"
    for _, div := range divs {
        s += strconv.Itoa(div) + "" + ""
    }
    return s[0 : len(s)-3]
}
 
func abundantOdd(searchFrom, countFrom, countTo int, printOne bool) int {
    count := countFrom
    n := searchFrom
    for ; count < countTo; n += 2 {
        divs := divisors(n)
        if tot := sum(divs); tot > n {
            count++
            if printOne && count < countTo {
                continue
            } 
            s := sumStr(divs)
            if !printOne {
                fmt.Printf(""%2d. %5d < %s = %d\n"", count, n, s, tot)
            } else {
                fmt.Printf(""%d < %s = %d\n"", n, s, tot)
            }
        }
    }
    return n
}
 
func main() {
    const max = 25
    fmt.Println(""The first"", max, ""abundant odd numbers are:"")
    n := abundantOdd(1, 0, 25, false)
 
    fmt.Println(""\nThe one thousandth abundant odd number is:"")
    abundantOdd(n, 25, 1000, true)
 
    fmt.Println(""\nThe first abundant odd number above one billion is:"")
    abundantOdd(1e9+1, 0, 1, true)
}",1625,73
77765,http://rosettacode.org/wiki/9_billion_names_of_God_the_integer,9 billion names of God the integer,"This task is a variation of the short story by Arthur C. Clarke.

(Solvers should be aware of the consequences of completing this task.)

In detail, to specify what is meant by a   “name”:

The integer 1 has 1 name     “1”.
The integer 2 has 2 names   “1+1”,   and   “2”.
The integer 3 has 3 names   “1+1+1”,   “2+1”,   and   “3”.
The integer 4 has 5 names   “1+1+1+1”,   “2+1+1”,   “2+2”,   “3+1”,   “4”.
The integer 5 has 7 names   “1+1+1+1+1”,   “2+1+1+1”,   “2+2+1”,   “3+1+1”,   “3+2”,   “4+1”,   “5”.


Task
Display the first 25 rows of a number triangle which begins:

                                      1
                                    1   1
                                  1   1   1 
                                1   2   1   1
                              1   2   2   1   1
                            1   3   3   2   1   1

Where row   



n


{\displaystyle n}

   corresponds to integer   



n


{\displaystyle n}

,   and each column   



C


{\displaystyle C}

   in row   



m


{\displaystyle m}

   from left to right corresponds to the number of names beginning with   



C


{\displaystyle C}

.

A function   



G
(
n
)


{\displaystyle G(n)}

   should return the sum of the   



n


{\displaystyle n}

-th   row.

Demonstrate this function by displaying:   



G
(
23
)


{\displaystyle G(23)}

,   



G
(
123
)


{\displaystyle G(123)}

,   



G
(
1234
)


{\displaystyle G(1234)}

,   and   



G
(
12345
)


{\displaystyle G(12345)}

.

Optionally note that the sum of the   



n


{\displaystyle n}

-th   row   



P
(
n
)


{\displaystyle P(n)}

   is the     integer partition function.

Demonstrate this is equivalent to   



G
(
n
)


{\displaystyle G(n)}

   by displaying:   



P
(
23
)


{\displaystyle P(23)}

,   



P
(
123
)


{\displaystyle P(123)}

,   



P
(
1234
)


{\displaystyle P(1234)}

,   and   



P
(
12345
)


{\displaystyle P(12345)}

.



Extra credit
If your environment is able, plot   



P
(
n
)


{\displaystyle P(n)}

   against   



n


{\displaystyle n}

   for   



n
=
1
…
999


{\displaystyle n=1\ldots 999}

.

Related tasks
 Partition function P

",#Go,Go,"package main
 
import (
	""fmt""
	""math/big""
)
 
func main() {
 
	intMin := func(a, b int) int {
		if a < b {
			return a
		} else {
			return b
		}
	}
 
	var cache = [][]*big.Int{{big.NewInt(1)}}
 
	cumu := func(n int) []*big.Int {
		for y := len(cache); y <= n; y++ {
			row := []*big.Int{big.NewInt(0)}
			for x := 1; x <= y; x++ {
				cacheValue := cache[y-x][intMin(x, y-x)]
				row = append(row, big.NewInt(0).Add(row[len(row)-1], cacheValue))
			}
			cache = append(cache, row)
		}
		return cache[n]
	}
 
	row := func(n int) {
		e := cumu(n)
		for i := 0; i < n; i++ {
			fmt.Printf("" %v "", (big.NewInt(0).Sub(e[i+1], e[i])).Text(10))
		}
		fmt.Println()
	}
 
	fmt.Println(""rows:"")
	for x := 1; x < 11; x++ {
		row(x)
	}
	fmt.Println()
 
	fmt.Println(""sums:"")
	for _, num := range [...]int{23, 123, 1234, 12345} {
		r := cumu(num)
		fmt.Printf(""%d %v\n"", num, r[len(r)-1].Text(10))
	}
}",891,51
77892,http://rosettacode.org/wiki/4-rings_or_4-squares_puzzle,4-rings or 4-squares puzzle,"4-rings or 4-squares puzzle

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Replace       a, b, c, d, e, f,   and
  g        with the decimal
digits   LOW   ───►   HIGH

such that the sum of the letters inside of each of the four large squares add up to
the same sum.

            ╔══════════════╗      ╔══════════════╗
            ║              ║      ║              ║
            ║      a       ║      ║      e       ║
            ║              ║      ║              ║
            ║          ┌───╫──────╫───┐      ┌───╫─────────┐
            ║          │   ║      ║   │      │   ║         │
            ║          │ b ║      ║ d │      │ f ║         │
            ║          │   ║      ║   │      │   ║         │
            ║          │   ║      ║   │      │   ║         │
            ╚══════════╪═══╝      ╚═══╪══════╪═══╝         │
                       │       c      │      │      g      │
                       │              │      │             │
                       │              │      │             │
                       └──────────────┘      └─────────────┘

Show all output here.



   Show all solutions for each letter being unique with
        LOW=1     HIGH=7

   Show all solutions for each letter being unique with
        LOW=3     HIGH=9

   Show only the   number   of solutions when each letter can be non-unique
        LOW=0     HIGH=9



Related task

 Solve the no connection puzzle

",#Go,Go,"package main
 
import ""fmt""
 
func main(){
	n, c := getCombs(1,7,true)
	fmt.Printf(""%d unique solutions in 1 to 7\n"",n)
	fmt.Println(c)
	n, c = getCombs(3,9,true)
	fmt.Printf(""%d unique solutions in 3 to 9\n"",n)
	fmt.Println(c)
	n, _ = getCombs(0,9,false)
	fmt.Printf(""%d non-unique solutions in 0 to 9\n"",n)
}
 
func getCombs(low,high int,unique bool) (num int,validCombs [][]int){
	for a := low; a <= high; a++ {
		for b := low; b <= high; b++ {
			for c := low; c <= high; c++ {
				for d := low; d <= high; d++ {
					for e := low; e <= high; e++ {
						for f := low; f <= high; f++ {
							for g := low; g <= high; g++ {
								if validComb(a,b,c,d,e,f,g) {
									if !unique || isUnique(a,b,c,d,e,f,g) {
										num++
										validCombs = append(validCombs,[]int{a,b,c,d,e,f,g})
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return
}
func isUnique(a,b,c,d,e,f,g int) (res bool) {
	data := make(map[int]int)
	data[a]++
	data[b]++
	data[c]++
	data[d]++
	data[e]++
	data[f]++
	data[g]++
	return len(data) == 7
}
func validComb(a,b,c,d,e,f,g int) bool{
	square1 := a + b
	square2 := b + c + d
	square3 := d + e + f
	square4 := f + g
	return square1 == square2 && square2 == square3 && square3 == square4
}
 ",1236,57
77949,http://rosettacode.org/wiki/21_game,21 game,"21 game

You are encouraged to solve this task according to the task description, using any language you may know.
21 is a two player game, the game is played by choosing
a number (1, 2, or 3) to be added to the running total.

The game is won by the player whose chosen number causes the running total
to reach exactly 21.

The running total starts at zero.
One player will be the computer.

Players alternate supplying a number to be added to the running total.



Task

Write a computer program that will:

 do the prompting (or provide a button menu), 
 check for errors and display appropriate error messages, 
 do the additions (add a chosen number to the running total), 
 display the running total, 
 provide a mechanism for the player to quit/exit/halt/stop/close the program,
 issue a notification when there is a winner, and
 determine who goes first (maybe a random or user choice, or can be specified when the game begins). 

",#Go,Go,"package main
 
import (
    ""bufio""
    ""fmt""
    ""log""
    ""math/rand""
    ""os""
    ""strconv""
    ""time""
)
 
var scanner = bufio.NewScanner(os.Stdin)
 
var (
    total = 0
    quit  = false
)
 
func itob(i int) bool {
    if i == 0 {
        return false
    }
    return true
}
 
func getChoice() {
    for {
        fmt.Print(""Your choice 1 to 3 : "")
        scanner.Scan()
        if scerr := scanner.Err(); scerr != nil {
            log.Fatalln(scerr, ""when choosing number"")
        }
        text := scanner.Text()
        if text == ""q"" || text == ""Q"" {
            quit = true
            return
        }
        input, err := strconv.Atoi(text)
        if err != nil {
            fmt.Println(""Invalid number, try again"")
            continue
        }
        newTotal := total + input
        switch {
        case input < 1 || input > 3:
            fmt.Println(""Out of range, try again"")
        case newTotal > 21:
            fmt.Println(""Too big, try again"")
        default:
            total = newTotal
            fmt.Println(""Running total is now"", total)
            return
        }
    }
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    computer := itob(rand.Intn(2))
    fmt.Println(""Enter q to quit at any time\n"")
    if computer {
        fmt.Println(""The computer will choose first"")
    } else {
        fmt.Println(""You will choose first"")
    }
    fmt.Println(""\nRunning total is now 0\n"")
    var choice int
    for round := 1; ; round++ {
        fmt.Printf(""ROUND %d:\n\n"", round)
        for i := 0; i < 2; i++ {
            if computer {
                if total < 18 {
                    choice = 1 + rand.Intn(3)
                } else {
                    choice = 21 - total
                }
                total += choice
                fmt.Println(""The computer chooses"", choice)
                fmt.Println(""Running total is now"", total)
                if total == 21 {
                    fmt.Println(""\nSo, commiserations, the computer has won!"")
                    return
                }
            } else {
                getChoice()
                if quit {
                    fmt.Println(""OK, quitting the game"")
                    return
                }
                if total == 21 {
                    fmt.Println(""\nSo, congratulations, you've won!"")
                    return
                }
            }
            fmt.Println()
            computer = !computer
        }
    }
}",2472,100
78153,http://rosettacode.org/wiki/24_game/Solve,24 game/Solve,"task

Write a program that takes four digits, either from user input or by random generation, and computes arithmetic expressions following the rules of the 24 game.

Show examples of solutions generated by the program.



Related task

   Arithmetic Evaluator

",#Go,Go,"package main
 
import (
	""fmt""
	""math/rand""
	""time""
)
 
const (
	op_num = iota
	op_add
	op_sub
	op_mul
	op_div
)
 
type frac struct {
	num, denom int
}
 
// Expression: can either be a single number, or a result of binary
// operation from left and right node
type Expr struct {
	op          int
	left, right *Expr
	value       frac
}
 
var n_cards = 4
var goal = 24
var digit_range = 9
 
func (x *Expr) String() string {
	if x.op == op_num {
		return fmt.Sprintf(""%d"", x.value.num)
	}
 
	var bl1, br1, bl2, br2, opstr string
	switch {
	case x.left.op == op_num:
	case x.left.op >= x.op:
	case x.left.op == op_add && x.op == op_sub:
		bl1, br1 = """", """"
	default:
		bl1, br1 = ""("", "")""
	}
 
	if x.right.op == op_num || x.op < x.right.op {
		bl2, br2 = """", """"
	} else {
		bl2, br2 = ""("", "")""
	}
 
	switch {
	case x.op == op_add:
		opstr = "" + ""
	case x.op == op_sub:
		opstr = "" - ""
	case x.op == op_mul:
		opstr = "" * ""
	case x.op == op_div:
		opstr = "" / ""
	}
 
	return bl1 + x.left.String() + br1 + opstr +
		bl2 + x.right.String() + br2
}
 
func expr_eval(x *Expr) (f frac) {
	if x.op == op_num {
		return x.value
	}
 
	l, r := expr_eval(x.left), expr_eval(x.right)
 
	switch x.op {
	case op_add:
		f.num = l.num*r.denom + l.denom*r.num
		f.denom = l.denom * r.denom
		return
 
	case op_sub:
		f.num = l.num*r.denom - l.denom*r.num
		f.denom = l.denom * r.denom
		return
 
	case op_mul:
		f.num = l.num * r.num
		f.denom = l.denom * r.denom
		return
 
	case op_div:
		f.num = l.num * r.denom
		f.denom = l.denom * r.num
		return
	}
	return
}
 
func solve(ex_in []*Expr) bool {
	// only one expression left, meaning all numbers are arranged into
	// a binary tree, so evaluate and see if we get 24
	if len(ex_in) == 1 {
		f := expr_eval(ex_in[0])
		if f.denom != 0 && f.num == f.denom*goal {
			fmt.Println(ex_in[0].String())
			return true
		}
		return false
	}
 
	var node Expr
	ex := make([]*Expr, len(ex_in)-1)
 
	// try to combine a pair of expressions into one, thus reduce
	// the list length by 1, and recurse down
	for i := range ex {
		copy(ex[i:len(ex)], ex_in[i+1:len(ex_in)])
 
		ex[i] = &node
		for j := i + 1; j < len(ex_in); j++ {
			node.left = ex_in[i]
			node.right = ex_in[j]
 
			// try all 4 operators
			for o := op_add; o <= op_div; o++ {
				node.op = o
				if solve(ex) {
					return true
				}
			}
 
			// also - and / are not commutative, so swap arguments
			node.left = ex_in[j]
			node.right = ex_in[i]
 
			node.op = op_sub
			if solve(ex) {
				return true
			}
 
			node.op = op_div
			if solve(ex) {
				return true
			}
 
			if j < len(ex) {
				ex[j] = ex_in[j]
			}
		}
		ex[i] = ex_in[i]
	}
	return false
}
 
func main() {
	cards := make([]*Expr, n_cards)
	rand.Seed(time.Now().Unix())
 
	for k := 0; k < 10; k++ {
		for i := 0; i < n_cards; i++ {
			cards[i] = &Expr{op_num, nil, nil,
				frac{rand.Intn(digit_range-1) + 1, 1}}
			fmt.Printf("" %d"", cards[i].value.num)
		}
		fmt.Print("":  "")
		if !solve(cards) {
			fmt.Println(""No solution"")
		}
	}
}",2993,171
78170,http://rosettacode.org/wiki/15_puzzle_solver,15 puzzle solver,"Your task is to write a program that finds a solution in the fewest moves possible single moves to a random Fifteen Puzzle Game.

For this task you will be using the following puzzle:


15 14  1  6
 9 11  4 12
 0 10  7  3
13  8  5  2


 1  2  3  4
 5  6  7  8
 9 10 11 12
13 14 15  0

The output must show the moves' directions, like so: left, left, left, down, right... and so on.

There are two solutions, of fifty-two moves:

rrrulddluuuldrurdddrullulurrrddldluurddlulurruldrdrd

rrruldluuldrurdddluulurrrdlddruldluurddlulurruldrrdd

see: Pretty Print of Optimal Solution

Finding either one, or both is an acceptable result.


Extra credit.
Solve the following problem:

  0 12  9 13
 15 11 10 14
  3  7  2  5
  4  8  6  1



Related Task

 15 puzzle game
 A* search algorithm

",#Go,Go,"package main
 
import ""fmt""
 
var (
    Nr = [16]int{3, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3}
    Nc = [16]int{3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2}
)
 
var (
    n, _n      int
    N0, N3, N4 [85]int
    N2         [85]uint64
)
 
const (
    i = 1
    g = 8
    e = 2
    l = 4
)
 
func fY() bool {
    if N2[n] == 0x123456789abcdef0 {
        return true
    }
    if N4[n] <= _n {
        return fN()
    }
    return false
}
 
func fZ(w int) bool {
    if w&i > 0 {
        fI()
        if fY() {
            return true
        }
        n--
    }
    if w&g > 0 {
        fG()
        if fY() {
            return true
        }
        n--
    }
    if w&e > 0 {
        fE()
        if fY() {
            return true
        }
        n--
    }
    if w&l > 0 {
        fL()
        if fY() {
            return true
        }
        n--
    }
    return false
}
 
func fN() bool {
    switch N0[n] {
    case 0:
        switch N3[n] {
        case 'l':
            return fZ(i)
        case 'u':
            return fZ(e)
        default:
            return fZ(i + e)
        }
    case 3:
        switch N3[n] {
        case 'r':
            return fZ(i)
        case 'u':
            return fZ(l)
        default:
            return fZ(i + l)
        }
    case 1, 2:
        switch N3[n] {
        case 'l':
            return fZ(i + l)
        case 'r':
            return fZ(i + e)
        case 'u':
            return fZ(e + l)
        default:
            return fZ(l + e + i)
        }
    case 12:
        switch N3[n] {
        case 'l':
            return fZ(g)
        case 'd':
            return fZ(e)
        default:
            return fZ(e + g)
        }
    case 15:
        switch N3[n] {
        case 'r':
            return fZ(g)
        case 'd':
            return fZ(l)
        default:
            return fZ(g + l)
        }
    case 13, 14:
        switch N3[n] {
        case 'l':
            return fZ(g + l)
        case 'r':
            return fZ(e + g)
        case 'd':
            return fZ(e + l)
        default:
            return fZ(g + e + l)
        }
    case 4, 8:
        switch N3[n] {
        case 'l':
            return fZ(i + g)
        case 'u':
            return fZ(g + e)
        case 'd':
            return fZ(i + e)
        default:
            return fZ(i + g + e)
        }
    case 7, 11:
        switch N3[n] {
        case 'd':
            return fZ(i + l)
        case 'u':
            return fZ(g + l)
        case 'r':
            return fZ(i + g)
        default:
            return fZ(i + g + l)
        }
    default:
        switch N3[n] {
        case 'd':
            return fZ(i + e + l)
        case 'l':
            return fZ(i + g + l)
        case 'r':
            return fZ(i + g + e)
        case 'u':
            return fZ(g + e + l)
        default:
            return fZ(i + g + e + l)
        }
    }
}
 
func fI() {
    g := (11 - N0[n]) * 4
    a := N2[n] & uint64(15<<uint(g))
    N0[n+1] = N0[n] + 4
    N2[n+1] = N2[n] - a + (a << 16)
    N3[n+1] = 'd'
    N4[n+1] = N4[n]
    cond := Nr[a>>uint(g)] <= N0[n]/4
    if !cond {
        N4[n+1]++
    }
    n++
}
 
func fG() {
    g := (19 - N0[n]) * 4
    a := N2[n] & uint64(15<<uint(g))
    N0[n+1] = N0[n] - 4
    N2[n+1] = N2[n] - a + (a >> 16)
    N3[n+1] = 'u'
    N4[n+1] = N4[n]
    cond := Nr[a>>uint(g)] >= N0[n]/4
    if !cond {
        N4[n+1]++
    }
    n++
}
 
func fE() {
    g := (14 - N0[n]) * 4
    a := N2[n] & uint64(15<<uint(g))
    N0[n+1] = N0[n] + 1
    N2[n+1] = N2[n] - a + (a << 4)
    N3[n+1] = 'r'
    N4[n+1] = N4[n]
    cond := Nc[a>>uint(g)] <= N0[n]%4
    if !cond {
        N4[n+1]++
    }
    n++
}
 
func fL() {
    g := (16 - N0[n]) * 4
    a := N2[n] & uint64(15<<uint(g))
    N0[n+1] = N0[n] - 1
    N2[n+1] = N2[n] - a + (a >> 4)
    N3[n+1] = 'l'
    N4[n+1] = N4[n]
    cond := Nc[a>>uint(g)] >= N0[n]%4
    if !cond {
        N4[n+1]++
    }
    n++
}
 
func fifteenSolver(n int, g uint64) {
    N0[0] = n
    N2[0] = g
    N4[0] = 0
}
 
func solve() {
    if fN() {
        fmt.Print(""Solution found in "", n, "" moves: "")
        for g := 1; g <= n; g++ {
            fmt.Printf(""%c"", N3[g])
        }
        fmt.Println()
    } else {
        n = 0
        _n++
        solve()
    }
}
 
func main() {
    fifteenSolver(8, 0xfe169b4c0a73d852)
    solve()
}",4360,242
78201,http://rosettacode.org/wiki/ABC_problem,ABC problem,"ABC problem

You are encouraged to solve this task according to the task description, using any language you may know.
You are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).

There are twenty blocks with two letters on each block.

A complete alphabet is guaranteed amongst all sides of the blocks.

The sample collection of blocks:

 (B O)
 (X K)
 (D Q)
 (C P)
 (N A)
 (G T)
 (R E)
 (T G)
 (Q D)
 (F S)
 (J W)
 (H U)
 (V I)
 (A N)
 (O B)
 (E R)
 (F S)
 (L Y)
 (P C)
 (Z M)



Task

Write a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.



The rules are simple:

   Once a letter on a block is used that block cannot be used again
   The function should be case-insensitive
   Show the output on this page for the following 7 words in the following example


Example

    >>> can_make_word(""A"")
    True
    >>> can_make_word(""BARK"")
    True
    >>> can_make_word(""BOOK"")
    False
    >>> can_make_word(""TREAT"")
    True
    >>> can_make_word(""COMMON"")
    False
    >>> can_make_word(""SQUAD"")
    True
    >>> can_make_word(""CONFUSE"")
    True

Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",#Go,Go,"package main
 
import (
	""fmt""
	""strings""
)
 
func newSpeller(blocks string) func(string) bool {
	bl := strings.Fields(blocks)
	return func(word string) bool {
		return r(word, bl)
	}
}
 
func r(word string, bl []string) bool {
	if word == """" {
		return true
	}
	c := word[0] | 32
	for i, b := range bl {
		if c == b[0]|32 || c == b[1]|32 {
			bl[i], bl[0] = bl[0], b
			if r(word[1:], bl[1:]) == true {
				return true
			}
			bl[i], bl[0] = bl[0], bl[i]
		}
	}
	return false
}
 
func main() {
	sp := newSpeller(
		""BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM"")
	for _, word := range []string{
		""A"", ""BARK"", ""BOOK"", ""TREAT"", ""COMMON"", ""SQUAD"", ""CONFUSE""} {
		fmt.Println(word, sp(word))
	}
}",709,39
78259,http://rosettacode.org/wiki/24_game,24 game,"The 24 Game tests one's mental arithmetic.



Task
Write a program that randomly chooses and displays four digits, each from 1 ──► 9 (inclusive) with repetitions allowed.

The program should prompt for the player to enter an arithmetic expression using just those, and all of those four digits, used exactly once each. The program should check then evaluate the expression.

The goal is for the player to enter an expression that (numerically) evaluates to 24.

 Only the following operators/functions are allowed: multiplication, division, addition, subtraction
 Division should use floating point or rational arithmetic, etc, to preserve remainders.
 Brackets are allowed, if using an infix expression evaluator.
 Forming multiple digit numbers from the supplied digits is disallowed. (So an answer of 12+12 when given 1, 2, 2, and 1 is wrong).
 The order of the digits when given does not have to be preserved.


Notes
 The type of expression evaluator used is not mandated. An RPN evaluator is equally acceptable for example.
 The task is not for the program to generate the expression, or test whether an expression is even possible.


Related tasks
 24 game/Solve


Reference
 The 24 Game on h2g2.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/rand""
    ""time""
)
 
func main() {
    rand.Seed(time.Now().Unix())
    n := make([]rune, 4)
    for i := range n {
        n[i] = rune(rand.Intn(9) + '1')
    }
    fmt.Printf(""Your numbers: %c\n"", n)
    fmt.Print(""Enter RPN: "")
    var expr string
    fmt.Scan(&expr)
    if len(expr) != 7 {
        fmt.Println(""invalid. expression length must be 7."" +
            "" (4 numbers, 3 operators, no spaces)"")
        return
    }
    stack := make([]float64, 0, 4)
    for _, r := range expr {
        if r >= '0' && r <= '9' {
            if len(n) == 0 {
                fmt.Println(""too many numbers."")
                return
            }
            i := 0
            for n[i] != r {
                i++
                if i == len(n) {
                    fmt.Println(""wrong numbers."")
                    return
                }
            }
            n = append(n[:i], n[i+1:]...)
            stack = append(stack, float64(r-'0'))
            continue
        }
        if len(stack) < 2 {
            fmt.Println(""invalid expression syntax."")
            return
        }
        switch r {
        case '+':
            stack[len(stack)-2] += stack[len(stack)-1]
        case '-':
            stack[len(stack)-2] -= stack[len(stack)-1]
        case '*':
            stack[len(stack)-2] *= stack[len(stack)-1]
        case '/':
            stack[len(stack)-2] /= stack[len(stack)-1]
        default:
            fmt.Printf(""%c invalid.\n"", r)
            return
        }
        stack = stack[:len(stack)-1]
    }
    if math.Abs(stack[0]-24) > 1e-6 {
        fmt.Println(""incorrect."", stack[0], ""!= 24"")
    } else {
        fmt.Println(""correct."")
    }
}",1727,68
78285,http://rosettacode.org/wiki/100_prisoners,100 prisoners,"

The Problem

 100 prisoners are individually numbered 1 to 100
 A room having a cupboard of 100 opaque drawers numbered 1 to 100, that cannot be seen from outside.
 Cards numbered 1 to 100 are placed randomly, one to a drawer, and the drawers all closed; at the start.
 Prisoners start outside the room
 They can decide some strategy before any enter the room.
 Prisoners enter the room one by one, can open a drawer, inspect the card number in the drawer, then close the drawer.
 A prisoner can open no more than 50 drawers.
 A prisoner tries to find his own number.
 A prisoner finding his own number is then held apart from the others.
 If all 100 prisoners find their own numbers then they will all be pardoned. If any don't then all sentences stand. 


The task

 Simulate several thousand instances of the game where the prisoners randomly open drawers
 Simulate several thousand instances of the game where the prisoners use the optimal strategy mentioned in the Wikipedia article, of:
 First opening the drawer whose outside number is his prisoner number.
 If the card within has his number then he succeeds otherwise he opens the drawer with the same number as that of the revealed card. (until he opens his maximum).


Show and compare the computed probabilities of success for the two strategies, here, on this page.




References

 The unbelievable solution to the 100 prisoner puzzle standupmaths (Video).
 wp:100 prisoners problem
 100 Prisoners Escape Puzzle DataGenetics.
 Random permutation statistics#One hundred prisoners on Wikipedia.

",#Go,Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
// Uses 0-based numbering rather than 1-based numbering throughout.
func doTrials(trials, np int, strategy string) {
    pardoned := 0
trial:
    for t := 0; t < trials; t++ {
        var drawers [100]int
        for i := 0; i < 100; i++ {
            drawers[i] = i
        }
        rand.Shuffle(100, func(i, j int) {
            drawers[i], drawers[j] = drawers[j], drawers[i]
        })
    prisoner:
        for p := 0; p < np; p++ {
            if strategy == ""optimal"" {
                prev := p
                for d := 0; d < 50; d++ {
                    this := drawers[prev]
                    if this == p {
                        continue prisoner
                    }
                    prev = this
                }
            } else {
                // Assumes a prisoner remembers previous drawers (s)he opened
                // and chooses at random from the others.
                var opened [100]bool
                for d := 0; d < 50; d++ {
                    var n int
                    for {
                        n = rand.Intn(100)
                        if !opened[n] {
                            opened[n] = true
                            break
                        }
                    }
                    if drawers[n] == p {
                        continue prisoner
                    }
                }
            }
            continue trial
        }
        pardoned++
    }
    rf := float64(pardoned) / float64(trials) * 100
    fmt.Printf(""  strategy = %-7s  pardoned = %-6d relative frequency = %5.2f%%\n\n"", strategy, pardoned, rf)
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    const trials = 100000
    for _, np := range []int{10, 100} {
        fmt.Printf(""Results from %d trials with %d prisoners:\n\n"", trials, np)
        for _, strategy := range [2]string{""random"", ""optimal""} {
            doTrials(trials, np, strategy)
        }
    }
}",1992,67
78339,http://rosettacode.org/wiki/2048,2048,"Task

Implement a 2D sliding block puzzle game where blocks with numbers are combined to add their values.



Rules of the game

   The rules are that on each turn the player must choose a direction   (up, down, left or right).
   All tiles move as far as possible in that direction, some move more than others. 
   Two adjacent tiles (in that direction only) with matching numbers combine into one bearing the sum of those numbers. 
   A move is valid when at least one tile can be moved,   if only by combination. 
   A new tile with the value of   2   is spawned at the end of each turn at a randomly chosen empty square   (if there is one). 
   Adding a new tile on a blank space.   Most of the time,   a new   2   is to be added,   and occasionally   (10% of the time),   a   4.
   To win,   the player must create a tile with the number   2048. 
   The player loses if no valid moves are possible.


The name comes from the popular open-source implementation of this game mechanic, 2048.



Requirements

   ""Non-greedy"" movement.   
  The tiles that were created by combining other tiles should not be combined again during the same turn (move).   
  That is to say,   that moving the tile row of:
               [2][2][2][2] 

 to the right should result in: 
               ......[4][4] 

 and not:
               .........[8] 

   ""Move direction priority"".   
  If more than one variant of combining is possible,   move direction shall indicate which combination will take effect. 
  For example, moving the tile row of:
               ...[2][2][2] 

 to the right should result in:
               ......[2][4] 

 and not:
               ......[4][2] 



   Check for valid moves.   The player shouldn't be able to skip their turn by trying a move that doesn't change the board.
   Check for a  win condition.
   Check for a lose condition.

",#Go,Go,"package main
 
import (
	""bufio""
	""fmt""
	""log""
	""math/rand""
	""os""
	""os/exec""
	""strconv""
	""strings""
	""text/template""
	""time""
	""unicode""
 
	""golang.org/x/crypto/ssh/terminal""
)
 
const maxPoints = 2048
const (
	fieldSizeX = 4
	fieldSizeY = 4
)
const tilesAtStart = 2
const probFor2 = 0.9
 
type button int
 
const (
	_ button = iota
	up
	down
	right
	left
	quit
)
 
var labels = func() map[button]rune {
	m := make(map[button]rune, 4)
	m[up] = 'W'
	m[down] = 'S'
	m[right] = 'D'
	m[left] = 'A'
	return m
}()
var keybinding = func() map[rune]button {
	m := make(map[rune]button, 8)
	for b, r := range labels {
		m[r] = b
		if unicode.IsUpper(r) {
			r = unicode.ToLower(r)
		} else {
			r = unicode.ToUpper(r)
		}
		m[r] = b
	}
	m[0x03] = quit
	return m
}()
 
var model = struct {
	Score int
	Field [fieldSizeY][fieldSizeX]int
}{}
 
var view = func() *template.Template {
	maxWidth := 1
	for i := maxPoints; i >= 10; i /= 10 {
		maxWidth++
	}
 
	w := maxWidth + 3
	r := make([]byte, fieldSizeX*w+1)
	for i := range r {
		if i%w == 0 {
			r[i] = '+'
		} else {
			r[i] = '-'
		}
	}
	rawBorder := string(r)
 
	v, err := template.New("""").Parse(`SCORE: {{.Score}}
{{range .Field}}
` + rawBorder + `
|{{range .}} {{if .}}{{printf ""%` + strconv.Itoa(maxWidth) + `d"" .}}{{else}}` +
		strings.Repeat("" "", maxWidth) + `{{end}} |{{end}}{{end}}
` + rawBorder + `
 
(` + string(labels[up]) + `)Up (` +
		string(labels[down]) + `)Down (` +
		string(labels[left]) + `)Left (` +
		string(labels[right]) + `)Right
`)
	check(err)
	return v
}()
 
func check(err error) {
	if err != nil {
		log.Panicln(err)
	}
}
 
func clear() {
	c := exec.Command(""clear"")
	c.Stdout = os.Stdout
	check(c.Run())
}
 
func draw() {
	clear()
	check(view.Execute(os.Stdout, model))
}
 
func addRandTile() (full bool) {
	free := make([]*int, 0, fieldSizeX*fieldSizeY)
 
	for x := 0; x < fieldSizeX; x++ {
		for y := 0; y < fieldSizeY; y++ {
			if model.Field[y][x] == 0 {
				free = append(free, &model.Field[y][x])
			}
		}
	}
 
	val := 4
	if rand.Float64() < probFor2 {
		val = 2
	}
	*free[rand.Intn(len(free))] = val
 
	return len(free) == 1
}
 
type point struct{ x, y int }
 
func (p point) get() int      { return model.Field[p.y][p.x] }
func (p point) set(n int)     { model.Field[p.y][p.x] = n }
func (p point) inField() bool { return p.x >= 0 && p.y >= 0 && p.x < fieldSizeX && p.y < fieldSizeY }
func (p *point) next(n point) { p.x += n.x; p.y += n.y }
 
func controller(key rune) (gameOver bool) {
	b := keybinding[key]
 
	if b == 0 {
		return false
	}
	if b == quit {
		return true
	}
 
	var starts []point
	var next point
 
	switch b {
	case up:
		next = point{0, 1}
		starts = make([]point, fieldSizeX)
		for x := 0; x < fieldSizeX; x++ {
			starts[x] = point{x, 0}
		}
	case down:
		next = point{0, -1}
		starts = make([]point, fieldSizeX)
		for x := 0; x < fieldSizeX; x++ {
			starts[x] = point{x, fieldSizeY - 1}
		}
	case right:
		next = point{-1, 0}
		starts = make([]point, fieldSizeY)
		for y := 0; y < fieldSizeY; y++ {
			starts[y] = point{fieldSizeX - 1, y}
		}
	case left:
		next = point{1, 0}
		starts = make([]point, fieldSizeY)
		for y := 0; y < fieldSizeY; y++ {
			starts[y] = point{0, y}
		}
	}
 
	moved := false
	winning := false
 
	for _, s := range starts {
		n := s
		move := func(set int) {
			moved = true
			s.set(set)
			n.set(0)
		}
		for n.next(next); n.inField(); n.next(next) {
			if s.get() != 0 {
				if n.get() == s.get() {
					score := s.get() * 2
					model.Score += score
					winning = score >= maxPoints
 
					move(score)
					s.next(next)
				} else if n.get() != 0 {
					s.next(next)
					if s.get() == 0 {
						move(n.get())
					}
				}
			} else if n.get() != 0 {
				move(n.get())
			}
		}
	}
 
	if !moved {
		return false
	}
 
	lost := false
	if addRandTile() {
		lost = true
	Out:
		for x := 0; x < fieldSizeX; x++ {
			for y := 0; y < fieldSizeY; y++ {
				if (y > 0 && model.Field[y][x] == model.Field[y-1][x]) ||
					(x > 0 && model.Field[y][x] == model.Field[y][x-1]) {
					lost = false
					break Out
				}
			}
		}
	}
 
	draw()
 
	if winning {
		fmt.Println(""You win!"")
		return true
	}
	if lost {
		fmt.Println(""Game Over"")
		return true
	}
 
	return false
}
 
func main() {
	oldState, err := terminal.MakeRaw(0)
	check(err)
	defer terminal.Restore(0, oldState)
 
	rand.Seed(time.Now().Unix())
 
	for i := tilesAtStart; i > 0; i-- {
		addRandTile()
	}
	draw()
 
	stdin := bufio.NewReader(os.Stdin)
 
	readKey := func() rune {
		r, _, err := stdin.ReadRune()
		check(err)
		return r
	}
 
	for !controller(readKey()) {
	}
}
 ",4553,270
78386,http://rosettacode.org/wiki/15_puzzle_game,15 puzzle game," 


Task

Implement the Fifteen Puzzle Game.



The   15-puzzle   is also known as:

   Fifteen Puzzle
   Gem Puzzle
   Boss Puzzle
   Game of Fifteen
   Mystic Square
   14-15 Puzzle
   and some others.


Related Tasks

   15 Puzzle Solver
   16 Puzzle Game

",#Go,Go,"package main
 
import (
	""fmt""
	""math/rand""
	""strings""
	""time""
)
 
func main() {
	rand.Seed(time.Now().UnixNano())
	p := newPuzzle()
	p.play()
}
 
type board [16]cell
type cell uint8
type move uint8
 
const (
	up move = iota
	down
	right
	left
)
 
func randMove() move { return move(rand.Intn(4)) }
 
var solvedBoard = board{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0}
 
func (b *board) String() string {
	var buf strings.Builder
	for i, c := range b {
		if c == 0 {
			buf.WriteString(""  ."")
		} else {
			_, _ = fmt.Fprintf(&buf, ""%3d"", c)
		}
		if i%4 == 3 {
			buf.WriteString(""\n"")
		}
	}
	return buf.String()
}
 
type puzzle struct {
	board board
	empty int // board[empty] == 0
	moves int
	quit  bool
}
 
func newPuzzle() *puzzle {
	p := &puzzle{
		board: solvedBoard,
		empty: 15,
	}
	// Could make this configurable, 10==easy, 50==normal, 100==hard
	p.shuffle(50)
	return p
}
 
func (p *puzzle) shuffle(moves int) {
	// As with other Rosetta solutions, we use some number
	// of random moves to ""shuffle"" the board.
	for i := 0; i < moves || p.board == solvedBoard; {
		if p.doMove(randMove()) {
			i++
		}
	}
}
 
func (p *puzzle) isValidMove(m move) (newIndex int, ok bool) {
	switch m {
	case up:
		return p.empty - 4, p.empty/4 > 0
	case down:
		return p.empty + 4, p.empty/4 < 3
	case right:
		return p.empty + 1, p.empty%4 < 3
	case left:
		return p.empty - 1, p.empty%4 > 0
	default:
		panic(""not reached"")
	}
}
 
func (p *puzzle) doMove(m move) bool {
	i := p.empty
	j, ok := p.isValidMove(m)
	if ok {
		p.board[i], p.board[j] = p.board[j], p.board[i]
		p.empty = j
		p.moves++
	}
	return ok
}
 
func (p *puzzle) play() {
	fmt.Printf(""Starting board:"")
	for p.board != solvedBoard && !p.quit {
		fmt.Printf(""\n%v\n"", &p.board)
		p.playOneMove()
	}
	if p.board == solvedBoard {
		fmt.Printf(""You solved the puzzle in %d moves.\n"", p.moves)
	}
}
 
func (p *puzzle) playOneMove() {
	for {
		fmt.Printf(""Enter move #%d (U, D, L, R, or Q): "", p.moves+1)
		var s string
		if n, err := fmt.Scanln(&s); err != nil || n != 1 {
			continue
		}
 
		s = strings.TrimSpace(s)
		if s == """" {
			continue
		}
 
		var m move
		switch s[0] {
		case 'U', 'u':
			m = up
		case 'D', 'd':
			m = down
		case 'L', 'l':
			m = left
		case 'R', 'r':
			m = right
		case 'Q', 'q':
			fmt.Printf(""Quiting after %d moves.\n"", p.moves)
			p.quit = true
			return
		default:
			fmt.Println(`
Please enter ""U"", ""D"", ""L"", or ""R"" to move the empty cell
up, down, left, or right. You can also enter ""Q"" to quit.
Upper or lowercase is accepted and only the first non-blank
character is important (i.e. you may enter ""up"" if you like).
`)
			continue
		}
 
		if !p.doMove(m) {
			fmt.Println(""That is not a valid move at the moment."")
			continue
		}
 
		return
	}
}",2758,154
78610,http://rosettacode.org/wiki/A%2BB,A+B,"A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.



Task

Given two integers,   A and B.

Their sum needs to be calculated.



Input data

Two integers are written in the input stream, separated by space(s):

 



(
−
1000
≤
A
,
B
≤
+
1000
)


{\displaystyle (-1000\leq A,B\leq +1000)}




Output data

The required output is one integer:   the sum of A and B.



Example



 input  

 output  


 2 2 

 4 


 3 2 

 5 


",#Go,Go,"package main
 
import ""fmt""
 
func main() {
    var a, b int
    fmt.Scan(&a, &b)
    fmt.Println(a + b)
}",106,9
78789,http://rosettacode.org/wiki/99_bottles_of_beer,99 bottles of beer,"Task

Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.



The beer song

The lyrics follow this form:


 99 bottles of beer on the wall

 99 bottles of beer

 Take one down, pass it around

 98 bottles of beer on the wall


 98 bottles of beer on the wall

 98 bottles of beer

 Take one down, pass it around

 97 bottles of beer on the wall

... and so on, until reaching   0     (zero).

Grammatical support for   1 bottle of beer   is optional.

As with any puzzle, try to do it in as creative/concise/comical a way
as possible (simple, obvious solutions allowed, too).




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




See also
 
   http://99-bottles-of-beer.net/
   Category:99_Bottles_of_Beer
   Category:Programming language families
   Wikipedia 99 bottles of beer

",#Go,Go,"package main
 
import ""fmt""
 
func main() {
	bottles := func(i int) string {
		switch i {
		case 0:
			return ""No more bottles""
		case 1:
			return ""1 bottle""
		default:
			return fmt.Sprintf(""%d bottles"", i)
		}
	}
 
	for i := 99; i > 0; i-- {
		fmt.Printf(""%s of beer on the wall\n"", bottles(i))
		fmt.Printf(""%s of beer\n"", bottles(i))
		fmt.Printf(""Take one down, pass it around\n"")
		fmt.Printf(""%s of beer on the wall\n"", bottles(i-1))
	}
}",446,23
