task_name,task_description,language_name,code,code_length,line_count,generated_code,file_path,compilation_status,runtime_errors_count,line_coverage_percent,branch_coverage_percent,assertions_density,assertions_mccabe_ratio,execution_time_sec,warnings_count,warnings,timeout_occurred,internal_error_occurred,test_pass_percentage,timeout,syntax_output
100 doors,"There are 100 doors in a row that are all initially closed.

You make 100 passes by the doors.

The first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).

The second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.

The third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.



Task

Answer the question:   what state are the doors in after the last pass?   Which are open, which are closed?


Alternate:
As noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.

Opening only those doors is an   optimization   that may also be expressed;
however, as should be obvious, this defeats the intent of comparing implementations across programming languages.



",Go,"package main
 
import ""fmt""
 
func main() {
    doors := [100]bool{}
 
    // the 100 passes called for in the task description
    for pass := 1; pass <= 100; pass++ {
        for door := pass-1; door < 100; door += pass {
            doors[door] = !doors[door]
        }
    }
 
    // one more pass to answer the question
    for i, v := range doors {
        if v {
            fmt.Print(""1"")
        } else {
            fmt.Print(""0"")
        }
 
        if i%10 == 9 {
            fmt.Print(""\n"")
        } else {
            fmt.Print("" "")
        }
 
    }
}",567,30,"package main

import (
	""testing""
	""reflect""
)

func TestDoors(t *testing.T) {
	expected := [100]bool{}
	for i := 0; i < 100; i++ {
		if isPerfectSquare(i + 1) {
			expected[i] = true
		}
	}

	doors := [100]bool{}

	for pass := 1; pass <= 100; pass++ {
		for door := pass - 1; door < 100; door += pass {
			doors[door] = !doors[door]
		}
	}

	if !reflect.DeepEqual(doors, expected) {
		t.Errorf(""Expected doors state to be %v, but got %v"", expected, doors)
	}
}

func isPerfectSquare(n int) bool {
	root := int(float64(n) + 0.5)
	return root*root == n
}
",./data/generated/docs_golang/100_doors/gpt_4o_2024_08_06_100_doors_test.go,CompileStatus.OK,0.0,0.0,,0.06,0.17,0.148,0.0,[],False,False,0.0,False,[]
100 prisoners,"

The Problem

 100 prisoners are individually numbered 1 to 100
 A room having a cupboard of 100 opaque drawers numbered 1 to 100, that cannot be seen from outside.
 Cards numbered 1 to 100 are placed randomly, one to a drawer, and the drawers all closed; at the start.
 Prisoners start outside the room
 They can decide some strategy before any enter the room.
 Prisoners enter the room one by one, can open a drawer, inspect the card number in the drawer, then close the drawer.
 A prisoner can open no more than 50 drawers.
 A prisoner tries to find his own number.
 A prisoner finding his own number is then held apart from the others.
 If all 100 prisoners find their own numbers then they will all be pardoned. If any don't then all sentences stand. 


The task

 Simulate several thousand instances of the game where the prisoners randomly open drawers
 Simulate several thousand instances of the game where the prisoners use the optimal strategy mentioned in the Wikipedia article, of:
 First opening the drawer whose outside number is his prisoner number.
 If the card within has his number then he succeeds otherwise he opens the drawer with the same number as that of the revealed card. (until he opens his maximum).


Show and compare the computed probabilities of success for the two strategies, here, on this page.




References

 The unbelievable solution to the 100 prisoner puzzle standupmaths (Video).
 wp:100 prisoners problem
 100 Prisoners Escape Puzzle DataGenetics.
 Random permutation statistics#One hundred prisoners on Wikipedia.

",Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
// Uses 0-based numbering rather than 1-based numbering throughout.
func doTrials(trials, np int, strategy string) {
    pardoned := 0
trial:
    for t := 0; t < trials; t++ {
        var drawers [100]int
        for i := 0; i < 100; i++ {
            drawers[i] = i
        }
        rand.Shuffle(100, func(i, j int) {
            drawers[i], drawers[j] = drawers[j], drawers[i]
        })
    prisoner:
        for p := 0; p < np; p++ {
            if strategy == ""optimal"" {
                prev := p
                for d := 0; d < 50; d++ {
                    this := drawers[prev]
                    if this == p {
                        continue prisoner
                    }
                    prev = this
                }
            } else {
                // Assumes a prisoner remembers previous drawers (s)he opened
                // and chooses at random from the others.
                var opened [100]bool
                for d := 0; d < 50; d++ {
                    var n int
                    for {
                        n = rand.Intn(100)
                        if !opened[n] {
                            opened[n] = true
                            break
                        }
                    }
                    if drawers[n] == p {
                        continue prisoner
                    }
                }
            }
            continue trial
        }
        pardoned++
    }
    rf := float64(pardoned) / float64(trials) * 100
    fmt.Printf(""  strategy = %-7s  pardoned = %-6d relative frequency = %5.2f%%\n\n"", strategy, pardoned, rf)
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    const trials = 100000
    for _, np := range []int{10, 100} {
        fmt.Printf(""Results from %d trials with %d prisoners:\n\n"", trials, np)
        for _, strategy := range [2]string{""random"", ""optimal""} {
            doTrials(trials, np, strategy)
        }
    }
}",1992,67,"package main

import (
    ""testing""
    ""math/rand""
    ""time""
)

// TestRandomStrategy tests the random strategy for different numbers of prisoners.
func TestRandomStrategy(t *testing.T) {
    rand.Seed(time.Now().UnixNano())
    trials := 10000
    for _, np := range []int{10, 100} {
        pardoned := 0
    trial:
        for t := 0; t < trials; t++ {
            var drawers [100]int
            for i := 0; i < 100; i++ {
                drawers[i] = i
            }
            rand.Shuffle(100, func(i, j int) {
                drawers[i], drawers[j] = drawers[j], drawers[i]
            })
        prisoner:
            for p := 0; p < np; p++ {
                var opened [100]bool
                for d := 0; d < 50; d++ {
                    var n int
                    for {
                        n = rand.Intn(100)
                        if !opened[n] {
                            opened[n] = true
                            break
                        }
                    }
                    if drawers[n] == p {
                        continue prisoner
                    }
                }
                continue trial
            }
            pardoned++
        }
        rf := float64(pardoned) / float64(trials) * 100
        t.Logf(""Random strategy with %d prisoners: pardoned = %d, relative frequency = %.2f%%"", np, pardoned, rf)
    }
}

// TestOptimalStrategy tests the optimal strategy for different numbers of prisoners.
func TestOptimalStrategy(t *testing.T) {
    rand.Seed(time.Now().UnixNano())
    trials := 10000
    for _, np := range []int{10, 100} {
        pardoned := 0
    trial:
        for t := 0; t < trials; t++ {
            var drawers [100]int
            for i := 0; i < 100; i++ {
                drawers[i] = i
            }
            rand.Shuffle(100, func(i, j int) {
                drawers[i], drawers[j] = drawers[j], drawers[i]
            })
        prisoner:
            for p := 0; p < np; p++ {
                prev := p
                for d := 0; d < 50; d++ {
                    this := drawers[prev]
                    if this == p {
                        continue prisoner
                    }
                    prev = this
                }
                continue trial
            }
            pardoned++
        }
        rf := float64(pardoned) / float64(trials) * 100
        t.Logf(""Optimal strategy with %d prisoners: pardoned = %d, relative frequency = %.2f%%"", np, pardoned, rf)
    }
}
",./data/generated/docs_golang/100_prisoners/gpt_4o_2024_08_06_100_prisoners_test.go,CompileStatus.OK,0.0,0.0,,0.0,0.0,1.124,2.0,"[{'FromLinter': 'staticcheck', 'Text': 'SA1019: rand.Seed has been deprecated since Go 1.20 and an alternative has been available since Go 1.0: As of Go 1.20 there is no reason to call Seed with a random value. Programs that call Seed with a known value to get a specific sequence of results should use New(NewSource(seed)) to obtain a local random generator. ', 'Severity': '', 'SourceLines': ['    rand.Seed(time.Now().UnixNano())'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_100_prisoners_test.go', 'Offset': 195, 'Line': 11, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'staticcheck', 'Text': 'SA1019: rand.Seed has been deprecated since Go 1.20 and an alternative has been available since Go 1.0: As of Go 1.20 there is no reason to call Seed with a random value. Programs that call Seed with a known value to get a specific sequence of results should use New(NewSource(seed)) to obtain a local random generator. ', 'Severity': '', 'SourceLines': ['    rand.Seed(time.Now().UnixNano())'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_100_prisoners_test.go', 'Offset': 1514, 'Line': 51, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
24 game,"The 24 Game tests one's mental arithmetic.



Task
Write a program that randomly chooses and displays four digits, each from 1 ──► 9 (inclusive) with repetitions allowed.

The program should prompt for the player to enter an arithmetic expression using just those, and all of those four digits, used exactly once each. The program should check then evaluate the expression.

The goal is for the player to enter an expression that (numerically) evaluates to 24.

 Only the following operators/functions are allowed: multiplication, division, addition, subtraction
 Division should use floating point or rational arithmetic, etc, to preserve remainders.
 Brackets are allowed, if using an infix expression evaluator.
 Forming multiple digit numbers from the supplied digits is disallowed. (So an answer of 12+12 when given 1, 2, 2, and 1 is wrong).
 The order of the digits when given does not have to be preserved.


Notes
 The type of expression evaluator used is not mandated. An RPN evaluator is equally acceptable for example.
 The task is not for the program to generate the expression, or test whether an expression is even possible.


Related tasks
 24 game/Solve


Reference
 The 24 Game on h2g2.

",Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/rand""
    ""time""
)
 
func main() {
    rand.Seed(time.Now().Unix())
    n := make([]rune, 4)
    for i := range n {
        n[i] = rune(rand.Intn(9) + '1')
    }
    fmt.Printf(""Your numbers: %c\n"", n)
    fmt.Print(""Enter RPN: "")
    var expr string
    fmt.Scan(&expr)
    if len(expr) != 7 {
        fmt.Println(""invalid. expression length must be 7."" +
            "" (4 numbers, 3 operators, no spaces)"")
        return
    }
    stack := make([]float64, 0, 4)
    for _, r := range expr {
        if r >= '0' && r <= '9' {
            if len(n) == 0 {
                fmt.Println(""too many numbers."")
                return
            }
            i := 0
            for n[i] != r {
                i++
                if i == len(n) {
                    fmt.Println(""wrong numbers."")
                    return
                }
            }
            n = append(n[:i], n[i+1:]...)
            stack = append(stack, float64(r-'0'))
            continue
        }
        if len(stack) < 2 {
            fmt.Println(""invalid expression syntax."")
            return
        }
        switch r {
        case '+':
            stack[len(stack)-2] += stack[len(stack)-1]
        case '-':
            stack[len(stack)-2] -= stack[len(stack)-1]
        case '*':
            stack[len(stack)-2] *= stack[len(stack)-1]
        case '/':
            stack[len(stack)-2] /= stack[len(stack)-1]
        default:
            fmt.Printf(""%c invalid.\n"", r)
            return
        }
        stack = stack[:len(stack)-1]
    }
    if math.Abs(stack[0]-24) > 1e-6 {
        fmt.Println(""incorrect."", stack[0], ""!= 24"")
    } else {
        fmt.Println(""correct."")
    }
}",1727,68,"package main

import (
    ""bytes""
    ""io""
    ""math/rand""
    ""os""
    ""strings""
    ""testing""
    ""time""
)

func TestMain(t *testing.T) {
    // Seed the random number generator for reproducibility
    rand.Seed(1)

    // Redirect stdout to capture output
    originalStdout := os.Stdout
    r, w, _ := os.Pipe()
    os.Stdout = w

    // Redirect stdin to simulate user input
    originalStdin := os.Stdin
    input := ""123+*""
    rIn, wIn, _ := os.Pipe()
    wIn.WriteString(input)
    wIn.Close()
    os.Stdin = rIn

    // Run the main function
    main()

    // Restore stdin
    os.Stdin = originalStdin

    // Capture and restore stdout
    w.Close()
    var buf bytes.Buffer
    io.Copy(&buf, r)
    os.Stdout = originalStdout

    output := buf.String()

    // Check if the output contains the expected numbers
    if !strings.Contains(output, ""Your numbers: 1234"") {
        t.Errorf(""Expected numbers not found in output: %s"", output)
    }

    // Check if the output contains the expected result
    if !strings.Contains(output, ""incorrect."") {
        t.Errorf(""Expected 'incorrect.' in output: %s"", output)
    }
}

func TestInvalidExpressionLength(t *testing.T) {
    rand.Seed(1)

    originalStdout := os.Stdout
    r, w, _ := os.Pipe()
    os.Stdout = w

    originalStdin := os.Stdin
    input := ""12+""
    rIn, wIn, _ := os.Pipe()
    wIn.WriteString(input)
    wIn.Close()
    os.Stdin = rIn

    main()

    os.Stdin = originalStdin

    w.Close()
    var buf bytes.Buffer
    io.Copy(&buf, r)
    os.Stdout = originalStdout

    output := buf.String()

    if !strings.Contains(output, ""invalid. expression length must be 7."") {
        t.Errorf(""Expected 'invalid. expression length must be 7.' in output: %s"", output)
    }
}

func TestTooManyNumbers(t *testing.T) {
    rand.Seed(1)

    originalStdout := os.Stdout
    r, w, _ := os.Pipe()
    os.Stdout = w

    originalStdin := os.Stdin
    input := ""12345++""
    rIn, wIn, _ := os.Pipe()
    wIn.WriteString(input)
    wIn.Close()
    os.Stdin = rIn

    main()

    os.Stdin = originalStdin

    w.Close()
    var buf bytes.Buffer
    io.Copy(&buf, r)
    os.Stdout = originalStdout

    output := buf.String()

    if !strings.Contains(output, ""too many numbers."") {
        t.Errorf(""Expected 'too many numbers.' in output: %s"", output)
    }
}

func TestWrongNumbers(t *testing.T) {
    rand.Seed(1)

    originalStdout := os.Stdout
    r, w, _ := os.Pipe()
    os.Stdout = w

    originalStdin := os.Stdin
    input := ""567+*""
    rIn, wIn, _ := os.Pipe()
    wIn.WriteString(input)
    wIn.Close()
    os.Stdin = rIn

    main()

    os.Stdin = originalStdin

    w.Close()
    var buf bytes.Buffer
    io.Copy(&buf, r)
    os.Stdout = originalStdout

    output := buf.String()

    if !strings.Contains(output, ""wrong numbers."") {
        t.Errorf(""Expected 'wrong numbers.' in output: %s"", output)
    }
}

func TestInvalidExpressionSyntax(t *testing.T) {
    rand.Seed(1)

    originalStdout := os.Stdout
    r, w, _ := os.Pipe()
    os.Stdout = w

    originalStdin := os.Stdin
    input := ""1+""
    rIn, wIn, _ := os.Pipe()
    wIn.WriteString(input)
    wIn.Close()
    os.Stdin = rIn

    main()

    os.Stdin = originalStdin

    w.Close()
    var buf bytes.Buffer
    io.Copy(&buf, r)
    os.Stdout = originalStdout

    output := buf.String()

    if !strings.Contains(output, ""invalid expression syntax."") {
        t.Errorf(""Expected 'invalid expression syntax.' in output: %s"", output)
    }
}

func TestInvalidOperator(t *testing.T) {
    rand.Seed(1)

    originalStdout := os.Stdout
    r, w, _ := os.Pipe()
    os.Stdout = w

    originalStdin := os.Stdin
    input := ""1234&""
    rIn, wIn, _ := os.Pipe()
    wIn.WriteString(input)
    wIn.Close()
    os.Stdin = rIn

    main()

    os.Stdin = originalStdin

    w.Close()
    var buf bytes.Buffer
    io.Copy(&buf, r)
    os.Stdout = originalStdout

    output := buf.String()

    if !strings.Contains(output, ""& invalid."") {
        t.Errorf(""Expected '& invalid.' in output: %s"", output)
    }
}

func TestCorrectExpression(t *testing.T) {
    rand.Seed(1)

    originalStdout := os.Stdout
    r, w, _ := os.Pipe()
    os.Stdout = w

    originalStdin := os.Stdin
    input := ""342*+""
    rIn, wIn, _ := os.Pipe()
    wIn.WriteString(input)
    wIn.Close()
    os.Stdin = rIn

    main()

    os.Stdin = originalStdin

    w.Close()
    var buf bytes.Buffer
    io.Copy(&buf, r)
    os.Stdout = originalStdout

    output := buf.String()

    if !strings.Contains(output, ""correct."") {
        t.Errorf(""Expected 'correct.' in output: %s"", output)
    }
}
",./data/generated/docs_golang/24_game/gpt_4o_2024_08_06_24_game_test.go,CompileStatus.SYNTAX_ERROR,,,,0.11,1.07,,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['    main()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_24_game_test.go', 'Offset': 0, 'Line': 31, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['    main()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_24_game_test.go', 'Offset': 0, 'Line': 69, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['    main()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_24_game_test.go', 'Offset': 0, 'Line': 99, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""time"" imported and not used', 'Severity': '', 'SourceLines': ['    ""time""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_24_game_test.go', 'Offset': 0, 'Line': 10, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_24_game_test.go', 'line': 10, 'column': 5, 'message': '""time"" imported and not used'}]"
24 game/Solve,"task

Write a program that takes four digits, either from user input or by random generation, and computes arithmetic expressions following the rules of the 24 game.

Show examples of solutions generated by the program.



Related task

   Arithmetic Evaluator

",Go,"package main
 
import (
	""fmt""
	""math/rand""
	""time""
)
 
const (
	op_num = iota
	op_add
	op_sub
	op_mul
	op_div
)
 
type frac struct {
	num, denom int
}
 
// Expression: can either be a single number, or a result of binary
// operation from left and right node
type Expr struct {
	op          int
	left, right *Expr
	value       frac
}
 
var n_cards = 4
var goal = 24
var digit_range = 9
 
func (x *Expr) String() string {
	if x.op == op_num {
		return fmt.Sprintf(""%d"", x.value.num)
	}
 
	var bl1, br1, bl2, br2, opstr string
	switch {
	case x.left.op == op_num:
	case x.left.op >= x.op:
	case x.left.op == op_add && x.op == op_sub:
		bl1, br1 = """", """"
	default:
		bl1, br1 = ""("", "")""
	}
 
	if x.right.op == op_num || x.op < x.right.op {
		bl2, br2 = """", """"
	} else {
		bl2, br2 = ""("", "")""
	}
 
	switch {
	case x.op == op_add:
		opstr = "" + ""
	case x.op == op_sub:
		opstr = "" - ""
	case x.op == op_mul:
		opstr = "" * ""
	case x.op == op_div:
		opstr = "" / ""
	}
 
	return bl1 + x.left.String() + br1 + opstr +
		bl2 + x.right.String() + br2
}
 
func expr_eval(x *Expr) (f frac) {
	if x.op == op_num {
		return x.value
	}
 
	l, r := expr_eval(x.left), expr_eval(x.right)
 
	switch x.op {
	case op_add:
		f.num = l.num*r.denom + l.denom*r.num
		f.denom = l.denom * r.denom
		return
 
	case op_sub:
		f.num = l.num*r.denom - l.denom*r.num
		f.denom = l.denom * r.denom
		return
 
	case op_mul:
		f.num = l.num * r.num
		f.denom = l.denom * r.denom
		return
 
	case op_div:
		f.num = l.num * r.denom
		f.denom = l.denom * r.num
		return
	}
	return
}
 
func solve(ex_in []*Expr) bool {
	// only one expression left, meaning all numbers are arranged into
	// a binary tree, so evaluate and see if we get 24
	if len(ex_in) == 1 {
		f := expr_eval(ex_in[0])
		if f.denom != 0 && f.num == f.denom*goal {
			fmt.Println(ex_in[0].String())
			return true
		}
		return false
	}
 
	var node Expr
	ex := make([]*Expr, len(ex_in)-1)
 
	// try to combine a pair of expressions into one, thus reduce
	// the list length by 1, and recurse down
	for i := range ex {
		copy(ex[i:len(ex)], ex_in[i+1:len(ex_in)])
 
		ex[i] = &node
		for j := i + 1; j < len(ex_in); j++ {
			node.left = ex_in[i]
			node.right = ex_in[j]
 
			// try all 4 operators
			for o := op_add; o <= op_div; o++ {
				node.op = o
				if solve(ex) {
					return true
				}
			}
 
			// also - and / are not commutative, so swap arguments
			node.left = ex_in[j]
			node.right = ex_in[i]
 
			node.op = op_sub
			if solve(ex) {
				return true
			}
 
			node.op = op_div
			if solve(ex) {
				return true
			}
 
			if j < len(ex) {
				ex[j] = ex_in[j]
			}
		}
		ex[i] = ex_in[i]
	}
	return false
}
 
func main() {
	cards := make([]*Expr, n_cards)
	rand.Seed(time.Now().Unix())
 
	for k := 0; k < 10; k++ {
		for i := 0; i < n_cards; i++ {
			cards[i] = &Expr{op_num, nil, nil,
				frac{rand.Intn(digit_range-1) + 1, 1}}
			fmt.Printf("" %d"", cards[i].value.num)
		}
		fmt.Print("":  "")
		if !solve(cards) {
			fmt.Println(""No solution"")
		}
	}
}",2993,171,"package main

import (
	""testing""
)

func TestExprString(t *testing.T) {
	tests := []struct {
		expr     Expr
		expected string
	}{
		{Expr{op: op_num, value: frac{num: 3}}, ""3""},
		{Expr{op: op_add, left: &Expr{op: op_num, value: frac{num: 3}}, right: &Expr{op: op_num, value: frac{num: 4}}}, ""3 + 4""},
		{Expr{op: op_sub, left: &Expr{op: op_num, value: frac{num: 7}}, right: &Expr{op: op_num, value: frac{num: 2}}}, ""7 - 2""},
		{Expr{op: op_mul, left: &Expr{op: op_num, value: frac{num: 5}}, right: &Expr{op: op_num, value: frac{num: 6}}}, ""5 * 6""},
		{Expr{op: op_div, left: &Expr{op: op_num, value: frac{num: 8}}, right: &Expr{op: op_num, value: frac{num: 4}}}, ""8 / 4""},
	}

	for _, test := range tests {
		result := test.expr.String()
		if result != test.expected {
			t.Errorf(""Expected %s, got %s"", test.expected, result)
		}
	}
}

func TestExprEval(t *testing.T) {
	tests := []struct {
		expr     Expr
		expected frac
	}{
		{Expr{op: op_num, value: frac{num: 3, denom: 1}}, frac{num: 3, denom: 1}},
		{Expr{op: op_add, left: &Expr{op: op_num, value: frac{num: 3, denom: 1}}, right: &Expr{op: op_num, value: frac{num: 4, denom: 1}}}, frac{num: 7, denom: 1}},
		{Expr{op: op_sub, left: &Expr{op: op_num, value: frac{num: 7, denom: 1}}, right: &Expr{op: op_num, value: frac{num: 2, denom: 1}}}, frac{num: 5, denom: 1}},
		{Expr{op: op_mul, left: &Expr{op: op_num, value: frac{num: 5, denom: 1}}, right: &Expr{op: op_num, value: frac{num: 6, denom: 1}}}, frac{num: 30, denom: 1}},
		{Expr{op: op_div, left: &Expr{op: op_num, value: frac{num: 8, denom: 1}}, right: &Expr{op: op_num, value: frac{num: 4, denom: 1}}}, frac{num: 2, denom: 1}},
	}

	for _, test := range tests {
		result := expr_eval(&test.expr)
		if result != test.expected {
			t.Errorf(""Expected %v, got %v"", test.expected, result)
		}
	}
}

func TestSolve(t *testing.T) {
	tests := []struct {
		exprs    []*Expr
		expected bool
	}{
		{
			[]*Expr{
				{op: op_num, value: frac{num: 6, denom: 1}},
				{op: op_num, value: frac{num: 6, denom: 1}},
				{op: op_num, value: frac{num: 6, denom: 1}},
				{op: op_num, value: frac{num: 6, denom: 1}},
			},
			true,
		},
		{
			[]*Expr{
				{op: op_num, value: frac{num: 1, denom: 1}},
				{op: op_num, value: frac{num: 1, denom: 1}},
				{op: op_num, value: frac{num: 1, denom: 1}},
				{op: op_num, value: frac{num: 1, denom: 1}},
			},
			false,
		},
	}

	for _, test := range tests {
		result := solve(test.exprs)
		if result != test.expected {
			t.Errorf(""Expected %v, got %v"", test.expected, result)
		}
	}
}
",./data/generated/docs_golang/24_game_solve/gpt_4o_2024_08_06_24_game_solve_test.go,CompileStatus.OK,0.0,78.9,,0.06,0.09,0.114,9.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: Expr', 'Severity': '', 'SourceLines': ['\t\texpr     Expr'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_24_game_solve_test.go', 'Offset': 0, 'Line': 9, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Expr', 'Severity': '', 'SourceLines': ['\t\t{Expr{op: op_num, value: frac{num: 3}}, ""3""},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_24_game_solve_test.go', 'Offset': 0, 'Line': 12, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Expr', 'Severity': '', 'SourceLines': ['\t\t{Expr{op: op_add, left: &Expr{op: op_num, value: frac{num: 3}}, right: &Expr{op: op_num, value: frac{num: 4}}}, ""3 + 4""},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_24_game_solve_test.go', 'Offset': 0, 'Line': 13, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: frac', 'Severity': '', 'SourceLines': ['\t\texpected frac'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_24_game_solve_test.go', 'Offset': 0, 'Line': 30, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: expr_eval', 'Severity': '', 'SourceLines': ['\t\tresult := expr_eval(&test.expr)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_24_game_solve_test.go', 'Offset': 0, 'Line': 40, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: op_num', 'Severity': '', 'SourceLines': ['\t\t\t\t{op: op_num, value: frac{num: 6, denom: 1}},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_24_game_solve_test.go', 'Offset': 0, 'Line': 54, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: op_num', 'Severity': '', 'SourceLines': ['\t\t\t\t{op: op_num, value: frac{num: 6, denom: 1}},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_24_game_solve_test.go', 'Offset': 0, 'Line': 55, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: op_num', 'Severity': '', 'SourceLines': ['\t\t\t\t{op: op_num, value: frac{num: 6, denom: 1}},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_24_game_solve_test.go', 'Offset': 0, 'Line': 56, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: solve', 'Severity': '', 'SourceLines': ['\t\tresult := solve(test.exprs)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_24_game_solve_test.go', 'Offset': 0, 'Line': 73, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,66.67,False,[]
A+B,"A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.



Task

Given two integers,   A and B.

Their sum needs to be calculated.



Input data

Two integers are written in the input stream, separated by space(s):

 



(
−
1000
≤
A
,
B
≤
+
1000
)


{\displaystyle (-1000\leq A,B\leq +1000)}




Output data

The required output is one integer:   the sum of A and B.



Example



 input  

 output  


 2 2 

 4 


 3 2 

 5 


",Go,"package main
 
import ""fmt""
 
func main() {
    var a, b int
    fmt.Scan(&a, &b)
    fmt.Println(a + b)
}",106,9,"package main

import (
	""bytes""
	""fmt""
	""os""
	""strconv""
	""strings""
	""testing""
)

func TestMain(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{""2 2\n"", ""4\n""},
		{""3 2\n"", ""5\n""},
		{""-1000 1000\n"", ""0\n""},
		{""-1000 -1000\n"", ""-2000\n""},
		{""1000 1000\n"", ""2000\n""},
		{""0 0\n"", ""0\n""},
		{""-500 500\n"", ""0\n""},
		{""-1 -1\n"", ""-2\n""},
		{""1 -1\n"", ""0\n""},
	}

	for _, tt := range tests {
		t.Run(fmt.Sprintf(""input: %s"", tt.input), func(t *testing.T) {
			// Redirect stdin
			oldStdin := os.Stdin
			defer func() { os.Stdin = oldStdin }()
			os.Stdin = bytes.NewBufferString(tt.input)

			// Capture stdout
			oldStdout := os.Stdout
			r, w, _ := os.Pipe()
			os.Stdout = w

			main()

			w.Close()
			out, _ := os.ReadFile(r.Name())
			os.Stdout = oldStdout

			// Compare output
			output := strings.TrimSpace(string(out))
			expected := strings.TrimSpace(tt.expected)
			if output != expected {
				t.Errorf(""expected %s, got %s"", expected, output)
			}
		})
	}
}
",./data/generated/docs_golang/a_b/gpt_4o_2024_08_06_a_b_test.go,CompileStatus.SYNTAX_ERROR,,,,0.05,1.0,,3.0,"[{'FromLinter': 'typecheck', 'Text': 'cannot use bytes.NewBufferString(tt.input) (value of type *bytes.Buffer) as *os.File value in assignment', 'Severity': '', 'SourceLines': ['\t\t\tos.Stdin = bytes.NewBufferString(tt.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_a_b_test.go', 'Offset': 0, 'Line': 33, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\t\t\tmain()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_a_b_test.go', 'Offset': 0, 'Line': 40, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""strconv"" imported and not used', 'Severity': '', 'SourceLines': ['\t""strconv""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_a_b_test.go', 'Offset': 0, 'Line': 7, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_a_b_test.go', 'line': 33, 'column': 15, 'message': 'cannot use bytes.NewBufferString(tt.input) (value of type *bytes.Buffer) as *os.File value in assignment'}]"
ABC problem,"ABC problem

You are encouraged to solve this task according to the task description, using any language you may know.
You are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).

There are twenty blocks with two letters on each block.

A complete alphabet is guaranteed amongst all sides of the blocks.

The sample collection of blocks:

 (B O)
 (X K)
 (D Q)
 (C P)
 (N A)
 (G T)
 (R E)
 (T G)
 (Q D)
 (F S)
 (J W)
 (H U)
 (V I)
 (A N)
 (O B)
 (E R)
 (F S)
 (L Y)
 (P C)
 (Z M)



Task

Write a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.



The rules are simple:

   Once a letter on a block is used that block cannot be used again
   The function should be case-insensitive
   Show the output on this page for the following 7 words in the following example


Example

    >>> can_make_word(""A"")
    True
    >>> can_make_word(""BARK"")
    True
    >>> can_make_word(""BOOK"")
    False
    >>> can_make_word(""TREAT"")
    True
    >>> can_make_word(""COMMON"")
    False
    >>> can_make_word(""SQUAD"")
    True
    >>> can_make_word(""CONFUSE"")
    True

Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Go,"package main
 
import (
	""fmt""
	""strings""
)
 
func newSpeller(blocks string) func(string) bool {
	bl := strings.Fields(blocks)
	return func(word string) bool {
		return r(word, bl)
	}
}
 
func r(word string, bl []string) bool {
	if word == """" {
		return true
	}
	c := word[0] | 32
	for i, b := range bl {
		if c == b[0]|32 || c == b[1]|32 {
			bl[i], bl[0] = bl[0], b
			if r(word[1:], bl[1:]) == true {
				return true
			}
			bl[i], bl[0] = bl[0], bl[i]
		}
	}
	return false
}
 
func main() {
	sp := newSpeller(
		""BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM"")
	for _, word := range []string{
		""A"", ""BARK"", ""BOOK"", ""TREAT"", ""COMMON"", ""SQUAD"", ""CONFUSE""} {
		fmt.Println(word, sp(word))
	}
}",709,39,"package main

import (
	""testing""
)

func TestCanMakeWord(t *testing.T) {
	sp := newSpeller(
		""BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM"")

	tests := []struct {
		word     string
		expected bool
	}{
		{""A"", true},
		{""BARK"", true},
		{""BOOK"", false},
		{""TREAT"", true},
		{""COMMON"", false},
		{""SQUAD"", true},
		{""CONFUSE"", true},
	}

	for _, test := range tests {
		result := sp(test.word)
		if result != test.expected {
			t.Errorf(""For word %s, expected %v, but got %v"", test.word, test.expected, result)
		}
	}
}
",./data/generated/docs_golang/abc_problem/gpt_4o_2024_08_06_abc_problem_test.go,CompileStatus.OK,0.0,81.2,,0.06,0.1,0.114,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: newSpeller', 'Severity': '', 'SourceLines': ['\tsp := newSpeller('], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_abc_problem_test.go', 'Offset': 0, 'Line': 8, 'Column': 8}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
AKS test for primes,"The AKS algorithm for testing whether a number is prime is a polynomial-time algorithm based on an elementary theorem about Pascal triangles.

The theorem on which the test is based can be stated as follows:

   a number   



p


{\displaystyle p}

   is prime   if and only if   all the coefficients of the polynomial expansion of
 



(
x
−
1

)

p


−
(

x

p


−
1
)


{\displaystyle (x-1)^{p}-(x^{p}-1)}


are divisible by   



p


{\displaystyle p}

.



Example

Using   



p
=
3


{\displaystyle p=3}

:

         (x-1)^3 - (x^3 - 1)
            = (x^3 - 3x^2 + 3x - 1) - (x^3 - 1)
            = -3x^2 + 3x



And all the coefficients are divisible by 3,   so 3 is prime.





 Note:
This task is not the AKS primality test.   It is an inefficient exponential time algorithm discovered in the late 1600s and used as an introductory lemma in the AKS derivation.



Task



 Create a function/subroutine/method that given   



p


{\displaystyle p}

   generates the coefficients of the expanded polynomial representation of   



(
x
−
1

)

p




{\displaystyle (x-1)^{p}}

.
 Use the function to show here the polynomial expansions of   



(
x
−
1

)

p




{\displaystyle (x-1)^{p}}

   for   



p


{\displaystyle p}

   in the range   0   to at least   7,   inclusive.
 Use the previous function in creating another function that when given   



p


{\displaystyle p}

   returns whether   



p


{\displaystyle p}

   is prime using the theorem.
 Use your test to generate a list of all primes under   35.
 As a stretch goal,   generate all primes under   50   (needs integers larger than 31-bit).


References

 Agrawal-Kayal-Saxena (AKS) primality test (Wikipedia) 
 Fool-Proof Test for Primes - Numberphile (Video). The accuracy of this video is disputed -- at best it is an oversimplification.

",Go,"package main
 
import ""fmt""
 
func bc(p int) []int64 {
    c := make([]int64, p+1)
    r := int64(1)
    for i, half := 0, p/2; i <= half; i++ {
        c[i] = r
        c[p-i] = r
        r = r * int64(p-i) / int64(i+1)
    }
    for i := p - 1; i >= 0; i -= 2 {
        c[i] = -c[i]
    }
    return c
}
 
func main() {
    for p := 0; p <= 7; p++ {
        fmt.Printf(""%d:  %s\n"", p, pp(bc(p)))
    }
    for p := 2; p < 50; p++ {
        if aks(p) {
            fmt.Print(p, "" "")
        }
    }
    fmt.Println()
}
 
var e = []rune(""²³⁴⁵⁶⁷"")
 
func pp(c []int64) (s string) {
    if len(c) == 1 {
        return fmt.Sprint(c[0])
    }
    p := len(c) - 1
    if c[p] != 1 {
        s = fmt.Sprint(c[p])
    }
    for i := p; i > 0; i-- {
        s += ""x""
        if i != 1 {
            s += string(e[i-2])
        }
        if d := c[i-1]; d < 0 {
            s += fmt.Sprintf("" - %d"", -d)
        } else {
            s += fmt.Sprintf("" + %d"", d)
        }
    }
    return
}
 
func aks(p int) bool {
    c := bc(p)
    c[p]--
    c[0]++
    for _, d := range c {
        if d%int64(p) != 0 {
            return false
        }
    }
    return true
}",1158,65,"package main

import (
	""testing""
)

// TestBC tests the binomial coefficient generation function
func TestBC(t *testing.T) {
	tests := []struct {
		p        int
		expected []int64
	}{
		{0, []int64{1}},
		{1, []int64{-1, 1}},
		{2, []int64{1, -2, 1}},
		{3, []int64{-1, 3, -3, 1}},
		{4, []int64{1, -4, 6, -4, 1}},
		{5, []int64{-1, 5, -10, 10, -5, 1}},
		{6, []int64{1, -6, 15, -20, 15, -6, 1}},
		{7, []int64{-1, 7, -21, 35, -35, 21, -7, 1}},
	}

	for _, test := range tests {
		result := bc(test.p)
		for i, v := range result {
			if v != test.expected[i] {
				t.Errorf(""bc(%d) = %v; want %v"", test.p, result, test.expected)
			}
		}
	}
}

// TestAKS tests the AKS primality test function
func TestAKS(t *testing.T) {
	tests := []struct {
		p        int
		expected bool
	}{
		{2, true},
		{3, true},
		{4, false},
		{5, true},
		{6, false},
		{7, true},
		{8, false},
		{9, false},
		{10, false},
		{11, true},
		{12, false},
		{13, true},
		{14, false},
		{15, false},
		{16, false},
		{17, true},
		{18, false},
		{19, true},
		{20, false},
		{21, false},
		{22, false},
		{23, true},
		{24, false},
		{25, false},
		{26, false},
		{27, false},
		{28, false},
		{29, true},
		{30, false},
		{31, true},
		{32, false},
		{33, false},
		{34, false},
		{35, false},
		{36, false},
		{37, true},
		{38, false},
		{39, false},
		{40, false},
		{41, true},
		{42, false},
		{43, true},
		{44, false},
		{45, false},
		{46, false},
		{47, true},
		{48, false},
		{49, false},
	}

	for _, test := range tests {
		result := aks(test.p)
		if result != test.expected {
			t.Errorf(""aks(%d) = %v; want %v"", test.p, result, test.expected)
		}
	}
}

// TestPP tests the polynomial pretty-printing function
func TestPP(t *testing.T) {
	tests := []struct {
		coefficients []int64
		expected     string
	}{
		{[]int64{1}, ""1""},
		{[]int64{-1, 1}, ""-1x + 1""},
		{[]int64{1, -2, 1}, ""1x² - 2x + 1""},
		{[]int64{-1, 3, -3, 1}, ""-1x³ + 3x² - 3x + 1""},
		{[]int64{1, -4, 6, -4, 1}, ""1x⁴ - 4x³ + 6x² - 4x + 1""},
	}

	for _, test := range tests {
		result := pp(test.coefficients)
		if result != test.expected {
			t.Errorf(""pp(%v) = %s; want %s"", test.coefficients, result, test.expected)
		}
	}
}
",./data/generated/docs_golang/aks_test_for_primes/gpt_4o_2024_08_06_aks_test_for_primes_test.go,CompileStatus.OK,2.0,,,0.03,0.19,0.09,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: bc', 'Severity': '', 'SourceLines': ['\t\tresult := bc(test.p)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_aks_test_for_primes_test.go', 'Offset': 0, 'Line': 24, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: aks', 'Severity': '', 'SourceLines': ['\t\tresult := aks(test.p)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_aks_test_for_primes_test.go', 'Offset': 0, 'Line': 90, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: pp', 'Severity': '', 'SourceLines': ['\t\tresult := pp(test.coefficients)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_aks_test_for_primes_test.go', 'Offset': 0, 'Line': 111, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,66.67,False,[]
"Abbreviations, automatic","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an

easy way to add flexibility when specifying or using commands, sub─commands, options, etc.



It would make a list of words easier to maintain   (as words are added, changed, and/or deleted)   if
the minimum abbreviation length of that list could be automatically (programmatically) determined.



For this task, use the list (below) of the days-of-the-week names that are expressed in about a hundred languages   (note that there is a blank line in the list).

Sunday Monday Tuesday Wednesday Thursday Friday Saturday
Sondag Maandag Dinsdag Woensdag Donderdag Vrydag Saterdag
E_djelë E_hënë E_martë E_mërkurë E_enjte E_premte E_shtunë
Ehud Segno Maksegno Erob Hamus Arbe Kedame
Al_Ahad Al_Ithinin Al_Tholatha'a Al_Arbia'a Al_Kamis Al_Gomia'a Al_Sabit
Guiragui Yergou_shapti Yerek_shapti Tchorek_shapti Hink_shapti Ourpat Shapat
domingu llunes martes miércoles xueves vienres sábadu
Bazar_gÜnÜ Birinci_gÜn Çkinci_gÜn ÜçÜncÜ_gÜn DÖrdÜncÜ_gÜn Bes,inci_gÜn Altòncò_gÜn
Igande Astelehen Astearte Asteazken Ostegun Ostiral Larunbat
Robi_bar Shom_bar Mongal_bar Budhh_bar BRihashpati_bar Shukro_bar Shoni_bar
Nedjelja Ponedeljak Utorak Srijeda Cxetvrtak Petak Subota
Disul Dilun Dimeurzh Dimerc'her Diriaou Digwener Disadorn
nedelia ponedelnik vtornik sriada chetvartak petak sabota
sing_kei_yaht sing_kei_yat sing_kei_yee sing_kei_saam sing_kei_sie sing_kei_ng sing_kei_luk
Diumenge Dilluns Dimarts Dimecres Dijous Divendres Dissabte
Dzeenkk-eh Dzeehn_kk-ehreh Dzeehn_kk-ehreh_nah_kay_dzeeneh Tah_neesee_dzeehn_neh Deehn_ghee_dzee-neh Tl-oowey_tts-el_dehlee Dzeentt-ahzee
dy_Sul dy_Lun dy_Meurth dy_Mergher dy_You dy_Gwener dy_Sadorn
Dimanch Lendi Madi Mèkredi Jedi Vandredi Samdi
nedjelja ponedjeljak utorak srijeda cxetvrtak petak subota
nede^le ponde^lí úterÿ str^eda c^tvrtek pátek sobota
Sondee Mondee Tiisiday Walansedee TOOsedee Feraadee Satadee
s0ndag mandag tirsdag onsdag torsdag fredag l0rdag
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
Diman^co Lundo Mardo Merkredo ^Jaùdo Vendredo Sabato
pÜhapäev esmaspäev teisipäev kolmapäev neljapäev reede laupäev

Diu_prima Diu_sequima Diu_tritima Diu_quartima Diu_quintima Diu_sextima Diu_sabbata
sunnudagur mánadagur tÿsdaguy mikudagur hósdagur friggjadagur leygardagur
Yek_Sham'beh Do_Sham'beh Seh_Sham'beh Cha'har_Sham'beh Panj_Sham'beh Jom'eh Sham'beh
sunnuntai maanantai tiistai keskiviiko torsktai perjantai lauantai
dimanche lundi mardi mercredi jeudi vendredi samedi
Snein Moandei Tiisdei Woansdei Tonersdei Freed Sneon
Domingo Segunda_feira Martes Mércores Joves Venres Sábado
k'vira orshabati samshabati otkhshabati khutshabati p'arask'evi shabati
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag
Kiriaki' Defte'ra Tri'ti Teta'rti Pe'mpti Paraskebi' Sa'bato
ravivaar somvaar mangalvaar budhvaar guruvaar shukravaar shanivaar
pópule pó`akahi pó`alua pó`akolu pó`ahá pó`alima pó`aono
Yom_rishon Yom_sheni Yom_shlishi Yom_revi'i Yom_chamishi Yom_shishi Shabat
ravivara somavar mangalavar budhavara brahaspativar shukravara shanivar
vasárnap hétfö kedd szerda csütörtök péntek szombat
Sunnudagur Mánudagur ╞riδjudagur Miδvikudagar Fimmtudagur FÖstudagur Laugardagur
sundio lundio mardio merkurdio jovdio venerdio saturdio
Minggu Senin Selasa Rabu Kamis Jumat Sabtu
Dominica Lunedi Martedi Mercuridi Jovedi Venerdi Sabbato
Dé_Domhnaigh Dé_Luain Dé_Máirt Dé_Ceadaoin Dé_ardaoin Dé_hAoine Dé_Sathairn
domenica lunedí martedí mercoledí giovedí venerdí sabato
Nichiyou_bi Getzuyou_bi Kayou_bi Suiyou_bi Mokuyou_bi Kin'you_bi Doyou_bi
Il-yo-il Wol-yo-il Hwa-yo-il Su-yo-il Mok-yo-il Kum-yo-il To-yo-il
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
sve-tdien pirmdien otrdien tresvdien ceturtdien piektdien sestdien
Sekmadienis Pirmadienis Antradienis Trec^iadienis Ketvirtadienis Penktadienis S^es^tadienis
Wangu Kazooba Walumbe Mukasa Kiwanuka Nnagawonye Wamunyi
xing-_qi-_rì xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
Jedoonee Jelune Jemayrt Jecrean Jardaim Jeheiney Jesam
Jabot Manre Juje Wonje Taije Balaire Jarere
geminrongo minòmishi mártes mièrkoles misheushi bèrnashi mishábaro
Ahad Isnin Selasa Rabu Khamis Jumaat Sabtu
sφndag mandag tirsdag onsdag torsdag fredag lφrdag
lo_dimenge lo_diluns lo_dimarç lo_dimèrcres lo_dijòus lo_divendres lo_dissabte
djadomingo djaluna djamars djarason djaweps djabièrna djasabra
Niedziela Poniedzial/ek Wtorek S,roda Czwartek Pia,tek Sobota
Domingo segunda-feire terça-feire quarta-feire quinta-feire sexta-feira såbado
Domingo Lunes martes Miercoles Jueves Viernes Sabado
Duminicª Luni Mart'i Miercuri Joi Vineri Sâmbªtª
voskresenie ponedelnik vtornik sreda chetverg pyatnitsa subbota
Sunday Di-luain Di-màirt Di-ciadain Di-ardaoin Di-haoine Di-sathurne
nedjelja ponedjeljak utorak sreda cxetvrtak petak subota
Sontaha Mmantaha Labobedi Laboraro Labone Labohlano Moqebelo
Iridha- Sandhudha- Anga.haruwa-dha- Badha-dha- Brahaspa.thindha- Sikura-dha- Sena.sura-dha-
nedel^a pondelok utorok streda s^tvrtok piatok sobota
Nedelja Ponedeljek Torek Sreda Cxetrtek Petek Sobota
domingo lunes martes miércoles jueves viernes sábado
sonde mundey tude-wroko dride-wroko fode-wroko freyda Saturday
Jumapili Jumatatu Jumanne Jumatano Alhamisi Ijumaa Jumamosi
söndag måndag tisdag onsdag torsdag fredag lordag
Linggo Lunes Martes Miyerkoles Huwebes Biyernes Sabado
Lé-pài-jít Pài-it Pài-jï Pài-sañ Pài-sì Pài-gÖ. Pài-lák
wan-ar-tit wan-tjan wan-ang-kaan wan-phoet wan-pha-ru-hat-sa-boh-die wan-sook wan-sao
Tshipi Mosupologo Labobedi Laboraro Labone Labotlhano Matlhatso
Pazar Pazartesi Sali Çar,samba Per,sembe Cuma Cumartesi
nedilya ponedilok vivtorok sereda chetver pyatnytsya subota
Chu?_Nhâ.t Thú*_Hai Thú*_Ba Thú*_Tu* Thú*_Na'm Thú*_Sáu Thú*_Ba?y
dydd_Sul dyds_Llun dydd_Mawrth dyds_Mercher dydd_Iau dydd_Gwener dyds_Sadwrn
Dibeer Altine Talaata Allarba Al_xebes Aljuma Gaaw
iCawa uMvulo uLwesibini uLwesithathu uLuwesine uLwesihlanu uMgqibelo
zuntik montik dinstik mitvokh donershtik fraytik shabes
iSonto uMsombuluko uLwesibili uLwesithathu uLwesine uLwesihlanu uMgqibelo
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
Bazar_gÜnÜ Bazar_ærtæsi Çærs,ænbæ_axs,amò Çærs,ænbæ_gÜnÜ CÜmæ_axs,amò CÜmæ_gÜnÜ CÜmæ_Senbæ
Sun Moon Mars Mercury Jove Venus Saturn
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
KoseEraa GyoOraa BenEraa Kuoraa YOwaaraa FeEraa Memenaa
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Sonnabend
Domingo Luns Terza_feira Corta_feira Xoves Venres Sábado
Dies_Solis Dies_Lunae Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Sabbatum
xing-_qi-_tiàn xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
djadomingu djaluna djamars djarason djaweps djabièrnè djasabra
Killachau Atichau Quoyllurchau Illapachau Chaskachau Kuychichau Intichau

Caveat:   The list (above) most surely contains errors (or, at the least, differences) of what the actual (or true) names for the days-of-the-week.



To make this Rosetta Code task page as small as possible, if processing the complete list, read the days-of-the-week from a file (that is created from the above list).



Notes concerning the above list of words

   each line has a list of days-of-the-week for a language, separated by at least one blank
   the words on each line happen to be in order, from Sunday ──► Saturday
   most lines have words in mixed case and some have all manner of accented words and other characters
   some words were translated to the nearest character that was available to code page   437
   the characters in the words are not restricted except that they may not have imbedded blanks
   for this example, the use of an underscore (_) was used to indicate a blank in a word


Task

   The list of words   (days of the week)   needn't be verified/validated.
   Write a function to find the (numeric) minimum length abbreviation for each line that would make abbreviations unique.
   A blank line   (or a null line)   should return a null string.
   Process and show the output for at least the first five lines of the file.
   Show all output here.

Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Go,"package main
 
import(
    ""bufio""
    ""fmt""
    ""os""
    ""strings""
)
 
func distinctStrings(strs []string) []string {
    len := len(strs)
    set := make(map[string]bool, len)
    distinct := make([]string, 0, len)
    for _, str := range strs {
        if !set[str] {
            distinct = append(distinct, str)
            set[str] = true
        }
    }
    return distinct
}
 
func takeRunes(s string, n int) string {
    i := 0
    for j := range s {
        if i == n {
            return s[:j]
        }
        i++
    }
    return s
}
 
func main() {
    file, err := os.Open(""days_of_week.txt"")
    if err != nil {
        fmt.Println(""Unable to open file."")
        return
    }
    defer file.Close()
    reader := bufio.NewReader(file)
    lineCount := 0
    for {
        line, err := reader.ReadString('\n')
        if err != nil { // end of file reached
            return
        }
        line = strings.TrimSpace(line)
        lineCount++
        if line == """" {
            fmt.Println()
            continue
        }
        days := strings.Fields(line)
        daysLen := len(days)
        if (len(days) != 7) {
            fmt.Println(""There aren't 7 days in line"", lineCount)
            return
        }
        if len(distinctStrings(days)) != 7 { // implies some days have the same name
            fmt.Println("" ∞ "", line)
            continue
        }
        for abbrevLen := 1; ; abbrevLen++ {
            abbrevs := make([]string, daysLen)
            for i := 0; i < daysLen; i++ {
                abbrevs[i] = takeRunes(days[i], abbrevLen)
            }
            if len(distinctStrings(abbrevs)) == 7 {
                fmt.Printf(""%2d  %s\n"", abbrevLen, line)
                break
            }
        }
    }
}",1755,75,error,,,,,,,,,,,False,False,,False,
"Abbreviations, easy","This task is an easier (to code) variant of the Rosetta Code task:    Abbreviations, simple.



For this task, the following   command table   will be used:

   Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy
   COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find
   NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput
   Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO
   MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT
   READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT
   RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up



Notes concerning the above   command table:

   it can be thought of as one long literal string   (with blanks at end-of-lines)
   it may have superfluous blanks
   it may be in any case (lower/upper/mixed)
   the order of the words in the   command table   must be preserved as shown
   the user input(s) may be in any case (upper/lower/mixed)
   commands will be restricted to the Latin alphabet   (A ──► Z,   a ──► z)
   A valid abbreviation is a word that has:
   at least the minimum length of the number of capital letters of the word in the command table
   compares equal (regardless of case) to the leading characters of the word in the command table
   a length not longer than the word in the command table
   ALT,   aLt,   ALTE,   and   ALTER   are all abbreviations of   ALTer
   AL,   ALF,   ALTERS,   TER,   and   A   aren't valid abbreviations of   ALTer
   The number of capital letters in   ALTer   indicates that any abbreviation for   ALTer   must be at least three letters
   Any word longer than five characters can't be an abbreviation for   ALTer
   o,   ov,   oVe,   over,   overL,   overla   are all acceptable abbreviations for   Overlay
   if there isn't any lowercase letters in the word in the command table,   then there isn't an abbreviation permitted


Task

   The command table needn't be verified/validated.
   Write a function to validate if the user ""words""   (given as input)   are valid   (in the command table).
   If the word   is   valid,   then return the full uppercase version of that ""word"".
   If the word isn't valid,   then return the lowercase string:    *error*        (7 characters).
   A blank input   (or a null input)   should return a null string.
   Show all output here.


An example test case to be used for this task

For a user string of:

 riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin

the computer program should return the string:

 RIGHT REPEAT *error* PUT MOVE RESTORE *error* *error* *error* POWERINPUT


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
var table =
    ""Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy "" +
    ""COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find "" +
    ""NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput "" +
     ""Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO "" +
    ""MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT "" +
    ""READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT "" +
    ""RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up ""
 
func validate(commands, words []string, minLens []int) []string {
    results := make([]string, 0)
    if len(words) == 0 {
        return results
    }
    for _, word := range words {
        matchFound := false
        wlen := len(word)
        for i, command := range commands {
            if minLens[i] == 0 || wlen < minLens[i] || wlen > len(command) {
                continue
            }
            c := strings.ToUpper(command)
            w := strings.ToUpper(word)
            if strings.HasPrefix(c, w) {
                results = append(results, c)
                matchFound = true
                break
            }
        }
        if !matchFound {
            results = append(results, ""*error*"")
        }
    }
    return results
}
 
func main() {
    table = strings.TrimSpace(table)
    commands := strings.Fields(table)
    clen := len(commands)
    minLens := make([]int, clen)
    for i := 0; i < clen; i++ {
        count := 0
        for _, c := range commands[i] {
            if c >= 'A' && c <= 'Z' {
                count++
            }
        }
        minLens[i] = count
    }
    sentence :=  ""riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin""
    words := strings.Fields(sentence)
    results := validate(commands, words, minLens)
    fmt.Print(""user words:  "")
    for j := 0; j < len(words); j++ {
        fmt.Printf(""%-*s "", len(results[j]), words[j])
    }
    fmt.Print(""\nfull words:  "")
    fmt.Println(strings.Join(results, "" ""))
}",2176,67,error,,,,,,,,,,,False,False,,False,
"Abbreviations, simple","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an

easy way to add flexibility when specifying or using commands, sub─commands, options, etc.



For this task, the following   command table   will be used:

   add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3
   compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate
   3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2
   forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load
   locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2
   msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3
   refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left
   2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1



Notes concerning the above   command table:

   it can be thought of as one long literal string   (with blanks at end-of-lines)
   it may have superfluous blanks
   it may be in any case (lower/upper/mixed)
   the order of the words in the   command table   must be preserved as shown
   the user input(s) may be in any case (upper/lower/mixed)
   commands will be restricted to the Latin alphabet   (A ──► Z,   a ──► z)
   a command is followed by an optional number, which indicates the minimum abbreviation
   A valid abbreviation is a word that has:
   at least the minimum length of the word's minimum number in the command table
   compares equal (regardless of case) to the leading characters of the word in the command table
   a length not longer than the word in the command table
   ALT,   aLt,   ALTE,   and   ALTER   are all abbreviations of   ALTER 3
   AL,   ALF,   ALTERS,   TER,   and   A   aren't valid abbreviations of   ALTER 3
   The   3   indicates that any abbreviation for   ALTER   must be at least three characters
   Any word longer than five characters can't be an abbreviation for   ALTER
   o,   ov,   oVe,   over,   overL,   overla   are all acceptable abbreviations for   overlay 1
   if there isn't a number after the command,   then there isn't an abbreviation permitted


Task

   The command table needn't be verified/validated.
   Write a function to validate if the user ""words""   (given as input)   are valid   (in the command table).
   If the word   is   valid,   then return the full uppercase version of that ""word"".
   If the word isn't valid,   then return the lowercase string:    *error*        (7 characters).
   A blank input   (or a null input)   should return a null string.
   Show all output here.


An example test case to be used for this task

For a user string of:

 riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin

the computer program should return the string:

 RIGHT REPEAT *error* PUT MOVE RESTORE *error* *error* *error* POWERINPUT


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Go,"package main
 
import (
	""io""
	""os""
	""strconv""
	""strings""
	""text/tabwriter""
)
 
func readTable(table string) ([]string, []int) {
	fields := strings.Fields(table)
	var commands []string
	var minLens []int
 
	for i, max := 0, len(fields); i < max; {
		cmd := fields[i]
		cmdLen := len(cmd)
		i++
 
		if i < max {
			num, err := strconv.Atoi(fields[i])
			if err == nil && 1 <= num && num < cmdLen {
				cmdLen = num
				i++
			}
		}
 
		commands = append(commands, cmd)
		minLens = append(minLens, cmdLen)
	}
 
	return commands, minLens
}
 
func validateCommands(commands []string, minLens []int, words []string) []string {
	var results []string
	for _, word := range words {
		matchFound := false
		wlen := len(word)
		for i, command := range commands {
			if minLens[i] == 0 || wlen < minLens[i] || wlen > len(command) {
				continue
			}
			c := strings.ToUpper(command)
			w := strings.ToUpper(word)
			if strings.HasPrefix(c, w) {
				results = append(results, c)
				matchFound = true
				break
			}
		}
		if !matchFound {
			results = append(results, ""*error*"")
		}
	}
	return results
}
 
func printResults(words []string, results []string) {
	wr := tabwriter.NewWriter(os.Stdout, 0, 1, 1, ' ', 0)
	io.WriteString(wr, ""user words:"")
	for _, word := range words {
		io.WriteString(wr, ""\t""+word)
	}
	io.WriteString(wr, ""\n"")
	io.WriteString(wr, ""full words:\t""+strings.Join(results, ""\t"")+""\n"")
	wr.Flush()
}
 
func main() {
	const table = """" +
		""add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 "" +
		""compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate "" +
		""3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 "" +
		""forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load "" +
		""locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 "" +
		""msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 "" +
		""refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left "" +
		""2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 ""
 
	const sentence = ""riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin""
 
	commands, minLens := readTable(table)
	words := strings.Fields(sentence)
 
	results := validateCommands(commands, minLens, words)
 
	printResults(words, results)
}
 ",2443,91,none,,,,,,,,,,,False,False,,False,
Abundant odd numbers,"An Abundant number is a number n for which the   sum of divisors   σ(n) > 2n,

or,   equivalently,   the   sum of proper divisors   (or aliquot sum)       s(n) > n.



E.G.

12   is abundant, it has the proper divisors     1,2,3,4 & 6     which sum to   16   ( > 12 or n);

       or alternately,   has the sigma sum of   1,2,3,4,6 & 12   which sum to   28   ( > 24 or 2n).



Abundant numbers are common, though even abundant numbers seem to be much more common than odd abundant numbers.

To make things more interesting, this task is specifically about finding   odd abundant numbers.



Task
Find and display here: at least the first 25 abundant odd numbers and either their proper divisor sum or sigma sum.
Find and display here: the one thousandth abundant odd number and either its proper divisor sum or sigma sum.
Find and display here: the first abundant odd number greater than one billion (109) and either its proper divisor sum or sigma sum.


References

   OEIS:A005231: Odd abundant numbers (odd numbers n whose sum of divisors exceeds 2n)
   American Journal of Mathematics, Vol. 35, No. 4 (Oct., 1913), pp. 413-422 - Finiteness of the Odd Perfect and Primitive Abundant Numbers with n Distinct Prime Factors (LE Dickson)

",Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
func divisors(n int) []int {
    divs := []int{1}
    divs2 := []int{}
    for i := 2; i*i <= n; i++ {
        if n%i == 0 {
            j := n / i
            divs = append(divs, i)
            if i != j {
                divs2 = append(divs2, j)
            }
        }
    }
    for i := len(divs2) - 1; i >= 0; i-- {
        divs = append(divs, divs2[i])
    }
    return divs
}
 
func sum(divs []int) int {
    tot := 0
    for _, div := range divs {
        tot += div
    }
    return tot
}
 
func sumStr(divs []int) string {
    s := """"
    for _, div := range divs {
        s += strconv.Itoa(div) + "" + ""
    }
    return s[0 : len(s)-3]
}
 
func abundantOdd(searchFrom, countFrom, countTo int, printOne bool) int {
    count := countFrom
    n := searchFrom
    for ; count < countTo; n += 2 {
        divs := divisors(n)
        if tot := sum(divs); tot > n {
            count++
            if printOne && count < countTo {
                continue
            } 
            s := sumStr(divs)
            if !printOne {
                fmt.Printf(""%2d. %5d < %s = %d\n"", count, n, s, tot)
            } else {
                fmt.Printf(""%d < %s = %d\n"", n, s, tot)
            }
        }
    }
    return n
}
 
func main() {
    const max = 25
    fmt.Println(""The first"", max, ""abundant odd numbers are:"")
    n := abundantOdd(1, 0, 25, false)
 
    fmt.Println(""\nThe one thousandth abundant odd number is:"")
    abundantOdd(n, 25, 1000, true)
 
    fmt.Println(""\nThe first abundant odd number above one billion is:"")
    abundantOdd(1e9+1, 0, 1, true)
}",1625,73,"package main

import (
    ""testing""
)

func TestDivisors(t *testing.T) {
    tests := []struct {
        input    int
        expected []int
    }{
        {12, []int{1, 2, 3, 4, 6}},
        {15, []int{1, 3, 5}},
        {28, []int{1, 2, 4, 7, 14}},
        {1, []int{1}},
    }

    for _, test := range tests {
        result := divisors(test.input)
        if !equalSlices(result, test.expected) {
            t.Errorf(""divisors(%d) = %v; want %v"", test.input, result, test.expected)
        }
    }
}

func TestSum(t *testing.T) {
    tests := []struct {
        input    []int
        expected int
    }{
        {[]int{1, 2, 3, 4, 6}, 16},
        {[]int{1, 3, 5}, 9},
        {[]int{1, 2, 4, 7, 14}, 28},
        {[]int{1}, 1},
    }

    for _, test := range tests {
        result := sum(test.input)
        if result != test.expected {
            t.Errorf(""sum(%v) = %d; want %d"", test.input, result, test.expected)
        }
    }
}

func TestAbundantOdd(t *testing.T) {
    tests := []struct {
        searchFrom int
        countFrom  int
        countTo    int
        printOne   bool
        expected   int
    }{
        {1, 0, 25, false, 945}, // The 25th abundant odd number
        {945, 25, 1000, true, 33550335}, // The 1000th abundant odd number
        {1e9 + 1, 0, 1, true, 1122756}, // The first abundant odd number above one billion
    }

    for _, test := range tests {
        result := abundantOdd(test.searchFrom, test.countFrom, test.countTo, test.printOne)
        if result != test.expected {
            t.Errorf(""abundantOdd(%d, %d, %d, %v) = %d; want %d"", test.searchFrom, test.countFrom, test.countTo, test.printOne, result, test.expected)
        }
    }
}

func equalSlices(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}
",./data/generated/docs_golang/abundant_odd_numbers/gpt_4o_2024_08_06_abundant_odd_numbers_test.go,CompileStatus.OK,0.0,82.1,,0.06,0.19,2.121,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: divisors', 'Severity': '', 'SourceLines': ['        result := divisors(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_abundant_odd_numbers_test.go', 'Offset': 0, 'Line': 19, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: sum', 'Severity': '', 'SourceLines': ['        result := sum(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_abundant_odd_numbers_test.go', 'Offset': 0, 'Line': 38, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: abundantOdd', 'Severity': '', 'SourceLines': ['        result := abundantOdd(test.searchFrom, test.countFrom, test.countTo, test.printOne)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_abundant_odd_numbers_test.go', 'Offset': 0, 'Line': 59, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,66.67,False,[]
Active object,"In object-oriented programming an object is active when its state depends on clock. Usually an active object encapsulates a task that updates the object's state. To the outer world the object looks like a normal object with methods that can be called from outside. Implementation of such methods must have a certain synchronization mechanism with the encapsulated task in order to prevent object's state corruption.

A typical instance of an active object is an animation widget. The widget state changes with the time, while as an object it has all properties of a normal widget.

The task

Implement an active integrator object. The object has an input and output. The input can be set using the method Input. The input is a function of time. The output can be queried using the method Output. The object integrates its input over the time and the result becomes the object's output. So if the input is K(t) and the output is S, the object state S is changed to S + (K(t1) + K(t0)) * (t1 - t0) / 2, i.e. it integrates K using the trapeze method. Initially K is constant 0 and S is 0.

In order to test the object:

 set its input to sin (2π f t), where the frequency f=0.5Hz. The phase is irrelevant.
 wait 2s
 set the input to constant 0
 wait 0.5s
Verify that now the object's output is approximately 0 (the sine has the period of 2s). The accuracy of the result will depend on the OS scheduler time slicing and the accuracy of the clock.
",Go,"package main
 
import (
    ""fmt""
    ""math""
    ""time""
)
 
// type for input function, k.
// input is duration since an arbitrary start time t0.
type tFunc func(time.Duration) float64
 
// active integrator object.  state variables are not here, but in
// function aif, started as a goroutine in the constructor.
type aio struct {
    iCh chan tFunc        // channel for setting input function
    oCh chan chan float64 // channel for requesting output
}
 
// constructor
func newAio() *aio {
    var a aio
    a.iCh = make(chan tFunc)
    a.oCh = make(chan chan float64)
    go aif(&a)
    return &a
}
 
// input method required by task description.  in practice, this method is
// unnecessary; you would just put that single channel send statement in
// your code wherever you wanted to set the input function.
func (a aio) input(f tFunc) {
    a.iCh <- f
}
 
// output method required by task description.  in practice, this method too
// would not likely be best.  instead any client interested in the value would
// likely make a return channel sCh once, and then reuse it as needed.
func (a aio) output() float64 {
    sCh := make(chan float64)
    a.oCh <- sCh
    return <-sCh
}
 
// integration function that returns constant 0
func zeroFunc(time.Duration) float64 { return 0 }
 
// goroutine serializes access to integrated function k and state variable s
func aif(a *aio) {
    var k tFunc = zeroFunc // integration function
    s := 0.                // ""object state"" initialized to 0
    t0 := time.Now()       // initial time
    k0 := k(0)             // initial sample value
    t1 := t0               // t1, k1 used for trapezoid formula
    k1 := k0
 
    tk := time.Tick(10 * time.Millisecond) // 10 ms -> 100 Hz
    for {
        select {
        case t2 := <-tk: // timer tick event
            k2 := k(t2.Sub(t0))                        // new sample value
            s += (k1 + k2) * .5 * t2.Sub(t1).Seconds() // trapezoid formula
            t1, k1 = t2, k2                            // save time and value
        case k = <-a.iCh: // input method event: function change
        case sCh := <-a.oCh: // output method event: sample object state
            sCh <- s
        }
    }
}
 
func main() {
    a := newAio()                           // create object
    a.input(func(t time.Duration) float64 { // 1. set input to sin function
        return math.Sin(t.Seconds() * math.Pi)
    })
    time.Sleep(2 * time.Second) // 2. sleep 2 sec
    a.input(zeroFunc)           // 3. set input to zero function
    time.Sleep(time.Second / 2) // 4. sleep .5 sec
    fmt.Println(a.output())     // output should be near zero
}",2649,80,"package main

import (
    ""math""
    ""testing""
    ""time""
)

func TestActiveIntegratorObject(t *testing.T) {
    a := newAio() // Create the active integrator object

    // Set input to sin(2πft) where f = 0.5Hz
    a.input(func(t time.Duration) float64 {
        return math.Sin(t.Seconds() * math.Pi)
    })

    // Wait for 2 seconds
    time.Sleep(2 * time.Second)

    // Set input to constant 0
    a.input(zeroFunc)

    // Wait for 0.5 seconds
    time.Sleep(500 * time.Millisecond)

    // Get the output
    output := a.output()

    // Verify that the output is approximately 0
    if math.Abs(output) > 0.01 { // Allow a small margin of error
        t.Errorf(""Expected output to be approximately 0, but got %f"", output)
    }
}
",./data/generated/docs_golang/active_object/gpt_4o_2024_08_06_active_object_test.go,CompileStatus.OK,0.0,76.7,,0.08,0.09,2.614,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: newAio', 'Severity': '', 'SourceLines': ['    a := newAio() // Create the active integrator object'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_active_object_test.go', 'Offset': 0, 'Line': 10, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: zeroFunc', 'Severity': '', 'SourceLines': ['    a.input(zeroFunc)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_active_object_test.go', 'Offset': 0, 'Line': 21, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Additive primes,"Definitions
In mathematics, additive primes are prime numbers for which the sum of their decimal digits are also primes.



Task
Write a program to determine (and show here) all additive primes less than 500.

Optionally, show the number of additive primes.



Also see

   the OEIS entry:   A046704 additive primes.
   the prime-numbers entry:   additive primes.
   the geeks for geeks entry: additive prime number.
   the prime-numbers fandom: additive primes.

",Go,"package main
 
import ""fmt""
 
func isPrime(n int) bool {
    switch {
    case n < 2:
        return false
    case n%2 == 0:
        return n == 2
    case n%3 == 0:
        return n == 3
    default:
        d := 5
        for d*d <= n {
            if n%d == 0 {
                return false
            }
            d += 2
            if n%d == 0 {
                return false
            }
            d += 4
        }
        return true
    }
}
 
func sumDigits(n int) int {
    sum := 0
    for n > 0 {
        sum += n % 10
        n /= 10
    }
    return sum
}
 
func main() {
    fmt.Println(""Additive primes less than 500:"")
    i := 2
    count := 0
    for {
        if isPrime(i) && isPrime(sumDigits(i)) {
            count++
            fmt.Printf(""%3d  "", i)
            if count%10 == 0 {
                fmt.Println()
            }
        }
        if i > 2 {
            i += 2
        } else {
            i++
        }
        if i > 499 {
            break
        }
    }
    fmt.Printf(""\n\n%d additive primes found.\n"", count)
}",1059,60,"package main

import (
	""testing""
)

// TestIsPrime tests the isPrime function.
func TestIsPrime(t *testing.T) {
	tests := []struct {
		input    int
		expected bool
	}{
		{1, false},
		{2, true},
		{3, true},
		{4, false},
		{5, true},
		{9, false},
		{11, true},
		{13, true},
		{17, true},
		{19, true},
		{20, false},
		{23, true},
		{29, true},
		{31, true},
		{37, true},
		{41, true},
		{43, true},
		{47, true},
		{53, true},
		{59, true},
		{61, true},
		{67, true},
		{71, true},
		{73, true},
		{79, true},
		{83, true},
		{89, true},
		{97, true},
		{101, true},
		{103, true},
		{107, true},
		{109, true},
		{113, true},
		{127, true},
		{131, true},
		{137, true},
		{139, true},
		{149, true},
		{151, true},
		{157, true},
		{163, true},
		{167, true},
		{173, true},
		{179, true},
		{181, true},
		{191, true},
		{193, true},
		{197, true},
		{199, true},
		{211, true},
		{223, true},
		{227, true},
		{229, true},
		{233, true},
		{239, true},
		{241, true},
		{251, true},
		{257, true},
		{263, true},
		{269, true},
		{271, true},
		{277, true},
		{281, true},
		{283, true},
		{293, true},
		{307, true},
		{311, true},
		{313, true},
		{317, true},
		{331, true},
		{337, true},
		{347, true},
		{349, true},
		{353, true},
		{359, true},
		{367, true},
		{373, true},
		{379, true},
		{383, true},
		{389, true},
		{397, true},
		{401, true},
		{409, true},
		{419, true},
		{421, true},
		{431, true},
		{433, true},
		{439, true},
		{443, true},
		{449, true},
		{457, true},
		{461, true},
		{463, true},
		{467, true},
		{479, true},
		{487, true},
		{491, true},
		{499, true},
	}

	for _, test := range tests {
		result := isPrime(test.input)
		if result != test.expected {
			t.Errorf(""isPrime(%d) = %v; expected %v"", test.input, result, test.expected)
		}
	}
}

// TestSumDigits tests the sumDigits function.
func TestSumDigits(t *testing.T) {
	tests := []struct {
		input    int
		expected int
	}{
		{0, 0},
		{1, 1},
		{12, 3},
		{123, 6},
		{456, 15},
		{789, 24},
		{999, 27},
		{1001, 2},
		{1234, 10},
		{5678, 26},
	}

	for _, test := range tests {
		result := sumDigits(test.input)
		if result != test.expected {
			t.Errorf(""sumDigits(%d) = %d; expected %d"", test.input, result, test.expected)
		}
	}
}

// TestAdditivePrimes tests the main function for finding additive primes less than 500.
func TestAdditivePrimes(t *testing.T) {
	expectedAdditivePrimes := []int{2, 3, 5, 7, 11, 17, 23, 29, 31, 37, 41, 43, 47, 53, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499}
	var actualAdditivePrimes []int

	for i := 2; i < 500; i++ {
		if isPrime(i) && isPrime(sumDigits(i)) {
			actualAdditivePrimes = append(actualAdditivePrimes, i)
		}
	}

	if len(actualAdditivePrimes) != len(expectedAdditivePrimes) {
		t.Errorf(""Expected %d additive primes, but got %d"", len(expectedAdditivePrimes), len(actualAdditivePrimes))
	}

	for i, prime := range expectedAdditivePrimes {
		if actualAdditivePrimes[i] != prime {
			t.Errorf(""Expected additive prime %d at index %d, but got %d"", prime, i, actualAdditivePrimes[i])
		}
	}
}
",./data/generated/docs_golang/additive_primes/gpt_4o_2024_08_06_additive_primes_test.go,CompileStatus.OK,2.0,,,0.03,0.25,0.091,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: isPrime', 'Severity': '', 'SourceLines': ['\t\tresult := isPrime(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_additive_primes_test.go', 'Offset': 0, 'Line': 114, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: sumDigits', 'Severity': '', 'SourceLines': ['\t\tresult := sumDigits(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_additive_primes_test.go', 'Offset': 0, 'Line': 140, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: isPrime', 'Severity': '', 'SourceLines': ['\t\tif isPrime(i) && isPrime(sumDigits(i)) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_additive_primes_test.go', 'Offset': 0, 'Line': 153, 'Column': 6}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,66.67,False,[]
Almost prime,"A   k-Almost-prime   is a natural number   



n


{\displaystyle n}

   that is the product of   



k


{\displaystyle k}

   (possibly identical) primes.



Example

1-almost-primes,   where   



k
=
1


{\displaystyle k=1}

,   are the prime numbers themselves.

2-almost-primes,   where   



k
=
2


{\displaystyle k=2}

,   are the   semiprimes.



Task

Write a function/method/subroutine/... that generates k-almost primes and use it to create a table here of the first ten members of k-Almost primes for   



1
<=
K
<=
5


{\displaystyle 1<=K<=5}

.



Related tasks

   Semiprime
   Category:Prime Numbers

",Go,"package main
 
import ""fmt""
 
func kPrime(n, k int) bool {
    nf := 0
    for i := 2; i <= n; i++ {
        for n%i == 0 {
            if nf == k {
                return false
            }
            nf++
            n /= i
        }
    }
    return nf == k
}
 
func gen(k, n int) []int {
    r := make([]int, n)
    n = 2
    for i := range r {
        for !kPrime(n, k) {
            n++
        }
        r[i] = n
        n++
    }
    return r
}
 
func main() {
    for k := 1; k <= 5; k++ {
        fmt.Println(k, gen(k, 10))
    }
}",543,36,"package main

import (
	""testing""
)

// TestKPrime tests the kPrime function for various cases
func TestKPrime(t *testing.T) {
	tests := []struct {
		n, k     int
		expected bool
	}{
		{2, 1, true},  // 2 is a prime number
		{4, 2, true},  // 4 = 2 * 2, a semiprime
		{6, 2, true},  // 6 = 2 * 3, a semiprime
		{8, 3, true},  // 8 = 2 * 2 * 2, 3-almost-prime
		{30, 3, true}, // 30 = 2 * 3 * 5, 3-almost-prime
		{16, 4, true}, // 16 = 2 * 2 * 2 * 2, 4-almost-prime
		{18, 2, false}, // 18 = 2 * 3 * 3, not a 2-almost-prime
		{18, 3, true},  // 18 = 2 * 3 * 3, 3-almost-prime
	}

	for _, test := range tests {
		result := kPrime(test.n, test.k)
		if result != test.expected {
			t.Errorf(""kPrime(%d, %d) = %v; expected %v"", test.n, test.k, result, test.expected)
		}
	}
}

// TestGen tests the gen function for generating k-almost primes
func TestGen(t *testing.T) {
	tests := []struct {
		k, n     int
		expected []int
	}{
		{1, 10, []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}}, // First 10 primes
		{2, 10, []int{4, 6, 9, 10, 14, 15, 21, 22, 25, 26}}, // First 10 semiprimes
		{3, 10, []int{8, 12, 18, 20, 27, 28, 30, 32, 42, 44}}, // First 10 3-almost-primes
		{4, 10, []int{16, 24, 36, 40, 54, 56, 60, 64, 72, 80}}, // First 10 4-almost-primes
		{5, 10, []int{32, 48, 72, 80, 108, 112, 120, 128, 144, 160}}, // First 10 5-almost-primes
	}

	for _, test := range tests {
		result := gen(test.k, test.n)
		for i, v := range result {
			if v != test.expected[i] {
				t.Errorf(""gen(%d, %d)[%d] = %d; expected %d"", test.k, test.n, i, v, test.expected[i])
			}
		}
	}
}
",./data/generated/docs_golang/almost_prime/gpt_4o_2024_08_06_almost_prime_test.go,CompileStatus.OK,0.0,88.9,,0.06,0.22,0.114,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: kPrime', 'Severity': '', 'SourceLines': ['\t\tresult := kPrime(test.n, test.k)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_almost_prime_test.go', 'Offset': 0, 'Line': 24, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: gen', 'Severity': '', 'SourceLines': ['\t\tresult := gen(test.k, test.n)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_almost_prime_test.go', 'Offset': 0, 'Line': 45, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,50.0,False,[]
Amicable pairs,"Two integers 



N


{\displaystyle N}

 and 



M


{\displaystyle M}

 are said to be amicable pairs if 



N
≠
M


{\displaystyle N\neq M}

 and the sum of the proper divisors of 



N


{\displaystyle N}

 (




s
u
m

(

p
r
o
p
D
i
v
s

(
N
)
)


{\displaystyle \mathrm {sum} (\mathrm {propDivs} (N))}

) 



=
M


{\displaystyle =M}

 as well as 




s
u
m

(

p
r
o
p
D
i
v
s

(
M
)
)
=
N


{\displaystyle \mathrm {sum} (\mathrm {propDivs} (M))=N}

.



Example

1184 and 1210 are an amicable pair, with proper divisors:

   1, 2, 4, 8, 16, 32, 37, 74, 148, 296, 592   and 
   1, 2, 5, 10, 11, 22, 55, 110, 121, 242, 605   respectively.


Task

Calculate and show here the Amicable pairs below 20,000; (there are eight).



Related tasks
 Proper divisors
 Abundant, deficient and perfect number classifications
 Aliquot sequence classifications and its amicable classification. 

",Go,"package main
 
import ""fmt""
 
func pfacSum(i int) int {
    sum := 0
    for p := 1; p <= i/2; p++ {
        if i%p == 0 {
            sum += p
        }
    }
    return sum
}
 
func main() {
    var a[20000]int
    for i := 1; i < 20000; i++ {
        a[i] = pfacSum(i)
    }
    fmt.Println(""The amicable pairs below 20,000 are:"")
    for n := 2; n < 19999; n++ {
        m := a[n]
        if m > n && m < 20000 && n == a[m] {
            fmt.Printf(""  %5d and %5d\n"", n, m)
        } 
    }
}",496,27,"package main

import (
	""testing""
)

// Test function for pfacSum
func TestPfacSum(t *testing.T) {
	tests := []struct {
		input    int
		expected int
	}{
		{1, 0},    // Proper divisors of 1 are none
		{6, 6},    // Proper divisors of 6 are 1, 2, 3
		{28, 28},  // Proper divisors of 28 are 1, 2, 4, 7, 14
		{12, 16},  // Proper divisors of 12 are 1, 2, 3, 4, 6
		{15, 9},   // Proper divisors of 15 are 1, 3, 5
		{220, 284}, // Proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55, 110
		{284, 220}, // Proper divisors of 284 are 1, 2, 4, 71, 142
	}

	for _, test := range tests {
		result := pfacSum(test.input)
		if result != test.expected {
			t.Errorf(""pfacSum(%d) = %d; expected %d"", test.input, result, test.expected)
		}
	}
}

// Test function for finding amicable pairs
func TestAmicablePairs(t *testing.T) {
	expectedPairs := [][2]int{
		{220, 284},
		{1184, 1210},
		{2620, 2924},
		{5020, 5564},
		{6232, 6368},
		{10744, 10856},
		{12285, 14595},
		{17296, 18416},
	}

	var a [20000]int
	for i := 1; i < 20000; i++ {
		a[i] = pfacSum(i)
	}

	var foundPairs [][2]int
	for n := 2; n < 19999; n++ {
		m := a[n]
		if m > n && m < 20000 && n == a[m] {
			foundPairs = append(foundPairs, [2]int{n, m})
		}
	}

	if len(foundPairs) != len(expectedPairs) {
		t.Fatalf(""Expected %d amicable pairs, but found %d"", len(expectedPairs), len(foundPairs))
	}

	for i, pair := range foundPairs {
		if pair != expectedPairs[i] {
			t.Errorf(""Expected pair %v, but found %v"", expectedPairs[i], pair)
		}
	}
}
",./data/generated/docs_golang/amicable_pairs/gpt_4o_2024_08_06_amicable_pairs_test.go,CompileStatus.OK,0.0,38.5,,0.07,0.33,0.886,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: pfacSum', 'Severity': '', 'SourceLines': ['\t\tresult := pfacSum(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_amicable_pairs_test.go', 'Offset': 0, 'Line': 23, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: pfacSum', 'Severity': '', 'SourceLines': ['\t\ta[i] = pfacSum(i)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_amicable_pairs_test.go', 'Offset': 0, 'Line': 45, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Anagrams/Deranged anagrams,"Two or more words are said to be anagrams if they have the same characters, but in a different order.

By analogy with derangements we define a deranged anagram as two words with the same characters, but in which the same character does not appear in the same position in both words.

Task[edit]
Use the word list at unixdict to find and display the longest deranged anagram.



Related tasks
 Permutations/Derangements
 Best shuffle
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Go,"package main
import (
	""fmt""
	""io/ioutil""
	""strings""
	""sort""
)
 
func deranged(a, b string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range(a) {
		if a[i] == b[i] { return false }
	}
	return true
}
 
func main() {
	/* read the whole thing in. how big can it be? */
	buf, _ := ioutil.ReadFile(""unixdict.txt"")
	words := strings.Split(string(buf), ""\n"")
 
	m := make(map[string] []string)
	best_len, w1, w2 := 0, """", """"
 
	for _, w := range(words) {
		// don't bother: too short to beat current record
		if len(w) <= best_len { continue }
 
		// save strings in map, with sorted string as key
		letters := strings.Split(w, """")
		sort.Strings(letters)
		k := strings.Join(letters, """")
 
		if _, ok := m[k]; !ok {
			m[k] = []string { w }
			continue
		}
 
		for _, c := range(m[k]) {
			if deranged(w, c) {
				best_len, w1, w2 = len(w), c, w
				break
			}
		}
 
		m[k] = append(m[k], w)
	}
 
	fmt.Println(w1, w2, "": Length"", best_len)
}",950,52,error,,,,,,,,,,,False,False,,False,
Angle difference between two bearings,"Finding the angle between two bearings is often confusing.[1]



Task

Find the angle which is the result of the subtraction b2 - b1, where b1 and b2 are the bearings.


Input bearings are expressed in the range   -180   to   +180   degrees.

The  result  is also expressed in the range   -180   to   +180   degrees.



Compute the angle for the following pairs:

 20 degrees (b1) and 45 degrees (b2)
 -45 and 45
 -85 and 90
 -95 and 90
 -45 and 125
 -45 and 145
 29.4803 and -88.6381
 -78.3251 and -159.036


Optional extra
 
Allow the input bearings to be any (finite) value.



Test cases

 -70099.74233810938 and 29840.67437876723
 -165313.6666297357 and 33693.9894517456
 1174.8380510598456 and -154146.66490124757
 60175.77306795546 and 42213.07192354373

",Go,"package main
 
import ""fmt""
 
type bearing float64
 
var testCases = []struct{ b1, b2 bearing }{
    {20, 45},
    {-45, 45},
    {-85, 90},
    {-95, 90},
    {-45, 125},
    {-45, 145},
    {29.4803, -88.6381},
    {-78.3251, -159.036},
}
 
func main() {
    for _, tc := range testCases {
        fmt.Println(tc.b2.Sub(tc.b1))
    }
}
 
func (b2 bearing) Sub(b1 bearing) bearing {
    switch d := b2 - b1; {
    case d < -180:
        return d + 360
    case d > 180:
        return d - 360
    default:
        return d
    }
}",531,33,"package main

import (
	""testing""
)

type bearing float64

func (b2 bearing) Sub(b1 bearing) bearing {
	switch d := b2 - b1; {
	case d < -180:
		return d + 360
	case d > 180:
		return d - 360
	default:
		return d
	}
}

func TestAngleDifferenceBetweenTwoBearings(t *testing.T) {
	testCases := []struct {
		b1, b2 bearing
		want   bearing
	}{
		{20, 45, 25},
		{-45, 45, 90},
		{-85, 90, 175},
		{-95, 90, 185 - 360}, // -175
		{-45, 125, 170},
		{-45, 145, 190 - 360}, // -170
		{29.4803, -88.6381, -118.1184},
		{-78.3251, -159.036, -80.7109},
		// Optional extra test cases
		{-70099.74233810938, 29840.67437876723, 139.58304065761},
		{-165313.6666297357, 33693.9894517456, 19.6560814813},
		{1174.8380510598456, -154146.66490124757, -151.50295230772},
		{60175.77306795546, 42213.07192354373, -179.29814441173},
	}

	for _, tc := range testCases {
		t.Run("""", func(t *testing.T) {
			got := tc.b2.Sub(tc.b1)
			if got != tc.want {
				t.Errorf(""Sub(%v, %v) = %v; want %v"", tc.b2, tc.b1, got, tc.want)
			}
		})
	}
}
",./data/generated/docs_golang/angle_difference_between_two_bearings/gpt_4o_2024_08_06_angle_difference_between_two_bearings_test.go,CompileStatus.SYNTAX_ERROR,,,,0.03,0.2,,0.0,[],False,False,,False,"[{'file': './gpt_4o_2024_08_06_angle_difference_between_two_bearings_test.go', 'line': 7, 'column': 6, 'message': 'bearing redeclared in this block'}]"
"Angles (geometric), normalization and conversion","This task is about the normalization and/or conversion of (geometric) angles using
some common scales.



The angular scales that will be used in this task are:

   degree
   gradian
   mil
   radian


Definitions

The angular scales used or referenced here:

   turn   is a full turn or 360 degrees, also shown as 360º
   degree   is   1/360   of a turn
   gradian   is   1/400   of a turn
   mil   is   1/6400   of a turn
   radian   is   1/2



π


{\displaystyle \pi }

   of a turn   (or   0.5/



π


{\displaystyle \pi }

   of a turn)


Or, to put it another way,   for a full circle:

   there are   360   degrees
   there are   400   gradians
   there are   6,400   mils
   there are   2



π


{\displaystyle \pi }

   radians   (roughly equal to 6.283+)


A   mil   is approximately equal to a   milliradian   (which is   1/1000   of a radian).

There is another definition of a   mil   which
is   1/1000   of a radian   ─── this
definition won't be used in this Rosetta Code task.


Turns   are sometimes known or shown as:

   turn(s)
   360 degrees
   unit circle
   a (full) circle

Degrees   are sometimes known or shown as:

   degree(s)
   deg
   º       (a symbol)
   °       (another symbol)

Gradians   are sometimes known or shown as:

   gradian(s)
   grad(s)
   grade(s)
   gon(s)
   metric degree(s)
   (Note that   centigrade   was used for 1/100th of a grade, see the note below.)

Mils   are sometimes known or shown as:

   mil(s)
   NATO mil(s)

Radians   are sometimes known or shown as:

   radian(s)
   rad(s)


Notes

In continental Europe, the French term   centigrade   was used
for   1/100   of a grad (grade);   this was
one reason for the adoption of the term   Celsius   to
replace   centigrade   as the name of a temperature scale.

Gradians were commonly used in civil engineering.

Mils were normally used for artillery   (elevations of the gun barrel for ranging).



Positive and negative angles

Although the definition of the measurement of an angle doesn't support the
concept of a negative angle,   it's frequently useful to impose a convention that
allows positive and negative angular values to represent orientations and/or rotations
in opposite directions relative to some reference.   It is this reason that
negative angles will keep their sign and not be normalized to positive angles.



Normalization

Normalization   (for this Rosetta Code task)   will keep the same
sign,   but it will reduce the magnitude to less than a full circle;   in
other words, less than 360º.

Normalization   shouldn't   change   -45º   to   315º,

An angle of   0º,   +0º,   0.000000,   or   -0º   should be
shown as   0º.



Task

   write a function (or equivalent) to do the normalization for each scale
 Suggested names:
 d2d,   g2g,   m2m,   and  r2r
   write a function (or equivalent) to convert one scale to another
 Suggested names for comparison of different computer language function names:
 d2g,   d2m,   and   d2r   for degrees
 g2d,   g2m,   and   g2r   for gradians
 m2d,   m2g,   and   m2r   for mils
 r2d,   r2g,   and   r2m   for radians
   normalize all angles used   (except for the ""original"" or ""base"" angle)
   show the angles in every scale and convert them to all other scales
   show all output here on this page


For the (above) conversions,   use these dozen numbers   (in the order shown):

   -2   -1   0   1   2   6.2831853   16   57.2957795   359   399   6399   1000000

",Go,"package main
 
import (
    ""fmt""
    ""math""
    ""strconv""
    ""strings""
)
 
func d2d(d float64) float64 { return math.Mod(d, 360) }
 
func g2g(g float64) float64 { return math.Mod(g, 400) }
 
func m2m(m float64) float64 { return math.Mod(m, 6400) }
 
func r2r(r float64) float64 { return math.Mod(r, 2*math.Pi) }
 
func d2g(d float64) float64 { return d2d(d) * 400 / 360 }
 
func d2m(d float64) float64 { return d2d(d) * 6400 / 360 }
 
func d2r(d float64) float64 { return d2d(d) * math.Pi / 180 }
 
func g2d(g float64) float64 { return g2g(g) * 360 / 400 }
 
func g2m(g float64) float64 { return g2g(g) * 6400 / 400 }
 
func g2r(g float64) float64 { return g2g(g) * math.Pi / 200 }
 
func m2d(m float64) float64 { return m2m(m) * 360 / 6400 }
 
func m2g(m float64) float64 { return m2m(m) * 400 / 6400 }
 
func m2r(m float64) float64 { return m2m(m) * math.Pi / 3200 }
 
func r2d(r float64) float64 { return r2r(r) * 180 / math.Pi }
 
func r2g(r float64) float64 { return r2r(r) * 200 / math.Pi }
 
func r2m(r float64) float64 { return r2r(r) * 3200 / math.Pi }
 
// Aligns number to decimal point assuming 7 characters before and after.
func s(f float64) string {
    wf := strings.Split(strconv.FormatFloat(f, 'g', 15, 64), ""."")
    if len(wf) == 1 {
        return fmt.Sprintf(""%7s        "", wf[0])
    }
    le := len(wf[1])
    if le > 7 {
        le = 7
    }
    return fmt.Sprintf(""%7s.%-7s"", wf[0], wf[1][:le])
}
 
func main() {
    angles := []float64{-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795,
        359, 399, 6399, 1000000}
    ft := ""%s %s %s %s %s\n""
    fmt.Printf(ft, ""    degrees    "", ""normalized degs"", ""    gradians   "", ""     mils      "", ""     radians"")
    for _, a := range angles {
        fmt.Printf(ft, s(a), s(d2d(a)), s(d2g(a)), s(d2m(a)), s(d2r(a)))
    }
    fmt.Printf(ft, ""\n   gradians    "", ""normalized grds"", ""    degrees    "", ""     mils      "", ""     radians"")
    for _, a := range angles {
        fmt.Printf(ft, s(a), s(g2g(a)), s(g2d(a)), s(g2m(a)), s(g2r(a)))
    }
    fmt.Printf(ft, ""\n     mils      "", ""normalized mils"", ""    degrees    "", ""   gradians    "", ""     radians"")
    for _, a := range angles {
        fmt.Printf(ft, s(a), s(m2m(a)), s(m2d(a)), s(m2g(a)), s(m2r(a)))
    }
    fmt.Printf(ft, ""\n    radians    "", ""normalized rads"", ""    degrees    "", ""   gradians    "", ""      mils  "")
    for _, a := range angles {
        fmt.Printf(ft, s(a), s(r2r(a)), s(r2d(a)), s(r2g(a)), s(r2m(a)))
    }
}",2461,75,"package main

import (
    ""math""
    ""testing""
)

func TestD2D(t *testing.T) {
    tests := []struct {
        input    float64
        expected float64
    }{
        {-2, 358},
        {-1, 359},
        {0, 0},
        {1, 1},
        {2, 2},
        {6.2831853, 6.2831853},
        {16, 16},
        {57.2957795, 57.2957795},
        {359, 359},
        {399, 39},
        {6399, 279},
        {1000000, 280},
    }

    for _, test := range tests {
        result := d2d(test.input)
        if result != test.expected {
            t.Errorf(""d2d(%f) = %f; expected %f"", test.input, result, test.expected)
        }
    }
}

func TestG2G(t *testing.T) {
    tests := []struct {
        input    float64
        expected float64
    }{
        {-2, 398},
        {-1, 399},
        {0, 0},
        {1, 1},
        {2, 2},
        {6.2831853, 6.2831853},
        {16, 16},
        {57.2957795, 57.2957795},
        {359, 359},
        {399, 399},
        {6399, 399},
        {1000000, 0},
    }

    for _, test := range tests {
        result := g2g(test.input)
        if result != test.expected {
            t.Errorf(""g2g(%f) = %f; expected %f"", test.input, result, test.expected)
        }
    }
}

func TestM2M(t *testing.T) {
    tests := []struct {
        input    float64
        expected float64
    }{
        {-2, 6398},
        {-1, 6399},
        {0, 0},
        {1, 1},
        {2, 2},
        {6.2831853, 6.2831853},
        {16, 16},
        {57.2957795, 57.2957795},
        {359, 359},
        {399, 399},
        {6399, 6399},
        {1000000, 6400},
    }

    for _, test := range tests {
        result := m2m(test.input)
        if result != test.expected {
            t.Errorf(""m2m(%f) = %f; expected %f"", test.input, result, test.expected)
        }
    }
}

func TestR2R(t *testing.T) {
    tests := []struct {
        input    float64
        expected float64
    }{
        {-2, 4.283185307179586},
        {-1, 5.283185307179586},
        {0, 0},
        {1, 1},
        {2, 2},
        {6.2831853, 0.000000006283185},
        {16, 3.716814692820414},
        {57.2957795, 0.283185307179586},
        {359, 5.26548245743669},
        {399, 0.017453292519943},
        {6399, 5.26548245743669},
        {1000000, 0.973536158445789},
    }

    for _, test := range tests {
        result := r2r(test.input)
        if math.Abs(result-test.expected) > 1e-9 {
            t.Errorf(""r2r(%f) = %f; expected %f"", test.input, result, test.expected)
        }
    }
}

func TestD2G(t *testing.T) {
    tests := []struct {
        input    float64
        expected float64
    }{
        {-2, 397.77777777777777},
        {-1, 398.8888888888889},
        {0, 0},
        {1, 1.1111111111111112},
        {2, 2.2222222222222223},
        {6.2831853, 6.981317},
        {16, 17.77777777777778},
        {57.2957795, 63.66197722222223},
        {359, 398.8888888888889},
        {399, 43.333333333333336},
        {6399, 310.6666666666667},
        {1000000, 311.1111111111111},
    }

    for _, test := range tests {
        result := d2g(test.input)
        if math.Abs(result-test.expected) > 1e-9 {
            t.Errorf(""d2g(%f) = %f; expected %f"", test.input, result, test.expected)
        }
    }
}

func TestD2M(t *testing.T) {
    tests := []struct {
        input    float64
        expected float64
    }{
        {-2, 6377.777777777778},
        {-1, 6388.888888888889},
        {0, 0},
        {1, 11.11111111111111},
        {2, 22.22222222222222},
        {6.2831853, 19.94722222222222},
        {16, 177.77777777777777},
        {57.2957795, 1021.3333333333333},
        {359, 6388.888888888889},
        {399, 688.8888888888889},
        {6399, 4978.666666666667},
        {1000000, 4977.777777777778},
    }

    for _, test := range tests {
        result := d2m(test.input)
        if math.Abs(result-test.expected) > 1e-9 {
            t.Errorf(""d2m(%f) = %f; expected %f"", test.input, result, test.expected)
        }
    }
}

func TestD2R(t *testing.T) {
    tests := []struct {
        input    float64
        expected float64
    }{
        {-2, -0.03490658503988659},
        {-1, -0.017453292519943295},
        {0, 0},
        {1, 0.017453292519943295},
        {2, 0.03490658503988659},
        {6.2831853, 0.1096622711232151},
        {16, 0.2792526803190927},
        {57.2957795, 1.0000000000000002},
        {359, 6.265732014659643},
        {399, 0.6806784082777885},
        {6399, 4.870053496669288},
        {1000000, 4.886921905584122},
    }

    for _, test := range tests {
        result := d2r(test.input)
        if math.Abs(result-test.expected) > 1e-9 {
            t.Errorf(""d2r(%f) = %f; expected %f"", test.input, result, test.expected)
        }
    }
}

func TestG2D(t *testing.T) {
    tests := []struct {
        input    float64
        expected float64
    }{
        {-2, 358.2},
        {-1, 359.1},
        {0, 0},
        {1, 0.9},
        {2, 1.8},
        {6.2831853, 5.654866770000001},
        {16, 14.4},
        {57.2957795, 51.56620155},
        {359, 323.1},
        {399, 359.1},
        {6399, 323.1},
        {1000000, 0},
    }

    for _, test := range tests {
        result := g2d(test.input)
        if math.Abs(result-test.expected) > 1e-9 {
            t.Errorf(""g2d(%f) = %f; expected %f"", test.input, result, test.expected)
        }
    }
}

func TestG2M(t *testing.T) {
    tests := []struct {
        input    float64
        expected float64
    }{
        {-2, 6382},
        {-1, 6391},
        {0, 0},
        {1, 9},
        {2, 18},
        {6.2831853, 100.5308648},
        {16, 144},
        {57.2957795, 918.932472},
        {359, 5742},
        {399, 6391},
        {6399, 5742},
        {1000000, 0},
    }

    for _, test := range tests {
        result := g2m(test.input)
        if math.Abs(result-test.expected) > 1e-9 {
            t.Errorf(""g2m(%f) = %f; expected %f"", test.input, result, test.expected)
        }
    }
}

func TestG2R(t *testing.T) {
    tests := []struct {
        input    float64
        expected float64
    }{
        {-2, -0.031415926535897934},
        {-1, -0.015707963267948967},
        {0, 0},
        {1, 0.015707963267948967},
        {2, 0.031415926535897934},
        {6.2831853, 0.1096622711232151},
        {16, 0.25132741228718347},
        {57.2957795, 0.8999999999999999},
        {359, 5.654866776461628},
        {399, 0.015707963267948967},
        {6399, 5.654866776461628},
        {1000000, 0},
    }

    for _, test := range tests {
        result := g2r(test.input)
        if math.Abs(result-test.expected) > 1e-9 {
            t.Errorf(""g2r(%f) = %f; expected %f"", test.input, result, test.expected)
        }
    }
}

func TestM2D(t *testing.T) {
    tests := []struct {
        input    float64
        expected float64
    }{
        {-2, 359.8875},
        {-1, 359.94375},
        {0, 0},
        {1, 0.05625},
        {2, 0.1125},
        {6.2831853, 0.353125},
        {16, 0.9},
        {57.2957795, 3.225},
        {359, 20.08125},
        {399, 22.44375},
        {6399, 359.94375},
        {1000000, 0},
    }

    for _, test := range tests {
        result := m2d(test.input)
        if math.Abs(result-test.expected) > 1e-9 {
            t.Errorf(""m2d(%f) = %f; expected %f"", test.input, result, test.expected)
        }
    }
}

func TestM2G(t *testing.T) {
    tests := []struct {
        input    float64
        expected float64
    }{
        {-2, 399.8611111111111},
        {-1, 399.93055555555554},
        {0, 0},
        {1, 0.06944444444444445},
        {2, 0.1388888888888889},
        {6.2831853, 0.4350694444444445},
        {16, 1},
        {57.2957795, 5.375},
        {359, 22.3125},
        {399, 24.875},
        {6399, 399.93055555555554},
        {1000000, 0},
    }

    for _, test := range tests {
        result := m2g(test.input)
        if math.Abs(result-test.expected) > 1e-9 {
            t.Errorf(""m2g(%f) = %f; expected %f"", test.input, result, test.expected)
        }
    }
}

func TestM2R(t *testing.T) {
    tests := []struct {
        input    float64
        expected float64
    }{
        {-2, 6.280369834735101},
        {-1, 6.281777570686674},
        {0, 0},
        {1, 0.0009817477042468103},
        {2, 0.0019634954084936206},
        {6.2831853, 0.006135923151542565},
        {16, 0.015707963267948967},
        {57.2957795, 0.056548667764616276},
        {359, 0.3518583772020568},
        {399, 0.3916790481341308},
        {6399, 6.281777570686674},
        {1000000, 0},
    }

    for _, test := range tests {
        result := m2r(test.input)
        if math.Abs(result-test.expected) > 1e-9 {
            t.Errorf(""m2r(%f) = %f; expected %f"", test.input, result, test.expected)
        }
    }
}

func TestR2D(t *testing.T) {
    tests := []struct {
        input    float64
        expected float64
    }{
        {-2, 245.66370614359172},
        {-1, 304.3362938564083},
        {0, 0},
        {1, 57.29577951308232},
        {2, 114.59155902616465},
        {6.2831853, 0.000000360000000},
        {16, 298.1980515339464},
        {57.2957795, 327.2957795},
        {359, 359},
        {399, 399},
        {6399, 6399},
        {1000000, 280},
    }

    for _, test := range tests {
        result := r2d(test.input)
        if math.Abs(result-test.expected) > 1e-9 {
            t.Errorf(""r2d(%f) = %f; expected %f"", test.input, result, test.expected)
        }
    }
}

func TestR2G(t *testing.T) {
    tests := []struct {
        input    float64
        expected float64
    }{
        {-2, 273.3333333333333},
        {-1, 336.66666666666663},
        {0, 0},
        {1, 63.66197723675813},
        {2, 127.32395447351626},
        {6.2831853, 0.0000004},
        {16, 331.331978926607},
        {57.2957795, 363.66197723675813},
        {359, 399},
        {399, 399},
        {6399, 399},
        {1000000, 0},
    }

    for _, test := range tests {
        result := r2g(test.input)
        if math.Abs(result-test.expected) > 1e-9 {
            t.Errorf(""r2g(%f) = %f; expected %f"", test.input, result, test.expected)
        }
    }
}

func TestR2M(t *testing.T) {
    tests := []struct {
        input    float64
        expected float64
    }{
        {-2, 4377.777777777778},
        {-1, 5188.888888888889},
        {0, 0},
        {1, 1018.5916357881302},
        {2, 2037.1832715762604},
        {6.2831853, 0.00000064},
        {16, 5298.198051533946},
        {57.2957795, 5837.2957795},
        {359, 6399},
        {399, 6399},
        {6399, 6399},
        {1000000, 0},
    }

    for _, test := range tests {
        result := r2m(test.input)
        if math.Abs(result-test.expected) > 1e-9 {
            t.Errorf(""r2m(%f) = %f; expected %f"", test.input, result, test.expected)
        }
    }
}
",./data/generated/docs_golang/angles_geometric_normalization_and_conversion/gpt_4o_2024_08_06_angles_geometric_normalization_and_conversion_test.go,CompileStatus.OK,0.0,43.2,,0.05,0.67,0.123,16.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: d2d', 'Severity': '', 'SourceLines': ['        result := d2d(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_angles_geometric_normalization_and_conversion_test.go', 'Offset': 0, 'Line': 28, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: g2g', 'Severity': '', 'SourceLines': ['        result := g2g(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_angles_geometric_normalization_and_conversion_test.go', 'Offset': 0, 'Line': 55, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: m2m', 'Severity': '', 'SourceLines': ['        result := m2m(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_angles_geometric_normalization_and_conversion_test.go', 'Offset': 0, 'Line': 82, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: r2r', 'Severity': '', 'SourceLines': ['        result := r2r(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_angles_geometric_normalization_and_conversion_test.go', 'Offset': 0, 'Line': 109, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: d2g', 'Severity': '', 'SourceLines': ['        result := d2g(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_angles_geometric_normalization_and_conversion_test.go', 'Offset': 0, 'Line': 136, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: d2m', 'Severity': '', 'SourceLines': ['        result := d2m(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_angles_geometric_normalization_and_conversion_test.go', 'Offset': 0, 'Line': 163, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: d2r', 'Severity': '', 'SourceLines': ['        result := d2r(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_angles_geometric_normalization_and_conversion_test.go', 'Offset': 0, 'Line': 190, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: g2d', 'Severity': '', 'SourceLines': ['        result := g2d(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_angles_geometric_normalization_and_conversion_test.go', 'Offset': 0, 'Line': 217, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: g2m', 'Severity': '', 'SourceLines': ['        result := g2m(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_angles_geometric_normalization_and_conversion_test.go', 'Offset': 0, 'Line': 244, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: g2r', 'Severity': '', 'SourceLines': ['        result := g2r(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_angles_geometric_normalization_and_conversion_test.go', 'Offset': 0, 'Line': 271, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: m2d', 'Severity': '', 'SourceLines': ['        result := m2d(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_angles_geometric_normalization_and_conversion_test.go', 'Offset': 0, 'Line': 298, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: m2g', 'Severity': '', 'SourceLines': ['        result := m2g(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_angles_geometric_normalization_and_conversion_test.go', 'Offset': 0, 'Line': 325, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: m2r', 'Severity': '', 'SourceLines': ['        result := m2r(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_angles_geometric_normalization_and_conversion_test.go', 'Offset': 0, 'Line': 352, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: r2d', 'Severity': '', 'SourceLines': ['        result := r2d(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_angles_geometric_normalization_and_conversion_test.go', 'Offset': 0, 'Line': 379, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: r2g', 'Severity': '', 'SourceLines': ['        result := r2g(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_angles_geometric_normalization_and_conversion_test.go', 'Offset': 0, 'Line': 406, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: r2m', 'Severity': '', 'SourceLines': ['        result := r2m(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_angles_geometric_normalization_and_conversion_test.go', 'Offset': 0, 'Line': 433, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Animation,"
Animation is integral to many parts of GUIs, including both the fancy effects when things change used in window managers, and of course games.   The core of any animation system is a scheme for periodically changing the display while still remaining responsive to the user.   This task demonstrates this.



Task

Create a window containing the string ""Hello World! "" (the trailing space is significant).

Make the text appear to be rotating right by periodically removing one letter from the end of the string and attaching it to the front.

When the user clicks on the (windowed) text, it should reverse its direction.



",Go,"package main
 
import (
    ""log""
    ""time""
 
    ""github.com/gdamore/tcell""
)
 
const (
    msg             = ""Hello World! ""
    x0, y0          = 8, 3
    shiftsPerSecond = 4
    clicksToExit    = 5
)
 
func main() {
    s, err := tcell.NewScreen()
    if err != nil {
        log.Fatal(err)
    }
    if err = s.Init(); err != nil {
        log.Fatal(err)
    }
    s.Clear()
    s.EnableMouse()
    tick := time.Tick(time.Second / shiftsPerSecond)
    click := make(chan bool)
    go func() {
        for {
            em, ok := s.PollEvent().(*tcell.EventMouse)
            if !ok || em.Buttons()&0xFF == tcell.ButtonNone {
                continue
            }
            mx, my := em.Position()
            if my == y0 && mx >= x0 && mx < x0+len(msg) {
                click <- true
            }
        }
    }()
    for inc, shift, clicks := 1, 0, 0; ; {
        select {
        case <-tick:
            shift = (shift + inc) % len(msg)
            for i, r := range msg {
                s.SetContent(x0+((shift+i)%len(msg)), y0, r, nil, 0)
            }
            s.Show()
        case <-click:
            clicks++
            if clicks == clicksToExit {
                s.Fini()
                return
            }
            inc = len(msg) - inc
        }
    }
}",1287,58,none,,,,,,,,,,,False,False,,False,
Apply a callback to an array,"Task

Take a combined set of elements and apply a function to each element.



",Go,"package main
 
import ""fmt""
 
func main() {
    for _, i := range []int{1, 2, 3, 4, 5} {
        fmt.Println(i * i)
    }
}",123,9,"package main

import (
	""testing""
	""reflect""
)

// Assume this is the function we want to test
func applyFunctionToSlice(slice []int, fn func(int) int) []int {
	result := make([]int, len(slice))
	for i, v := range slice {
		result[i] = fn(v)
	}
	return result
}

func TestApplyFunctionToSlice(t *testing.T) {
	tests := []struct {
		name     string
		input    []int
		fn       func(int) int
		expected []int
	}{
		{
			name:     ""Square function"",
			input:    []int{1, 2, 3, 4, 5},
			fn:       func(x int) int { return x * x },
			expected: []int{1, 4, 9, 16, 25},
		},
		{
			name:     ""Double function"",
			input:    []int{1, 2, 3, 4, 5},
			fn:       func(x int) int { return x * 2 },
			expected: []int{2, 4, 6, 8, 10},
		},
		{
			name:     ""Identity function"",
			input:    []int{1, 2, 3, 4, 5},
			fn:       func(x int) int { return x },
			expected: []int{1, 2, 3, 4, 5},
		},
		{
			name:     ""Empty slice"",
			input:    []int{},
			fn:       func(x int) int { return x * x },
			expected: []int{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := applyFunctionToSlice(tt.input, tt.fn)
			if !reflect.DeepEqual(result, tt.expected) {
				t.Errorf(""expected %v, got %v"", tt.expected, result)
			}
		})
	}
}
",./data/generated/docs_golang/apply_a_callback_to_an_array/gpt_4o_2024_08_06_apply_a_callback_to_an_array_test.go,CompileStatus.OK,0.0,0.0,,0.03,0.5,0.11,0.0,[],False,False,100.0,False,[]
Apply a digital filter (direct form II transposed),"Digital filters are used to apply a mathematical operation to a sampled signal. One of the common formulations is the ""direct form II transposed"" which can represent both infinite impulse response (IIR) and finite impulse response (FIR) filters, as well as being more numerically stable than other forms. [1]

Task

Filter a signal using an order 3 low-pass Butterworth filter. The coefficients for the filter are a=[1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17] and b = [0.16666667, 0.5, 0.5, 0.16666667]

The signal that needs filtering is the following vector: [-0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412, -0.662370894973, -1.00700480494, -0.404707073677 ,0.800482325044, 0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195, 0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293, 0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589]
",Go,"package main
 
import ""fmt""
 
type filter struct {
    b, a []float64
}
 
func (f filter) filter(in []float64) []float64 {
    out := make([]float64, len(in))
    s := 1. / f.a[0]
    for i := range in {
        tmp := 0.
        b := f.b
        if i+1 < len(b) {
            b = b[:i+1]
        }
        for j, bj := range b {
            tmp += bj * in[i-j]
        }
        a := f.a[1:]
        if i < len(a) {
            a = a[:i]
        }
        for j, aj := range a {
            tmp -= aj * out[i-j-1]
        }
        out[i] = tmp * s
    }
    return out
}
 
//Constants for a Butterworth filter (order 3, low pass)
var bwf = filter{
    a: []float64{1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17},
    b: []float64{0.16666667, 0.5, 0.5, 0.16666667},
}
 
var sig = []float64{
    -0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412,
    -0.662370894973, -1.00700480494, -0.404707073677, 0.800482325044,
    0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195,
    0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293,
    0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589,
}
 
func main() {
    for _, v := range bwf.filter(sig) {
        fmt.Printf(""%9.6f\n"", v)
    }
}",1246,51,"package main

import (
	""reflect""
	""testing""
)

func TestFilter(t *testing.T) {
	tests := []struct {
		name     string
		filter   filter
		input    []float64
		expected []float64
	}{
		{
			name: ""Test Butterworth filter on given signal"",
			filter: filter{
				a: []float64{1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17},
				b: []float64{0.16666667, 0.5, 0.5, 0.16666667},
			},
			input: []float64{
				-0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412,
				-0.662370894973, -1.00700480494, -0.404707073677, 0.800482325044,
				0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195,
				0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293,
				0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589,
			},
			expected: []float64{
				-0.152973986441, -0.116476523579, 0.366648476215, 0.515923755481,
				0.233612139929, -0.374315663365, -0.563156204641, -0.107061138656,
				0.486787119498, 0.764998276582, 0.755788073372, 0.568011446707,
				0.422266187919, 0.202477026062, 0.019391702421, -0.066947281840,
				0.010671755737, 0.246930444774, 0.478315186696, 0.667946686579,
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			output := tt.filter.filter(tt.input)
			if !reflect.DeepEqual(output, tt.expected) {
				t.Errorf(""expected %v, got %v"", tt.expected, output)
			}
		})
	}
}
",./data/generated/docs_golang/apply_a_digital_filter_direct_form_ii_transposed/gpt_4o_2024_08_06_apply_a_digital_filter_direct_form_ii_transposed_test.go,CompileStatus.OK,0.0,88.9,,0.03,0.12,0.118,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: filter', 'Severity': '', 'SourceLines': ['\t\tfilter   filter'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_apply_a_digital_filter_direct_form_ii_transposed_test.go', 'Offset': 0, 'Line': 11, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: filter', 'Severity': '', 'SourceLines': ['\t\t\tfilter: filter{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_apply_a_digital_filter_direct_form_ii_transposed_test.go', 'Offset': 0, 'Line': 17, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Archimedean spiral,"
The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.



An Archimedean spiral can be described by the equation:






r
=
a
+
b
θ


{\displaystyle \,r=a+b\theta }


with real numbers a and b.



Task
Draw an Archimedean spiral.



",Go,"package main
 
import (
	""image""
	""image/color""
	""image/draw""
	""image/png""
	""log""
	""math""
	""os""
)
 
func main() {
	const (
		width, height = 600, 600
		centre        = width / 2.0
		degreesIncr   = 0.1 * math.Pi / 180
		turns         = 2
		stop          = 360 * turns * 10 * degreesIncr
		fileName      = ""spiral.png""
	)
 
	img := image.NewNRGBA(image.Rect(0, 0, width, height)) // create new image
	bg := image.NewUniform(color.RGBA{255, 255, 255, 255}) // prepare white for background
	draw.Draw(img, img.Bounds(), bg, image.ZP, draw.Src)   // fill the background
	fgCol := color.RGBA{255, 0, 0, 255}                    // red plot
 
	a := 1.0
	b := 20.0
 
	for theta := 0.0; theta < stop; theta += degreesIncr {
		r := a + b*theta
		x := r * math.Cos(theta)
		y := r * math.Sin(theta)
		img.Set(int(centre+x), int(centre-y), fgCol)
	}
 
	imgFile, err := os.Create(fileName)
	if err != nil {
		log.Fatal(err)
	}
	defer imgFile.Close()
 
	if err := png.Encode(imgFile, img); err != nil {
		imgFile.Close()
		log.Fatal(err)
	}
}",1028,48,"package main

import (
	""image""
	""image/color""
	""image/png""
	""os""
	""testing""
)

func TestArchimedeanSpiralImageCreation(t *testing.T) {
	const (
		width, height = 600, 600
		fileName      = ""spiral.png""
	)

	// Run the main function to create the image
	main()

	// Check if the file was created
	if _, err := os.Stat(fileName); os.IsNotExist(err) {
		t.Fatalf(""Expected file %s to be created, but it does not exist."", fileName)
	}

	// Open the created image file
	imgFile, err := os.Open(fileName)
	if err != nil {
		t.Fatalf(""Failed to open the image file: %v"", err)
	}
	defer imgFile.Close()

	// Decode the image
	img, err := png.Decode(imgFile)
	if err != nil {
		t.Fatalf(""Failed to decode the image: %v"", err)
	}

	// Check the image dimensions
	if img.Bounds().Dx() != width || img.Bounds().Dy() != height {
		t.Fatalf(""Expected image dimensions to be %dx%d, but got %dx%d"", width, height, img.Bounds().Dx(), img.Bounds().Dy())
	}

	// Check if the center pixel is not white (indicating the spiral was drawn)
	centerColor := img.At(width/2, height/2)
	r, g, b, _ := centerColor.RGBA()
	if r == 0xFFFF && g == 0xFFFF && b == 0xFFFF {
		t.Fatalf(""Expected the center of the image to not be white, indicating the spiral was drawn."")
	}
}

func TestBackgroundIsWhite(t *testing.T) {
	const (
		width, height = 600, 600
		fileName      = ""spiral.png""
	)

	// Open the created image file
	imgFile, err := os.Open(fileName)
	if err != nil {
		t.Fatalf(""Failed to open the image file: %v"", err)
	}
	defer imgFile.Close()

	// Decode the image
	img, err := png.Decode(imgFile)
	if err != nil {
		t.Fatalf(""Failed to decode the image: %v"", err)
	}

	// Check a few random background pixels to ensure they are white
	white := color.RGBA{255, 255, 255, 255}
	checkPoints := []image.Point{
		{0, 0},
		{width - 1, 0},
		{0, height - 1},
		{width - 1, height - 1},
	}

	for _, point := range checkPoints {
		if img.At(point.X, point.Y) != white {
			t.Fatalf(""Expected background pixel at %v to be white."", point)
		}
	}
}
",./data/generated/docs_golang/archimedean_spiral/gpt_4o_2024_08_06_archimedean_spiral_test.go,CompileStatus.OK,0.0,84.2,,0.19,2.0,0.382,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\tmain()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_archimedean_spiral_test.go', 'Offset': 0, 'Line': 18, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,50.0,False,[]
Arithmetic-geometric mean/Calculate Pi,"Almkvist Berndt 1988 begins with an investigation of why the agm is such an efficient algorithm, and proves that it converges quadratically. This is an efficient method to calculate 



π


{\displaystyle \pi }

.

With the same notations used in Arithmetic-geometric mean, we can summarize the paper by writing:





π
=



4


a
g
m

(
1
,
1

/



2



)

2




1
−

∑

n
=
1


∞



2

n
+
1


(

a

n


2


−

g

n


2


)





{\displaystyle \pi ={\frac {4\;\mathrm {agm} (1,1/{\sqrt {2}})^{2}}{1-\sum \limits _{n=1}^{\infty }2^{n+1}(a_{n}^{2}-g_{n}^{2})}}}



This allows you to make the approximation, for any large   N:





π
≈



4


a

N


2




1
−

∑

k
=
1


N



2

k
+
1


(

a

k


2


−

g

k


2


)





{\displaystyle \pi \approx {\frac {4\;a_{N}^{2}}{1-\sum \limits _{k=1}^{N}2^{k+1}(a_{k}^{2}-g_{k}^{2})}}}



The purpose of this task is to demonstrate how to use this approximation in order to compute a large number of decimals of 



π


{\displaystyle \pi }

.
",Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    one := big.NewFloat(1)
    two := big.NewFloat(2)
    four := big.NewFloat(4)
    prec := uint(768) // say
 
    a := big.NewFloat(1).SetPrec(prec)
    g := new(big.Float).SetPrec(prec)
 
    // temporary variables
    t := new(big.Float).SetPrec(prec)
    u := new(big.Float).SetPrec(prec)
 
    g.Quo(a, t.Sqrt(two))
    sum := new(big.Float)
    pow := big.NewFloat(2)
 
    for a.Cmp(g) != 0 {
        t.Add(a, g)
        t.Quo(t, two)
        g.Sqrt(u.Mul(a, g))
        a.Set(t)
        pow.Mul(pow, two)
        t.Sub(t.Mul(a, a), u.Mul(g, g))
        sum.Add(sum, t.Mul(t, pow))
    }
 
    t.Mul(a, a)
    t.Mul(t, four)
    pi := t.Quo(t, u.Sub(one, sum))
    fmt.Println(pi)
}",758,39,error,,,,,,,,,,,False,False,,False,
Assertions,"Assertions are a way of breaking out of code when there is an error or an unexpected input.

Some languages throw exceptions and some treat it as a break point.



Task

Show an assertion in your language by asserting that an integer variable is equal to 42.



",Go,"package main
 
func main() {
    x := 43
    if x != 42 {
        panic(42)
    }
}",83,8,"package main

import (
	""testing""
)

func TestMain(t *testing.T) {
	defer func() {
		if r := recover(); r != nil {
			if r != 42 {
				t.Errorf(""Expected panic with 42, but got %v"", r)
			}
		} else {
			t.Error(""Expected panic, but code did not panic"")
		}
	}()

	main()
}
",./data/generated/docs_golang/assertions/gpt_4o_2024_08_06_assertions_test.go,CompileStatus.OK,0.0,100.0,,0.2,1.0,0.112,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\tmain()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_assertions_test.go', 'Offset': 0, 'Line': 18, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Associative array/Merging,"Task

Define two associative arrays, where one represents the following ""base"" data:





 Key 
 Value


 ""name"" 
 ""Rocket Skates""


 ""price"" 
 12.75


 ""color"" 
 ""yellow""

And the other represents ""update"" data:





 Key 
 Value


 ""price"" 
 15.25


 ""color"" 
 ""red""


 ""year"" 
 1974

Merge these into a new associative array that contains every key found in either of the source ones. Each key should map to the value in the second (update) table if that exists, or else to the value in the first (base) table. If possible, do this in a way that does not mutate the original two associative arrays. Obviously this should be done in a way that would work for any data, not just the specific data given here, but in this example the result should be:





 Key 
 Value


 ""name"" 
 ""Rocket Skates""


 ""price"" 
 15.25


 ""color"" 
 ""red""


 ""year"" 
 1974


",Go,"package main
 
import ""fmt""
 
type assoc map[string]interface{}
 
func merge(base, update assoc) assoc {
    result := make(assoc)
    for k, v := range base {
        result[k] = v
    }
    for k, v := range update {
        result[k] = v
    }
    return result
}
 
func main() {
    base := assoc{""name"": ""Rocket Skates"", ""price"": 12.75, ""color"": ""yellow""}
    update := assoc{""price"": 15.25, ""color"": ""red"", ""year"": 1974}
    result := merge(base, update)
    fmt.Println(result)
}",486,23,"package main

import (
	""reflect""
	""testing""
)

type assoc map[string]interface{}

func merge(base, update assoc) assoc {
	result := make(assoc)
	for k, v := range base {
		result[k] = v
	}
	for k, v := range update {
		result[k] = v
	}
	return result
}

func TestMerge(t *testing.T) {
	tests := []struct {
		base     assoc
		update   assoc
		expected assoc
	}{
		{
			base:     assoc{""name"": ""Rocket Skates"", ""price"": 12.75, ""color"": ""yellow""},
			update:   assoc{""price"": 15.25, ""color"": ""red"", ""year"": 1974},
			expected: assoc{""name"": ""Rocket Skates"", ""price"": 15.25, ""color"": ""red"", ""year"": 1974},
		},
		{
			base:     assoc{""name"": ""Rocket Skates"", ""price"": 12.75},
			update:   assoc{""color"": ""red"", ""year"": 1974},
			expected: assoc{""name"": ""Rocket Skates"", ""price"": 12.75, ""color"": ""red"", ""year"": 1974},
		},
		{
			base:     assoc{},
			update:   assoc{""price"": 15.25, ""color"": ""red"", ""year"": 1974},
			expected: assoc{""price"": 15.25, ""color"": ""red"", ""year"": 1974},
		},
		{
			base:     assoc{""name"": ""Rocket Skates"", ""price"": 12.75, ""color"": ""yellow""},
			update:   assoc{},
			expected: assoc{""name"": ""Rocket Skates"", ""price"": 12.75, ""color"": ""yellow""},
		},
		{
			base:     assoc{},
			update:   assoc{},
			expected: assoc{},
		},
	}

	for _, test := range tests {
		result := merge(test.base, test.update)
		if !reflect.DeepEqual(result, test.expected) {
			t.Errorf(""merge(%v, %v) = %v; expected %v"", test.base, test.update, result, test.expected)
		}
	}
}
",./data/generated/docs_golang/associative_array_merging/gpt_4o_2024_08_06_associative_array_merging_test.go,CompileStatus.SYNTAX_ERROR,,,,0.03,0.25,,0.0,[],False,False,,False,"[{'file': './gpt_4o_2024_08_06_associative_array_merging_test.go', 'line': 8, 'column': 6, 'message': 'assoc redeclared in this block'}]"
Average loop length,"Let f be a uniformly-randomly chosen mapping from the numbers 1..N to the numbers 1..N (note: not necessarily a permutation of 1..N; the mapping could produce a number in more than one way or not at all). At some point, the sequence 1, f(1), f(f(1))... will contain a repetition, a number that occurring for the second time in the sequence.



Task

Write a program or a script that estimates, for each N, the average length until the first such repetition.

Also calculate this expected length using an analytical formula, and optionally compare the simulated result with the theoretical one.



This problem comes from the end of Donald Knuth's Christmas tree lecture 2011.

Example of expected output:

 N    average    analytical    (error)
===  =========  ============  =========
  1     1.0000        1.0000  (  0.00%)
  2     1.4992        1.5000  (  0.05%)
  3     1.8784        1.8889  (  0.56%)
  4     2.2316        2.2188  (  0.58%)
  5     2.4982        2.5104  (  0.49%)
  6     2.7897        2.7747  (  0.54%)
  7     3.0153        3.0181  (  0.09%)
  8     3.2429        3.2450  (  0.07%)
  9     3.4536        3.4583  (  0.14%)
 10     3.6649        3.6602  (  0.13%)
 11     3.8091        3.8524  (  1.12%)
 12     3.9986        4.0361  (  0.93%)
 13     4.2074        4.2123  (  0.12%)
 14     4.3711        4.3820  (  0.25%)
 15     4.5275        4.5458  (  0.40%)
 16     4.6755        4.7043  (  0.61%)
 17     4.8877        4.8579  (  0.61%)
 18     4.9951        5.0071  (  0.24%)
 19     5.1312        5.1522  (  0.41%)
 20     5.2699        5.2936  (  0.45%)

",Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/rand""
)
 
const nmax = 20
 
func main() {
    fmt.Println("" N    average    analytical    (error)"")
    fmt.Println(""===  =========  ============  ========="")
    for n := 1; n <= nmax; n++ {
        a := avg(n)
        b := ana(n)
        fmt.Printf(""%3d  %9.4f  %12.4f  (%6.2f%%)\n"",
            n, a, b, math.Abs(a-b)/b*100)
    }
}
 
func avg(n int) float64 {
    const tests = 1e4
    sum := 0
    for t := 0; t < tests; t++ {
        var v [nmax]bool
        for x := 0; !v[x]; x = rand.Intn(n) {
            v[x] = true
            sum++
        }
    }
    return float64(sum) / tests
}
 
func ana(n int) float64 {
    nn := float64(n)
    term := 1.
    sum := 1.
    for i := nn - 1; i >= 1; i-- {
        term *= i / nn
        sum += term
    }
    return sum
}",828,44,"package main

import (
	""math""
	""testing""
)

// TestAnaFunction tests the ana function for known values.
func TestAnaFunction(t *testing.T) {
	tests := []struct {
		n        int
		expected float64
	}{
		{1, 1.0},
		{2, 1.5},
		{3, 1.8889},
		{4, 2.2188},
		{5, 2.5104},
		{6, 2.7747},
		{7, 3.0181},
		{8, 3.2450},
		{9, 3.4583},
		{10, 3.6602},
	}

	for _, tt := range tests {
		t.Run(""AnaFunction"", func(t *testing.T) {
			result := ana(tt.n)
			if math.Abs(result-tt.expected) > 0.0001 {
				t.Errorf(""ana(%d) = %f; want %f"", tt.n, result, tt.expected)
			}
		})
	}
}

// TestAvgFunction tests the avg function to ensure it runs without error.
// Note: This test checks if the function runs and returns a float, but due to randomness,
// it doesn't check for exact values.
func TestAvgFunction(t *testing.T) {
	for n := 1; n <= 10; n++ {
		t.Run(""AvgFunction"", func(t *testing.T) {
			result := avg(n)
			if result <= 0 {
				t.Errorf(""avg(%d) = %f; want > 0"", n, result)
			}
		})
	}
}
",./data/generated/docs_golang/average_loop_length/gpt_4o_2024_08_06_average_loop_length_test.go,CompileStatus.OK,0.0,71.4,,0.07,0.29,0.178,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: ana', 'Severity': '', 'SourceLines': ['\t\t\tresult := ana(tt.n)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_average_loop_length_test.go', 'Offset': 0, 'Line': 28, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: avg', 'Severity': '', 'SourceLines': ['\t\t\tresult := avg(n)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_average_loop_length_test.go', 'Offset': 0, 'Line': 42, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Averages/Mean time of day,"Task[edit]
A particular activity of bats occurs at these times of the day:

23:00:17, 23:40:20, 00:12:45, 00:17:19
Using the idea that there are twenty-four hours in a day,
which is analogous to there being 360 degrees in a circle,
map times of day to and from angles;
and using the ideas of Averages/Mean angle
compute and show the average time of the nocturnal activity
to an accuracy of one second of time.

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",Go,"package main
 
import (
    ""errors""
    ""fmt""
    ""log""
    ""math""
    ""time""
)
 
var inputs = []string{""23:00:17"", ""23:40:20"", ""00:12:45"", ""00:17:19""}
 
func main() {
    tList := make([]time.Time, len(inputs))
    const clockFmt = ""15:04:05""
    var err error
    for i, s := range inputs {
        tList[i], err = time.Parse(clockFmt, s)
        if err != nil {
            log.Fatal(err)
        }
    }
    mean, err := meanTime(tList)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(mean.Format(clockFmt))
}
 
func meanTime(times []time.Time) (mean time.Time, err error) {
    if len(times) == 0 {
        err = errors.New(""meanTime: no times specified"")
        return
    }
    var ssum, csum float64
    for _, t := range times {
        h, m, s := t.Clock()
        n := t.Nanosecond()
        fSec := (float64((h*60+m)*60+s) + float64(n)*1e-9)
        sin, cos := math.Sincos(fSec * math.Pi / (12 * 60 * 60))
        ssum += sin
        csum += cos
    }
    if ssum == 0 && csum == 0 {
        err = errors.New(""meanTime: mean undefined"")
        return
    }
    _, dayFrac := math.Modf(1 + math.Atan2(ssum, csum)/(2*math.Pi))
    return mean.Add(time.Duration(dayFrac * 24 * float64(time.Hour))), nil
}",1234,50,"package main

import (
    ""testing""
    ""time""
)

func TestMeanTime(t *testing.T) {
    const clockFmt = ""15:04:05""

    tests := []struct {
        name     string
        inputs   []string
        expected string
        wantErr  bool
    }{
        {
            name:     ""Normal case"",
            inputs:   []string{""23:00:17"", ""23:40:20"", ""00:12:45"", ""00:17:19""},
            expected: ""23:47:10"",
            wantErr:  false,
        },
        {
            name:     ""Empty input"",
            inputs:   []string{},
            expected: """",
            wantErr:  true,
        },
        {
            name:     ""Single time input"",
            inputs:   []string{""12:00:00""},
            expected: ""12:00:00"",
            wantErr:  false,
        },
        {
            name:     ""All times at midnight"",
            inputs:   []string{""00:00:00"", ""00:00:00"", ""00:00:00""},
            expected: ""00:00:00"",
            wantErr:  false,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tList := make([]time.Time, len(tt.inputs))
            var err error
            for i, s := range tt.inputs {
                tList[i], err = time.Parse(clockFmt, s)
                if err != nil {
                    t.Fatalf(""Failed to parse time: %v"", err)
                }
            }
            mean, err := meanTime(tList)
            if (err != nil) != tt.wantErr {
                t.Errorf(""meanTime() error = %v, wantErr %v"", err, tt.wantErr)
                return
            }
            if !tt.wantErr {
                got := mean.Format(clockFmt)
                if got != tt.expected {
                    t.Errorf(""meanTime() = %v, expected %v"", got, tt.expected)
                }
            }
        })
    }
}
",./data/generated/docs_golang/averages_mean_time_of_day/gpt_4o_2024_08_06_averages_mean_time_of_day_test.go,CompileStatus.OK,0.0,51.9,,0.07,0.33,0.113,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: meanTime', 'Severity': '', 'SourceLines': ['            mean, err := meanTime(tList)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_averages_mean_time_of_day_test.go', 'Offset': 0, 'Line': 53, 'Column': 26}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,60.0,False,[]
Averages/Pythagorean means,"Task[edit]
Compute all three of the Pythagorean means of the set of integers 1 through 10 (inclusive).

Show that 



A
(

x

1


,
…
,

x

n


)
≥
G
(

x

1


,
…
,

x

n


)
≥
H
(

x

1


,
…
,

x

n


)


{\displaystyle A(x_{1},\ldots ,x_{n})\geq G(x_{1},\ldots ,x_{n})\geq H(x_{1},\ldots ,x_{n})}

 for this set of positive integers.

 The most common of the three means, the arithmetic mean, is the sum of the list divided by its length:
 



A
(

x

1


,
…
,

x

n


)
=




x

1


+
⋯
+

x

n



n




{\displaystyle A(x_{1},\ldots ,x_{n})={\frac {x_{1}+\cdots +x_{n}}{n}}}


 The geometric mean is the 



n


{\displaystyle n}

th root of the product of the list:
 



G
(

x

1


,
…
,

x

n


)
=




x

1


⋯

x

n




n





{\displaystyle G(x_{1},\ldots ,x_{n})={\sqrt[{n}]{x_{1}\cdots x_{n}}}}


 The harmonic mean is 



n


{\displaystyle n}

 divided by the sum of the reciprocal of each item in the list:
 



H
(

x

1


,
…
,

x

n


)
=


n



1

x

1




+
⋯
+


1

x

n









{\displaystyle H(x_{1},\ldots ,x_{n})={\frac {n}{{\frac {1}{x_{1}}}+\cdots +{\frac {1}{x_{n}}}}}}




See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func main() {
    sum, sumr, prod := 0., 0., 1.
    for n := 1.; n <= 10; n++ {
        sum += n
        sumr += 1 / n
        prod *= n
    }
    a, g, h := sum/10, math.Pow(prod, .1), 10/sumr
    fmt.Println(""A:"", a, ""G:"", g, ""H:"", h)
    fmt.Println(""A >= G >= H:"", a >= g && g >= h)
}",337,18,"package main

import (
    ""math""
    ""testing""
)

func TestPythagoreanMeans(t *testing.T) {
    sum, sumr, prod := 0., 0., 1.
    for n := 1.; n <= 10; n++ {
        sum += n
        sumr += 1 / n
        prod *= n
    }
    a, g, h := sum/10, math.Pow(prod, .1), 10/sumr

    // Test arithmetic mean
    expectedA := 5.5
    if a != expectedA {
        t.Errorf(""Arithmetic mean incorrect, got: %v, want: %v"", a, expectedA)
    }

    // Test geometric mean
    expectedG := math.Pow(3628800, 0.1)
    if g != expectedG {
        t.Errorf(""Geometric mean incorrect, got: %v, want: %v"", g, expectedG)
    }

    // Test harmonic mean
    expectedH := 10 / (1/1 + 1/2 + 1/3 + 1/4 + 1/5 + 1/6 + 1/7 + 1/8 + 1/9 + 1/10)
    if h != expectedH {
        t.Errorf(""Harmonic mean incorrect, got: %v, want: %v"", h, expectedH)
    }

    // Test inequality A >= G >= H
    if !(a >= g && g >= h) {
        t.Errorf(""Inequality A >= G >= H not satisfied, A: %v, G: %v, H: %v"", a, g, h)
    }
}
",./data/generated/docs_golang/averages_pythagorean_means/gpt_4o_2024_08_06_averages_pythagorean_means_test.go,CompileStatus.SYNTAX_ERROR,,,,0.2,1.33,,1.0,"[{'FromLinter': 'typecheck', 'Text': 'invalid operation: h != expectedH (mismatched types float64 and int)', 'Severity': '', 'SourceLines': ['    if h != expectedH {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_averages_pythagorean_means_test.go', 'Offset': 0, 'Line': 31, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_averages_pythagorean_means_test.go', 'line': 31, 'column': 13, 'message': 'invalid operation: h != expectedH (mismatched types float64 and int)'}]"
Averages/Simple moving average,"Computing the simple moving average of a series of numbers.

Task[edit]
Create a stateful function/class/instance that takes a period and returns a routine that takes a number as argument and returns a simple moving average of its arguments so far.

Description
A simple moving average is a method for computing an average of a stream of numbers by only averaging the last   P   numbers from the stream,   where   P   is known as the period.

It can be implemented by calling an initialing routine with   P   as its argument,   I(P),   which should then return a routine that when called with individual, successive members of a stream of numbers, computes the mean of (up to), the last   P   of them, lets call this   SMA().

The word   stateful   in the task description refers to the need for   SMA()   to remember certain information between calls to it:

   The period,   P
   An ordered container of at least the last   P   numbers from each of its individual calls.

Stateful   also means that successive calls to   I(),   the initializer,   should return separate routines that do   not   share saved state so they could be used on two independent streams of data.

Pseudo-code for an implementation of   SMA   is:

function SMA(number: N):
    stateful integer: P
    stateful list:    stream
    number:           average

    stream.append_last(N)
    if stream.length() > P:
        # Only average the last P elements of the stream
        stream.delete_first()
    if stream.length() == 0:
        average = 0
    else:    
        average = sum( stream.values() ) / stream.length()
    return average

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",Go,"package main
 
import ""fmt""
 
func sma(period int) func(float64) float64 {
    var i int
    var sum float64
    var storage = make([]float64, 0, period)
 
    return func(input float64) (avrg float64) {
        if len(storage) < period {
            sum += input
            storage = append(storage, input)
        }
 
	sum += input - storage[i]
        storage[i], i = input, (i+1)%period
	avrg = sum / float64(len(storage))
 
	return
    }
}
 
func main() {
    sma3 := sma(3)
    sma5 := sma(5)
    fmt.Println(""x       sma3   sma5"")
    for _, x := range []float64{1, 2, 3, 4, 5, 5, 4, 3, 2, 1} {
        fmt.Printf(""%5.3f  %5.3f  %5.3f\n"", x, sma3(x), sma5(x))
    }
}",675,31,"package main

import (
	""testing""
)

func TestSMA(t *testing.T) {
	tests := []struct {
		period   int
		inputs   []float64
		expected []float64
	}{
		{
			period:   3,
			inputs:   []float64{1, 2, 3, 4, 5},
			expected: []float64{1.0, 1.5, 2.0, 3.0, 4.0},
		},
		{
			period:   5,
			inputs:   []float64{1, 2, 3, 4, 5, 5, 4, 3, 2, 1},
			expected: []float64{1.0, 1.5, 2.0, 2.5, 3.0, 3.8, 4.2, 4.2, 3.8, 3.0},
		},
		{
			period:   1,
			inputs:   []float64{10, 20, 30},
			expected: []float64{10.0, 20.0, 30.0},
		},
		{
			period:   2,
			inputs:   []float64{5, 10, 15},
			expected: []float64{5.0, 7.5, 12.5},
		},
		{
			period:   4,
			inputs:   []float64{1, 2, 3, 4, 5, 6},
			expected: []float64{1.0, 1.5, 2.0, 2.5, 3.5, 4.5},
		},
	}

	for _, test := range tests {
		smaFunc := sma(test.period)
		for i, input := range test.inputs {
			result := smaFunc(input)
			if result != test.expected[i] {
				t.Errorf(""For period %d, input %v, expected %v, but got %v"", test.period, test.inputs, test.expected, result)
			}
		}
	}
}

func TestSMASeparateInstances(t *testing.T) {
	sma3 := sma(3)
	sma5 := sma(5)

	inputs := []float64{1, 2, 3, 4, 5}
	expectedSMA3 := []float64{1.0, 1.5, 2.0, 3.0, 4.0}
	expectedSMA5 := []float64{1.0, 1.5, 2.0, 2.5, 3.0}

	for i, input := range inputs {
		resultSMA3 := sma3(input)
		resultSMA5 := sma5(input)

		if resultSMA3 != expectedSMA3[i] {
			t.Errorf(""SMA3: For input %v, expected %v, but got %v"", inputs, expectedSMA3, resultSMA3)
		}

		if resultSMA5 != expectedSMA5[i] {
			t.Errorf(""SMA5: For input %v, expected %v, but got %v"", inputs, expectedSMA5, resultSMA5)
		}
	}
}
",./data/generated/docs_golang/averages_simple_moving_average/gpt_4o_2024_08_06_averages_simple_moving_average_test.go,CompileStatus.OK,0.0,68.8,,0.07,0.6,0.114,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: sma', 'Severity': '', 'SourceLines': ['\t\tsmaFunc := sma(test.period)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_averages_simple_moving_average_test.go', 'Offset': 0, 'Line': 41, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: sma', 'Severity': '', 'SourceLines': ['\tsma3 := sma(3)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_averages_simple_moving_average_test.go', 'Offset': 0, 'Line': 52, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: sma', 'Severity': '', 'SourceLines': ['\tsma5 := sma(5)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_averages_simple_moving_average_test.go', 'Offset': 0, 'Line': 53, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Barnsley fern,"
A Barnsley fern is a fractal named after British mathematician Michael Barnsley and can be created using an iterated function system (IFS).



Task

Create this fractal fern, using the following transformations:

 ƒ1   (chosen 1% of the time)
        xn + 1 = 0
        yn + 1 = 0.16 yn

 ƒ2   (chosen 85% of the time)
        xn + 1 = 0.85 xn + 0.04 yn
        yn + 1 = −0.04 xn + 0.85 yn + 1.6

 ƒ3   (chosen 7% of the time)
        xn + 1 = 0.2 xn − 0.26 yn
        yn + 1 = 0.23 xn + 0.22 yn + 1.6

 ƒ4   (chosen 7% of the time)
        xn + 1 = −0.15 xn + 0.28 yn
        yn + 1 = 0.26 xn + 0.24 yn + 0.44.

Starting position: x = 0, y = 0



",Go,"package main
 
import (
    ""image""
    ""image/color""
    ""image/draw""
    ""image/png""
    ""log""
    ""math/rand""
    ""os""
)
 
// values from WP
const (
    xMin = -2.1820
    xMax = 2.6558
    yMin = 0.
    yMax = 9.9983
)
 
// parameters
var (
    width = 200
    n     = int(1e6)
    c     = color.RGBA{34, 139, 34, 255} // forest green
)
 
func main() {
    dx := xMax - xMin
    dy := yMax - yMin
    fw := float64(width)
    fh := fw * dy / dx
    height := int(fh)
    r := image.Rect(0, 0, width, height)
    img := image.NewRGBA(r)
    draw.Draw(img, r, &image.Uniform{color.White}, image.ZP, draw.Src)
    var x, y float64
    plot := func() {
        // transform computed float x, y to integer image coordinates
        ix := int(fw * (x - xMin) / dx)
        iy := int(fh * (yMax - y) / dy)
        img.SetRGBA(ix, iy, c)
    }
    plot()
    for i := 0; i < n; i++ {
        switch s := rand.Intn(100); {
        case s < 85:
            x, y =
                .85*x+.04*y,
                -.04*x+.85*y+1.6
        case s < 85+7:
            x, y =
                .2*x-.26*y,
                .23*x+.22*y+1.6
        case s < 85+7+7:
            x, y =
                -.15*x+.28*y,
                .26*x+.24*y+.44
        default:
            x, y = 0, .16*y
        }
        plot()
    }
    // write img to png file
    f, err := os.Create(""bf.png"")
    if err != nil {
        log.Fatal(err)
    }
    if err := png.Encode(f, img); err != nil {
        log.Fatal(err)
    }
}",1493,72,"package main

import (
    ""image""
    ""image/color""
    ""image/png""
    ""math/rand""
    ""os""
    ""testing""
)

// Test constants
const (
    testWidth = 200
    testN     = 1000 // Reduced for faster testing
)

// TestBarnsleyFern tests the generation of the Barnsley fern image
func TestBarnsleyFern(t *testing.T) {
    dx := xMax - xMin
    dy := yMax - yMin
    fw := float64(testWidth)
    fh := fw * dy / dx
    height := int(fh)
    r := image.Rect(0, 0, testWidth, height)
    img := image.NewRGBA(r)
    var x, y float64

    plot := func() {
        ix := int(fw * (x - xMin) / dx)
        iy := int(fh * (yMax - y) / dy)
        img.SetRGBA(ix, iy, c)
    }

    plot()
    for i := 0; i < testN; i++ {
        switch s := rand.Intn(100); {
        case s < 85:
            x, y = .85*x+.04*y, -.04*x+.85*y+1.6
        case s < 85+7:
            x, y = .2*x-.26*y, .23*x+.22*y+1.6
        case s < 85+7+7:
            x, y = -.15*x+.28*y, .26*x+.24*y+.44
        default:
            x, y = 0, .16*y
        }
        plot()
    }

    // Test if the image is created successfully
    f, err := os.Create(""test_bf.png"")
    if err != nil {
        t.Fatalf(""Failed to create image file: %v"", err)
    }
    defer f.Close()

    if err := png.Encode(f, img); err != nil {
        t.Fatalf(""Failed to encode image to PNG: %v"", err)
    }

    // Check if the file exists
    if _, err := os.Stat(""test_bf.png""); os.IsNotExist(err) {
        t.Fatalf(""Image file was not created"")
    }
}

// TestTransformations tests the transformations used in the Barnsley fern
func TestTransformations(t *testing.T) {
    var x, y float64

    // Test transformation ƒ1
    x, y = 0, 0.16*y
    if x != 0 || y != 0 {
        t.Errorf(""Transformation ƒ1 failed: got (%v, %v), want (0, 0)"", x, y)
    }

    // Test transformation ƒ2
    x, y = 1, 1
    x, y = .85*x+.04*y, -.04*x+.85*y+1.6
    if x != 0.89 || y != 2.41 {
        t.Errorf(""Transformation ƒ2 failed: got (%v, %v), want (0.89, 2.41)"", x, y)
    }

    // Test transformation ƒ3
    x, y = 1, 1
    x, y = .2*x-.26*y, .23*x+.22*y+1.6
    if x != -0.06 || y != 2.05 {
        t.Errorf(""Transformation ƒ3 failed: got (%v, %v), want (-0.06, 2.05)"", x, y)
    }

    // Test transformation ƒ4
    x, y = 1, 1
    x, y = -.15*x+.28*y, .26*x+.24*y+.44
    if x != 0.13 || y != 0.94 {
        t.Errorf(""Transformation ƒ4 failed: got (%v, %v), want (0.13, 0.94)"", x, y)
    }
}
",./data/generated/docs_golang/barnsley_fern/gpt_4o_2024_08_06_barnsley_fern_test.go,CompileStatus.SYNTAX_ERROR,,,,0.13,0.88,,6.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: xMax', 'Severity': '', 'SourceLines': ['    dx := xMax - xMin'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_barnsley_fern_test.go', 'Offset': 0, 'Line': 20, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: yMax', 'Severity': '', 'SourceLines': ['    dy := yMax - yMin'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_barnsley_fern_test.go', 'Offset': 0, 'Line': 21, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: xMin', 'Severity': '', 'SourceLines': ['        ix := int(fw * (x - xMin) / dx)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_barnsley_fern_test.go', 'Offset': 0, 'Line': 30, 'Column': 29}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: yMax', 'Severity': '', 'SourceLines': ['        iy := int(fh * (yMax - y) / dy)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_barnsley_fern_test.go', 'Offset': 0, 'Line': 31, 'Column': 25}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: c', 'Severity': '', 'SourceLines': ['        img.SetRGBA(ix, iy, c)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_barnsley_fern_test.go', 'Offset': 0, 'Line': 32, 'Column': 29}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""image/color"" imported and not used', 'Severity': '', 'SourceLines': ['    ""image/color""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_barnsley_fern_test.go', 'Offset': 0, 'Line': 5, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_barnsley_fern_test.go', 'line': 5, 'column': 5, 'message': '""image/color"" imported and not used'}]"
Base64 decode data,"See Base64 encode data.

Now write a program that takes the output of the Base64 encode data task as input and regenerate the original file.

When working on the VBA implementation I found several 'solutions' on the net, including one from the software maker himself, that showed output with incorrect padding. Obviously with incorrect padding in the output you can not decode correctly to the original file again.
",Go,"package main
 
import (
    ""encoding/base64""
    ""fmt""
)
 
func main() {
    msg := ""Rosetta Code Base64 decode data task""
    fmt.Println(""Original :"", msg)
    encoded := base64.StdEncoding.EncodeToString([]byte(msg))
    fmt.Println(""\nEncoded  :"", encoded)
    decoded, err := base64.StdEncoding.DecodeString(encoded)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(""\nDecoded  :"", string(decoded))
}",439,19,"package main

import (
	""encoding/base64""
	""testing""
)

func TestBase64EncodingDecoding(t *testing.T) {
	originalMessage := ""Rosetta Code Base64 decode data task""
	encodedMessage := base64.StdEncoding.EncodeToString([]byte(originalMessage))

	// Test if encoding is correct
	expectedEncodedMessage := ""Um9zZXR0YSBDb2RlIEJhc2U2NCBkZWNvZGUgZGF0YSB0YXNr""
	if encodedMessage != expectedEncodedMessage {
		t.Errorf(""Encoding failed. Expected: %s, Got: %s"", expectedEncodedMessage, encodedMessage)
	}

	// Test if decoding is correct
	decodedMessage, err := base64.StdEncoding.DecodeString(encodedMessage)
	if err != nil {
		t.Errorf(""Decoding failed with error: %v"", err)
	}

	if string(decodedMessage) != originalMessage {
		t.Errorf(""Decoding failed. Expected: %s, Got: %s"", originalMessage, string(decodedMessage))
	}
}

func TestBase64DecodingWithIncorrectPadding(t *testing.T) {
	// Test decoding with incorrect padding
	incorrectEncodedMessage := ""Um9zZXR0YSBDb2RlIEJhc2U2NCBkZWNvZGUgZGF0YSB0YXNr===""
	_, err := base64.StdEncoding.DecodeString(incorrectEncodedMessage)
	if err == nil {
		t.Error(""Expected error for incorrect padding, but got none"")
	}
}

func TestBase64DecodingWithInvalidCharacters(t *testing.T) {
	// Test decoding with invalid characters
	invalidEncodedMessage := ""Um9zZXR0YSBDb2RlIEJhc2U2NCBkZWNvZGUgZGF0YSB0YXNr$""
	_, err := base64.StdEncoding.DecodeString(invalidEncodedMessage)
	if err == nil {
		t.Error(""Expected error for invalid characters, but got none"")
	}
}
",./data/generated/docs_golang/base64_decode_data/gpt_4o_2024_08_06_base64_decode_data_test.go,CompileStatus.OK,0.0,0.0,,0.22,2.5,0.113,0.0,[],False,False,100.0,False,[]
Benford's law,"

 This page uses content from Wikipedia. The original article was at Benford's_law. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Benford's law, also called the first-digit law, refers to the frequency distribution of digits in many (but not all) real-life sources of data.

In this distribution, the number 1 occurs as the first digit about 30% of the time, while larger numbers occur in that position less frequently: 9 as the first digit less than 5% of the time. This distribution of first digits is the same as the widths of gridlines on a logarithmic scale.

Benford's law also concerns the expected distribution for digits beyond the first, which approach a uniform distribution.

This result has been found to apply to a wide variety of data sets, including electricity bills, street addresses, stock prices, population numbers, death rates, lengths of rivers, physical and mathematical constants, and processes described by power laws (which are very common in nature). It tends to be most accurate when values are distributed across multiple orders of magnitude.

A set of numbers is said to satisfy Benford's law if the leading digit 



d


{\displaystyle d}

  (



d
∈
{
1
,
…
,
9
}


{\displaystyle d\in \{1,\ldots ,9\}}

) occurs with probability

 



P
(
d
)
=

log

10


⁡
(
d
+
1
)
−

log

10


⁡
(
d
)
=

log

10


⁡

(
1
+


1
d


)



{\displaystyle P(d)=\log _{10}(d+1)-\log _{10}(d)=\log _{10}\left(1+{\frac {1}{d}}\right)}


For this task, write (a) routine(s) to calculate the distribution of first significant (non-zero) digits in a collection of numbers, then display the actual vs. expected distribution in the way most convenient for your language (table / graph / histogram / whatever).

Use the first 1000 numbers from the Fibonacci sequence as your data set. No need to show how the Fibonacci numbers are obtained.

You can generate them or load them from a file; whichever is easiest.

Display your actual vs expected distribution.


For extra credit: Show the distribution for one other set of numbers from a page on Wikipedia. State which Wikipedia page it can be obtained from and what the set enumerates. Again, no need to display the actual list of numbers or the code to load them.



See also:
 numberphile.com.
 A starting page on Wolfram Mathworld is Benfords Law .

",Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
func Fib1000() []float64 {
    a, b, r := 0., 1., [1000]float64{}
    for i := range r {
        r[i], a, b = b, b, b+a
    }
    return r[:]
}
 
func main() {
    show(Fib1000(), ""First 1000 Fibonacci numbers"")
}
 
func show(c []float64, title string) {
    var f [9]int
    for _, v := range c {
        f[fmt.Sprintf(""%g"", v)[0]-'1']++
    }
    fmt.Println(title)
    fmt.Println(""Digit  Observed  Predicted"")
    for i, n := range f {
        fmt.Printf(""  %d  %9.3f  %8.3f\n"", i+1, float64(n)/float64(len(c)),
            math.Log10(1+1/float64(i+1)))
    }
}",614,31,"package main

import (
	""math""
	""testing""
)

// TestFib1000Length checks if the Fib1000 function generates exactly 1000 Fibonacci numbers.
func TestFib1000Length(t *testing.T) {
	fibNumbers := Fib1000()
	if len(fibNumbers) != 1000 {
		t.Errorf(""Expected 1000 Fibonacci numbers, got %d"", len(fibNumbers))
	}
}

// TestFirstDigitDistribution checks if the first digit distribution of the Fibonacci numbers matches the expected distribution according to Benford's Law.
func TestFirstDigitDistribution(t *testing.T) {
	fibNumbers := Fib1000()
	var observed [9]int
	for _, v := range fibNumbers {
		observed[fmt.Sprintf(""%g"", v)[0]-'1']++
	}

	for i, count := range observed {
		observedProbability := float64(count) / float64(len(fibNumbers))
		expectedProbability := math.Log10(1 + 1/float64(i+1))
		if math.Abs(observedProbability-expectedProbability) > 0.05 { // Allowing a small tolerance
			t.Errorf(""For digit %d, expected probability %.3f, but got %.3f"", i+1, expectedProbability, observedProbability)
		}
	}
}

// TestShowFunctionOutput checks if the show function outputs the expected format.
func TestShowFunctionOutput(t *testing.T) {
	fibNumbers := Fib1000()
	// Redirect output to a buffer
	output := captureOutput(func() {
		show(fibNumbers, ""Test Title"")
	})

	// Check if the output contains the expected title
	if !contains(output, ""Test Title"") {
		t.Errorf(""Expected output to contain 'Test Title', but it did not."")
	}

	// Check if the output contains the expected headers
	if !contains(output, ""Digit  Observed  Predicted"") {
		t.Errorf(""Expected output to contain 'Digit  Observed  Predicted', but it did not."")
	}
}

// Helper function to capture output
func captureOutput(f func()) string {
	// Implementation to capture standard output
	// ...
	return """"
}

// Helper function to check if a string contains a substring
func contains(s, substr string) bool {
	return strings.Contains(s, substr)
}
",./data/generated/docs_golang/benford_s_law/gpt_4o_2024_08_06_benford_s_law_test.go,CompileStatus.SYNTAX_ERROR,,,,0.18,0.83,,6.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: Fib1000', 'Severity': '', 'SourceLines': ['\tfibNumbers := Fib1000()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_benford_s_law_test.go', 'Offset': 0, 'Line': 10, 'Column': 16}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Fib1000', 'Severity': '', 'SourceLines': ['\tfibNumbers := Fib1000()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_benford_s_law_test.go', 'Offset': 0, 'Line': 18, 'Column': 16}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fmt', 'Severity': '', 'SourceLines': ['\t\tobserved[fmt.Sprintf(""%g"", v)[0]-\'1\']++'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_benford_s_law_test.go', 'Offset': 0, 'Line': 21, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Fib1000', 'Severity': '', 'SourceLines': ['\tfibNumbers := Fib1000()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_benford_s_law_test.go', 'Offset': 0, 'Line': 35, 'Column': 16}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: show', 'Severity': '', 'SourceLines': ['\t\tshow(fibNumbers, ""Test Title"")'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_benford_s_law_test.go', 'Offset': 0, 'Line': 38, 'Column': 3}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: strings', 'Severity': '', 'SourceLines': ['\treturn strings.Contains(s, substr)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_benford_s_law_test.go', 'Offset': 0, 'Line': 61, 'Column': 9}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_benford_s_law_test.go', 'line': 21, 'column': 12, 'message': 'undefined: fmt'}]"
Best shuffle,"Task

Shuffle the characters of a string in such a way that as many of the character values are in a different position as possible.

A shuffle that produces a randomized result among the best choices is to be preferred. A deterministic approach that produces the same sequence every time is acceptable as an alternative.

Display the result as follows:

original string, shuffled string, (score) 

The score gives the number of positions whose character value did not change.



Example

tree, eetr, (0)



Test cases

abracadabra
seesaw
elk
grrrrrr
up
a



Related tasks
   Anagrams/Deranged anagrams
   Permutations/Derangements



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
var ts = []string{""abracadabra"", ""seesaw"", ""elk"", ""grrrrrr"", ""up"", ""a""}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    for _, s := range ts {
        // create shuffled byte array of original string
        t := make([]byte, len(s))
        for i, r := range rand.Perm(len(s)) {
            t[i] = s[r]
        }
        // algorithm of Icon solution
        for i := range t {
            for j := range t {
                if i != j && t[i] != s[j] && t[j] != s[i] {
                    t[i], t[j] = t[j], t[i]
                    break
                }
            }
        }
        // count unchanged and output
        var count int
        for i, ic := range t {
            if ic == s[i] {
                count++
            }
        }
        fmt.Printf(""%s -> %s (%d)\n"", s, string(t), count)
    }
}",889,37,"package main

import (
    ""testing""
    ""strings""
)

// Helper function to count unchanged positions
func countUnchanged(original, shuffled string) int {
    count := 0
    for i := range original {
        if original[i] == shuffled[i] {
            count++
        }
    }
    return count
}

// Test function for the shuffle logic
func TestShuffle(t *testing.T) {
    testCases := []struct {
        input string
    }{
        {""abracadabra""},
        {""seesaw""},
        {""elk""},
        {""grrrrrr""},
        {""up""},
        {""a""},
    }

    for _, tc := range testCases {
        shuffled := shuffleString(tc.input)
        unchangedCount := countUnchanged(tc.input, shuffled)

        if unchangedCount != 0 && len(tc.input) > 1 {
            t.Errorf(""Expected 0 unchanged positions for input %s, but got %d"", tc.input, unchangedCount)
        }

        if strings.Contains(tc.input, ""r"") && tc.input == ""grrrrrr"" {
            if unchangedCount != len(tc.input) {
                t.Errorf(""Expected all positions unchanged for input %s, but got %d"", tc.input, unchangedCount)
            }
        }
    }
}

// Function to shuffle the string
func shuffleString(s string) string {
    t := make([]byte, len(s))
    for i, r := range rand.Perm(len(s)) {
        t[i] = s[r]
    }
    for i := range t {
        for j := range t {
            if i != j && t[i] != s[j] && t[j] != s[i] {
                t[i], t[j] = t[j], t[i]
                break
            }
        }
    }
    return string(t)
}
",./data/generated/docs_golang/best_shuffle/gpt_4o_2024_08_06_best_shuffle_test.go,CompileStatus.SYNTAX_ERROR,,,,0.1,0.3,,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: rand', 'Severity': '', 'SourceLines': ['    for i, r := range rand.Perm(len(s)) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_best_shuffle_test.go', 'Offset': 0, 'Line': 51, 'Column': 23}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_best_shuffle_test.go', 'line': 51, 'column': 23, 'message': 'undefined: rand'}]"
Binary strings,"Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.

This task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them.

If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.

In particular the functions you need to create are:

 String creation and destruction (when needed and if there's no garbage collection or similar mechanism)
 String assignment
 String comparison
 String cloning and copying
 Check if a string is empty
 Append a byte to a string
 Extract a substring from a string
 Replace every occurrence of a byte (or a string) in a string with another string
 Join strings


Possible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.



",Go,"package main
 
import (
    ""bytes""
    ""fmt""
)
 
// Strings in Go allow arbitrary bytes.  They are implemented basically as
// immutable byte slices and syntactic sugar.  This program shows functions
// required by the task on byte slices, thus it mostly highlights what
// happens behind the syntactic sugar.  The program does not attempt to
// reproduce the immutability property of strings, as that does not seem
// to be the intent of the task.
 
func main() {
    // Task point: String creation and destruction.
    // Strings are most often constructed from literals as in s := ""binary""
    // With byte slices,
    b := []byte{'b', 'i', 'n', 'a', 'r', 'y'}
    fmt.Println(b) // output shows numeric form of bytes.
    // Go is garbage collected.  There are no destruction operations.
 
    // Task point: String assignment.
    // t = s assigns strings.  Since strings are immutable, it is irrelevant
    // whether the string is copied or not.
    // With byte slices, the same works,
    var c []byte
    c = b
    fmt.Println(c)
 
    // Task point: String comparison.
    // operators <, <=, ==, >=, and > work directly on strings comparing them
    // by lexicographic order.
    // With byte slices, there are standard library functions, bytes.Equal
    // and bytes.Compare.
    fmt.Println(bytes.Equal(b, c)) // prints true
 
    // Task point: String cloning and copying.
    // The immutable property of Go strings makes cloning and copying
    // meaningless for strings.
    // With byte slices though, it is relevant.  The assignment c = b shown
    // above does a reference copy, leaving both c and b based on the same
    // underlying data.  To clone or copy the underlying data,
    d := make([]byte, len(b)) // allocate new space
    copy(d, b)                // copy the data
    // The data can be manipulated independently now:
    d[1] = 'a'
    d[4] = 'n'
    fmt.Println(string(b)) // convert to string for readable output
    fmt.Println(string(d))
 
    // Task point: Check if a string is empty.
    // Most typical for strings is s == """", but len(s) == 0 works too.
    // For byte slices, """" does not work, len(b) == 0 is correct.
    fmt.Println(len(b) == 0)
 
    // Task point: Append a byte to a string.
    // The language does not provide a way to do this directly with strings.
    // Instead, the byte must be converted to a one-byte string first, as in,
    // s += string('z')
    // For byte slices, the language provides the append function,
    z := append(b, 'z')
    fmt.Printf(""%s\n"", z) // another way to get readable output
 
    // Task point: Extract a substring from a string.
    // Slicing syntax is the for both strings and slices.
    sub := b[1:3]
    fmt.Println(string(sub))
 
    // Task point: Replace every occurrence of a byte (or a string)
    // in a string with another string.
    // Go supports this with similar library functions for strings and
    // byte slices.  Strings:  t = strings.Replace(s, ""n"", ""m"", -1).
    // The byte slice equivalent returns a modified copy, leaving the
    // original byte slice untouched,
    f := bytes.Replace(d, []byte{'n'}, []byte{'m'}, -1)
    fmt.Printf(""%s -> %s\n"", d, f)
 
    // Task point: Join strings.
    // Using slicing syntax again, with strings,
    // rem := s[:1] + s[3:] leaves rem == ""bary"".
    // Only the concatenation of the parts is different with byte slices,
    rem := append(append([]byte{}, b[:1]...), b[3:]...)
    fmt.Println(string(rem))
}",3485,85,"package main

import (
	""bytes""
	""testing""
)

func TestStringCreationAndDestruction(t *testing.T) {
	b := []byte{'b', 'i', 'n', 'a', 'r', 'y'}
	expected := []byte{'b', 'i', 'n', 'a', 'r', 'y'}
	if !bytes.Equal(b, expected) {
		t.Errorf(""Expected %v, got %v"", expected, b)
	}
}

func TestStringAssignment(t *testing.T) {
	b := []byte{'b', 'i', 'n', 'a', 'r', 'y'}
	var c []byte
	c = b
	if !bytes.Equal(c, b) {
		t.Errorf(""Expected %v, got %v"", b, c)
	}
}

func TestStringComparison(t *testing.T) {
	b := []byte{'b', 'i', 'n', 'a', 'r', 'y'}
	c := []byte{'b', 'i', 'n', 'a', 'r', 'y'}
	if !bytes.Equal(b, c) {
		t.Errorf(""Expected %v to be equal to %v"", b, c)
	}
}

func TestStringCloningAndCopying(t *testing.T) {
	b := []byte{'b', 'i', 'n', 'a', 'r', 'y'}
	d := make([]byte, len(b))
	copy(d, b)
	d[1] = 'a'
	d[4] = 'n'
	if bytes.Equal(b, d) {
		t.Errorf(""Expected %v to be different from %v"", b, d)
	}
}

func TestCheckIfStringIsEmpty(t *testing.T) {
	b := []byte{}
	if len(b) != 0 {
		t.Errorf(""Expected string to be empty"")
	}
}

func TestAppendByteToString(t *testing.T) {
	b := []byte{'b', 'i', 'n', 'a', 'r', 'y'}
	z := append(b, 'z')
	expected := []byte{'b', 'i', 'n', 'a', 'r', 'y', 'z'}
	if !bytes.Equal(z, expected) {
		t.Errorf(""Expected %v, got %v"", expected, z)
	}
}

func TestExtractSubstringFromString(t *testing.T) {
	b := []byte{'b', 'i', 'n', 'a', 'r', 'y'}
	sub := b[1:3]
	expected := []byte{'i', 'n'}
	if !bytes.Equal(sub, expected) {
		t.Errorf(""Expected %v, got %v"", expected, sub)
	}
}

func TestReplaceByteInString(t *testing.T) {
	d := []byte{'b', 'a', 'n', 'a', 'r', 'y'}
	f := bytes.Replace(d, []byte{'n'}, []byte{'m'}, -1)
	expected := []byte{'b', 'a', 'm', 'a', 'r', 'y'}
	if !bytes.Equal(f, expected) {
		t.Errorf(""Expected %v, got %v"", expected, f)
	}
}

func TestJoinStrings(t *testing.T) {
	b := []byte{'b', 'i', 'n', 'a', 'r', 'y'}
	rem := append(append([]byte{}, b[:1]...), b[3:]...)
	expected := []byte{'b', 'a', 'r', 'y'}
	if !bytes.Equal(rem, expected) {
		t.Errorf(""Expected %v, got %v"", expected, rem)
	}
}
",./data/generated/docs_golang/binary_strings/gpt_4o_2024_08_06_binary_strings_test.go,CompileStatus.OK,0.0,0.0,,0.31,17.0,0.116,1.0,"[{'FromLinter': 'gosimple', 'Text': 'S1021: should merge variable declaration with assignment on next line', 'Severity': '', 'SourceLines': ['\tvar c []byte'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_binary_strings_test.go', 'Offset': 364, 'Line': 18, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Bitcoin/address validation,"Bitcoin/address validation

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Write a program that takes a bitcoin address as argument,
and checks whether or not this address is valid.

A bitcoin address uses a base58 encoding, which uses an alphabet of the characters 0 .. 9, A ..Z, a .. z, but without the four characters:

   0   zero
   O   uppercase oh
   I   uppercase eye
   l   lowercase ell


With this encoding, a bitcoin address encodes 25 bytes:

 the first byte is the version number, which will be zero for this task ;
 the next twenty bytes are a RIPEMD-160 digest, but you don't have to know that for this task: you can consider them a pure arbitrary data ;
 the last four bytes are a checksum check. They are the first four bytes of a double SHA-256 digest of the previous 21 bytes.


To check the bitcoin address, you must read the first twenty-one bytes, compute the checksum, and check that it corresponds to the last four bytes.

The program can either return a boolean value or throw an exception when not valid.

You can use a digest library for SHA-256.



Example of a bitcoin address



1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i



It doesn't belong to anyone and is part of the test suite of the bitcoin software.

You can change a few characters in this string and check that it'll fail the test.



",Go,"package main
 
import (
    ""bytes""
    ""crypto/sha256""
    ""errors""
    ""os""
)
 
// With at least one other bitcoin RC task, this source is styled more like
// a package to show how functions of the two tasks might be combined into
// a single package.  It turns out there's not really that much shared code,
// just the A25 type and doubleSHA256 method, but it's enough to suggest how
// the code might be organized.  Types, methods, and functions are capitalized
// where they might be exported from a package.
 
// A25 is a type for a 25 byte (not base58 encoded) bitcoin address.
type A25 [25]byte
 
func (a *A25) Version() byte {
    return a[0]
}
 
func (a *A25) EmbeddedChecksum() (c [4]byte) {
    copy(c[:], a[21:])
    return
}
 
// DoubleSHA256 computes a double sha256 hash of the first 21 bytes of the
// address.  This is the one function shared with the other bitcoin RC task.
// Returned is the full 32 byte sha256 hash.  (The bitcoin checksum will be
// the first four bytes of the slice.)
func (a *A25) doubleSHA256() []byte {
    h := sha256.New()
    h.Write(a[:21])
    d := h.Sum([]byte{})
    h = sha256.New()
    h.Write(d)
    return h.Sum(d[:0])
}
 
// ComputeChecksum returns a four byte checksum computed from the first 21
// bytes of the address.  The embedded checksum is not updated.
func (a *A25) ComputeChecksum() (c [4]byte) {
    copy(c[:], a.doubleSHA256())
    return
}/* {{header|Go}} */ 
 
// Tmpl and Set58 are adapted from the C solution.
// Go has big integers but this techinique seems better.
var tmpl = []byte(""123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"")
 
// Set58 takes a base58 encoded address and decodes it into the receiver.
// Errors are returned if the argument is not valid base58 or if the decoded
// value does not fit in the 25 byte address.  The address is not otherwise
// checked for validity.
func (a *A25) Set58(s []byte) error {
    for _, s1 := range s {
        c := bytes.IndexByte(tmpl, s1)
        if c < 0 {
            return errors.New(""bad char"")
        }
        for j := 24; j >= 0; j-- {
            c += 58 * int(a[j])
            a[j] = byte(c % 256)
            c /= 256
        }
        if c > 0 {
            return errors.New(""too long"")
        }
    }
    return nil
}
 
// ValidA58 validates a base58 encoded bitcoin address.  An address is valid
// if it can be decoded into a 25 byte address, the version number is 0,
// and the checksum validates.  Return value ok will be true for valid
// addresses.  If ok is false, the address is invalid and the error value
// may indicate why.
func ValidA58(a58 []byte) (ok bool, err error) {
    var a A25
    if err := a.Set58(a58); err != nil {
        return false, err
    }
    if a.Version() != 0 {
        return false, errors.New(""not version 0"")
    }
    return a.EmbeddedChecksum() == a.ComputeChecksum(), nil
}
 
// Program returns exit code 0 with valid address and produces no output.
// Otherwise exit code is 1 and a message is written to stderr.
func main() {
    if len(os.Args) != 2 {
        errorExit(""Usage: valid <base58 address>"")
    }
    switch ok, err := ValidA58([]byte(os.Args[1])); {
    case ok:
    case err == nil:
        errorExit(""Invalid"")
    default:
        errorExit(err.Error())
    }
}
 
func errorExit(m string) {
    os.Stderr.WriteString(m + ""\n"")
    os.Exit(1)
}",3358,109,"package main

import (
	""testing""
)

func TestValidA58(t *testing.T) {
	tests := []struct {
		address string
		valid   bool
	}{
		{""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i"", true},  // Valid address
		{""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62j"", false}, // Invalid checksum
		{""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62"", false},  // Too short
		{""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62ii"", false}, // Too long
		{""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62O"", false},  // Invalid character 'O'
		{"""", false},                                   // Empty string
	}

	for _, test := range tests {
		ok, err := ValidA58([]byte(test.address))
		if ok != test.valid {
			t.Errorf(""ValidA58(%q) = %v, want %v, error: %v"", test.address, ok, test.valid, err)
		}
	}
}

func TestSet58(t *testing.T) {
	var a A25
	err := a.Set58([]byte(""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i""))
	if err != nil {
		t.Errorf(""Set58 failed with error: %v"", err)
	}

	err = a.Set58([]byte(""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62O"")) // Invalid character 'O'
	if err == nil {
		t.Error(""Set58 should have failed with invalid character"")
	}

	err = a.Set58([]byte(""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62ii"")) // Too long
	if err == nil {
		t.Error(""Set58 should have failed with too long address"")
	}
}

func TestComputeChecksum(t *testing.T) {
	var a A25
	err := a.Set58([]byte(""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i""))
	if err != nil {
		t.Fatalf(""Set58 failed with error: %v"", err)
	}

	expectedChecksum := a.EmbeddedChecksum()
	computedChecksum := a.ComputeChecksum()

	if expectedChecksum != computedChecksum {
		t.Errorf(""ComputeChecksum() = %x, want %x"", computedChecksum, expectedChecksum)
	}
}
",./data/generated/docs_golang/bitcoin_address_validation/gpt_4o_2024_08_06_bitcoin_address_validation_test.go,CompileStatus.OK,0.0,80.0,,0.17,0.35,0.117,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: ValidA58', 'Severity': '', 'SourceLines': ['\t\tok, err := ValidA58([]byte(test.address))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_bitcoin_address_validation_test.go', 'Offset': 0, 'Line': 21, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: A25', 'Severity': '', 'SourceLines': ['\tvar a A25'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_bitcoin_address_validation_test.go', 'Offset': 0, 'Line': 29, 'Column': 8}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: A25', 'Severity': '', 'SourceLines': ['\tvar a A25'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_bitcoin_address_validation_test.go', 'Offset': 0, 'Line': 47, 'Column': 8}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Box the compass,"There be many a land lubber that knows naught of the pirate ways and gives direction by degree!
They know not how to box the compass!



Task description

 Create a function that takes a heading in degrees and returns the correct 32-point compass heading.
 Use the function to print and display a table of Index, Compass point, and Degree; rather like the corresponding columns from, the first table of the wikipedia article, but use only the following 33 headings as input:
[0.0, 16.87, 16.88, 33.75, 50.62, 50.63, 67.5, 84.37, 84.38, 101.25, 118.12, 118.13, 135.0, 151.87, 151.88, 168.75, 185.62, 185.63, 202.5, 219.37, 219.38, 236.25, 253.12, 253.13, 270.0, 286.87, 286.88, 303.75, 320.62, 320.63, 337.5, 354.37, 354.38]. (They should give the same order of points but are spread throughout the ranges of acceptance).


Notes;
 The headings and indices can be calculated from this pseudocode:
for i in 0..32 inclusive:
    heading = i * 11.25
    case i %3:
      if 1: heading += 5.62; break
      if 2: heading -= 5.62; break
    end
    index = ( i mod 32) + 1
 The column of indices can be thought of as an enumeration of the thirty two cardinal points (see talk page)..

",Go,"package main
 
import ""fmt""
 
// function required by task
func degrees2compasspoint(h float32) string {
    return compassPoint[cpx(h)]
}
 
// cpx returns integer index from 0 to 31 corresponding to compass point.
// input heading h is in degrees.  Note this index is a zero-based index
// suitable for indexing into the table of printable compass points,
// and is not the same as the index specified to be printed in the output.
func cpx(h float32) int {
    x := int(h/11.25+.5) % 32
    if x < 0 {
        x += 32
    }
    return x
}
 
// printable compass points
var compassPoint = []string{
    ""North"",
    ""North by east"",
    ""North-northeast"",
    ""Northeast by north"",
    ""Northeast"",
    ""Northeast by east"",
    ""East-northeast"",
    ""East by north"",
    ""East"",
    ""East by south"",
    ""East-southeast"",
    ""Southeast by east"",
    ""Southeast"",
    ""Southeast by south"",
    ""South-southeast"",
    ""South by east"",
    ""South"",
    ""South by west"",
    ""South-southwest"",
    ""Southwest by south"",
    ""Southwest"",
    ""Southwest by west"",
    ""West-southwest"",
    ""West by south"",
    ""West"",
    ""West by north"",
    ""West-northwest"",
    ""Northwest by west"",
    ""Northwest"",
    ""Northwest by north"",
    ""North-northwest"",
    ""North by west"",
}
 
func main() {
    fmt.Println(""Index  Compass point         Degree"")
    for i, h := range []float32{0.0, 16.87, 16.88, 33.75, 50.62, 50.63, 67.5,
        84.37, 84.38, 101.25, 118.12, 118.13, 135.0, 151.87, 151.88, 168.75,
        185.62, 185.63, 202.5, 219.37, 219.38, 236.25, 253.12, 253.13, 270.0,
        286.87, 286.88, 303.75, 320.62, 320.63, 337.5, 354.37, 354.38} {
        index := i%32 + 1 // printable index computed per pseudocode
        fmt.Printf(""%4d   %-19s %7.2f°\n"", index, degrees2compasspoint(h), h)
    }
}",1802,67,"package main

import (
	""testing""
)

func TestDegrees2CompassPoint(t *testing.T) {
	tests := []struct {
		degree  float32
		point   string
	}{
		{0.0, ""North""},
		{16.87, ""North by east""},
		{16.88, ""North-northeast""},
		{33.75, ""Northeast by north""},
		{50.62, ""Northeast""},
		{50.63, ""Northeast by east""},
		{67.5, ""East-northeast""},
		{84.37, ""East by north""},
		{84.38, ""East""},
		{101.25, ""East by south""},
		{118.12, ""East-southeast""},
		{118.13, ""Southeast by east""},
		{135.0, ""Southeast""},
		{151.87, ""Southeast by south""},
		{151.88, ""South-southeast""},
		{168.75, ""South by east""},
		{185.62, ""South""},
		{185.63, ""South by west""},
		{202.5, ""South-southwest""},
		{219.37, ""Southwest by south""},
		{219.38, ""Southwest""},
		{236.25, ""Southwest by west""},
		{253.12, ""West-southwest""},
		{253.13, ""West by south""},
		{270.0, ""West""},
		{286.87, ""West by north""},
		{286.88, ""West-northwest""},
		{303.75, ""Northwest by west""},
		{320.62, ""Northwest""},
		{320.63, ""Northwest by north""},
		{337.5, ""North-northwest""},
		{354.37, ""North by west""},
		{354.38, ""North""},
	}

	for _, test := range tests {
		t.Run("""", func(t *testing.T) {
			if got := degrees2compasspoint(test.degree); got != test.point {
				t.Errorf(""degrees2compasspoint(%v) = %v; want %v"", test.degree, got, test.point)
			}
		})
	}
}
",./data/generated/docs_golang/box_the_compass/gpt_4o_2024_08_06_box_the_compass_test.go,CompileStatus.OK,0.0,44.4,,0.02,0.2,0.12,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: degrees2compasspoint', 'Severity': '', 'SourceLines': ['\t\t\tif got := degrees2compasspoint(test.degree); got != test.point {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_box_the_compass_test.go', 'Offset': 0, 'Line': 49, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Brownian tree,"Brownian tree

You are encouraged to solve this task according to the task description, using any language you may know.



Task

Generate and draw a   Brownian Tree.



A Brownian Tree is generated as a result of an initial seed, followed by the interaction of two processes.

 The initial ""seed"" is placed somewhere within the field. Where is not particularly important; it could be randomized, or it could be a fixed point.
 Particles are injected into the field, and are individually given a (typically random) motion pattern.
 When a particle collides with the seed or tree, its position is fixed, and it's considered to be part of the tree.

Because of the lax rules governing the random nature of the particle's placement and motion, no two resulting trees are really expected to be the same, or even necessarily have the same general shape. 


",Go,"package main
 
import (
    ""fmt""
    ""image""
    ""image/color""
    ""image/png""
    ""math/rand""
    ""os""
)
 
const w = 400     // image width
const h = 300     // image height
const n = 15000   // number of particles to add
const frost = 255 // white
 
var g *image.Gray
 
func main() {
    g = image.NewGray(image.Rectangle{image.Point{0, 0}, image.Point{w, h}})
    // off center seed position makes pleasingly asymetrical tree
    g.SetGray(w/3, h/3, color.Gray{frost})
generate:
    for a := 0; a < n; {
        // generate random position for new particle
        rp := image.Point{rand.Intn(w), rand.Intn(h)}
        if g.At(rp.X, rp.Y).(color.Gray).Y == frost {
            // position is already set.  find a nearby free position.
            for {
                rp.X += rand.Intn(3) - 1
                rp.Y += rand.Intn(3) - 1
                // execpt if we run out of bounds, consider the particle lost.
                if !rp.In(g.Rect) {
                    continue generate
                }
                if g.At(rp.X, rp.Y).(color.Gray).Y != frost {
                    break
                }
            }
        } else {
            // else particle is in free space.  let it wander
            // until it touches tree
            for !hasNeighbor(rp) {
                rp.X += rand.Intn(3) - 1
                rp.Y += rand.Intn(3) - 1
                // but again, if it wanders out of bounds consider it lost.
                if !rp.In(g.Rect) {
                    continue generate
                }
            }
        }
        // x, y now specify a free position toucing the tree.
        g.SetGray(rp.X, rp.Y, color.Gray{frost})
        a++
        // progress indicator
        if a%100 == 0 {
            fmt.Println(a, ""of"", n)
        }
    }
    f, err := os.Create(""tree.png"")
    if err != nil {
        fmt.Println(err)
        return
    }
    err = png.Encode(f, g)
    if err != nil {
        fmt.Println(err)
    }
    f.Close()
}
 
var n8 = []image.Point{
    {-1, -1}, {-1, 0}, {-1, 1},
    {0, -1}, {0, 1},
    {1, -1}, {1, 0}, {1, 1}}
 
func hasNeighbor(p image.Point) bool { 
    for _, n := range n8 {
        o := p.Add(n)
        if o.In(g.Rect) && g.At(o.X, o.Y).(color.Gray).Y == frost {
            return true
        }
    }
    return false
}",2305,85,"package main

import (
	""image""
	""image/color""
	""testing""
)

func TestHasNeighbor(t *testing.T) {
	// Initialize a small test image
	testWidth, testHeight := 10, 10
	g = image.NewGray(image.Rectangle{image.Point{0, 0}, image.Point{testWidth, testHeight}})

	// Set a seed point in the middle
	seedPoint := image.Point{5, 5}
	g.SetGray(seedPoint.X, seedPoint.Y, color.Gray{frost})

	tests := []struct {
		point    image.Point
		expected bool
	}{
		{image.Point{4, 4}, true},  // Diagonal neighbor
		{image.Point{5, 4}, true},  // Vertical neighbor
		{image.Point{4, 5}, true},  // Horizontal neighbor
		{image.Point{6, 6}, false}, // No neighbor
		{image.Point{0, 0}, false}, // Edge of the image, no neighbor
	}

	for _, test := range tests {
		result := hasNeighbor(test.point)
		if result != test.expected {
			t.Errorf(""hasNeighbor(%v) = %v; want %v"", test.point, result, test.expected)
		}
	}
}
",./data/generated/docs_golang/brownian_tree/gpt_4o_2024_08_06_brownian_tree_test.go,CompileStatus.OK,0.0,14.7,,0.05,0.07,0.11,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: g', 'Severity': '', 'SourceLines': ['\tg = image.NewGray(image.Rectangle{image.Point{0, 0}, image.Point{testWidth, testHeight}})'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_brownian_tree_test.go', 'Offset': 0, 'Line': 12, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: g', 'Severity': '', 'SourceLines': ['\tg.SetGray(seedPoint.X, seedPoint.Y, color.Gray{frost})'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_brownian_tree_test.go', 'Offset': 0, 'Line': 16, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: hasNeighbor', 'Severity': '', 'SourceLines': ['\t\tresult := hasNeighbor(test.point)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_brownian_tree_test.go', 'Offset': 0, 'Line': 30, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
CSV data manipulation,"CSV spreadsheet files are suitable for storing tabular data in a relatively portable way.

The CSV format is flexible but somewhat ill-defined.

For present purposes, authors may assume that the data fields contain no commas, backslashes, or quotation marks.



Task

Read a CSV file, change some values and save the changes back to a file.

For this task we will use the following CSV file:

C1,C2,C3,C4,C5
1,5,9,13,17
2,6,10,14,18
3,7,11,15,19
4,8,12,16,20

Suggestions


 Show how to add a column, headed 'SUM', of the sums of the rows.
 If possible, illustrate the use of built-in or standard functions, methods, or libraries, that handle generic CSV files.


",Go,"package main
 
import (
	""encoding/csv""
	""log""
	""os""
	""strconv""
)
 
func main() {
	rows := readSample()
	appendSum(rows)
	writeChanges(rows)
}
 
func readSample() [][]string {
	f, err := os.Open(""sample.csv"")
	if err != nil {
		log.Fatal(err)
	}
	rows, err := csv.NewReader(f).ReadAll()
	f.Close()
	if err != nil {
		log.Fatal(err)
	}
	return rows
}
 
func appendSum(rows [][]string) {
	rows[0] = append(rows[0], ""SUM"")
	for i := 1; i < len(rows); i++ {
		rows[i] = append(rows[i], sum(rows[i]))
	}
}
 
func sum(row []string) string {
	sum := 0
	for _, s := range row {
		x, err := strconv.Atoi(s)
		if err != nil {
			return ""NA""
		}
		sum += x
	}
	return strconv.Itoa(sum)
}
 
func writeChanges(rows [][]string) {
	f, err := os.Create(""output.csv"")
	if err != nil {
		log.Fatal(err)
	}
	err = csv.NewWriter(f).WriteAll(rows)
	f.Close()
	if err != nil {
		log.Fatal(err)
	}
}",876,58,"package main

import (
	""encoding/csv""
	""os""
	""reflect""
	""strconv""
	""testing""
)

// TestReadSample tests the readSample function
func TestReadSample(t *testing.T) {
	expected := [][]string{
		{""C1"", ""C2"", ""C3"", ""C4"", ""C5""},
		{""1"", ""5"", ""9"", ""13"", ""17""},
		{""2"", ""6"", ""10"", ""14"", ""18""},
		{""3"", ""7"", ""11"", ""15"", ""19""},
		{""4"", ""8"", ""12"", ""16"", ""20""},
	}

	// Create a temporary CSV file for testing
	file, err := os.Create(""sample.csv"")
	if err != nil {
		t.Fatalf(""Failed to create sample.csv: %v"", err)
	}
	writer := csv.NewWriter(file)
	writer.WriteAll(expected)
	writer.Flush()
	file.Close()

	// Test the readSample function
	result := readSample()
	if !reflect.DeepEqual(result, expected) {
		t.Errorf(""readSample() = %v, want %v"", result, expected)
	}

	// Clean up
	os.Remove(""sample.csv"")
}

// TestAppendSum tests the appendSum function
func TestAppendSum(t *testing.T) {
	input := [][]string{
		{""C1"", ""C2"", ""C3"", ""C4"", ""C5""},
		{""1"", ""5"", ""9"", ""13"", ""17""},
		{""2"", ""6"", ""10"", ""14"", ""18""},
		{""3"", ""7"", ""11"", ""15"", ""19""},
		{""4"", ""8"", ""12"", ""16"", ""20""},
	}
	expected := [][]string{
		{""C1"", ""C2"", ""C3"", ""C4"", ""C5"", ""SUM""},
		{""1"", ""5"", ""9"", ""13"", ""17"", ""45""},
		{""2"", ""6"", ""10"", ""14"", ""18"", ""50""},
		{""3"", ""7"", ""11"", ""15"", ""19"", ""55""},
		{""4"", ""8"", ""12"", ""16"", ""20"", ""60""},
	}

	appendSum(input)
	if !reflect.DeepEqual(input, expected) {
		t.Errorf(""appendSum() = %v, want %v"", input, expected)
	}
}

// TestSum tests the sum function
func TestSum(t *testing.T) {
	tests := []struct {
		input    []string
		expected string
	}{
		{[]string{""1"", ""2"", ""3""}, ""6""},
		{[]string{""10"", ""20"", ""30""}, ""60""},
		{[]string{""a"", ""b"", ""c""}, ""NA""},
	}

	for _, test := range tests {
		result := sum(test.input)
		if result != test.expected {
			t.Errorf(""sum(%v) = %v, want %v"", test.input, result, test.expected)
		}
	}
}

// TestWriteChanges tests the writeChanges function
func TestWriteChanges(t *testing.T) {
	input := [][]string{
		{""C1"", ""C2"", ""C3"", ""C4"", ""C5"", ""SUM""},
		{""1"", ""5"", ""9"", ""13"", ""17"", ""45""},
		{""2"", ""6"", ""10"", ""14"", ""18"", ""50""},
		{""3"", ""7"", ""11"", ""15"", ""19"", ""55""},
		{""4"", ""8"", ""12"", ""16"", ""20"", ""60""},
	}

	// Write changes to a temporary file
	writeChanges(input)

	// Read the file back and compare
	file, err := os.Open(""output.csv"")
	if err != nil {
		t.Fatalf(""Failed to open output.csv: %v"", err)
	}
	defer file.Close()

	reader := csv.NewReader(file)
	result, err := reader.ReadAll()
	if err != nil {
		t.Fatalf(""Failed to read output.csv: %v"", err)
	}

	if !reflect.DeepEqual(result, input) {
		t.Errorf(""writeChanges() = %v, want %v"", result, input)
	}

	// Clean up
	os.Remove(""output.csv"")
}
",./data/generated/docs_golang/csv_data_manipulation/gpt_4o_2024_08_06_csv_data_manipulation_test.go,CompileStatus.SYNTAX_ERROR,,,,0.15,0.58,,5.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: readSample', 'Severity': '', 'SourceLines': ['\tresult := readSample()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_csv_data_manipulation_test.go', 'Offset': 0, 'Line': 32, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: appendSum', 'Severity': '', 'SourceLines': ['\tappendSum(input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_csv_data_manipulation_test.go', 'Offset': 0, 'Line': 58, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: sum', 'Severity': '', 'SourceLines': ['\t\tresult := sum(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_csv_data_manipulation_test.go', 'Offset': 0, 'Line': 76, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: writeChanges', 'Severity': '', 'SourceLines': ['\twriteChanges(input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_csv_data_manipulation_test.go', 'Offset': 0, 'Line': 94, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""strconv"" imported and not used', 'Severity': '', 'SourceLines': ['\t""strconv""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_csv_data_manipulation_test.go', 'Offset': 0, 'Line': 7, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_csv_data_manipulation_test.go', 'line': 7, 'column': 2, 'message': '""strconv"" imported and not used'}]"
CUSIP,"

 This page uses content from Wikipedia. The original article was at CUSIP. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



A   CUSIP   is a nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades. The CUSIP was adopted as an American National Standard under Accredited Standards X9.6.



Task

Ensure the last digit   (i.e., the   check digit)   of the CUSIP code (the 1st column) is correct, against the following:

   037833100       Apple Incorporated 
   17275R102       Cisco Systems 
   38259P508       Google Incorporated 
   594918104       Microsoft Corporation 
   68389X106       Oracle Corporation   (incorrect)
   68389X105       Oracle Corporation 


Example pseudo-code below.
algorithm Cusip-Check-Digit(cusip) is
   Input: an 8-character CUSIP
 
   sum := 0
   for 1 ≤ i ≤ 8 do
      c := the ith character of cusip
      if c is a digit then
         v := numeric value of the digit c
      else if c is a letter then
         p := ordinal position of c in the alphabet (A=1, B=2...)
         v := p + 9
      else if c = ""*"" then
         v := 36
      else if c = ""@"" then
         v := 37
      else if' c = ""#"" then
         v := 38
      end if
      if i is even then
         v := v × 2
      end if
 
      sum := sum + int ( v div 10 ) + v mod 10
   repeat
 
   return (10 - (sum mod 10)) mod 10
end function
See related tasks
 
 SEDOL
 ISIN

",Go,"package main
 
import ""fmt""
 
func isCusip(s string) bool {
    if len(s) != 9 { return false }
    sum := 0
    for i := 0; i < 8; i++ {
        c := s[i]
        var v int
        switch {
            case c >= '0' && c <= '9':
                v = int(c) - 48
            case c >= 'A' && c <= 'Z':
                v = int(c) - 55
            case c == '*':
                v = 36
            case c == '@':
                v = 37
            case c == '#':
                v = 38
            default:
                return false
        }
        if i % 2 == 1 { v *= 2 }  // check if odd as using 0-based indexing
        sum += v/10 + v%10
    }
    return int(s[8]) - 48 == (10 - (sum%10)) % 10
}
 
func main() {
    candidates := []string {
        ""037833100"",
        ""17275R102"",
        ""38259P508"",
        ""594918104"",
        ""68389X106"",
        ""68389X105"",
    }
 
    for _, candidate := range candidates {
        var b string
        if isCusip(candidate) {
            b = ""correct""
        } else {
            b = ""incorrect""
        }
        fmt.Printf(""%s -> %s\n"", candidate, b)
    }
}
 ",1116,51,"package main

import ""testing""

// TestIsCusip tests the isCusip function with various CUSIP codes.
func TestIsCusip(t *testing.T) {
    tests := []struct {
        cusip    string
        expected bool
    }{
        {""037833100"", true},  // Apple Incorporated
        {""17275R102"", true},  // Cisco Systems
        {""38259P508"", true},  // Google Incorporated
        {""594918104"", true},  // Microsoft Corporation
        {""68389X106"", false}, // Oracle Corporation (incorrect)
        {""68389X105"", true},  // Oracle Corporation
        {""123456789"", false}, // Invalid CUSIP (incorrect check digit)
        {""ABCDEFGH1"", false}, // Invalid CUSIP (non-numeric check digit)
        {""12345678@"", false}, // Invalid CUSIP (invalid character)
        {"""", false},          // Empty string
        {""12345678"", false},  // Too short
        {""1234567890"", false},// Too long
    }

    for _, test := range tests {
        result := isCusip(test.cusip)
        if result != test.expected {
            t.Errorf(""isCusip(%s) = %v; want %v"", test.cusip, result, test.expected)
        }
    }
}
",./data/generated/docs_golang/cusip/gpt_4o_2024_08_06_cusip_test.go,CompileStatus.OK,0.0,54.2,,0.05,0.07,0.116,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: isCusip', 'Severity': '', 'SourceLines': ['        result := isCusip(test.cusip)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cusip_test.go', 'Offset': 0, 'Line': 26, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Cartesian product of two or more lists,"Task

Show one or more idiomatic ways of generating the Cartesian product of two arbitrary lists in your language.

Demonstrate that your function/method correctly returns:

{1, 2} × {3, 4} = {(1, 3), (1, 4), (2, 3), (2, 4)}
and, in contrast:

{3, 4} × {1, 2} = {(3, 1), (3, 2), (4, 1), (4, 2)}
Also demonstrate, using your function/method, that the product of an empty list with any other list is empty.

 {1, 2} × {} = {}
 {} × {1, 2} = {}
For extra credit, show or write a function returning the n-ary product of an arbitrary number of lists, each of arbitrary length. Your function might, for example, accept a single argument which is itself a list of lists, and return the n-ary product of those lists.

Use your n-ary Cartesian product function to show the following products:

 {1776, 1789} × {7, 12} × {4, 14, 23} × {0, 1}
 {1, 2, 3} × {30} × {500, 100}
 {1, 2, 3} × {} × {500, 100}

",Go,"package main
 
import ""fmt""
 
type pair [2]int
 
func cart2(a, b []int) []pair {
    p := make([]pair, len(a)*len(b))
    i := 0
    for _, a := range a {
        for _, b := range b {
            p[i] = pair{a, b}
            i++
        }
    }
    return p
}
 
func main() {
    fmt.Println(cart2([]int{1, 2}, []int{3, 4}))
    fmt.Println(cart2([]int{3, 4}, []int{1, 2}))
    fmt.Println(cart2([]int{1, 2}, nil))
    fmt.Println(cart2(nil, []int{1, 2}))
}",459,24,"package main

import (
	""reflect""
	""testing""
)

type pair [2]int

func cart2(a, b []int) []pair {
	p := make([]pair, len(a)*len(b))
	i := 0
	for _, a := range a {
		for _, b := range b {
			p[i] = pair{a, b}
			i++
		}
	}
	return p
}

func cartN(lists ...[]int) [][]int {
	if len(lists) == 0 {
		return [][]int{}
	}

	result := [][]int{{}}
	for _, list := range lists {
		var newResult [][]int
		for _, x := range result {
			for _, y := range list {
				newResult = append(newResult, append(append([]int{}, x...), y))
			}
		}
		result = newResult
	}
	return result
}

func TestCart2(t *testing.T) {
	tests := []struct {
		a, b     []int
		expected []pair
	}{
		{[]int{1, 2}, []int{3, 4}, []pair{{1, 3}, {1, 4}, {2, 3}, {2, 4}}},
		{[]int{3, 4}, []int{1, 2}, []pair{{3, 1}, {3, 2}, {4, 1}, {4, 2}}},
		{[]int{1, 2}, nil, []pair{}},
		{nil, []int{1, 2}, []pair{}},
	}

	for _, test := range tests {
		result := cart2(test.a, test.b)
		if !reflect.DeepEqual(result, test.expected) {
			t.Errorf(""cart2(%v, %v) = %v; expected %v"", test.a, test.b, result, test.expected)
		}
	}
}

func TestCartN(t *testing.T) {
	tests := []struct {
		lists    [][]int
		expected [][]int
	}{
		{
			[][]int{{1776, 1789}, {7, 12}, {4, 14, 23}, {0, 1}},
			[][]int{
				{1776, 7, 4, 0}, {1776, 7, 4, 1}, {1776, 7, 14, 0}, {1776, 7, 14, 1}, {1776, 7, 23, 0}, {1776, 7, 23, 1},
				{1776, 12, 4, 0}, {1776, 12, 4, 1}, {1776, 12, 14, 0}, {1776, 12, 14, 1}, {1776, 12, 23, 0}, {1776, 12, 23, 1},
				{1789, 7, 4, 0}, {1789, 7, 4, 1}, {1789, 7, 14, 0}, {1789, 7, 14, 1}, {1789, 7, 23, 0}, {1789, 7, 23, 1},
				{1789, 12, 4, 0}, {1789, 12, 4, 1}, {1789, 12, 14, 0}, {1789, 12, 14, 1}, {1789, 12, 23, 0}, {1789, 12, 23, 1},
			},
		},
		{
			[][]int{{1, 2, 3}, {30}, {500, 100}},
			[][]int{
				{1, 30, 500}, {1, 30, 100},
				{2, 30, 500}, {2, 30, 100},
				{3, 30, 500}, {3, 30, 100},
			},
		},
		{
			[][]int{{1, 2, 3}, {}, {500, 100}},
			[][]int{},
		},
	}

	for _, test := range tests {
		result := cartN(test.lists...)
		if !reflect.DeepEqual(result, test.expected) {
			t.Errorf(""cartN(%v) = %v; expected %v"", test.lists, result, test.expected)
		}
	}
}
",./data/generated/docs_golang/cartesian_product_of_two_or_more_lists/gpt_4o_2024_08_06_cartesian_product_of_two_or_more_lists_test.go,CompileStatus.SYNTAX_ERROR,,,,0.04,0.5,,0.0,[],False,False,,False,"[{'file': './gpt_4o_2024_08_06_cartesian_product_of_two_or_more_lists_test.go', 'line': 8, 'column': 6, 'message': 'pair redeclared in this block'}]"
Catalan numbers,"Catalan numbers

You are encouraged to solve this task according to the task description, using any language you may know.


Catalan numbers are a sequence of numbers which can be defined directly:






C

n


=


1

n
+
1






(



2
n

n


)



=



(
2
n
)
!


(
n
+
1
)
!

n
!





 for 

n
≥
0.


{\displaystyle C_{n}={\frac {1}{n+1}}{2n \choose n}={\frac {(2n)!}{(n+1)!\,n!}}\qquad {\mbox{ for }}n\geq 0.}


Or recursively:






C

0


=
1


and



C

n
+
1


=

∑

i
=
0


n



C

i




C

n
−
i




for 

n
≥
0
;


{\displaystyle C_{0}=1\quad {\mbox{and}}\quad C_{n+1}=\sum _{i=0}^{n}C_{i}\,C_{n-i}\quad {\text{for }}n\geq 0;}


Or alternatively (also recursive):






C

0


=
1


and



C

n


=



2
(
2
n
−
1
)


n
+
1




C

n
−
1


,


{\displaystyle C_{0}=1\quad {\mbox{and}}\quad C_{n}={\frac {2(2n-1)}{n+1}}C_{n-1},}




Task

Implement at least one of these algorithms and print out the first 15 Catalan numbers with each.

Memoization   is not required, but may be worth the effort when using the second method above.



Related tasks

Catalan numbers/Pascal's triangle
Evaluate binomial coefficients

",Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    var b, c big.Int
    for n := int64(0); n < 15; n++ {
        fmt.Println(c.Div(b.Binomial(n*2, n), c.SetInt64(n+1)))
    }
}",196,13,"package main

import (
	""math/big""
	""testing""
)

// TestCatalanNumbers tests the calculation of the first 15 Catalan numbers.
func TestCatalanNumbers(t *testing.T) {
	expectedCatalanNumbers := []string{
		""1"", ""1"", ""2"", ""5"", ""14"", ""42"", ""132"", ""429"", ""1430"", ""4862"",
		""16796"", ""58786"", ""208012"", ""742900"", ""2674440"",
	}

	var b, c big.Int
	for n := int64(0); n < 15; n++ {
		result := c.Div(b.Binomial(n*2, n), c.SetInt64(n+1)).String()
		if result != expectedCatalanNumbers[n] {
			t.Errorf(""Catalan number C(%d) = %s; want %s"", n, result, expectedCatalanNumbers[n])
		}
	}
}
",./data/generated/docs_golang/catalan_numbers/gpt_4o_2024_08_06_catalan_numbers_test.go,CompileStatus.OK,0.0,0.0,,0.11,0.5,0.095,0.0,[],False,False,100.0,False,[]
Chaos game,"The Chaos Game is a method of generating the attractor of an iterated function system (IFS).

One of the best-known and simplest examples creates a fractal, using a polygon and an initial point selected at random.



Task
Play the Chaos Game using the corners of an equilateral triangle as the reference points.   Add a starting point at random (preferably inside the triangle).   Then add the next point halfway between the starting point and one of the reference points.   This reference point is chosen at random.

After a sufficient number of iterations, the image of a Sierpinski Triangle should emerge.



See also
 The Game of Chaos

",Go,"package main
 
import (
	""fmt""
	""image""
	""image/color""
	""image/draw""
	""image/gif""
	""log""
	""math""
	""math/rand""
	""os""
	""time""
)
 
var bwPalette = color.Palette{
	color.Transparent,
	color.White,
	color.RGBA{R: 0xff, A: 0xff},
	color.RGBA{G: 0xff, A: 0xff},
	color.RGBA{B: 0xff, A: 0xff},
}
 
func main() {
	const (
		width          = 160
		frames         = 100
		pointsPerFrame = 50
		delay          = 100 * time.Millisecond
		filename       = ""chaos_anim.gif""
	)
 
	var tan60 = math.Sin(math.Pi / 3)
	height := int(math.Round(float64(width) * tan60))
	b := image.Rect(0, 0, width, height)
	vertices := [...]image.Point{
		{0, height}, {width, height}, {width / 2, 0},
	}
 
	// Make a filled triangle.
	m := image.NewPaletted(b, bwPalette)
	for y := b.Min.Y; y < b.Max.Y; y++ {
		bg := int(math.Round(float64(b.Max.Y-y) / 2 / tan60))
		for x := b.Min.X + bg; x < b.Max.X-bg; x++ {
			m.SetColorIndex(x, y, 1)
		}
	}
 
	// Pick starting point
	var p image.Point
	rand.Seed(time.Now().UnixNano())
	p.Y = rand.Intn(height) + b.Min.Y
	p.X = rand.Intn(width) + b.Min.X // TODO: make within triangle
 
	anim := newAnim(frames, delay)
	addFrame(anim, m)
	for i := 1; i < frames; i++ {
		for j := 0; j < pointsPerFrame; j++ {
			// Pick a random vertex
			vi := rand.Intn(len(vertices))
			v := vertices[vi]
			// Move p halfway there
			p.X = (p.X + v.X) / 2
			p.Y = (p.Y + v.Y) / 2
			m.SetColorIndex(p.X, p.Y, uint8(2+vi))
		}
		addFrame(anim, m)
	}
	if err := writeAnim(anim, filename); err != nil {
		log.Fatal(err)
	}
	fmt.Printf(""wrote to %q\n"", filename)
}
 
// Stuff for making a simple GIF animation.
 
func newAnim(frames int, delay time.Duration) *gif.GIF {
	const gifDelayScale = 10 * time.Millisecond
	g := &gif.GIF{
		Image: make([]*image.Paletted, 0, frames),
		Delay: make([]int, 1, frames),
	}
	g.Delay[0] = int(delay / gifDelayScale)
	return g
}
func addFrame(anim *gif.GIF, m *image.Paletted) {
	b := m.Bounds()
	dst := image.NewPaletted(b, m.Palette)
	draw.Draw(dst, b, m, image.ZP, draw.Src)
	anim.Image = append(anim.Image, dst)
	if len(anim.Delay) < len(anim.Image) {
		anim.Delay = append(anim.Delay, anim.Delay[0])
	}
}
func writeAnim(anim *gif.GIF, filename string) error {
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	err = gif.EncodeAll(f, anim)
	if cerr := f.Close(); err == nil {
		err = cerr
	}
	return err
}",2351,105,"package main

import (
	""image""
	""image/color""
	""image/gif""
	""math""
	""math/rand""
	""os""
	""testing""
	""time""
)

// TestNewAnim checks if a new GIF animation is created with the correct number of frames and delay.
func TestNewAnim(t *testing.T) {
	frames := 10
	delay := 100 * time.Millisecond
	anim := newAnim(frames, delay)

	if len(anim.Image) != 0 {
		t.Errorf(""Expected 0 images, got %d"", len(anim.Image))
	}
	if len(anim.Delay) != 1 {
		t.Errorf(""Expected 1 delay entry, got %d"", len(anim.Delay))
	}
	expectedDelay := int(delay / (10 * time.Millisecond))
	if anim.Delay[0] != expectedDelay {
		t.Errorf(""Expected delay %d, got %d"", expectedDelay, anim.Delay[0])
	}
}

// TestAddFrame checks if frames are added correctly to the GIF animation.
func TestAddFrame(t *testing.T) {
	anim := newAnim(10, 100*time.Millisecond)
	b := image.Rect(0, 0, 100, 100)
	m := image.NewPaletted(b, color.Palette{color.White, color.Black})

	addFrame(anim, m)
	if len(anim.Image) != 1 {
		t.Errorf(""Expected 1 image, got %d"", len(anim.Image))
	}
	if len(anim.Delay) != 1 {
		t.Errorf(""Expected 1 delay entry, got %d"", len(anim.Delay))
	}
}

// TestWriteAnim checks if the GIF animation is written to a file correctly.
func TestWriteAnim(t *testing.T) {
	anim := newAnim(1, 100*time.Millisecond)
	b := image.Rect(0, 0, 100, 100)
	m := image.NewPaletted(b, color.Palette{color.White, color.Black})
	addFrame(anim, m)

	filename := ""test.gif""
	defer os.Remove(filename)

	err := writeAnim(anim, filename)
	if err != nil {
		t.Fatalf(""Failed to write animation: %v"", err)
	}

	if _, err := os.Stat(filename); os.IsNotExist(err) {
		t.Errorf(""File %s was not created"", filename)
	}
}

// TestChaosGame checks if the chaos game generates points within the bounds of the triangle.
func TestChaosGame(t *testing.T) {
	const (
		width  = 160
		height = 139 // height calculated using tan(60 degrees) * width
	)
	vertices := [...]image.Point{
		{0, height}, {width, height}, {width / 2, 0},
	}

	rand.Seed(time.Now().UnixNano())
	p := image.Point{
		X: rand.Intn(width),
		Y: rand.Intn(height),
	}

	for i := 0; i < 1000; i++ {
		vi := rand.Intn(len(vertices))
		v := vertices[vi]
		p.X = (p.X + v.X) / 2
		p.Y = (p.Y + v.Y) / 2

		if p.X < 0 || p.X > width || p.Y < 0 || p.Y > height {
			t.Errorf(""Point out of bounds: (%d, %d)"", p.X, p.Y)
		}
	}
}
",./data/generated/docs_golang/chaos_game/gpt_4o_2024_08_06_chaos_game_test.go,CompileStatus.SYNTAX_ERROR,,,,0.16,0.67,,8.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: newAnim', 'Severity': '', 'SourceLines': ['\tanim := newAnim(frames, delay)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_chaos_game_test.go', 'Offset': 0, 'Line': 18, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: newAnim', 'Severity': '', 'SourceLines': ['\tanim := newAnim(10, 100*time.Millisecond)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_chaos_game_test.go', 'Offset': 0, 'Line': 34, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: addFrame', 'Severity': '', 'SourceLines': ['\taddFrame(anim, m)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_chaos_game_test.go', 'Offset': 0, 'Line': 38, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: newAnim', 'Severity': '', 'SourceLines': ['\tanim := newAnim(1, 100*time.Millisecond)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_chaos_game_test.go', 'Offset': 0, 'Line': 49, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: addFrame', 'Severity': '', 'SourceLines': ['\taddFrame(anim, m)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_chaos_game_test.go', 'Offset': 0, 'Line': 52, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: writeAnim', 'Severity': '', 'SourceLines': ['\terr := writeAnim(anim, filename)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_chaos_game_test.go', 'Offset': 0, 'Line': 57, 'Column': 9}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""image/gif"" imported and not used', 'Severity': '', 'SourceLines': ['\t""image/gif""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_chaos_game_test.go', 'Offset': 0, 'Line': 6, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""math"" imported and not used', 'Severity': '', 'SourceLines': ['\t""math""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_chaos_game_test.go', 'Offset': 0, 'Line': 7, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_chaos_game_test.go', 'line': 6, 'column': 2, 'message': '""image/gif"" imported and not used'}]"
Check Machin-like formulas,"Machin-like formulas   are useful for efficiently computing numerical approximations for 



π


{\displaystyle \pi }





Task

Verify the following Machin-like formulas are correct by calculating the value of tan   (right hand side) for each equation using exact arithmetic and showing they equal 1:

 





π
4


=
arctan
⁡


1
2


+
arctan
⁡


1
3




{\displaystyle {\pi \over 4}=\arctan {1 \over 2}+\arctan {1 \over 3}}

 
 





π
4


=
2
arctan
⁡


1
3


+
arctan
⁡


1
7




{\displaystyle {\pi \over 4}=2\arctan {1 \over 3}+\arctan {1 \over 7}}


 





π
4


=
4
arctan
⁡


1
5


−
arctan
⁡


1
239




{\displaystyle {\pi \over 4}=4\arctan {1 \over 5}-\arctan {1 \over 239}}


 





π
4


=
5
arctan
⁡


1
7


+
2
arctan
⁡


3
79




{\displaystyle {\pi \over 4}=5\arctan {1 \over 7}+2\arctan {3 \over 79}}


 





π
4


=
5
arctan
⁡


29
278


+
7
arctan
⁡


3
79




{\displaystyle {\pi \over 4}=5\arctan {29 \over 278}+7\arctan {3 \over 79}}


 





π
4


=
arctan
⁡


1
2


+
arctan
⁡


1
5


+
arctan
⁡


1
8




{\displaystyle {\pi \over 4}=\arctan {1 \over 2}+\arctan {1 \over 5}+\arctan {1 \over 8}}

 
 





π
4


=
4
arctan
⁡


1
5


−
arctan
⁡


1
70


+
arctan
⁡


1
99




{\displaystyle {\pi \over 4}=4\arctan {1 \over 5}-\arctan {1 \over 70}+\arctan {1 \over 99}}

 
 





π
4


=
5
arctan
⁡


1
7


+
4
arctan
⁡


1
53


+
2
arctan
⁡


1
4443




{\displaystyle {\pi \over 4}=5\arctan {1 \over 7}+4\arctan {1 \over 53}+2\arctan {1 \over 4443}}


 





π
4


=
6
arctan
⁡


1
8


+
2
arctan
⁡


1
57


+
arctan
⁡


1
239




{\displaystyle {\pi \over 4}=6\arctan {1 \over 8}+2\arctan {1 \over 57}+\arctan {1 \over 239}}


 





π
4


=
8
arctan
⁡


1
10


−
arctan
⁡


1
239


−
4
arctan
⁡


1
515




{\displaystyle {\pi \over 4}=8\arctan {1 \over 10}-\arctan {1 \over 239}-4\arctan {1 \over 515}}


 





π
4


=
12
arctan
⁡


1
18


+
8
arctan
⁡


1
57


−
5
arctan
⁡


1
239




{\displaystyle {\pi \over 4}=12\arctan {1 \over 18}+8\arctan {1 \over 57}-5\arctan {1 \over 239}}


 





π
4


=
16
arctan
⁡


1
21


+
3
arctan
⁡


1
239


+
4
arctan
⁡


3
1042




{\displaystyle {\pi \over 4}=16\arctan {1 \over 21}+3\arctan {1 \over 239}+4\arctan {3 \over 1042}}


 





π
4


=
22
arctan
⁡


1
28


+
2
arctan
⁡


1
443


−
5
arctan
⁡


1
1393


−
10
arctan
⁡


1
11018




{\displaystyle {\pi \over 4}=22\arctan {1 \over 28}+2\arctan {1 \over 443}-5\arctan {1 \over 1393}-10\arctan {1 \over 11018}}


 





π
4


=
22
arctan
⁡


1
38


+
17
arctan
⁡


7
601


+
10
arctan
⁡


7
8149




{\displaystyle {\pi \over 4}=22\arctan {1 \over 38}+17\arctan {7 \over 601}+10\arctan {7 \over 8149}}


 





π
4


=
44
arctan
⁡


1
57


+
7
arctan
⁡


1
239


−
12
arctan
⁡


1
682


+
24
arctan
⁡


1
12943




{\displaystyle {\pi \over 4}=44\arctan {1 \over 57}+7\arctan {1 \over 239}-12\arctan {1 \over 682}+24\arctan {1 \over 12943}}


 





π
4


=
88
arctan
⁡


1
172


+
51
arctan
⁡


1
239


+
32
arctan
⁡


1
682


+
44
arctan
⁡


1
5357


+
68
arctan
⁡


1
12943




{\displaystyle {\pi \over 4}=88\arctan {1 \over 172}+51\arctan {1 \over 239}+32\arctan {1 \over 682}+44\arctan {1 \over 5357}+68\arctan {1 \over 12943}}


and confirm that the following formula is incorrect by showing   tan   (right hand side)   is not   1:

 





π
4


=
88
arctan
⁡


1
172


+
51
arctan
⁡


1
239


+
32
arctan
⁡


1
682


+
44
arctan
⁡


1
5357


+
68
arctan
⁡


1
12944




{\displaystyle {\pi \over 4}=88\arctan {1 \over 172}+51\arctan {1 \over 239}+32\arctan {1 \over 682}+44\arctan {1 \over 5357}+68\arctan {1 \over 12944}}


These identities are useful in calculating the values:

 



tan
⁡
(
a
+
b
)
=



tan
⁡
(
a
)
+
tan
⁡
(
b
)


1
−
tan
⁡
(
a
)
tan
⁡
(
b
)





{\displaystyle \tan(a+b)={\tan(a)+\tan(b) \over 1-\tan(a)\tan(b)}}


 



tan
⁡

(
arctan
⁡


a
b


)

=


a
b




{\displaystyle \tan \left(\arctan {a \over b}\right)={a \over b}}


 



tan
⁡
(
−
a
)
=
−
tan
⁡
(
a
)


{\displaystyle \tan(-a)=-\tan(a)}




You can store the equations in any convenient data structure, but for extra credit parse them from human-readable text input.

Note: to formally prove the formula correct, it would have to be shown that 






−
3
p
i

4




{\displaystyle {-3pi \over 4}}

 < right hand side < 






5
p
i

4




{\displaystyle {5pi \over 4}}

 due to 



tan
⁡
(
)


{\displaystyle \tan()}

 periodicity.


",Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
type mTerm struct {
    a, n, d int64
}
 
var testCases = [][]mTerm{
    {{1, 1, 2}, {1, 1, 3}},
    {{2, 1, 3}, {1, 1, 7}},
    {{4, 1, 5}, {-1, 1, 239}},
    {{5, 1, 7}, {2, 3, 79}},
    {{1, 1, 2}, {1, 1, 5}, {1, 1, 8}},
    {{4, 1, 5}, {-1, 1, 70}, {1, 1, 99}},
    {{5, 1, 7}, {4, 1, 53}, {2, 1, 4443}},
    {{6, 1, 8}, {2, 1, 57}, {1, 1, 239}},
    {{8, 1, 10}, {-1, 1, 239}, {-4, 1, 515}},
    {{12, 1, 18}, {8, 1, 57}, {-5, 1, 239}},
    {{16, 1, 21}, {3, 1, 239}, {4, 3, 1042}},
    {{22, 1, 28}, {2, 1, 443}, {-5, 1, 1393}, {-10, 1, 11018}},
    {{22, 1, 38}, {17, 7, 601}, {10, 7, 8149}},
    {{44, 1, 57}, {7, 1, 239}, {-12, 1, 682}, {24, 1, 12943}},
    {{88, 1, 172}, {51, 1, 239}, {32, 1, 682}, {44, 1, 5357}, {68, 1, 12943}},
    {{88, 1, 172}, {51, 1, 239}, {32, 1, 682}, {44, 1, 5357}, {68, 1, 12944}},
}
 
func main() {
    for _, m := range testCases {
        fmt.Printf(""tan %v = %v\n"", m, tans(m))
    }
}
 
var one = big.NewRat(1, 1)
 
func tans(m []mTerm) *big.Rat {
    if len(m) == 1 {
        return tanEval(m[0].a, big.NewRat(m[0].n, m[0].d))
    }
    half := len(m) / 2
    a := tans(m[:half])
    b := tans(m[half:])
    r := new(big.Rat)
    return r.Quo(new(big.Rat).Add(a, b), r.Sub(one, r.Mul(a, b)))
}
 
func tanEval(coef int64, f *big.Rat) *big.Rat {
    if coef == 1 {
        return f
    }
    if coef < 0 {
        r := tanEval(-coef, f)
        return r.Neg(r)
    }
    ca := coef / 2
    cb := coef - ca
    a := tanEval(ca, f)
    b := tanEval(cb, f)
    r := new(big.Rat)
    return r.Quo(new(big.Rat).Add(a, b), r.Sub(one, r.Mul(a, b)))
}",1639,64,"package main

import (
	""math/big""
	""testing""
)

func TestMachinLikeFormulas(t *testing.T) {
	testCases := []struct {
		terms   []mTerm
		isValid bool
	}{
		{[]mTerm{{1, 1, 2}, {1, 1, 3}}, true},
		{[]mTerm{{2, 1, 3}, {1, 1, 7}}, true},
		{[]mTerm{{4, 1, 5}, {-1, 1, 239}}, true},
		{[]mTerm{{5, 1, 7}, {2, 3, 79}}, true},
		{[]mTerm{{1, 1, 2}, {1, 1, 5}, {1, 1, 8}}, true},
		{[]mTerm{{4, 1, 5}, {-1, 1, 70}, {1, 1, 99}}, true},
		{[]mTerm{{5, 1, 7}, {4, 1, 53}, {2, 1, 4443}}, true},
		{[]mTerm{{6, 1, 8}, {2, 1, 57}, {1, 1, 239}}, true},
		{[]mTerm{{8, 1, 10}, {-1, 1, 239}, {-4, 1, 515}}, true},
		{[]mTerm{{12, 1, 18}, {8, 1, 57}, {-5, 1, 239}}, true},
		{[]mTerm{{16, 1, 21}, {3, 1, 239}, {4, 3, 1042}}, true},
		{[]mTerm{{22, 1, 28}, {2, 1, 443}, {-5, 1, 1393}, {-10, 1, 11018}}, true},
		{[]mTerm{{22, 1, 38}, {17, 7, 601}, {10, 7, 8149}}, true},
		{[]mTerm{{44, 1, 57}, {7, 1, 239}, {-12, 1, 682}, {24, 1, 12943}}, true},
		{[]mTerm{{88, 1, 172}, {51, 1, 239}, {32, 1, 682}, {44, 1, 5357}, {68, 1, 12943}}, true},
		{[]mTerm{{88, 1, 172}, {51, 1, 239}, {32, 1, 682}, {44, 1, 5357}, {68, 1, 12944}}, false},
	}

	for i, tc := range testCases {
		result := tans(tc.terms)
		expected := big.NewRat(1, 1)
		if tc.isValid && result.Cmp(expected) != 0 {
			t.Errorf(""Test case %d failed: expected %v, got %v"", i, expected, result)
		}
		if !tc.isValid && result.Cmp(expected) == 0 {
			t.Errorf(""Test case %d failed: expected not %v, got %v"", i, expected, result)
		}
	}
}
",./data/generated/docs_golang/check_machin_like_formulas/gpt_4o_2024_08_06_check_machin_like_formulas_test.go,CompileStatus.OK,0.0,90.0,,0.07,0.29,0.126,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: mTerm', 'Severity': '', 'SourceLines': ['\t\tterms   []mTerm'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_check_machin_like_formulas_test.go', 'Offset': 0, 'Line': 10, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: mTerm', 'Severity': '', 'SourceLines': ['\t\t{[]mTerm{{1, 1, 2}, {1, 1, 3}}, true},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_check_machin_like_formulas_test.go', 'Offset': 0, 'Line': 13, 'Column': 6}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: mTerm', 'Severity': '', 'SourceLines': ['\t\t{[]mTerm{{2, 1, 3}, {1, 1, 7}}, true},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_check_machin_like_formulas_test.go', 'Offset': 0, 'Line': 14, 'Column': 6}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: tans', 'Severity': '', 'SourceLines': ['\t\tresult := tans(tc.terms)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_check_machin_like_formulas_test.go', 'Offset': 0, 'Line': 32, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Check that file exists,"Task

Verify that a file called     input.txt     and   a directory called     docs     exist.



This should be done twice:  

   once for the current working directory,   and
   once for a file and a directory in the filesystem root.


Optional criteria (May 2015):   verify it works with:

   zero-length files
   an unusual filename:     `Abdu'l-Bahá.txt  

",Go,"package main
 
import (
    ""fmt""
    ""os""
)
 
func printStat(p string) {
    switch i, err := os.Stat(p); {
    case err != nil:
        fmt.Println(err)
    case i.IsDir():
        fmt.Println(p, ""is a directory"")
    default:
        fmt.Println(p, ""is a file"")
    }
}
 
func main() {
    printStat(""input.txt"")
    printStat(""/input.txt"")
    printStat(""docs"")
    printStat(""/docs"")
}",390,24,"package main

import (
    ""os""
    ""testing""
)

func TestFileAndDirectoryExistence(t *testing.T) {
    // Test for current working directory
    if _, err := os.Stat(""input.txt""); os.IsNotExist(err) {
        t.Errorf(""input.txt does not exist in the current working directory"")
    }

    if _, err := os.Stat(""docs""); os.IsNotExist(err) {
        t.Errorf(""docs directory does not exist in the current working directory"")
    }

    // Test for filesystem root
    if _, err := os.Stat(""/input.txt""); os.IsNotExist(err) {
        t.Errorf(""/input.txt does not exist in the filesystem root"")
    }

    if _, err := os.Stat(""/docs""); os.IsNotExist(err) {
        t.Errorf(""/docs directory does not exist in the filesystem root"")
    }
}

func TestZeroLengthFile(t *testing.T) {
    file, err := os.Create(""zero_length.txt"")
    if err != nil {
        t.Fatalf(""Failed to create zero-length file: %v"", err)
    }
    file.Close()

    fileInfo, err := os.Stat(""zero_length.txt"")
    if err != nil {
        t.Fatalf(""Failed to stat zero-length file: %v"", err)
    }

    if fileInfo.Size() != 0 {
        t.Errorf(""Expected zero-length file, got size: %d"", fileInfo.Size())
    }

    os.Remove(""zero_length.txt"")
}

func TestUnusualFilename(t *testing.T) {
    filename := ""Abdu'l-Bahá.txt""
    file, err := os.Create(filename)
    if err != nil {
        t.Fatalf(""Failed to create file with unusual filename: %v"", err)
    }
    file.Close()

    if _, err := os.Stat(filename); os.IsNotExist(err) {
        t.Errorf(""File with unusual filename does not exist"")
    }

    os.Remove(filename)
}
",./data/generated/docs_golang/check_that_file_exists/gpt_4o_2024_08_06_check_that_file_exists_test.go,CompileStatus.OK,0.0,0.0,,0.29,2.25,0.091,0.0,[],False,False,66.67,False,[]
Checkpoint synchronization,"The checkpoint synchronization is a problem of synchronizing multiple tasks. Consider a workshop where several workers (tasks) assembly details of some mechanism. When each of them completes his work they put the details together. There is no store, so a worker who finished its part first must wait for others before starting another one. Putting details together is the checkpoint at which tasks synchronize themselves before going their paths apart.

The task

Implement checkpoint synchronization in your language.

Make sure that the solution is race condition-free. Note that a straightforward solution based on events is exposed to race condition. Let two tasks A and B need to be synchronized at a checkpoint. Each signals its event (EA and EB correspondingly), then waits for the AND-combination of the events (EA&EB) and resets its event. Consider the following scenario: A signals EA first and gets blocked waiting for EA&EB. Then B signals EB and loses the processor. Then A is released (both events are signaled) and resets EA. Now if B returns and enters waiting for EA&EB, it gets lost.

When a worker is ready it shall not continue before others finish. A typical implementation bug is when a worker is counted twice within one working cycle causing its premature completion. This happens when the quickest worker serves its cycle two times while the laziest one is lagging behind.

If you can, implement workers joining and leaving.
",Go,"package main
 
import (
    ""log""
    ""math/rand""
    ""sync""
    ""time""
)
 
func worker(part string) {
    log.Println(part, ""worker begins part"")
    time.Sleep(time.Duration(rand.Int63n(1e6)))
    log.Println(part, ""worker completes part"")
    wg.Done()
}
 
var (
    partList    = []string{""A"", ""B"", ""C"", ""D""}
    nAssemblies = 3
    wg          sync.WaitGroup
)
 
func main() {
    rand.Seed(time.Now().UnixNano())
    for c := 1; c <= nAssemblies; c++ {
        log.Println(""begin assembly cycle"", c)
        wg.Add(len(partList))
        for _, part := range partList {
            go worker(part)
        }
        wg.Wait()
        log.Println(""assemble.  cycle"", c, ""complete"")
    }
}",694,34,"package main

import (
	""bytes""
	""log""
	""strings""
	""sync""
	""testing""
)

func TestCheckpointSynchronization(t *testing.T) {
	// Capture the log output
	var logBuffer bytes.Buffer
	log.SetOutput(&logBuffer)

	// Reset the WaitGroup for testing
	wg = sync.WaitGroup{}

	// Run the main function
	main()

	// Split the log output into lines
	logLines := strings.Split(logBuffer.String(), ""\n"")

	// Check that each cycle has all parts completed before the assembly message
	for c := 1; c <= nAssemblies; c++ {
		cycleStart := logLines[0]
		if !strings.Contains(cycleStart, ""begin assembly cycle"") {
			t.Fatalf(""Expected cycle start log, got: %s"", cycleStart)
		}

		// Check for each part completion
		for _, part := range partList {
			partCompleted := false
			for _, line := range logLines {
				if strings.Contains(line, part+"" worker completes part"") {
					partCompleted = true
					break
				}
			}
			if !partCompleted {
				t.Errorf(""Part %s did not complete in cycle %d"", part, c)
			}
		}

		// Check for cycle completion
		cycleComplete := false
		for _, line := range logLines {
			if strings.Contains(line, ""assemble.  cycle ""+string(c)+"" complete"") {
				cycleComplete = true
				break
			}
		}
		if !cycleComplete {
			t.Errorf(""Cycle %d did not complete"", c)
		}

		// Remove processed lines for the next cycle
		logLines = logLines[1:]
	}
}
",./data/generated/docs_golang/checkpoint_synchronization/gpt_4o_2024_08_06_checkpoint_synchronization_test.go,CompileStatus.SYNTAX_ERROR,,,,0.21,1.5,,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: wg', 'Severity': '', 'SourceLines': ['\twg = sync.WaitGroup{}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_checkpoint_synchronization_test.go', 'Offset': 0, 'Line': 17, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\tmain()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_checkpoint_synchronization_test.go', 'Offset': 0, 'Line': 20, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: nAssemblies', 'Severity': '', 'SourceLines': ['\tfor c := 1; c <= nAssemblies; c++ {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_checkpoint_synchronization_test.go', 'Offset': 0, 'Line': 26, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: partList', 'Severity': '', 'SourceLines': ['\t\tfor _, part := range partList {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_checkpoint_synchronization_test.go', 'Offset': 0, 'Line': 33, 'Column': 24}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_checkpoint_synchronization_test.go', 'line': 49, 'column': 50, 'message': 'conversion from int to string yields a string of one rune, not a string of digits'}]"
Cheryl's birthday,"Albert and Bernard just became friends with Cheryl, and they want to know when her birthday is.

Cheryl gave them a list of ten possible dates:

     May 15,     May 16,     May 19
     June 17,    June 18
     July 14,    July 16
     August 14,  August 15,  August 17

Cheryl then tells Albert the   month   of birth,   and Bernard the   day   (of the month)   of birth.

 1)  Albert:   I don't know when Cheryl's birthday is, but I know that Bernard does not know too.
 2)  Bernard:  At first I don't know when Cheryl's birthday is, but I know now.
 3)  Albert:   Then I also know when Cheryl's birthday is.



Task
Write a computer program to deduce, by successive elimination, Cheryl's birthday.



Related task

 Sum and Product Puzzle


References
 Wikipedia article of the same name.
 Tuple Relational Calculus

",Go,"package main
 
import (
    ""fmt""
    ""time""
)
 
type birthday struct{ month, day int }
 
func (b birthday) String() string {
    return fmt.Sprintf(""%s %d"", time.Month(b.month), b.day)
}
 
func (b birthday) monthUniqueIn(bds []birthday) bool {
    count := 0
    for _, bd := range bds {
        if bd.month == b.month {
            count++
        }
    }
    if count == 1 {
        return true
    }
    return false
}
 
func (b birthday) dayUniqueIn(bds []birthday) bool {
    count := 0
    for _, bd := range bds {
        if bd.day == b.day {
            count++
        }
    }
    if count == 1 {
        return true
    }
    return false
}
 
func (b birthday) monthWithUniqueDayIn(bds []birthday) bool {
    for _, bd := range bds {
        if bd.month == b.month && bd.dayUniqueIn(bds) {
            return true
        }
    }
    return false
}
 
func main() {
    choices := []birthday{
        {5, 15}, {5, 16}, {5, 19}, {6, 17}, {6, 18},
        {7, 14}, {7, 16}, {8, 14}, {8, 15}, {8, 17},
    }
 
    // Albert knows the month but doesn't know the day.
    // So the month can't be unique within the choices.
    var filtered []birthday
    for _, bd := range choices {
        if !bd.monthUniqueIn(choices) {
            filtered = append(filtered, bd)
        }
    }
 
    // Albert also knows that Bernard doesn't know the answer.
    // So the month can't have a unique day.
    var filtered2 []birthday
    for _, bd := range filtered {
        if !bd.monthWithUniqueDayIn(filtered) {
            filtered2 = append(filtered2, bd)
        }
    }
 
    // Bernard now knows the answer.
    // So the day must be unique within the remaining choices.
    var filtered3 []birthday
    for _, bd := range filtered2 {
        if bd.dayUniqueIn(filtered2) {
            filtered3 = append(filtered3, bd)
        }
    }
 
    // Albert now knows the answer too.
    // So the month must be unique within the remaining choices.
    var filtered4 []birthday
    for _, bd := range filtered3 {
        if bd.monthUniqueIn(filtered3) {
            filtered4 = append(filtered4, bd)
        }
    }
 
    if len(filtered4) == 1 {
        fmt.Println(""Cheryl's birthday is"", filtered4[0])
    } else {
        fmt.Println(""Something went wrong!"")
    }
}",2268,96,"package main

import (
	""testing""
)

func TestMonthUniqueIn(t *testing.T) {
	choices := []birthday{
		{5, 15}, {5, 16}, {5, 19}, {6, 17}, {6, 18},
		{7, 14}, {7, 16}, {8, 14}, {8, 15}, {8, 17},
	}

	tests := []struct {
		bd       birthday
		expected bool
	}{
		{birthday{5, 15}, false},
		{birthday{6, 17}, false},
		{birthday{7, 14}, false},
		{birthday{8, 14}, false},
	}

	for _, test := range tests {
		if result := test.bd.monthUniqueIn(choices); result != test.expected {
			t.Errorf(""monthUniqueIn(%v) = %v; want %v"", test.bd, result, test.expected)
		}
	}
}

func TestDayUniqueIn(t *testing.T) {
	choices := []birthday{
		{5, 15}, {5, 16}, {5, 19}, {6, 17}, {6, 18},
		{7, 14}, {7, 16}, {8, 14}, {8, 15}, {8, 17},
	}

	tests := []struct {
		bd       birthday
		expected bool
	}{
		{birthday{5, 15}, true},
		{birthday{5, 16}, true},
		{birthday{5, 19}, true},
		{birthday{6, 17}, true},
		{birthday{6, 18}, true},
		{birthday{7, 14}, false},
		{birthday{7, 16}, true},
		{birthday{8, 14}, false},
		{birthday{8, 15}, true},
		{birthday{8, 17}, true},
	}

	for _, test := range tests {
		if result := test.bd.dayUniqueIn(choices); result != test.expected {
			t.Errorf(""dayUniqueIn(%v) = %v; want %v"", test.bd, result, test.expected)
		}
	}
}

func TestMonthWithUniqueDayIn(t *testing.T) {
	choices := []birthday{
		{5, 15}, {5, 16}, {5, 19}, {6, 17}, {6, 18},
		{7, 14}, {7, 16}, {8, 14}, {8, 15}, {8, 17},
	}

	tests := []struct {
		bd       birthday
		expected bool
	}{
		{birthday{5, 15}, true},
		{birthday{6, 17}, true},
		{birthday{7, 14}, false},
		{birthday{8, 14}, false},
	}

	for _, test := range tests {
		if result := test.bd.monthWithUniqueDayIn(choices); result != test.expected {
			t.Errorf(""monthWithUniqueDayIn(%v) = %v; want %v"", test.bd, result, test.expected)
		}
	}
}

func TestMainLogic(t *testing.T) {
	choices := []birthday{
		{5, 15}, {5, 16}, {5, 19}, {6, 17}, {6, 18},
		{7, 14}, {7, 16}, {8, 14}, {8, 15}, {8, 17},
	}

	// Step 1: Filter out months with unique days
	var filtered []birthday
	for _, bd := range choices {
		if !bd.monthUniqueIn(choices) {
			filtered = append(filtered, bd)
		}
	}

	expectedFiltered := []birthday{
		{5, 15}, {5, 16}, {5, 19}, {6, 17}, {6, 18},
	}

	if len(filtered) != len(expectedFiltered) {
		t.Fatalf(""Expected filtered length %d, got %d"", len(expectedFiltered), len(filtered))
	}

	// Step 2: Filter out months with unique days
	var filtered2 []birthday
	for _, bd := range filtered {
		if !bd.monthWithUniqueDayIn(filtered) {
			filtered2 = append(filtered2, bd)
		}
	}

	expectedFiltered2 := []birthday{
		{7, 14}, {7, 16}, {8, 14}, {8, 15}, {8, 17},
	}

	if len(filtered2) != len(expectedFiltered2) {
		t.Fatalf(""Expected filtered2 length %d, got %d"", len(expectedFiltered2), len(filtered2))
	}

	// Step 3: Bernard knows the answer, so the day must be unique
	var filtered3 []birthday
	for _, bd := range filtered2 {
		if bd.dayUniqueIn(filtered2) {
			filtered3 = append(filtered3, bd)
		}
	}

	expectedFiltered3 := []birthday{
		{7, 16}, {8, 15}, {8, 17},
	}

	if len(filtered3) != len(expectedFiltered3) {
		t.Fatalf(""Expected filtered3 length %d, got %d"", len(expectedFiltered3), len(filtered3))
	}

	// Step 4: Albert knows the answer, so the month must be unique
	var filtered4 []birthday
	for _, bd := range filtered3 {
		if bd.monthUniqueIn(filtered3) {
			filtered4 = append(filtered4, bd)
		}
	}

	expectedFiltered4 := []birthday{
		{7, 16},
	}

	if len(filtered4) != len(expectedFiltered4) {
		t.Fatalf(""Expected filtered4 length %d, got %d"", len(expectedFiltered4), len(filtered4))
	}

	if filtered4[0] != (birthday{7, 16}) {
		t.Errorf(""Expected Cheryl's birthday to be July 16, got %v"", filtered4[0])
	}
}
",./data/generated/docs_golang/cheryl_s_birthday/gpt_4o_2024_08_06_cheryl_s_birthday_test.go,CompileStatus.OK,0.0,46.2,,0.09,0.35,0.096,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: birthday', 'Severity': '', 'SourceLines': ['\tchoices := []birthday{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cheryl_s_birthday_test.go', 'Offset': 0, 'Line': 8, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: birthday', 'Severity': '', 'SourceLines': ['\t\tbd       birthday'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cheryl_s_birthday_test.go', 'Offset': 0, 'Line': 14, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: birthday', 'Severity': '', 'SourceLines': ['\t\t{birthday{5, 15}, false},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cheryl_s_birthday_test.go', 'Offset': 0, 'Line': 17, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,50.0,False,[]
Chinese zodiac,"Traditionally, the Chinese have counted years using two simultaneous cycles, one of length 10 (the ""celestial stems"") and one of length 12 (the ""terrestrial branches""); the combination results in a repeating 60-year pattern. Mapping the branches to twelve traditional animal deities results in the well-known ""Chinese zodiac"", assigning each year to a given animal. For example, Tuesday, February 1, 2022 CE (in the common Gregorian calendar) will begin the lunisolar Year of the Tiger.

The celestial stems have no one-to-one mapping like that of the branches to animals; however, the five pairs of consecutive stems each belong to one of the five traditional Chinese elements (Wood, Fire, Earth, Metal, and Water). Further, one of the two years within each element's governance is associated with yin, the other with yang.

Thus, 2022 is also the yang year of Water. Note that since 12 is an even number, the association between animals and yin/yang doesn't change. Consecutive Years of the Rooster will cycle through the five elements, but will always be yin, despite the apparent conceptual mismatch between the specifically-male English animal name and the female aspect denoted by yin.

Task
 Create a subroutine or program that will return or output the animal, yin/yang association, and element for the lunisolar year that begins in a given CE year.
You may optionally provide more information in the form of the year's numerical position within the 60-year cycle and/or its actual Chinese stem-branch name (in Han characters or Pinyin transliteration).

Requisite information

 The animal cycle runs in this order: Rat, Ox, Tiger, Rabbit, Dragon, Snake, Horse, Goat, Monkey, Rooster, Dog, Pig.
 The element cycle runs in this order: Wood, Fire, Earth, Metal, Water.
 The yang year precedes the yin year within each element.
 The current 60-year cycle began in 1984 CE; the first cycle of the Common Era began in 4 CE.
Thus, 1984 was the year of the Wood Rat (yang), 1985 was the year of the Wood Ox (yin), and 1986 the year of the Fire Tiger (yang); 2022 - which, as already noted, is the year of the Water Tiger (yang) - is the 39th year of the current cycle.

Information for optional task

 The ten celestial stems are 甲 jiă, 乙 yĭ, 丙 bĭng, 丁 dīng, 戊 wù, 己 jĭ, 庚 gēng, 辛 xīn, 壬 rén, and 癸 gŭi. With the ASCII version of Pinyin tones, the names are written ""jia3"", ""yi3"", ""bing3"", ""ding1"", ""wu4"", ""ji3"", ""geng1"", ""xin1"", ""ren2"", and ""gui3"".
 The twelve terrestrial branches are 子 zĭ, 丑 chŏu, 寅 yín, 卯 măo, 辰 chén, 巳 sì, 午 wŭ, 未 wèi, 申 shēn, 酉 yŏu, 戌 xū, 亥 hài. In ASCII Pinyin, those are ""zi3"", ""chou3"", ""yin2"", ""mao3"", ""chen2"", ""si4"", ""wu3"", ""wei4"", ""shen1"", ""you3"", ""xu1"", and ""hai4"".
Therefore 1984 was 甲子 (jiă-zĭ, or jia3-zi3). 2022 is 壬寅 (rén-yín or ren2-yin2).
",Go,"package main
 
import ""fmt""
 
var (
    animalString = []string{""Rat"", ""Ox"", ""Tiger"", ""Rabbit"", ""Dragon"", ""Snake"",
        ""Horse"", ""Goat"", ""Monkey"", ""Rooster"", ""Dog"", ""Pig""}
    stemYYString  = []string{""Yang"", ""Yin""}
    elementString = []string{""Wood"", ""Fire"", ""Earth"", ""Metal"", ""Water""}
    stemCh        = []rune(""甲乙丙丁戊己庚辛壬癸"")
    branchCh      = []rune(""子丑寅卯辰巳午未申酉戌亥"")
)
 
func cz(yr int) (animal, yinYang, element, stemBranch string, cycleYear int) {
    yr -= 4
    stem := yr % 10
    branch := yr % 12
    return animalString[branch],
        stemYYString[stem%2],
        elementString[stem/2],
        string([]rune{stemCh[stem], branchCh[branch]}),
        yr%60 + 1
}
 
func main() {
    for _, yr := range []int{1935, 1938, 1968, 1972, 1976} {
        a, yy, e, sb, cy := cz(yr)
        fmt.Printf(""%d: %s %s, %s, Cycle year %d %s\n"",
            yr, e, a, yy, cy, sb)
    }
}",891,31,"package main

import (
	""testing""
)

func TestCZ(t *testing.T) {
	tests := []struct {
		year      int
		expectedAnimal string
		expectedYinYang string
		expectedElement string
		expectedStemBranch string
		expectedCycleYear int
	}{
		{1935, ""Pig"", ""Yin"", ""Wood"", ""乙亥"", 12},
		{1938, ""Tiger"", ""Yang"", ""Earth"", ""戊寅"", 15},
		{1968, ""Monkey"", ""Yang"", ""Earth"", ""戊申"", 45},
		{1972, ""Rat"", ""Yang"", ""Water"", ""壬子"", 49},
		{1976, ""Dragon"", ""Yang"", ""Fire"", ""丙辰"", 53},
		{1984, ""Rat"", ""Yang"", ""Wood"", ""甲子"", 1},
		{2022, ""Tiger"", ""Yang"", ""Water"", ""壬寅"", 39},
		{2023, ""Rabbit"", ""Yin"", ""Water"", ""癸卯"", 40},
		{2044, ""Dragon"", ""Yang"", ""Wood"", ""甲辰"", 1},
		{2045, ""Snake"", ""Yin"", ""Wood"", ""乙巳"", 2},
	}

	for _, test := range tests {
		animal, yinYang, element, stemBranch, cycleYear := cz(test.year)
		if animal != test.expectedAnimal {
			t.Errorf(""For year %d, expected animal %s, got %s"", test.year, test.expectedAnimal, animal)
		}
		if yinYang != test.expectedYinYang {
			t.Errorf(""For year %d, expected yin/yang %s, got %s"", test.year, test.expectedYinYang, yinYang)
		}
		if element != test.expectedElement {
			t.Errorf(""For year %d, expected element %s, got %s"", test.year, test.expectedElement, element)
		}
		if stemBranch != test.expectedStemBranch {
			t.Errorf(""For year %d, expected stem-branch %s, got %s"", test.year, test.expectedStemBranch, stemBranch)
		}
		if cycleYear != test.expectedCycleYear {
			t.Errorf(""For year %d, expected cycle year %d, got %d"", test.year, test.expectedCycleYear, cycleYear)
		}
	}
}
",./data/generated/docs_golang/chinese_zodiac/gpt_4o_2024_08_06_chinese_zodiac_test.go,CompileStatus.OK,2.0,,,0.16,1.67,0.074,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: cz', 'Severity': '', 'SourceLines': ['\t\tanimal, yinYang, element, stemBranch, cycleYear := cz(test.year)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_chinese_zodiac_test.go', 'Offset': 0, 'Line': 29, 'Column': 54}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Cholesky decomposition,"Every symmetric, positive definite matrix A can be decomposed into a product of a unique lower triangular matrix L and its transpose:





A
=
L

L

T




{\displaystyle A=LL^{T}}






L


{\displaystyle L}

 is called the Cholesky factor of 



A


{\displaystyle A}

, and can be interpreted as a generalized square root of 



A


{\displaystyle A}

, as described in Cholesky decomposition.

In a 3x3 example, we have to solve the following system of equations:









A



=


(




a

11





a

21





a

31







a

21





a

22





a

32







a

31





a

32





a

33





)








=


(




l

11




0


0





l

21





l

22




0





l

31





l

32





l

33





)




(




l

11





l

21





l

31






0



l

22





l

32






0


0



l

33





)


≡
L

L

T








=


(




l

11


2





l

21



l

11





l

31



l

11







l

21



l

11





l

21


2


+

l

22


2





l

31



l

21


+

l

32



l

22







l

31



l

11





l

31



l

21


+

l

32



l

22





l

31


2


+

l

32


2


+

l

33


2





)








{\displaystyle {\begin{aligned}A&={\begin{pmatrix}a_{11}&a_{21}&a_{31}\\a_{21}&a_{22}&a_{32}\\a_{31}&a_{32}&a_{33}\\\end{pmatrix}}\\&={\begin{pmatrix}l_{11}&0&0\\l_{21}&l_{22}&0\\l_{31}&l_{32}&l_{33}\\\end{pmatrix}}{\begin{pmatrix}l_{11}&l_{21}&l_{31}\\0&l_{22}&l_{32}\\0&0&l_{33}\end{pmatrix}}\equiv LL^{T}\\&={\begin{pmatrix}l_{11}^{2}&l_{21}l_{11}&l_{31}l_{11}\\l_{21}l_{11}&l_{21}^{2}+l_{22}^{2}&l_{31}l_{21}+l_{32}l_{22}\\l_{31}l_{11}&l_{31}l_{21}+l_{32}l_{22}&l_{31}^{2}+l_{32}^{2}+l_{33}^{2}\end{pmatrix}}\end{aligned}}}


We can see that for the diagonal elements (




l

k
k




{\displaystyle l_{kk}}

) of 



L


{\displaystyle L}

 there is a calculation pattern:






l

11


=



a

11






{\displaystyle l_{11}={\sqrt {a_{11}}}}







l

22


=



a

22


−

l

21


2






{\displaystyle l_{22}={\sqrt {a_{22}-l_{21}^{2}}}}







l

33


=



a

33


−
(

l

31


2


+

l

32


2


)




{\displaystyle l_{33}={\sqrt {a_{33}-(l_{31}^{2}+l_{32}^{2})}}}


or in general:






l

k
k


=



a

k
k


−

∑

j
=
1


k
−
1



l

k
j


2






{\displaystyle l_{kk}={\sqrt {a_{kk}-\sum _{j=1}^{k-1}l_{kj}^{2}}}}


For the elements below the diagonal (




l

i
k




{\displaystyle l_{ik}}

, where 



i
>
k


{\displaystyle i>k}

) there is also a calculation pattern:






l

21


=


1

l

11





a

21




{\displaystyle l_{21}={\frac {1}{l_{11}}}a_{21}}







l

31


=


1

l

11





a

31




{\displaystyle l_{31}={\frac {1}{l_{11}}}a_{31}}







l

32


=


1

l

22




(

a

32


−

l

31



l

21


)


{\displaystyle l_{32}={\frac {1}{l_{22}}}(a_{32}-l_{31}l_{21})}


which can also be expressed in a general formula:






l

i
k


=


1

l

k
k





(

a

i
k


−

∑

j
=
1


k
−
1



l

i
j



l

k
j


)



{\displaystyle l_{ik}={\frac {1}{l_{kk}}}\left(a_{ik}-\sum _{j=1}^{k-1}l_{ij}l_{kj}\right)}


Task description

The task is to implement a routine which will return a lower Cholesky factor 



L


{\displaystyle L}

 for every given symmetric, positive definite nxn matrix 



A


{\displaystyle A}

. You should then test it on the following two examples and include your output.

Example 1:

25  15  -5                 5   0   0
15  18   0         -->     3   3   0
-5   0  11                -1   1   3

Example 2:

18  22   54   42           4.24264    0.00000    0.00000    0.00000
22  70   86   62   -->     5.18545    6.56591    0.00000    0.00000
54  86  174  134          12.72792    3.04604    1.64974    0.00000
42  62  134  106           9.89949    1.62455    1.84971    1.39262



Note

 The Cholesky decomposition of a Pascal upper-triangle matrix is the Identity matrix of the same size. 
 The Cholesky decomposition of a Pascal symmetric matrix is the Pascal lower-triangle matrix of the same size.",Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
// symmetric and lower use a packed representation that stores only
// the lower triangle.
 
type symmetric struct {
    order int
    ele   []float64
}
 
type lower struct {
    order int
    ele   []float64
}
 
// symmetric.print prints a square matrix from the packed representation,
// printing the upper triange as a transpose of the lower.
func (s *symmetric) print() {
    const eleFmt = ""%10.5f ""
    row, diag := 1, 0
    for i, e := range s.ele {
        fmt.Printf(eleFmt, e)
        if i == diag {
            for j, col := diag+row, row; col < s.order; j += col {
                fmt.Printf(eleFmt, s.ele[j])
                col++
            }
            fmt.Println()
            row++
            diag += row
        }
    }
}
 
// lower.print prints a square matrix from the packed representation,
// printing the upper triangle as all zeros.
func (l *lower) print() {
    const eleFmt = ""%10.5f ""
    row, diag := 1, 0
    for i, e := range l.ele {
        fmt.Printf(eleFmt, e)
        if i == diag {
            for j := row; j < l.order; j++ {
                fmt.Printf(eleFmt, 0.)
            }
            fmt.Println()
            row++
            diag += row
        }
    }
}
 
// choleskyLower returns the cholesky decomposition of a symmetric real
// matrix.  The matrix must be positive definite but this is not checked.
func (a *symmetric) choleskyLower() *lower {
    l := &lower{a.order, make([]float64, len(a.ele))}
    row, col := 1, 1
    dr := 0 // index of diagonal element at end of row
    dc := 0 // index of diagonal element at top of column
    for i, e := range a.ele {
        if i < dr {
            d := (e - l.ele[i]) / l.ele[dc]
            l.ele[i] = d
            ci, cx := col, dc
            for j := i + 1; j <= dr; j++ {
                cx += ci
                ci++
                l.ele[j] += d * l.ele[cx]
            }
            col++
            dc += col
        } else {
            l.ele[i] = math.Sqrt(e - l.ele[i])
            row++
            dr += row
            col = 1
            dc = 0
        }
    }
    return l
}
 
func main() {
    demo(&symmetric{3, []float64{
        25,
        15, 18,
        -5, 0, 11}})
    demo(&symmetric{4, []float64{
        18,
        22, 70,
        54, 86, 174,
        42, 62, 134, 106}})
}
 
func demo(a *symmetric) {
    fmt.Println(""A:"")
    a.print()
    fmt.Println(""L:"")
    a.choleskyLower().print()
}",2472,105,"package main

import (
    ""math""
    ""testing""
)

func TestCholeskyDecomposition(t *testing.T) {
    tests := []struct {
        name     string
        input    *symmetric
        expected *lower
    }{
        {
            name: ""Example 1"",
            input: &symmetric{3, []float64{
                25,
                15, 18,
                -5, 0, 11}},
            expected: &lower{3, []float64{
                5,
                3, 3,
                -1, 1, 3}},
        },
        {
            name: ""Example 2"",
            input: &symmetric{4, []float64{
                18,
                22, 70,
                54, 86, 174,
                42, 62, 134, 106}},
            expected: &lower{4, []float64{
                4.24264,
                5.18545, 6.56591,
                12.72792, 3.04604, 1.64974,
                9.89949, 1.62455, 1.84971, 1.39262}},
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := tt.input.choleskyLower()
            if !compareLowerMatrices(result, tt.expected) {
                t.Errorf(""choleskyLower() = %v, expected %v"", result.ele, tt.expected.ele)
            }
        })
    }
}

func compareLowerMatrices(a, b *lower) bool {
    if a.order != b.order {
        return false
    }
    for i := range a.ele {
        if math.Abs(a.ele[i]-b.ele[i]) > 1e-5 {
            return false
        }
    }
    return true
}
",./data/generated/docs_golang/cholesky_decomposition/gpt_4o_2024_08_06_cholesky_decomposition_test.go,CompileStatus.OK,0.0,43.8,,0.03,0.07,0.097,6.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: lower', 'Severity': '', 'SourceLines': ['func compareLowerMatrices(a, b *lower) bool {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cholesky_decomposition_test.go', 'Offset': 0, 'Line': 50, 'Column': 33}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: symmetric', 'Severity': '', 'SourceLines': ['        input    *symmetric'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cholesky_decomposition_test.go', 'Offset': 0, 'Line': 11, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: lower', 'Severity': '', 'SourceLines': ['        expected *lower'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cholesky_decomposition_test.go', 'Offset': 0, 'Line': 12, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: symmetric', 'Severity': '', 'SourceLines': ['            input: &symmetric{3, []float64{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cholesky_decomposition_test.go', 'Offset': 0, 'Line': 16, 'Column': 21}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: lower', 'Severity': '', 'SourceLines': ['            expected: &lower{3, []float64{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cholesky_decomposition_test.go', 'Offset': 0, 'Line': 20, 'Column': 24}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: symmetric', 'Severity': '', 'SourceLines': ['            input: &symmetric{4, []float64{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cholesky_decomposition_test.go', 'Offset': 0, 'Line': 27, 'Column': 21}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Circles of given radius through two points,"
Given two points on a plane and a radius, usually two circles of given radius can be drawn through the points.

Exceptions

 r==0.0 should be treated as never describing circles (except in the case where the points are coincident).
 If the points are coincident then an infinite number of circles with the point on their circumference can be drawn, unless r==0.0 as well which then collapses the circles to a point.
 If the points form a diameter then return two identical circles or return a single circle, according to which is the most natural mechanism for the implementation language.
 If the points are too far apart then no circles can be drawn.


Task detail

 Write a function/subroutine/method/... that takes two points and a radius and returns the two circles through those points, or some indication of special cases where two, possibly equal, circles cannot be returned.
 Show here the output for the following inputs:
      p1                p2           r
0.1234, 0.9876    0.8765, 0.2345    2.0
0.0000, 2.0000    0.0000, 0.0000    1.0
0.1234, 0.9876    0.1234, 0.9876    2.0
0.1234, 0.9876    0.8765, 0.2345    0.5
0.1234, 0.9876    0.1234, 0.9876    0.0



Related task

   Total circles area.


See also

   Finding the Center of a Circle from 2 Points and Radius from Math forum @ Drexel

",Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
var (
    Two  = ""Two circles.""
    R0   = ""R==0.0 does not describe circles.""
    Co   = ""Coincident points describe an infinite number of circles.""
    CoR0 = ""Coincident points with r==0.0 describe a degenerate circle.""
    Diam = ""Points form a diameter and describe only a single circle.""
    Far  = ""Points too far apart to form circles.""
)
 
type point struct{ x, y float64 }
 
func circles(p1, p2 point, r float64) (c1, c2 point, Case string) {
    if p1 == p2 {
        if r == 0 {
            return p1, p1, CoR0
        }
        Case = Co
        return
    }
    if r == 0 {
        return p1, p2, R0
    }
    dx := p2.x - p1.x
    dy := p2.y - p1.y
    q := math.Hypot(dx, dy)
    if q > 2*r {
        Case = Far
        return
    }
    m := point{(p1.x + p2.x) / 2, (p1.y + p2.y) / 2}
    if q == 2*r {
        return m, m, Diam
    }
    d := math.Sqrt(r*r - q*q/4)
    ox := d * dx / q
    oy := d * dy / q
    return point{m.x - oy, m.y + ox}, point{m.x + oy, m.y - ox}, Two
}
 
var td = []struct {
    p1, p2 point
    r      float64
}{
    {point{0.1234, 0.9876}, point{0.8765, 0.2345}, 2.0},
    {point{0.0000, 2.0000}, point{0.0000, 0.0000}, 1.0},
    {point{0.1234, 0.9876}, point{0.1234, 0.9876}, 2.0},
    {point{0.1234, 0.9876}, point{0.8765, 0.2345}, 0.5},
    {point{0.1234, 0.9876}, point{0.1234, 0.9876}, 0.0},
}
 
func main() {
    for _, tc := range td {
        fmt.Println(""p1: "", tc.p1)
        fmt.Println(""p2: "", tc.p2)
        fmt.Println(""r: "", tc.r)
        c1, c2, Case := circles(tc.p1, tc.p2, tc.r)
        fmt.Println(""  "", Case)
        switch Case {
        case CoR0, Diam:
            fmt.Println(""   Center: "", c1)
        case Two:
            fmt.Println(""   Center 1: "", c1)
            fmt.Println(""   Center 2: "", c2)
        }
        fmt.Println()
    }
}",1862,74,"package main

import (
	""testing""
	""math""
)

func TestCircles(t *testing.T) {
	tests := []struct {
		p1, p2 point
		r      float64
		wantC1 point
		wantC2 point
		wantCase string
	}{
		{point{0.1234, 0.9876}, point{0.8765, 0.2345}, 2.0, point{0.1234, 0.9876}, point{0.8765, 0.2345}, Two},
		{point{0.0000, 2.0000}, point{0.0000, 0.0000}, 1.0, point{0.0000, 1.0}, point{0.0000, 1.0}, Diam},
		{point{0.1234, 0.9876}, point{0.1234, 0.9876}, 2.0, point{0.1234, 0.9876}, point{0.1234, 0.9876}, Co},
		{point{0.1234, 0.9876}, point{0.8765, 0.2345}, 0.5, point{0.1234, 0.9876}, point{0.8765, 0.2345}, Far},
		{point{0.1234, 0.9876}, point{0.1234, 0.9876}, 0.0, point{0.1234, 0.9876}, point{0.1234, 0.9876}, CoR0},
	}

	for _, tt := range tests {
		t.Run(tt.wantCase, func(t *testing.T) {
			gotC1, gotC2, gotCase := circles(tt.p1, tt.p2, tt.r)
			if gotCase != tt.wantCase {
				t.Errorf(""circles() gotCase = %v, want %v"", gotCase, tt.wantCase)
			}
			if !pointsEqual(gotC1, tt.wantC1) || !pointsEqual(gotC2, tt.wantC2) {
				t.Errorf(""circles() gotC1 = %v, gotC2 = %v, wantC1 = %v, wantC2 = %v"", gotC1, gotC2, tt.wantC1, tt.wantC2)
			}
		})
	}
}

func pointsEqual(p1, p2 point) bool {
	return math.Abs(p1.x-p2.x) < 1e-9 && math.Abs(p1.y-p2.y) < 1e-9
}
",./data/generated/docs_golang/circles_of_given_radius_through_two_points/gpt_4o_2024_08_06_circles_of_given_radius_through_two_points_test.go,CompileStatus.OK,0.0,61.3,,0.09,0.2,0.143,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: point', 'Severity': '', 'SourceLines': ['func pointsEqual(p1, p2 point) bool {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_circles_of_given_radius_through_two_points_test.go', 'Offset': 0, 'Line': 36, 'Column': 25}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: point', 'Severity': '', 'SourceLines': ['\t\tp1, p2 point'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_circles_of_given_radius_through_two_points_test.go', 'Offset': 0, 'Line': 10, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: point', 'Severity': '', 'SourceLines': ['\t\twantC1 point'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_circles_of_given_radius_through_two_points_test.go', 'Offset': 0, 'Line': 12, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: circles', 'Severity': '', 'SourceLines': ['\t\t\tgotC1, gotC2, gotCase := circles(tt.p1, tt.p2, tt.r)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_circles_of_given_radius_through_two_points_test.go', 'Offset': 0, 'Line': 25, 'Column': 29}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,33.33,False,[]
Cistercian numerals,"Cistercian numerals were used across Europe by Cistercian monks during the Late Medieval Period as an alternative to Roman numerals. They were used to represent base 10 integers from 0 to 9999.

How they work
All Cistercian numerals begin with a vertical line segment, which by itself represents the number 0. Then, glyphs representing the digits 1 through 9 are optionally added to the four quadrants surrounding the vertical line segment. These glyphs are drawn with vertical and horizontal symmetry about the initial line segment. Each quadrant corresponds to a digit place in the number:

 The upper-right quadrant represents the ones place.
 The upper-left quadrant represents the tens place.
 The lower-right quadrant represents the hundreds place.
 The lower-left quadrant represents the thousands place.
Please consult the following image for examples of Cistercian numerals showing each glyph: [1]

Task
 Write a function/procedure/routine to display any given Cistercian numeral. This could be done by drawing to the display, creating an image, or even as text (as long as it is a reasonable facsimile).
 Use the routine to show the following Cistercian numerals:
 0
 1
 20
 300
 4000
 5555
 6789
 And a number of your choice!
Notes
Due to the inability to upload images to Rosetta Code as of this task's creation, showing output here on this page is not required. However, it is welcomed — especially for text output.

See also
 Numberphile - The Forgotten Number System
 dcode.fr - Online Cistercian numeral converter

",Go,"package main
 
import ""fmt""
 
var n = make([][]string, 15)
 
func initN() {
    for i := 0; i < 15; i++ {
        n[i] = make([]string, 11)
        for j := 0; j < 11; j++ {
            n[i][j] = "" ""
        }
        n[i][5] = ""x""
    }
}
 
func horiz(c1, c2, r int) {
    for c := c1; c <= c2; c++ {
        n[r][c] = ""x""
    }
}
 
func verti(r1, r2, c int) {
    for r := r1; r <= r2; r++ {
        n[r][c] = ""x""
    }
}
 
func diagd(c1, c2, r int) {
    for c := c1; c <= c2; c++ {
        n[r+c-c1][c] = ""x""
    }
}
 
func diagu(c1, c2, r int) {
    for c := c1; c <= c2; c++ {
        n[r-c+c1][c] = ""x""
    }
}
 
var draw map[int]func() // map contains recursive closures
 
func initDraw() {
    draw = map[int]func(){
        1: func() { horiz(6, 10, 0) },
        2: func() { horiz(6, 10, 4) },
        3: func() { diagd(6, 10, 0) },
        4: func() { diagu(6, 10, 4) },
        5: func() { draw[1](); draw[4]() },
        6: func() { verti(0, 4, 10) },
        7: func() { draw[1](); draw[6]() },
        8: func() { draw[2](); draw[6]() },
        9: func() { draw[1](); draw[8]() },
 
        10: func() { horiz(0, 4, 0) },
        20: func() { horiz(0, 4, 4) },
        30: func() { diagu(0, 4, 4) },
        40: func() { diagd(0, 4, 0) },
        50: func() { draw[10](); draw[40]() },
        60: func() { verti(0, 4, 0) },
        70: func() { draw[10](); draw[60]() },
        80: func() { draw[20](); draw[60]() },
        90: func() { draw[10](); draw[80]() },
 
        100: func() { horiz(6, 10, 14) },
        200: func() { horiz(6, 10, 10) },
        300: func() { diagu(6, 10, 14) },
        400: func() { diagd(6, 10, 10) },
        500: func() { draw[100](); draw[400]() },
        600: func() { verti(10, 14, 10) },
        700: func() { draw[100](); draw[600]() },
        800: func() { draw[200](); draw[600]() },
        900: func() { draw[100](); draw[800]() },
 
        1000: func() { horiz(0, 4, 14) },
        2000: func() { horiz(0, 4, 10) },
        3000: func() { diagd(0, 4, 10) },
        4000: func() { diagu(0, 4, 14) },
        5000: func() { draw[1000](); draw[4000]() },
        6000: func() { verti(10, 14, 0) },
        7000: func() { draw[1000](); draw[6000]() },
        8000: func() { draw[2000](); draw[6000]() },
        9000: func() { draw[1000](); draw[8000]() },
    }
}
 
func printNumeral() {
    for i := 0; i < 15; i++ {
        for j := 0; j < 11; j++ {
            fmt.Printf(""%s "", n[i][j])
        }
        fmt.Println()
    }
    fmt.Println()
}
 
func main() {
    initDraw()
    numbers := []int{0, 1, 20, 300, 4000, 5555, 6789, 9999}
    for _, number := range numbers {
        initN()
        fmt.Printf(""%d:\n"", number)
        thousands := number / 1000
        number %= 1000
        hundreds := number / 100
        number %= 100
        tens := number / 10
        ones := number % 10
        if thousands > 0 {
            draw[thousands*1000]()
        }
        if hundreds > 0 {
            draw[hundreds*100]()
        }
        if tens > 0 {
            draw[tens*10]()
        }
        if ones > 0 {
            draw[ones]()
        }
        printNumeral()
    }
}",3150,123,"package main

import (
	""bytes""
	""testing""
)

func captureOutput(f func()) string {
	var buf bytes.Buffer
	fmt.SetOutput(&buf)
	defer fmt.SetOutput(nil)
	f()
	return buf.String()
}

func TestCistercianNumerals(t *testing.T) {
	tests := []struct {
		number   int
		expected string
	}{
		{0, ""x\n""},
		{1, ""x x x x x x x x x x x x x x x\n""},
		{20, ""x x x x x x x x x x x x x x x\n""},
		{300, ""x x x x x x x x x x x x x x x\n""},
		{4000, ""x x x x x x x x x x x x x x x\n""},
		{5555, ""x x x x x x x x x x x x x x x\n""},
		{6789, ""x x x x x x x x x x x x x x x\n""},
		{9999, ""x x x x x x x x x x x x x x x\n""},
	}

	for _, tt := range tests {
		t.Run(fmt.Sprintf(""Number %d"", tt.number), func(t *testing.T) {
			initDraw()
			initN()
			thousands := tt.number / 1000
			tt.number %= 1000
			hundreds := tt.number / 100
			tt.number %= 100
			tens := tt.number / 10
			ones := tt.number % 10
			if thousands > 0 {
				draw[thousands*1000]()
			}
			if hundreds > 0 {
				draw[hundreds*100]()
			}
			if tens > 0 {
				draw[tens*10]()
			}
			if ones > 0 {
				draw[ones]()
			}

			output := captureOutput(printNumeral)
			if output != tt.expected {
				t.Errorf(""expected %q, got %q"", tt.expected, output)
			}
		})
	}
}
",./data/generated/docs_golang/cistercian_numerals/gpt_4o_2024_08_06_cistercian_numerals_test.go,CompileStatus.SYNTAX_ERROR,,,,0.02,0.02,,9.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: fmt', 'Severity': '', 'SourceLines': ['\tfmt.SetOutput(&buf)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cistercian_numerals_test.go', 'Offset': 0, 'Line': 10, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fmt', 'Severity': '', 'SourceLines': ['\tdefer fmt.SetOutput(nil)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cistercian_numerals_test.go', 'Offset': 0, 'Line': 11, 'Column': 8}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fmt', 'Severity': '', 'SourceLines': ['\t\tt.Run(fmt.Sprintf(""Number %d"", tt.number), func(t *testing.T) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cistercian_numerals_test.go', 'Offset': 0, 'Line': 32, 'Column': 9}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: initDraw', 'Severity': '', 'SourceLines': ['\t\t\tinitDraw()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cistercian_numerals_test.go', 'Offset': 0, 'Line': 33, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: initN', 'Severity': '', 'SourceLines': ['\t\t\tinitN()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cistercian_numerals_test.go', 'Offset': 0, 'Line': 34, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: draw', 'Severity': '', 'SourceLines': ['\t\t\t\tdraw[thousands*1000]()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cistercian_numerals_test.go', 'Offset': 0, 'Line': 42, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: draw', 'Severity': '', 'SourceLines': ['\t\t\t\tdraw[hundreds*100]()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cistercian_numerals_test.go', 'Offset': 0, 'Line': 45, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: draw', 'Severity': '', 'SourceLines': ['\t\t\t\tdraw[tens*10]()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cistercian_numerals_test.go', 'Offset': 0, 'Line': 48, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: printNumeral', 'Severity': '', 'SourceLines': ['\t\t\toutput := captureOutput(printNumeral)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cistercian_numerals_test.go', 'Offset': 0, 'Line': 54, 'Column': 28}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_cistercian_numerals_test.go', 'line': 10, 'column': 2, 'message': 'undefined: fmt'}]"
Color wheel,"Task

Write a function to draw a HSV color wheel completely with code.

This is strictly for learning purposes only. It's highly recommended that you use an image in an actual application to actually draw the color wheel   (as procedurally drawing is super slow). This does help you understand how color wheels work and this can easily be used to determine a color value based on a position within a circle.


",Go,"package main
 
import (
    ""github.com/fogleman/gg""
    ""math""
)
 
const tau = 2 * math.Pi
 
func hsb2rgb(hue, sat, bri float64) (r, g, b int) {
    u := int(bri*255 + 0.5)
    if sat == 0 {
        r, g, b = u, u, u
    } else {
        h := (hue - math.Floor(hue)) * 6
        f := h - math.Floor(h)
        p := int(bri*(1-sat)*255 + 0.5)
        q := int(bri*(1-sat*f)*255 + 0.5)
        t := int(bri*(1-sat*(1-f))*255 + 0.5)
        switch int(h) {
        case 0:
            r, g, b = u, t, p
        case 1:
            r, g, b = q, u, p
        case 2:
            r, g, b = p, u, t
        case 3:
            r, g, b = p, q, u
        case 4:
            r, g, b = t, p, u
        case 5:
            r, g, b = u, p, q
        }
    }
    return
}
 
func colorWheel(dc *gg.Context) {
    width, height := dc.Width(), dc.Height()
    centerX, centerY := width/2, height/2
    radius := centerX
    if centerY < radius {
        radius = centerY
    }
    for y := 0; y < height; y++ {
        dy := float64(y - centerY)
        for x := 0; x < width; x++ {
            dx := float64(x - centerX)
            dist := math.Sqrt(dx*dx + dy*dy)
            if dist <= float64(radius) {
                theta := math.Atan2(dy, dx)
                hue := (theta + math.Pi) / tau
                r, g, b := hsb2rgb(hue, 1, 1)
                dc.SetRGB255(r, g, b)
                dc.SetPixel(x, y)
            }
        }
    }
}
 
func main() {
    const width, height = 480, 480
    dc := gg.NewContext(width, height)
    dc.SetRGB(1, 1, 1) // set background color to white
    dc.Clear()
    colorWheel(dc)
    dc.SavePNG(""color_wheel.png"")
}",1649,68,"package main

import (
	""image/color""
	""testing""

	""github.com/fogleman/gg""
)

func TestHSB2RGB(t *testing.T) {
	tests := []struct {
		hue, sat, bri float64
		expectedR, expectedG, expectedB int
	}{
		{0, 0, 0, 0, 0, 0},       // Black
		{0, 0, 1, 255, 255, 255}, // White
		{0, 1, 1, 255, 0, 0},     // Red
		{0.333, 1, 1, 0, 255, 0}, // Green
		{0.667, 1, 1, 0, 0, 255}, // Blue
	}

	for _, test := range tests {
		r, g, b := hsb2rgb(test.hue, test.sat, test.bri)
		if r != test.expectedR || g != test.expectedG || b != test.expectedB {
			t.Errorf(""hsb2rgb(%v, %v, %v) = (%v, %v, %v); want (%v, %v, %v)"",
				test.hue, test.sat, test.bri, r, g, b, test.expectedR, test.expectedG, test.expectedB)
		}
	}
}

func TestColorWheel(t *testing.T) {
	const width, height = 480, 480
	dc := gg.NewContext(width, height)
	dc.SetRGB(1, 1, 1) // set background color to white
	dc.Clear()
	colorWheel(dc)

	// Check a few key points to ensure the color wheel is drawn correctly
	tests := []struct {
		x, y int
		expectedColor color.Color
	}{
		{240, 240, color.RGBA{255, 0, 0, 255}}, // Center should be red
		{480, 240, color.RGBA{0, 255, 0, 255}}, // Right edge should be green
		{0, 240, color.RGBA{0, 255, 255, 255}}, // Left edge should be cyan
		{240, 0, color.RGBA{255, 0, 255, 255}}, // Top edge should be magenta
		{240, 480, color.RGBA{255, 255, 0, 255}}, // Bottom edge should be yellow
	}

	for _, test := range tests {
		r, g, b, a := dc.Image().At(test.x, test.y).RGBA()
		expectedR, expectedG, expectedB, expectedA := test.expectedColor.RGBA()
		if r != expectedR || g != expectedG || b != expectedB || a != expectedA {
			t.Errorf(""Pixel at (%v, %v) = (%v, %v, %v, %v); want (%v, %v, %v, %v)"",
				test.x, test.y, r, g, b, a, expectedR, expectedG, expectedB, expectedA)
		}
	}
}
",./data/generated/docs_golang/color_wheel/gpt_4o_2024_08_06_color_wheel_test.go,CompileStatus.OK,0.0,81.6,,0.06,0.14,0.551,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: hsb2rgb', 'Severity': '', 'SourceLines': ['\t\tr, g, b := hsb2rgb(test.hue, test.sat, test.bri)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_color_wheel_test.go', 'Offset': 0, 'Line': 23, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: colorWheel', 'Severity': '', 'SourceLines': ['\tcolorWheel(dc)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_color_wheel_test.go', 'Offset': 0, 'Line': 36, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Colour pinstripe/Display,"The task is to create 1 pixel wide coloured vertical pinstripes with a sufficient number of pinstripes to span the entire width of the graphics display.



The pinstripes should either follow the system palette sequence,   or a sequence that includes:

black,   red,   green,   blue,   magenta,   cyan,   yellow,   and   white:

   after filling the top quarter, switch to a wider 2 pixel wide vertical pinstripe pattern,
   halfway down the display, switch to 3 pixel wide vertical pinstripe,
   finally to a 4 pixels wide vertical pinstripe for the last quarter of the display.


See also

   display black and white 
   print colour

",Go,"package main
 
import ""github.com/fogleman/gg""
 
var palette = [8]string{
    ""000000"", // black
    ""FF0000"", // red
    ""00FF00"", // green
    ""0000FF"", // blue
    ""FF00FF"", // magenta
    ""00FFFF"", // cyan
    ""FFFF00"", // yellow
    ""FFFFFF"", // white
}
 
func pinstripe(dc *gg.Context) {
    w := dc.Width()
    h := dc.Height() / 4
    for b := 1; b <= 4; b++ {
        for x, ci := 0, 0; x < w; x, ci = x+b, ci+1 {
            dc.SetHexColor(palette[ci%8])
            y := h * (b - 1)
            dc.DrawRectangle(float64(x), float64(y), float64(b), float64(h))
            dc.Fill()
        }
    }
}
 
func main() {
    dc := gg.NewContext(900, 600)
    pinstripe(dc)
    dc.SavePNG(""color_pinstripe.png"")
}",718,33,"package main

import (
	""testing""
	""github.com/fogleman/gg""
	""image""
	""image/color""
)

func TestPinstripe(t *testing.T) {
	width := 900
	height := 600
	dc := gg.NewContext(width, height)
	pinstripe(dc)

	img := dc.Image()

	// Define expected colors in the palette
	expectedColors := []color.Color{
		color.RGBA{0, 0, 0, 255},       // black
		color.RGBA{255, 0, 0, 255},     // red
		color.RGBA{0, 255, 0, 255},     // green
		color.RGBA{0, 0, 255, 255},     // blue
		color.RGBA{255, 0, 255, 255},   // magenta
		color.RGBA{0, 255, 255, 255},   // cyan
		color.RGBA{255, 255, 0, 255},   // yellow
		color.RGBA{255, 255, 255, 255}, // white
	}

	// Check each section of the image
	for b := 1; b <= 4; b++ {
		stripeWidth := b
		yStart := (b - 1) * height / 4
		yEnd := b * height / 4

		for x := 0; x < width; x += stripeWidth {
			expectedColor := expectedColors[(x/stripeWidth)%8]

			for y := yStart; y < yEnd; y++ {
				actualColor := img.At(x, y)
				if !colorsEqual(expectedColor, actualColor) {
					t.Errorf(""Expected color %v at (%d, %d), but got %v"", expectedColor, x, y, actualColor)
				}
			}
		}
	}
}

func colorsEqual(c1, c2 color.Color) bool {
	r1, g1, b1, a1 := c1.RGBA()
	r2, g2, b2, a2 := c2.RGBA()
	return r1 == r2 && g1 == g2 && b1 == b2 && a1 == a2
}
",./data/generated/docs_golang/colour_pinstripe_display/gpt_4o_2024_08_06_colour_pinstripe_display_test.go,CompileStatus.SYNTAX_ERROR,,,,0.03,0.25,,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: pinstripe', 'Severity': '', 'SourceLines': ['\tpinstripe(dc)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_colour_pinstripe_display_test.go', 'Offset': 0, 'Line': 14, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""image"" imported and not used', 'Severity': '', 'SourceLines': ['\t""image""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_colour_pinstripe_display_test.go', 'Offset': 0, 'Line': 6, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_colour_pinstripe_display_test.go', 'line': 6, 'column': 2, 'message': '""image"" imported and not used'}]"
Combinations and permutations,"

 This page uses content from Wikipedia. The original article was at Combination. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



 This page uses content from Wikipedia. The original article was at Permutation. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

Task

Implement the combination    (nCk)    and permutation    (nPk)    operators in the target language:

 






n



C

k


=



(


n
k


)



=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle ^{n}\operatorname {C} _{k}={\binom {n}{k}}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}


 






n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




See the Wikipedia articles for a more detailed description.

To test, generate and print examples of:

   A sample of permutations from 1 to 12 and Combinations from 10 to 60 using exact Integer arithmetic.
   A sample of permutations from 5 to 15000 and Combinations from 100 to 1000 using approximate Floating point arithmetic.
 This 'floating point' code could be implemented using an approximation, e.g., by calling the Gamma function.


Related task

   Evaluate binomial coefficients



 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",Go," 
package main
 
import (
	""fmt""
	""math/big""
)
 
func main() {
	var n, p int64
	fmt.Printf(""A sample of permutations from 1 to 12:\n"")
	for n = 1; n < 13; n++ {
		p = n / 3
		fmt.Printf(""P(%d,%d) = %d\n"", n, p, perm(big.NewInt(n), big.NewInt(p)))
	}
	fmt.Printf(""\nA sample of combinations from 10 to 60:\n"")
	for n = 10; n < 61; n += 10 {
		p = n / 3
		fmt.Printf(""C(%d,%d) = %d\n"", n, p, comb(big.NewInt(n), big.NewInt(p)))
	}
	fmt.Printf(""\nA sample of permutations from 5 to 15000:\n"")
	nArr := [...]int64{5, 50, 500, 1000, 5000, 15000}
	for _, n = range nArr {
		p = n / 3
		fmt.Printf(""P(%d,%d) = %d\n"", n, p, perm(big.NewInt(n), big.NewInt(p)))
	}
	fmt.Printf(""\nA sample of combinations from 100 to 1000:\n"")
	for n = 100; n < 1001; n += 100 {
		p = n / 3
		fmt.Printf(""C(%d,%d) = %d\n"", n, p, comb(big.NewInt(n), big.NewInt(p)))
	}
}
 
func fact(n *big.Int) *big.Int {
	if n.Sign() < 1 {
		return big.NewInt(0)
	}
	r := big.NewInt(1)
	i := big.NewInt(2)
	for i.Cmp(n) < 1 {
		r.Mul(r, i)
		i.Add(i, big.NewInt(1))
	}
	return r
}
 
func perm(n, k *big.Int) *big.Int {
	r := fact(n)
	r.Div(r, fact(n.Sub(n, k)))
	return r
}
 
func comb(n, r *big.Int) *big.Int {
	if r.Cmp(n) == 1 {
		return big.NewInt(0)
	}
	if r.Cmp(n) == 0 {
		return big.NewInt(1)
	}
	c := fact(n)
	den := fact(n.Sub(n, r))
	den.Mul(den, fact(r))
	c.Div(c, den)
	return c
}
 ",1352,66,"package main

import (
	""math/big""
	""testing""
)

// TestFactorial tests the fact function for calculating factorials.
func TestFactorial(t *testing.T) {
	tests := []struct {
		input    int64
		expected string
	}{
		{0, ""0""},
		{1, ""1""},
		{5, ""120""},
		{10, ""3628800""},
	}

	for _, test := range tests {
		result := fact(big.NewInt(test.input))
		if result.String() != test.expected {
			t.Errorf(""Expected factorial of %d to be %s, got %s"", test.input, test.expected, result.String())
		}
	}
}

// TestPermutations tests the perm function for calculating permutations.
func TestPermutations(t *testing.T) {
	tests := []struct {
		n, k     int64
		expected string
	}{
		{5, 3, ""60""},
		{10, 5, ""30240""},
		{12, 4, ""11880""},
	}

	for _, test := range tests {
		result := perm(big.NewInt(test.n), big.NewInt(test.k))
		if result.String() != test.expected {
			t.Errorf(""Expected P(%d, %d) to be %s, got %s"", test.n, test.k, test.expected, result.String())
		}
	}
}

// TestCombinations tests the comb function for calculating combinations.
func TestCombinations(t *testing.T) {
	tests := []struct {
		n, k     int64
		expected string
	}{
		{5, 3, ""10""},
		{10, 5, ""252""},
		{12, 4, ""495""},
	}

	for _, test := range tests {
		result := comb(big.NewInt(test.n), big.NewInt(test.k))
		if result.String() != test.expected {
			t.Errorf(""Expected C(%d, %d) to be %s, got %s"", test.n, test.k, test.expected, result.String())
		}
	}
}

// TestEdgeCases tests edge cases for permutations and combinations.
func TestEdgeCases(t *testing.T) {
	tests := []struct {
		n, k     int64
		expectedP string
		expectedC string
	}{
		{0, 0, ""1"", ""1""},
		{5, 0, ""1"", ""1""},
		{5, 5, ""120"", ""1""},
		{5, 6, ""0"", ""0""},
	}

	for _, test := range tests {
		resultP := perm(big.NewInt(test.n), big.NewInt(test.k))
		resultC := comb(big.NewInt(test.n), big.NewInt(test.k))
		if resultP.String() != test.expectedP {
			t.Errorf(""Expected P(%d, %d) to be %s, got %s"", test.n, test.k, test.expectedP, resultP.String())
		}
		if resultC.String() != test.expectedC {
			t.Errorf(""Expected C(%d, %d) to be %s, got %s"", test.n, test.k, test.expectedC, resultC.String())
		}
	}
}
",./data/generated/docs_golang/combinations_and_permutations/gpt_4o_2024_08_06_combinations_and_permutations_test.go,CompileStatus.OK,2.0,,,0.1,0.42,0.123,5.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: fact', 'Severity': '', 'SourceLines': ['\t\tresult := fact(big.NewInt(test.input))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_combinations_and_permutations_test.go', 'Offset': 0, 'Line': 21, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: perm', 'Severity': '', 'SourceLines': ['\t\tresult := perm(big.NewInt(test.n), big.NewInt(test.k))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_combinations_and_permutations_test.go', 'Offset': 0, 'Line': 40, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: comb', 'Severity': '', 'SourceLines': ['\t\tresult := comb(big.NewInt(test.n), big.NewInt(test.k))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_combinations_and_permutations_test.go', 'Offset': 0, 'Line': 59, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: perm', 'Severity': '', 'SourceLines': ['\t\tresultP := perm(big.NewInt(test.n), big.NewInt(test.k))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_combinations_and_permutations_test.go', 'Offset': 0, 'Line': 80, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: comb', 'Severity': '', 'SourceLines': ['\t\tresultC := comb(big.NewInt(test.n), big.NewInt(test.k))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_combinations_and_permutations_test.go', 'Offset': 0, 'Line': 81, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,75.0,False,[]
Command-line arguments,"Command-line arguments is part of Short Circuit's Console Program Basics selection.
Scripted main
See also Program name.

For parsing command line arguments intelligently, see Parsing command-line arguments.

Example command line:

myprogram -c ""alpha beta"" -h ""gamma""
",Go," 
package main
import (
	""fmt""
	""os""
)
 
func main() {
	for i, x := range os.Args[1:] {
		fmt.Printf(""the argument #%d is %s\n"", i, x)
	}
}
 ",141,13,"package main

import (
	""bytes""
	""os""
	""testing""
)

func TestMainFunction(t *testing.T) {
	// Save the original os.Args
	originalArgs := os.Args
	defer func() { os.Args = originalArgs }()

	// Test cases
	tests := []struct {
		args     []string
		expected string
	}{
		{
			args:     []string{""myprogram"", ""-c"", ""alpha beta"", ""-h"", ""gamma""},
			expected: ""the argument #0 is -c\nthe argument #1 is alpha beta\nthe argument #2 is -h\nthe argument #3 is gamma\n"",
		},
		{
			args:     []string{""myprogram"", ""singleArg""},
			expected: ""the argument #0 is singleArg\n"",
		},
		{
			args:     []string{""myprogram""},
			expected: """",
		},
	}

	for _, test := range tests {
		// Set os.Args to the test case arguments
		os.Args = test.args

		// Capture the output
		var buf bytes.Buffer
		out := &buf
		original := os.Stdout
		defer func() { os.Stdout = original }()
		os.Stdout = out

		// Call the main function
		main()

		// Check the output
		if got := out.String(); got != test.expected {
			t.Errorf(""For args %v, expected %q but got %q"", test.args, test.expected, got)
		}
	}
}
",./data/generated/docs_golang/command_line_arguments/gpt_4o_2024_08_06_command_line_arguments_test.go,CompileStatus.SYNTAX_ERROR,,,,0.04,0.5,,2.0,"[{'FromLinter': 'typecheck', 'Text': 'cannot use out (variable of type *bytes.Buffer) as *os.File value in assignment', 'Severity': '', 'SourceLines': ['\t\tos.Stdout = out'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_command_line_arguments_test.go', 'Offset': 0, 'Line': 42, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\t\tmain()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_command_line_arguments_test.go', 'Offset': 0, 'Line': 45, 'Column': 3}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_command_line_arguments_test.go', 'line': 42, 'column': 15, 'message': 'cannot use out (variable of type *bytes.Buffer) as *os.File value in assignment'}]"
Commatizing numbers,"Commatizing   numbers (as used here, is a handy expedient made-up word) is the act of adding commas to a number (or string), or to the numeric part of a larger string.



Task

Write a function that takes a string as an argument with optional arguments or parameters (the format of parameters/options is left to the programmer) that in general, adds commas (or some
other characters, including blanks or tabs) to the first numeric part of a string (if it's suitable for commatizing as per the rules below), and returns that newly commatized string.

Some of the commatizing rules (specified below) are arbitrary, but they'll be a part of this task requirements, if only to make the results consistent amongst national preferences and other disciplines.

The number may be part of a larger (non-numeric) string such as:

   «US$1744 millions»       ──or──
   ±25000 motes.


The string may possibly not have a number suitable for commatizing, so it should be untouched and no error generated.

If any argument (option) is invalid, nothing is changed and no error need be generated (quiet execution, no fail execution).   Error message generation is optional.

The exponent part of a number is never commatized.   The following string isn't suitable for commatizing:   9.7e+12000

Leading zeroes are never commatized.   The string   0000000005714.882   after commatization is:   0000000005,714.882

Any   period   (.)   in a number is assumed to be a   decimal point.

The original string is never changed   except   by the addition of commas   [or whatever character(s) is/are used for insertion], if at all.

To wit, the following should be preserved:

   leading signs (+, -)       ── even superfluous signs
   leading/trailing/embedded blanks, tabs, and other whitespace 
   the case (upper/lower) of the exponent indicator, e.g.:   4.8903d-002


Any exponent character(s) should be supported:

   1247e12
   57256.1D-4
   4444^60
   7500∙10**35
   8500x10**35
   9500↑35
   +55000↑3
   1000**100
   2048²
   409632
   10000pow(pi)

Numbers may be terminated with any non-digit character, including subscripts and/or superscript:   41421356243   or   7320509076(base 24).

The character(s) to be used for the comma can be specified, and may contain blanks, tabs, and other whitespace characters, as well as multiple characters.   The default is the comma (,) character.

The   period length   can be specified   (sometimes referred to as ""thousands"" or ""thousands separators"").   The   period length   can be defined as the length (or number) of the decimal digits between commas.   The default period length is   3.

 E.G.:   in this example, the   period length   is five:   56789,12340,14148
The location of where to start the scanning for the target field (the numeric part) should be able to be specified.   The default is   1.

The character strings below may be placed in a file (and read) or stored as simple strings within the program.



Strings to be used as a minimum

The value of   pi   (expressed in base 10)   should be separated with blanks every   5   places past the decimal point,

the Zimbabwe dollar amount should use a decimal point for the ""comma"" separator:

   pi=3.14159265358979323846264338327950288419716939937510582097494459231
   The author has two Z$100000000000000 Zimbabwe notes (100 trillion).
   ""-in Aus$+1411.8millions""
   ===US$0017440 millions=== (in 2000 dollars)
   123.e8000 is pretty big.
   The land area of the earth is 57268900(29% of the surface) square miles.
   Ain't no numbers in this here words, nohow, no way, Jose.
   James was never known as 0000000007
   Arthur Eddington wrote: I believe there are 15747724136275002577605653961181555468044717914527116709366231425076185631031296 protons in the universe.
   ␢␢␢$-140000±100 millions.
   6/9/1946 was a good year for some.

where the penultimate string has three leading blanks   (real blanks are to be used).



Also see

 The Wiki entry:   (sir) Arthur Eddington's number of protons in the universe. 

",Go,"package main
 
import (
    ""fmt""
    ""regexp""
    ""strings""
)
 
var reg = regexp.MustCompile(`(\.[0-9]+|[1-9]([0-9]+)?(\.[0-9]+)?)`)
 
func reverse(s string) string {
    r := []rune(s)
    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {
        r[i], r[j] = r[j], r[i]
    }
    return string(r)
}
 
func commatize(s string, startIndex, period int, sep string) string {
    if startIndex < 0 || startIndex >= len(s) || period < 1 || sep == """" {
        return s
    }
    m := reg.FindString(s[startIndex:]) // this can only contain ASCII characters
    if m == """" {
        return s
    }
    splits := strings.Split(m, ""."")
    ip := splits[0]
    if len(ip) > period {
        pi := reverse(ip)
        for i := (len(ip) - 1) / period * period; i >= period; i -= period {
            pi = pi[:i] + sep + pi[i:]
        }
        ip = reverse(pi)
    }
    if strings.Contains(m, ""."") {
        dp := splits[1]
        if len(dp) > period {
            for i := (len(dp) - 1) / period * period; i >= period; i -= period {
                dp = dp[:i] + sep + dp[i:]
            }
        }
        ip += ""."" + dp
    }
    return s[:startIndex] + strings.Replace(s[startIndex:], m, ip, 1)
}
 
func main() {
    tests := [...]string{
        ""123456789.123456789"",
        "".123456789"",
        ""57256.1D-4"",
        ""pi=3.14159265358979323846264338327950288419716939937510582097494459231"",
        ""The author has two Z$100000000000000 Zimbabwe notes (100 trillion)."",
        ""-in Aus$+1411.8millions"",
        ""===US$0017440 millions=== (in 2000 dollars)"",
        ""123.e8000 is pretty big."",
        ""The land area of the earth is 57268900(29% of the surface) square miles."",
        ""Ain't no numbers in this here words, nohow, no way, Jose."",
        ""James was never known as 0000000007"",
        ""Arthur Eddington wrote: I believe there are "" +
            ""15747724136275002577605653961181555468044717914527116709366231425076185631031296"" +
            "" protons in the universe."",
        ""   $-140000±100 millions."",
        ""6/9/1946 was a good year for some."",
    }
    fmt.Println(commatize(tests[0], 0, 2, ""*""))
    fmt.Println(commatize(tests[1], 0, 3, ""-""))
    fmt.Println(commatize(tests[2], 0, 4, ""__""))
    fmt.Println(commatize(tests[3], 0, 5, "" ""))
    fmt.Println(commatize(tests[4], 0, 3, "".""))
    for _, test := range tests[5:] {
        fmt.Println(commatize(test, 0, 3, "",""))
    }
}",2424,75,error,,,,,,,,,,,False,False,,False,
Concurrent computing,"Task

Using either native language concurrency syntax or freely available libraries, write a program to display the strings ""Enjoy"" ""Rosetta"" ""Code"", one string per line, in random order.

Concurrency syntax must use threads, tasks, co-routines, or whatever concurrency is called in your language.



",Go,"package main
 
import (
    ""fmt""
    ""golang.org/x/exp/rand""
    ""time""
)
 
func main() {
    words := []string{""Enjoy"", ""Rosetta"", ""Code""}
    seed := uint64(time.Now().UnixNano())
    q := make(chan string)
    for i, w := range words {
        go func(w string, seed uint64) {
            r := rand.New(rand.NewSource(seed))
            time.Sleep(time.Duration(r.Int63n(1e9)))
            q <- w
        }(w, seed+uint64(i))
    }
    for i := 0; i < len(words); i++ {
        fmt.Println(<-q)
    }
}",506,23,"package main

import (
    ""testing""
    ""strings""
    ""golang.org/x/exp/rand""
    ""time""
)

func TestConcurrentOutput(t *testing.T) {
    words := []string{""Enjoy"", ""Rosetta"", ""Code""}
    seed := uint64(time.Now().UnixNano())
    q := make(chan string)
    for i, w := range words {
        go func(w string, seed uint64) {
            r := rand.New(rand.NewSource(seed))
            time.Sleep(time.Duration(r.Int63n(1e9)))
            q <- w
        }(w, seed+uint64(i))
    }

    receivedWords := make([]string, 0, len(words))
    for i := 0; i < len(words); i++ {
        receivedWords = append(receivedWords, <-q)
    }

    // Check if all words are received
    for _, word := range words {
        if !contains(receivedWords, word) {
            t.Errorf(""Expected word %s not found in output"", word)
        }
    }

    // Check if there are no extra words
    if len(receivedWords) != len(words) {
        t.Errorf(""Expected %d words, but got %d"", len(words), len(receivedWords))
    }
}

func contains(slice []string, item string) bool {
    for _, s := range slice {
        if s == item {
            return true
        }
    }
    return false
}
",./data/generated/docs_golang/concurrent_computing/gpt_4o_2024_08_06_concurrent_computing_test.go,CompileStatus.SYNTAX_ERROR,,,,0.08,0.5,,1.0,"[{'FromLinter': 'typecheck', 'Text': '""strings"" imported and not used', 'Severity': '', 'SourceLines': ['    ""strings""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_concurrent_computing_test.go', 'Offset': 0, 'Line': 5, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_concurrent_computing_test.go', 'line': 5, 'column': 5, 'message': '""strings"" imported and not used'}]"
Continued fraction,"continued fraction
Mathworld





a

0


+









b

1












a

1


+









b

2












a

2


+









b

3












a

3


+
⋱

















{\displaystyle a_{0}+{\cfrac {b_{1}}{a_{1}+{\cfrac {b_{2}}{a_{2}+{\cfrac {b_{3}}{a_{3}+\ddots }}}}}}}


The task is to write a program which generates such a number and prints a real representation of it. The code should be tested by calculating and printing the square root of 2, Napier's Constant, and Pi, using the following coefficients:

For the square root of 2, use 




a

0


=
1


{\displaystyle a_{0}=1}

 then 




a

N


=
2


{\displaystyle a_{N}=2}

. 




b

N




{\displaystyle b_{N}}

 is always 



1


{\displaystyle 1}

.







2


=
1
+








1









2
+








1









2
+








1









2
+
⋱

















{\displaystyle {\sqrt {2}}=1+{\cfrac {1}{2+{\cfrac {1}{2+{\cfrac {1}{2+\ddots }}}}}}}


For Napier's Constant, use 




a

0


=
2


{\displaystyle a_{0}=2}

, then 




a

N


=
N


{\displaystyle a_{N}=N}

. 




b

1


=
1


{\displaystyle b_{1}=1}

 then 




b

N


=
N
−
1


{\displaystyle b_{N}=N-1}

.





e
=
2
+








1









1
+








1









2
+








2









3
+








3









4
+
⋱






















{\displaystyle e=2+{\cfrac {1}{1+{\cfrac {1}{2+{\cfrac {2}{3+{\cfrac {3}{4+\ddots }}}}}}}}}


For Pi, use 




a

0


=
3


{\displaystyle a_{0}=3}

 then 




a

N


=
6


{\displaystyle a_{N}=6}

. 




b

N


=
(
2
N
−
1

)

2




{\displaystyle b_{N}=(2N-1)^{2}}

.





π
=
3
+








1









6
+








9









6
+








25









6
+
⋱

















{\displaystyle \pi =3+{\cfrac {1}{6+{\cfrac {9}{6+{\cfrac {25}{6+\ddots }}}}}}}




See also

   Continued fraction/Arithmetic for tasks that do arithmetic over continued fractions.

",Go,"package main
 
import ""fmt""
 
type cfTerm struct {
    a, b int
}
 
// follows subscript convention of mathworld and WP where there is no b(0).
// cf[0].b is unused in this representation.
type cf []cfTerm
 
func cfSqrt2(nTerms int) cf {
    f := make(cf, nTerms)
    for n := range f {
        f[n] = cfTerm{2, 1}
    }
    f[0].a = 1
    return f
}
 
func cfNap(nTerms int) cf {
    f := make(cf, nTerms)
    for n := range f {
        f[n] = cfTerm{n, n - 1}
    }
    f[0].a = 2
    f[1].b = 1
    return f
}
 
func cfPi(nTerms int) cf {
    f := make(cf, nTerms)
    for n := range f {
        g := 2*n - 1
        f[n] = cfTerm{6, g * g}
    }
    f[0].a = 3
    return f
}
 
func (f cf) real() (r float64) {
    for n := len(f) - 1; n > 0; n-- {
        r = float64(f[n].b) / (float64(f[n].a) + r)
    }
    return r + float64(f[0].a)
}
 
func main() {
    fmt.Println(""sqrt2:"", cfSqrt2(20).real())
    fmt.Println(""nap:  "", cfNap(20).real())
    fmt.Println(""pi:   "", cfPi(20).real())
}",994,53,"package main

import (
	""math""
	""testing""
)

// TestCfSqrt2 tests the continued fraction representation of the square root of 2.
func TestCfSqrt2(t *testing.T) {
	expected := math.Sqrt(2)
	actual := cfSqrt2(20).real()
	if math.Abs(actual-expected) > 1e-9 {
		t.Errorf(""cfSqrt2(20) = %v; want %v"", actual, expected)
	}
}

// TestCfNap tests the continued fraction representation of Napier's Constant (e).
func TestCfNap(t *testing.T) {
	expected := math.E
	actual := cfNap(20).real()
	if math.Abs(actual-expected) > 1e-9 {
		t.Errorf(""cfNap(20) = %v; want %v"", actual, expected)
	}
}

// TestCfPi tests the continued fraction representation of Pi.
func TestCfPi(t *testing.T) {
	expected := math.Pi
	actual := cfPi(20).real()
	if math.Abs(actual-expected) > 1e-9 {
		t.Errorf(""cfPi(20) = %v; want %v"", actual, expected)
	}
}
",./data/generated/docs_golang/continued_fraction/gpt_4o_2024_08_06_continued_fraction_test.go,CompileStatus.OK,0.0,87.0,,0.18,0.33,0.166,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: cfSqrt2', 'Severity': '', 'SourceLines': ['\tactual := cfSqrt2(20).real()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_continued_fraction_test.go', 'Offset': 0, 'Line': 11, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: cfNap', 'Severity': '', 'SourceLines': ['\tactual := cfNap(20).real()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_continued_fraction_test.go', 'Offset': 0, 'Line': 20, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: cfPi', 'Severity': '', 'SourceLines': ['\tactual := cfPi(20).real()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_continued_fraction_test.go', 'Offset': 0, 'Line': 29, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,66.67,False,[]
Convex hull,"Find the points which form a convex hull from a set of arbitrary two dimensional points.

For example, given the points (16,3), (12,17), (0,6), (-4,-6), (16,6), (16,-7), (16,-3), (17,-4), (5,19), (19,-8), (3,16), (12,13), (3,-4), (17,5), (-3,15), (-3,-9), (0,11), (-9,-3), (-4,-2) and (12,10) the convex hull would be (-9,-3), (-3,-9), (19,-8), (17,5), (12,17), (5,19) and (-3,15).




See also
 Convex Hull (youtube)
 http://www.geeksforgeeks.org/convex-hull-set-2-graham-scan/

",Go,"package main
 
import (
	""fmt""
	""image""
	""sort""
)
 
 
// ConvexHull returns the set of points that define the
// convex hull of p in CCW order starting from the left most.
func (p points) ConvexHull() points {
	// From https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain
	// with only minor deviations.
	sort.Sort(p)
	var h points
 
	// Lower hull
	for _, pt := range p {
		for len(h) >= 2 && !ccw(h[len(h)-2], h[len(h)-1], pt) {
			h = h[:len(h)-1]
		}
		h = append(h, pt)
	}
 
	// Upper hull
	for i, t := len(p)-2, len(h)+1; i >= 0; i-- {
		pt := p[i]
		for len(h) >= t && !ccw(h[len(h)-2], h[len(h)-1], pt) {
			h = h[:len(h)-1]
		}
		h = append(h, pt)
	}
 
	return h[:len(h)-1]
}
 
// ccw returns true if the three points make a counter-clockwise turn
func ccw(a, b, c image.Point) bool {
	return ((b.X - a.X) * (c.Y - a.Y)) > ((b.Y - a.Y) * (c.X - a.X))
}
 
type points []image.Point
 
func (p points) Len() int      { return len(p) }
func (p points) Swap(i, j int) { p[i], p[j] = p[j], p[i] }
func (p points) Less(i, j int) bool {
	if p[i].X == p[j].X {
		return p[i].Y < p[i].Y
	}
	return p[i].X < p[j].X
}
 
func main() {
	pts := points{
		{16, 3}, {12, 17}, {0, 6}, {-4, -6}, {16, 6},
		{16, -7}, {16, -3}, {17, -4}, {5, 19}, {19, -8},
		{3, 16}, {12, 13}, {3, -4}, {17, 5}, {-3, 15},
		{-3, -9}, {0, 11}, {-9, -3}, {-4, -2}, {12, 10},
	}
	hull := pts.ConvexHull()
	fmt.Println(""Convex Hull:"", hull)
}",1449,63,"package main

import (
	""image""
	""reflect""
	""testing""
)

func TestConvexHull(t *testing.T) {
	tests := []struct {
		name     string
		points   points
		expected points
	}{
		{
			name: ""Example case"",
			points: points{
				{16, 3}, {12, 17}, {0, 6}, {-4, -6}, {16, 6},
				{16, -7}, {16, -3}, {17, -4}, {5, 19}, {19, -8},
				{3, 16}, {12, 13}, {3, -4}, {17, 5}, {-3, 15},
				{-3, -9}, {0, 11}, {-9, -3}, {-4, -2}, {12, 10},
			},
			expected: points{
				{-9, -3}, {-3, -9}, {19, -8}, {17, 5}, {12, 17}, {5, 19}, {-3, 15},
			},
		},
		{
			name: ""Single point"",
			points: points{
				{0, 0},
			},
			expected: points{
				{0, 0},
			},
		},
		{
			name: ""Two points"",
			points: points{
				{0, 0}, {1, 1},
			},
			expected: points{
				{0, 0}, {1, 1},
			},
		},
		{
			name: ""Collinear points"",
			points: points{
				{0, 0}, {1, 1}, {2, 2}, {3, 3},
			},
			expected: points{
				{0, 0}, {3, 3},
			},
		},
		{
			name: ""Square shape"",
			points: points{
				{0, 0}, {0, 1}, {1, 0}, {1, 1},
			},
			expected: points{
				{0, 0}, {1, 0}, {1, 1}, {0, 1},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := tt.points.ConvexHull()
			if !reflect.DeepEqual(result, tt.expected) {
				t.Errorf(""expected %v, got %v"", tt.expected, result)
			}
		})
	}
}
",./data/generated/docs_golang/convex_hull/gpt_4o_2024_08_06_convex_hull_test.go,CompileStatus.SYNTAX_ERROR,,,,0.03,0.08,,7.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: points', 'Severity': '', 'SourceLines': ['\t\tpoints   points'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_convex_hull_test.go', 'Offset': 0, 'Line': 12, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: points', 'Severity': '', 'SourceLines': ['\t\texpected points'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_convex_hull_test.go', 'Offset': 0, 'Line': 13, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: points', 'Severity': '', 'SourceLines': ['\t\t\tpoints: points{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_convex_hull_test.go', 'Offset': 0, 'Line': 17, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'missing type in composite literal', 'Severity': '', 'SourceLines': ['\t\t\t\t{16, 3}, {12, 17}, {0, 6}, {-4, -6}, {16, 6},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_convex_hull_test.go', 'Offset': 0, 'Line': 18, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'missing type in composite literal', 'Severity': '', 'SourceLines': ['\t\t\t\t{16, -7}, {16, -3}, {17, -4}, {5, 19}, {19, -8},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_convex_hull_test.go', 'Offset': 0, 'Line': 19, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'missing type in composite literal', 'Severity': '', 'SourceLines': ['\t\t\t\t{3, 16}, {12, 13}, {3, -4}, {17, 5}, {-3, 15},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_convex_hull_test.go', 'Offset': 0, 'Line': 20, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""image"" imported and not used', 'Severity': '', 'SourceLines': ['\t""image""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_convex_hull_test.go', 'Offset': 0, 'Line': 4, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_convex_hull_test.go', 'line': 4, 'column': 2, 'message': '""image"" imported and not used'}]"
Conway's Game of Life,"The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.

Conway's game of life is described   here:

A cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.

We calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:

   C   N                 new C
   1   0,1             ->  0  # Lonely
   1   4,5,6,7,8       ->  0  # Overcrowded
   1   2,3             ->  1  # Lives
   0   3               ->  1  # It takes three to give birth!
   0   0,1,2,4,5,6,7,8 ->  0  # Barren

Assume cells beyond the boundary are always dead.

The ""game"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.



Task

Although you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.



References

   Its creator John Conway, explains   the game of life.   Video from numberphile on youtube.
   John Conway   Inventing Game of Life   - Numberphile video.


Related task

   Langton's ant   - another well known cellular automaton.

",Go,"package main
 
import (
	""bytes""
	""fmt""
	""math/rand""
	""time""
)
 
type Field struct {
	s    [][]bool
	w, h int
}
 
func NewField(w, h int) Field {
	s := make([][]bool, h)
	for i := range s {
		s[i] = make([]bool, w)
	}
	return Field{s: s, w: w, h: h}
}
 
func (f Field) Set(x, y int, b bool) {
	f.s[y][x] = b
}
 
func (f Field) Next(x, y int) bool {
	on := 0
	for i := -1; i <= 1; i++ {
		for j := -1; j <= 1; j++ {
			if f.State(x+i, y+j) && !(j == 0 && i == 0) {
				on++
			}
		}
	}
	return on == 3 || on == 2 && f.State(x, y)
}
 
func (f Field) State(x, y int) bool {
	for y < 0 {
		y += f.h
	}
	for x < 0 {
		x += f.w
	}
	return f.s[y%f.h][x%f.w]
}
 
type Life struct {
	w, h int
	a, b Field
}
 
func NewLife(w, h int) *Life {
	a := NewField(w, h)
	for i := 0; i < (w * h / 2); i++ {
		a.Set(rand.Intn(w), rand.Intn(h), true)
	}
	return &Life{
		a: a,
		b: NewField(w, h),
		w: w, h: h,
	}
}
 
func (l *Life) Step() {
	for y := 0; y < l.h; y++ {
		for x := 0; x < l.w; x++ {
			l.b.Set(x, y, l.a.Next(x, y))
		}
	}
	l.a, l.b = l.b, l.a
}
 
func (l *Life) String() string {
	var buf bytes.Buffer
	for y := 0; y < l.h; y++ {
		for x := 0; x < l.w; x++ {
			b := byte(' ')
			if l.a.State(x, y) {
				b = '*'
			}
			buf.WriteByte(b)
		}
		buf.WriteByte('\n')
	}
	return buf.String()
}
 
func main() {
	l := NewLife(80, 15)
	for i := 0; i < 300; i++ {
		l.Step()
		fmt.Print(""\x0c"")
		fmt.Println(l)
		time.Sleep(time.Second / 30)
	}
}",1436,98,"package main

import (
	""testing""
)

func TestBlinker(t *testing.T) {
	// Initialize a 3x3 grid
	life := &Life{
		w: 3,
		h: 3,
		a: NewField(3, 3),
		b: NewField(3, 3),
	}

	// Set up the blinker pattern
	life.a.Set(0, 1, true)
	life.a.Set(1, 1, true)
	life.a.Set(2, 1, true)

	// Expected pattern after 1st generation
	expectedGen1 := [][]bool{
		{false, true, false},
		{false, true, false},
		{false, true, false},
	}

	// Expected pattern after 2nd generation (should be same as initial)
	expectedGen2 := [][]bool{
		{false, false, false},
		{true, true, true},
		{false, false, false},
	}

	// Expected pattern after 3rd generation (should be same as 1st)
	expectedGen3 := [][]bool{
		{false, true, false},
		{false, true, false},
		{false, true, false},
	}

	// Step 1
	life.Step()
	assertFieldState(t, life.a, expectedGen1, ""Generation 1"")

	// Step 2
	life.Step()
	assertFieldState(t, life.a, expectedGen2, ""Generation 2"")

	// Step 3
	life.Step()
	assertFieldState(t, life.a, expectedGen3, ""Generation 3"")
}

func assertFieldState(t *testing.T, field Field, expected [][]bool, generation string) {
	for y := 0; y < field.h; y++ {
		for x := 0; x < field.w; x++ {
			if field.State(x, y) != expected[y][x] {
				t.Errorf(""Mismatch in %s at (%d, %d): expected %v, got %v"", generation, x, y, expected[y][x], field.State(x, y))
			}
		}
	}
}
",./data/generated/docs_golang/conway_s_game_of_life/gpt_4o_2024_08_06_conway_s_game_of_life_test.go,CompileStatus.OK,0.0,51.3,,0.03,0.04,0.169,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: Field', 'Severity': '', 'SourceLines': ['func assertFieldState(t *testing.T, field Field, expected [][]bool, generation string) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_conway_s_game_of_life_test.go', 'Offset': 0, 'Line': 55, 'Column': 43}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Life', 'Severity': '', 'SourceLines': ['\tlife := &Life{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_conway_s_game_of_life_test.go', 'Offset': 0, 'Line': 9, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: NewField', 'Severity': '', 'SourceLines': ['\t\ta: NewField(3, 3),'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_conway_s_game_of_life_test.go', 'Offset': 0, 'Line': 12, 'Column': 6}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: NewField', 'Severity': '', 'SourceLines': ['\t\tb: NewField(3, 3),'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_conway_s_game_of_life_test.go', 'Offset': 0, 'Line': 13, 'Column': 6}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Count in factors,"Task

Write a program which counts up from   1,   displaying each number as the multiplication of its prime factors.

For the purpose of this task,   1   (unity)   may be shown as itself.



Example

      2   is prime,   so it would be shown as itself.

      6   is not prime;   it would be shown as   



2
×
3


{\displaystyle 2\times 3}

.
2144   is not prime;   it would be shown as   



2
×
2
×
2
×
2
×
2
×
67


{\displaystyle 2\times 2\times 2\times 2\times 2\times 67}

.



Related tasks

   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes

",Go,"package main
 
import ""fmt""
 
func main() {
    fmt.Println(""1: 1"")
    for i := 2; ; i++ {
        fmt.Printf(""%d: "", i)
        var x string
        for n, f := i, 2; n != 1; f++ {
            for m := n % f; m == 0; m = n % f {
                fmt.Print(x, f)
                x = ""×""
                n /= f
            }
        }
        fmt.Println()
    }
}",363,19,"package main

import (
	""fmt""
	""testing""
)

// Mock function to simulate the behavior of the original code
func countInFactors(limit int) []string {
	results := []string{""1: 1""}
	for i := 2; i <= limit; i++ {
		result := fmt.Sprintf(""%d: "", i)
		var x string
		for n, f := i, 2; n != 1; f++ {
			for m := n % f; m == 0; m = n % f {
				result += fmt.Sprintf(""%s%d"", x, f)
				x = ""×""
				n /= f
			}
		}
		results = append(results, result)
	}
	return results
}

func TestCountInFactors(t *testing.T) {
	tests := []struct {
		limit    int
		expected []string
	}{
		{
			limit: 1,
			expected: []string{
				""1: 1"",
			},
		},
		{
			limit: 2,
			expected: []string{
				""1: 1"",
				""2: 2"",
			},
		},
		{
			limit: 3,
			expected: []string{
				""1: 1"",
				""2: 2"",
				""3: 3"",
			},
		},
		{
			limit: 6,
			expected: []string{
				""1: 1"",
				""2: 2"",
				""3: 3"",
				""4: 2×2"",
				""5: 5"",
				""6: 2×3"",
			},
		},
		{
			limit: 10,
			expected: []string{
				""1: 1"",
				""2: 2"",
				""3: 3"",
				""4: 2×2"",
				""5: 5"",
				""6: 2×3"",
				""7: 7"",
				""8: 2×2×2"",
				""9: 3×3"",
				""10: 2×5"",
			},
		},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""Limit %d"", test.limit), func(t *testing.T) {
			result := countInFactors(test.limit)
			if len(result) != len(test.expected) {
				t.Fatalf(""expected length %d, got %d"", len(test.expected), len(result))
			}
			for i, expected := range test.expected {
				if result[i] != expected {
					t.Errorf(""expected %q, got %q"", expected, result[i])
				}
			}
		})
	}
}
",./data/generated/docs_golang/count_in_factors/gpt_4o_2024_08_06_count_in_factors_test.go,CompileStatus.OK,0.0,0.0,,0.06,0.5,0.113,0.0,[],False,False,100.0,False,[]
Cramer's rule,"linear algebra
Cramer's rule
system of linear equations


Given


 




{





a

1


x
+

b

1


y
+

c

1


z


=



d

1









a

2


x
+

b

2


y
+

c

2


z


=



d

2









a

3


x
+

b

3


y
+

c

3


z


=



d

3












{\displaystyle \left\{{\begin{matrix}a_{1}x+b_{1}y+c_{1}z&={\color {red}d_{1}}\\a_{2}x+b_{2}y+c_{2}z&={\color {red}d_{2}}\\a_{3}x+b_{3}y+c_{3}z&={\color {red}d_{3}}\end{matrix}}\right.}




which in matrix format is



 





[




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





]




[



x




y




z



]


=


[






d

1











d

2











d

3







]


.


{\displaystyle {\begin{bmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{bmatrix}}{\begin{bmatrix}x\\y\\z\end{bmatrix}}={\begin{bmatrix}{\color {red}d_{1}}\\{\color {red}d_{2}}\\{\color {red}d_{3}}\end{bmatrix}}.}




Then the values of 



x
,
y


{\displaystyle x,y}

 and 



z


{\displaystyle z}

 can be found as follows:







x
=



|






d

1







b

1





c

1









d

2







b

2





c

2









d

3







b

3





c

3





|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



,

y
=



|




a

1







d

1







c

1







a

2







d

2







c

2







a

3







d

3







c

3





|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



,

 and 

z
=



|




a

1





b

1







d

1









a

2





b

2







d

2









a

3





b

3







d

3







|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



.


{\displaystyle x={\frac {\begin{vmatrix}{\color {red}d_{1}}&b_{1}&c_{1}\\{\color {red}d_{2}}&b_{2}&c_{2}\\{\color {red}d_{3}}&b_{3}&c_{3}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}},\quad y={\frac {\begin{vmatrix}a_{1}&{\color {red}d_{1}}&c_{1}\\a_{2}&{\color {red}d_{2}}&c_{2}\\a_{3}&{\color {red}d_{3}}&c_{3}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}},{\text{ and }}z={\frac {\begin{vmatrix}a_{1}&b_{1}&{\color {red}d_{1}}\\a_{2}&b_{2}&{\color {red}d_{2}}\\a_{3}&b_{3}&{\color {red}d_{3}}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}}.}






Task
Given the following system of equations:









{



2
w
−
x
+
5
y
+
z
=
−
3




3
w
+
2
x
+
2
y
−
6
z
=
−
32




w
+
3
x
+
3
y
−
z
=
−
47




5
w
−
2
x
−
3
y
+
3
z
=
49








{\displaystyle {\begin{cases}2w-x+5y+z=-3\\3w+2x+2y-6z=-32\\w+3x+3y-z=-47\\5w-2x-3y+3z=49\\\end{cases}}}




solve for 



w


{\displaystyle w}

, 



x


{\displaystyle x}

, 



y


{\displaystyle y}

 and 



z


{\displaystyle z}

, using Cramer's rule.



",Go,"package main
 
import (
    ""fmt""
 
    ""gonum.org/v1/gonum/mat""
)
 
var m = mat.NewDense(4, 4, []float64{
    2, -1, 5, 1,
    3, 2, 2, -6,
    1, 3, 3, -1,
    5, -2, -3, 3,
})
 
var v = []float64{-3, -32, -47, 49}
 
func main() {
    x := make([]float64, len(v))
    b := make([]float64, len(v))
    d := mat.Det(m)
    for c := range v {
        mat.Col(b, c, m)
        m.SetCol(c, v)
        x[c] = mat.Det(m) / d
        m.SetCol(c, b)
    }
    fmt.Println(x)
}",469,29,"package main

import (
	""math""
	""testing""

	""gonum.org/v1/gonum/mat""
)

func TestCramersRule(t *testing.T) {
	// Define the matrix and vector as in the main function
	m := mat.NewDense(4, 4, []float64{
		2, -1, 5, 1,
		3, 2, 2, -6,
		1, 3, 3, -1,
		5, -2, -3, 3,
	})
	v := []float64{-3, -32, -47, 49}

	// Expected results calculated manually or using a reliable tool
	expected := []float64{1, -5, 2, -3}

	// Calculate the determinant of the original matrix
	d := mat.Det(m)

	// Solve using Cramer's rule
	x := make([]float64, len(v))
	b := make([]float64, len(v))
	for c := range v {
		mat.Col(b, c, m)
		m.SetCol(c, v)
		x[c] = mat.Det(m) / d
		m.SetCol(c, b)
	}

	// Compare the results with expected values
	for i := range x {
		if !almostEqual(x[i], expected[i], 1e-9) {
			t.Errorf(""Expected x[%d] = %v, but got %v"", i, expected[i], x[i])
		}
	}
}

// Helper function to compare floating-point numbers with a tolerance
func almostEqual(a, b, tolerance float64) bool {
	return math.Abs(a-b) <= tolerance
}
",./data/generated/docs_golang/cramer_s_rule/gpt_4o_2024_08_06_cramer_s_rule_test.go,CompileStatus.OK,0.0,0.0,,0.04,0.5,0.133,0.0,[],False,False,0.0,False,[]
Create a file,"In this task, the job is to create a new empty file called ""output.txt"" of size 0 bytes
and an empty directory called ""docs"". This should be done twice: once ""here"", i.e. in the current working directory and once in the filesystem root.
",Go,"package main
 
import (
    ""fmt""
    ""os""
)
 
func createFile(fn string) {
    f, err := os.Create(fn)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(""file"", fn, ""created!"")
    f.Close()
}
 
func createDir(dn string) {
    err := os.Mkdir(dn, 0666)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(""directory"", dn, ""created!"")
}
 
func main() {
    createFile(""input.txt"")
    createFile(""/input.txt"")
    createDir(""docs"")
    createDir(""/docs"")
}",518,32,"package main

import (
    ""os""
    ""testing""
)

func TestCreateFile(t *testing.T) {
    // Test creating a file in the current directory
    createFile(""output.txt"")
    if _, err := os.Stat(""output.txt""); os.IsNotExist(err) {
        t.Errorf(""File output.txt was not created in the current directory"")
    } else {
        os.Remove(""output.txt"") // Clean up
    }

    // Test creating a file in the root directory
    createFile(""/output.txt"")
    if _, err := os.Stat(""/output.txt""); os.IsNotExist(err) {
        t.Errorf(""File /output.txt was not created in the root directory"")
    } else {
        os.Remove(""/output.txt"") // Clean up
    }
}

func TestCreateDir(t *testing.T) {
    // Test creating a directory in the current directory
    createDir(""docs"")
    if _, err := os.Stat(""docs""); os.IsNotExist(err) {
        t.Errorf(""Directory docs was not created in the current directory"")
    } else {
        os.Remove(""docs"") // Clean up
    }

    // Test creating a directory in the root directory
    createDir(""/docs"")
    if _, err := os.Stat(""/docs""); os.IsNotExist(err) {
        t.Errorf(""Directory /docs was not created in the root directory"")
    } else {
        os.Remove(""/docs"") // Clean up
    }
}
",./data/generated/docs_golang/create_a_file/gpt_4o_2024_08_06_create_a_file_test.go,CompileStatus.OK,0.0,46.7,,0.17,0.8,0.156,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: createFile', 'Severity': '', 'SourceLines': ['    createFile(""output.txt"")'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_create_a_file_test.go', 'Offset': 0, 'Line': 10, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: createFile', 'Severity': '', 'SourceLines': ['    createFile(""/output.txt"")'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_create_a_file_test.go', 'Offset': 0, 'Line': 18, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: createDir', 'Severity': '', 'SourceLines': ['    createDir(""docs"")'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_create_a_file_test.go', 'Offset': 0, 'Line': 28, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: createDir', 'Severity': '', 'SourceLines': ['    createDir(""/docs"")'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_create_a_file_test.go', 'Offset': 0, 'Line': 36, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Create a two-dimensional array at runtime,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
Get two integers from the user, then create a two-dimensional array where the two dimensions have the sizes given by those numbers, and which can be accessed in the most natural way possible. Write some element of that array, and then output that element. Finally destroy the array if not done by the language itself.
",Go,"package main
 
import ""fmt""
 
func main() {
    var row, col int
    fmt.Print(""enter rows cols: "")
    fmt.Scan(&row, &col)
 
    // allocate composed 2d array
    a := make([][]int, row)
    for i := range a {
        a[i] = make([]int, col)
    }
 
    // array elements initialized to 0
    fmt.Println(""a[0][0] ="", a[0][0])
 
    // assign
    a[row-1][col-1] = 7
 
    // retrieve
    fmt.Printf(""a[%d][%d] = %d\n"", row-1, col-1, a[row-1][col-1])
 
    // remove only reference
    a = nil
    // memory allocated earlier with make can now be garbage collected.
}",569,28,"package main

import (
	""bytes""
	""fmt""
	""testing""
)

func TestCreateTwoDimensionalArray(t *testing.T) {
	tests := []struct {
		row, col int
		expected string
	}{
		{2, 3, ""a[0][0] = 0\na[1][2] = 7\n""},
		{1, 1, ""a[0][0] = 0\na[0][0] = 7\n""},
		{3, 2, ""a[0][0] = 0\na[2][1] = 7\n""},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""row=%d,col=%d"", test.row, test.col), func(t *testing.T) {
			// Redirect standard output to capture the prints
			var buf bytes.Buffer
			fmtPrint = func(a ...interface{}) (n int, err error) {
				return fmt.Fprint(&buf, a...)
			}
			fmtPrintf = func(format string, a ...interface{}) (n int, err error) {
				return fmt.Fprintf(&buf, format, a...)
			}

			// Simulate user input
			fmtScan = func(a ...interface{}) (n int, err error) {
				*a[0].(*int) = test.row
				*a[1].(*int) = test.col
				return 2, nil
			}

			main()

			// Check the output
			if buf.String() != test.expected {
				t.Errorf(""expected %q, got %q"", test.expected, buf.String())
			}
		})
	}
}

// Mock functions to replace fmt.Scan, fmt.Print, and fmt.Printf
var fmtScan = fmt.Scan
var fmtPrint = fmt.Print
var fmtPrintf = fmt.Printf
",./data/generated/docs_golang/create_a_two_dimensional_array_at_runtime/gpt_4o_2024_08_06_create_a_two_dimensional_array_at_runtime_test.go,CompileStatus.OK,2.0,,,0.04,0.5,0.087,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\t\t\tmain()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_create_a_two_dimensional_array_at_runtime_test.go', 'Offset': 0, 'Line': 37, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Create an HTML table,"Create an HTML table.

 The table body should have at least three rows of three columns.
 Each of these three columns should be labelled ""X"", ""Y"", and ""Z"". 
 An extra column should be added at either the extreme left or the extreme right of the table that has no heading, but is filled with sequential row numbers. 
 The rows of the ""X"", ""Y"", and ""Z"" columns should be filled with random or sequential integers having 4 digits or less. 
 The numbers should be aligned in the same fashion for all columns.

",Go,"package main
 
import (
    ""fmt""
    ""html/template""
    ""os""
)
 
type row struct {
    X, Y, Z int
}
 
var tmpl = `<table>
    <tr><th></th><th>X</th><th>Y</th><th>Z</th></tr>
{{range $ix, $row := .}}    <tr><td>{{$ix}}</td>
        <td>{{$row.X}}</td>
        <td>{{$row.Y}}</td>
        <td>{{$row.Z}}</td></tr>
{{end}}</table>
`
 
func main() {
    // create template
    ct := template.Must(template.New("""").Parse(tmpl))
 
    // make up data
    data := make([]row, 4)
    for r := range data {
        data[r] = row{r*3, r*3+1, r*3+2}
    }
 
    // apply template to data
    if err := ct.Execute(os.Stdout, data); err != nil {
        fmt.Println(err)
    }
}",669,36,"package main

import (
	""bytes""
	""html/template""
	""testing""
)

type row struct {
	X, Y, Z int
}

var tmpl = `<table>
    <tr><th></th><th>X</th><th>Y</th><th>Z</th></tr>
{{range $ix, $row := .}}    <tr><td>{{$ix}}</td>
        <td>{{$row.X}}</td>
        <td>{{$row.Y}}</td>
        <td>{{$row.Z}}</td></tr>
{{end}}</table>
`

func TestHTMLTableGeneration(t *testing.T) {
	tests := []struct {
		name     string
		data     []row
		expected string
	}{
		{
			name: ""Test with 3 rows"",
			data: []row{
				{X: 1000, Y: 2000, Z: 3000},
				{X: 4000, Y: 5000, Z: 6000},
				{X: 7000, Y: 8000, Z: 9000},
			},
			expected: `<table>
    <tr><th></th><th>X</th><th>Y</th><th>Z</th></tr>
    <tr><td>0</td>
        <td>1000</td>
        <td>2000</td>
        <td>3000</td></tr>
    <tr><td>1</td>
        <td>4000</td>
        <td>5000</td>
        <td>6000</td></tr>
    <tr><td>2</td>
        <td>7000</td>
        <td>8000</td>
        <td>9000</td></tr>
</table>
`,
		},
		{
			name: ""Test with no rows"",
			data: []row{},
			expected: `<table>
    <tr><th></th><th>X</th><th>Y</th><th>Z</th></tr>
</table>
`,
		},
		{
			name: ""Test with 1 row"",
			data: []row{
				{X: 123, Y: 456, Z: 789},
			},
			expected: `<table>
    <tr><th></th><th>X</th><th>Y</th><th>Z</th></tr>
    <tr><td>0</td>
        <td>123</td>
        <td>456</td>
        <td>789</td></tr>
</table>
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ct := template.Must(template.New("""").Parse(tmpl))
			var buf bytes.Buffer
			if err := ct.Execute(&buf, tt.data); err != nil {
				t.Fatalf(""Failed to execute template: %v"", err)
			}
			if buf.String() != tt.expected {
				t.Errorf(""Expected:\n%s\nGot:\n%s"", tt.expected, buf.String())
			}
		})
	}
}
",./data/generated/docs_golang/create_an_html_table/gpt_4o_2024_08_06_create_an_html_table_test.go,CompileStatus.SYNTAX_ERROR,,,,0.06,0.67,,0.0,[],False,False,,False,"[{'file': './gpt_4o_2024_08_06_create_an_html_table_test.go', 'line': 9, 'column': 6, 'message': 'row redeclared in this block'}]"
Cuban primes,"The name   cuban   has nothing to do with   Cuba  (the country),   but has to do with the
fact that cubes   (3rd powers)   play a role in its definition.



Some definitions of cuban primes

   primes which are the difference of two consecutive cubes.
   primes of the form:   (n+1)3 - n3.
   primes of the form:   n3 - (n-1)3.
   primes   p   such that   n2(p+n)   is a cube for some   n>0.
   primes   p   such that   4p = 1 + 3n2.


Cuban primes were named in 1923 by Allan Joseph Champneys Cunningham.



Task requirements

   show the first   200   cuban primes   (in a multi─line horizontal format).
   show the   100,000th   cuban prime.
   show all cuban primes with commas   (if appropriate).
   show all output here.


Note that   cuban prime   isn't capitalized   (as it doesn't refer to the nation of Cuba).



Also see

   Wikipedia entry:     cuban prime.
   MathWorld entry:   cuban prime.
   The OEIS entry:     A002407.     The   100,000th   cuban prime can be verified in the   2nd   example   on this OEIS web page.

",Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func commatize(n uint64) string {
    s := fmt.Sprintf(""%d"", n)
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    return s
}
 
func main() {
    var z big.Int
    var cube1, cube2, cube100k, diff uint64
    cubans := make([]string, 200)
    cube1 = 1
    count := 0
    for i := 1; ; i++ {
        j := i + 1
        cube2 = uint64(j * j * j)
        diff = cube2 - cube1
        z.SetUint64(diff)
        if z.ProbablyPrime(0) { // 100% accurate for z < 2 ^ 64
            if count < 200 {
                cubans[count] = commatize(diff)
            }
            count++
            if count == 100000 {
                cube100k = diff
                break
            }
        }
        cube1 = cube2
    }
    fmt.Println(""The first 200 cuban primes are:-"")
    for i := 0; i < 20; i++ {
        j := i * 10 
        fmt.Printf(""%9s\n"", cubans[j : j+10]) // 10 per line say
    }
    fmt.Println(""\nThe 100,000th cuban prime is"", commatize(cube100k))
}",1059,46,"package main

import (
	""testing""
	""math/big""
	""strings""
)

// TestCommatize tests the commatize function for various cases.
func TestCommatize(t *testing.T) {
	tests := []struct {
		input    uint64
		expected string
	}{
		{1000, ""1,000""},
		{1000000, ""1,000,000""},
		{123456789, ""123,456,789""},
		{0, ""0""},
		{999, ""999""},
	}

	for _, test := range tests {
		result := commatize(test.input)
		if result != test.expected {
			t.Errorf(""commatize(%d) = %s; expected %s"", test.input, result, test.expected)
		}
	}
}

// TestCubanPrimes tests the generation of cuban primes.
func TestCubanPrimes(t *testing.T) {
	var z big.Int
	var cube1, cube2, diff uint64
	cubans := make([]string, 200)
	cube1 = 1
	count := 0
	var cube100k uint64

	for i := 1; ; i++ {
		j := i + 1
		cube2 = uint64(j * j * j)
		diff = cube2 - cube1
		z.SetUint64(diff)
		if z.ProbablyPrime(0) {
			if count < 200 {
				cubans[count] = commatize(diff)
			}
			count++
			if count == 100000 {
				cube100k = diff
				break
			}
		}
		cube1 = cube2
	}

	// Verify the first 200 cuban primes
	expectedFirst200 := []string{
		""7"", ""19"", ""37"", ""61"", ""127"", ""271"", ""397"", ""547"", ""757"", ""907"",
		""1,081"", ""1,487"", ""1,867"", ""2,137"", ""2,197"", ""2,617"", ""3,097"", ""3,307"", ""3,757"", ""4,081"",
		// Add more expected values as needed
	}

	for i, expected := range expectedFirst200 {
		if cubans[i] != expected {
			t.Errorf(""First 200 cuban primes mismatch at index %d: got %s, expected %s"", i, cubans[i], expected)
		}
	}

	// Verify the 100,000th cuban prime
	expected100k := ""1,215,716,827,157""
	if commatize(cube100k) != expected100k {
		t.Errorf(""100,000th cuban prime mismatch: got %s, expected %s"", commatize(cube100k), expected100k)
	}
}

// TestOutputFormat tests the output format of the cuban primes.
func TestOutputFormat(t *testing.T) {
	var z big.Int
	var cube1, cube2, diff uint64
	cubans := make([]string, 200)
	cube1 = 1
	count := 0
	var cube100k uint64

	for i := 1; ; i++ {
		j := i + 1
		cube2 = uint64(j * j * j)
		diff = cube2 - cube1
		z.SetUint64(diff)
		if z.ProbablyPrime(0) {
			if count < 200 {
				cubans[count] = commatize(diff)
			}
			count++
			if count == 100000 {
				cube100k = diff
				break
			}
		}
		cube1 = cube2
	}

	// Check the format of the first 200 cuban primes
	output := strings.Join(cubans, "", "")
	if !strings.Contains(output, ""7, 19, 37"") {
		t.Errorf(""Output format for first 200 cuban primes is incorrect: %s"", output)
	}

	// Check the format of the 100,000th cuban prime
	if commatize(cube100k) != ""1,215,716,827,157"" {
		t.Errorf(""Output format for 100,000th cuban prime is incorrect: %s"", commatize(cube100k))
	}
}
",./data/generated/docs_golang/cuban_primes/gpt_4o_2024_08_06_cuban_primes_test.go,CompileStatus.OK,,,,0.09,0.75,,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: commatize', 'Severity': '', 'SourceLines': ['\t\tresult := commatize(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cuban_primes_test.go', 'Offset': 0, 'Line': 23, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: commatize', 'Severity': '', 'SourceLines': ['\t\t\t\tcubans[count] = commatize(diff)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cuban_primes_test.go', 'Offset': 0, 'Line': 46, 'Column': 21}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: commatize', 'Severity': '', 'SourceLines': ['\tif commatize(cube100k) != expected100k {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cuban_primes_test.go', 'Offset': 0, 'Line': 72, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,True,[]
Currency,"Task

Show how to represent currency in a simple example, using a data type that represent exact values of dollars and cents.



Note

The IEEE 754 binary floating point representations of numbers like   2.86   and   .0765   are not exact.

For this example, data will be two items with prices in dollars and cents, a quantity for each, and a tax rate.

Use the values:

 4000000000000000 hamburgers at $5.50 each       (four quadrillion burgers)
 2 milkshakes at $2.86 each, and 
 a tax rate of 7.65%. 


(That number of hamburgers is a 4 with 15 zeros after it.   The number is contrived to exclude naïve task solutions using 64 bit floating point types.)

Compute and output (show results on this page):

 the total price before tax
 the tax
 the total with tax 


The tax value must be computed by rounding to the nearest whole cent and this exact value must be added to the total price before tax.

The output must show dollars and cents with a decimal point.

The three results displayed should be:

 22000000000000005.72
 1683000000000000.44 
 23683000000000006.16 


Dollar signs and thousands separators are optional.



",Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math/big""
)
 
// DC for dollars and cents.  Value is an integer number of cents.
type DC int64
 
func (dc DC) String() string {
    d := dc / 100
    if dc < 0 {
        dc = -dc
    }
    return fmt.Sprintf(""%d.%02d"", d, dc%100)
}
 
// Extend returns extended price of a unit price.
func (dc DC) Extend(n int) DC {
    return dc * DC(n)
}
 
var one = big.NewInt(1)
var hundred = big.NewRat(100, 1)
 
// ParseDC parses dollars and cents as a string into a DC.
func ParseDC(s string) (DC, bool) {
    r, ok := new(big.Rat).SetString(s)
    if !ok {
        return 0, false
    }
    r.Mul(r, hundred)
    if r.Denom().Cmp(one) != 0 {
        return 0, false
    }
    return DC(r.Num().Int64()), true
}
 
// TR for tax rate.  Value is an an exact rational.
type TR struct {
    *big.Rat
}
func NewTR() TR {
    return TR{new(big.Rat)}
}
 
// SetString overrides Rat.SetString to return the TR type.
func (tr TR) SetString(s string) (TR, bool) {
    if _, ok := tr.Rat.SetString(s); !ok {
        return TR{}, false
    }
    return tr, true
}
 
var half = big.NewRat(1, 2)
 
// Tax computes a tax amount, rounding to the nearest cent.
func (tr TR) Tax(dc DC) DC {
    r := big.NewRat(int64(dc), 1)
    r.Add(r.Mul(r, tr.Rat), half)
    return DC(new(big.Int).Div(r.Num(), r.Denom()).Int64())
}
 
func main() {
    hamburgerPrice, ok := ParseDC(""5.50"")
    if !ok {
        log.Fatal(""Invalid hamburger price"")
    }
    milkshakePrice, ok := ParseDC(""2.86"")
    if !ok {
        log.Fatal(""Invalid milkshake price"")
    }
    taxRate, ok := NewTR().SetString(""0.0765"")
    if !ok {
        log.Fatal(""Invalid tax rate"")
    }
 
    totalBeforeTax := hamburgerPrice.Extend(4000000000000000) +
        milkshakePrice.Extend(2)
    tax := taxRate.Tax(totalBeforeTax)
    total := totalBeforeTax + tax
 
    fmt.Printf(""Total before tax: %22s\n"", totalBeforeTax)
    fmt.Printf(""             Tax: %22s\n"", tax)
    fmt.Printf(""           Total: %22s\n"", total)
}",2006,88,"package main

import (
    ""testing""
)

func TestParseDC(t *testing.T) {
    tests := []struct {
        input    string
        expected DC
        valid    bool
    }{
        {""5.50"", 550, true},
        {""2.86"", 286, true},
        {""0.00"", 0, true},
        {""invalid"", 0, false},
        {""5.505"", 0, false}, // Invalid due to more than two decimal places
    }

    for _, test := range tests {
        result, valid := ParseDC(test.input)
        if result != test.expected || valid != test.valid {
            t.Errorf(""ParseDC(%s) = %d, %v; expected %d, %v"", test.input, result, valid, test.expected, test.valid)
        }
    }
}

func TestDCString(t *testing.T) {
    tests := []struct {
        input    DC
        expected string
    }{
        {550, ""5.50""},
        {286, ""2.86""},
        {0, ""0.00""},
        {-550, ""-5.50""},
    }

    for _, test := range tests {
        result := test.input.String()
        if result != test.expected {
            t.Errorf(""DC(%d).String() = %s; expected %s"", test.input, result, test.expected)
        }
    }
}

func TestDCExtend(t *testing.T) {
    tests := []struct {
        price    DC
        quantity int
        expected DC
    }{
        {550, 2, 1100},
        {286, 3, 858},
        {0, 5, 0},
    }

    for _, test := range tests {
        result := test.price.Extend(test.quantity)
        if result != test.expected {
            t.Errorf(""DC(%d).Extend(%d) = %d; expected %d"", test.price, test.quantity, result, test.expected)
        }
    }
}

func TestTRSetString(t *testing.T) {
    tests := []struct {
        input    string
        expected bool
    }{
        {""0.0765"", true},
        {""0.00"", true},
        {""invalid"", false},
    }

    for _, test := range tests {
        tr := NewTR()
        _, valid := tr.SetString(test.input)
        if valid != test.expected {
            t.Errorf(""TR.SetString(%s) = %v; expected %v"", test.input, valid, test.expected)
        }
    }
}

func TestTRTax(t *testing.T) {
    taxRate, _ := NewTR().SetString(""0.0765"")

    tests := []struct {
        amount   DC
        expected DC
    }{
        {22000000000000005, 1683000000000000},
        {100, 8}, // 7.65% of 100 is 7.65, rounded to 8
        {0, 0},
    }

    for _, test := range tests {
        result := taxRate.Tax(test.amount)
        if result != test.expected {
            t.Errorf(""TR.Tax(%d) = %d; expected %d"", test.amount, result, test.expected)
        }
    }
}

func TestMainCalculation(t *testing.T) {
    hamburgerPrice, _ := ParseDC(""5.50"")
    milkshakePrice, _ := ParseDC(""2.86"")
    taxRate, _ := NewTR().SetString(""0.0765"")

    totalBeforeTax := hamburgerPrice.Extend(4000000000000000) +
        milkshakePrice.Extend(2)
    tax := taxRate.Tax(totalBeforeTax)
    total := totalBeforeTax + tax

    if totalBeforeTax != 22000000000000005 {
        t.Errorf(""Total before tax = %d; expected 22000000000000005"", totalBeforeTax)
    }
    if tax != 1683000000000000 {
        t.Errorf(""Tax = %d; expected 1683000000000000"", tax)
    }
    if total != 23683000000000006 {
        t.Errorf(""Total = %d; expected 23683000000000006"", total)
    }
}
",./data/generated/docs_golang/currency/gpt_4o_2024_08_06_currency_test.go,CompileStatus.OK,0.0,55.9,,0.1,0.57,0.146,9.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: DC', 'Severity': '', 'SourceLines': ['        expected DC'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_currency_test.go', 'Offset': 0, 'Line': 10, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: ParseDC', 'Severity': '', 'SourceLines': ['        result, valid := ParseDC(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_currency_test.go', 'Offset': 0, 'Line': 21, 'Column': 26}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: DC', 'Severity': '', 'SourceLines': ['        input    DC'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_currency_test.go', 'Offset': 0, 'Line': 30, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: DC', 'Severity': '', 'SourceLines': ['        price    DC'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_currency_test.go', 'Offset': 0, 'Line': 49, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: NewTR', 'Severity': '', 'SourceLines': ['        tr := NewTR()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_currency_test.go', 'Offset': 0, 'Line': 77, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: NewTR', 'Severity': '', 'SourceLines': ['    taxRate, _ := NewTR().SetString(""0.0765"")'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_currency_test.go', 'Offset': 0, 'Line': 86, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: ParseDC', 'Severity': '', 'SourceLines': ['    hamburgerPrice, _ := ParseDC(""5.50"")'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_currency_test.go', 'Offset': 0, 'Line': 106, 'Column': 26}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: ParseDC', 'Severity': '', 'SourceLines': ['    milkshakePrice, _ := ParseDC(""2.86"")'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_currency_test.go', 'Offset': 0, 'Line': 107, 'Column': 26}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: NewTR', 'Severity': '', 'SourceLines': ['    taxRate, _ := NewTR().SetString(""0.0765"")'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_currency_test.go', 'Offset': 0, 'Line': 108, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,83.33,False,[]
Cyclotomic polynomial,"The nth Cyclotomic polynomial, for any positive integer n, is the unique irreducible polynomial of largest degree with integer coefficients that is a divisor of x^n − 1, and is not a divisor of x^k − 1 for any k < n.



Task

 Find and print the first 30 cyclotomic polynomials.
 Find and print the order of the first 10 cyclotomic polynomials that have n or -n as a coefficient.


See also
 Wikipedia article, Cyclotomic polynomial, showing ways to calculate them.
 The sequence A013594 with the smallest order of cyclotomic polynomial containing n or -n as a coefficient.",Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math""
    ""sort""
    ""strings""
)
 
const (
    algo          = 2
    maxAllFactors = 100000
)
 
func iabs(i int) int {
    if i < 0 {
        return -i
    }
    return i
}
 
type term struct{ coef, exp int }
 
func (t term) mul(t2 term) term {
    return term{t.coef * t2.coef, t.exp + t2.exp}
}
 
func (t term) add(t2 term) term {
    if t.exp != t2.exp {
        log.Fatal(""exponents unequal in term.add method"")
    }
    return term{t.coef + t2.coef, t.exp}
}
 
func (t term) negate() term { return term{-t.coef, t.exp} }
 
func (t term) String() string {
    switch {
    case t.coef == 0:
        return ""0""
    case t.exp == 0:
        return fmt.Sprintf(""%d"", t.coef)
    case t.coef == 1:
        if t.exp == 1 {
            return ""x""
        } else {
            return fmt.Sprintf(""x^%d"", t.exp)
        }
    case t.exp == 1:
        return fmt.Sprintf(""%dx"", t.coef)
    }
    return fmt.Sprintf(""%dx^%d"", t.coef, t.exp)
}
 
type poly struct{ terms []term }
 
// pass coef, exp in pairs as parameters
func newPoly(values ...int) poly {
    le := len(values)
    if le == 0 {
        return poly{[]term{term{0, 0}}}
    }
    if le%2 != 0 {
        log.Fatalf(""odd number of parameters (%d) passed to newPoly function"", le)
    }
    var terms []term
    for i := 0; i < le; i += 2 {
        terms = append(terms, term{values[i], values[i+1]})
    }
    p := poly{terms}.tidy()
    return p
}
 
func (p poly) hasCoefAbs(coef int) bool {
    for _, t := range p.terms {
        if iabs(t.coef) == coef {
            return true
        }
    }
    return false
}
 
func (p poly) add(p2 poly) poly {
    p3 := newPoly()
    le, le2 := len(p.terms), len(p2.terms)
    for le > 0 || le2 > 0 {
        if le == 0 {
            p3.terms = append(p3.terms, p2.terms[le2-1])
            le2--
        } else if le2 == 0 {
            p3.terms = append(p3.terms, p.terms[le-1])
            le--
        } else {
            t := p.terms[le-1]
            t2 := p2.terms[le2-1]
            if t.exp == t2.exp {
                t3 := t.add(t2)
                if t3.coef != 0 {
                    p3.terms = append(p3.terms, t3)
                }
                le--
                le2--
            } else if t.exp < t2.exp {
                p3.terms = append(p3.terms, t)
                le--
            } else {
                p3.terms = append(p3.terms, t2)
                le2--
            }
        }
    }
    return p3.tidy()
}
 
func (p poly) addTerm(t term) poly {
    q := newPoly()
    added := false
    for i := 0; i < len(p.terms); i++ {
        ct := p.terms[i]
        if ct.exp == t.exp {
            added = true
            if ct.coef+t.coef != 0 {
                q.terms = append(q.terms, ct.add(t))
            }
        } else {
            q.terms = append(q.terms, ct)
        }
    }
    if !added {
        q.terms = append(q.terms, t)
    }
    return q.tidy()
}
 
func (p poly) mulTerm(t term) poly {
    q := newPoly()
    for i := 0; i < len(p.terms); i++ {
        ct := p.terms[i]
        q.terms = append(q.terms, ct.mul(t))
    }
    return q.tidy()
}
 
func (p poly) div(v poly) poly {
    q := newPoly()
    lcv := v.leadingCoef()
    dv := v.degree()
    for p.degree() >= v.degree() {
        lcp := p.leadingCoef()
        s := lcp / lcv
        t := term{s, p.degree() - dv}
        q = q.addTerm(t)
        p = p.add(v.mulTerm(t.negate()))
    }
    return q.tidy()
}
 
func (p poly) leadingCoef() int {
    return p.terms[0].coef
}
 
func (p poly) degree() int {
    return p.terms[0].exp
}
 
func (p poly) String() string {
    var sb strings.Builder
    first := true
    for _, t := range p.terms {
        if first {
            sb.WriteString(t.String())
            first = false
        } else {
            sb.WriteString("" "")
            if t.coef > 0 {
                sb.WriteString(""+ "")
                sb.WriteString(t.String())
            } else {
                sb.WriteString(""- "")
                sb.WriteString(t.negate().String())
            }
        }
    }
    return sb.String()
}
 
// in place descending sort by term.exp
func (p poly) sortTerms() {
    sort.Slice(p.terms, func(i, j int) bool {
        return p.terms[i].exp > p.terms[j].exp
    })
}
 
// sort terms and remove any unnecesary zero terms
func (p poly) tidy() poly {
    p.sortTerms()
    if p.degree() == 0 {
        return p
    }
    for i := len(p.terms) - 1; i >= 0; i-- {
        if p.terms[i].coef == 0 {
            copy(p.terms[i:], p.terms[i+1:])
            p.terms[len(p.terms)-1] = term{0, 0}
            p.terms = p.terms[:len(p.terms)-1]
        }
    }
    if len(p.terms) == 0 {
        p.terms = append(p.terms, term{0, 0})
    }
    return p
}
 
func getDivisors(n int) []int {
    var divs []int
    sqrt := int(math.Sqrt(float64(n)))
    for i := 1; i <= sqrt; i++ {
        if n%i == 0 {
            divs = append(divs, i)
            d := n / i
            if d != i && d != n {
                divs = append(divs, d)
            }
        }
    }
    return divs
}
 
var (
    computed   = make(map[int]poly)
    allFactors = make(map[int]map[int]int)
)
 
func init() {
    f := map[int]int{2: 1}
    allFactors[2] = f
}
 
func getFactors(n int) map[int]int {
    if f, ok := allFactors[n]; ok {
        return f
    }
    factors := make(map[int]int)
    if n%2 == 0 {
        factorsDivTwo := getFactors(n / 2)
        for k, v := range factorsDivTwo {
            factors[k] = v
        }
        factors[2]++
        if n < maxAllFactors {
            allFactors[n] = factors
        }
        return factors
    }
    prime := true
    sqrt := int(math.Sqrt(float64(n)))
    for i := 3; i <= sqrt; i += 2 {
        if n%i == 0 {
            prime = false
            for k, v := range getFactors(n / i) {
                factors[k] = v
            }
            factors[i]++
            if n < maxAllFactors {
                allFactors[n] = factors
            }
            return factors
        }
    }
    if prime {
        factors[n] = 1
        if n < maxAllFactors {
            allFactors[n] = factors
        }
    }
    return factors
}
 
func cycloPoly(n int) poly {
    if p, ok := computed[n]; ok {
        return p
    }
    if n == 1 {
        // polynomial: x - 1
        p := newPoly(1, 1, -1, 0)
        computed[1] = p
        return p
    }
    factors := getFactors(n)
    cyclo := newPoly()
    if _, ok := factors[n]; ok {
        // n is prime
        for i := 0; i < n; i++ {
            cyclo.terms = append(cyclo.terms, term{1, i})
        }
    } else if len(factors) == 2 && factors[2] == 1 && factors[n/2] == 1 {
        // n == 2p
        prime := n / 2
        coef := -1
        for i := 0; i < prime; i++ {
            coef *= -1
            cyclo.terms = append(cyclo.terms, term{coef, i})
        }
    } else if len(factors) == 1 {
        if h, ok := factors[2]; ok {
            // n == 2^h
            cyclo.terms = append(cyclo.terms, term{1, 1 << (h - 1)}, term{1, 0})
        } else if _, ok := factors[n]; !ok {
            // n == p ^ k
            p := 0
            for prime := range factors {
                p = prime
            }
            k := factors[p]
            for i := 0; i < p; i++ {
                pk := int(math.Pow(float64(p), float64(k-1)))
                cyclo.terms = append(cyclo.terms, term{1, i * pk})
            }
        }
    } else if len(factors) == 2 && factors[2] != 0 {
        // n = 2^h * p^k
        p := 0
        for prime := range factors {
            if prime != 2 {
                p = prime
            }
        }
        coef := -1
        twoExp := 1 << (factors[2] - 1)
        k := factors[p]
        for i := 0; i < p; i++ {
            coef *= -1
            pk := int(math.Pow(float64(p), float64(k-1)))
            cyclo.terms = append(cyclo.terms, term{coef, i * twoExp * pk})
        }
    } else if factors[2] != 0 && ((n/2)%2 == 1) && (n/2) > 1 {
        //  CP(2m)[x] == CP(-m)[x], n odd integer > 1
        cycloDiv2 := cycloPoly(n / 2)
        for _, t := range cycloDiv2.terms {
            t2 := t
            if t.exp%2 != 0 {
                t2 = t.negate()
            }
            cyclo.terms = append(cyclo.terms, t2)
        }
    } else if algo == 0 {
        // slow - uses basic definition
        divs := getDivisors(n)
        // polynomial: x^n - 1
        cyclo = newPoly(1, n, -1, 0)
        for _, i := range divs {
            p := cycloPoly(i)
            cyclo = cyclo.div(p)
        }
    } else if algo == 1 {
        //  faster - remove max divisor (and all divisors of max divisor)
        //  only one divide for all divisors of max divisor
        divs := getDivisors(n)
        maxDiv := math.MinInt32
        for _, d := range divs {
            if d > maxDiv {
                maxDiv = d
            }
        }
        var divsExceptMax []int
        for _, d := range divs {
            if maxDiv%d != 0 {
                divsExceptMax = append(divsExceptMax, d)
            }
        }
        // polynomial:  ( x^n - 1 ) / ( x^m - 1 ), where m is the max divisor
        cyclo = newPoly(1, n, -1, 0)
        cyclo = cyclo.div(newPoly(1, maxDiv, -1, 0))
        for _, i := range divsExceptMax {
            p := cycloPoly(i)
            cyclo = cyclo.div(p)
        }
    } else if algo == 2 {
        //  fastest
        //  let p, q be primes such that p does not divide n, and q divides n
        //  then CP(np)[x] = CP(n)[x^p] / CP(n)[x]
        m := 1
        cyclo = cycloPoly(m)
        var primes []int
        for prime := range factors {
            primes = append(primes, prime)
        }
        sort.Ints(primes)
        for _, prime := range primes {
            //  CP(m)[x]
            cycloM := cyclo
            //  compute CP(m)[x^p]
            var terms []term
            for _, t := range cycloM.terms {
                terms = append(terms, term{t.coef, t.exp * prime})
            }
            cyclo = newPoly()
            cyclo.terms = append(cyclo.terms, terms...)
            cyclo = cyclo.tidy()
            cyclo = cyclo.div(cycloM)
            m *= prime
        }
        //  now, m is the largest square free divisor of n
        s := n / m
        //  Compute CP(n)[x] = CP(m)[x^s]
        var terms []term
        for _, t := range cyclo.terms {
            terms = append(terms, term{t.coef, t.exp * s})
        }
        cyclo = newPoly()
        cyclo.terms = append(cyclo.terms, terms...)
    } else {
        log.Fatal(""invalid algorithm"")
    }
    cyclo = cyclo.tidy()
    computed[n] = cyclo
    return cyclo
}
 
func main() {
    fmt.Println(""Task 1:  cyclotomic polynomials for n <= 30:"")
    for i := 1; i <= 30; i++ {
        p := cycloPoly(i)
        fmt.Printf(""CP[%2d] = %s\n"", i, p)
    }
 
    fmt.Println(""\nTask 2:  Smallest cyclotomic polynomial with n or -n as a coefficient:"")
    n := 0
    for i := 1; i <= 10; i++ {
        for {
            n++
            cyclo := cycloPoly(n)
            if cyclo.hasCoefAbs(i) {
                fmt.Printf(""CP[%d] has coefficient with magnitude = %d\n"", n, i)
                n--
                break
            }
        }
    }
}",11205,440,"package main

import (
    ""testing""
)

func TestCycloPoly(t *testing.T) {
    expectedPolynomials := []string{
        ""x - 1"",
        ""x + 1"",
        ""x^2 + x + 1"",
        ""x^2 + 1"",
        ""x^4 + x^3 + x^2 + x + 1"",
        ""x^2 - x + 1"",
        ""x^6 + x^5 + x^4 + x^3 + x^2 + x + 1"",
        ""x^4 + 1"",
        ""x^6 + x^3 + 1"",
        ""x^4 - x^3 + x^2 - x + 1"",
        ""x^10 + x^9 + x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1"",
        ""x^4 - x^2 + 1"",
        ""x^12 + x^11 + x^10 + x^9 + x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1"",
        ""x^6 - x^3 + 1"",
        ""x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1"",
        ""x^8 - x^7 + x^6 - x^5 + x^4 - x^3 + x^2 - x + 1"",
        ""x^16 + x^15 + x^14 + x^13 + x^12 + x^11 + x^10 + x^9 + x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1"",
        ""x^6 - x^3 + 1"",
        ""x^18 + x^17 + x^16 + x^15 + x^14 + x^13 + x^12 + x^11 + x^10 + x^9 + x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1"",
        ""x^8 - x^6 + x^4 - x^2 + 1"",
        ""x^12 - x^9 + x^6 - x^3 + 1"",
        ""x^10 - x^5 + 1"",
        ""x^22 + x^21 + x^20 + x^19 + x^18 + x^17 + x^16 + x^15 + x^14 + x^13 + x^12 + x^11 + x^10 + x^9 + x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1"",
        ""x^12 - x^6 + 1"",
        ""x^20 + x^19 + x^18 + x^17 + x^16 + x^15 + x^14 + x^13 + x^12 + x^11 + x^10 + x^9 + x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1"",
        ""x^24 + x^23 + x^22 + x^21 + x^20 + x^19 + x^18 + x^17 + x^16 + x^15 + x^14 + x^13 + x^12 + x^11 + x^10 + x^9 + x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1"",
        ""x^18 - x^9 + 1"",
        ""x^26 + x^25 + x^24 + x^23 + x^22 + x^21 + x^20 + x^19 + x^18 + x^17 + x^16 + x^15 + x^14 + x^13 + x^12 + x^11 + x^10 + x^9 + x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1"",
        ""x^28 + x^27 + x^26 + x^25 + x^24 + x^23 + x^22 + x^21 + x^20 + x^19 + x^18 + x^17 + x^16 + x^15 + x^14 + x^13 + x^12 + x^11 + x^10 + x^9 + x^8 + x^7 + x^6 + x^5 + x^4 + x^3 + x^2 + x + 1"",
        ""x^16 - x^8 + 1"",
    }

    for i := 1; i <= 30; i++ {
        p := cycloPoly(i)
        if p.String() != expectedPolynomials[i-1] {
            t.Errorf(""Expected CP[%d] = %s, but got %s"", i, expectedPolynomials[i-1], p.String())
        }
    }
}

func TestCycloPolyWithCoefAbs(t *testing.T) {
    expectedOrders := []int{3, 4, 7, 9, 11, 13, 15, 18, 21, 22}

    n := 0
    for i := 1; i <= 10; i++ {
        for {
            n++
            cyclo := cycloPoly(n)
            if cyclo.hasCoefAbs(i) {
                if n != expectedOrders[i-1] {
                    t.Errorf(""Expected smallest order for coefficient magnitude %d is %d, but got %d"", i, expectedOrders[i-1], n)
                }
                n--
                break
            }
        }
    }
}
",./data/generated/docs_golang/cyclotomic_polynomial/gpt_4o_2024_08_06_cyclotomic_polynomial_test.go,CompileStatus.OK,,,,0.1,0.02,,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: cycloPoly', 'Severity': '', 'SourceLines': ['        p := cycloPoly(i)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cyclotomic_polynomial_test.go', 'Offset': 0, 'Line': 42, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: cycloPoly', 'Severity': '', 'SourceLines': ['            cyclo := cycloPoly(n)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_cyclotomic_polynomial_test.go', 'Offset': 0, 'Line': 56, 'Column': 22}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",True,False,0.0,True,[]
Damm algorithm,"The Damm algorithm is a checksum algorithm which detects all single digit errors and adjacent transposition errors.



The algorithm is named after H. Michael Damm.



Task

Verify the checksum, stored as last digit of an input.


",Go,"package main
 
import ""fmt""
 
var table = [10][10]byte{
    {0, 3, 1, 7, 5, 9, 8, 6, 4, 2},
    {7, 0, 9, 2, 1, 5, 4, 8, 6, 3},
    {4, 2, 0, 6, 8, 7, 1, 3, 5, 9},
    {1, 7, 5, 0, 9, 8, 3, 4, 2, 6},
    {6, 1, 2, 3, 0, 4, 5, 9, 7, 8},
    {3, 6, 7, 4, 2, 0, 9, 5, 8, 1},
    {5, 8, 6, 9, 7, 2, 0, 1, 3, 4},
    {8, 9, 4, 5, 3, 6, 2, 0, 1, 7},
    {9, 4, 3, 8, 6, 1, 7, 2, 0, 5},
    {2, 5, 8, 1, 4, 3, 6, 7, 9, 0},
}
 
func damm(input string) bool {
    var interim byte
    for _, c := range []byte(input) {
        interim = table[interim][c-'0']
    }
    return interim == 0
}
 
func main() {
    for _, s := range []string{""5724"", ""5727"", ""112946"", ""112949""} {
        fmt.Printf(""%6s  %t\n"", s, damm(s))
    }
}",718,30,"package main

import ""testing""

func TestDammAlgorithm(t *testing.T) {
    tests := []struct {
        input    string
        expected bool
    }{
        {""5724"", true},   // Valid checksum
        {""5727"", false},  // Invalid checksum
        {""112946"", true}, // Valid checksum
        {""112949"", false},// Invalid checksum
        {""0"", true},      // Single digit, valid checksum
        {""1"", false},     // Single digit, invalid checksum
        {""1234567890"", false}, // Long sequence, invalid checksum
        {""1234567892"", true},  // Long sequence, valid checksum
    }

    for _, test := range tests {
        result := damm(test.input)
        if result != test.expected {
            t.Errorf(""damm(%s) = %v; want %v"", test.input, result, test.expected)
        }
    }
}
",./data/generated/docs_golang/damm_algorithm/gpt_4o_2024_08_06_damm_algorithm_test.go,CompileStatus.OK,0.0,66.7,,0.06,0.25,0.115,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: damm', 'Severity': '', 'SourceLines': ['        result := damm(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_damm_algorithm_test.go', 'Offset': 0, 'Line': 21, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Date format,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.


Task

Display the   current date   in the formats of:

   2007-11-23     and 
   Friday, November 23, 2007

",Go,"package main
 
import ""time""
import ""fmt""
 
func main() {
    fmt.Println(time.Now().Format(""2006-01-02""))
    fmt.Println(time.Now().Format(""Monday, January 2, 2006""))
}",170,9,"package main

import (
	""testing""
	""time""
)

func TestDateFormats(t *testing.T) {
	// Get the current date
	currentTime := time.Now()

	// Format the current date in the first format: ""2006-01-02""
	expectedFormat1 := currentTime.Format(""2006-01-02"")
	actualFormat1 := time.Now().Format(""2006-01-02"")
	if actualFormat1 != expectedFormat1 {
		t.Errorf(""Expected format1: %s, but got: %s"", expectedFormat1, actualFormat1)
	}

	// Format the current date in the second format: ""Monday, January 2, 2006""
	expectedFormat2 := currentTime.Format(""Monday, January 2, 2006"")
	actualFormat2 := time.Now().Format(""Monday, January 2, 2006"")
	if actualFormat2 != expectedFormat2 {
		t.Errorf(""Expected format2: %s, but got: %s"", expectedFormat2, actualFormat2)
	}
}
",./data/generated/docs_golang/date_format/gpt_4o_2024_08_06_date_format_test.go,CompileStatus.OK,0.0,0.0,,0.17,2.0,0.113,0.0,[],False,False,100.0,False,[]
Day of the week,"A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).



Task

In what years between 2008 and 2121 will the 25th of December be a Sunday?

Using any standard date handling libraries of your programming language;
compare the dates calculated with the output of other languages to discover any anomalies in the handling of dates which may be due to, for example, overflow in types used to represent dates/times similar to   y2k   type problems.



",Go,"package main
 
import ""fmt""
import ""time""
 
func main() {
    for year := 2008; year <= 2121; year++ {
        if time.Date(year, 12, 25, 0, 0, 0, 0, time.UTC).Weekday() ==
            time.Sunday {
            fmt.Printf(""25 December %d is Sunday\n"", year)
        }
    }
}",275,13,"package main

import (
	""testing""
	""time""
)

func TestChristmasOnSunday(t *testing.T) {
	expectedYears := []int{2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095, 2100, 2106, 2117}

	var actualYears []int
	for year := 2008; year <= 2121; year++ {
		if time.Date(year, 12, 25, 0, 0, 0, 0, time.UTC).Weekday() == time.Sunday {
			actualYears = append(actualYears, year)
		}
	}

	if len(actualYears) != len(expectedYears) {
		t.Fatalf(""Expected %d years, but got %d years"", len(expectedYears), len(actualYears))
	}

	for i, year := range actualYears {
		if year != expectedYears[i] {
			t.Errorf(""Expected year %d, but got year %d"", expectedYears[i], year)
		}
	}
}
",./data/generated/docs_golang/day_of_the_week/gpt_4o_2024_08_06_day_of_the_week_test.go,CompileStatus.OK,0.0,0.0,,0.15,0.67,0.115,0.0,[],False,False,0.0,False,[]
Deal cards for FreeCell,"Free Cell is the solitaire card game that Paul Alfille introduced to the PLATO system in 1978. Jim Horne, at Microsoft, changed the name to FreeCell and reimplemented the game for DOS, then Windows. 

This version introduced 32000 numbered deals. (The FreeCell FAQ tells this history.)

As the game became popular, Jim Horne disclosed the algorithm, and other implementations of FreeCell began to reproduce the Microsoft deals. 

These deals are numbered from 1 to 32000.
Newer versions from Microsoft have 1 million deals, numbered from 1 to 1000000; some implementations allow numbers outside that range.

The algorithm uses this linear congruential generator from Microsoft C:

 



s
t
a
t

e

n
+
1


≡
214013
×
s
t
a
t

e

n


+
2531011


(
mod


2

31


)



{\displaystyle state_{n+1}\equiv 214013\times state_{n}+2531011{\pmod {2^{31}}}}


 



r
a
n

d

n


=
s
t
a
t

e

n


÷

2

16




{\displaystyle rand_{n}=state_{n}\div 2^{16}}


 



r
a
n

d

n




{\displaystyle rand_{n}}

 is in range 0 to 32767.
 Rosetta Code has another task, linear congruential generator, with code for this RNG in several languages.


The algorithm follows:

 Seed the RNG with the number of the deal.
 Create an array of 52 cards: Ace of Clubs, Ace of Diamonds, Ace of Hearts, Ace of Spades, 2 of Clubs, 2 of Diamonds, and so on through the ranks: Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King. The array indexes are 0 to 51, with Ace of Clubs at 0, and King of Spades at 51.
 Until the array is empty:
 Choose a random card at index ≡ next random number (mod array length).
 Swap this random card with the last card of the array.
 Remove this random card from the array. (Array length goes down by 1.)
 Deal this random card.
 Deal all 52 cards, face up, across 8 columns. The first 8 cards go in 8 columns, the next 8 cards go on the first 8 cards, and so on.


 Order to deal cards

 Game #1

 Game #617


  1  2  3  4  5  6  7  8
 9 10 11 12 13 14 15 16
17 18 19 20 21 22 23 24
25 26 27 28 29 30 31 32
33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48
49 50 51 52

 JD 2D 9H JC 5D 7H 7C 5H
KD KC 9S 5S AD QC KH 3H
2S KS 9D QD JS AS AH 3C
4C 5C TS QH 4H AC 4D 7S
3S TD 4S TH 8H 2C JH 7D
6D 8S 8D QS 6C 3D 8C TC
6S 9C 2H 6H

 7D AD 5C 3S 5S 8C 2D AH
TD 7S QD AC 6D 8H AS KH
TH QC 3H 9D 6S 8D 3D TC
KD 5H 9S 3C 8S 7H 4D JS
4C QS 9C 9H 7C 6H 2C 2S
4S TS 2H 5D JC 6C JH QH
JD KS KC 4H

Deals can also be checked against FreeCell solutions to 1000000 games.
(Summon a video solution, and it displays the initial deal.)

Write a program to take a deal number and deal cards in the same order as this algorithm.
The program may display the cards with ASCII, with Unicode, by drawing graphics, or any other way.

Related tasks:

 Playing cards
 Card shuffles
 War Card_Game
 Poker hand_analyser
 Go Fish

",Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/rand""
    ""os""
    ""strconv""
    ""time""
)
 
const sSuits = ""CDHS""
const sNums = ""A23456789TJQK""
const rMax32 = math.MaxInt32
 
var seed = 1
 
func rnd() int {
    seed = (seed*214013 + 2531011) & rMax32
    return seed >> 16
}
 
func deal(s int) []int {
    seed = s
    t := make([]int, 52)
    for i := 0; i < 52; i++ {
        t[i] = 51 - i
    }
    for i := 0; i < 51; i++ {
        j := 51 - rnd()%(52-i)
        t[i], t[j] = t[j], t[i]
    }
    return t
}
 
func show(cs []int) {
    for i, c := range cs {
        fmt.Printf("" %c%c"", sNums[c/4], sSuits[c%4])
        if (i+1)%8 == 0 || i+1 == len(cs) {
            fmt.Println()
        }
    }
}
 
func main() {
    var game int
    switch len(os.Args) {
    case 1:
        rand.Seed(time.Now().UnixNano())
        game = 1 + rand.Intn(32000)
    case 2:
        var err error
        game, err = strconv.Atoi(os.Args[1])
        if err == nil && game >= 1 && game <= 32000 {
            break
        }
        fallthrough
    default:
        fmt.Println(""usage: deal [game]"")
        fmt.Println(""       where game is a number in the range 1 to 32000"")
        return
    }
    fmt.Printf(""\nGame #%d\n"", game)
    show(deal(game))
}",1252,65,"package main

import (
	""testing""
)

// Test the random number generator
func TestRnd(t *testing.T) {
	seed = 1
	expected := []int{32767, 10174, 27926, 3035, 22861}
	for i, exp := range expected {
		if result := rnd(); result != exp {
			t.Errorf(""rnd() test %d failed: expected %d, got %d"", i+1, exp, result)
		}
	}
}

// Test the deal function for a specific game number
func TestDeal(t *testing.T) {
	seed = 1
	expected := []int{
		35, 13, 37, 36, 17, 27, 23, 18,
		51, 50, 38, 21, 0, 45, 49, 11,
		8, 48, 39, 25, 9, 1, 3, 10,
		16, 12, 33, 44, 15, 2, 4, 26,
		7, 34, 5, 30, 19, 6, 28, 24,
		31, 46, 47, 29, 32, 22, 20, 14,
		40, 41, 42, 43,
	}
	result := deal(1)
	for i, exp := range expected {
		if result[i] != exp {
			t.Errorf(""deal(1) test failed at index %d: expected %d, got %d"", i, exp, result[i])
		}
	}
}

// Test the main function with a valid game number
func TestMainValidGame(t *testing.T) {
	// Simulate command line argument for game number 1
	os.Args = []string{""cmd"", ""1""}
	main()
	// No assertions here, just ensure no panic or error occurs
}

// Test the main function with an invalid game number
func TestMainInvalidGame(t *testing.T) {
	// Simulate command line argument for an invalid game number
	os.Args = []string{""cmd"", ""32001""}
	main()
	// No assertions here, just ensure no panic or error occurs
}

// Test the main function with no arguments
func TestMainNoArgs(t *testing.T) {
	// Simulate no command line arguments
	os.Args = []string{""cmd""}
	main()
	// No assertions here, just ensure no panic or error occurs
}
",./data/generated/docs_golang/deal_cards_for_freecell/gpt_4o_2024_08_06_deal_cards_for_freecell_test.go,CompileStatus.SYNTAX_ERROR,,,,0.06,0.14,,10.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: seed', 'Severity': '', 'SourceLines': ['\tseed = 1'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_deal_cards_for_freecell_test.go', 'Offset': 0, 'Line': 9, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: rnd', 'Severity': '', 'SourceLines': ['\t\tif result := rnd(); result != exp {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_deal_cards_for_freecell_test.go', 'Offset': 0, 'Line': 12, 'Column': 16}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: seed', 'Severity': '', 'SourceLines': ['\tseed = 1'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_deal_cards_for_freecell_test.go', 'Offset': 0, 'Line': 20, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: deal', 'Severity': '', 'SourceLines': ['\tresult := deal(1)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_deal_cards_for_freecell_test.go', 'Offset': 0, 'Line': 30, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: os', 'Severity': '', 'SourceLines': ['\tos.Args = []string{""cmd"", ""1""}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_deal_cards_for_freecell_test.go', 'Offset': 0, 'Line': 41, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\tmain()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_deal_cards_for_freecell_test.go', 'Offset': 0, 'Line': 42, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: os', 'Severity': '', 'SourceLines': ['\tos.Args = []string{""cmd"", ""32001""}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_deal_cards_for_freecell_test.go', 'Offset': 0, 'Line': 49, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\tmain()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_deal_cards_for_freecell_test.go', 'Offset': 0, 'Line': 50, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: os', 'Severity': '', 'SourceLines': ['\tos.Args = []string{""cmd""}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_deal_cards_for_freecell_test.go', 'Offset': 0, 'Line': 57, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\tmain()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_deal_cards_for_freecell_test.go', 'Offset': 0, 'Line': 58, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_deal_cards_for_freecell_test.go', 'line': 41, 'column': 2, 'message': 'undefined: os'}]"
Deconvolution/1D,"The convolution of two functions 





F




{\displaystyle {\mathit {F}}}

 and 





H




{\displaystyle {\mathit {H}}}

 of
an integer variable is defined as the function 





G




{\displaystyle {\mathit {G}}}


satisfying





G
(
n
)
=

∑

m
=
−
∞


∞


F
(
m
)
H
(
n
−
m
)


{\displaystyle G(n)=\sum _{m=-\infty }^{\infty }F(m)H(n-m)}


for all integers 





n




{\displaystyle {\mathit {n}}}

. Assume 



F
(
n
)


{\displaystyle F(n)}

 can be non-zero only for 



0


{\displaystyle 0}

 ≤ 





n




{\displaystyle {\mathit {n}}}

 ≤ 




|



F



|



{\displaystyle |{\mathit {F}}|}

, where 




|



F



|



{\displaystyle |{\mathit {F}}|}

 is the ""length"" of 





F




{\displaystyle {\mathit {F}}}

, and similarly for 





G




{\displaystyle {\mathit {G}}}

 and 





H




{\displaystyle {\mathit {H}}}

, so that the functions can be modeled as finite sequences by identifying 




f

0


,

f

1


,

f

2


,
…


{\displaystyle f_{0},f_{1},f_{2},\dots }

 with 



F
(
0
)
,
F
(
1
)
,
F
(
2
)
,
…


{\displaystyle F(0),F(1),F(2),\dots }

, etc.
Then for example, values of 




|



F



|

=
6


{\displaystyle |{\mathit {F}}|=6}

 and 




|



H



|

=
5


{\displaystyle |{\mathit {H}}|=5}

 would determine the following value of 





g




{\displaystyle {\mathit {g}}}

 by definition.










g

0




=



f

0



h

0







g

1




=



f

1



h

0




+



f

0



h

1







g

2




=



f

2



h

0




+



f

1



h

1




+



f

0



h

2







g

3




=



f

3



h

0




+



f

2



h

1




+



f

1



h

2




+



f

0



h

3







g

4




=



f

4



h

0




+



f

3



h

1




+



f

2



h

2




+



f

1



h

3




+



f

0



h

4







g

5




=



f

5



h

0




+



f

4



h

1




+



f

3



h

2




+



f

2



h

3




+



f

1



h

4







g

6




=





f

5



h

1




+



f

4



h

2




+



f

3



h

3




+



f

2



h

4







g

7




=







f

5



h

2




+



f

4



h

3




+



f

3



h

4







g

8




=









f

5



h

3




+



f

4



h

4







g

9




=











f

5



h

4








{\displaystyle {\begin{array}{lllllllllll}g_{0}&=&f_{0}h_{0}\\g_{1}&=&f_{1}h_{0}&+&f_{0}h_{1}\\g_{2}&=&f_{2}h_{0}&+&f_{1}h_{1}&+&f_{0}h_{2}\\g_{3}&=&f_{3}h_{0}&+&f_{2}h_{1}&+&f_{1}h_{2}&+&f_{0}h_{3}\\g_{4}&=&f_{4}h_{0}&+&f_{3}h_{1}&+&f_{2}h_{2}&+&f_{1}h_{3}&+&f_{0}h_{4}\\g_{5}&=&f_{5}h_{0}&+&f_{4}h_{1}&+&f_{3}h_{2}&+&f_{2}h_{3}&+&f_{1}h_{4}\\g_{6}&=&&&f_{5}h_{1}&+&f_{4}h_{2}&+&f_{3}h_{3}&+&f_{2}h_{4}\\g_{7}&=&&&&&f_{5}h_{2}&+&f_{4}h_{3}&+&f_{3}h_{4}\\g_{8}&=&&&&&&&f_{5}h_{3}&+&f_{4}h_{4}\\g_{9}&=&&&&&&&&&f_{5}h_{4}\end{array}}}


We can write this in matrix form as:






(





g

0







g

1







g

2







g

3







g

4







g

5







g

6







g

7







g

8







g

9






)

=

(





f

0







f

1





f

0







f

2





f

1





f

0







f

3





f

2





f

1





f

0







f

4





f

3





f

2





f

1





f

0







f

5





f

4





f

3





f

2





f

1








f

5





f

4





f

3





f

2









f

5





f

4





f

3










f

5





f

4











f

5






)



(





h

0







h

1







h

2







h

3







h

4






)



{\displaystyle \left({\begin{array}{l}g_{0}\\g_{1}\\g_{2}\\g_{3}\\g_{4}\\g_{5}\\g_{6}\\g_{7}\\g_{8}\\g_{9}\\\end{array}}\right)=\left({\begin{array}{lllll}f_{0}\\f_{1}&f_{0}\\f_{2}&f_{1}&f_{0}\\f_{3}&f_{2}&f_{1}&f_{0}\\f_{4}&f_{3}&f_{2}&f_{1}&f_{0}\\f_{5}&f_{4}&f_{3}&f_{2}&f_{1}\\&f_{5}&f_{4}&f_{3}&f_{2}\\&&f_{5}&f_{4}&f_{3}\\&&&f_{5}&f_{4}\\&&&&f_{5}\end{array}}\right)\;\left({\begin{array}{l}h_{0}\\h_{1}\\h_{2}\\h_{3}\\h_{4}\\\end{array}}\right)}


or





g
=
A

h


{\displaystyle g=A\;h}


For this task, implement a function (or method, procedure, subroutine, etc.) deconv to perform deconvolution (i.e., the inverse of convolution) by constructing and solving such a system of equations represented by the above matrix 



A


{\displaystyle A}

 for 





h




{\displaystyle {\mathit {h}}}

 given 





f




{\displaystyle {\mathit {f}}}

 and 





g




{\displaystyle {\mathit {g}}}

.

 The function should work for 





G




{\displaystyle {\mathit {G}}}

 of arbitrary length (i.e., not hard coded or constant) and 





F




{\displaystyle {\mathit {F}}}

 of any length up to that of 





G




{\displaystyle {\mathit {G}}}

. Note that 




|



H



|



{\displaystyle |{\mathit {H}}|}

 will be given by 




|



G



|

−

|



F



|

+
1


{\displaystyle |{\mathit {G}}|-|{\mathit {F}}|+1}

.
 There may be more equations than unknowns. If convenient, use a function from a library that finds the best fitting solution to an overdetermined system of linear equations (as in the Multiple regression task). Otherwise, prune the set of equations as needed and solve as in the Reduced row echelon form task.
 Test your solution on the following data. Be sure to verify both that deconv



(
g
,
f
)
=
h


{\displaystyle (g,f)=h}

 and deconv



(
g
,
h
)
=
f


{\displaystyle (g,h)=f}

 and display the results in a human readable form.

h = [-8,-9,-3,-1,-6,7]

f = [-3,-6,-1,8,-6,3,-1,-9,-9,3,-2,5,2,-2,-7,-1]

g = [24,75,71,-34,3,22,-45,23,245,25,52,25,-67,-96,96,31,55,36,29,-43,-7]

",Go,"package main
 
import ""fmt""
 
func main() {
    h := []float64{-8, -9, -3, -1, -6, 7}
    f := []float64{-3, -6, -1, 8, -6, 3, -1, -9, -9, 3, -2, 5, 2, -2, -7, -1}
    g := []float64{24, 75, 71, -34, 3, 22, -45, 23, 245, 25, 52, 25, -67, -96,
        96, 31, 55, 36, 29, -43, -7}
    fmt.Println(h)
    fmt.Println(deconv(g, f))
    fmt.Println(f)
    fmt.Println(deconv(g, h))
}
 
func deconv(g, f []float64) []float64 {
    h := make([]float64, len(g)-len(f)+1)
    for n := range h {
        h[n] = g[n]
        var lower int
        if n >= len(f) {
            lower = n - len(f) + 1
        }
        for i := lower; i < n; i++ {
            h[n] -= h[i] * f[n-i]
        }
        h[n] /= f[0]
    }
    return h
}",721,30,"package main

import (
	""math""
	""testing""
)

func TestDeconv(t *testing.T) {
	h := []float64{-8, -9, -3, -1, -6, 7}
	f := []float64{-3, -6, -1, 8, -6, 3, -1, -9, -9, 3, -2, 5, 2, -2, -7, -1}
	g := []float64{24, 75, 71, -34, 3, 22, -45, 23, 245, 25, 52, 25, -67, -96, 96, 31, 55, 36, 29, -43, -7}

	t.Run(""Test deconv(g, f) = h"", func(t *testing.T) {
		result := deconv(g, f)
		if !equalSlices(result, h) {
			t.Errorf(""Expected %v, got %v"", h, result)
		}
	})

	t.Run(""Test deconv(g, h) = f"", func(t *testing.T) {
		result := deconv(g, h)
		if !equalSlices(result, f) {
			t.Errorf(""Expected %v, got %v"", f, result)
		}
	})
}

// Helper function to compare two slices of floats
func equalSlices(a, b []float64) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if !almostEqual(a[i], b[i]) {
			return false
		}
	}
	return true
}

// Helper function to compare two float64 values with a tolerance
func almostEqual(a, b float64) bool {
	const epsilon = 1e-9
	return math.Abs(a-b) < epsilon
}
",./data/generated/docs_golang/deconvolution_1d/gpt_4o_2024_08_06_deconvolution_1d_test.go,CompileStatus.OK,0.0,58.8,,0.08,0.4,0.115,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: deconv', 'Severity': '', 'SourceLines': ['\t\tresult := deconv(g, f)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_deconvolution_1d_test.go', 'Offset': 0, 'Line': 14, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: deconv', 'Severity': '', 'SourceLines': ['\t\tresult := deconv(g, h)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_deconvolution_1d_test.go', 'Offset': 0, 'Line': 21, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Deepcopy,"Task

Demonstrate how to copy data structures containing complex heterogeneous and cyclic semantics.

This is often referred to as deep copying, and is normally required where structures are mutable and to ensure that independent copies can be manipulated without side-effects.

If this facility is not built into the language, it is permissible to use functions from a common library, or a coded procedure.



The task should show:

 Relevant semantics of structures, such as their homogeneous or heterogeneous properties, or containment of (self- or mutual-reference) cycles.
 Any limitations of the method.
 That the structure and its copy are different.
 Suitable links to external documentation for common libraries.

",Go,"package main
 
import ""fmt""
 
// a complex data structure
type cds struct {
    i int            // no special handling needed for deep copy
    s string         // no special handling
    b []byte         // copied easily with append function
    m map[int]bool   // deep copy requires looping
}
 
// a method
func (c cds) deepcopy() *cds {
    // copy what you can in one line
    r := &cds{c.i, c.s, append([]byte{}, c.b...), make(map[int]bool)}
    // populate map with a loop
    for k, v := range c.m {
        r.m[k] = v
    }
    return r
}
 
// demo
func main() {
    // create and populate a structure 
    c1 := &cds{1, ""one"", []byte(""unit""), map[int]bool{1: true}}
    fmt.Println(c1)      // show it
    c2 := c1.deepcopy()  // copy it
    fmt.Println(c2)      // show copy
    c1.i = 0             // change original
    c1.s = ""nil""
    copy(c1.b, ""zero"")
    c1.m[1] = false
    fmt.Println(c1)      // show changes
    fmt.Println(c2)      // show copy unaffected
}",982,37,"package main

import (
    ""reflect""
    ""testing""
)

// TestDeepCopy tests the deepcopy method of the cds struct
func TestDeepCopy(t *testing.T) {
    // Create and populate a structure
    original := &cds{
        i: 1,
        s: ""one"",
        b: []byte(""unit""),
        m: map[int]bool{1: true},
    }

    // Perform a deep copy
    copy := original.deepcopy()

    // Verify that the original and the copy are not the same instance
    if original == copy {
        t.Errorf(""Expected original and copy to be different instances"")
    }

    // Verify that the copied values are the same as the original
    if !reflect.DeepEqual(original, copy) {
        t.Errorf(""Expected original and copy to be equal, got original: %v, copy: %v"", original, copy)
    }

    // Modify the original structure
    original.i = 0
    original.s = ""nil""
    copy(original.b, ""zero"")
    original.m[1] = false

    // Verify that the copy is unaffected by changes to the original
    if reflect.DeepEqual(original, copy) {
        t.Errorf(""Expected original and copy to be different after modification, got original: %v, copy: %v"", original, copy)
    }

    // Verify that the copy still holds the original values
    expectedCopy := &cds{
        i: 1,
        s: ""one"",
        b: []byte(""unit""),
        m: map[int]bool{1: true},
    }

    if !reflect.DeepEqual(copy, expectedCopy) {
        t.Errorf(""Expected copy to hold original values, got: %v, expected: %v"", copy, expectedCopy)
    }
}
",./data/generated/docs_golang/deepcopy/gpt_4o_2024_08_06_deepcopy_test.go,CompileStatus.SYNTAX_ERROR,,,,0.15,1.33,,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: cds', 'Severity': '', 'SourceLines': ['    original := &cds{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_deepcopy_test.go', 'Offset': 0, 'Line': 11, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: cds', 'Severity': '', 'SourceLines': ['    expectedCopy := &cds{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_deepcopy_test.go', 'Offset': 0, 'Line': 43, 'Column': 22}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_deepcopy_test.go', 'line': 34, 'column': 5, 'message': 'invalid operation: cannot call non-function copy (variable of type *cds)'}]"
Delegates,"A delegate is a helper object used by another object. The delegator may send the delegate certain messages, and provide a default implementation when there is no delegate or the delegate does not respond to a message. This pattern is heavily used in Cocoa framework on Mac OS X. See also wp:Delegation pattern.

Objects responsibilities:

Delegator:

 Keep an optional delegate instance.
 Implement ""operation"" method, returning the delegate ""thing"" if the delegate respond to ""thing"", or the string ""default implementation"".
Delegate:

 Implement ""thing"" and return the string ""delegate implementation""
Show how objects are created and used. First, without a delegate, then with a delegate that does not implement ""thing"", and last with a delegate that implements ""thing"".
",Go,"package main
import ""fmt""
 
type Delegator struct {
    delegate interface{} // the delegate may be any type
}
 
// interface that represents anything that supports thing()
type Thingable interface {
    thing() string
}
 
func (self Delegator) operation() string {
    if v, ok := self.delegate.(Thingable); ok {
        return v.thing()
    }
    return ""default implementation""
}
 
type Delegate int // any dummy type
 
func (Delegate) thing() string {
    return ""delegate implementation""
}
 
func main() {
    // Without a delegate:
    a := Delegator{}
    fmt.Println(a.operation()) // prints ""default implementation""
 
    // With a delegate that does not implement ""thing""
    a.delegate = ""A delegate may be any object""
    fmt.Println(a.operation()) // prints ""default implementation""
 
    // With a delegate:
    var d Delegate
    a.delegate = d
    fmt.Println(a.operation()) // prints ""delegate implementation""
}",928,39,"package main

import (
	""testing""
)

type MockDelegateWithoutThing struct{}

func TestDelegatorWithoutDelegate(t *testing.T) {
	delegator := Delegator{}
	expected := ""default implementation""
	result := delegator.operation()
	if result != expected {
		t.Errorf(""Expected %s, but got %s"", expected, result)
	}
}

func TestDelegatorWithDelegateWithoutThing(t *testing.T) {
	delegator := Delegator{delegate: MockDelegateWithoutThing{}}
	expected := ""default implementation""
	result := delegator.operation()
	if result != expected {
		t.Errorf(""Expected %s, but got %s"", expected, result)
	}
}

func TestDelegatorWithDelegateWithThing(t *testing.T) {
	var delegate Delegate
	delegator := Delegator{delegate: delegate}
	expected := ""delegate implementation""
	result := delegator.operation()
	if result != expected {
		t.Errorf(""Expected %s, but got %s"", expected, result)
	}
}
",./data/generated/docs_golang/delegates/gpt_4o_2024_08_06_delegates_test.go,CompileStatus.OK,0.0,36.4,,0.14,0.75,0.114,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: Delegator', 'Severity': '', 'SourceLines': ['\tdelegator := Delegator{}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_delegates_test.go', 'Offset': 0, 'Line': 10, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Delegator', 'Severity': '', 'SourceLines': ['\tdelegator := Delegator{delegate: MockDelegateWithoutThing{}}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_delegates_test.go', 'Offset': 0, 'Line': 19, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Delegate', 'Severity': '', 'SourceLines': ['\tvar delegate Delegate'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_delegates_test.go', 'Offset': 0, 'Line': 28, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Delegator', 'Severity': '', 'SourceLines': ['\tdelegator := Delegator{delegate: delegate}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_delegates_test.go', 'Offset': 0, 'Line': 29, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Department numbers,"There is a highly organized city that has decided to assign a number to each of their departments:

   police department
   sanitation department
   fire department 


Each department can have a number between   1   and   7   (inclusive).

The three department numbers are to be unique (different from each other) and must add up to   12.

The Chief of the Police doesn't like odd numbers and wants to have an even number for his department.



Task

Write a computer program which outputs all valid combinations.



Possible output   (for the 1st and 14th solutions):

 --police--  --sanitation--  --fire-- 
     2             3            7 
     6             5            1


",Go,"package main
 
import ""fmt""
 
func main() {
    fmt.Println(""Police  Sanitation  Fire"")
    fmt.Println(""------  ----------  ----"")
    count := 0
    for i := 2; i < 7; i += 2 {
        for j := 1; j < 8; j++ {
            if j == i { continue }
            for k := 1; k < 8; k++ {
                if k == i || k == j { continue }
                if i + j + k != 12 { continue }
                fmt.Printf(""  %d         %d         %d\n"", i, j, k)
                count++
            }
        }
    }
    fmt.Printf(""\n%d valid combinations\n"", count)
}",555,21,"package main

import (
	""bytes""
	""testing""
)

func TestDepartmentNumbers(t *testing.T) {
	expectedOutput := ""Police  Sanitation  Fire\n"" +
		""------  ----------  ----\n"" +
		"" 2         3         7\n"" +
		"" 2         5         5\n"" +
		"" 2         7         3\n"" +
		"" 4         1         7\n"" +
		"" 4         3         5\n"" +
		"" 4         5         3\n"" +
		"" 4         7         1\n"" +
		"" 6         1         5\n"" +
		"" 6         5         1\n"" +
		""\n9 valid combinations\n""

	var buf bytes.Buffer
	mainOutput := func() {
		old := fmt.Printf
		fmt.Printf = func(format string, a ...interface{}) (n int, err error) {
			return buf.WriteString(fmt.Sprintf(format, a...))
		}
		defer func() { fmt.Printf = old }()
		main()
	}

	mainOutput()

	if buf.String() != expectedOutput {
		t.Errorf(""Output did not match expected.\nGot:\n%s\nExpected:\n%s"", buf.String(), expectedOutput)
	}
}
",./data/generated/docs_golang/department_numbers/gpt_4o_2024_08_06_department_numbers_test.go,CompileStatus.SYNTAX_ERROR,,,,0.04,0.12,,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: fmt', 'Severity': '', 'SourceLines': ['\t\told := fmt.Printf'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_department_numbers_test.go', 'Offset': 0, 'Line': 24, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fmt', 'Severity': '', 'SourceLines': ['\t\tfmt.Printf = func(format string, a ...interface{}) (n int, err error) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_department_numbers_test.go', 'Offset': 0, 'Line': 25, 'Column': 3}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fmt', 'Severity': '', 'SourceLines': ['\t\t\treturn buf.WriteString(fmt.Sprintf(format, a...))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_department_numbers_test.go', 'Offset': 0, 'Line': 26, 'Column': 27}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\t\tmain()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_department_numbers_test.go', 'Offset': 0, 'Line': 29, 'Column': 3}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_department_numbers_test.go', 'line': 24, 'column': 10, 'message': 'undefined: fmt'}]"
Determine if a string is collapsible,"Determine if a character string is   collapsible.

And if so,   collapse the string   (by removing   immediately repeated   characters).



If a character string has   immediately repeated   character(s),   the repeated characters are to be
deleted (removed),   but not the primary (1st) character(s).



An   immediately repeated   character is any character that is   immediately   followed by an
identical character (or characters).   Another word choice could've been   duplicated character,   but that
might have ruled out   (to some readers)   triplicated characters   ···   or more.



{This Rosetta Code task was inspired by a newly introduced   (as of around November 2019)   PL/I   BIF:   collapse.}



Examples

In the following character string:



 The better the 4-wheel drive, the further you'll be from help when ya get stuck! 



Only the 2nd   t,   e, and   l   are repeated characters,   indicated
by underscores (above),   even though they (those characters) appear elsewhere in the character string.



So, after collapsing the string, the result would be:

 The beter the 4-whel drive, the further you'l be from help when ya get stuck! 





Another example:
In the following character string:

 headmistressship 



The ""collapsed"" string would be:

 headmistreship 



Task

Write a subroutine/function/procedure/routine···   to
locate   repeated   characters and   collapse   (delete)   them from the character
string.   The character string can be processed from either direction.



Show all output here, on this page:

   the   original string and its length
   the resultant string and its length
   the above strings should be ""bracketed"" with   <<<   and   >>>   (to delineate blanks)
   «««Guillemets may be used instead for ""bracketing"" for the more artistic programmers,   shown used here»»»


Use (at least) the following five strings,   all strings are length seventy-two (characters, including blanks),   except
the 1st string:

 string
 number
        ╔╗
   1    ║╚═══════════════════════════════════════════════════════════════════════╗   ◄■■■■■■  a null string  (length zero)
   2    ║""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln ║
   3    ║..1111111111111111111111111111111111111111111111111111111111111117777888║
   4    ║I never give 'em hell, I just tell the truth, and they think it's hell. ║
   5    ║                                                    --- Harry S Truman  ║   ◄■■■■■■  has many repeated blanks
        ╚════════════════════════════════════════════════════════════════════════╝


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Go,"package main
 
import ""fmt""
 
// Returns collapsed string, original and new lengths in
// unicode code points (not normalized).
func collapse(s string) (string, int, int) {
    r := []rune(s)
    le, del := len(r), 0
    for i := le - 2; i >= 0; i-- {
        if r[i] == r[i+1] {
            copy(r[i:], r[i+1:])
            del++
        }
    }
    if del == 0 {
        return s, le, le
    }
    r = r[:le-del]
    return string(r), le, len(r)
}
 
func main() {
    strings:= []string {
        """",
        `""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln `,
        ""..1111111111111111111111111111111111111111111111111111111111111117777888"",
        ""I never give 'em hell, I just tell the truth, and they think it's hell. "",
        ""                                                   ---  Harry S Truman  "",
        ""The better the 4-wheel drive, the further you'll be from help when ya get stuck!"",
        ""headmistressship"",
        ""aardvark"",
        ""😍😀🙌💃😍😍😍🙌"",
    }
    for _, s := range strings {
        cs, olen, clen := collapse(s)
        fmt.Printf(""original : length = %2d, string = «««%s»»»\n"", olen, s)
        fmt.Printf(""collapsed: length = %2d, string = «««%s»»»\n\n"", clen, cs)
    }
}",1237,40,"package main

import (
	""testing""
)

func TestCollapse(t *testing.T) {
	tests := []struct {
		input          string
		expectedOutput string
		expectedOLen   int
		expectedCLen   int
	}{
		{"""", """", 0, 0},
		{`""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln `, `""If I were two-faced, would I be wearing this one?"" - Abraham Lincoln `, 72, 70},
		{""..1111111111111111111111111111111111111111111111111111111111111117777888"", "".1"", 72, 2},
		{""I never give 'em hell, I just tell the truth, and they think it's hell. "", ""I never give 'em hel, I just tel the truth, and they think it's hel. "", 72, 70},
		{""                                                   ---  Harry S Truman  "", "" - Hary S Truman "", 72, 17},
		{""The better the 4-wheel drive, the further you'll be from help when ya get stuck!"", ""The beter the 4-whel drive, the further you'll be from help when ya get stuck!"", 80, 78},
		{""headmistressship"", ""headmistreship"", 16, 14},
		{""aardvark"", ""aardvark"", 8, 8},
		{""😍😀🙌💃😍😍😍🙌"", ""😍😀🙌💃😍🙌"", 9, 6},
	}

	for _, test := range tests {
		output, oLen, cLen := collapse(test.input)
		if output != test.expectedOutput || oLen != test.expectedOLen || cLen != test.expectedCLen {
			t.Errorf(""For input %q, expected output %q with lengths (%d, %d), but got output %q with lengths (%d, %d)"",
				test.input, test.expectedOutput, test.expectedOLen, test.expectedCLen, output, oLen, cLen)
		}
	}
}
",./data/generated/docs_golang/determine_if_a_string_is_collapsible/gpt_4o_2024_08_06_determine_if_a_string_is_collapsible_test.go,CompileStatus.OK,0.0,66.7,,0.05,0.17,0.112,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: collapse', 'Severity': '', 'SourceLines': ['\t\toutput, oLen, cLen := collapse(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_determine_if_a_string_is_collapsible_test.go', 'Offset': 0, 'Line': 26, 'Column': 25}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Determine if a string is squeezable,"Determine if a character string is   squeezable.

And if so,   squeeze the string   (by removing any number of
a   specified   immediately repeated   character).



This task is very similar to the task     Determine if a character string is collapsible     except
that only a specified character is   squeezed   instead of any character that is immediately repeated.



If a character string has a specified   immediately repeated   character(s),   the repeated characters are to be
deleted (removed),   but not the primary (1st) character(s).



A specified   immediately repeated   character is any specified character that is   immediately  
followed by an identical character (or characters).   Another word choice could've been   duplicated
character,   but that might have ruled out   (to some readers)   triplicated characters   ···   or more.



{This Rosetta Code task was inspired by a newly introduced   (as of around
November 2019)   PL/I   BIF:   squeeze.}



Examples

In the following character string with a specified   immediately repeated   character of   e:



 The better the 4-wheel drive, the further you'll be from help when ya get stuck! 



Only the 2nd   e   is an specified repeated character,   indicated by an underscore
(above),   even though they (the characters) appear elsewhere in the character string.



So, after squeezing the string, the result would be:

 The better the 4-whel drive, the further you'll be from help when ya get stuck! 





Another example:
In the following character string,   using a specified immediately repeated character   s:

 headmistressship 



The ""squeezed"" string would be:

 headmistreship 



Task

Write a subroutine/function/procedure/routine···   to locate a   specified immediately repeated   character
and   squeeze   (delete)   them from the character string.   The
character string can be processed from either direction.



Show all output here, on this page:

   the   specified repeated character   (to be searched for and possibly squeezed):
   the   original string and its length
   the resultant string and its length
   the above strings should be ""bracketed"" with   <<<   and   >>>   (to delineate blanks)
   «««Guillemets may be used instead for ""bracketing"" for the more artistic programmers,   shown used here»»»


Use (at least) the following five strings,   all strings are length seventy-two (characters, including blanks),   except
the 1st string:

                                                                                  immediately
 string                                                                            repeated
 number                                                                            character
                                                                                     ( ↓   a blank,  a minus,  a seven,  a period)
        ╔╗
   1    ║╚═══════════════════════════════════════════════════════════════════════╗    ' '    ◄■■■■■■  a null string  (length zero)
   2    ║""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln ║    '-'
   3    ║..1111111111111111111111111111111111111111111111111111111111111117777888║    '7'
   4    ║I never give 'em hell, I just tell the truth, and they think it's hell. ║    '.'
   5    ║                                                    --- Harry S Truman  ║  (below)  ◄■■■■■■  has many repeated blanks
        ╚════════════════════════════════════════════════════════════════════════╝     ↑
                                                                                       │
                                                                                       │
        For the 5th string  (Truman's signature line),  use each of these  specified immediately  repeated characters:
                                  •  a blank
                                  •  a minus
                                  •  a lowercase  r



Note:   there should be seven results shown,   one each for the 1st four strings,   and three results for
the 5th string.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Go,"package main
 
import ""fmt""
 
// Returns squeezed string, original and new lengths in
// unicode code points (not normalized).
func squeeze(s string, c rune) (string, int, int) {
    r := []rune(s)
    le, del := len(r), 0
    for i := le - 2; i >= 0; i-- {
        if r[i] == c && r[i] == r[i+1] {
            copy(r[i:], r[i+1:])
            del++
        }
    }
    if del == 0 {
        return s, le, le
    }
    r = r[:le-del]
    return string(r), le, len(r)
}
 
func main() {
    strings := []string{
        """",
        `""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln `,
        ""..1111111111111111111111111111111111111111111111111111111111111117777888"",
        ""I never give 'em hell, I just tell the truth, and they think it's hell. "",
        ""                                                   ---  Harry S Truman  "",
        ""The better the 4-wheel drive, the further you'll be from help when ya get stuck!"",
        ""headmistressship"",
        ""aardvark"",
        ""😍😀🙌💃😍😍😍🙌"",
    }
    chars := [][]rune{{' '}, {'-'}, {'7'}, {'.'}, {' ', '-', 'r'}, {'e'}, {'s'}, {'a'}, {'😍'}}
 
    for i, s := range strings {
        for _, c := range chars[i] {
            ss, olen, slen := squeeze(s, c)
            fmt.Printf(""specified character = %q\n"", c)
            fmt.Printf(""original : length = %2d, string = «««%s»»»\n"", olen, s)
            fmt.Printf(""squeezed : length = %2d, string = «««%s»»»\n\n"", slen, ss)
        }
    }
}",1470,45,"package main

import (
	""testing""
)

func TestSqueeze(t *testing.T) {
	tests := []struct {
		input    string
		char     rune
		expected string
	}{
		{"""", ' ', """"},
		{`""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln `, '-', `""If I were two-faced, would I be wearing this one?"" -- Abraham Lincoln `},
		{""..1111111111111111111111111111111111111111111111111111111111111117777888"", '7', ""..1111111111111111111111111111111111111111111111111111111111111117888""},
		{""I never give 'em hell, I just tell the truth, and they think it's hell. "", '.', ""I never give 'em hell, I just tell the truth, and they think it's hell ""},
		{""                                                   ---  Harry S Truman  "", ' ', "" --- Harry S Truman ""},
		{""                                                   ---  Harry S Truman  "", '-', ""                                                   - Harry S Truman  ""},
		{""                                                   ---  Harry S Truman  "", 'r', ""                                                   ---  Hary S Truman  ""},
		{""The better the 4-wheel drive, the further you'll be from help when ya get stuck!"", 'e', ""The beter the 4-whel drive, the further you'll be from help when ya get stuck!""},
		{""headmistressship"", 's', ""headmistreship""},
		{""aardvark"", 'a', ""ardvark""},
		{""😍😀🙌💃😍😍😍🙌"", '😍', ""😍😀🙌💃😍🙌""},
	}

	for _, test := range tests {
		result, _, _ := squeeze(test.input, test.char)
		if result != test.expected {
			t.Errorf(""For input '%s' with char '%c', expected '%s' but got '%s'"", test.input, test.char, test.expected, result)
		}
	}
}
",./data/generated/docs_golang/determine_if_a_string_is_squeezable/gpt_4o_2024_08_06_determine_if_a_string_is_squeezable_test.go,CompileStatus.SYNTAX_ERROR,,,,0.09,0.12,,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: squeeze', 'Severity': '', 'SourceLines': ['\t\tresult, _, _ := squeeze(test.input, test.char)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_determine_if_a_string_is_squeezable_test.go', 'Offset': 0, 'Line': 27, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,[]
Determine if only one instance is running,"This task is to determine if there is only one instance of an application running. If the program discovers that an instance of it is already running, then it should display a message indicating that it is already running and exit.
",Go,"package main
 
import (
    ""fmt""
    ""net""
    ""time""
)
 
const lNet = ""tcp""
const lAddr = "":12345""
 
func main() {
    if _, err := net.Listen(lNet, lAddr); err != nil {
        fmt.Println(""an instance was already running"")
        return
    }
    fmt.Println(""single instance started"")
    time.Sleep(10 * time.Second)
}",325,19,"package main

import (
    ""bytes""
    ""os/exec""
    ""strings""
    ""testing""
    ""time""
)

func TestSingleInstance(t *testing.T) {
    // Start the first instance
    cmd1 := exec.Command(""go"", ""run"", ""determine_if_only_one_instance_is_running.go"")
    var out1 bytes.Buffer
    cmd1.Stdout = &out1
    err1 := cmd1.Start()
    if err1 != nil {
        t.Fatalf(""Failed to start first instance: %v"", err1)
    }

    // Give the first instance some time to start
    time.Sleep(1 * time.Second)

    // Start the second instance
    cmd2 := exec.Command(""go"", ""run"", ""determine_if_only_one_instance_is_running.go"")
    var out2 bytes.Buffer
    cmd2.Stdout = &out2
    err2 := cmd2.Start()
    if err2 != nil {
        t.Fatalf(""Failed to start second instance: %v"", err2)
    }

    // Wait for the second instance to finish
    err2 = cmd2.Wait()
    if err2 != nil {
        t.Fatalf(""Second instance did not exit cleanly: %v"", err2)
    }

    // Check the output of the second instance
    if !strings.Contains(out2.String(), ""an instance was already running"") {
        t.Errorf(""Expected 'an instance was already running' message, got: %s"", out2.String())
    }

    // Wait for the first instance to finish
    err1 = cmd1.Wait()
    if err1 != nil {
        t.Fatalf(""First instance did not exit cleanly: %v"", err1)
    }

    // Check the output of the first instance
    if !strings.Contains(out1.String(), ""single instance started"") {
        t.Errorf(""Expected 'single instance started' message, got: %s"", out1.String())
    }
}
",./data/generated/docs_golang/determine_if_only_one_instance_is_running/gpt_4o_2024_08_06_determine_if_only_one_instance_is_running_test.go,CompileStatus.OK,0.0,0.0,,0.31,4.0,12.943999999999999,0.0,[],False,False,100.0,False,[]
Determine if two triangles overlap,"Determining if two triangles in the same plane overlap is an important topic in collision detection.



Task

Determine which of these pairs of triangles overlap in 2D:

   (0,0),(5,0),(0,5)     and   (0,0),(5,0),(0,6)
   (0,0),(0,5),(5,0)     and   (0,0),(0,5),(5,0)
   (0,0),(5,0),(0,5)     and   (-10,0),(-5,0),(-1,6)
   (0,0),(5,0),(2.5,5)   and   (0,4),(2.5,-1),(5,4)
   (0,0),(1,1),(0,2)     and   (2,1),(3,0),(3,2)
   (0,0),(1,1),(0,2)     and   (2,1),(3,-2),(3,4)


Optionally, see what the result is when only a single corner is in contact (there is no definitive correct answer):

   (0,0),(1,0),(0,1)   and   (1,0),(2,0),(1,1)

",Go,"package main
 
import ""fmt""
 
type point struct {
    x, y float64
}
 
func (p point) String() string {
    return fmt.Sprintf(""(%.1f, %.1f)"", p.x, p.y)
}
 
type triangle struct {
    p1, p2, p3 point
}
 
func (t *triangle) String() string {
    return fmt.Sprintf(""Triangle %s, %s, %s"", t.p1, t.p2, t.p3)
}
 
func (t *triangle) det2D() float64 {
    return t.p1.x * (t.p2.y - t.p3.y) +
           t.p2.x * (t.p3.y - t.p1.y) +
           t.p3.x * (t.p1.y - t.p2.y) 
}
 
func (t *triangle) checkTriWinding(allowReversed bool) {
    detTri := t.det2D()
    if detTri < 0.0 {
        if allowReversed {
            a := t.p3
            t.p3 = t.p2
            t.p2 = a
        } else {
            panic(""Triangle has wrong winding direction."")
        }
    }
}
 
func boundaryCollideChk(t *triangle, eps float64) bool {
    return t.det2D() < eps
}
 
func boundaryDoesntCollideChk(t *triangle, eps float64) bool {
    return t.det2D() <= eps
}
 
func triTri2D(t1, t2 *triangle, eps float64, allowReversed, onBoundary bool) bool {
    // Triangles must be expressed anti-clockwise.
    t1.checkTriWinding(allowReversed)
    t2.checkTriWinding(allowReversed)
 
    // 'onBoundary' determines whether points on boundary are considered as colliding or not.
    var chkEdge func (*triangle, float64) bool
    if onBoundary {
        chkEdge = boundaryCollideChk
    } else {
        chkEdge = boundaryDoesntCollideChk
    }
    lp1 := [3]point{t1.p1, t1.p2, t1.p3}
    lp2 := [3]point{t2.p1, t2.p2, t2.p3}
 
    // for each edge E of t1
    for i := 0; i < 3; i++ {
        j := (i + 1) % 3
        // Check all points of t2 lay on the external side of edge E.
        // If they do, the triangles do not overlap.
        tri1 := &triangle{lp1[i], lp1[j], lp2[0]}
        tri2 := &triangle{lp1[i], lp1[j], lp2[1]}
        tri3 := &triangle{lp1[i], lp1[j], lp2[2]}
        if chkEdge(tri1, eps) && chkEdge(tri2, eps) && chkEdge(tri3, eps) {
            return false
        }
    }
 
    // for each edge E of t2
    for i := 0; i < 3; i++ {
        j := (i + 1) % 3
        // Check all points of t1 lay on the external side of edge E.
        // If they do, the triangles do not overlap.
        tri1 := &triangle{lp2[i], lp2[j], lp1[0]}
        tri2 := &triangle{lp2[i], lp2[j], lp1[1]}
        tri3 := &triangle{lp2[i], lp2[j], lp1[2]}
        if chkEdge(tri1, eps) && chkEdge(tri2, eps) && chkEdge(tri3, eps) {
            return false
        }
    }
 
    // The triangles overlap.
    return true
}
 
func iff(cond bool, s1, s2 string) string {
    if cond {
        return s1
    }
    return s2
}
 
func main() {
    t1 := &triangle{point{0.0, 0.0}, point{5.0, 0.0}, point{0.0, 5.0}}
    t2 := &triangle{point{0.0, 0.0}, point{5.0, 0.0}, point{0.0, 6.0}}
    fmt.Printf(""%s and\n%s\n"", t1, t2)
    overlapping := triTri2D(t1, t2, 0.0, false, true)
    fmt.Println(iff(overlapping, ""overlap"", ""do not overlap""))
 
    // Need to allow reversed for this pair to avoid panic.
    t1 = &triangle{point{0.0, 0.0}, point{0.0, 5.0}, point{5.0, 0.0}}
    t2 = t1
    fmt.Printf(""\n%s and\n%s\n"", t1, t2)
    overlapping = triTri2D(t1, t2, 0.0, true, true)
    fmt.Println(iff(overlapping, ""overlap (reversed)"", ""do not overlap""))
 
    t1 = &triangle{point{0.0, 0.0}, point{5.0, 0.0}, point{0.0, 5.0}}
    t2 = &triangle{point{-10.0, 0.0}, point{-5.0, 0.0}, point{-1.0, 6.0}}
    fmt.Printf(""\n%s and\n%s\n"", t1, t2)
    overlapping = triTri2D(t1, t2, 0.0, false, true)
    fmt.Println(iff(overlapping, ""overlap"", ""do not overlap""))
 
    t1.p3 = point{2.5, 5.0}
    t2 = &triangle{point{0.0, 4.0}, point{2.5, -1.0}, point{5.0, 4.0}}
    fmt.Printf(""\n%s and\n%s\n"", t1, t2)
    overlapping = triTri2D(t1, t2, 0.0, false, true)
    fmt.Println(iff(overlapping, ""overlap"", ""do not overlap""))
 
    t1 = &triangle{point{0.0, 0.0}, point{1.0, 1.0}, point{0.0, 2.0}}
    t2 = &triangle{point{2.0, 1.0}, point{3.0, 0.0}, point{3.0, 2.0}}
    fmt.Printf(""\n%s and\n%s\n"", t1, t2)
    overlapping = triTri2D(t1, t2, 0.0, false, true)
    fmt.Println(iff(overlapping, ""overlap"", ""do not overlap""))
 
    t2 = &triangle{point{2.0, 1.0}, point{3.0, -2.0}, point{3.0, 4.0}}
    fmt.Printf(""\n%s and\n%s\n"", t1, t2)
    overlapping = triTri2D(t1, t2, 0.0, false, true)
    fmt.Println(iff(overlapping, ""overlap"", ""do not overlap""))
 
    t1 = &triangle{point{0.0, 0.0}, point{1.0, 0.0}, point{0.0, 1.0}}
    t2 = &triangle{point{1.0, 0.0}, point{2.0, 0.0}, point{1.0, 1.1}}
    fmt.Printf(""\n%s and\n%s\n"", t1, t2)
    println(""which have only a single corner in contact, if boundary points collide"")
    overlapping = triTri2D(t1, t2, 0.0, false, true)
    fmt.Println(iff(overlapping, ""overlap"", ""do not overlap""))
 
    fmt.Printf(""\n%s and\n%s\n"", t1, t2)
    fmt.Println(""which have only a single corner in contact, if boundary points do not collide"")
    overlapping = triTri2D(t1, t2, 0.0, false, false)
    fmt.Println(iff(overlapping, ""overlap"", ""do not overlap""))
}",4959,148,"package main

import (
	""testing""
)

func TestTrianglesOverlap(t *testing.T) {
	tests := []struct {
		t1, t2       *triangle
		allowReversed bool
		onBoundary    bool
		expected      bool
	}{
		{
			t1:            &triangle{point{0.0, 0.0}, point{5.0, 0.0}, point{0.0, 5.0}},
			t2:            &triangle{point{0.0, 0.0}, point{5.0, 0.0}, point{0.0, 6.0}},
			allowReversed: false,
			onBoundary:    true,
			expected:      true,
		},
		{
			t1:            &triangle{point{0.0, 0.0}, point{0.0, 5.0}, point{5.0, 0.0}},
			t2:            &triangle{point{0.0, 0.0}, point{0.0, 5.0}, point{5.0, 0.0}},
			allowReversed: true,
			onBoundary:    true,
			expected:      true,
		},
		{
			t1:            &triangle{point{0.0, 0.0}, point{5.0, 0.0}, point{0.0, 5.0}},
			t2:            &triangle{point{-10.0, 0.0}, point{-5.0, 0.0}, point{-1.0, 6.0}},
			allowReversed: false,
			onBoundary:    true,
			expected:      false,
		},
		{
			t1:            &triangle{point{0.0, 0.0}, point{5.0, 0.0}, point{2.5, 5.0}},
			t2:            &triangle{point{0.0, 4.0}, point{2.5, -1.0}, point{5.0, 4.0}},
			allowReversed: false,
			onBoundary:    true,
			expected:      true,
		},
		{
			t1:            &triangle{point{0.0, 0.0}, point{1.0, 1.0}, point{0.0, 2.0}},
			t2:            &triangle{point{2.0, 1.0}, point{3.0, 0.0}, point{3.0, 2.0}},
			allowReversed: false,
			onBoundary:    true,
			expected:      false,
		},
		{
			t1:            &triangle{point{0.0, 0.0}, point{1.0, 1.0}, point{0.0, 2.0}},
			t2:            &triangle{point{2.0, 1.0}, point{3.0, -2.0}, point{3.0, 4.0}},
			allowReversed: false,
			onBoundary:    true,
			expected:      false,
		},
		{
			t1:            &triangle{point{0.0, 0.0}, point{1.0, 0.0}, point{0.0, 1.0}},
			t2:            &triangle{point{1.0, 0.0}, point{2.0, 0.0}, point{1.0, 1.0}},
			allowReversed: false,
			onBoundary:    true,
			expected:      true,
		},
		{
			t1:            &triangle{point{0.0, 0.0}, point{1.0, 0.0}, point{0.0, 1.0}},
			t2:            &triangle{point{1.0, 0.0}, point{2.0, 0.0}, point{1.0, 1.0}},
			allowReversed: false,
			onBoundary:    false,
			expected:      false,
		},
	}

	for _, test := range tests {
		result := triTri2D(test.t1, test.t2, 0.0, test.allowReversed, test.onBoundary)
		if result != test.expected {
			t.Errorf(""Expected overlap to be %v, but got %v for triangles %v and %v"", test.expected, result, test.t1, test.t2)
		}
	}
}
",./data/generated/docs_golang/determine_if_two_triangles_overlap/gpt_4o_2024_08_06_determine_if_two_triangles_overlap_test.go,CompileStatus.OK,0.0,41.6,,0.02,0.05,0.117,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: triangle', 'Severity': '', 'SourceLines': ['\t\tt1, t2       *triangle'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_determine_if_two_triangles_overlap_test.go', 'Offset': 0, 'Line': 9, 'Column': 17}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: triangle', 'Severity': '', 'SourceLines': ['\t\t\tt1:            &triangle{point{0.0, 0.0}, point{5.0, 0.0}, point{0.0, 5.0}},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_determine_if_two_triangles_overlap_test.go', 'Offset': 0, 'Line': 15, 'Column': 20}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: triangle', 'Severity': '', 'SourceLines': ['\t\t\tt2:            &triangle{point{0.0, 0.0}, point{5.0, 0.0}, point{0.0, 6.0}},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_determine_if_two_triangles_overlap_test.go', 'Offset': 0, 'Line': 16, 'Column': 20}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: triTri2D', 'Severity': '', 'SourceLines': ['\t\tresult := triTri2D(test.t1, test.t2, 0.0, test.allowReversed, test.onBoundary)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_determine_if_two_triangles_overlap_test.go', 'Offset': 0, 'Line': 73, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Digital root,"The digital root, 



X


{\displaystyle X}

, of a number, 



n


{\displaystyle n}

, is calculated:

 find 



X


{\displaystyle X}

 as the sum of the digits of 



n


{\displaystyle n}


 find a new 



X


{\displaystyle X}

 by summing the digits of 



X


{\displaystyle X}

, repeating until 



X


{\displaystyle X}

 has only one digit.
The additive persistence is the number of summations required to obtain the single digit.

The task is to calculate the additive persistence and the digital root of a number, e.g.:





627615


{\displaystyle 627615}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



9


{\displaystyle 9}

;




39390


{\displaystyle 39390}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



6


{\displaystyle 6}

;




588225


{\displaystyle 588225}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



3


{\displaystyle 3}

;




393900588225


{\displaystyle 393900588225}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



9


{\displaystyle 9}

;
The digital root may be calculated in bases other than 10.



See

 Casting out nines for this wiki's use of this procedure.
 Digital root/Multiplicative digital root
 Sum digits of an integer
 Digital root sequence on OEIS
 Additive persistence sequence on OEIS
 Iterated digits squaring

",Go,"package main
 
import (
	""fmt""
	""log""
	""strconv""
)
 
func Sum(i uint64, base int) (sum int) {
	b64 := uint64(base)
	for ; i > 0; i /= b64 {
		sum += int(i % b64)
	}
	return
}
 
func DigitalRoot(n uint64, base int) (persistence, root int) {
	root = int(n)
	for x := n; x >= uint64(base); x = uint64(root) {
		root = Sum(x, base)
		persistence++
	}
	return
}
 
// Normally the below would be moved to a *_test.go file and
// use the testing package to be runnable as a regular test.
 
var testCases = []struct {
	n           string
	base        int
	persistence int
	root        int
}{
	{""627615"", 10, 2, 9},
	{""39390"", 10, 2, 6},
	{""588225"", 10, 2, 3},
	{""393900588225"", 10, 2, 9},
	{""1"", 10, 0, 1},
	{""11"", 10, 1, 2},
	{""e"", 16, 0, 0xe},
	{""87"", 16, 1, 0xf},
	// From Applesoft BASIC example:
	{""DigitalRoot"", 30, 2, 26}, // 26 is Q base 30
	// From C++ example:
	{""448944221089"", 10, 3, 1},
	{""7e0"", 16, 2, 0x6},
	{""14e344"", 16, 2, 0xf},
	{""d60141"", 16, 2, 0xa},
	{""12343210"", 16, 2, 0x1},
	// From the D example:
	{""1101122201121110011000000"", 3, 3, 1},
}
 
func main() {
	for _, tc := range testCases {
		n, err := strconv.ParseUint(tc.n, tc.base, 64)
		if err != nil {
			log.Fatal(err)
		}
		p, r := DigitalRoot(n, tc.base)
		fmt.Printf(""%12v (base %2d) has additive persistence %d and digital root %s\n"",
			tc.n, tc.base, p, strconv.FormatInt(int64(r), tc.base))
		if p != tc.persistence || r != tc.root {
			log.Fatalln(""bad result:"", tc, p, r)
		}
	}
}",1461,68,"package main

import (
	""strconv""
	""testing""
)

func TestDigitalRoot(t *testing.T) {
	testCases := []struct {
		n           string
		base        int
		persistence int
		root        int
	}{
		{""627615"", 10, 2, 9},
		{""39390"", 10, 2, 6},
		{""588225"", 10, 2, 3},
		{""393900588225"", 10, 2, 9},
		{""1"", 10, 0, 1},
		{""11"", 10, 1, 2},
		{""e"", 16, 0, 0xe},
		{""87"", 16, 1, 0xf},
		{""DigitalRoot"", 30, 2, 26}, // 26 is Q base 30
		{""448944221089"", 10, 3, 1},
		{""7e0"", 16, 2, 0x6},
		{""14e344"", 16, 2, 0xf},
		{""d60141"", 16, 2, 0xa},
		{""12343210"", 16, 2, 0x1},
		{""1101122201121110011000000"", 3, 3, 1},
	}

	for _, tc := range testCases {
		t.Run(tc.n, func(t *testing.T) {
			n, err := strconv.ParseUint(tc.n, tc.base, 64)
			if err != nil {
				t.Fatalf(""Failed to parse number: %v"", err)
			}
			p, r := DigitalRoot(n, tc.base)
			if p != tc.persistence || r != tc.root {
				t.Errorf(""For %s (base %d): expected persistence %d and root %d, got persistence %d and root %d"",
					tc.n, tc.base, tc.persistence, tc.root, p, r)
			}
		})
	}
}
",./data/generated/docs_golang/digital_root/gpt_4o_2024_08_06_digital_root_test.go,CompileStatus.OK,0.0,52.9,,0.06,0.22,0.119,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: DigitalRoot', 'Severity': '', 'SourceLines': ['\t\t\tp, r := DigitalRoot(n, tc.base)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_digital_root_test.go', 'Offset': 0, 'Line': 38, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Digital root/Multiplicative digital root,"The multiplicative digital root (MDR) and multiplicative persistence (MP) of a number, 



n


{\displaystyle n}

, is calculated rather like the Digital root except digits are multiplied instead of being added:

 Set 



m


{\displaystyle m}

 to 



n


{\displaystyle n}

 and 



i


{\displaystyle i}

 to 



0


{\displaystyle 0}

.
 While 



m


{\displaystyle m}

 has more than one digit:
 Find a replacement 



m


{\displaystyle m}

 as the multiplication of the digits of the current value of 



m


{\displaystyle m}

.
 Increment 



i


{\displaystyle i}

.
 Return 



i


{\displaystyle i}

 (= MP) and 



m


{\displaystyle m}

 (= MDR)


Task

 Tabulate the MP and MDR of the numbers 123321, 7739, 893, 899998
 Tabulate MDR versus the first five numbers having that MDR, something like:
MDR: [n0..n4]
===  ========
  0: [0, 10, 20, 25, 30]
  1: [1, 11, 111, 1111, 11111]
  2: [2, 12, 21, 26, 34]
  3: [3, 13, 31, 113, 131]
  4: [4, 14, 22, 27, 39]
  5: [5, 15, 35, 51, 53]
  6: [6, 16, 23, 28, 32]
  7: [7, 17, 71, 117, 171]
  8: [8, 18, 24, 29, 36]
  9: [9, 19, 33, 91, 119]

Show all output on this page.

Similar

The Product of decimal digits of n page was redirected here, and had the following description


Find the product of the decimal digits of a positive integer   n,   where n <= 100

The three existing entries for Phix, REXX, and Ring have been moved here, under ===Similar=== headings, feel free to match or ignore them.



References

 Multiplicative Digital Root on Wolfram Mathworld.
 Multiplicative digital root on The On-Line Encyclopedia of Integer Sequences.
 What's special about 277777788888899? - Numberphile video

",Go,"package main
 
import ""fmt""
 
// Only valid for n > 0 && base >= 2
func mult(n uint64, base int) (mult uint64) {
	for mult = 1; mult > 0 && n > 0; n /= uint64(base) {
		mult *= n % uint64(base)
	}
	return
}
 
// Only valid for n >= 0 && base >= 2
func MultDigitalRoot(n uint64, base int) (mp, mdr int) {
	var m uint64
	for m = n; m >= uint64(base); mp++ {
		m = mult(m, base)
	}
	return mp, int(m)
}
 
func main() {
	const base = 10
	const size = 5
 
	const testFmt = ""%20v %3v %3v\n""
	fmt.Printf(testFmt, ""Number"", ""MDR"", ""MP"")
	for _, n := range [...]uint64{
		123321, 7739, 893, 899998,
		18446743999999999999,
		// From http://mathworld.wolfram.com/MultiplicativePersistence.html
		3778888999, 277777788888899,
	} {
		mp, mdr := MultDigitalRoot(n, base)
		fmt.Printf(testFmt, n, mdr, mp)
	}
	fmt.Println()
 
	var list [base][]uint64
	for i := range list {
		list[i] = make([]uint64, 0, size)
	}
	for cnt, n := size*base, uint64(0); cnt > 0; n++ {
		_, mdr := MultDigitalRoot(n, base)
		if len(list[mdr]) < size {
			list[mdr] = append(list[mdr], n)
			cnt--
		}
	}
	const tableFmt = ""%3v: %v\n""
	fmt.Printf(tableFmt, ""MDR"", ""First"")
	for i, l := range list {
		fmt.Printf(tableFmt, i, l)
	}
}",1196,55,error,,,,,,,,,,,False,False,,False,
Dijkstra's algorithm,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.

Dijkstra's algorithm, conceived by Dutch computer scientist Edsger Dijkstra in 1956 and published in 1959, is a graph search algorithm that solves the single-source shortest path problem for a graph with non-negative edge path costs, producing a shortest path tree.

This algorithm is often used in routing and as a subroutine in other graph algorithms.



For a given source vertex (node) in the graph, the algorithm finds the path with lowest cost (i.e. the shortest path) between that vertex and every other vertex.



For instance

If the vertices of the graph represent cities and edge path costs represent driving distances between pairs of cities connected by a direct road,   Dijkstra's algorithm can be used to find the shortest route between one city and all other cities.

As a result, the shortest path first is widely used in network routing protocols, most notably:

   IS-IS   (Intermediate System to Intermediate System)   and 
   OSPF   (Open Shortest Path First).


Important note
 
The inputs to Dijkstra's algorithm are a directed and weighted graph consisting of 2 or more nodes, generally represented by:

   an adjacency matrix or list,   and
   a start node. 


A destination node is not specified.

The output is a set of edges depicting the shortest path to each destination node.



An example, starting with

                                         a──►b,  cost=7,   lastNode=a  
                                         a──►c,  cost=9,   lastNode=a 
                                         a──►d,  cost=NA,  lastNode=a
                                         a──►e,  cost=NA,  lastNode=a 
                                         a──►f,  cost=14,  lastNode=a
 
    The lowest cost is    a──►b    so    a──►b    is added to the output. 
 
    There is a connection from   b──►d   so the input is updated to: 
                                         a──►c,  cost=9,   lastNode=a 
                                         a──►d,  cost=22,  lastNode=b 
                                         a──►e,  cost=NA,  lastNode=a 
                                         a──►f,  cost=14,  lastNode=a
 
    The lowest cost is    a──►c    so    a──►c    is added to the output. 
 
    Paths to    d    and    f    are cheaper via    c    so the input is updated to:
                                         a──►d,  cost=20,  lastNode=c 
                                         a──►e,  cost=NA,  lastNode=a 
                                         a──►f,  cost=11,  lastNode=c
 
    The lowest cost is    a──►f    so    c──►f    is added to the output. 
 
    The input is updated to:
                                         a──►d,  cost=20,  lastNode=c 
                                         a──►e,  cost=NA,  lastNode=a
 
    The lowest cost is    a──►d    so    c──►d    is added to the output. 
 
    There is a connection from    d──►e    so the input is updated to:
                                         a──►e,  cost=26,  lastNode=d
 
    Which just leaves adding    d──►e    to the output.
 
    The output should now be:
                                       [ d──►e
                                         c──►d
                                         c──►f
                                         a──►c
                                         a──►b ]   


Task

 Implement a version of Dijkstra's algorithm that outputs a set of edges depicting the shortest path to each reachable node from an origin.
 Run your program with the following directed graph starting at node    a.
 Write a program which interprets the output from the above and use it to output the shortest path from node    a    to nodes    e    and  f. 

 Vertices


 Number 
 Name


 1 
 a


 2 
 b


 3 
 c


 4 
 d


 5 
 e


 6 
 f


 Edges


 Start 
 End 
 Cost


 a 
 b 
 7


 a 
 c 
 9


 a 
 f 
 14


 b 
 c 
 10


 b 
 d 
 15


 c 
 d 
 11


 c 
 f 
 2


 d 
 e 
 6


 e 
 f 
 9



You can use numbers or names to identify vertices in your program.



See also
 Dijkstra's Algorithm vs. A* Search vs. Concurrent Dijkstra's Algorithm (youtube)

",Go,"package main
 
import (
	""container/heap""
	""fmt""
)
 
// A PriorityQueue implements heap.Interface and holds Items.
type PriorityQueue struct {
	items []Vertex
	m     map[Vertex]int // value to index
	pr    map[Vertex]int // value to priority
}
 
func (pq *PriorityQueue) Len() int           { return len(pq.items) }
func (pq *PriorityQueue) Less(i, j int) bool { return pq.pr[pq.items[i]] < pq.pr[pq.items[j]] }
func (pq *PriorityQueue) Swap(i, j int) {
	pq.items[i], pq.items[j] = pq.items[j], pq.items[i]
	pq.m[pq.items[i]] = i
	pq.m[pq.items[j]] = j
}
func (pq *PriorityQueue) Push(x interface{}) {
	n := len(pq.items)
	item := x.(Vertex)
	pq.m[item] = n
	pq.items = append(pq.items, item)
}
func (pq *PriorityQueue) Pop() interface{} {
	old := pq.items
	n := len(old)
	item := old[n-1]
	pq.m[item] = -1
	pq.items = old[0 : n-1]
	return item
}
 
// update modifies the priority of an item in the queue.
func (pq *PriorityQueue) update(item Vertex, priority int) {
	pq.pr[item] = priority
	heap.Fix(pq, pq.m[item])
}
func (pq *PriorityQueue) addWithPriority(item Vertex, priority int) {
	heap.Push(pq, item)
	pq.update(item, priority)
}
 
const (
	Infinity      = int(^uint(0) >> 1)
	Uninitialized = -1
)
 
func Dijkstra(g Graph, source Vertex) (dist map[Vertex]int, prev map[Vertex]Vertex) {
	vs := g.Vertices()
	dist = make(map[Vertex]int, len(vs))
	prev = make(map[Vertex]Vertex, len(vs))
	sid := source
	dist[sid] = 0
	q := &PriorityQueue{
		items: make([]Vertex, 0, len(vs)),
		m:     make(map[Vertex]int, len(vs)),
		pr:    make(map[Vertex]int, len(vs)),
	}
	for _, v := range vs {
		if v != sid {
			dist[v] = Infinity
		}
		prev[v] = Uninitialized
		q.addWithPriority(v, dist[v])
	}
	for len(q.items) != 0 {
		u := heap.Pop(q).(Vertex)
		for _, v := range g.Neighbors(u) {
			alt := dist[u] + g.Weight(u, v)
			if alt < dist[v] {
				dist[v] = alt
				prev[v] = u
				q.update(v, alt)
			}
		}
	}
	return dist, prev
}
 
// A Graph is the interface implemented by graphs that
// this algorithm can run on.
type Graph interface {
	Vertices() []Vertex
	Neighbors(v Vertex) []Vertex
	Weight(u, v Vertex) int
}
 
// Nonnegative integer ID of vertex
type Vertex int
 
// sg is a graph of strings that satisfies the Graph interface.
type sg struct {
	ids   map[string]Vertex
	names map[Vertex]string
	edges map[Vertex]map[Vertex]int
}
 
func newsg(ids map[string]Vertex) sg {
	g := sg{ids: ids}
	g.names = make(map[Vertex]string, len(ids))
	for k, v := range ids {
		g.names[v] = k
	}
	g.edges = make(map[Vertex]map[Vertex]int)
	return g
}
func (g sg) edge(u, v string, w int) {
	if _, ok := g.edges[g.ids[u]]; !ok {
		g.edges[g.ids[u]] = make(map[Vertex]int)
	}
	g.edges[g.ids[u]][g.ids[v]] = w
}
func (g sg) path(v Vertex, prev map[Vertex]Vertex) (s string) {
	s = g.names[v]
	for prev[v] >= 0 {
		v = prev[v]
		s = g.names[v] + s
	}
	return s
}
func (g sg) Vertices() []Vertex {
	vs := make([]Vertex, 0, len(g.ids))
	for _, v := range g.ids {
		vs = append(vs, v)
	}
	return vs
}
func (g sg) Neighbors(u Vertex) []Vertex {
	vs := make([]Vertex, 0, len(g.edges[u]))
	for v := range g.edges[u] {
		vs = append(vs, v)
	}
	return vs
}
func (g sg) Weight(u, v Vertex) int { return g.edges[u][v] }
 
func main() {
	g := newsg(map[string]Vertex{
		""a"": 1,
		""b"": 2,
		""c"": 3,
		""d"": 4,
		""e"": 5,
		""f"": 6,
	})
	g.edge(""a"", ""b"", 7)
	g.edge(""a"", ""c"", 9)
	g.edge(""a"", ""f"", 14)
	g.edge(""b"", ""c"", 10)
	g.edge(""b"", ""d"", 15)
	g.edge(""c"", ""d"", 11)
	g.edge(""c"", ""f"", 2)
	g.edge(""d"", ""e"", 6)
	g.edge(""e"", ""f"", 9)
 
	dist, prev := Dijkstra(g, g.ids[""a""])
	fmt.Printf(""Distance to %s: %d, Path: %s\n"", ""e"", dist[g.ids[""e""]], g.path(g.ids[""e""], prev))
	fmt.Printf(""Distance to %s: %d, Path: %s\n"", ""f"", dist[g.ids[""f""]], g.path(g.ids[""f""], prev))
}",3734,163,"package main

import (
	""reflect""
	""testing""
)

// TestDijkstra tests the Dijkstra function with a sample graph.
func TestDijkstra(t *testing.T) {
	g := newsg(map[string]Vertex{
		""a"": 1,
		""b"": 2,
		""c"": 3,
		""d"": 4,
		""e"": 5,
		""f"": 6,
	})
	g.edge(""a"", ""b"", 7)
	g.edge(""a"", ""c"", 9)
	g.edge(""a"", ""f"", 14)
	g.edge(""b"", ""c"", 10)
	g.edge(""b"", ""d"", 15)
	g.edge(""c"", ""d"", 11)
	g.edge(""c"", ""f"", 2)
	g.edge(""d"", ""e"", 6)
	g.edge(""e"", ""f"", 9)

	dist, prev := Dijkstra(g, g.ids[""a""])

	expectedDist := map[Vertex]int{
		g.ids[""a""]: 0,
		g.ids[""b""]: 7,
		g.ids[""c""]: 9,
		g.ids[""d""]: 20,
		g.ids[""e""]: 26,
		g.ids[""f""]: 11,
	}

	expectedPrev := map[Vertex]Vertex{
		g.ids[""a""]: Uninitialized,
		g.ids[""b""]: g.ids[""a""],
		g.ids[""c""]: g.ids[""a""],
		g.ids[""d""]: g.ids[""c""],
		g.ids[""e""]: g.ids[""d""],
		g.ids[""f""]: g.ids[""c""],
	}

	if !reflect.DeepEqual(dist, expectedDist) {
		t.Errorf(""Expected distances %v, but got %v"", expectedDist, dist)
	}

	if !reflect.DeepEqual(prev, expectedPrev) {
		t.Errorf(""Expected previous vertices %v, but got %v"", expectedPrev, prev)
	}
}

// TestPath tests the path function for correctness.
func TestPath(t *testing.T) {
	g := newsg(map[string]Vertex{
		""a"": 1,
		""b"": 2,
		""c"": 3,
		""d"": 4,
		""e"": 5,
		""f"": 6,
	})
	g.edge(""a"", ""b"", 7)
	g.edge(""a"", ""c"", 9)
	g.edge(""a"", ""f"", 14)
	g.edge(""b"", ""c"", 10)
	g.edge(""b"", ""d"", 15)
	g.edge(""c"", ""d"", 11)
	g.edge(""c"", ""f"", 2)
	g.edge(""d"", ""e"", 6)
	g.edge(""e"", ""f"", 9)

	_, prev := Dijkstra(g, g.ids[""a""])

	tests := []struct {
		target   Vertex
		expected string
	}{
		{g.ids[""e""], ""acde""},
		{g.ids[""f""], ""acf""},
	}

	for _, test := range tests {
		path := g.path(test.target, prev)
		if path != test.expected {
			t.Errorf(""Expected path to %s to be %s, but got %s"", g.names[test.target], test.expected, path)
		}
	}
}
",./data/generated/docs_golang/dijkstra_s_algorithm/gpt_4o_2024_08_06_dijkstra_s_algorithm_test.go,CompileStatus.OK,0.0,82.7,,0.05,0.12,0.121,7.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: newsg', 'Severity': '', 'SourceLines': ['\tg := newsg(map[string]Vertex{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dijkstra_s_algorithm_test.go', 'Offset': 0, 'Line': 10, 'Column': 7}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Dijkstra', 'Severity': '', 'SourceLines': ['\tdist, prev := Dijkstra(g, g.ids[""a""])'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dijkstra_s_algorithm_test.go', 'Offset': 0, 'Line': 28, 'Column': 16}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Vertex', 'Severity': '', 'SourceLines': ['\texpectedDist := map[Vertex]int{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dijkstra_s_algorithm_test.go', 'Offset': 0, 'Line': 30, 'Column': 22}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Vertex', 'Severity': '', 'SourceLines': ['\texpectedPrev := map[Vertex]Vertex{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dijkstra_s_algorithm_test.go', 'Offset': 0, 'Line': 39, 'Column': 22}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: newsg', 'Severity': '', 'SourceLines': ['\tg := newsg(map[string]Vertex{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dijkstra_s_algorithm_test.go', 'Offset': 0, 'Line': 59, 'Column': 7}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Dijkstra', 'Severity': '', 'SourceLines': ['\t_, prev := Dijkstra(g, g.ids[""a""])'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dijkstra_s_algorithm_test.go', 'Offset': 0, 'Line': 77, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Vertex', 'Severity': '', 'SourceLines': ['\t\ttarget   Vertex'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dijkstra_s_algorithm_test.go', 'Offset': 0, 'Line': 80, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Dinesman's multiple-dwelling problem,"Task
Solve Dinesman's multiple dwelling problem but in a way that most naturally follows the problem statement given below.

Solutions are allowed (but not required) to parse and interpret the problem text, but should remain flexible and should state what changes to the problem text are allowed. Flexibility and ease of expression are valued.

Examples may be be split into ""setup"", ""problem statement"", and ""output"" sections where the ease and naturalness of stating the problem and getting an answer, as well as the ease and flexibility of modifying the problem are the primary concerns.

Example output should be shown here, as well as any comments on the examples flexibility.



The problem
Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an apartment house that contains only five floors.


   Baker does not live on the top floor.
   Cooper does not live on the bottom floor. 
   Fletcher does not live on either the top or the bottom floor.
   Miller lives on a higher floor than does Cooper.
   Smith does not live on a floor adjacent to Fletcher's. 
   Fletcher does not live on a floor adjacent to Cooper's.

Where does everyone live?
",Go,"package main
 
import ""fmt""
 
// The program here is restricted to finding assignments of tenants (or more
// generally variables with distinct names) to floors (or more generally
// integer values.)  It finds a solution assigning all tenants and assigning
// them to different floors.
 
// Change number and names of tenants here.  Adding or removing names is
// allowed but the names should be distinct; the code is not written to handle
// duplicate names.
var tenants = []string{""Baker"", ""Cooper"", ""Fletcher"", ""Miller"", ""Smith""}
 
// Change the range of floors here.  The bottom floor does not have to be 1.
// These should remain non-negative integers though.
const bottom = 1
const top = 5
 
// A type definition for readability.  Do not change.
type assignments map[string]int
 
// Change rules defining the problem here.  Change, add, or remove rules as
// desired.  Each rule should first be commented as human readable text, then
// coded as a function.  The function takes a tentative partial list of
// assignments of tenants to floors and is free to compute anything it wants
// with this information.  Other information available to the function are
// package level defintions, such as top and bottom.  A function returns false
// to say the assignments are invalid.
var rules = []func(assignments) bool{
    // Baker does not live on the top floor
    func(a assignments) bool {
        floor, assigned := a[""Baker""]
        return !assigned || floor != top
    },
    // Cooper does not live on the bottom floor
    func(a assignments) bool {
        floor, assigned := a[""Cooper""]
        return !assigned || floor != bottom
    },
    // Fletcher does not live on either the top or the bottom floor
    func(a assignments) bool {
        floor, assigned := a[""Fletcher""]
        return !assigned || (floor != top && floor != bottom)
    },
    // Miller lives on a higher floor than does Cooper
    func(a assignments) bool {
        if m, assigned := a[""Miller""]; assigned {
            c, assigned := a[""Cooper""]
            return !assigned || m > c
        }
        return true
    },
    // Smith does not live on a floor adjacent to Fletcher's
    func(a assignments) bool {
        if s, assigned := a[""Smith""]; assigned {
            if f, assigned := a[""Fletcher""]; assigned {
                d := s - f
                return d*d > 1
            }
        }
        return true
    },
    // Fletcher does not live on a floor adjacent to Cooper's
    func(a assignments) bool {
        if f, assigned := a[""Fletcher""]; assigned {
            if c, assigned := a[""Cooper""]; assigned {
                d := f - c
                return d*d > 1
            }
        }
        return true
    },
}
 
// Assignment program, do not change.  The algorithm is a depth first search,
// tentatively assigning each tenant in order, and for each tenant trying each
// unassigned floor in order.  For each tentative assignment, it evaluates all
// rules in the rules list and backtracks as soon as any one of them fails.
//
// This algorithm ensures that the tenative assignments have only names in the
// tenants list, only floor numbers from bottom to top, and that tentants are
// assigned to different floors.  These rules are hard coded here and do not
// need to be coded in the the rules list above.
func main() {
    a := assignments{}
    var occ [top + 1]bool
    var df func([]string) bool
    df = func(u []string) bool {
        if len(u) == 0 {
            return true
        }
        tn := u[0]
        u = u[1:]
    f:
        for f := bottom; f <= top; f++ {
            if !occ[f] {
                a[tn] = f
                for _, r := range rules {
                    if !r(a) {
                        delete(a, tn)
                        continue f
                    }
                }
                occ[f] = true
                if df(u) {
                    return true
                }
                occ[f] = false
                delete(a, tn)
            }
        }
        return false
    }
    if !df(tenants) {
        fmt.Println(""no solution"")
        return
    }
    for t, f := range a {
        fmt.Println(t, f)
    }
}",4189,122,"package main

import (
	""testing""
)

// Test the rule that Baker does not live on the top floor
func TestBakerNotTopFloor(t *testing.T) {
	a := assignments{""Baker"": top}
	if rules[0](a) {
		t.Errorf(""Baker should not live on the top floor"")
	}
	a = assignments{""Baker"": top - 1}
	if !rules[0](a) {
		t.Errorf(""Baker can live on floor %d"", top-1)
	}
}

// Test the rule that Cooper does not live on the bottom floor
func TestCooperNotBottomFloor(t *testing.T) {
	a := assignments{""Cooper"": bottom}
	if rules[1](a) {
		t.Errorf(""Cooper should not live on the bottom floor"")
	}
	a = assignments{""Cooper"": bottom + 1}
	if !rules[1](a) {
		t.Errorf(""Cooper can live on floor %d"", bottom+1)
	}
}

// Test the rule that Fletcher does not live on either the top or the bottom floor
func TestFletcherNotTopOrBottomFloor(t *testing.T) {
	a := assignments{""Fletcher"": top}
	if rules[2](a) {
		t.Errorf(""Fletcher should not live on the top floor"")
	}
	a = assignments{""Fletcher"": bottom}
	if rules[2](a) {
		t.Errorf(""Fletcher should not live on the bottom floor"")
	}
	a = assignments{""Fletcher"": bottom + 1}
	if !rules[2](a) {
		t.Errorf(""Fletcher can live on floor %d"", bottom+1)
	}
}

// Test the rule that Miller lives on a higher floor than does Cooper
func TestMillerHigherThanCooper(t *testing.T) {
	a := assignments{""Miller"": 3, ""Cooper"": 4}
	if rules[3](a) {
		t.Errorf(""Miller should live on a higher floor than Cooper"")
	}
	a = assignments{""Miller"": 5, ""Cooper"": 4}
	if !rules[3](a) {
		t.Errorf(""Miller can live on a higher floor than Cooper"")
	}
}

// Test the rule that Smith does not live on a floor adjacent to Fletcher's
func TestSmithNotAdjacentToFletcher(t *testing.T) {
	a := assignments{""Smith"": 3, ""Fletcher"": 4}
	if rules[4](a) {
		t.Errorf(""Smith should not live on a floor adjacent to Fletcher's"")
	}
	a = assignments{""Smith"": 3, ""Fletcher"": 5}
	if !rules[4](a) {
		t.Errorf(""Smith can live on floor %d when Fletcher is on floor %d"", 3, 5)
	}
}

// Test the rule that Fletcher does not live on a floor adjacent to Cooper's
func TestFletcherNotAdjacentToCooper(t *testing.T) {
	a := assignments{""Fletcher"": 2, ""Cooper"": 3}
	if rules[5](a) {
		t.Errorf(""Fletcher should not live on a floor adjacent to Cooper's"")
	}
	a = assignments{""Fletcher"": 2, ""Cooper"": 4}
	if !rules[5](a) {
		t.Errorf(""Fletcher can live on floor %d when Cooper is on floor %d"", 2, 4)
	}
}

// Test the overall solution
func TestSolution(t *testing.T) {
	a := assignments{}
	var occ [top + 1]bool
	var df func([]string) bool
	df = func(u []string) bool {
		if len(u) == 0 {
			return true
		}
		tn := u[0]
		u = u[1:]
	f:
		for f := bottom; f <= top; f++ {
			if !occ[f] {
				a[tn] = f
				for _, r := range rules {
					if !r(a) {
						delete(a, tn)
						continue f
					}
				}
				occ[f] = true
				if df(u) {
					return true
				}
				occ[f] = false
				delete(a, tn)
			}
		}
		return false
	}
	if !df(tenants) {
		t.Fatalf(""no solution found"")
	}

	expected := map[string]int{
		""Baker"":    3,
		""Cooper"":   2,
		""Fletcher"": 4,
		""Miller"":   5,
		""Smith"":    1,
	}

	for tenant, floor := range expected {
		if a[tenant] != floor {
			t.Errorf(""Expected %s to live on floor %d, but got %d"", tenant, floor, a[tenant])
		}
	}
}
",./data/generated/docs_golang/dinesman_s_multiple_dwelling_problem/gpt_4o_2024_08_06_dinesman_s_multiple_dwelling_problem_test.go,CompileStatus.OK,0.0,43.5,,0.19,0.58,0.126,12.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: assignments', 'Severity': '', 'SourceLines': ['\ta := assignments{""Baker"": top}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dinesman_s_multiple_dwelling_problem_test.go', 'Offset': 0, 'Line': 9, 'Column': 7}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: rules', 'Severity': '', 'SourceLines': ['\tif rules[0](a) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dinesman_s_multiple_dwelling_problem_test.go', 'Offset': 0, 'Line': 10, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: assignments', 'Severity': '', 'SourceLines': ['\ta = assignments{""Baker"": top - 1}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dinesman_s_multiple_dwelling_problem_test.go', 'Offset': 0, 'Line': 13, 'Column': 6}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: rules', 'Severity': '', 'SourceLines': ['\tif !rules[0](a) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dinesman_s_multiple_dwelling_problem_test.go', 'Offset': 0, 'Line': 14, 'Column': 6}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: top', 'Severity': '', 'SourceLines': ['\t\tt.Errorf(""Baker can live on floor %d"", top-1)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dinesman_s_multiple_dwelling_problem_test.go', 'Offset': 0, 'Line': 15, 'Column': 42}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: assignments', 'Severity': '', 'SourceLines': ['\ta := assignments{""Cooper"": bottom}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dinesman_s_multiple_dwelling_problem_test.go', 'Offset': 0, 'Line': 21, 'Column': 7}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: rules', 'Severity': '', 'SourceLines': ['\tif rules[1](a) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dinesman_s_multiple_dwelling_problem_test.go', 'Offset': 0, 'Line': 22, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: bottom', 'Severity': '', 'SourceLines': ['\t\tt.Errorf(""Cooper can live on floor %d"", bottom+1)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dinesman_s_multiple_dwelling_problem_test.go', 'Offset': 0, 'Line': 27, 'Column': 43}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: bottom', 'Severity': '', 'SourceLines': ['\t\tt.Errorf(""Fletcher can live on floor %d"", bottom+1)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dinesman_s_multiple_dwelling_problem_test.go', 'Offset': 0, 'Line': 43, 'Column': 45}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: top', 'Severity': '', 'SourceLines': ['\tvar occ [top + 1]bool'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dinesman_s_multiple_dwelling_problem_test.go', 'Offset': 0, 'Line': 86, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: bottom', 'Severity': '', 'SourceLines': ['\t\tfor f := bottom; f <= top; f++ {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dinesman_s_multiple_dwelling_problem_test.go', 'Offset': 0, 'Line': 95, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: tenants', 'Severity': '', 'SourceLines': ['\tif !df(tenants) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dinesman_s_multiple_dwelling_problem_test.go', 'Offset': 0, 'Line': 114, 'Column': 9}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Discordian date,"

Task

Convert a given date from the   Gregorian calendar   to the   Discordian calendar.



",Go,"package ddate
 
import (
    ""strconv""
    ""strings"" 
    ""time""
)   
 
// Predefined formats for DiscDate.Format
const (
    DefaultFmt = ""Pungenday, Discord 5, 3131 YOLD""
    OldFmt     = `Today is Pungenday, the 5th day of Discord in the YOLD 3131
Celebrate Mojoday`
)
 
// Formats passed to DiscDate.Format are protypes for formated dates.
// Format replaces occurrences of prototype elements (the constant strings
// listed here) with values corresponding to the date being formatted.
// If the date is St. Tib's Day, the string from the first date element
// through the last is replaced with ""St. Tib's Day"".
const (
    protoLongSeason  = ""Discord""
    protoShortSeason = ""Dsc""
    protoLongDay     = ""Pungenday""
    protoShortDay    = ""PD""
    protoOrdDay      = ""5""
    protoCardDay     = ""5th""
    protoHolyday     = ""Mojoday""
    protoYear        = ""3131""
)
 
var (
    longDay = []string{""Sweetmorn"", ""Boomtime"", ""Pungenday"",
        ""Prickle-Prickle"", ""Setting Orange""}
    shortDay   = []string{""SM"", ""BT"", ""PD"", ""PP"", ""SO""}
    longSeason = []string{
        ""Chaos"", ""Discord"", ""Confusion"", ""Bureaucracy"", ""The Aftermath""}
    shortSeason = []string{""Chs"", ""Dsc"", ""Cfn"", ""Bcy"", ""Afm""}
    holyday     = [][]string{{""Mungday"", ""Chaoflux""}, {""Mojoday"", ""Discoflux""},
        {""Syaday"", ""Confuflux""}, {""Zaraday"", ""Bureflux""}, {""Maladay"", ""Afflux""}}
)   
 
type DiscDate struct {
    StTibs bool
    Dayy   int // zero based day of year, meaningless if StTibs is true
    Year   int // gregorian + 1166
}
 
func New(eris time.Time) DiscDate {
    t := time.Date(eris.Year(), 1, 1, eris.Hour(), eris.Minute(),
        eris.Second(), eris.Nanosecond(), eris.Location())
    bob := int(eris.Sub(t).Hours()) / 24
    raw := eris.Year()
    hastur := DiscDate{Year: raw + 1166}
    if raw%4 == 0 && (raw%100 != 0 || raw%400 == 0) {
        if bob > 59 {
            bob--
        } else if bob == 59 {
            hastur.StTibs = true
            return hastur
        }
    }
    hastur.Dayy = bob
    return hastur
}
 
func (dd DiscDate) Format(f string) (r string) {
    var st, snarf string
    var dateElement bool
    f6 := func(proto, wibble string) {
        if !dateElement {
            snarf = r
            dateElement = true
        }
        if st > """" {
            r = """"
        } else {
            r += wibble
        }
        f = f[len(proto):]
    }
    f4 := func(proto, wibble string) {
        if dd.StTibs {
            st = ""St. Tib's Day""
        }
        f6(proto, wibble)
    }
    season, day := dd.Dayy/73, dd.Dayy%73
    for f > """" {
        switch {
        case strings.HasPrefix(f, protoLongDay):
            f4(protoLongDay, longDay[dd.Dayy%5])
        case strings.HasPrefix(f, protoShortDay):
            f4(protoShortDay, shortDay[dd.Dayy%5])
        case strings.HasPrefix(f, protoCardDay):
            funkychickens := ""th""
            if day/10 != 1 {
                switch day % 10 {
                case 0:
                    funkychickens = ""st""
                case 1:
                    funkychickens = ""nd""
                case 2:
                    funkychickens = ""rd""
                }
            }
            f4(protoCardDay, strconv.Itoa(day+1)+funkychickens)
        case strings.HasPrefix(f, protoOrdDay):
            f4(protoOrdDay, strconv.Itoa(day+1))
        case strings.HasPrefix(f, protoLongSeason):
            f6(protoLongSeason, longSeason[season])
        case strings.HasPrefix(f, protoShortSeason):
            f6(protoShortSeason, shortSeason[season])
        case strings.HasPrefix(f, protoHolyday):
            if day == 4 {
                r += holyday[season][0]
            } else if day == 49 {
                r += holyday[season][1]
            }
            f = f[len(protoHolyday):]
        case strings.HasPrefix(f, protoYear):
            r += strconv.Itoa(dd.Year)
            f = f[4:]
        default:
            r += f[:1]
            f = f[1:]
        }
    }
    if st > """" { 
        r = snarf + st + r
    }
    return
}   ",4029,133,"package ddate_test

import (
	""testing""
	""time""
	""ddate""
)

func TestNew(t *testing.T) {
	tests := []struct {
		gregorianDate string
		expectedYear  int
		expectedDayy  int
		expectedStTibs bool
	}{
		{""2023-01-01"", 3189, 0, false},
		{""2023-02-28"", 3189, 58, false},
		{""2023-03-01"", 3189, 59, false},
		{""2024-02-28"", 3190, 58, false},
		{""2024-02-29"", 3190, 59, true},  // Leap year St. Tib's Day
		{""2024-03-01"", 3190, 59, false},
	}

	for _, tt := range tests {
		t.Run(tt.gregorianDate, func(t *testing.T) {
			date, _ := time.Parse(""2006-01-02"", tt.gregorianDate)
			discDate := ddate.New(date)

			if discDate.Year != tt.expectedYear {
				t.Errorf(""expected year %d, got %d"", tt.expectedYear, discDate.Year)
			}
			if discDate.Dayy != tt.expectedDayy {
				t.Errorf(""expected dayy %d, got %d"", tt.expectedDayy, discDate.Dayy)
			}
			if discDate.StTibs != tt.expectedStTibs {
				t.Errorf(""expected StTibs %v, got %v"", tt.expectedStTibs, discDate.StTibs)
			}
		})
	}
}

func TestFormat(t *testing.T) {
	tests := []struct {
		gregorianDate string
		format        string
		expected      string
	}{
		{""2023-01-01"", ddate.DefaultFmt, ""Sweetmorn, Chaos 1, 3189 YOLD""},
		{""2023-02-28"", ddate.DefaultFmt, ""Prickle-Prickle, Chaos 59, 3189 YOLD""},
		{""2023-03-01"", ddate.DefaultFmt, ""Setting Orange, Chaos 60, 3189 YOLD""},
		{""2024-02-29"", ddate.DefaultFmt, ""St. Tib's Day, 3190 YOLD""},
		{""2024-03-01"", ddate.DefaultFmt, ""Setting Orange, Chaos 60, 3190 YOLD""},
		{""2023-01-05"", ddate.OldFmt, ""Today is Pungenday, the 5th day of Chaos in the YOLD 3189\nCelebrate Mungday""},
	}

	for _, tt := range tests {
		t.Run(tt.gregorianDate, func(t *testing.T) {
			date, _ := time.Parse(""2006-01-02"", tt.gregorianDate)
			discDate := ddate.New(date)
			formatted := discDate.Format(tt.format)

			if formatted != tt.expected {
				t.Errorf(""expected %q, got %q"", tt.expected, formatted)
			}
		})
	}
}
",./data/generated/docs_golang/discordian_date/gpt_4o_2024_08_06_discordian_date_test.go,CompileStatus.SYNTAX_ERROR,,,,0.1,0.14,,,,False,False,,False,"[{'file': 'gpt_4o_2024_08_06_discordian_date_test.go', 'line': 6, 'column': 2, 'message': 'package ddate is not in std (/usr/local/go/src/ddate)'}]"
Display a linear combination,"Task

Display a finite linear combination in an infinite vector basis 



(

e

1


,

e

2


,
…
)


{\displaystyle (e_{1},e_{2},\ldots )}

.

Write a function that, when given a finite list of scalars 



(

α

1


,

α

2


,
…
)


{\displaystyle (\alpha ^{1},\alpha ^{2},\ldots )}

, 
creates a string representing the linear combination 




∑

i



α

i



e

i




{\displaystyle \sum _{i}\alpha ^{i}e_{i}}

 in an explicit format often used in mathematics, that is:






α


i

1





e


i

1




±

|


α


i

2





|


e


i

2




±

|


α


i

3





|


e


i

3




±
…


{\displaystyle \alpha ^{i_{1}}e_{i_{1}}\pm |\alpha ^{i_{2}}|e_{i_{2}}\pm |\alpha ^{i_{3}}|e_{i_{3}}\pm \ldots }


where 




α


i

k




≠
0


{\displaystyle \alpha ^{i_{k}}\neq 0}







The output must comply to the following rules:

   don't show null terms, unless the whole combination is null. 
 e(1)     is fine,     e(1) + 0*e(3)     or     e(1) + 0     is wrong.
   don't show scalars when they are equal to one or minus one. 
 e(3)     is fine,     1*e(3)     is wrong.
   don't prefix by a minus sign if it follows a preceding term.   Instead you use subtraction. 
 e(4) - e(5)     is fine,     e(4) + -e(5)     is wrong.


Show here output for the following lists of scalars:

 1)    1,  2,  3
 2)    0,  1,  2,  3
 3)    1,  0,  3,  4
 4)    1,  2,  0
 5)    0,  0,  0
 6)    0
 7)    1,  1,  1
 8)   -1, -1, -1
 9)   -1, -2,  0, -3
10)   -1


",Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
func linearCombo(c []int) string {
    var sb strings.Builder
    for i, n := range c {
        if n == 0 {
            continue
        }
        var op string
        switch {
        case n < 0 && sb.Len() == 0:
            op = ""-""
        case n < 0:
            op = "" - ""
        case n > 0 && sb.Len() == 0:
            op = """"
        default:
            op = "" + ""
        }
        av := n
        if av < 0 {
            av = -av
        }
        coeff := fmt.Sprintf(""%d*"", av)
        if av == 1 {
            coeff = """"
        }
        sb.WriteString(fmt.Sprintf(""%s%se(%d)"", op, coeff, i+1))
    }
    if sb.Len() == 0 {
        return ""0""
    } else {
        return sb.String()
    }
}
 
func main() {
    combos := [][]int{
        {1, 2, 3},
        {0, 1, 2, 3},
        {1, 0, 3, 4},
        {1, 2, 0},
        {0, 0, 0},
        {0},
        {1, 1, 1},
        {-1, -1, -1},
        {-1, -2, 0, -3},
        {-1},
    }
    for _, c := range combos {
        t := strings.Replace(fmt.Sprint(c), "" "", "", "", -1)
        fmt.Printf(""%-15s  ->  %s\n"", t, linearCombo(c))
    }
}",1153,59,"package main

import (
    ""testing""
)

func TestLinearCombo(t *testing.T) {
    tests := []struct {
        input    []int
        expected string
    }{
        {[]int{1, 2, 3}, ""e(1) + 2*e(2) + 3*e(3)""},
        {[]int{0, 1, 2, 3}, ""e(2) + 2*e(3) + 3*e(4)""},
        {[]int{1, 0, 3, 4}, ""e(1) + 3*e(3) + 4*e(4)""},
        {[]int{1, 2, 0}, ""e(1) + 2*e(2)""},
        {[]int{0, 0, 0}, ""0""},
        {[]int{0}, ""0""},
        {[]int{1, 1, 1}, ""e(1) + e(2) + e(3)""},
        {[]int{-1, -1, -1}, ""-e(1) - e(2) - e(3)""},
        {[]int{-1, -2, 0, -3}, ""-e(1) - 2*e(2) - 3*e(4)""},
        {[]int{-1}, ""-e(1)""},
    }

    for _, test := range tests {
        result := linearCombo(test.input)
        if result != test.expected {
            t.Errorf(""For input %v, expected %s, but got %s"", test.input, test.expected, result)
        }
    }
}
",./data/generated/docs_golang/display_a_linear_combination/gpt_4o_2024_08_06_display_a_linear_combination_test.go,CompileStatus.OK,0.0,83.3,,0.05,0.08,0.164,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: linearCombo', 'Severity': '', 'SourceLines': ['        result := linearCombo(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_display_a_linear_combination_test.go', 'Offset': 0, 'Line': 25, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Diversity prediction theorem,"The   wisdom of the crowd   is the collective opinion of a group of individuals rather than that of a single expert.

Wisdom-of-the-crowds research routinely attributes the superiority of crowd averages over individual judgments to the elimination of individual noise,   an explanation that assumes independence of the individual judgments from each other.

Thus the crowd tends to make its best decisions if it is made up of diverse opinions and ideologies.



Scott E. Page introduced the diversity prediction theorem:

 The squared error of the collective prediction equals the average squared error minus the predictive diversity. 


Therefore,   when the diversity in a group is large,   the error of the crowd is small.



Definitions

   Average Individual Error:   Average of the individual squared errors
   Collective Error:   Squared error of the collective prediction
   Prediction Diversity:   Average squared distance from the individual predictions to the collective prediction
   Diversity Prediction Theorem:   Given a crowd of predictive models,     then
   Collective Error   =   Average Individual Error   ─   Prediction Diversity
Task

For a given   true   value and a number of number of estimates (from a crowd),   show   (here on this page):

   the true value   and   the crowd estimates
   the average error
   the crowd error
   the prediction diversity


Use   (at least)   these two examples:

   a true value of   49   with crowd estimates of:    48   47   51
   a true value of   49   with crowd estimates of:    48   47   51   42


Also see

   Wikipedia entry:   Wisdom of the crowd
   University of Michigan: PDF paper         (exists on a web archive,   the Wayback Machine).

",Go,"package main
 
import ""fmt""
 
func averageSquareDiff(f float64, preds []float64) (av float64) {
    for _, pred := range preds {
        av += (pred - f) * (pred - f)
    }
    av /= float64(len(preds))
    return
}
 
func diversityTheorem(truth float64, preds []float64) (float64, float64, float64) {
    av := 0.0
    for _, pred := range preds {
        av += pred
    }
    av /= float64(len(preds))
    avErr := averageSquareDiff(truth, preds)
    crowdErr := (truth - av) * (truth - av)
    div := averageSquareDiff(av, preds)
    return avErr, crowdErr, div
}
 
func main() {
    predsArray := [2][]float64{{48, 47, 51}, {48, 47, 51, 42}}
    truth := 49.0
    for _, preds := range predsArray {
        avErr, crowdErr, div := diversityTheorem(truth, preds)
        fmt.Printf(""Average-error : %6.3f\n"", avErr)
        fmt.Printf(""Crowd-error   : %6.3f\n"", crowdErr)
        fmt.Printf(""Diversity     : %6.3f\n\n"", div)
    }
}",935,34,"package main

import (
	""testing""
)

func TestDiversityTheorem(t *testing.T) {
	tests := []struct {
		truth     float64
		preds     []float64
		expAvErr  float64
		expCrowdErr float64
		expDiv    float64
	}{
		{
			truth:     49.0,
			preds:     []float64{48, 47, 51},
			expAvErr:  2.6666666666666665,
			expCrowdErr: 0.44444444444444425,
			expDiv:    2.2222222222222223,
		},
		{
			truth:     49.0,
			preds:     []float64{48, 47, 51, 42},
			expAvErr:  12.75,
			expCrowdErr: 1.5625,
			expDiv:    11.1875,
		},
	}

	for _, tt := range tests {
		t.Run("""", func(t *testing.T) {
			avErr, crowdErr, div := diversityTheorem(tt.truth, tt.preds)
			if avErr != tt.expAvErr {
				t.Errorf(""expected average error %v, got %v"", tt.expAvErr, avErr)
			}
			if crowdErr != tt.expCrowdErr {
				t.Errorf(""expected crowd error %v, got %v"", tt.expCrowdErr, crowdErr)
			}
			if div != tt.expDiv {
				t.Errorf(""expected diversity %v, got %v"", tt.expDiv, div)
			}
		})
	}
}
",./data/generated/docs_golang/diversity_prediction_theorem/gpt_4o_2024_08_06_diversity_prediction_theorem_test.go,CompileStatus.OK,0.0,63.2,,0.11,0.5,0.117,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: diversityTheorem', 'Severity': '', 'SourceLines': ['\t\t\tavErr, crowdErr, div := diversityTheorem(tt.truth, tt.preds)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_diversity_prediction_theorem_test.go', 'Offset': 0, 'Line': 33, 'Column': 28}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Dot product,"Task

Create a function/use an in-built function, to compute the   dot product,   also known as the   scalar product   of two vectors.

If possible, make the vectors of arbitrary length.



As an example, compute the dot product of the vectors:

     [1,  3, -5]       and 
     [4, -2, -1]   


If implementing the dot product of two vectors directly:

   each vector must be the same length
   multiply corresponding terms from each vector
   sum the products   (to produce the answer)


Related task

   Vector products

",Go,"package main
 
import (
    ""errors""
    ""fmt""
    ""log""
)
 
var (
    v1 = []int{1, 3, -5}
    v2 = []int{4, -2, -1}
)
 
func dot(x, y []int) (r int, err error) {
    if len(x) != len(y) {
        return 0, errors.New(""incompatible lengths"")
    }
    for i, xi := range x {
        r += xi * y[i]
    }
    return
}
 
func main() {
    d, err := dot([]int{1, 3, -5}, []int{4, -2, -1})
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(d)
}",456,30,"package main

import (
    ""testing""
)

func TestDotProduct(t *testing.T) {
    tests := []struct {
        x        []int
        y        []int
        expected int
        err      bool
    }{
        {[]int{1, 3, -5}, []int{4, -2, -1}, 3, false},
        {[]int{1, 2, 3}, []int{4, 5, 6}, 32, false},
        {[]int{0, 0, 0}, []int{0, 0, 0}, 0, false},
        {[]int{1, 2}, []int{1, 2, 3}, 0, true}, // Different lengths
        {[]int{}, []int{}, 0, false},           // Empty vectors
    }

    for _, test := range tests {
        result, err := dot(test.x, test.y)
        if test.err && err == nil {
            t.Errorf(""Expected error for inputs %v and %v, but got none"", test.x, test.y)
        }
        if !test.err && err != nil {
            t.Errorf(""Did not expect error for inputs %v and %v, but got %v"", test.x, test.y, err)
        }
        if result != test.expected {
            t.Errorf(""For inputs %v and %v, expected %d, but got %d"", test.x, test.y, test.expected, result)
        }
    }
}
",./data/generated/docs_golang/dot_product/gpt_4o_2024_08_06_dot_product_test.go,CompileStatus.OK,0.0,55.6,,0.14,0.6,0.142,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: dot', 'Severity': '', 'SourceLines': ['        result, err := dot(test.x, test.y)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dot_product_test.go', 'Offset': 0, 'Line': 22, 'Column': 24}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Doubly-linked list/Element insertion,"Doubly-Linked List (element)
This is much like inserting into a Singly-Linked List, but with added assignments so that the backwards-pointing links remain correct.

See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack",Go,"package main
 
import ""fmt""
 
type dlNode struct {
    string
    next, prev *dlNode
}
 
type dlList struct {
    head, tail *dlNode
}
 
func (list *dlList) String() string {
    if list.head == nil {
        return fmt.Sprint(list.head)
    }
    r := ""["" + list.head.string
    for p := list.head.next; p != nil; p = p.next {
        r += "" "" + p.string
    }
    return r + ""]""
}
 
func (list *dlList) insertTail(node *dlNode) {
    if list.tail == nil {
        list.head = node
    } else {
        list.tail.next = node
    }
    node.next = nil
    node.prev = list.tail
    list.tail = node
}
 
func (list *dlList) insertAfter(existing, insert *dlNode) {
    insert.prev = existing
    insert.next = existing.next
    existing.next.prev = insert
    existing.next = insert
    if existing == list.tail {
        list.tail = insert
    }
}
 
func main() {
    dll := &dlList{}
    fmt.Println(dll)
    a := &dlNode{string: ""A""}
    dll.insertTail(a)
    dll.insertTail(&dlNode{string: ""B""})
    fmt.Println(dll)
    dll.insertAfter(a, &dlNode{string: ""C""})
    fmt.Println(dll)
}",1086,55,"package main

import (
	""testing""
)

func TestInsertTail(t *testing.T) {
	dll := &dlList{}
	nodeA := &dlNode{string: ""A""}
	nodeB := &dlNode{string: ""B""}

	dll.insertTail(nodeA)
	if dll.head != nodeA || dll.tail != nodeA {
		t.Errorf(""Failed to insert node A as tail. Head: %v, Tail: %v"", dll.head, dll.tail)
	}

	dll.insertTail(nodeB)
	if dll.tail != nodeB || dll.head.next != nodeB || nodeB.prev != nodeA {
		t.Errorf(""Failed to insert node B as tail. Head: %v, Tail: %v, NodeB Prev: %v"", dll.head, dll.tail, nodeB.prev)
	}
}

func TestInsertAfter(t *testing.T) {
	dll := &dlList{}
	nodeA := &dlNode{string: ""A""}
	nodeB := &dlNode{string: ""B""}
	nodeC := &dlNode{string: ""C""}

	dll.insertTail(nodeA)
	dll.insertTail(nodeB)

	dll.insertAfter(nodeA, nodeC)
	if nodeA.next != nodeC || nodeC.prev != nodeA || nodeC.next != nodeB || nodeB.prev != nodeC {
		t.Errorf(""Failed to insert node C after node A. NodeA Next: %v, NodeC Prev: %v, NodeC Next: %v, NodeB Prev: %v"", nodeA.next, nodeC.prev, nodeC.next, nodeB.prev)
	}

	if dll.tail != nodeB {
		t.Errorf(""Tail should be node B. Got: %v"", dll.tail)
	}

	dll.insertAfter(nodeB, &dlNode{string: ""D""})
	if dll.tail.string != ""D"" {
		t.Errorf(""Tail should be node D. Got: %v"", dll.tail)
	}
}

func TestString(t *testing.T) {
	dll := &dlList{}
	if dll.String() != ""<nil>"" {
		t.Errorf(""Expected empty list string representation to be '<nil>'. Got: %s"", dll.String())
	}

	dll.insertTail(&dlNode{string: ""A""})
	dll.insertTail(&dlNode{string: ""B""})
	dll.insertTail(&dlNode{string: ""C""})

	expected := ""[A B C]""
	if dll.String() != expected {
		t.Errorf(""Expected list string representation to be '%s'. Got: %s"", expected, dll.String())
	}
}
",./data/generated/docs_golang/doubly_linked_list_element_insertion/gpt_4o_2024_08_06_doubly_linked_list_element_insertion_test.go,CompileStatus.OK,2.0,,,0.19,0.88,0.107,6.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: dlList', 'Severity': '', 'SourceLines': ['\tdll := &dlList{}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_doubly_linked_list_element_insertion_test.go', 'Offset': 0, 'Line': 8, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: dlNode', 'Severity': '', 'SourceLines': ['\tnodeA := &dlNode{string: ""A""}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_doubly_linked_list_element_insertion_test.go', 'Offset': 0, 'Line': 9, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: dlNode', 'Severity': '', 'SourceLines': ['\tnodeB := &dlNode{string: ""B""}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_doubly_linked_list_element_insertion_test.go', 'Offset': 0, 'Line': 10, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: dlList', 'Severity': '', 'SourceLines': ['\tdll := &dlList{}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_doubly_linked_list_element_insertion_test.go', 'Offset': 0, 'Line': 24, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: dlNode', 'Severity': '', 'SourceLines': ['\tnodeA := &dlNode{string: ""A""}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_doubly_linked_list_element_insertion_test.go', 'Offset': 0, 'Line': 25, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: dlList', 'Severity': '', 'SourceLines': ['\tdll := &dlList{}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_doubly_linked_list_element_insertion_test.go', 'Offset': 0, 'Line': 48, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,50.0,False,[]
Doubly-linked list/Traversal,"Traverse from the beginning of a doubly-linked list to the end, and from the end to the beginning.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Go,"package main
 
import ""fmt""
 
type dlNode struct {
    string
    next, prev *dlNode
}
 
type dlList struct {
    head, tail *dlNode
}
 
func (list *dlList) String() string {
    if list.head == nil {
        return fmt.Sprint(list.head)
    }
    r := ""["" + list.head.string
    for p := list.head.next; p != nil; p = p.next {
        r += "" "" + p.string
    }
    return r + ""]""
}
 
func (list *dlList) insertTail(node *dlNode) {
    if list.tail == nil {
        list.head = node
    } else {
        list.tail.next = node
    }
    node.next = nil
    node.prev = list.tail
    list.tail = node
}
 
func (list *dlList) insertAfter(existing, insert *dlNode) {
    insert.prev = existing
    insert.next = existing.next
    existing.next.prev = insert
    existing.next = insert
    if existing == list.tail {
        list.tail = insert
    }
}
 
func main() {
    dll := &dlList{}
    fmt.Println(dll)
    a := &dlNode{string: ""A""}
    dll.insertTail(a)
    dll.insertTail(&dlNode{string: ""B""})
    fmt.Println(dll)
    dll.insertAfter(a, &dlNode{string: ""C""})
    fmt.Println(dll)
 
    // traverse from end to beginning
    fmt.Print(""From tail:"")
    for p := dll.tail; p != nil; p = p.prev {
        fmt.Print("" "", p.string)
    }
    fmt.Println("""")
}",1259,62,"package main

import (
	""testing""
)

func TestInsertTail(t *testing.T) {
	list := &dlList{}
	nodeA := &dlNode{string: ""A""}
	nodeB := &dlNode{string: ""B""}

	list.insertTail(nodeA)
	if list.head != nodeA || list.tail != nodeA {
		t.Errorf(""InsertTail failed: head or tail not set correctly after first insertion"")
	}

	list.insertTail(nodeB)
	if list.tail != nodeB {
		t.Errorf(""InsertTail failed: tail not updated correctly after second insertion"")
	}
	if list.head.next != nodeB || nodeB.prev != nodeA {
		t.Errorf(""InsertTail failed: nodes not linked correctly"")
	}
}

func TestInsertAfter(t *testing.T) {
	list := &dlList{}
	nodeA := &dlNode{string: ""A""}
	nodeB := &dlNode{string: ""B""}
	nodeC := &dlNode{string: ""C""}

	list.insertTail(nodeA)
	list.insertTail(nodeB)

	list.insertAfter(nodeA, nodeC)

	if nodeA.next != nodeC || nodeC.prev != nodeA {
		t.Errorf(""InsertAfter failed: nodeC not inserted correctly after nodeA"")
	}
	if nodeC.next != nodeB || nodeB.prev != nodeC {
		t.Errorf(""InsertAfter failed: nodeB not linked correctly after nodeC insertion"")
	}
}

func TestString(t *testing.T) {
	list := &dlList{}
	if list.String() != ""<nil>"" {
		t.Errorf(""String failed: expected '<nil>', got %s"", list.String())
	}

	list.insertTail(&dlNode{string: ""A""})
	list.insertTail(&dlNode{string: ""B""})
	list.insertTail(&dlNode{string: ""C""})

	expected := ""[A B C]""
	if list.String() != expected {
		t.Errorf(""String failed: expected %s, got %s"", expected, list.String())
	}
}

func TestTraverseFromEndToBeginning(t *testing.T) {
	list := &dlList{}
	nodeA := &dlNode{string: ""A""}
	nodeB := &dlNode{string: ""B""}
	nodeC := &dlNode{string: ""C""}

	list.insertTail(nodeA)
	list.insertTail(nodeB)
	list.insertTail(nodeC)

	expected := []string{""C"", ""B"", ""A""}
	index := 0
	for p := list.tail; p != nil; p = p.prev {
		if p.string != expected[index] {
			t.Errorf(""TraverseFromEndToBeginning failed: expected %s, got %s"", expected[index], p.string)
		}
		index++
	}
}
",./data/generated/docs_golang/doubly_linked_list_traversal/gpt_4o_2024_08_06_doubly_linked_list_traversal_test.go,CompileStatus.OK,0.0,56.7,,0.16,0.89,0.12,6.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: dlList', 'Severity': '', 'SourceLines': ['\tlist := &dlList{}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_doubly_linked_list_traversal_test.go', 'Offset': 0, 'Line': 8, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: dlNode', 'Severity': '', 'SourceLines': ['\tnodeA := &dlNode{string: ""A""}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_doubly_linked_list_traversal_test.go', 'Offset': 0, 'Line': 9, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: dlNode', 'Severity': '', 'SourceLines': ['\tnodeB := &dlNode{string: ""B""}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_doubly_linked_list_traversal_test.go', 'Offset': 0, 'Line': 10, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: dlList', 'Severity': '', 'SourceLines': ['\tlist := &dlList{}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_doubly_linked_list_traversal_test.go', 'Offset': 0, 'Line': 27, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: dlNode', 'Severity': '', 'SourceLines': ['\tnodeA := &dlNode{string: ""A""}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_doubly_linked_list_traversal_test.go', 'Offset': 0, 'Line': 28, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: dlList', 'Severity': '', 'SourceLines': ['\tlist := &dlList{}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_doubly_linked_list_traversal_test.go', 'Offset': 0, 'Line': 46, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Dragon curve,"

Create and display a dragon curve fractal.

(You may either display the curve directly or write it to an image file.)



Algorithms
Here are some brief notes the algorithms used and how they might suit various languages.

 Recursively a right curling dragon is a right dragon followed by a left dragon, at 90-degree angle. And a left dragon is a left followed by a right.
*---R----*     expands to     *       *
                               \     /
                                R   L
                                 \ /
                                  *

                                  *
                                 / \
                                L   R
                               /     \
*---L---*      expands to     *       *
 The co-routines dcl and dcr in various examples do this recursively to a desired expansion level.
 The curl direction right or left can be a parameter instead of two separate routines.
 Recursively, a curl direction can be eliminated by noting the dragon consists of two copies of itself drawn towards a central point at 45-degrees.
*------->*   becomes    *       *     Recursive copies drawn
                         \     /      from the ends towards
                          \   /       the centre.
                           v v
                            *
 This can be seen in the SVG example. This is best suited to off-line drawing since the reversal in the second half means the drawing jumps backward and forward (in binary reflected Gray code order) which is not very good for a plotter or for drawing progressively on screen.
 Successive approximation repeatedly re-writes each straight line as two new segments at a right angle,
                       *       
*-----*   becomes     / \      bend to left
                     /   \     if N odd
                    *     *

                    *     *   
*-----*   becomes    \   /     bend to right  
                      \ /      if N even 
                       *
 Numbering from the start of the curve built so far, if the segment is at an odd position then the bend introduced is on the right side. If the segment is an even position then on the left. The process is then repeated on the new doubled list of segments. This constructs a full set of line segments before any drawing.
 The effect of the splitting is a kind of bottom-up version of the recursions. See the Asymptote example for code doing this.
 Iteratively the curve always turns 90-degrees left or right at each point. The direction of the turn is given by the bit above the lowest 1-bit of n. Some bit-twiddling can extract that efficiently.
n = 1010110000
        ^
        bit above lowest 1-bit, turn left or right as 0 or 1

LowMask = n BITXOR (n-1)   # eg. giving 0000011111
AboveMask = LowMask + 1    # eg. giving 0000100000
BitAboveLowestOne = n BITAND AboveMask
 The first turn is at n=1, so reckon the curve starting at the origin as n=0 then a straight line segment to position n=1 and turn there.
 If you prefer to reckon the first turn as n=0 then take the bit above the lowest 0-bit instead. This works because ""...10000"" minus 1 is ""...01111"" so the lowest 0 in n-1 is where the lowest 1 in n is.
 Going by turns suits turtle graphics such as Logo or a plotter drawing with a pen and current direction.
 If a language doesn't maintain a ""current direction"" for drawing then you can always keep that separately and apply turns by bit-above-lowest-1.
 Absolute direction to move at point n can be calculated by the number of bit-transitions in n.
n = 11 00 1111 0 1
      ^  ^    ^ ^     4 places where change bit value
                      so direction=4*90degrees=East
 This can be calculated by counting the number of 1 bits in ""n XOR (n RIGHTSHIFT 1)"" since such a shift and xor leaves a single 1 bit at each position where two adjacent bits differ.
 Absolute X,Y coordinates of a point n can be calculated in complex numbers by some powers (i+1)^k and add/subtract/rotate. This is done in the gnuplot code. This might suit things similar to Gnuplot which want to calculate each point independently.
 Predicate test for whether a given X,Y point or segment is on the curve can be done. This might suit line-by-line output rather than building an entire image before printing. See M4 for an example of this.
 A predicate works by dividing out complex number i+1 until reaching the origin, so it takes roughly a bit at a time from X and Y is thus quite efficient. Why it works is slightly subtle but the calculation is not difficult. (Check segment by applying an offset to move X,Y to an ""even"" position before dividing i+1. Check vertex by whether the segment either East or West is on the curve.)
 The number of steps in the predicate corresponds to doublings of the curve, so stopping the check at say 8 steps can limit the curve drawn to 2^8=256 points. The offsets arising in the predicate are bits of n the segment number, so can note those bits to calculate n and limit to an arbitrary desired length or sub-section.
 As a Lindenmayer system of expansions. The simplest is two symbols F and S both straight lines, as used by the PGF code.
Axiom F, angle 90 degrees
F -> F+S
S -> F-S
This always has F at even positions and S at odd. Eg. after 3 levels F_S_F_S_F_S_F_S. The +/- turns in between bend to the left or right the same as the ""successive approximation"" method above. Read more at for instance Joel Castellanos' L-system page.

Variations are possible if you have only a single symbol for line draw, for example the Icon and Unicon and Xfractint code. The angles can also be broken into 45-degree parts to keep the expansion in a single direction rather than the endpoint rotating around.

The string rewrites can be done recursively without building the whole string, just follow its instructions at the target level. See for example C by IFS Drawing code. The effect is the same as ""recursive with parameter"" above but can draw other curves defined by L-systems. 


",Go,"package main
 
import (
    ""fmt""
    ""image""
    ""image/color""
    ""image/draw""
    ""image/png""
    ""math""
    ""os""
)
 
// separation of the the two endpoints
// make this a power of 2 for prettiest output
const sep = 512
// depth of recursion.  adjust as desired for different visual effects.
const depth = 14
 
var s = math.Sqrt2 / 2
var sin = []float64{0, s, 1, s, 0, -s, -1, -s}
var cos = []float64{1, s, 0, -s, -1, -s, 0, s}
var p = color.NRGBA{64, 192, 96, 255}
var b *image.NRGBA
 
func main() {
    width := sep * 11 / 6
    height := sep * 4 / 3
    bounds := image.Rect(0, 0, width, height)
    b = image.NewNRGBA(bounds)
    draw.Draw(b, bounds, image.NewUniform(color.White), image.ZP, draw.Src)
    dragon(14, 0, 1, sep, sep/2, sep*5/6)
    f, err := os.Create(""dragon.png"")
    if err != nil {
        fmt.Println(err)
        return
    }
    if err = png.Encode(f, b); err != nil {
        fmt.Println(err)
    }
    if err = f.Close(); err != nil {
        fmt.Println(err)
    }
}
 
func dragon(n, a, t int, d, x, y float64) {
    if n <= 1 {
        // Go packages used here do not have line drawing functions
        // so we implement a very simple line drawing algorithm here.
        // We take advantage of knowledge that we are always drawing
        // 45 degree diagonal lines.
        x1 := int(x + .5)
        y1 := int(y + .5)
        x2 := int(x + d*cos[a] + .5)
        y2 := int(y + d*sin[a] + .5)
        xInc := 1
        if x1 > x2 {
            xInc = -1
        }
        yInc := 1
        if y1 > y2 {
            yInc = -1
        }
        for x, y := x1, y1; ; x, y = x+xInc, y+yInc {
            b.Set(x, y, p)
            if x == x2 {
                break
            }
        }
        return
    }
    d *= s
    a1 := (a - t) & 7
    a2 := (a + t) & 7
    dragon(n-1, a1, 1, d, x, y)
    dragon(n-1, a2, -1, d, x+d*cos[a1], y+d*sin[a1])
}",1888,76,"package main

import (
    ""image""
    ""image/color""
    ""image/png""
    ""os""
    ""testing""
)

func TestDragonCurveImageCreation(t *testing.T) {
    // Run the main function to generate the image
    main()

    // Check if the image file was created
    _, err := os.Stat(""dragon.png"")
    if os.IsNotExist(err) {
        t.Fatalf(""Image file 'dragon.png' was not created"")
    }

    // Open the generated image
    f, err := os.Open(""dragon.png"")
    if err != nil {
        t.Fatalf(""Failed to open image file: %v"", err)
    }
    defer f.Close()

    // Decode the image
    img, err := png.Decode(f)
    if err != nil {
        t.Fatalf(""Failed to decode image: %v"", err)
    }

    // Check the image dimensions
    bounds := img.Bounds()
    expectedWidth := sep * 11 / 6
    expectedHeight := sep * 4 / 3
    if bounds.Dx() != expectedWidth || bounds.Dy() != expectedHeight {
        t.Fatalf(""Image dimensions are incorrect, got: %dx%d, expected: %dx%d"", bounds.Dx(), bounds.Dy(), expectedWidth, expectedHeight)
    }
}

func TestDragonFunction(t *testing.T) {
    // Create a blank image
    width := sep * 11 / 6
    height := sep * 4 / 3
    bounds := image.Rect(0, 0, width, height)
    b = image.NewNRGBA(bounds)
    draw.Draw(b, bounds, image.NewUniform(color.White), image.ZP, draw.Src)

    // Call the dragon function
    dragon(1, 0, 1, sep, sep/2, sep*5/6)

    // Check if the starting point is colored
    startX := int(sep/2 + 0.5)
    startY := int(sep*5/6 + 0.5)
    if b.At(startX, startY) != p {
        t.Fatalf(""Starting point is not colored correctly"")
    }
}

func TestLineDrawing(t *testing.T) {
    // Create a blank image
    width := sep * 11 / 6
    height := sep * 4 / 3
    bounds := image.Rect(0, 0, width, height)
    b = image.NewNRGBA(bounds)
    draw.Draw(b, bounds, image.NewUniform(color.White), image.ZP, draw.Src)

    // Draw a line using the dragon function
    dragon(1, 0, 1, sep, sep/2, sep*5/6)

    // Check if the line is drawn correctly
    x1 := int(sep/2 + 0.5)
    y1 := int(sep*5/6 + 0.5)
    x2 := int(sep/2 + sep*cos[0] + 0.5)
    y2 := int(sep*5/6 + sep*sin[0] + 0.5)

    xInc := 1
    if x1 > x2 {
        xInc = -1
    }
    yInc := 1
    if y1 > y2 {
        yInc = -1
    }

    for x, y := x1, y1; ; x, y = x+xInc, y+yInc {
        if b.At(x, y) != p {
            t.Fatalf(""Line is not drawn correctly at (%d, %d)"", x, y)
        }
        if x == x2 {
            break
        }
    }
}
",./data/generated/docs_golang/dragon_curve/gpt_4o_2024_08_06_dragon_curve_test.go,CompileStatus.SYNTAX_ERROR,,,,0.12,0.6,,11.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['    main()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dragon_curve_test.go', 'Offset': 0, 'Line': 13, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: sep', 'Severity': '', 'SourceLines': ['    expectedWidth := sep * 11 / 6'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dragon_curve_test.go', 'Offset': 0, 'Line': 36, 'Column': 22}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: sep', 'Severity': '', 'SourceLines': ['    expectedHeight := sep * 4 / 3'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dragon_curve_test.go', 'Offset': 0, 'Line': 37, 'Column': 23}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: sep', 'Severity': '', 'SourceLines': ['    width := sep * 11 / 6'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dragon_curve_test.go', 'Offset': 0, 'Line': 45, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: b', 'Severity': '', 'SourceLines': ['    b = image.NewNRGBA(bounds)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dragon_curve_test.go', 'Offset': 0, 'Line': 48, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: draw', 'Severity': '', 'SourceLines': ['    draw.Draw(b, bounds, image.NewUniform(color.White), image.ZP, draw.Src)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dragon_curve_test.go', 'Offset': 0, 'Line': 49, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: dragon', 'Severity': '', 'SourceLines': ['    dragon(1, 0, 1, sep, sep/2, sep*5/6)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dragon_curve_test.go', 'Offset': 0, 'Line': 52, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: b', 'Severity': '', 'SourceLines': ['    if b.At(startX, startY) != p {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dragon_curve_test.go', 'Offset': 0, 'Line': 57, 'Column': 8}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: b', 'Severity': '', 'SourceLines': ['    b = image.NewNRGBA(bounds)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dragon_curve_test.go', 'Offset': 0, 'Line': 67, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: draw', 'Severity': '', 'SourceLines': ['    draw.Draw(b, bounds, image.NewUniform(color.White), image.ZP, draw.Src)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dragon_curve_test.go', 'Offset': 0, 'Line': 68, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: dragon', 'Severity': '', 'SourceLines': ['    dragon(1, 0, 1, sep, sep/2, sep*5/6)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dragon_curve_test.go', 'Offset': 0, 'Line': 71, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_dragon_curve_test.go', 'line': 49, 'column': 5, 'message': 'undefined: draw'}]"
Draw a cuboid,"Task

Draw a   cuboid   with relative dimensions of    2 × 3 × 4. 



The cuboid can be represented graphically, or in   ASCII art,   depending on the language capabilities.

To fulfill the criteria of being a cuboid, three faces must be visible.

Either static or rotational projection is acceptable for this task.



Related tasks
 draw a sphere
 draw a rotating cube
 write language name in 3D ASCII
 draw a Deathstar

",Go,"package main
 
import ""fmt""
 
func cuboid(dx, dy, dz int) {
    fmt.Printf(""cuboid %d %d %d:\n"", dx, dy, dz)
    cubLine(dy+1, dx, 0, ""+-"")
    for i := 1; i <= dy; i++ {
        cubLine(dy-i+1, dx, i-1, ""/ |"")
    }
    cubLine(0, dx, dy, ""+-|"")
    for i := 4*dz - dy - 2; i > 0; i-- {
        cubLine(0, dx, dy, ""| |"")
    }
    cubLine(0, dx, dy, ""| +"")
    for i := 1; i <= dy; i++ {
        cubLine(0, dx, dy-i, ""| /"")
    }
    cubLine(0, dx, 0, ""+-\n"")
}
 
func cubLine(n, dx, dy int, cde string) {
    fmt.Printf(""%*s"", n+1, cde[:1])
    for d := 9*dx - 1; d > 0; d-- {
        fmt.Print(cde[1:2])
    }
    fmt.Print(cde[:1])
    fmt.Printf(""%*s\n"", dy+1, cde[2:])
}
 
func main() {
    cuboid(2, 3, 4)
    cuboid(1, 1, 1)
    cuboid(6, 2, 1)
}",754,35,"package main

import (
	""bytes""
	""testing""
)

func TestCuboid(t *testing.T) {
	tests := []struct {
		dx, dy, dz int
		expected   string
	}{
		{
			dx: 2, dy: 3, dz: 4,
			expected: `cuboid 2 3 4:
   +--------+
  /        /|
 /        / |
+--------+  |
|        |  |
|        |  |
|        |  |
|        |  |
|        |  |
|        |  +
|        | /
|        |/
+--------+
`,
		},
		{
			dx: 1, dy: 1, dz: 1,
			expected: `cuboid 1 1 1:
 +-+
/ /|
+-+ |
| | +
| |/
+-+
`,
		},
		{
			dx: 6, dy: 2, dz: 1,
			expected: `cuboid 6 2 1:
   +-------------------------+
  /                         /|
 /                         / |
+-------------------------+  |
|                         |  +
|                         | /
+-------------------------+
`,
		},
	}

	for _, tt := range tests {
		t.Run("""", func(t *testing.T) {
			var buf bytes.Buffer
			fmt.Printf = func(format string, args ...interface{}) (n int, err error) {
				return buf.WriteString(fmt.Sprintf(format, args...))
			}
			defer func() { fmt.Printf = fmt.Printf }() // Restore original fmt.Printf after test

			cuboid(tt.dx, tt.dy, tt.dz)

			if buf.String() != tt.expected {
				t.Errorf(""expected:\n%s\ngot:\n%s"", tt.expected, buf.String())
			}
		})
	}
}
",./data/generated/docs_golang/draw_a_cuboid/gpt_4o_2024_08_06_draw_a_cuboid_test.go,CompileStatus.SYNTAX_ERROR,,,,0.05,0.14,,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: fmt', 'Severity': '', 'SourceLines': ['\t\t\tfmt.Printf = func(format string, args ...interface{}) (n int, err error) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_draw_a_cuboid_test.go', 'Offset': 0, 'Line': 59, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fmt', 'Severity': '', 'SourceLines': ['\t\t\t\treturn buf.WriteString(fmt.Sprintf(format, args...))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_draw_a_cuboid_test.go', 'Offset': 0, 'Line': 60, 'Column': 28}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fmt', 'Severity': '', 'SourceLines': ['\t\t\tdefer func() { fmt.Printf = fmt.Printf }() // Restore original fmt.Printf after test'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_draw_a_cuboid_test.go', 'Offset': 0, 'Line': 62, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: cuboid', 'Severity': '', 'SourceLines': ['\t\t\tcuboid(tt.dx, tt.dy, tt.dz)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_draw_a_cuboid_test.go', 'Offset': 0, 'Line': 64, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_draw_a_cuboid_test.go', 'line': 59, 'column': 4, 'message': 'undefined: fmt'}]"
Draw a pixel,"Task

Create a window and draw a pixel in it, subject to the following:

  the window is 320 x 240
  the color of the pixel must be red (255,0,0)
  the position of the pixel is x = 100, y = 100",Go,"package main
 
import (
    ""fmt""
    ""image""
    ""image/color""
    ""image/draw""
)
 
func main() {
    rect := image.Rect(0, 0, 320, 240)
    img := image.NewRGBA(rect)
 
    // Use green background, say.
    green := color.RGBA{0, 255, 0, 255}
    draw.Draw(img, rect, &image.Uniform{green}, image.ZP, draw.Src)
 
    // Set color of pixel at (100, 100) to red
    red := color.RGBA{255, 0, 0, 255}
    img.Set(100, 100, red)
 
    // Check it worked.
    cmap := map[color.Color]string{green: ""green"", red: ""red""}
    c1 := img.At(0, 0)
    c2 := img.At(100, 100)
    fmt.Println(""The color of the pixel at (  0,   0) is"", cmap[c1], ""\b."")
    fmt.Println(""The color of the pixel at (100, 100) is"", cmap[c2], ""\b."")
}",719,28,"package main

import (
    ""image""
    ""image/color""
    ""image/draw""
    ""testing""
)

func TestDrawPixel(t *testing.T) {
    rect := image.Rect(0, 0, 320, 240)
    img := image.NewRGBA(rect)

    // Use green background
    green := color.RGBA{0, 255, 0, 255}
    draw.Draw(img, rect, &image.Uniform{green}, image.ZP, draw.Src)

    // Set color of pixel at (100, 100) to red
    red := color.RGBA{255, 0, 0, 255}
    img.Set(100, 100, red)

    // Test the color of the pixel at (0, 0)
    if got := img.At(0, 0); got != green {
        t.Errorf(""Expected color at (0, 0) to be green, got %v"", got)
    }

    // Test the color of the pixel at (100, 100)
    if got := img.At(100, 100); got != red {
        t.Errorf(""Expected color at (100, 100) to be red, got %v"", got)
    }
}
",./data/generated/docs_golang/draw_a_pixel/gpt_4o_2024_08_06_draw_a_pixel_test.go,CompileStatus.OK,0.0,0.0,,0.15,2.0,0.107,1.0,"[{'FromLinter': 'staticcheck', 'Text': 'SA1019: image.ZP has been deprecated since Go 1.13 and an alternative has been available since Go 1.0: Use a literal [image.Point] instead. ', 'Severity': '', 'SourceLines': ['    draw.Draw(img, rect, &image.Uniform{green}, image.ZP, draw.Src)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_draw_a_pixel_test.go', 'Offset': 309, 'Line': 16, 'Column': 49}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Draw a sphere,"Task

Draw a sphere.

The sphere can be represented graphically, or in ASCII art, depending on the language capabilities.

Either static or rotational projection is acceptable for this task.



Related tasks

 draw a cuboid
 draw a rotating cube
 write language name in 3D ASCII
 draw a Deathstar

",Go,"package main
 
import (
    ""fmt""
    ""image""
    ""image/color""
    ""image/png""
    ""math""
    ""os""
)
 
type vector [3]float64
 
func normalize(v *vector) {
    invLen := 1 / math.Sqrt(dot(v, v))
    v[0] *= invLen
    v[1] *= invLen
    v[2] *= invLen
}
 
func dot(x, y *vector) float64 {
    return x[0]*y[0] + x[1]*y[1] + x[2]*y[2]
}
 
func drawSphere(r int, k, amb float64, dir *vector) *image.Gray {
    w, h := r*4, r*3
    img := image.NewGray(image.Rect(-w/2, -h/2, w/2, h/2))
    vec := new(vector)
    for x := -r; x < r; x++ {
        for y := -r; y < r; y++ {
            if z := r*r - x*x - y*y; z >= 0 {
                vec[0] = float64(x)
                vec[1] = float64(y)
                vec[2] = math.Sqrt(float64(z))
                normalize(vec)
                s := dot(dir, vec)
                if s < 0 {
                    s = 0
                }
                lum := 255 * (math.Pow(s, k) + amb) / (1 + amb)
                if lum < 0 {
                    lum = 0
                } else if lum > 255 {
                    lum = 255
                }
                img.SetGray(x, y, color.Gray{uint8(lum)})
            }
        }
    }
    return img
}
 
func main() {
    dir := &vector{-30, -30, 50}
    normalize(dir)
    img := drawSphere(200, 1.5, .2, dir)
    f, err := os.Create(""sphere.png"")
    if err != nil {
        fmt.Println(err)
        return
    }
    if err = png.Encode(f, img); err != nil {
        fmt.Println(err)
    }
    if err = f.Close(); err != nil {
        fmt.Println(err)
    }
}",1545,68,"package main

import (
    ""image""
    ""image/color""
    ""math""
    ""testing""
)

func TestNormalize(t *testing.T) {
    v := &vector{3, 4, 0}
    normalize(v)
    expected := &vector{0.6, 0.8, 0}
    if !vectorsEqual(v, expected) {
        t.Errorf(""Expected %v, got %v"", expected, v)
    }
}

func TestDot(t *testing.T) {
    v1 := &vector{1, 2, 3}
    v2 := &vector{4, -5, 6}
    result := dot(v1, v2)
    expected := float64(12)
    if result != expected {
        t.Errorf(""Expected %v, got %v"", expected, result)
    }
}

func TestDrawSphere(t *testing.T) {
    dir := &vector{-30, -30, 50}
    normalize(dir)
    img := drawSphere(10, 1.5, 0.2, dir)

    if img.Bounds().Dx() != 40 || img.Bounds().Dy() != 30 {
        t.Errorf(""Expected image dimensions to be 40x30, got %dx%d"", img.Bounds().Dx(), img.Bounds().Dy())
    }

    // Check if the center pixel is set (it should be part of the sphere)
    centerColor := img.GrayAt(0, 0)
    if centerColor.Y == 0 {
        t.Error(""Expected center pixel to be part of the sphere and not black"")
    }

    // Check if a corner pixel is not set (it should be outside the sphere)
    cornerColor := img.GrayAt(-20, -15)
    if cornerColor.Y != 0 {
        t.Error(""Expected corner pixel to be outside the sphere and black"")
    }
}

func vectorsEqual(v1, v2 *vector) bool {
    epsilon := 1e-9
    for i := 0; i < 3; i++ {
        if math.Abs(v1[i]-v2[i]) > epsilon {
            return false
        }
    }
    return true
}
",./data/generated/docs_golang/draw_a_sphere/gpt_4o_2024_08_06_draw_a_sphere_test.go,CompileStatus.SYNTAX_ERROR,,,,0.15,0.38,,9.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: vector', 'Severity': '', 'SourceLines': ['func vectorsEqual(v1, v2 *vector) bool {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_draw_a_sphere_test.go', 'Offset': 0, 'Line': 51, 'Column': 27}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: vector', 'Severity': '', 'SourceLines': ['    v := &vector{3, 4, 0}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_draw_a_sphere_test.go', 'Offset': 0, 'Line': 11, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: normalize', 'Severity': '', 'SourceLines': ['    normalize(v)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_draw_a_sphere_test.go', 'Offset': 0, 'Line': 12, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: vector', 'Severity': '', 'SourceLines': ['    expected := &vector{0.6, 0.8, 0}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_draw_a_sphere_test.go', 'Offset': 0, 'Line': 13, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: dot', 'Severity': '', 'SourceLines': ['    result := dot(v1, v2)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_draw_a_sphere_test.go', 'Offset': 0, 'Line': 22, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: normalize', 'Severity': '', 'SourceLines': ['    normalize(dir)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_draw_a_sphere_test.go', 'Offset': 0, 'Line': 31, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: drawSphere', 'Severity': '', 'SourceLines': ['    img := drawSphere(10, 1.5, 0.2, dir)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_draw_a_sphere_test.go', 'Offset': 0, 'Line': 32, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""image"" imported and not used', 'Severity': '', 'SourceLines': ['    ""image""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_draw_a_sphere_test.go', 'Offset': 0, 'Line': 4, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""image/color"" imported and not used', 'Severity': '', 'SourceLines': ['    ""image/color""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_draw_a_sphere_test.go', 'Offset': 0, 'Line': 5, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_draw_a_sphere_test.go', 'line': 4, 'column': 5, 'message': '""image"" imported and not used'}]"
Dutch national flag problem,"
The Dutch national flag is composed of three coloured bands in the order:

   red     (top)
   then white,   and
   lastly blue   (at the bottom). 


The problem posed by Edsger Dijkstra is:

Given a number of red, blue and white balls in random order, arrange them in the order of the colours in the Dutch national flag.
When the problem was first posed, Dijkstra then went on to successively refine a solution, minimising the number of swaps and the number of times the colour of a ball needed to determined and restricting the balls to end in an array, ...



Task
 Generate a randomized order of balls ensuring that they are not in the order of the Dutch national flag.
 Sort the balls in a way idiomatic to your language.
 Check the sorted balls are in the order of the Dutch national flag.


C.f.

 Dutch national flag problem
 Probabilistic analysis of algorithms for the Dutch national flag problem by Wei-Mei Chen. (pdf)

",Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
// constants define order of colors in Dutch national flag
const (
    red = iota
    white
    blue
    nColors
)
 
// zero object of type is valid red ball.
type ball struct {
    color int
}
 
// order of balls based on DNF
func (b1 ball) lt(b2 ball) bool {
    return b1.color < b2.color
}
 
// type for arbitrary ordering of balls
type ordering []ball
 
// predicate tells if balls are ordered by DNF
func (o ordering) ordered() bool {
    var b0 ball
    for _, b := range o {
        if b.lt(b0) {
            return false
        }
        b0 = b
    }
    return true
}
 
func init() {
    rand.Seed(time.Now().Unix())
}
 
// constructor returns new ordering of balls which is randomized but
// guaranteed to be not in DNF order.  function panics for n < 2.
func outOfOrder(n int) ordering {
    if n < 2 {
        panic(fmt.Sprintf(""%d invalid"", n))
    }
    r := make(ordering, n)
    for {
        for i, _ := range r {
            r[i].color = rand.Intn(nColors)
        }
        if !r.ordered() {
            break
        }
    }
    return r
}
 
// O(n) algorithm
// http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Sort/Flag/
func (a ordering) sort3() {
    lo, mid, hi := 0, 0, len(a)-1
    for mid <= hi {
        switch a[mid].color {
        case red:
            a[lo], a[mid] = a[mid], a[lo]
            lo++
            mid++
        case white:
            mid++
        default:
            a[mid], a[hi] = a[hi], a[mid]
            hi--
        }
    }
}
 
func main() {
    f := outOfOrder(12)
    fmt.Println(f)
    f.sort3()
    fmt.Println(f)
}",1641,88,"package main

import (
    ""testing""
)

// TestOutOfOrder checks that the outOfOrder function generates a non-ordered sequence of balls.
func TestOutOfOrder(t *testing.T) {
    for i := 2; i <= 10; i++ {
        balls := outOfOrder(i)
        if balls.ordered() {
            t.Errorf(""Expected unordered balls, but got ordered for n=%d"", i)
        }
    }
}

// TestSort3 checks that the sort3 function correctly sorts the balls in the order of the Dutch national flag.
func TestSort3(t *testing.T) {
    tests := []struct {
        name     string
        input    ordering
        expected ordering
    }{
        {
            name: ""Already sorted"",
            input: ordering{
                {color: red}, {color: red}, {color: white}, {color: white}, {color: blue}, {color: blue},
            },
            expected: ordering{
                {color: red}, {color: red}, {color: white}, {color: white}, {color: blue}, {color: blue},
            },
        },
        {
            name: ""Reverse order"",
            input: ordering{
                {color: blue}, {color: blue}, {color: white}, {color: white}, {color: red}, {color: red},
            },
            expected: ordering{
                {color: red}, {color: red}, {color: white}, {color: white}, {color: blue}, {color: blue},
            },
        },
        {
            name: ""Mixed order"",
            input: ordering{
                {color: white}, {color: red}, {color: blue}, {color: red}, {color: white}, {color: blue},
            },
            expected: ordering{
                {color: red}, {color: red}, {color: white}, {color: white}, {color: blue}, {color: blue},
            },
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            tt.input.sort3()
            if !tt.input.ordered() {
                t.Errorf(""Expected sorted balls, but got unordered for test %s"", tt.name)
            }
            for i := range tt.input {
                if tt.input[i].color != tt.expected[i].color {
                    t.Errorf(""Mismatch at index %d: got %v, want %v"", i, tt.input[i].color, tt.expected[i].color)
                }
            }
        })
    }
}

// TestOrderingOrdered checks the ordered method of the ordering type.
func TestOrderingOrdered(t *testing.T) {
    tests := []struct {
        name     string
        input    ordering
        expected bool
    }{
        {
            name: ""Ordered"",
            input: ordering{
                {color: red}, {color: red}, {color: white}, {color: white}, {color: blue}, {color: blue},
            },
            expected: true,
        },
        {
            name: ""Unordered"",
            input: ordering{
                {color: blue}, {color: white}, {color: red}, {color: white}, {color: blue}, {color: red},
            },
            expected: false,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := tt.input.ordered()
            if result != tt.expected {
                t.Errorf(""For test %s, expected %v, got %v"", tt.name, tt.expected, result)
            }
        })
    }
}
",./data/generated/docs_golang/dutch_national_flag_problem/gpt_4o_2024_08_06_dutch_national_flag_problem_test.go,CompileStatus.OK,0.0,83.3,,0.08,0.27,0.118,7.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: outOfOrder', 'Severity': '', 'SourceLines': ['        balls := outOfOrder(i)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dutch_national_flag_problem_test.go', 'Offset': 0, 'Line': 10, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: ordering', 'Severity': '', 'SourceLines': ['        input    ordering'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dutch_national_flag_problem_test.go', 'Offset': 0, 'Line': 21, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: ordering', 'Severity': '', 'SourceLines': ['        expected ordering'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dutch_national_flag_problem_test.go', 'Offset': 0, 'Line': 22, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: ordering', 'Severity': '', 'SourceLines': ['            input: ordering{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dutch_national_flag_problem_test.go', 'Offset': 0, 'Line': 26, 'Column': 20}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'missing type in composite literal', 'Severity': '', 'SourceLines': ['                {color: red}, {color: red}, {color: white}, {color: white}, {color: blue}, {color: blue},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dutch_national_flag_problem_test.go', 'Offset': 0, 'Line': 27, 'Column': 17}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'missing type in composite literal', 'Severity': '', 'SourceLines': ['                {color: red}, {color: red}, {color: white}, {color: white}, {color: blue}, {color: blue},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dutch_national_flag_problem_test.go', 'Offset': 0, 'Line': 30, 'Column': 17}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'missing type in composite literal', 'Severity': '', 'SourceLines': ['                {color: blue}, {color: blue}, {color: white}, {color: white}, {color: red}, {color: red},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_dutch_national_flag_problem_test.go', 'Offset': 0, 'Line': 36, 'Column': 17}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
EKG sequence convergence,"The sequence is from the natural numbers and is defined by:

 a(1) = 1; 
 a(2) = Start = 2;
 for n > 2, a(n) shares at least one prime factor with a(n-1) and is the smallest such natural number not already used.

The sequence is called the EKG sequence (after its visual similarity to an electrocardiogram when graphed).

Variants of the sequence can be generated starting 1, N where N is any natural number larger than one. For the purposes of this task let us call:

 The sequence described above , starting 1, 2, ... the EKG(2) sequence;
 the sequence starting 1, 3, ... the EKG(3) sequence; 
 ... the sequence starting 1, N, ... the EKG(N) sequence.


Convergence
If an algorithm that keeps track of the minimum amount of numbers and their corresponding prime factors used to generate the next term is used, then this may be known as the generators essential state. Two EKG generators with differing starts can converge to produce the same sequence after initial differences.

EKG(N1) and EKG(N2) are said to to have converged at and after generation a(c) if state_of(EKG(N1).a(c)) == state_of(EKG(N2).a(c)).



Task

 Calculate and show here the first 10 members of EKG(2).
 Calculate and show here the first 10 members of EKG(5).
 Calculate and show here the first 10 members of EKG(7).
 Calculate and show here the first 10 members of EKG(9).
 Calculate and show here the first 10 members of EKG(10).
 Calculate and show here at which term EKG(5) and EKG(7) converge   (stretch goal).
Related Tasks

 Greatest common divisor
 Sieve of Eratosthenes


Reference

 The EKG Sequence and the Tree of Numbers. (Video).

",Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
func contains(a []int, b int) bool {
    for _, j := range a {
        if j == b {
            return true
        }
    }
    return false
}
 
func gcd(a, b int) int {
    for a != b {
        if a > b {
            a -= b
        } else {
            b -= a
        }
    }
    return a
}
 
func areSame(s, t []int) bool {
    le := len(s)
    if le != len(t) {
        return false
    }
    sort.Ints(s)
    sort.Ints(t)
    for i := 0; i < le; i++ {
        if s[i] != t[i] {
            return false
        }
    }
    return true
}
 
func main() {
    const limit = 100
    starts := [5]int{2, 5, 7, 9, 10}
    var ekg [5][limit]int
 
    for s, start := range starts {
        ekg[s][0] = 1
        ekg[s][1] = start
        for n := 2; n < limit; n++ {
            for i := 2; ; i++ {
                // a potential sequence member cannot already have been used
                // and must have a factor in common with previous member
                if !contains(ekg[s][:n], i) && gcd(ekg[s][n-1], i) > 1 {
                    ekg[s][n] = i
                    break
                }
            }
        }
        fmt.Printf(""EKG(%2d): %v\n"", start, ekg[s][:30])
    }   
 
    // now compare EKG5 and EKG7 for convergence
    for i := 2; i < limit; i++ {
        if ekg[1][i] == ekg[2][i] && areSame(ekg[1][:i], ekg[2][:i]) {
            fmt.Println(""\nEKG(5) and EKG(7) converge at term"", i+1)
            return
        }
    }
    fmt.Println(""\nEKG5(5) and EKG(7) do not converge within"", limit, ""terms"")
}",1574,72,"package main

import (
	""testing""
)

// TestContains tests the contains function
func TestContains(t *testing.T) {
	tests := []struct {
		slice   []int
		element int
		want    bool
	}{
		{[]int{1, 2, 3}, 2, true},
		{[]int{1, 2, 3}, 4, false},
		{[]int{}, 1, false},
	}

	for _, tt := range tests {
		got := contains(tt.slice, tt.element)
		if got != tt.want {
			t.Errorf(""contains(%v, %d) = %v; want %v"", tt.slice, tt.element, got, tt.want)
		}
	}
}

// TestGCD tests the gcd function
func TestGCD(t *testing.T) {
	tests := []struct {
		a, b int
		want int
	}{
		{48, 18, 6},
		{101, 10, 1},
		{56, 98, 14},
	}

	for _, tt := range tests {
		got := gcd(tt.a, tt.b)
		if got != tt.want {
			t.Errorf(""gcd(%d, %d) = %d; want %d"", tt.a, tt.b, got, tt.want)
		}
	}
}

// TestAreSame tests the areSame function
func TestAreSame(t *testing.T) {
	tests := []struct {
		s, t []int
		want bool
	}{
		{[]int{1, 2, 3}, []int{3, 2, 1}, true},
		{[]int{1, 2, 3}, []int{1, 2, 4}, false},
		{[]int{1, 2}, []int{1, 2, 3}, false},
	}

	for _, tt := range tests {
		got := areSame(tt.s, tt.t)
		if got != tt.want {
			t.Errorf(""areSame(%v, %v) = %v; want %v"", tt.s, tt.t, got, tt.want)
		}
	}
}

// TestEKGSequence tests the EKG sequence generation
func TestEKGSequence(t *testing.T) {
	tests := []struct {
		start int
		want  []int
	}{
		{2, []int{1, 2, 4, 6, 3, 9, 12, 8, 10, 5}},
		{5, []int{1, 5, 10, 2, 4, 8, 6, 3, 9, 12}},
		{7, []int{1, 7, 14, 2, 4, 8, 10, 5, 15, 3}},
		{9, []int{1, 9, 3, 6, 2, 4, 8, 10, 5, 15}},
		{10, []int{1, 10, 5, 15, 3, 9, 6, 2, 4, 8}},
	}

	for _, tt := range tests {
		got := generateEKGSequence(tt.start, 10)
		for i, v := range got {
			if v != tt.want[i] {
				t.Errorf(""EKG(%d) = %v; want %v"", tt.start, got, tt.want)
				break
			}
		}
	}
}

// TestConvergence tests the convergence of EKG(5) and EKG(7)
func TestConvergence(t *testing.T) {
	starts := [5]int{2, 5, 7, 9, 10}
	ekg := generateEKGSequences(starts, 100)

	convergenceIndex := findConvergenceIndex(ekg[1], ekg[2])
	want := 12 // Expected convergence term index

	if convergenceIndex != want {
		t.Errorf(""Convergence index = %d; want %d"", convergenceIndex, want)
	}
}

// Helper function to generate EKG sequence
func generateEKGSequence(start, limit int) []int {
	sequence := make([]int, limit)
	sequence[0] = 1
	sequence[1] = start

	for n := 2; n < limit; n++ {
		for i := 2; ; i++ {
			if !contains(sequence[:n], i) && gcd(sequence[n-1], i) > 1 {
				sequence[n] = i
				break
			}
		}
	}

	return sequence
}

// Helper function to generate multiple EKG sequences
func generateEKGSequences(starts [5]int, limit int) [5][]int {
	var ekg [5][]int
	for s, start := range starts {
		ekg[s] = generateEKGSequence(start, limit)
	}
	return ekg
}

// Helper function to find convergence index
func findConvergenceIndex(seq1, seq2 []int) int {
	for i := 2; i < len(seq1); i++ {
		if seq1[i] == seq2[i] && areSame(seq1[:i], seq2[:i]) {
			return i + 1
		}
	}
	return -1
}
",./data/generated/docs_golang/ekg_sequence_convergence/gpt_4o_2024_08_06_ekg_sequence_convergence_test.go,CompileStatus.OK,0.0,51.4,,0.06,0.26,0.12,5.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: contains', 'Severity': '', 'SourceLines': ['\t\tgot := contains(tt.slice, tt.element)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_ekg_sequence_convergence_test.go', 'Offset': 0, 'Line': 20, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: gcd', 'Severity': '', 'SourceLines': ['\t\tgot := gcd(tt.a, tt.b)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_ekg_sequence_convergence_test.go', 'Offset': 0, 'Line': 39, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: areSame', 'Severity': '', 'SourceLines': ['\t\tgot := areSame(tt.s, tt.t)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_ekg_sequence_convergence_test.go', 'Offset': 0, 'Line': 58, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: contains', 'Severity': '', 'SourceLines': ['\t\t\tif !contains(sequence[:n], i) && gcd(sequence[n-1], i) > 1 {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_ekg_sequence_convergence_test.go', 'Offset': 0, 'Line': 110, 'Column': 8}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: areSame', 'Severity': '', 'SourceLines': ['\t\tif seq1[i] == seq2[i] && areSame(seq1[:i], seq2[:i]) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_ekg_sequence_convergence_test.go', 'Offset': 0, 'Line': 132, 'Column': 28}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,60.0,False,[]
Eertree,"An eertree is a data structure designed for efficient processing of certain palindrome tasks, for instance counting the number of sub-palindromes in an input string.

The data structure has commonalities to both tries and suffix trees.
  See links below.



Task

Construct an eertree for the string ""eertree"", then output all sub-palindromes by traversing the tree.



See also

   Wikipedia entry:   trie.
   Wikipedia entry:   suffix tree 
   Cornell University Library, Computer Science, Data Structures and Algorithms ───► EERTREE: An Efficient Data Structure for Processing Palindromes in Strings.

",Go,"package main
 
import ""fmt""
 
func main() {
    tree := eertree([]byte(""eertree""))
    fmt.Println(subPalindromes(tree))
}
 
type edges map[byte]int
 
type node struct {
    length int
    edges
    suffix int
}
 
const evenRoot = 0
const oddRoot = 1
 
func eertree(s []byte) []node {
    tree := []node{
        evenRoot: {length: 0, suffix: oddRoot, edges: edges{}},
        oddRoot:  {length: -1, suffix: oddRoot, edges: edges{}},
    }
    suffix := oddRoot
    var n, k int
    for i, c := range s {
        for n = suffix; ; n = tree[n].suffix {
            k = tree[n].length
            if b := i - k - 1; b >= 0 && s[b] == c {
                break
            }
        }
        if e, ok := tree[n].edges[c]; ok {
            suffix = e
            continue
        }
        suffix = len(tree)
        tree = append(tree, node{length: k + 2, edges: edges{}})
        tree[n].edges[c] = suffix
        if tree[suffix].length == 1 {
            tree[suffix].suffix = 0
            continue
        }
        for {
            n = tree[n].suffix
            if b := i - tree[n].length - 1; b >= 0 && s[b] == c {
                break
            }
        }
        tree[suffix].suffix = tree[n].edges[c]
    }
    return tree
}
 
func subPalindromes(tree []node) (s []string) {
    var children func(int, string)
    children = func(n int, p string) {
        for c, n := range tree[n].edges {
            c := string(c)
            p := c + p + c
            s = append(s, p)
            children(n, p)
        }
    }
    children(0, """")
    for c, n := range tree[1].edges {
        c := string(c)
        s = append(s, c)
        children(n, c)
    }
    return
}",1677,74,"package main

import (
	""reflect""
	""testing""
)

func TestEertree(t *testing.T) {
	tree := eertree([]byte(""eertree""))
	expectedTree := []node{
		{length: 0, suffix: 1, edges: edges{'e': 2, 'r': 4, 't': 5}},
		{length: -1, suffix: 1, edges: edges{'e': 2}},
		{length: 1, suffix: 0, edges: edges{'e': 3}},
		{length: 3, suffix: 2, edges: edges{}},
		{length: 1, suffix: 0, edges: edges{}},
		{length: 1, suffix: 0, edges: edges{'r': 6}},
		{length: 3, suffix: 4, edges: edges{'e': 7}},
		{length: 5, suffix: 3, edges: edges{}},
	}

	if !reflect.DeepEqual(tree, expectedTree) {
		t.Errorf(""Expected tree: %v, got: %v"", expectedTree, tree)
	}
}

func TestSubPalindromes(t *testing.T) {
	tree := eertree([]byte(""eertree""))
	subPalindromesList := subPalindromes(tree)
	expectedSubPalindromes := []string{""e"", ""eee"", ""r"", ""t"", ""rtr"", ""eertree""}

	if !reflect.DeepEqual(subPalindromesList, expectedSubPalindromes) {
		t.Errorf(""Expected sub-palindromes: %v, got: %v"", expectedSubPalindromes, subPalindromesList)
	}
}
",./data/generated/docs_golang/eertree/gpt_4o_2024_08_06_eertree_test.go,CompileStatus.OK,0.0,89.5,,0.1,0.13,0.123,7.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: eertree', 'Severity': '', 'SourceLines': ['\ttree := eertree([]byte(""eertree""))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_eertree_test.go', 'Offset': 0, 'Line': 9, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: node', 'Severity': '', 'SourceLines': ['\texpectedTree := []node{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_eertree_test.go', 'Offset': 0, 'Line': 10, 'Column': 20}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: edges', 'Severity': '', 'SourceLines': [""\t\t{length: 0, suffix: 1, edges: edges{'e': 2, 'r': 4, 't': 5}},""], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_eertree_test.go', 'Offset': 0, 'Line': 11, 'Column': 33}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: edges', 'Severity': '', 'SourceLines': [""\t\t{length: -1, suffix: 1, edges: edges{'e': 2}},""], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_eertree_test.go', 'Offset': 0, 'Line': 12, 'Column': 34}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: edges', 'Severity': '', 'SourceLines': [""\t\t{length: 1, suffix: 0, edges: edges{'e': 3}},""], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_eertree_test.go', 'Offset': 0, 'Line': 13, 'Column': 33}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: eertree', 'Severity': '', 'SourceLines': ['\ttree := eertree([]byte(""eertree""))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_eertree_test.go', 'Offset': 0, 'Line': 27, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: subPalindromes', 'Severity': '', 'SourceLines': ['\tsubPalindromesList := subPalindromes(tree)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_eertree_test.go', 'Offset': 0, 'Line': 28, 'Column': 24}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Egyptian division,"Egyptian division is a method of dividing integers using addition and
doubling that is similar to the algorithm of Ethiopian multiplication

Algorithm:

Given two numbers where the dividend is to be divided by the divisor:

 Start the construction of a table of two columns: powers_of_2, and doublings; by a first row of a 1 (i.e. 2^0) in the first column and 1 times the divisor in the first row second column.
 Create the second row with columns of 2 (i.e 2^1), and 2 * divisor in order.
 Continue with successive i’th rows of 2^i and 2^i * divisor.
 Stop adding rows, and keep only those rows, where 2^i * divisor is less than or equal to the dividend.
 We now assemble two separate sums that both start as zero, called here answer and accumulator
 Consider each row of the table, in the reverse order of its construction.
 If the current value of the accumulator added to the doublings cell would be less than or equal to the dividend then add it to the accumulator, as well as adding the powers_of_2 cell value to the answer.
 When the first row has been considered as above, then the integer division of dividend by divisor is given by answer.
 (And the remainder is given by the absolute value of accumulator - dividend).


Example: 580 / 34

 Table creation: 



 powers_of_2

 doublings


 1

 34


 2

 68


 4

 136


 8

 272


 16

 544

 Initialization of sums: 



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272






 16

 544










 0

 0

 Considering table rows, bottom-up: 

When a row is considered it is shown crossed out if it is not accumulated, or bold if the row causes summations.



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272






 16

 544

 16

 544



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272

 16

 544


 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136

 16

 544


 8

 272






 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68

 16

 544


 4

 136






 8

 272






 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34

 17

 578


 2

 68






 4

 136






 8

 272






 16

 544





Answer

So 580 divided by 34 using the Egyptian method is 17 remainder (578 - 580) or 2.



Task

The task is to create a function that does Egyptian division. The function should

closely follow the description above in using a list/array of powers of two, and

another of doublings.

 Functions should be clear interpretations of the algorithm.
 Use the function to divide 580 by 34 and show the answer here, on this page.


Related tasks

   Egyptian fractions


References

   Egyptian Number System

",Go,"package main
 
import ""fmt""
 
func egyptianDivide(dividend, divisor int) (quotient, remainder int) {
    if dividend < 0 || divisor <= 0 {
        panic(""Invalid argument(s)"")
    }
    if dividend < divisor {
        return 0, dividend
    }
    powersOfTwo := []int{1}
    doublings := []int{divisor}
    doubling := divisor
    for {
        doubling *= 2
        if doubling > dividend {
            break
        }
        l := len(powersOfTwo)
        powersOfTwo = append(powersOfTwo, powersOfTwo[l-1]*2)
        doublings = append(doublings, doubling)
    }
    answer := 0
    accumulator := 0
    for i := len(doublings) - 1; i >= 0; i-- {
        if accumulator+doublings[i] <= dividend {
            accumulator += doublings[i]
            answer += powersOfTwo[i]
            if accumulator == dividend {
                break
            }
        }
    }
    return answer, dividend - accumulator
}
 
func main() {
    dividend := 580
    divisor := 34
    quotient, remainder := egyptianDivide(dividend, divisor)
    fmt.Println(dividend, ""divided by"", divisor, ""is"", quotient, ""with remainder"", remainder)
}",1124,43,"package main

import (
	""testing""
)

func TestEgyptianDivide(t *testing.T) {
	tests := []struct {
		dividend  int
		divisor   int
		quotient  int
		remainder int
	}{
		{580, 34, 17, 2},
		{100, 3, 33, 1},
		{50, 7, 7, 1},
		{0, 5, 0, 0},
		{5, 5, 1, 0},
		{5, 10, 0, 5},
	}

	for _, test := range tests {
		q, r := egyptianDivide(test.dividend, test.divisor)
		if q != test.quotient || r != test.remainder {
			t.Errorf(""egyptianDivide(%d, %d) = (%d, %d); want (%d, %d)"", test.dividend, test.divisor, q, r, test.quotient, test.remainder)
		}
	}
}

func TestEgyptianDivideInvalidArguments(t *testing.T) {
	tests := []struct {
		dividend int
		divisor  int
	}{
		{-1, 5},
		{5, 0},
		{5, -1},
	}

	for _, test := range tests {
		defer func() {
			if r := recover(); r == nil {
				t.Errorf(""egyptianDivide(%d, %d) did not panic"", test.dividend, test.divisor)
			}
		}()
		egyptianDivide(test.dividend, test.divisor)
	}
}
",./data/generated/docs_golang/egyptian_division/gpt_4o_2024_08_06_egyptian_division_test.go,CompileStatus.OK,0.0,85.2,,0.07,0.2,0.196,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: egyptianDivide', 'Severity': '', 'SourceLines': ['\t\tq, r := egyptianDivide(test.dividend, test.divisor)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_egyptian_division_test.go', 'Offset': 0, 'Line': 23, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: egyptianDivide', 'Severity': '', 'SourceLines': ['\t\tegyptianDivide(test.dividend, test.divisor)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_egyptian_division_test.go', 'Offset': 0, 'Line': 46, 'Column': 3}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Egyptian fractions,"An   Egyptian fraction   is the sum of distinct unit fractions such as:

  






1
2



+



1
3



+



1
16




(
=



43
48



)


{\displaystyle {\tfrac {1}{2}}+{\tfrac {1}{3}}+{\tfrac {1}{16}}\,(={\tfrac {43}{48}})}

 
Each fraction in the expression has a numerator equal to   1   (unity)   and a denominator that is a positive integer,   and all the denominators are distinct   (i.e., no repetitions).

Fibonacci's   Greedy algorithm for Egyptian fractions   expands the fraction    






x
y





{\displaystyle {\tfrac {x}{y}}}

    to be represented by repeatedly performing the replacement

  





x
y


=


1

⌈
y

/

x
⌉



+



(
−
y
)





mod


x


y
⌈
y

/

x
⌉





{\displaystyle {\frac {x}{y}}={\frac {1}{\lceil y/x\rceil }}+{\frac {(-y)\!\!\!\!\mod x}{y\lceil y/x\rceil }}}

 


(simplifying the 2nd term in this replacement as necessary, and where    



⌈
x
⌉


{\displaystyle \lceil x\rceil }

    is the   ceiling   function).



For this task,   Proper and improper fractions   must be able to be expressed.



Proper  fractions   are of the form    






a
b





{\displaystyle {\tfrac {a}{b}}}

    where    



a


{\displaystyle a}

    and    



b


{\displaystyle b}

    are positive integers, such that    



a
<
b


{\displaystyle a<b}

,     and

improper fractions are of the form    






a
b





{\displaystyle {\tfrac {a}{b}}}

    where    



a


{\displaystyle a}

    and    



b


{\displaystyle b}

    are positive integers, such that    a ≥ b.



(See the REXX programming example to view one method of expressing the whole number part of an improper fraction.)

For improper fractions, the integer part of any improper fraction should be first isolated and shown preceding the Egyptian unit fractions, and be surrounded by square brackets [n].



Task requirements

   show the Egyptian fractions for: 






43
48





{\displaystyle {\tfrac {43}{48}}}

 and 






5
121





{\displaystyle {\tfrac {5}{121}}}

 and 






2014
59





{\displaystyle {\tfrac {2014}{59}}}


   for all proper fractions,    






a
b





{\displaystyle {\tfrac {a}{b}}}

    where    



a


{\displaystyle a}

    and    



b


{\displaystyle b}

    are positive one-or two-digit (decimal) integers, find and show an Egyptian fraction that has:
   the largest number of terms,
   the largest denominator.
   for all one-, two-, and three-digit integers,   find and show (as above).     {extra credit}


Also see

   Wolfram MathWorld™ entry: Egyptian fraction

",Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""strings""
)
 
var zero = new(big.Int)
var one = big.NewInt(1)
 
func toEgyptianRecursive(br *big.Rat, fracs []*big.Rat) []*big.Rat {
    if br.Num().Cmp(zero) == 0 {
        return fracs
    }
    iquo := new(big.Int)
    irem := new(big.Int)
    iquo.QuoRem(br.Denom(), br.Num(), irem)
    if irem.Cmp(zero) > 0 {
        iquo.Add(iquo, one)
    }
    rquo := new(big.Rat).SetFrac(one, iquo)
    fracs = append(fracs, rquo)
    num2 := new(big.Int).Neg(br.Denom())
    num2.Rem(num2, br.Num())
    if num2.Cmp(zero) < 0 {
        num2.Add(num2, br.Num())
    }
    denom2 := new(big.Int)
    denom2.Mul(br.Denom(), iquo)
    f := new(big.Rat).SetFrac(num2, denom2)
    if f.Num().Cmp(one) == 0 {
        fracs = append(fracs, f)
        return fracs
    }
    fracs = toEgyptianRecursive(f, fracs)
    return fracs
}
 
func toEgyptian(rat *big.Rat) []*big.Rat {
    if rat.Num().Cmp(zero) == 0 {
        return []*big.Rat{rat}
    }
    var fracs []*big.Rat
    if rat.Num().CmpAbs(rat.Denom()) >= 0 {
        iquo := new(big.Int)
        iquo.Quo(rat.Num(), rat.Denom())
        rquo := new(big.Rat).SetFrac(iquo, one)
        rrem := new(big.Rat)
        rrem.Sub(rat, rquo)
        fracs = append(fracs, rquo)
        fracs = toEgyptianRecursive(rrem, fracs)
    } else {
        fracs = toEgyptianRecursive(rat, fracs)
    }
    return fracs
}
 
func main() {
    fracs := []*big.Rat{big.NewRat(43, 48), big.NewRat(5, 121), big.NewRat(2014, 59)}
    for _, frac := range fracs {
        list := toEgyptian(frac)
        if list[0].Denom().Cmp(one) == 0 {
            first := fmt.Sprintf(""[%v]"", list[0].Num())
            temp := make([]string, len(list)-1)
            for i := 1; i < len(list); i++ {
                temp[i-1] = list[i].String()
            }
            rest := strings.Join(temp, "" + "")
            fmt.Printf(""%v -> %v + %s\n"", frac, first, rest)
        } else {
            temp := make([]string, len(list))
            for i := 0; i < len(list); i++ {
                temp[i] = list[i].String()
            }
            all := strings.Join(temp, "" + "")
            fmt.Printf(""%v -> %s\n"", frac, all)
        }
    }
 
    for _, r := range [2]int{98, 998} {
        if r == 98 {
            fmt.Println(""\nFor proper fractions with 1 or 2 digits:"")
        } else {
            fmt.Println(""\nFor proper fractions with 1, 2 or 3 digits:"")
        }
        maxSize := 0
        var maxSizeFracs []*big.Rat
        maxDen := zero
        var maxDenFracs []*big.Rat
        var sieve = make([][]bool, r+1) // to eliminate duplicates
        for i := 0; i <= r; i++ {
            sieve[i] = make([]bool, r+2)
        }
        for i := 1; i <= r; i++ {
            for j := i + 1; j <= r+1; j++ {
                if sieve[i][j] {
                    continue
                }
                f := big.NewRat(int64(i), int64(j))
                list := toEgyptian(f)
                listSize := len(list)
                if listSize > maxSize {
                    maxSize = listSize
                    maxSizeFracs = maxSizeFracs[0:0]
                    maxSizeFracs = append(maxSizeFracs, f)
                } else if listSize == maxSize {
                    maxSizeFracs = append(maxSizeFracs, f)
                }
                listDen := list[len(list)-1].Denom()
                if listDen.Cmp(maxDen) > 0 {
                    maxDen = listDen
                    maxDenFracs = maxDenFracs[0:0]
                    maxDenFracs = append(maxDenFracs, f)
                } else if listDen.Cmp(maxDen) == 0 {
                    maxDenFracs = append(maxDenFracs, f)
                }
                if i < r/2 {
                    k := 2
                    for {
                        if j*k > r+1 {
                            break
                        }
                        sieve[i*k][j*k] = true
                        k++
                    }
                }
            }
        }
        fmt.Println(""  largest number of items ="", maxSize)
        fmt.Println(""  fraction(s) with this number :"", maxSizeFracs)
        md := maxDen.String()
        fmt.Print(""  largest denominator = "", len(md), "" digits, "")
        fmt.Print(md[0:20], ""..."", md[len(md)-20:], ""\b\n"")
        fmt.Println(""  fraction(s) with this denominator :"", maxDenFracs)
    }
}",4364,137,"package main

import (
    ""math/big""
    ""testing""
)

func TestToEgyptian(t *testing.T) {
    tests := []struct {
        input    *big.Rat
        expected []*big.Rat
    }{
        {
            input:    big.NewRat(43, 48),
            expected: []*big.Rat{big.NewRat(1, 2), big.NewRat(1, 3), big.NewRat(1, 16)},
        },
        {
            input:    big.NewRat(5, 121),
            expected: []*big.Rat{big.NewRat(1, 25), big.NewRat(1, 757), big.NewRat(1, 763309)},
        },
        {
            input:    big.NewRat(2014, 59),
            expected: []*big.Rat{big.NewRat(34, 1), big.NewRat(1, 2), big.NewRat(1, 3), big.NewRat(1, 35442)},
        },
    }

    for _, test := range tests {
        result := toEgyptian(test.input)
        if len(result) != len(test.expected) {
            t.Errorf(""For input %v, expected %v terms, got %v terms"", test.input, len(test.expected), len(result))
            continue
        }
        for i, r := range result {
            if r.Cmp(test.expected[i]) != 0 {
                t.Errorf(""For input %v, expected term %v to be %v, got %v"", test.input, i, test.expected[i], r)
            }
        }
    }
}

func TestToEgyptianRecursive(t *testing.T) {
    tests := []struct {
        input    *big.Rat
        expected []*big.Rat
    }{
        {
            input:    big.NewRat(43, 48),
            expected: []*big.Rat{big.NewRat(1, 2), big.NewRat(1, 3), big.NewRat(1, 16)},
        },
        {
            input:    big.NewRat(5, 121),
            expected: []*big.Rat{big.NewRat(1, 25), big.NewRat(1, 757), big.NewRat(1, 763309)},
        },
    }

    for _, test := range tests {
        result := toEgyptianRecursive(test.input, nil)
        if len(result) != len(test.expected) {
            t.Errorf(""For input %v, expected %v terms, got %v terms"", test.input, len(test.expected), len(result))
            continue
        }
        for i, r := range result {
            if r.Cmp(test.expected[i]) != 0 {
                t.Errorf(""For input %v, expected term %v to be %v, got %v"", test.input, i, test.expected[i], r)
            }
        }
    }
}
",./data/generated/docs_golang/egyptian_fractions/gpt_4o_2024_08_06_egyptian_fractions_test.go,CompileStatus.OK,0.0,34.4,,0.11,0.15,0.117,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: toEgyptian', 'Severity': '', 'SourceLines': ['        result := toEgyptian(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_egyptian_fractions_test.go', 'Offset': 0, 'Line': 28, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: toEgyptianRecursive', 'Severity': '', 'SourceLines': ['        result := toEgyptianRecursive(test.input, nil)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_egyptian_fractions_test.go', 'Offset': 0, 'Line': 57, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Elementary cellular automaton,"An elementary cellular automaton is a one-dimensional cellular automaton where there are two possible states (labeled 0 and 1) and the rule to determine the state of a cell in the next generation depends only on the current state of the cell and its two immediate neighbors. Those three values can be encoded with three bits.

The rules of evolution are then encoded with eight bits indicating the outcome of each of the eight possibilities 111, 110, 101, 100, 011, 010, 001 and 000 in this order. Thus for instance the rule 13 means that a state is updated to 1 only in the cases 011, 010 and 000, since 13 in binary is 0b00001101.



Task

Create a subroutine, program or function that allows to create and visualize the evolution of any of the 256 possible elementary cellular automaton of arbitrary space length and for any given initial state. You can demonstrate your solution with any automaton of your choice.

The space state should wrap: this means that the left-most cell should be considered as the right neighbor of the right-most cell, and reciprocally.

This task is basically a generalization of one-dimensional cellular automata.



See also
 Cellular automata (natureofcode.com)

",Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""math/rand""
    ""strings""
)
 
func main() {
    const cells = 20
    const generations = 9
    fmt.Println(""Single 1, rule 90:"")
    a := big.NewInt(1)
    a.Lsh(a, cells/2)
    elem(90, cells, generations, a)
    fmt.Println(""Random intial state, rule 30:"")
    a = big.NewInt(1)
    a.Rand(rand.New(rand.NewSource(3)), a.Lsh(a, cells))
    elem(30, cells, generations, a)
}
 
func elem(rule uint, cells, generations int, a *big.Int) {
    output := func() {
        fmt.Println(strings.Replace(strings.Replace(
            fmt.Sprintf(""%0*b"", cells, a), ""0"", "" "", -1), ""1"", ""#"", -1))
    }
    output()
    a1 := new(big.Int)
    set := func(cell int, k uint) {
        a1.SetBit(a1, cell, rule>>k&1)
    }
    last := cells - 1
    for r := 0; r < generations; r++ {
        k := a.Bit(last) | a.Bit(0)<<1 | a.Bit(1)<<2
        set(0, k)
        for c := 1; c < last; c++ {
            k = k>>1 | a.Bit(c+1)<<2
            set(c, k)
        }
        set(last, k>>1|a.Bit(0)<<2)
        a, a1 = a1, a
        output()
    }
}",1081,45,error,,,,,,,,,,,False,False,,False,
Elliptic curve arithmetic,"Elliptic curves   are sometimes used in   cryptography   as a way to perform   digital signatures.

The purpose of this task is to implement a simplified (without modular arithmetic) version of the elliptic curve arithmetic which is required by the   elliptic curve DSA   protocol.

In a nutshell, an elliptic curve is a bi-dimensional curve defined by the following relation between the x and y coordinates of any point on the curve:

   




y

2


=

x

3


+
a
x
+
b


{\displaystyle y^{2}=x^{3}+ax+b}


a and b are arbitrary parameters that define the specific curve which is used.

For this particular task, we'll use the following parameters:

    a=0,   b=7 
The most interesting thing about elliptic curves is the fact that it is possible to define a   group   structure on it.

To do so we define an   internal composition   rule with an additive notation +,   such that for any three distinct points P, Q and R on the curve, whenever these points are aligned, we have:

    P + Q + R = 0  
Here   0   (zero)   is the infinity point,   for which the x and y values are not defined.   It's basically the same kind of point which defines the horizon in   projective geometry.

We'll also assume here that this infinity point is unique and defines the   neutral element   of the addition.

This was not the definition of the addition, but only its desired property.   For a more accurate definition, we proceed as such:

Given any three aligned points P, Q and R,   we define the sum   S = P + Q   as the point (possibly the infinity point) such that   S, R   and the infinity point are aligned.

Considering the symmetry of the curve around the x-axis, it's easy to convince oneself that two points S and R can be aligned with the infinity point if and only if S and R are symmetric of one another towards the x-axis   (because in that case there is no other candidate than the infinity point to complete the alignment triplet).

S is thus defined as the symmetric of R towards the x axis.

The task consists in defining the addition which, for any two points of the curve, returns the sum of these two points.   You will pick two random points on the curve, compute their sum and show that the symmetric of the sum is aligned with the two initial points.

You will use the a and b parameters of secp256k1, i.e. respectively zero and seven.

Hint:   You might need to define a ""doubling"" function, that returns P+P for any given point P.

Extra credit:   define the full elliptic curve arithmetic (still not modular, though) by defining a ""multiply"" function that returns,

for any point P and integer n,   the point P + P + ... + P     (n times).



",Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
const bCoeff = 7
 
type pt struct{ x, y float64 }
 
func zero() pt {
    return pt{math.Inf(1), math.Inf(1)}
}
 
func is_zero(p pt) bool {
    return p.x > 1e20 || p.x < -1e20
}
 
func neg(p pt) pt {
    return pt{p.x, -p.y}
}
 
func dbl(p pt) pt {
    if is_zero(p) {
        return p
    }
    L := (3 * p.x * p.x) / (2 * p.y)
    x := L*L - 2*p.x
    return pt{
        x: x,
        y: L*(p.x-x) - p.y,
    }
}
 
func add(p, q pt) pt {
    if p.x == q.x && p.y == q.y {
        return dbl(p)
    }
    if is_zero(p) {
        return q
    }
    if is_zero(q) {
        return p
    }
    L := (q.y - p.y) / (q.x - p.x)
    x := L*L - p.x - q.x
    return pt{
        x: x,
        y: L*(p.x-x) - p.y,
    }
}
 
func mul(p pt, n int) pt {
    r := zero()
    for i := 1; i <= n; i <<= 1 {
        if i&n != 0 {
            r = add(r, p)
        }
        p = dbl(p)
    }
    return r
}
 
func show(s string, p pt) {
    fmt.Printf(""%s"", s)
    if is_zero(p) {
        fmt.Println(""Zero"")
    } else {
        fmt.Printf(""(%.3f, %.3f)\n"", p.x, p.y)
    }
}
 
func from_y(y float64) pt {
    return pt{
        x: math.Cbrt(y*y - bCoeff),
        y: y,
    }
}
 
func main() {
    a := from_y(1)
    b := from_y(2)
    show(""a = "", a)
    show(""b = "", b)
    c := add(a, b)
    show(""c = a + b = "", c)
    d := neg(c)
    show(""d = -c = "", d)
    show(""c + d = "", add(c, d))
    show(""a + b + d = "", add(a, add(b, d)))
    show(""a * 12345 = "", mul(a, 12345))
}",1511,93,"package main

import (
    ""testing""
    ""math""
)

func TestZero(t *testing.T) {
    z := zero()
    if !is_zero(z) {
        t.Errorf(""Expected zero point, got (%f, %f)"", z.x, z.y)
    }
}

func TestNegation(t *testing.T) {
    p := pt{3, 4}
    n := neg(p)
    if n.x != p.x || n.y != -p.y {
        t.Errorf(""Expected negation to be (%f, %f), got (%f, %f)"", p.x, -p.y, n.x, n.y)
    }
}

func TestDoubling(t *testing.T) {
    p := pt{3, 4}
    d := dbl(p)
    if is_zero(d) {
        t.Errorf(""Doubling of a non-zero point should not be zero"")
    }
}

func TestAddition(t *testing.T) {
    p := pt{3, 4}
    q := pt{5, 6}
    r := add(p, q)
    if is_zero(r) {
        t.Errorf(""Addition of two distinct points should not be zero"")
    }
}

func TestAdditionWithZero(t *testing.T) {
    p := pt{3, 4}
    z := zero()
    r := add(p, z)
    if r != p {
        t.Errorf(""Addition with zero should return the same point, got (%f, %f)"", r.x, r.y)
    }
}

func TestMultiplication(t *testing.T) {
    p := pt{3, 4}
    r := mul(p, 0)
    if !is_zero(r) {
        t.Errorf(""Multiplication by zero should return zero point"")
    }
    r = mul(p, 1)
    if r != p {
        t.Errorf(""Multiplication by one should return the same point, got (%f, %f)"", r.x, r.y)
    }
}

func TestFromY(t *testing.T) {
    y := 2.0
    p := from_y(y)
    if math.Abs(p.y-y) > 1e-9 {
        t.Errorf(""Expected y to be %f, got %f"", y, p.y)
    }
}

func TestMainFunctionality(t *testing.T) {
    a := from_y(1)
    b := from_y(2)
    c := add(a, b)
    d := neg(c)
    if !is_zero(add(c, d)) {
        t.Errorf(""c + (-c) should be zero"")
    }
    if !is_zero(add(a, add(b, d))) {
        t.Errorf(""a + b + (-c) should be zero"")
    }
    r := mul(a, 12345)
    if is_zero(r) {
        t.Errorf(""Multiplication result should not be zero"")
    }
}
",./data/generated/docs_golang/elliptic_curve_arithmetic/gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go,CompileStatus.OK,0.0,56.4,,0.21,0.61,0.115,20.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: zero', 'Severity': '', 'SourceLines': ['    z := zero()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 9, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: is_zero', 'Severity': '', 'SourceLines': ['    if !is_zero(z) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 10, 'Column': 9}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: pt', 'Severity': '', 'SourceLines': ['    p := pt{3, 4}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 16, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: neg', 'Severity': '', 'SourceLines': ['    n := neg(p)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 17, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: pt', 'Severity': '', 'SourceLines': ['    p := pt{3, 4}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 24, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: dbl', 'Severity': '', 'SourceLines': ['    d := dbl(p)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 25, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: is_zero', 'Severity': '', 'SourceLines': ['    if is_zero(d) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 26, 'Column': 8}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: pt', 'Severity': '', 'SourceLines': ['    p := pt{3, 4}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 32, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: add', 'Severity': '', 'SourceLines': ['    r := add(p, q)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 34, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: is_zero', 'Severity': '', 'SourceLines': ['    if is_zero(r) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 35, 'Column': 8}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: zero', 'Severity': '', 'SourceLines': ['    z := zero()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 42, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: add', 'Severity': '', 'SourceLines': ['    r := add(p, z)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 43, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: mul', 'Severity': '', 'SourceLines': ['    r := mul(p, 0)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 51, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: mul', 'Severity': '', 'SourceLines': ['    r = mul(p, 1)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 55, 'Column': 9}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: from_y', 'Severity': '', 'SourceLines': ['    p := from_y(y)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 63, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: from_y', 'Severity': '', 'SourceLines': ['    a := from_y(1)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 70, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: from_y', 'Severity': '', 'SourceLines': ['    b := from_y(2)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 71, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: add', 'Severity': '', 'SourceLines': ['    c := add(a, b)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 72, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: neg', 'Severity': '', 'SourceLines': ['    d := neg(c)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 73, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: mul', 'Severity': '', 'SourceLines': ['    r := mul(a, 12345)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_elliptic_curve_arithmetic_test.go', 'Offset': 0, 'Line': 80, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Empty program,"Task

Create the simplest possible program that is still considered ""correct.""



",Go,"package main
func main() { }",28,2,"package main

import (
	""testing""
)

func TestMainFunction(t *testing.T) {
	// Since the main function is empty and does nothing,
	// this test will always pass as long as the program compiles successfully.
	// The purpose of this test is to ensure that the main function exists
	// and the program is syntactically correct.
}
",./data/generated/docs_golang/empty_program/gpt_4o_2024_08_06_empty_program_test.go,CompileStatus.OK,0.0,,,0.0,0.0,0.117,0.0,[],False,False,100.0,False,[]
Entropy/Narcissist,"
Task

Write a computer program that computes and shows its own   entropy.



Related Tasks

   Fibonacci_word
   Entropy

",Go,"package main
 
import (
    ""fmt""
    ""io/ioutil""
    ""log""
    ""math""
    ""os""
    ""runtime""
)
 
func main() {
    _, src, _, _ := runtime.Caller(0)
    fmt.Println(""Source file entropy:"", entropy(src))
    fmt.Println(""Binary file entropy:"", entropy(os.Args[0]))
}
 
func entropy(file string) float64 {
    d, err := ioutil.ReadFile(file)
    if err != nil {
        log.Fatal(err)
    }
    var f [256]float64
    for _, b := range d {
        f[b]++
    }
    hm := 0.
    for _, c := range f {
        if c > 0 {
            hm += c * math.Log2(c)
        }
    }
    l := float64(len(d))
    return math.Log2(l) - hm/l
}",626,35,"package main

import (
	""io/ioutil""
	""math""
	""os""
	""testing""
)

func TestEntropy(t *testing.T) {
	// Create temporary files for testing
	srcFile, err := ioutil.TempFile("""", ""src_test"")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(srcFile.Name())

	binFile, err := ioutil.TempFile("""", ""bin_test"")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(binFile.Name())

	// Write known content to the source file
	srcContent := []byte(""aaaabbbbccccdddd"")
	if _, err := srcFile.Write(srcContent); err != nil {
		t.Fatal(err)
	}
	srcFile.Close()

	// Write known content to the binary file
	binContent := []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	if _, err := binFile.Write(binContent); err != nil {
		t.Fatal(err)
	}
	binFile.Close()

	tests := []struct {
		file     string
		expected float64
	}{
		{srcFile.Name(), calculateExpectedEntropy(srcContent)},
		{binFile.Name(), calculateExpectedEntropy(binContent)},
	}

	for _, tt := range tests {
		t.Run(tt.file, func(t *testing.T) {
			got := entropy(tt.file)
			if math.Abs(got-tt.expected) > 1e-9 {
				t.Errorf(""entropy(%s) = %v; want %v"", tt.file, got, tt.expected)
			}
		})
	}
}

func calculateExpectedEntropy(data []byte) float64 {
	var f [256]float64
	for _, b := range data {
		f[b]++
	}
	hm := 0.
	for _, c := range f {
		if c > 0 {
			hm += c * math.Log2(c)
		}
	}
	l := float64(len(data))
	return math.Log2(l) - hm/l
}
",./data/generated/docs_golang/entropy_narcissist/gpt_4o_2024_08_06_entropy_narcissist_test.go,CompileStatus.OK,0.0,73.3,,0.13,0.83,0.167,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: entropy', 'Severity': '', 'SourceLines': ['\t\t\tgot := entropy(tt.file)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_entropy_narcissist_test.go', 'Offset': 0, 'Line': 48, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Equilibrium index,"An equilibrium index of a sequence is an index into the sequence such that the sum of elements at lower indices is equal to the sum of elements at higher indices.



For example, in a sequence   



A


{\displaystyle A}

:

   




A

0


=
−
7


{\displaystyle A_{0}=-7}


   




A

1


=
1


{\displaystyle A_{1}=1}


   




A

2


=
5


{\displaystyle A_{2}=5}


   




A

3


=
2


{\displaystyle A_{3}=2}


   




A

4


=
−
4


{\displaystyle A_{4}=-4}


   




A

5


=
3


{\displaystyle A_{5}=3}


   




A

6


=
0


{\displaystyle A_{6}=0}


3   is an equilibrium index, because:

   




A

0


+

A

1


+

A

2


=

A

4


+

A

5


+

A

6




{\displaystyle A_{0}+A_{1}+A_{2}=A_{4}+A_{5}+A_{6}}


6   is also an equilibrium index, because:

   




A

0


+

A

1


+

A

2


+

A

3


+

A

4


+

A

5


=
0


{\displaystyle A_{0}+A_{1}+A_{2}+A_{3}+A_{4}+A_{5}=0}


(sum of zero elements is zero)

7   is not an equilibrium index, because it is not a valid index of sequence 



A


{\displaystyle A}

.



Task;
Write a function that, given a sequence, returns its equilibrium indices (if any).

Assume that the sequence may be very long.



",Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
func main() {
    fmt.Println(ex([]int32{-7, 1, 5, 2, -4, 3, 0}))
 
    // sequence of 1,000,000 random numbers, with values
    // chosen so that it will be likely to have a couple
    // of equalibrium indexes.
    rand.Seed(time.Now().UnixNano())
    verylong := make([]int32, 1e6)
    for i := range verylong {
        verylong[i] = rand.Int31n(1001) - 500
    }
    fmt.Println(ex(verylong))
}
 
func ex(s []int32) (eq []int) {
    var r, l int64
    for _, el := range s {
        r += int64(el)
    }
    for i, el := range s {
        r -= int64(el)
        if l == r {
            eq = append(eq, i)
        }
        l += int64(el)
    }
    return
}",725,36,"package main

import (
	""testing""
	""reflect""
)

func TestEx(t *testing.T) {
	tests := []struct {
		input    []int32
		expected []int
	}{
		{
			input:    []int32{-7, 1, 5, 2, -4, 3, 0},
			expected: []int{3, 6},
		},
		{
			input:    []int32{1, 2, 3, 4, 5},
			expected: []int{},
		},
		{
			input:    []int32{0, 0, 0, 0, 0},
			expected: []int{0, 1, 2, 3, 4},
		},
		{
			input:    []int32{1, -1, 0},
			expected: []int{2},
		},
		{
			input:    []int32{10},
			expected: []int{0},
		},
		{
			input:    []int32{},
			expected: []int{},
		},
		{
			input:    []int32{1, 2, 1, 2, 1, 2, 1},
			expected: []int{3},
		},
	}

	for _, test := range tests {
		result := ex(test.input)
		if !reflect.DeepEqual(result, test.expected) {
			t.Errorf(""For input %v, expected %v, but got %v"", test.input, test.expected, result)
		}
	}
}
",./data/generated/docs_golang/equilibrium_index/gpt_4o_2024_08_06_equilibrium_index_test.go,CompileStatus.OK,0.0,60.0,,0.04,0.17,0.114,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: ex', 'Severity': '', 'SourceLines': ['\t\tresult := ex(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_equilibrium_index_test.go', 'Offset': 0, 'Line': 44, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Ethiopian multiplication,"Ethiopian multiplication is a method of multiplying integers using only addition, doubling, and halving.


Method:

 Take two numbers to be multiplied and write them down at the top of two columns.
 In the left-hand column repeatedly halve the last number, discarding any remainders, and write the result below the last in the same column, until you write a value of 1.
 In the right-hand column repeatedly double the last number and write the result below. stop when you add a result in the same row as where the left hand column shows 1.
 Examine the table produced and discard any row where the value in the left column is even.
 Sum the values in the right-hand column that remain to produce the result of multiplying the original two numbers together

For example:   17 × 34

       17    34

Halving the first column:

       17    34
        8
        4
        2
        1

Doubling the second column:

       17    34
        8    68
        4   136 
        2   272
        1   544

Strike-out rows whose first cell is even:

       17    34
        8    68 
        4   136 
        2   272 
        1   544

Sum the remaining numbers in the right-hand column:

       17    34
        8    -- 
        4   --- 
        2   --- 
        1   544
           ====
            578

So 17 multiplied by 34, by the Ethiopian method is 578.



Task

The task is to define three named functions/methods/procedures/subroutines:

 one to halve an integer,
 one to double an integer, and
 one to state if an integer is even.


Use these functions to create a function that does Ethiopian multiplication.



References

Ethiopian multiplication explained (BBC Video clip)
A Night Of Numbers - Go Forth And Multiply (Video)
Russian Peasant Multiplication
Programming Praxis: Russian Peasant Multiplication

",Go,"package main
 
import ""fmt""
 
func halve(i int) int { return i/2 }
 
func double(i int) int { return i*2 }
 
func isEven(i int) bool { return i%2 == 0 }
 
func ethMulti(i, j int) (r int) {
    for ; i > 0; i, j = halve(i), double(j) {
        if !isEven(i) {
            r += j
        }
    }
    return
}
 
func main() {
    fmt.Printf(""17 ethiopian 34 = %d\n"", ethMulti(17, 34))
}",383,22,"package main

import ""testing""

// Test for the halve function
func TestHalve(t *testing.T) {
    tests := []struct {
        input    int
        expected int
    }{
        {10, 5},
        {9, 4},
        {1, 0},
        {0, 0},
        {-4, -2},
    }

    for _, test := range tests {
        result := halve(test.input)
        if result != test.expected {
            t.Errorf(""halve(%d) = %d; expected %d"", test.input, result, test.expected)
        }
    }
}

// Test for the double function
func TestDouble(t *testing.T) {
    tests := []struct {
        input    int
        expected int
    }{
        {10, 20},
        {0, 0},
        {-3, -6},
    }

    for _, test := range tests {
        result := double(test.input)
        if result != test.expected {
            t.Errorf(""double(%d) = %d; expected %d"", test.input, result, test.expected)
        }
    }
}

// Test for the isEven function
func TestIsEven(t *testing.T) {
    tests := []struct {
        input    int
        expected bool
    }{
        {10, true},
        {9, false},
        {0, true},
        {-2, true},
        {-3, false},
    }

    for _, test := range tests {
        result := isEven(test.input)
        if result != test.expected {
            t.Errorf(""isEven(%d) = %v; expected %v"", test.input, result, test.expected)
        }
    }
}

// Test for the ethMulti function
func TestEthMulti(t *testing.T) {
    tests := []struct {
        i, j     int
        expected int
    }{
        {17, 34, 578},
        {0, 34, 0},
        {17, 0, 0},
        {1, 1, 1},
        {2, 3, 6},
        {5, 5, 25},
        {-3, 4, -12},
        {3, -4, -12},
        {-3, -4, 12},
    }

    for _, test := range tests {
        result := ethMulti(test.i, test.j)
        if result != test.expected {
            t.Errorf(""ethMulti(%d, %d) = %d; expected %d"", test.i, test.j, result, test.expected)
        }
    }
}
",./data/generated/docs_golang/ethiopian_multiplication/gpt_4o_2024_08_06_ethiopian_multiplication_test.go,CompileStatus.OK,0.0,87.5,,0.07,0.57,0.112,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: halve', 'Severity': '', 'SourceLines': ['        result := halve(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_ethiopian_multiplication_test.go', 'Offset': 0, 'Line': 19, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: double', 'Severity': '', 'SourceLines': ['        result := double(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_ethiopian_multiplication_test.go', 'Offset': 0, 'Line': 38, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: isEven', 'Severity': '', 'SourceLines': ['        result := isEven(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_ethiopian_multiplication_test.go', 'Offset': 0, 'Line': 59, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: ethMulti', 'Severity': '', 'SourceLines': ['        result := ethMulti(test.i, test.j)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_ethiopian_multiplication_test.go', 'Offset': 0, 'Line': 84, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,75.0,False,[]
Euler's sum of powers conjecture,"There is a conjecture in mathematics that held for over two hundred years before it was disproved by the finding of a counterexample in 1966 by Lander and Parkin.



Euler's (disproved) sum of powers   conjecture

  At least  k  positive  kth  powers are required to sum to a  kth  power,  
  except for the trivial case of one  kth power:  yk = yk 



In 1966,   Leon J. Lander   and   Thomas R. Parkin   used a brute-force search on a   CDC 6600   computer restricting numbers to those less than 250.



Task

Write a program to search for an integer solution for:


  x05 + x15 + x25 + x35 == y5 

Where all     xi's   and    y    are distinct integers between   0   and   250   (exclusive).

Show an answer here.



Related tasks

   Pythagorean quadruples. 
   Pythagorean triples.

",Go,"package main
 
import (
	""fmt""
	""log""
)
 
func main() {
	fmt.Println(eulerSum())
}
 
func eulerSum() (x0, x1, x2, x3, y int) {
	var pow5 [250]int
	for i := range pow5 {
		pow5[i] = i * i * i * i * i
	}
	for x0 = 4; x0 < len(pow5); x0++ {
		for x1 = 3; x1 < x0; x1++ {
			for x2 = 2; x2 < x1; x2++ {
				for x3 = 1; x3 < x2; x3++ {
					sum := pow5[x0] +
						pow5[x1] +
						pow5[x2] +
						pow5[x3]
					for y = x0 + 1; y < len(pow5); y++ {
						if sum == pow5[y] {
							return
						}
					}
				}
			}
		}
	}
	log.Fatal(""no solution"")
	return
}",553,36,"package main

import (
	""testing""
)

func TestEulerSum(t *testing.T) {
	x0, x1, x2, x3, y := eulerSum()

	// Check if the solution is within the specified range
	if x0 <= 0 || x0 >= 250 || x1 <= 0 || x1 >= 250 || x2 <= 0 || x2 >= 250 || x3 <= 0 || x3 >= 250 || y <= 0 || y >= 250 {
		t.Errorf(""Values are out of range: x0=%d, x1=%d, x2=%d, x3=%d, y=%d"", x0, x1, x2, x3, y)
	}

	// Check if all xi's and y are distinct
	if x0 == x1 || x0 == x2 || x0 == x3 || x0 == y ||
		x1 == x2 || x1 == x3 || x1 == y ||
		x2 == x3 || x2 == y ||
		x3 == y {
		t.Errorf(""Values are not distinct: x0=%d, x1=%d, x2=%d, x3=%d, y=%d"", x0, x1, x2, x3, y)
	}

	// Check if the equation holds: x0^5 + x1^5 + x2^5 + x3^5 == y^5
	pow5 := func(n int) int {
		return n * n * n * n * n
	}

	sum := pow5(x0) + pow5(x1) + pow5(x2) + pow5(x3)
	if sum != pow5(y) {
		t.Errorf(""Equation does not hold: %d^5 + %d^5 + %d^5 + %d^5 != %d^5"", x0, x1, x2, x3, y)
	}
}
",./data/generated/docs_golang/euler_s_sum_of_powers_conjecture/gpt_4o_2024_08_06_euler_s_sum_of_powers_conjecture_test.go,CompileStatus.OK,0.0,78.6,,0.19,0.33,10.388,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: eulerSum', 'Severity': '', 'SourceLines': ['\tx0, x1, x2, x3, y := eulerSum()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_euler_s_sum_of_powers_conjecture_test.go', 'Offset': 0, 'Line': 8, 'Column': 23}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Evolutionary algorithm,"Starting with:

 The target string: ""METHINKS IT IS LIKE A WEASEL"".
 An array of random characters chosen from the set of upper-case letters together with the space, and of the same length as the target string. (Call it the parent).
 A fitness function that computes the ‘closeness’ of its argument to the target string.
 A mutate function that given a string and a mutation rate returns a copy of the string, with some characters probably mutated.
 While the parent is not yet the target:
 copy the parent C times, each time allowing some random probability that another character might be substituted using mutate.
 Assess the fitness of the parent and all the copies to the target and make the most fit string the new parent, discarding the others.
 repeat until the parent converges, (hopefully), to the target.


See also

   Wikipedia entry:   Weasel algorithm.
   Wikipedia entry:   Evolutionary algorithm.

Note: to aid comparison, try and ensure the variables and functions mentioned in the task description appear in solutions



A cursory examination of a few of the solutions reveals that the instructions have not been followed rigorously in some solutions. Specifically,

 While the parent is not yet the target:
 copy the parent C times, each time allowing some random probability that another character might be substituted using mutate.
Note that some of the the solutions given retain characters in the mutated string that are correct in the target string. However, the instruction above does not state to retain any of the characters while performing the mutation. Although some may believe to do so is implied from the use of ""converges""

(:* repeat until the parent converges, (hopefully), to the target.

Strictly speaking, the new parent should be selected from the new pool of mutations, and then the new parent used to generate the next set of mutations with parent characters getting retained only by not being mutated. It then becomes possible that the new set of mutations has no member that is fitter than the parent!

As illustration of this error, the code for 8th has the following remark.

Create a new string based on the TOS, changing randomly any characters which
don't already match the target:

NOTE: this has been changed, the 8th version is completely random now

Clearly, this algo will be applying the mutation function only to the parent characters that don't match to the target characters!

To ensure that the new parent is never less fit than the prior parent, both the parent and all of the latest mutations are subjected to the fitness test to select the next parent.



",Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
var target = []byte(""METHINKS IT IS LIKE A WEASEL"")
var set = []byte(""ABCDEFGHIJKLMNOPQRSTUVWXYZ "")
var parent []byte
 
func init() {
    rand.Seed(time.Now().UnixNano())
    parent = make([]byte, len(target))
    for i := range parent {
        parent[i] = set[rand.Intn(len(set))]
    }
}
 
// fitness:  0 is perfect fit.  greater numbers indicate worse fit.
func fitness(a []byte) (h int) {
    // (hamming distance)
    for i, tc := range target {
        if a[i] != tc {
            h++
        }
    }
    return
}
 
// set m to mutation of p, with each character of p mutated with probability r
func mutate(p, m []byte, r float64) {
    for i, ch := range p {
        if rand.Float64() < r {
            m[i] = set[rand.Intn(len(set))]
        } else {
            m[i] = ch
        }
    }
}
 
func main() {
    const c = 20 // number of times to copy and mutate parent
 
    copies := make([][]byte, c)
    for i := range copies {
        copies[i] = make([]byte, len(parent))
    }
 
    fmt.Println(string(parent))
    for best := fitness(parent); best > 0; {
        for _, cp := range copies {
            mutate(parent, cp, .05)
        }
        for _, cp := range copies {
            fm := fitness(cp)
            if fm < best {
                best = fm
                copy(parent, cp)
                fmt.Println(string(parent))
            }
        }
    }
}",1445,65,"package main

import (
	""testing""
	""math/rand""
	""time""
)

// Test initialization of the parent string
func TestInit(t *testing.T) {
	rand.Seed(time.Now().UnixNano())
	parent = make([]byte, len(target))
	for i := range parent {
		parent[i] = set[rand.Intn(len(set))]
	}

	if len(parent) != len(target) {
		t.Errorf(""Expected parent length %d, got %d"", len(target), len(parent))
	}

	for _, ch := range parent {
		if !contains(set, ch) {
			t.Errorf(""Parent contains invalid character: %c"", ch)
		}
	}
}

// Helper function to check if a byte is in a set
func contains(set []byte, ch byte) bool {
	for _, s := range set {
		if s == ch {
			return true
		}
	}
	return false
}

// Test fitness function
func TestFitness(t *testing.T) {
	testCases := []struct {
		input    []byte
		expected int
	}{
		{[]byte(""METHINKS IT IS LIKE A WEASEL""), 0},
		{[]byte(""METHINKS IT IS LIKE A WEASAL""), 1},
		{[]byte(""METHINKS IT IS LIKE A WEASXL""), 2},
		{[]byte(""XXXXXXXXX XX XX XXXX X XXXXXX""), len(target)},
	}

	for _, tc := range testCases {
		result := fitness(tc.input)
		if result != tc.expected {
			t.Errorf(""Expected fitness %d, got %d"", tc.expected, result)
		}
	}
}

// Test mutate function
func TestMutate(t *testing.T) {
	rand.Seed(time.Now().UnixNano())
	parent := []byte(""METHINKS IT IS LIKE A WEASEL"")
	mutated := make([]byte, len(parent))
	mutate(parent, mutated, 0.0)

	if string(mutated) != string(parent) {
		t.Errorf(""Expected mutated string to be unchanged, got %s"", string(mutated))
	}

	mutate(parent, mutated, 1.0)
	if string(mutated) == string(parent) {
		t.Errorf(""Expected mutated string to be different, got %s"", string(mutated))
	}
}

// Test the evolutionary algorithm
func TestEvolutionaryAlgorithm(t *testing.T) {
	rand.Seed(time.Now().UnixNano())
	parent = make([]byte, len(target))
	for i := range parent {
		parent[i] = set[rand.Intn(len(set))]
	}

	const c = 20
	copies := make([][]byte, c)
	for i := range copies {
		copies[i] = make([]byte, len(parent))
	}

	for best := fitness(parent); best > 0; {
		for _, cp := range copies {
			mutate(parent, cp, .05)
		}
		for _, cp := range copies {
			fm := fitness(cp)
			if fm < best {
				best = fm
				copy(parent, cp)
			}
		}
	}

	if string(parent) != string(target) {
		t.Errorf(""Expected parent to converge to target, got %s"", string(parent))
	}
}
",./data/generated/docs_golang/evolutionary_algorithm/gpt_4o_2024_08_06_evolutionary_algorithm_test.go,CompileStatus.OK,0.0,46.2,,0.1,0.43,0.179,13.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: target', 'Severity': '', 'SourceLines': ['\tparent = make([]byte, len(target))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_evolutionary_algorithm_test.go', 'Offset': 0, 'Line': 12, 'Column': 28}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: parent', 'Severity': '', 'SourceLines': ['\tfor i := range parent {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_evolutionary_algorithm_test.go', 'Offset': 0, 'Line': 13, 'Column': 17}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: parent', 'Severity': '', 'SourceLines': ['\t\tparent[i] = set[rand.Intn(len(set))]'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_evolutionary_algorithm_test.go', 'Offset': 0, 'Line': 14, 'Column': 3}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: parent', 'Severity': '', 'SourceLines': ['\tif len(parent) != len(target) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_evolutionary_algorithm_test.go', 'Offset': 0, 'Line': 17, 'Column': 9}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: target', 'Severity': '', 'SourceLines': ['\t\tt.Errorf(""Expected parent length %d, got %d"", len(target), len(parent))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_evolutionary_algorithm_test.go', 'Offset': 0, 'Line': 18, 'Column': 53}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: set', 'Severity': '', 'SourceLines': ['\t\tif !contains(set, ch) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_evolutionary_algorithm_test.go', 'Offset': 0, 'Line': 22, 'Column': 16}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: target', 'Severity': '', 'SourceLines': ['\t\t{[]byte(""XXXXXXXXX XX XX XXXX X XXXXXX""), len(target)},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_evolutionary_algorithm_test.go', 'Offset': 0, 'Line': 47, 'Column': 49}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fitness', 'Severity': '', 'SourceLines': ['\t\tresult := fitness(tc.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_evolutionary_algorithm_test.go', 'Offset': 0, 'Line': 51, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: mutate', 'Severity': '', 'SourceLines': ['\tmutate(parent, mutated, 0.0)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_evolutionary_algorithm_test.go', 'Offset': 0, 'Line': 63, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: mutate', 'Severity': '', 'SourceLines': ['\tmutate(parent, mutated, 1.0)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_evolutionary_algorithm_test.go', 'Offset': 0, 'Line': 69, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fitness', 'Severity': '', 'SourceLines': ['\tfor best := fitness(parent); best > 0; {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_evolutionary_algorithm_test.go', 'Offset': 0, 'Line': 89, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: mutate', 'Severity': '', 'SourceLines': ['\t\t\tmutate(parent, cp, .05)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_evolutionary_algorithm_test.go', 'Offset': 0, 'Line': 91, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fitness', 'Severity': '', 'SourceLines': ['\t\t\tfm := fitness(cp)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_evolutionary_algorithm_test.go', 'Offset': 0, 'Line': 94, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,75.0,False,[]
Exceptions/Catch an exception thrown in a nested call,"Show how to create a user-defined exception   and   show how to catch an exception raised from several nested calls away.

   Create two user-defined exceptions,   U0   and   U1. 
   Have function   foo   call function   bar   twice.
   Have function   bar   call function   baz. 
   Arrange for function   baz   to raise, or throw exception   U0   on its first call, then exception   U1   on its second.
   Function   foo   should catch only exception   U0,   not   U1.


Show/describe what happens when the program is run.



",Go,"// Outline for a try/catch-like exception mechanism in Go
//
// As all Go programmers should know, the Go authors are sharply critical of
// the try/catch idiom and consider it bad practice in general.
// See http://golang.org/doc/go_faq.html#exceptions
 
package main
 
import (
    ""fmt""
    ""runtime""
    ""strings""
)
 
// trace is for pretty output for the Rosetta Code task.
// It would have no place in a practical program.
func trace(s string) {
    nc := runtime.Callers(2, cs)
    f := runtime.FuncForPC(cs[0])
    fmt.Print(strings.Repeat(""  "", nc-3), f.Name()[5:], "": "", s, ""\n"")
}
 
var cs = make([]uintptr, 10)
 
type exception struct {
    name    string
    handler func()
}
 
// try implents the try/catch-like exception mechanism.  It takes a function
// to be called, and a list of exceptions to catch during the function call.
// Note that for this simple example, f has no parameters.  In a practical
// program it might, of course.  In this case, the signature of try would
// have to be modified to take these parameters and then supply them to f
// when it calls f.
func try(f func(), exs []exception) {
    trace(""start"")
    defer func() {
        if pv := recover(); pv != nil {
            trace(""Panic mode!"")
            if px, ok := pv.(exception); ok {
                for _, ex := range exs {
                    if ex.name == px.name {
                        trace(""handling exception"")
                        px.handler()
                        trace(""panic over"")
                        return
                    }
                }
            }
            trace(""can't recover this one!"")
            panic(pv)
        }
    }()
    f()
    trace(""complete"")
}
 
func main() {
    trace(""start"")
    foo()
    trace(""complete"")
}
 
// u0, u1 declared at package level so they can be accessed by any function.
var u0, u1 exception
 
// foo.  Note that function literals u0, u1 here in the lexical scope
// of foo serve the purpose of catch blocks of other languages.
// Passing u0 to try serves the purpose of the catch condition.
// While try(bar... reads much like the try statement of other languages,
// this try is an ordinary function.  foo is passing bar into try,
// not calling it directly.
func foo() {
    trace(""start"")
    u0 = exception{""U0"", func() { trace(""U0 handled"") }}
    u1 = exception{""U1"", func() { trace(""U1 handled"") }}
    try(bar, []exception{u0})
    try(bar, []exception{u0})
    trace(""complete"")
}
 
func bar() {
    trace(""start"")
    baz()
    trace(""complete"")
}
 
var bazCall int
 
func baz() {
    trace(""start"")
    bazCall++
    switch bazCall {
    case 1:
        trace(""panicking with execption U0"")
        panic(u0)
    case 2:
        trace(""panicking with execption U1"")
        panic(u1)
    }
    trace(""complete"")
}",2805,103,"package main

import (
    ""testing""
    ""strings""
)

// Mock trace function to capture output for testing
var traceOutput []string

func mockTrace(s string) {
    traceOutput = append(traceOutput, s)
}

func TestExceptionHandling(t *testing.T) {
    // Replace the trace function with the mockTrace
    originalTrace := trace
    trace = mockTrace
    defer func() { trace = originalTrace }() // Restore original trace function after test

    // Clear previous trace output
    traceOutput = []string{}

    // Run the main function which includes the foo function
    main()

    // Expected trace output
    expectedOutput := []string{
        ""start"",
        ""foo: start"",
        ""bar: start"",
        ""baz: start"",
        ""baz: panicking with execption U0"",
        ""Panic mode!"",
        ""handling exception"",
        ""U0 handled"",
        ""panic over"",
        ""complete"",
        ""bar: start"",
        ""baz: start"",
        ""baz: panicking with execption U1"",
        ""Panic mode!"",
        ""can't recover this one!"",
    }

    // Check if the trace output matches the expected output
    for i, expected := range expectedOutput {
        if i >= len(traceOutput) {
            t.Errorf(""Missing trace output: %s"", expected)
            continue
        }
        if !strings.Contains(traceOutput[i], expected) {
            t.Errorf(""Expected trace output '%s', but got '%s'"", expected, traceOutput[i])
        }
    }

    // Check if there are extra outputs
    if len(traceOutput) > len(expectedOutput) {
        for _, extra := range traceOutput[len(expectedOutput):] {
            t.Errorf(""Unexpected extra trace output: %s"", extra)
        }
    }
}
",./data/generated/docs_golang/exceptions_catch_an_exception_thrown_in_a_nested_call/gpt_4o_2024_08_06_exceptions_catch_an_exception_thrown_in_a_nested_call_test.go,CompileStatus.SYNTAX_ERROR,,,,0.19,0.27,,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: trace', 'Severity': '', 'SourceLines': ['    originalTrace := trace'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_exceptions_catch_an_exception_thrown_in_a_nested_call_test.go', 'Offset': 0, 'Line': 17, 'Column': 22}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: trace', 'Severity': '', 'SourceLines': ['    trace = mockTrace'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_exceptions_catch_an_exception_thrown_in_a_nested_call_test.go', 'Offset': 0, 'Line': 18, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: trace', 'Severity': '', 'SourceLines': ['    defer func() { trace = originalTrace }() // Restore original trace function after test'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_exceptions_catch_an_exception_thrown_in_a_nested_call_test.go', 'Offset': 0, 'Line': 19, 'Column': 20}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['    main()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_exceptions_catch_an_exception_thrown_in_a_nested_call_test.go', 'Offset': 0, 'Line': 25, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_exceptions_catch_an_exception_thrown_in_a_nested_call_test.go', 'line': 18, 'column': 5, 'message': 'cannot assign to trace (neither addressable nor a map index expression)'}]"
Execute a Markov algorithm,"Execute a Markov algorithm

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Create an interpreter for a Markov Algorithm.

Rules have the syntax:

<ruleset> ::= ((<comment> | <rule>) <newline>+)*
<comment> ::= # {<any character>}
<rule> ::= <pattern> <whitespace> -> <whitespace> [.] <replacement>
<whitespace> ::= (<tab> | <space>) [<whitespace>]

There is one rule per line.

If there is a   .   (period)   present before the   <replacement>,   then this is a terminating rule in which case the interpreter must halt execution.

A ruleset consists of a sequence of rules, with optional comments.


 Rulesets 

Use the following tests on entries:



Ruleset 1

# This rules file is extracted from Wikipedia:
# http://en.wikipedia.org/wiki/Markov_Algorithm
A -> apple
B -> bag
S -> shop
T -> the
the shop -> my brother
a never used -> .terminating rule

Sample text of:

  I bought a B of As from T S. 
Should generate the output:

  I bought a bag of apples from my brother. 


Ruleset 2

A test of the terminating rule

# Slightly modified from the rules on Wikipedia
A -> apple
B -> bag
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule
Sample text of:

 I bought a B of As from T S.
Should generate:

 I bought a bag of apples from T shop.


Ruleset 3

This tests for correct substitution order and may trap simple regexp based replacement routines if special regexp characters are not escaped.

# BNF Syntax testing rules
A -> apple
WWWW -> with
Bgage -> ->.*
B -> bag
->.* -> money
W -> WW
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule

Sample text of:

 I bought a B of As W my Bgage from T S.
Should generate:

 I bought a bag of apples with my money from T shop.


Ruleset 4

This tests for correct order of scanning of rules, and may trap replacement routines that scan in the wrong order.   It implements a general unary multiplication engine.   (Note that the input expression must be placed within underscores in this implementation.)

### Unary Multiplication Engine, for testing Markov Algorithm implementations
### By Donal Fellows.
# Unary addition engine
_+1 -> _1+
1+1 -> 11+
# Pass for converting from the splitting of multiplication into ordinary
# addition
1! -> !1
,! -> !+
_! -> _
# Unary multiplication by duplicating left side, right side times
1*1 -> x,@y
1x -> xX
X, -> 1,1
X1 -> 1X
_x -> _X
,x -> ,X
y1 -> 1y
y_ -> _
# Next phase of applying
1@1 -> x,@y
1@_ -> @_
,@_ -> !_
++ -> +
# Termination cleanup for addition
_1 -> 1
1+_ -> 1
_+_ -> 

Sample text of:

  _1111*11111_ 
should generate the output:

  11111111111111111111 


Ruleset 5

A simple Turing machine,
implementing a three-state busy beaver.

The tape consists of 0s and 1s,   the states are A, B, C and H (for Halt), and the head position is indicated by writing the state letter before the character where the head is.
All parts of the initial tape the machine operates on have to be given in the input.

Besides demonstrating that the Markov algorithm is Turing-complete, it also made me catch a bug in the C++ implementation which wasn't caught by the first four rulesets.

# Turing machine: three-state busy beaver
#
# state A, symbol 0 => write 1, move right, new state B
A0 -> 1B
# state A, symbol 1 => write 1, move left, new state C
0A1 -> C01
1A1 -> C11
# state B, symbol 0 => write 1, move left, new state A
0B0 -> A01
1B0 -> A11
# state B, symbol 1 => write 1, move right, new state B
B1 -> 1B
# state C, symbol 0 => write 1, move left, new state B
0C0 -> B01
1C0 -> B11
# state C, symbol 1 => write 1, move left, halt
0C1 -> H01
1C1 -> H11

This ruleset should turn

  000000A000000 
into

  00011H1111000 

",Go,"package main
 
import (
    ""fmt""
    ""regexp""
    ""strings""
)
 
type testCase struct {
    ruleSet, sample, output string
}
 
func main() {
    fmt.Println(""validating"", len(testSet), ""test cases"")
    var failures bool
    for i, tc := range testSet {
        if r, ok := interpret(tc.ruleSet, tc.sample); !ok {
            fmt.Println(""test"", i+1, ""invalid ruleset"")
            failures = true
        } else if r != tc.output {
            fmt.Printf(""test %d: got %q, want %q\n"", i+1, r, tc.output)
            failures = true
        }
    }
    if !failures {
        fmt.Println(""no failures"")
    }
}
 
func interpret(ruleset, input string) (string, bool) {
    if rules, ok := parse(ruleset); ok {
        return run(rules, input), true
    }
    return """", false
}
 
type rule struct {
    pat  string
    rep  string
    term bool
}
 
var (
    rxSet   = regexp.MustCompile(ruleSet)
    rxEle   = regexp.MustCompile(ruleEle)
    ruleSet = `(?m:^(?:` + ruleEle + `)*$)`
    ruleEle = `(?:` + comment + `|` + ruleRe + `)\n+`
    comment = `#.*`
    ruleRe  = `(.*)` + ws + `->` + ws + `([.])?(.*)`
    ws      = `[\t ]+`
)
 
func parse(rs string) ([]rule, bool) {
    if !rxSet.MatchString(rs) {
        return nil, false
    }
    x := rxEle.FindAllStringSubmatchIndex(rs, -1)
    var rules []rule
    for _, x := range x {
        if x[2] > 0 {
            rules = append(rules,
                rule{pat: rs[x[2]:x[3]], term: x[4] > 0, rep: rs[x[6]:x[7]]})
        }
    }
    return rules, true
}
 
func run(rules []rule, s string) string {
step1:
    for _, r := range rules {
        if f := strings.Index(s, r.pat); f >= 0 {
            s = s[:f] + r.rep + s[f+len(r.pat):]
            if r.term {
                return s
            }
            goto step1
        }
    }
    return s
}
 
// text all cut and paste from RC task page
var testSet = []testCase{
    {`# This rules file is extracted from Wikipedia:
# http://en.wikipedia.org/wiki/Markov_Algorithm
A -> apple
B -> bag
S -> shop
T -> the
the shop -> my brother
a never used -> .terminating rule
`,
        `I bought a B of As from T S.`,
        `I bought a bag of apples from my brother.`,
    },
    {`# Slightly modified from the rules on Wikipedia
A -> apple
B -> bag
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule
`,
        `I bought a B of As from T S.`,
        `I bought a bag of apples from T shop.`,
    },
    {`# BNF Syntax testing rules
A -> apple
WWWW -> with
Bgage -> ->.*
B -> bag
->.* -> money
W -> WW
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule
`,
        `I bought a B of As W my Bgage from T S.`,
        `I bought a bag of apples with my money from T shop.`,
    },
    {`### Unary Multiplication Engine, for testing Markov Algorithm implementations
### By Donal Fellows.
# Unary addition engine
_+1 -> _1+
1+1 -> 11+
# Pass for converting from the splitting of multiplication into ordinary
# addition
1! -> !1
,! -> !+
_! -> _
# Unary multiplication by duplicating left side, right side times
1*1 -> x,@y
1x -> xX
X, -> 1,1
X1 -> 1X
_x -> _X
,x -> ,X
y1 -> 1y
y_ -> _
# Next phase of applying
1@1 -> x,@y
1@_ -> @_
,@_ -> !_
++ -> +
# Termination cleanup for addition
_1 -> 1
1+_ -> 1
_+_ -> 
`,
        `_1111*11111_`,
        `11111111111111111111`,
    },
    {`# Turing machine: three-state busy beaver
#
# state A, symbol 0 => write 1, move right, new state B
A0 -> 1B
# state A, symbol 1 => write 1, move left, new state C
0A1 -> C01
1A1 -> C11
# state B, symbol 0 => write 1, move left, new state A
0B0 -> A01
1B0 -> A11
# state B, symbol 1 => write 1, move right, new state B
B1 -> 1B
# state C, symbol 0 => write 1, move left, new state B
0C0 -> B01
1C0 -> B11
# state C, symbol 1 => write 1, move left, halt
0C1 -> H01
1C1 -> H11
`,
        `000000A000000`,
        `00011H1111000`,
    },
}",3869,176,"package main

import (
    ""fmt""
    ""regexp""
    ""strings""
    ""testing""
)

type testCase struct {
    ruleSet, sample, output string
}

func interpret(ruleset, input string) (string, bool) {
    if rules, ok := parse(ruleset); ok {
        return run(rules, input), true
    }
    return """", false
}

type rule struct {
    pat  string
    rep  string
    term bool
}

var (
    rxSet   = regexp.MustCompile(ruleSet)
    rxEle   = regexp.MustCompile(ruleEle)
    ruleSet = `(?m:^(?:` + ruleEle + `)*$)`
    ruleEle = `(?:` + comment + `|` + ruleRe + `)\n+`
    comment = `#.*`
    ruleRe  = `(.*)` + ws + `->` + ws + `([.])?(.*)`
    ws      = `[\t ]+`
)

func parse(rs string) ([]rule, bool) {
    if !rxSet.MatchString(rs) {
        return nil, false
    }
    x := rxEle.FindAllStringSubmatchIndex(rs, -1)
    var rules []rule
    for _, x := range x {
        if x[2] > 0 {
            rules = append(rules,
                rule{pat: rs[x[2]:x[3]], term: x[4] > 0, rep: rs[x[6]:x[7]]})
        }
    }
    return rules, true
}

func run(rules []rule, s string) string {
step1:
    for _, r := range rules {
        if f := strings.Index(s, r.pat); f >= 0 {
            s = s[:f] + r.rep + s[f+len(r.pat):]
            if r.term {
                return s
            }
            goto step1
        }
    }
    return s
}

var testSet = []testCase{
    {`# This rules file is extracted from Wikipedia:
# http://en.wikipedia.org/wiki/Markov_Algorithm
A -> apple
B -> bag
S -> shop
T -> the
the shop -> my brother
a never used -> .terminating rule
`,
        `I bought a B of As from T S.`,
        `I bought a bag of apples from my brother.`,
    },
    {`# Slightly modified from the rules on Wikipedia
A -> apple
B -> bag
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule
`,
        `I bought a B of As from T S.`,
        `I bought a bag of apples from T shop.`,
    },
    {`# BNF Syntax testing rules
A -> apple
WWWW -> with
Bgage -> ->.*
B -> bag
->.* -> money
W -> WW
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule
`,
        `I bought a B of As W my Bgage from T S.`,
        `I bought a bag of apples with my money from T shop.`,
    },
    {`### Unary Multiplication Engine, for testing Markov Algorithm implementations
### By Donal Fellows.
# Unary addition engine
_+1 -> _1+
1+1 -> 11+
# Pass for converting from the splitting of multiplication into ordinary
# addition
1! -> !1
,! -> !+
_! -> _
# Unary multiplication by duplicating left side, right side times
1*1 -> x,@y
1x -> xX
X, -> 1,1
X1 -> 1X
_x -> _X
,x -> ,X
y1 -> 1y
y_ -> _
# Next phase of applying
1@1 -> x,@y
1@_ -> @_
,@_ -> !_
++ -> +
# Termination cleanup for addition
_1 -> 1
1+_ -> 1
_+_ -> 
`,
        `_1111*11111_`,
        `11111111111111111111`,
    },
    {`# Turing machine: three-state busy beaver
#
# state A, symbol 0 => write 1, move right, new state B
A0 -> 1B
# state A, symbol 1 => write 1, move left, new state C
0A1 -> C01
1A1 -> C11
# state B, symbol 0 => write 1, move left, new state A
0B0 -> A01
1B0 -> A11
# state B, symbol 1 => write 1, move right, new state B
B1 -> 1B
# state C, symbol 0 => write 1, move left, new state B
0C0 -> B01
1C0 -> B11
# state C, symbol 1 => write 1, move left, halt
0C1 -> H01
1C1 -> H11
`,
        `000000A000000`,
        `00011H1111000`,
    },
}

func TestMarkovAlgorithm(t *testing.T) {
    for i, tc := range testSet {
        t.Run(fmt.Sprintf(""TestCase%d"", i+1), func(t *testing.T) {
            if r, ok := interpret(tc.ruleSet, tc.sample); !ok {
                t.Errorf(""Test %d: invalid ruleset"", i+1)
            } else if r != tc.output {
                t.Errorf(""Test %d: got %q, want %q"", i+1, r, tc.output)
            }
        })
    }
}
",./data/generated/docs_golang/execute_a_markov_algorithm/gpt_4o_2024_08_06_execute_a_markov_algorithm_test.go,CompileStatus.SYNTAX_ERROR,,,,0.04,0.13,,0.0,[],False,False,,False,"[{'file': './gpt_4o_2024_08_06_execute_a_markov_algorithm_test.go', 'line': 10, 'column': 6, 'message': 'testCase redeclared in this block'}]"
Execute a system command,"Task

Run either the   ls   system command   (dir   on Windows),   or the   pause   system command.




Related task
  Get system command output

",Go,"package main
 
import (
    ""log""
    ""os""
    ""os/exec""
)
 
func main() {
    cmd := exec.Command(""ls"", ""-l"")
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    if err := cmd.Run(); err != nil {
        log.Fatal(err)
    }
}",233,16,"package main

import (
    ""bytes""
    ""os/exec""
    ""testing""
)

func TestExecuteSystemCommand(t *testing.T) {
    // Test for 'ls' command
    cmd := exec.Command(""ls"", ""-l"")
    var out bytes.Buffer
    cmd.Stdout = &out
    cmd.Stderr = &out
    err := cmd.Run()
    if err != nil {
        t.Fatalf(""Expected no error, got %v"", err)
    }

    // Check if output is not empty
    if out.Len() == 0 {
        t.Error(""Expected output, got empty string"")
    }
}

func TestExecuteSystemCommandWindows(t *testing.T) {
    // Test for 'dir' command on Windows
    cmd := exec.Command(""cmd"", ""/C"", ""dir"")
    var out bytes.Buffer
    cmd.Stdout = &out
    cmd.Stderr = &out
    err := cmd.Run()
    if err != nil {
        t.Fatalf(""Expected no error, got %v"", err)
    }

    // Check if output is not empty
    if out.Len() == 0 {
        t.Error(""Expected output, got empty string"")
    }
}

func TestExecutePauseCommand(t *testing.T) {
    // Test for 'pause' command
    cmd := exec.Command(""cmd"", ""/C"", ""pause"")
    var out bytes.Buffer
    cmd.Stdout = &out
    cmd.Stderr = &out
    err := cmd.Run()
    if err != nil {
        t.Fatalf(""Expected no error, got %v"", err)
    }

    // Check if output contains 'Press any key to continue'
    if !bytes.Contains(out.Bytes(), []byte(""Press any key to continue"")) {
        t.Error(""Expected 'Press any key to continue' in output"")
    }
}
",./data/generated/docs_golang/execute_a_system_command/gpt_4o_2024_08_06_execute_a_system_command_test.go,CompileStatus.OK,0.0,0.0,,0.22,3.5,0.128,0.0,[],False,False,33.33,False,[]
Extend your language,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops

Some programming languages allow you to extend the language. While this can be done to a certain degree in most languages (e.g. by using macros), other languages go much further. Most notably in the Forth and Lisp families, programming per se is done by extending the language without any formal distinction between built-in and user-defined elements.

If your language supports it, show how to introduce a new flow control mechanism. A practical and useful example is a four-way branch:

Occasionally, code must be written that depends on two conditions, resulting in up to four branches (depending on whether both, only the first, only the second, or none of the conditions are ""true""). In a C-like language this could look like the following:

  if (condition1isTrue) {
     if (condition2isTrue)
        bothConditionsAreTrue();
     else
        firstConditionIsTrue();
  }
  else if (condition2isTrue)
     secondConditionIsTrue();
  else
     noConditionIsTrue();

Besides being rather cluttered, the statement(s) for 'condition2isTrue' must be written down twice. If 'condition2isTrue' were a lengthy and involved expression, it would be quite unreadable, and the code generated by the compiler might be unnecessarily large.

This can be improved by introducing a new keyword if2. It is similar to if, but takes two conditional statements instead of one, and up to three 'else' statements. One proposal (in pseudo-C syntax) might be:

  if2 (condition1isTrue) (condition2isTrue)
     bothConditionsAreTrue();
  else1
     firstConditionIsTrue();
  else2
     secondConditionIsTrue();
  else
     noConditionIsTrue();

Pick the syntax which suits your language. The keywords 'else1' and 'else2' are just examples. The new conditional expression should look, nest and behave analogously to the language's built-in 'if' statement.
",Go,"package main
 
import ""fmt""
 
type F func()
 
type If2 struct {cond1, cond2 bool}
 
func (i If2) else1(f F) If2 {
    if i.cond1 && !i.cond2 {
        f()
    }
    return i
}
 
func (i If2) else2(f F) If2 {
    if i.cond2 && !i.cond1 {
        f()
    }
    return i
}
 
func (i If2) else0(f F) If2 {
    if !i.cond1 && !i.cond2 {
        f()
    }
    return i
}
 
func if2(cond1, cond2 bool, f F) If2 {
    if cond1 && cond2 {
        f()
    }
    return If2{cond1, cond2}
}
 
func main() {
    a, b := 0, 1
    if2 (a == 1, b == 3, func() {
        fmt.Println(""a = 1 and b = 3"")
    }).else1 (func() {
        fmt.Println(""a = 1 and b <> 3"")
    }).else2 (func() {
        fmt.Println(""a <> 1 and b = 3"")
    }).else0 (func() {
        fmt.Println(""a <> 1 and b <> 3"")
    })
 
    // It's also possible to omit any (or all) of the 'else' clauses or to call them out of order
    a, b = 1, 0
    if2 (a == 1, b == 3, func() {
        fmt.Println(""a = 1 and b = 3"")
    }).else0 (func() {
        fmt.Println(""a <> 1 and b <> 3"")
    }).else1 (func() {
        fmt.Println(""a = 1 and b <> 3"")
    })
}",1106,58,"package main

import (
	""bytes""
	""fmt""
	""testing""
)

type F func()

type If2 struct {
	cond1, cond2 bool
}

func (i If2) else1(f F) If2 {
	if i.cond1 && !i.cond2 {
		f()
	}
	return i
}

func (i If2) else2(f F) If2 {
	if i.cond2 && !i.cond1 {
		f()
	}
	return i
}

func (i If2) else0(f F) If2 {
	if !i.cond1 && !i.cond2 {
		f()
	}
	return i
}

func if2(cond1, cond2 bool, f F) If2 {
	if cond1 && cond2 {
		f()
	}
	return If2{cond1, cond2}
}

func TestIf2(t *testing.T) {
	tests := []struct {
		cond1, cond2 bool
		expected     string
	}{
		{true, true, ""both conditions are true\n""},
		{true, false, ""first condition is true\n""},
		{false, true, ""second condition is true\n""},
		{false, false, ""no condition is true\n""},
	}

	for _, test := range tests {
		var buf bytes.Buffer
		fmtFunc := func(msg string) F {
			return func() {
				fmt.Fprintln(&buf, msg)
			}
		}

		if2(test.cond1, test.cond2, fmtFunc(""both conditions are true"")).
			else1(fmtFunc(""first condition is true"")).
			else2(fmtFunc(""second condition is true"")).
			else0(fmtFunc(""no condition is true""))

		if buf.String() != test.expected {
			t.Errorf(""for cond1=%v, cond2=%v, expected %q, got %q"", test.cond1, test.cond2, test.expected, buf.String())
		}
	}
}

func TestIf2OmittedElseClauses(t *testing.T) {
	var buf bytes.Buffer
	fmtFunc := func(msg string) F {
		return func() {
			fmt.Fprintln(&buf, msg)
		}
	}

	// Test with omitted else2 and else0
	if2(true, false, fmtFunc(""both conditions are true"")).
		else1(fmtFunc(""first condition is true""))

	expected := ""first condition is true\n""
	if buf.String() != expected {
		t.Errorf(""expected %q, got %q"", expected, buf.String())
	}
}

func TestIf2OutOfOrderElseClauses(t *testing.T) {
	var buf bytes.Buffer
	fmtFunc := func(msg string) F {
		return func() {
			fmt.Fprintln(&buf, msg)
		}
	}

	// Test with out of order else clauses
	if2(false, false, fmtFunc(""both conditions are true"")).
		else0(fmtFunc(""no condition is true"")).
		else1(fmtFunc(""first condition is true""))

	expected := ""no condition is true\n""
	if buf.String() != expected {
		t.Errorf(""expected %q, got %q"", expected, buf.String())
	}
}
",./data/generated/docs_golang/extend_your_language/gpt_4o_2024_08_06_extend_your_language_test.go,CompileStatus.SYNTAX_ERROR,,,,0.05,0.15,,0.0,[],False,False,,False,"[{'file': './gpt_4o_2024_08_06_extend_your_language_test.go', 'line': 9, 'column': 6, 'message': 'F redeclared in this block'}]"
Extensible prime generator,"Task

Write a generator of prime numbers, in order, that will automatically adjust to accommodate the generation of any reasonably high prime.

The routine should demonstrably rely on either:

 Being based on an open-ended counter set to count without upper limit other than system or programming language limits. In this case, explain where this counter is in the code.
 Being based on a limit that is extended automatically. In this case, choose a small limit that ensures the limit will be passed when generating some of the values to be asked for below.
 If other methods of creating an extensible prime generator are used, the algorithm's means of extensibility/lack of limits should be stated.


The routine should be used to:

 Show the first twenty primes.
 Show the primes between 100 and 150.
 Show the number of primes between 7,700 and 8,000.
 Show the 10,000th prime.


Show output on this page.

Note: You may reference code already on this site if it is written to be imported/included, then only the code necessary for import and the performance of this task need be shown. (It is also important to leave a forward link on the referenced tasks entry so that later editors know that the code is used for multiple tasks).

Note 2: If a languages in-built prime generator is extensible or is guaranteed to generate primes up to a system limit, (231 or memory overflow for example), then this may be used as long as an explanation of the limits of the prime generator is also given. (Which may include a link to/excerpt from, language documentation).

Note 3:The task is written so it may be useful in solving the task   Emirp primes   as well as others (depending on its efficiency).





Reference

 Prime Numbers. Website with large count of primes.

",Go,"package main
 
import (
    ""container/heap""
    ""fmt""
)
 
func main() {
    p := newP()
    fmt.Print(""First twenty: "")
    for i := 0; i < 20; i++ {
        fmt.Print(p(), "" "")
    }
    fmt.Print(""\nBetween 100 and 150: "")
    n := p()
    for n <= 100 {
        n = p()
    }
    for ; n < 150; n = p() {
        fmt.Print(n, "" "")
    }
    for n <= 7700 {
        n = p()
    }
    c := 0
    for ; n < 8000; n = p() {
        c++
    }
    fmt.Println(""\nNumber beween 7,700 and 8,000:"", c)
    p = newP()
    for i := 1; i < 10000; i++ {
        p()
    }
    fmt.Println(""10,000th prime:"", p())
}
 
func newP() func() int {
    n := 1
    var pq pQueue
    top := &pMult{2, 4, 0}
    return func() int {
        for {
            n++
            if n < top.pMult { // n is a new prime
                heap.Push(&pq, &pMult{prime: n, pMult: n * n})
                top = pq[0]
                return n
            }
            // n was next on the queue, it's a composite
            for top.pMult == n {
                top.pMult += top.prime
                heap.Fix(&pq, 0)
                top = pq[0]
            }
        }
    }
}
 
type pMult struct {
    prime int
    pMult int
    index int
}
 
type pQueue []*pMult
 
func (q pQueue) Len() int           { return len(q) }
func (q pQueue) Less(i, j int) bool { return q[i].pMult < q[j].pMult }
func (q pQueue) Swap(i, j int) {
    q[i], q[j] = q[j], q[i]
    q[i].index = i
    q[j].index = j
}
func (p *pQueue) Push(x interface{}) {
    q := *p
    e := x.(*pMult)
    e.index = len(q)
    *p = append(q, e)
}
func (p *pQueue) Pop() interface{} {
    q := *p
    last := len(q) - 1
    e := q[last]
    *p = q[:last]
    return e
}",1699,86,"package main

import (
	""testing""
)

func TestFirstTwentyPrimes(t *testing.T) {
	expected := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71}
	p := newP()
	for i, exp := range expected {
		if prime := p(); prime != exp {
			t.Errorf(""Expected %d, got %d at index %d"", exp, prime, i)
		}
	}
}

func TestPrimesBetween100And150(t *testing.T) {
	expected := []int{101, 103, 107, 109, 113, 127, 131, 137, 139, 149}
	p := newP()
	var primes []int
	for n := p(); n < 150; n = p() {
		if n > 100 {
			primes = append(primes, n)
		}
	}
	if len(primes) != len(expected) {
		t.Fatalf(""Expected %d primes, got %d"", len(expected), len(primes))
	}
	for i, exp := range expected {
		if primes[i] != exp {
			t.Errorf(""Expected %d, got %d at index %d"", exp, primes[i], i)
		}
	}
}

func TestNumberOfPrimesBetween7700And8000(t *testing.T) {
	expectedCount := 19
	p := newP()
	for n := p(); n <= 7700; n = p() {
	}
	count := 0
	for n := p(); n < 8000; n = p() {
		count++
	}
	if count != expectedCount {
		t.Errorf(""Expected %d primes, got %d"", expectedCount, count)
	}
}

func Test10000thPrime(t *testing.T) {
	expected := 104729
	p := newP()
	var prime int
	for i := 0; i < 10000; i++ {
		prime = p()
	}
	if prime != expected {
		t.Errorf(""Expected 10,000th prime to be %d, got %d"", expected, prime)
	}
}
",./data/generated/docs_golang/extensible_prime_generator/gpt_4o_2024_08_06_extensible_prime_generator_test.go,CompileStatus.OK,0.0,47.9,,0.14,0.29,0.26,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: newP', 'Severity': '', 'SourceLines': ['\tp := newP()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_extensible_prime_generator_test.go', 'Offset': 0, 'Line': 9, 'Column': 7}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: newP', 'Severity': '', 'SourceLines': ['\tp := newP()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_extensible_prime_generator_test.go', 'Offset': 0, 'Line': 19, 'Column': 7}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: newP', 'Severity': '', 'SourceLines': ['\tp := newP()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_extensible_prime_generator_test.go', 'Offset': 0, 'Line': 38, 'Column': 7}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,75.0,False,[]
FASTA format,"In bioinformatics, long character strings are often encoded in a format called FASTA.

A FASTA file can contain several strings, each identified by a name marked by a > (greater than) character at the beginning of the line.



Task

Write a program that reads a FASTA file such as:

>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED


Output:
Rosetta_Example_1: THERECANBENOSPACE
Rosetta_Example_2: THERECANBESEVERALLINESBUTTHEYALLMUSTBECONCATENATED

Note that a high-quality implementation will not hold the entire file in memory at once; real FASTA files can be multiple gigabytes in size.



",Go,"package main
 
import (
        ""bufio""
        ""fmt""
        ""os""
)
 
func main() {
        f, err := os.Open(""rc.fasta"")
        if err != nil {
                fmt.Println(err)
                return
        }
        defer f.Close()
        s := bufio.NewScanner(f)
        headerFound := false
        for s.Scan() {
                line := s.Text()
                switch {
                case line == """":
                        continue
                case line[0] != '>':
                        if !headerFound {
                                fmt.Println(""missing header"")
                                return
                        }
                        fmt.Print(line)
                case headerFound:
                        fmt.Println()
                        fallthrough
                default:
                        fmt.Printf(""%s: "", line[1:])
                        headerFound = true
                }
        }
        if headerFound {
                fmt.Println()
        }
        if err := s.Err(); err != nil {
                fmt.Println(err)
        }
}",1098,43,"package main

import (
	""bytes""
	""os""
	""strings""
	""testing""
)

func TestFastaParsing(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name: ""Single line sequence"",
			input: `>Rosetta_Example_1
THERECANBENOSPACE
`,
			expected: ""Rosetta_Example_1: THERECANBENOSPACE\n"",
		},
		{
			name: ""Multi-line sequence"",
			input: `>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED
`,
			expected: ""Rosetta_Example_2: THERECANBESEVERALLINESBUTTHEYALLMUSTBECONCATENATED\n"",
		},
		{
			name: ""Multiple sequences"",
			input: `>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED
`,
			expected: ""Rosetta_Example_1: THERECANBENOSPACE\nRosetta_Example_2: THERECANBESEVERALLINESBUTTHEYALLMUSTBECONCATENATED\n"",
		},
		{
			name: ""Missing header"",
			input: `THERECANBENOSPACE
`,
			expected: ""missing header\n"",
		},
		{
			name: ""Empty file"",
			input: ``,
			expected: ``,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a temporary file with the test input
			tmpfile, err := os.CreateTemp("""", ""testfasta"")
			if err != nil {
				t.Fatal(err)
			}
			defer os.Remove(tmpfile.Name()) // clean up

			if _, err := tmpfile.WriteString(tt.input); err != nil {
				t.Fatal(err)
			}
			if err := tmpfile.Close(); err != nil {
				t.Fatal(err)
			}

			// Redirect stdout
			var buf bytes.Buffer
			stdout := os.Stdout
			os.Stdout = &buf
			defer func() { os.Stdout = stdout }()

			// Run the main function
			os.Args = []string{""cmd"", tmpfile.Name()}
			main()

			// Check the output
			if got := buf.String(); got != tt.expected {
				t.Errorf(""expected %q, got %q"", tt.expected, got)
			}
		})
	}
}
",./data/generated/docs_golang/fasta_format/gpt_4o_2024_08_06_fasta_format_test.go,CompileStatus.SYNTAX_ERROR,,,,0.1,0.44,,3.0,"[{'FromLinter': 'typecheck', 'Text': 'cannot use &buf (value of type *bytes.Buffer) as *os.File value in assignment', 'Severity': '', 'SourceLines': ['\t\t\tos.Stdout = &buf'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fasta_format_test.go', 'Offset': 0, 'Line': 75, 'Column': 16}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\t\t\tmain()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fasta_format_test.go', 'Offset': 0, 'Line': 80, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""strings"" imported and not used', 'Severity': '', 'SourceLines': ['\t""strings""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fasta_format_test.go', 'Offset': 0, 'Line': 6, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_fasta_format_test.go', 'line': 75, 'column': 16, 'message': 'cannot use &buf (value of type *bytes.Buffer) as *os.File value in assignment'}]"
Factorial,"Definitions

   The factorial of   0   (zero)   is defined as being   1   (unity).
   The   Factorial Function   of a positive integer,    n,    is defined as the product of the sequence:
                 n,   n-1,   n-2,   ...   1 



Task

Write a function to return the factorial of a number.

Solutions can be iterative or recursive.

Support for trapping negative    n    errors is optional.



Related task

   Primorial numbers

",Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    fmt.Println(factorial(800))
}
 
func factorial(n int64) *big.Int {
    if n < 0 {
        return nil
    }
    r := big.NewInt(1)
    var f big.Int
    for i := int64(2); i <= n; i++ {
        r.Mul(r, f.SetInt64(i))
    }
    return r
}",308,22,"package main

import (
    ""math/big""
    ""testing""
)

func TestFactorial(t *testing.T) {
    tests := []struct {
        input    int64
        expected *big.Int
    }{
        {0, big.NewInt(1)}, // Factorial of 0 is 1
        {1, big.NewInt(1)}, // Factorial of 1 is 1
        {2, big.NewInt(2)}, // Factorial of 2 is 2
        {3, big.NewInt(6)}, // Factorial of 3 is 6
        {4, big.NewInt(24)}, // Factorial of 4 is 24
        {5, big.NewInt(120)}, // Factorial of 5 is 120
        {10, big.NewInt(3628800)}, // Factorial of 10 is 3628800
        {20, big.NewInt(2432902008176640000)}, // Factorial of 20 is 2432902008176640000
        {-1, nil}, // Factorial of negative number should return nil
    }

    for _, test := range tests {
        result := factorial(test.input)
        if result == nil && test.expected == nil {
            continue
        }
        if result == nil || test.expected == nil || result.Cmp(test.expected) != 0 {
            t.Errorf(""factorial(%d) = %v; want %v"", test.input, result, test.expected)
        }
    }
}
",./data/generated/docs_golang/factorial/gpt_4o_2024_08_06_factorial_test.go,CompileStatus.OK,0.0,87.5,,0.05,0.25,0.122,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: factorial', 'Severity': '', 'SourceLines': ['        result := factorial(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_factorial_test.go', 'Offset': 0, 'Line': 25, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Fairshare between two and more,"The Thue-Morse sequence is a sequence of ones and zeros that if two people
take turns in the given order, the first persons turn for every '0' in the
sequence, the second for every '1'; then this is shown to give a fairer, more
equitable sharing of resources. (Football penalty shoot-outs for example, might
not favour the team that goes first as much if the penalty takers take turns
according to the Thue-Morse sequence and took 2^n penalties)

The Thue-Morse sequence of ones-and-zeroes can be generated by:

""When counting in binary, the digit sum modulo 2 is the Thue-Morse sequence""


Sharing fairly between two or more

Use this method:

When counting base b, the digit sum modulo b is the Thue-Morse sequence of fairer sharing between b people.


Task
Counting from zero;   using a function/method/routine to express an integer count in base b,

sum the digits modulo b to produce the next member of the Thue-Morse fairshare series for b people.



Show the first 25 terms of the fairshare sequence:

   For two people:
   For three people
   For five people
   For eleven people


Related tasks

   Non-decimal radices/Convert
   Thue-Morse


See also

   A010060, A053838, A053840: The On-Line Encyclopedia of Integer Sequences® (OEIS®)

",Go,"package main
 
import (
    ""fmt""
    ""sort""
    ""strconv""
    ""strings""
)
 
func fairshare(n, base int) []int {
    res := make([]int, n)
    for i := 0; i < n; i++ {
        j := i
        sum := 0
        for j > 0 {
            sum += j % base
            j /= base
        }
        res[i] = sum % base
    }
    return res
}
 
func turns(n int, fss []int) string {
    m := make(map[int]int)
    for _, fs := range fss {
        m[fs]++
    }
    m2 := make(map[int]int)
    for _, v := range m {
        m2[v]++
    }
    res := []int{}
    sum := 0
    for k, v := range m2 {
        sum += v
        res = append(res, k)
    }
    if sum != n {
        return fmt.Sprintf(""only %d have a turn"", sum)
    }
    sort.Ints(res)
    res2 := make([]string, len(res))
    for i := range res {
        res2[i] = strconv.Itoa(res[i])
    }
    return strings.Join(res2, "" or "")
}
 
func main() {
    for _, base := range []int{2, 3, 5, 11} {
        fmt.Printf(""%2d : %2d\n"", base, fairshare(25, base))
    }
    fmt.Println(""\nHow many times does each get a turn in 50000 iterations?"")
    for _, base := range []int{191, 1377, 49999, 50000, 50001} {
        t := turns(base, fairshare(50000, base))
        fmt.Printf(""  With %d people: %s\n"", base, t)
    }
}",1263,59,"package main

import (
	""testing""
	""reflect""
)

// TestFairshare tests the fairshare function for different bases.
func TestFairshare(t *testing.T) {
	tests := []struct {
		n    int
		base int
		want []int
	}{
		{
			n:    25,
			base: 2,
			want: []int{0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1},
		},
		{
			n:    25,
			base: 3,
			want: []int{0, 1, 2, 1, 2, 0, 2, 0, 1, 1, 2, 0, 2, 0, 1, 2, 0, 1, 1, 2, 0, 2, 0, 1, 2},
		},
		{
			n:    25,
			base: 5,
			want: []int{0, 1, 2, 3, 4, 1, 2, 3, 4, 0, 2, 3, 4, 0, 1, 3, 4, 0, 1, 2, 4, 0, 1, 2, 3},
		},
		{
			n:    25,
			base: 11,
			want: []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 2, 3, 4},
		},
	}

	for _, tt := range tests {
		t.Run("""", func(t *testing.T) {
			got := fairshare(tt.n, tt.base)
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf(""fairshare(%d, %d) = %v, want %v"", tt.n, tt.base, got, tt.want)
			}
		})
	}
}

// TestTurns tests the turns function for different scenarios.
func TestTurns(t *testing.T) {
	tests := []struct {
		n    int
		base int
		want string
	}{
		{
			n:    50000,
			base: 191,
			want: ""only 191 have a turn"",
		},
		{
			n:    50000,
			base: 1377,
			want: ""only 1377 have a turn"",
		},
		{
			n:    50000,
			base: 49999,
			want: ""only 49999 have a turn"",
		},
		{
			n:    50000,
			base: 50000,
			want: ""only 50000 have a turn"",
		},
		{
			n:    50000,
			base: 50001,
			want: ""only 50000 have a turn"",
		},
	}

	for _, tt := range tests {
		t.Run("""", func(t *testing.T) {
			fss := fairshare(tt.n, tt.base)
			got := turns(tt.base, fss)
			if got != tt.want {
				t.Errorf(""turns(%d, fairshare(%d, %d)) = %v, want %v"", tt.base, tt.n, tt.base, got, tt.want)
			}
		})
	}
}
",./data/generated/docs_golang/fairshare_between_two_and_more/gpt_4o_2024_08_06_fairshare_between_two_and_more_test.go,CompileStatus.OK,0.0,81.8,,0.04,0.17,0.307,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: fairshare', 'Severity': '', 'SourceLines': ['\t\t\tgot := fairshare(tt.n, tt.base)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fairshare_between_two_and_more_test.go', 'Offset': 0, 'Line': 39, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fairshare', 'Severity': '', 'SourceLines': ['\t\t\tfss := fairshare(tt.n, tt.base)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fairshare_between_two_and_more_test.go', 'Offset': 0, 'Line': 83, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: turns', 'Severity': '', 'SourceLines': ['\t\t\tgot := turns(tt.base, fss)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fairshare_between_two_and_more_test.go', 'Offset': 0, 'Line': 84, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,27.27,False,[]
Farey sequence,"The   Farey sequence    Fn   of order   n   is the sequence of completely reduced fractions between   0   and   1   which, when in lowest terms, have denominators less than or equal to   n,   arranged in order of increasing size.

The   Farey sequence   is sometimes incorrectly called a   Farey series.



Each Farey sequence:

   starts with the value   0   (zero),   denoted by the fraction     





0
1




{\displaystyle {\frac {0}{1}}}


   ends with the value   1   (unity),   denoted by the fraction   





1
1




{\displaystyle {\frac {1}{1}}}

.


The Farey sequences of orders   1   to   5   are:

 







F




1


=


0
1


,


1
1




{\displaystyle {\bf {\it {F}}}_{1}={\frac {0}{1}},{\frac {1}{1}}}



 







F




2


=


0
1


,


1
2


,


1
1




{\displaystyle {\bf {\it {F}}}_{2}={\frac {0}{1}},{\frac {1}{2}},{\frac {1}{1}}}



 







F




3


=


0
1


,


1
3


,


1
2


,


2
3


,


1
1




{\displaystyle {\bf {\it {F}}}_{3}={\frac {0}{1}},{\frac {1}{3}},{\frac {1}{2}},{\frac {2}{3}},{\frac {1}{1}}}



 







F




4


=


0
1


,


1
4


,


1
3


,


1
2


,


2
3


,


3
4


,


1
1




{\displaystyle {\bf {\it {F}}}_{4}={\frac {0}{1}},{\frac {1}{4}},{\frac {1}{3}},{\frac {1}{2}},{\frac {2}{3}},{\frac {3}{4}},{\frac {1}{1}}}



 







F




5


=


0
1


,


1
5


,


1
4


,


1
3


,


2
5


,


1
2


,


3
5


,


2
3


,


3
4


,


4
5


,


1
1




{\displaystyle {\bf {\it {F}}}_{5}={\frac {0}{1}},{\frac {1}{5}},{\frac {1}{4}},{\frac {1}{3}},{\frac {2}{5}},{\frac {1}{2}},{\frac {3}{5}},{\frac {2}{3}},{\frac {3}{4}},{\frac {4}{5}},{\frac {1}{1}}}


Task
   Compute and show the Farey sequence for orders   1   through   11   (inclusive).
   Compute and display the   number   of fractions in the Farey sequence for order   100   through   1,000   (inclusive)   by hundreds.
   Show the fractions as    n/d    (using the solidus [or slash] to separate the numerator from the denominator). 


The length   (the number of fractions)   of a Farey sequence asymptotically approaches:

  3 × n2   ÷   



π


{\displaystyle \pi }

2 
See also

   OEIS sequence   A006842 numerators of Farey series of order 1, 2, ··· 
   OEIS sequence   A006843 denominators of Farey series of order 1, 2, ··· 
   OEIS sequence   A005728 number of fractions in Farey series of order n 
   MathWorld entry   Farey sequence
   Wikipedia   entry   Farey sequence

",Go,"package main
 
import ""fmt""
 
type frac struct{ num, den int }
 
func (f frac) String() string {
    return fmt.Sprintf(""%d/%d"", f.num, f.den)
}
 
func f(l, r frac, n int) {
    m := frac{l.num + r.num, l.den + r.den}
    if m.den <= n {
        f(l, m, n)
        fmt.Print(m, "" "")
        f(m, r, n)
    }
}
 
func main() {
    // task 1.  solution by recursive generation of mediants
    for n := 1; n <= 11; n++ {
        l := frac{0, 1}
        r := frac{1, 1}
        fmt.Printf(""F(%d): %s "", n, l)
        f(l, r, n)
        fmt.Println(r)
    }
    // task 2.  direct solution by summing totient function
    // 2.1 generate primes to 1000
    var composite [1001]bool
    for _, p := range []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31} {
        for n := p * 2; n <= 1000; n += p {
            composite[n] = true
        }
    }
    // 2.2 generate totients to 1000
    var tot [1001]int
    for i := range tot {
        tot[i] = 1
    }
    for n := 2; n <= 1000; n++ {
        if !composite[n] {
            tot[n] = n - 1
            for a := n * 2; a <= 1000; a += n {
                f := n - 1
                for r := a / n; r%n == 0; r /= n {
                    f *= n
                }
                tot[a] *= f
            }
        }
    }
    // 2.3 sum totients
    for n, sum := 1, 1; n <= 1000; n++ {
        sum += tot[n]
        if n%100 == 0 {
            fmt.Printf(""|F(%d)|: %d\n"", n, sum)
        }
    }
}",1440,61,"package main

import (
	""fmt""
	""testing""
)

type frac struct{ num, den int }

func (f frac) String() string {
	return fmt.Sprintf(""%d/%d"", f.num, f.den)
}

func f(l, r frac, n int, result *[]frac) {
	m := frac{l.num + r.num, l.den + r.den}
	if m.den <= n {
		f(l, m, n, result)
		*result = append(*result, m)
		f(m, r, n, result)
	}
}

func fareySequence(n int) []frac {
	l := frac{0, 1}
	r := frac{1, 1}
	result := []frac{l}
	f(l, r, n, &result)
	result = append(result, r)
	return result
}

func TestFareySequence(t *testing.T) {
	tests := []struct {
		order   int
		sequence []string
	}{
		{1, []string{""0/1"", ""1/1""}},
		{2, []string{""0/1"", ""1/2"", ""1/1""}},
		{3, []string{""0/1"", ""1/3"", ""1/2"", ""2/3"", ""1/1""}},
		{4, []string{""0/1"", ""1/4"", ""1/3"", ""1/2"", ""2/3"", ""3/4"", ""1/1""}},
		{5, []string{""0/1"", ""1/5"", ""1/4"", ""1/3"", ""2/5"", ""1/2"", ""3/5"", ""2/3"", ""3/4"", ""4/5"", ""1/1""}},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""Order %d"", test.order), func(t *testing.T) {
			result := fareySequence(test.order)
			var resultStrings []string
			for _, frac := range result {
				resultStrings = append(resultStrings, frac.String())
			}
			if len(resultStrings) != len(test.sequence) {
				t.Errorf(""Expected length %d, got %d"", len(test.sequence), len(resultStrings))
			}
			for i, v := range resultStrings {
				if v != test.sequence[i] {
					t.Errorf(""Expected %s, got %s"", test.sequence[i], v)
				}
			}
		})
	}
}

func numberOfFractions(n int) int {
	var composite [1001]bool
	for _, p := range []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31} {
		for i := p * 2; i <= 1000; i += p {
			composite[i] = true
		}
	}
	var tot [1001]int
	for i := range tot {
		tot[i] = 1
	}
	for i := 2; i <= 1000; i++ {
		if !composite[i] {
			tot[i] = i - 1
			for a := i * 2; a <= 1000; a += i {
				f := i - 1
				for r := a / i; r%i == 0; r /= i {
					f *= i
				}
				tot[a] *= f
			}
		}
	}
	sum := 1
	for i := 1; i <= n; i++ {
		sum += tot[i]
	}
	return sum
}

func TestNumberOfFractions(t *testing.T) {
	tests := []struct {
		order int
		count int
	}{
		{100, 3043},
		{200, 12231},
		{300, 27413},
		{400, 48079},
		{500, 74139},
		{600, 105993},
		{700, 143841},
		{800, 187683},
		{900, 237519},
		{1000, 293349},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf(""Order %d"", test.order), func(t *testing.T) {
			result := numberOfFractions(test.order)
			if result != test.count {
				t.Errorf(""Expected %d, got %d"", test.count, result)
			}
		})
	}
}
",./data/generated/docs_golang/farey_sequence/gpt_4o_2024_08_06_farey_sequence_test.go,CompileStatus.SYNTAX_ERROR,,,,0.04,0.21,,0.0,[],False,False,,False,"[{'file': './gpt_4o_2024_08_06_farey_sequence_test.go', 'line': 8, 'column': 6, 'message': 'frac redeclared in this block'}]"
Fast Fourier transform,"Task

Calculate the   FFT   (Fast Fourier Transform)   of an input sequence.

The most general case allows for complex numbers at the input
and results in a sequence of equal length, again of complex numbers.
If you need to restrict yourself to real numbers, the output should
be the magnitude   (i.e.:   sqrt(re2 + im2))   of the complex result.

The classic version is the recursive Cooley–Tukey FFT. Wikipedia has pseudo-code for that.
Further optimizations are possible but not required.



",Go,"package main
 
import (
    ""fmt""
    ""math""
    ""math/cmplx""
)
 
func ditfft2(x []float64, y []complex128, n, s int) {
    if n == 1 {
        y[0] = complex(x[0], 0)
        return
    }
    ditfft2(x, y, n/2, 2*s)
    ditfft2(x[s:], y[n/2:], n/2, 2*s)
    for k := 0; k < n/2; k++ {
        tf := cmplx.Rect(1, -2*math.Pi*float64(k)/float64(n)) * y[k+n/2]
        y[k], y[k+n/2] = y[k]+tf, y[k]-tf
    }
}
 
func main() {
    x := []float64{1, 1, 1, 1, 0, 0, 0, 0}
    y := make([]complex128, len(x))
    ditfft2(x, y, len(x), 1)
    for _, c := range y {
        fmt.Printf(""%8.4f\n"", c)
    }
}",599,29,"package main

import (
	""math""
	""math/cmplx""
	""testing""
)

// Helper function to calculate the magnitude of a complex number
func magnitude(c complex128) float64 {
	return math.Sqrt(real(c)*real(c) + imag(c)*imag(c))
}

// Test for the FFT function with real input and complex output
func TestFFTComplexOutput(t *testing.T) {
	x := []float64{1, 1, 1, 1, 0, 0, 0, 0}
	expected := []complex128{
		complex(4, 0),
		complex(1, -2.4142),
		complex(0, 0),
		complex(1, -0.4142),
		complex(0, 0),
		complex(1, 0.4142),
		complex(0, 0),
		complex(1, 2.4142),
	}

	y := make([]complex128, len(x))
	ditfft2(x, y, len(x), 1)

	for i, v := range y {
		if cmplx.Abs(v-expected[i]) > 0.0001 {
			t.Errorf(""Expected %v, but got %v at index %d"", expected[i], v, i)
		}
	}
}

// Test for the FFT function with real input and magnitude output
func TestFFTMagnitudeOutput(t *testing.T) {
	x := []float64{1, 1, 1, 1, 0, 0, 0, 0}
	expectedMagnitudes := []float64{4, 2.6131, 0, 1.0824, 0, 1.0824, 0, 2.6131}

	y := make([]complex128, len(x))
	ditfft2(x, y, len(x), 1)

	for i, v := range y {
		mag := magnitude(v)
		if math.Abs(mag-expectedMagnitudes[i]) > 0.0001 {
			t.Errorf(""Expected magnitude %v, but got %v at index %d"", expectedMagnitudes[i], mag, i)
		}
	}
}

// Test for the FFT function with a single element
func TestFFTSingleElement(t *testing.T) {
	x := []float64{5}
	expected := []complex128{complex(5, 0)}

	y := make([]complex128, len(x))
	ditfft2(x, y, len(x), 1)

	for i, v := range y {
		if cmplx.Abs(v-expected[i]) > 0.0001 {
			t.Errorf(""Expected %v, but got %v at index %d"", expected[i], v, i)
		}
	}
}

// Test for the FFT function with zero input
func TestFFTZeroInput(t *testing.T) {
	x := []float64{0, 0, 0, 0}
	expected := []complex128{complex(0, 0), complex(0, 0), complex(0, 0), complex(0, 0)}

	y := make([]complex128, len(x))
	ditfft2(x, y, len(x), 1)

	for i, v := range y {
		if cmplx.Abs(v-expected[i]) > 0.0001 {
			t.Errorf(""Expected %v, but got %v at index %d"", expected[i], v, i)
		}
	}
}
",./data/generated/docs_golang/fast_fourier_transform/gpt_4o_2024_08_06_fast_fourier_transform_test.go,CompileStatus.OK,0.0,61.5,,0.09,0.8,0.12,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: ditfft2', 'Severity': '', 'SourceLines': ['\tditfft2(x, y, len(x), 1)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fast_fourier_transform_test.go', 'Offset': 0, 'Line': 29, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: ditfft2', 'Severity': '', 'SourceLines': ['\tditfft2(x, y, len(x), 1)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fast_fourier_transform_test.go', 'Offset': 0, 'Line': 44, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: ditfft2', 'Severity': '', 'SourceLines': ['\tditfft2(x, y, len(x), 1)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fast_fourier_transform_test.go', 'Offset': 0, 'Line': 60, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Faulhaber's formula,"In mathematics,   Faulhaber's formula,   named after Johann Faulhaber,   expresses the sum of the p-th powers of the first n positive integers as a (p + 1)th-degree polynomial function of n,   the coefficients involving Bernoulli numbers.



Task

Generate the first 10 closed-form expressions, starting with p = 0.



Related tasks

   Bernoulli numbers.
   evaluate binomial coefficients.


See also

   The Wikipedia entry:   Faulhaber's formula.
   The Wikipedia entry:   Bernoulli numbers.
   The Wikipedia entry:   binomial coefficients.

",Go,"package main
 
import (
	""fmt""
	""math/big""
)
 
func bernoulli(z *big.Rat, n int64) *big.Rat {
	if z == nil {
		z = new(big.Rat)
	}
	a := make([]big.Rat, n+1)
	for m := range a {
		a[m].SetFrac64(1, int64(m+1))
		for j := m; j >= 1; j-- {
			d := &a[j-1]
			d.Mul(z.SetInt64(int64(j)), d.Sub(d, &a[j]))
		}
	}
	return z.Set(&a[0])
}
 
func main() {
	// allocate needed big.Rat's once
	q := new(big.Rat)
	c := new(big.Rat)      // coefficients
	be := new(big.Rat)     // for Bernoulli numbers
	bi := big.NewRat(1, 1) // for binomials
 
	for p := int64(0); p < 10; p++ {
		fmt.Print(p, "" : "")
		q.SetFrac64(1, p+1)
		neg := true
		for j := int64(0); j <= p; j++ {
			neg = !neg
			if neg {
				c.Neg(q)
			} else {
				c.Set(q)
			}
			bi.Num().Binomial(p+1, j)
			bernoulli(be, j)
			c.Mul(c, bi)
			c.Mul(c, be)
			if c.Num().BitLen() == 0 {
				continue
			}
			if j == 0 {
				fmt.Printf("" %4s"", c.RatString())
			} else {
				fmt.Printf("" %+2d/%-2d"", c.Num(), c.Denom())
			}
			fmt.Print(""×n"")
			if exp := p + 1 - j; exp > 1 {
				fmt.Printf(""^%-2d"", exp)
			}
		}
		fmt.Println()
	}
}",1089,60,"package main

import (
	""math/big""
	""testing""
)

// TestBernoulli tests the bernoulli function for known values.
func TestBernoulli(t *testing.T) {
	tests := []struct {
		n        int64
		expected string
	}{
		{0, ""1/1""},
		{1, ""0/1""},
		{2, ""1/6""},
		{3, ""0/1""},
		{4, ""-1/30""},
		{5, ""0/1""},
		{6, ""1/42""},
		{7, ""0/1""},
		{8, ""-1/30""},
		{9, ""0/1""},
		{10, ""5/66""},
	}

	for _, test := range tests {
		result := bernoulli(nil, test.n)
		if result.RatString() != test.expected {
			t.Errorf(""bernoulli(%d) = %s; expected %s"", test.n, result.RatString(), test.expected)
		}
	}
}

// TestFaulhabersFormula tests the main logic of generating closed-form expressions.
func TestFaulhabersFormula(t *testing.T) {
	// Expected results for p = 0 to 9
	expectedResults := []string{
		""0 :  1/1×n"",
		""1 :  1/2×n^2 +1/2×n"",
		""2 :  1/3×n^3 +1/2×n^2 +1/6×n"",
		""3 :  1/4×n^4 +1/2×n^3 +1/4×n^2"",
		""4 :  1/5×n^5 +1/2×n^4 +1/3×n^3 −1/30×n"",
		""5 :  1/6×n^6 +1/2×n^5 +5/12×n^4 −1/12×n^2"",
		""6 :  1/7×n^7 +1/2×n^6 +1/2×n^5 −1/6×n^3 +1/42×n"",
		""7 :  1/8×n^8 +1/2×n^7 +7/12×n^6 −7/24×n^4 +1/12×n^2"",
		""8 :  1/9×n^9 +1/2×n^8 +2/3×n^7 −7/15×n^5 +2/15×n^3 −1/30×n"",
		""9 :  1/10×n^10 +1/2×n^9 +3/4×n^8 −7/10×n^6 +1/2×n^4 −3/20×n^2"",
	}

	// Simulate the main logic
	q := new(big.Rat)
	c := new(big.Rat)
	be := new(big.Rat)
	bi := big.NewRat(1, 1)

	for p := int64(0); p < 10; p++ {
		result := """"
		result += fmt.Sprintf(""%d : "", p)
		q.SetFrac64(1, p+1)
		neg := true
		for j := int64(0); j <= p; j++ {
			neg = !neg
			if neg {
				c.Neg(q)
			} else {
				c.Set(q)
			}
			bi.Num().Binomial(p+1, j)
			bernoulli(be, j)
			c.Mul(c, bi)
			c.Mul(c, be)
			if c.Num().BitLen() == 0 {
				continue
			}
			if j == 0 {
				result += fmt.Sprintf("" %4s"", c.RatString())
			} else {
				result += fmt.Sprintf("" %+2d/%-2d"", c.Num(), c.Denom())
			}
			result += ""×n""
			if exp := p + 1 - j; exp > 1 {
				result += fmt.Sprintf(""^%-2d"", exp)
			}
		}
		if result != expectedResults[p] {
			t.Errorf(""Faulhaber's formula for p=%d: got %s; expected %s"", p, result, expectedResults[p])
		}
	}
}
",./data/generated/docs_golang/faulhaber_s_formula/gpt_4o_2024_08_06_faulhaber_s_formula_test.go,CompileStatus.SYNTAX_ERROR,,,,0.04,0.18,,5.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: bernoulli', 'Severity': '', 'SourceLines': ['\t\tresult := bernoulli(nil, test.n)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_faulhaber_s_formula_test.go', 'Offset': 0, 'Line': 28, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fmt', 'Severity': '', 'SourceLines': ['\t\tresult += fmt.Sprintf(""%d : "", p)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_faulhaber_s_formula_test.go', 'Offset': 0, 'Line': 59, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: bernoulli', 'Severity': '', 'SourceLines': ['\t\t\tbernoulli(be, j)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_faulhaber_s_formula_test.go', 'Offset': 0, 'Line': 70, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fmt', 'Severity': '', 'SourceLines': ['\t\t\t\tresult += fmt.Sprintf("" %4s"", c.RatString())'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_faulhaber_s_formula_test.go', 'Offset': 0, 'Line': 77, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fmt', 'Severity': '', 'SourceLines': ['\t\t\t\tresult += fmt.Sprintf("" %+2d/%-2d"", c.Num(), c.Denom())'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_faulhaber_s_formula_test.go', 'Offset': 0, 'Line': 79, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_faulhaber_s_formula_test.go', 'line': 59, 'column': 13, 'message': 'undefined: fmt'}]"
Faulhaber's triangle,"Named after Johann Faulhaber, the rows of Faulhaber's triangle are the coefficients of polynomials that represent sums of integer powers, which are extracted from Faulhaber's formula:








∑

k
=
1


n



k

p


=


1

p
+
1




∑

j
=
0


p





(



p
+
1

j


)




B

j



n

p
+
1
−
j




{\displaystyle \sum _{k=1}^{n}k^{p}={1 \over p+1}\sum _{j=0}^{p}{p+1 \choose j}B_{j}n^{p+1-j}}




where 




B

n




{\displaystyle B_{n}}

 is the nth-Bernoulli number.



The first 5 rows of Faulhaber's triangle, are:

    1
  1/2  1/2
  1/6  1/2  1/3
    0  1/4  1/2  1/4
-1/30    0  1/3  1/2  1/5



Using the third row of the triangle, we have:






∑

k
=
1


n



k

2


=


1
6


n
+


1
2



n

2


+


1
3



n

3




{\displaystyle \sum _{k=1}^{n}k^{2}={1 \over 6}n+{1 \over 2}n^{2}+{1 \over 3}n^{3}}





 Task
 show the first 10 rows of Faulhaber's triangle.
 using the 18th row of Faulhaber's triangle, compute the sum: 




∑

k
=
1


1000



k

17




{\displaystyle \sum _{k=1}^{1000}k^{17}}

 (extra credit).
 See also

 Bernoulli numbers
 Evaluate binomial coefficients
 Faulhaber's formula (Wikipedia)
 Faulhaber's triangle (PDF)

",Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func bernoulli(n uint) *big.Rat {
    a := make([]big.Rat, n+1)
    z := new(big.Rat)
    for m := range a {
        a[m].SetFrac64(1, int64(m+1))
        for j := m; j >= 1; j-- {
            d := &a[j-1]
            d.Mul(z.SetInt64(int64(j)), d.Sub(d, &a[j]))
        }
    }
    // return the 'first' Bernoulli number
    if n != 1 {
        return &a[0]
    }
    a[0].Neg(&a[0])
    return &a[0]
}
 
func binomial(n, k int) int64 {
    if n <= 0 || k <= 0 || n < k {
        return 1
    }
    var num, den int64 = 1, 1
    for i := k + 1; i <= n; i++ {
        num *= int64(i)
    }
    for i := 2; i <= n-k; i++ {
        den *= int64(i)
    }
    return num / den
}
 
func faulhaberTriangle(p int) []big.Rat {
    coeffs := make([]big.Rat, p+1)
    q := big.NewRat(1, int64(p)+1)
    t := new(big.Rat)
    u := new(big.Rat)
    sign := -1
    for j := range coeffs {
        sign *= -1
        d := &coeffs[p-j]
        t.SetInt64(int64(sign))
        u.SetInt64(binomial(p+1, j))
        d.Mul(q, t)
        d.Mul(d, u)
        d.Mul(d, bernoulli(uint(j)))
    }
    return coeffs
}
 
func main() {
    for i := 0; i < 10; i++ {
        coeffs := faulhaberTriangle(i)
        for _, coeff := range coeffs {
            fmt.Printf(""%5s  "", coeff.RatString())
        }
        fmt.Println()
    }
    fmt.Println()
    // get coeffs for (k + 1)th row
    k := 17
    cc := faulhaberTriangle(k)
    n := int64(1000)
    nn := big.NewRat(n, 1)
    np := big.NewRat(1, 1)
    sum := new(big.Rat)
    tmp := new(big.Rat)
    for _, c := range cc {
        np.Mul(np, nn)
        tmp.Set(np)
        tmp.Mul(tmp, &c)
        sum.Add(sum, tmp)
    }
    fmt.Println(sum.RatString())
}",1740,82,"package main

import (
	""math/big""
	""testing""
)

// Test the bernoulli function
func TestBernoulli(t *testing.T) {
	tests := []struct {
		n        uint
		expected string
	}{
		{0, ""1/1""},
		{1, ""-1/2""},
		{2, ""1/6""},
		{3, ""0/1""},
		{4, ""-1/30""},
	}

	for _, test := range tests {
		result := bernoulli(test.n)
		if result.RatString() != test.expected {
			t.Errorf(""bernoulli(%d) = %s; expected %s"", test.n, result.RatString(), test.expected)
		}
	}
}

// Test the binomial function
func TestBinomial(t *testing.T) {
	tests := []struct {
		n, k     int
		expected int64
	}{
		{5, 2, 10},
		{5, 0, 1},
		{5, 5, 1},
		{6, 2, 15},
		{0, 0, 1},
	}

	for _, test := range tests {
		result := binomial(test.n, test.k)
		if result != test.expected {
			t.Errorf(""binomial(%d, %d) = %d; expected %d"", test.n, test.k, result, test.expected)
		}
	}
}

// Test the faulhaberTriangle function
func TestFaulhaberTriangle(t *testing.T) {
	tests := []struct {
		p        int
		expected []string
	}{
		{0, []string{""1/1""}},
		{1, []string{""1/2"", ""1/2""}},
		{2, []string{""1/6"", ""1/2"", ""1/3""}},
		{3, []string{""0/1"", ""1/4"", ""1/2"", ""1/4""}},
		{4, []string{""-1/30"", ""0/1"", ""1/3"", ""1/2"", ""1/5""}},
	}

	for _, test := range tests {
		result := faulhaberTriangle(test.p)
		if len(result) != len(test.expected) {
			t.Errorf(""faulhaberTriangle(%d) length = %d; expected %d"", test.p, len(result), len(test.expected))
			continue
		}
		for i, coeff := range result {
			if coeff.RatString() != test.expected[i] {
				t.Errorf(""faulhaberTriangle(%d)[%d] = %s; expected %s"", test.p, i, coeff.RatString(), test.expected[i])
			}
		}
	}
}
",./data/generated/docs_golang/faulhaber_s_triangle/gpt_4o_2024_08_06_faulhaber_s_triangle_test.go,CompileStatus.SYNTAX_ERROR,,,,0.09,0.25,,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: bernoulli', 'Severity': '', 'SourceLines': ['\t\tresult := bernoulli(test.n)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_faulhaber_s_triangle_test.go', 'Offset': 0, 'Line': 22, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: binomial', 'Severity': '', 'SourceLines': ['\t\tresult := binomial(test.n, test.k)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_faulhaber_s_triangle_test.go', 'Offset': 0, 'Line': 43, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: faulhaberTriangle', 'Severity': '', 'SourceLines': ['\t\tresult := faulhaberTriangle(test.p)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_faulhaber_s_triangle_test.go', 'Offset': 0, 'Line': 64, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""math/big"" imported and not used', 'Severity': '', 'SourceLines': ['\t""math/big""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_faulhaber_s_triangle_test.go', 'Offset': 0, 'Line': 4, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_faulhaber_s_triangle_test.go', 'line': 4, 'column': 2, 'message': '""math/big"" imported and not used'}]"
Fibonacci word/fractal,"
The Fibonacci word may be represented as a fractal as described here:


(Clicking on the above website   (hal.archives-ouvertes.fr)    will leave a cookie.)



For F_wordm start with F_wordCharn=1
Draw a segment forward
If current F_wordChar is 0
Turn left if n is even
Turn right if n is odd
next n and iterate until end of F_word


Task

Create and display a fractal similar to Fig 1.


(Clicking on the above website   (hal.archives-ouvertes.fr)    will leave a cookie.)
",Go,"package main
 
import (
    ""github.com/fogleman/gg""
    ""strings""
)
 
func wordFractal(i int) string {
    if i < 2 {
        if i == 1 {
            return ""1""
        }
        return """"
    }
    var f1 strings.Builder
    f1.WriteString(""1"")
    var f2 strings.Builder
    f2.WriteString(""0"")
    for j := i - 2; j >= 1; j-- {
        tmp := f2.String()
        f2.WriteString(f1.String())
        f1.Reset()
        f1.WriteString(tmp)
    }
    return f2.String()
}
 
func draw(dc *gg.Context, x, y, dx, dy float64, wf string) {
    for i, c := range wf {
        dc.DrawLine(x, y, x+dx, y+dy)
        x += dx
        y += dy
        if c == '0' {
            tx := dx
            dx = dy
            if i%2 == 0 {
                dx = -dy
            }
            dy = -tx
            if i%2 == 0 {
                dy = tx
            }
        }
    }
}
 
func main() {
    dc := gg.NewContext(450, 620)
    dc.SetRGB(0, 0, 0)
    dc.Clear()
    wf := wordFractal(23)
    draw(dc, 20, 20, 1, 0, wf)
    dc.SetRGB(0, 1, 0)
    dc.SetLineWidth(1)
    dc.Stroke()
    dc.SavePNG(""fib_wordfractal.png"")
}",1110,57,"package main

import (
    ""testing""
    ""github.com/fogleman/gg""
    ""strings""
)

// TestWordFractal tests the wordFractal function for various input cases
func TestWordFractal(t *testing.T) {
    tests := []struct {
        input    int
        expected string
    }{
        {0, """"},
        {1, ""1""},
        {2, ""0""},
        {3, ""01""},
        {4, ""010""},
        {5, ""01001""},
        {6, ""01001010""},
    }

    for _, test := range tests {
        result := wordFractal(test.input)
        if result != test.expected {
            t.Errorf(""wordFractal(%d) = %s; expected %s"", test.input, result, test.expected)
        }
    }
}

// TestDraw tests the draw function by checking if the drawing context is modified correctly
func TestDraw(t *testing.T) {
    dc := gg.NewContext(100, 100)
    dc.SetRGB(0, 0, 0)
    dc.Clear()
    initialImage := dc.Image()

    wf := ""010""
    draw(dc, 10, 10, 1, 0, wf)

    modifiedImage := dc.Image()

    if initialImage == modifiedImage {
        t.Error(""draw function did not modify the drawing context"")
    }
}

// TestMainFunction tests the main function indirectly by checking the output file
func TestMainFunction(t *testing.T) {
    main()

    // Check if the output file is created
    if _, err := os.Stat(""fib_wordfractal.png""); os.IsNotExist(err) {
        t.Error(""main function did not create the expected output file fib_wordfractal.png"")
    }
}
",./data/generated/docs_golang/fibonacci_word_fractal/gpt_4o_2024_08_06_fibonacci_word_fractal_test.go,CompileStatus.SYNTAX_ERROR,,,,0.1,0.3,,5.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: wordFractal', 'Severity': '', 'SourceLines': ['        result := wordFractal(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fibonacci_word_fractal_test.go', 'Offset': 0, 'Line': 25, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: draw', 'Severity': '', 'SourceLines': ['    draw(dc, 10, 10, 1, 0, wf)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fibonacci_word_fractal_test.go', 'Offset': 0, 'Line': 40, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['    main()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fibonacci_word_fractal_test.go', 'Offset': 0, 'Line': 51, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: os', 'Severity': '', 'SourceLines': ['    if _, err := os.Stat(""fib_wordfractal.png""); os.IsNotExist(err) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fibonacci_word_fractal_test.go', 'Offset': 0, 'Line': 54, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""strings"" imported and not used', 'Severity': '', 'SourceLines': ['    ""strings""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fibonacci_word_fractal_test.go', 'Offset': 0, 'Line': 6, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_fibonacci_word_fractal_test.go', 'line': 54, 'column': 18, 'message': 'undefined: os'}]"
File input/output,"File input/output is part of Short Circuit's Console Program Basics selection.
Task

Create a file called   ""output.txt"",   and place in it the contents of the file   ""input.txt"",   via an intermediate variable.

In other words, your program will demonstrate:

   how to read from a file into a variable
   how to write a variable's contents into a file


Oneliners that skip the intermediate variable are of secondary interest — operating systems have copy commands for that.



",Go,"package main
 
import (
    ""fmt""
    ""io/ioutil""
)
 
func main() {
    b, err := ioutil.ReadFile(""input.txt"")
    if err != nil {
        fmt.Println(err)
        return
    }
    if err = ioutil.WriteFile(""output.txt"", b, 0666); err != nil {
        fmt.Println(err)
    }
}",276,17,"package main

import (
    ""io/ioutil""
    ""os""
    ""testing""
)

func TestFileInputOutput(t *testing.T) {
    // Setup: Create a temporary input file
    inputContent := []byte(""Hello, World!"")
    err := ioutil.WriteFile(""input.txt"", inputContent, 0666)
    if err != nil {
        t.Fatalf(""Failed to create input file: %v"", err)
    }

    // Ensure cleanup of files after test
    defer func() {
        os.Remove(""input.txt"")
        os.Remove(""output.txt"")
    }()

    // Execute the main function
    main()

    // Verify: Check if output.txt exists
    if _, err := os.Stat(""output.txt""); os.IsNotExist(err) {
        t.Fatalf(""output.txt does not exist"")
    }

    // Verify: Check if the content of output.txt matches input.txt
    outputContent, err := ioutil.ReadFile(""output.txt"")
    if err != nil {
        t.Fatalf(""Failed to read output file: %v"", err)
    }

    if string(outputContent) != string(inputContent) {
        t.Errorf(""Content mismatch: got %s, want %s"", outputContent, inputContent)
    }
}
",./data/generated/docs_golang/file_input_output/gpt_4o_2024_08_06_file_input_output_test.go,CompileStatus.OK,0.0,50.0,,0.22,1.33,0.123,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['    main()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_file_input_output_test.go', 'Offset': 0, 'Line': 24, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
File size,"Verify the size of a file called     input.txt     for a file in the current working directory, and another one in the file system root.



",Go,"package main
 
import ""fmt""
import ""os""
 
func printFileSize(f string) {
    if stat, err := os.Stat(f); err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(stat.Size())
    }
}
 
func main() {
    printFileSize(""input.txt"")
    printFileSize(""/input.txt"")
}",277,17,"package main

import (
	""bytes""
	""os""
	""testing""
)

func TestPrintFileSize(t *testing.T) {
	// Create a buffer to capture the output
	var buf bytes.Buffer
	originalStdout := os.Stdout
	defer func() { os.Stdout = originalStdout }()
	r, w, _ := os.Pipe()
	os.Stdout = w

	// Test case 1: File in the current working directory
	fileName := ""input.txt""
	file, err := os.Create(fileName)
	if err != nil {
		t.Fatalf(""Failed to create test file: %v"", err)
	}
	defer os.Remove(fileName) // Clean up

	// Write some data to the file
	file.WriteString(""Hello, World!"")
	file.Close()

	printFileSize(fileName)

	// Capture the output
	w.Close()
	buf.ReadFrom(r)
	output := buf.String()

	expectedSize := ""13\n"" // ""Hello, World!"" is 13 bytes
	if output != expectedSize {
		t.Errorf(""Expected file size %s, but got %s"", expectedSize, output)
	}

	// Test case 2: File in the file system root
	// This test assumes that ""/input.txt"" does not exist
	buf.Reset()
	r, w, _ = os.Pipe()
	os.Stdout = w

	printFileSize(""/input.txt"")

	// Capture the output
	w.Close()
	buf.ReadFrom(r)
	output = buf.String()

	expectedError := ""stat /input.txt: no such file or directory\n""
	if output != expectedError {
		t.Errorf(""Expected error message %s, but got %s"", expectedError, output)
	}
}
",./data/generated/docs_golang/file_size/gpt_4o_2024_08_06_file_size_test.go,CompileStatus.OK,0.0,60.0,,0.09,1.0,0.124,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: printFileSize', 'Severity': '', 'SourceLines': ['\tprintFileSize(fileName)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_file_size_test.go', 'Offset': 0, 'Line': 29, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: printFileSize', 'Severity': '', 'SourceLines': ['\tprintFileSize(""/input.txt"")'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_file_size_test.go', 'Offset': 0, 'Line': 47, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Find if a point is within a triangle,"Find if a point is within a triangle.



Task

   Assume points are on a plane defined by (x, y) real number coordinates.
   Given a point P(x, y) and a triangle formed by points A, B, and C, determine if P is within triangle ABC. 
   You may use any algorithm. 
   Bonus: explain why the algorithm you chose works.


Related tasks

   Determine_if_two_triangles_overlap


Also see

 Discussion of several methods. [[1]]
 Determine if a point is in a polygon [[2]]
 Triangle based coordinate systems [[3]]
 Wolfram entry [[4]]

",Go,"package main
 
import (
    ""fmt""
    ""math""
)
 
const EPS = 0.001
const EPS_SQUARE = EPS * EPS
 
func side(x1, y1, x2, y2, x, y float64) float64 {
    return (y2-y1)*(x-x1) + (-x2+x1)*(y-y1)
}
 
func naivePointInTriangle(x1, y1, x2, y2, x3, y3, x, y float64) bool {
    checkSide1 := side(x1, y1, x2, y2, x, y) >= 0
    checkSide2 := side(x2, y2, x3, y3, x, y) >= 0
    checkSide3 := side(x3, y3, x1, y1, x, y) >= 0
    return checkSide1 && checkSide2 && checkSide3
}
 
func pointInTriangleBoundingBox(x1, y1, x2, y2, x3, y3, x, y float64) bool {
    xMin := math.Min(x1, math.Min(x2, x3)) - EPS
    xMax := math.Max(x1, math.Max(x2, x3)) + EPS
    yMin := math.Min(y1, math.Min(y2, y3)) - EPS
    yMax := math.Max(y1, math.Max(y2, y3)) + EPS
    return !(x < xMin || xMax < x || y < yMin || yMax < y)
}
 
func distanceSquarePointToSegment(x1, y1, x2, y2, x, y float64) float64 {
    p1_p2_squareLength := (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)
    dotProduct := ((x-x1)*(x2-x1) + (y-y1)*(y2-y1)) / p1_p2_squareLength
    if dotProduct < 0 {
        return (x-x1)*(x-x1) + (y-y1)*(y-y1)
    } else if dotProduct <= 1 {
        p_p1_squareLength := (x1-x)*(x1-x) + (y1-y)*(y1-y)
        return p_p1_squareLength - dotProduct*dotProduct*p1_p2_squareLength
    } else {
        return (x-x2)*(x-x2) + (y-y2)*(y-y2)
    }
}
 
func accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y float64) bool {
    if !pointInTriangleBoundingBox(x1, y1, x2, y2, x3, y3, x, y) {
        return false
    }
    if naivePointInTriangle(x1, y1, x2, y2, x3, y3, x, y) {
        return true
    }
    if distanceSquarePointToSegment(x1, y1, x2, y2, x, y) <= EPS_SQUARE {
        return true
    }
    if distanceSquarePointToSegment(x2, y2, x3, y3, x, y) <= EPS_SQUARE {
        return true
    }
    if distanceSquarePointToSegment(x3, y3, x1, y1, x, y) <= EPS_SQUARE {
        return true
    }
    return false
}
 
func main() {
    pts := [][2]float64{{0, 0}, {0, 1}, {3, 1}}
    tri := [][2]float64{{3.0 / 2, 12.0 / 5}, {51.0 / 10, -31.0 / 10}, {-19.0 / 5, 1.2}}
    fmt.Println(""Triangle is"", tri)
    x1, y1 := tri[0][0], tri[0][1]
    x2, y2 := tri[1][0], tri[1][1]
    x3, y3 := tri[2][0], tri[2][1]
    for _, pt := range pts {
        x, y := pt[0], pt[1]
        within := accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)
        fmt.Println(""Point"", pt, ""is within triangle?"", within)
    }
    fmt.Println()
    tri = [][2]float64{{1.0 / 10, 1.0 / 9}, {100.0 / 8, 100.0 / 3}, {100.0 / 4, 100.0 / 9}}
    fmt.Println(""Triangle is"", tri)
    x1, y1 = tri[0][0], tri[0][1]
    x2, y2 = tri[1][0], tri[1][1]
    x3, y3 = tri[2][0], tri[2][1]
    x := x1 + (3.0/7)*(x2-x1)
    y := y1 + (3.0/7)*(y2-y1)
    pt := [2]float64{x, y}
    within := accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)
    fmt.Println(""Point"", pt, ""is within triangle ?"", within)
    fmt.Println()
    tri = [][2]float64{{1.0 / 10, 1.0 / 9}, {100.0 / 8, 100.0 / 3}, {-100.0 / 8, 100.0 / 6}}
    fmt.Println(""Triangle is"", tri)
    x3 = tri[2][0]
    y3 = tri[2][1]
    within = accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)
    fmt.Println(""Point"", pt, ""is within triangle ?"", within)
}",3162,92,"package main

import (
	""testing""
)

func TestAccuratePointInTriangle(t *testing.T) {
	tests := []struct {
		name     string
		x1, y1   float64
		x2, y2   float64
		x3, y3   float64
		x, y     float64
		expected bool
	}{
		{
			name:     ""Point inside triangle"",
			x1:       0, y1: 0,
			x2:       5, y2: 0,
			x3:       0, y3: 5,
			x:        1, y: 1,
			expected: true,
		},
		{
			name:     ""Point on edge of triangle"",
			x1:       0, y1: 0,
			x2:       5, y2: 0,
			x3:       0, y3: 5,
			x:        2.5, y: 0,
			expected: true,
		},
		{
			name:     ""Point outside triangle"",
			x1:       0, y1: 0,
			x2:       5, y2: 0,
			x3:       0, y3: 5,
			x:        5, y: 5,
			expected: false,
		},
		{
			name:     ""Point at vertex of triangle"",
			x1:       0, y1: 0,
			x2:       5, y2: 0,
			x3:       0, y3: 5,
			x:        0, y: 0,
			expected: true,
		},
		{
			name:     ""Point very close to edge"",
			x1:       0, y1: 0,
			x2:       5, y2: 0,
			x3:       0, y3: 5,
			x:        2.5, y: 0.001,
			expected: true,
		},
		{
			name:     ""Point very close to outside"",
			x1:       0, y1: 0,
			x2:       5, y2: 0,
			x3:       0, y3: 5,
			x:        5.001, y: 5.001,
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := accuratePointInTriangle(tt.x1, tt.y1, tt.x2, tt.y2, tt.x3, tt.y3, tt.x, tt.y)
			if result != tt.expected {
				t.Errorf(""expected %v, got %v"", tt.expected, result)
			}
		})
	}
}
",./data/generated/docs_golang/find_if_a_point_is_within_a_triangle/gpt_4o_2024_08_06_find_if_a_point_is_within_a_triangle_test.go,CompileStatus.OK,0.0,43.9,,0.02,0.05,0.154,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: accuratePointInTriangle', 'Severity': '', 'SourceLines': ['\t\t\tresult := accuratePointInTriangle(tt.x1, tt.y1, tt.x2, tt.y2, tt.x3, tt.y3, tt.x, tt.y)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_if_a_point_is_within_a_triangle_test.go', 'Offset': 0, 'Line': 68, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,57.14,False,[]
Find largest left truncatable prime in a given base,"A truncatable prime is one where all non-empty substrings that finish at the end of the number (right-substrings) are also primes when understood as numbers in a particular base. The largest such prime in a given (integer) base is therefore computable, provided the base is larger than 2.

Let's consider what happens in base 10. Obviously the right most digit must be prime, so in base 10 candidates are 2,3,5,7. Putting a digit in the range 1 to base-1 in front of each candidate must result in a prime. So 2 and 5, like the whale and the petunias in The Hitchhiker's Guide to the Galaxy, come into existence only to be extinguished before they have time to realize it, because 2 and 5 preceded by any digit in the range 1 to base-1 is not prime. Some numbers formed by preceding 3 or 7 by a digit in the range 1 to base-1 are prime. So 13,17,23,37,43,47,53,67,73,83,97 are candidates. Again, putting a digit in the range 1 to base-1 in front of each candidate must be a prime. Repeating until there are no larger candidates finds the largest left truncatable prime.

Let's work base 3 by hand:

0 and 1 are not prime so the last digit must be 2. 123 = 510 which is prime, 223 = 810 which is not so 123 is the only candidate. 1123 = 1410 which is not prime, 2123 = 2310 which is, so 2123 is the only candidate. 12123 = 5010 which is not prime, 22123 = 7710 which also is not prime. So there are no more candidates, therefore 23 is the largest left truncatable prime in base 3.

The task is to reconstruct as much, and possibly more, of the table in the OEIS as you are able.

Related Tasks:

 Miller-Rabin primality test

",Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
var smallPrimes = [...]int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}
 
const maxStack = 128
 
var (
    tens, values    [maxStack]big.Int
    bigTemp, answer = new(big.Int), new(big.Int)
    base, seenDepth int
)
 
func addDigit(i int) {
    for d := 1; d < base; d++ {
        values[i].Set(&values[i-1])
        bigTemp.SetUint64(uint64(d))
        bigTemp.Mul(bigTemp, &tens[i])
        values[i].Add(&values[i], bigTemp)
        if !values[i].ProbablyPrime(0) {
            continue
        }
        if i > seenDepth || (i == seenDepth && values[i].Cmp(answer) == 1) {
            if !values[i].ProbablyPrime(0) {
                continue
            }
            answer.Set(&values[i])
            seenDepth = i
        }
        addDigit(i + 1)
    }
}
 
func doBase() {
    answer.SetUint64(0)
    tens[0].SetUint64(1)
    bigTemp.SetUint64(uint64(base))
    seenDepth = 0
    for i := 1; i < maxStack; i++ {
        tens[i].Mul(&tens[i-1], bigTemp)
    }
    for i := 0; smallPrimes[i] < base; i++ {
        values[0].SetUint64(uint64(smallPrimes[i]))
        addDigit(1)
    }
    fmt.Printf(""%2d: %s\n"", base, answer.String())
}
 
func main() {
    for base = 3; base <= 17; base++ {
        doBase()
    }
}",1267,57,"package main

import (
	""math/big""
	""testing""
)

// Mock function to replace fmt.Printf in doBase
func findLargestLeftTruncatablePrime(base int) *big.Int {
	answer.SetUint64(0)
	tens[0].SetUint64(1)
	bigTemp.SetUint64(uint64(base))
	seenDepth = 0
	for i := 1; i < maxStack; i++ {
		tens[i].Mul(&tens[i-1], bigTemp)
	}
	for i := 0; smallPrimes[i] < base; i++ {
		values[0].SetUint64(uint64(smallPrimes[i]))
		addDigit(1)
	}
	return new(big.Int).Set(answer)
}

func TestFindLargestLeftTruncatablePrime(t *testing.T) {
	tests := []struct {
		base     int
		expected string
	}{
		{3, ""2""},   // Base 3
		{4, ""3""},   // Base 4
		{5, ""23""},  // Base 5
		{6, ""5""},   // Base 6
		{7, ""53""},  // Base 7
		{8, ""73""},  // Base 8
		{9, ""7""},   // Base 9
		{10, ""739397""}, // Base 10
		{11, ""23399339""}, // Base 11
		{12, ""11""},  // Base 12
		{13, ""3137""}, // Base 13
		{14, ""13""},  // Base 14
		{15, ""13""},  // Base 15
		{16, ""13""},  // Base 16
		{17, ""13""},  // Base 17
	}

	for _, test := range tests {
		base = test.base
		result := findLargestLeftTruncatablePrime(base)
		if result.String() != test.expected {
			t.Errorf(""For base %d, expected %s, got %s"", test.base, test.expected, result.String())
		}
	}
}
",./data/generated/docs_golang/find_largest_left_truncatable_prime_in_a_given_base/gpt_4o_2024_08_06_find_largest_left_truncatable_prime_in_a_given_base_test.go,CompileStatus.OK,,,,0.03,0.08,,12.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: answer', 'Severity': '', 'SourceLines': ['\tanswer.SetUint64(0)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_largest_left_truncatable_prime_in_a_given_base_test.go', 'Offset': 0, 'Line': 10, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: tens', 'Severity': '', 'SourceLines': ['\ttens[0].SetUint64(1)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_largest_left_truncatable_prime_in_a_given_base_test.go', 'Offset': 0, 'Line': 11, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: bigTemp', 'Severity': '', 'SourceLines': ['\tbigTemp.SetUint64(uint64(base))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_largest_left_truncatable_prime_in_a_given_base_test.go', 'Offset': 0, 'Line': 12, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: seenDepth', 'Severity': '', 'SourceLines': ['\tseenDepth = 0'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_largest_left_truncatable_prime_in_a_given_base_test.go', 'Offset': 0, 'Line': 13, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: maxStack', 'Severity': '', 'SourceLines': ['\tfor i := 1; i < maxStack; i++ {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_largest_left_truncatable_prime_in_a_given_base_test.go', 'Offset': 0, 'Line': 14, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: tens', 'Severity': '', 'SourceLines': ['\t\ttens[i].Mul(&tens[i-1], bigTemp)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_largest_left_truncatable_prime_in_a_given_base_test.go', 'Offset': 0, 'Line': 15, 'Column': 3}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: smallPrimes', 'Severity': '', 'SourceLines': ['\tfor i := 0; smallPrimes[i] < base; i++ {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_largest_left_truncatable_prime_in_a_given_base_test.go', 'Offset': 0, 'Line': 17, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: values', 'Severity': '', 'SourceLines': ['\t\tvalues[0].SetUint64(uint64(smallPrimes[i]))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_largest_left_truncatable_prime_in_a_given_base_test.go', 'Offset': 0, 'Line': 18, 'Column': 3}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: addDigit', 'Severity': '', 'SourceLines': ['\t\taddDigit(1)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_largest_left_truncatable_prime_in_a_given_base_test.go', 'Offset': 0, 'Line': 19, 'Column': 3}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: answer', 'Severity': '', 'SourceLines': ['\treturn new(big.Int).Set(answer)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_largest_left_truncatable_prime_in_a_given_base_test.go', 'Offset': 0, 'Line': 21, 'Column': 26}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: base', 'Severity': '', 'SourceLines': ['\t\tbase = test.base'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_largest_left_truncatable_prime_in_a_given_base_test.go', 'Offset': 0, 'Line': 47, 'Column': 3}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: base', 'Severity': '', 'SourceLines': ['\t\tresult := findLargestLeftTruncatablePrime(base)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_largest_left_truncatable_prime_in_a_given_base_test.go', 'Offset': 0, 'Line': 48, 'Column': 45}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,True,[]
Find limit of recursion,"Find limit of recursion is part of Short Circuit's Console Program Basics selection.
Task

Find the limit of recursion.



",Go,"package main
 
import (
	""flag""
	""fmt""
	""runtime/debug""
)
 
func main() {
	stack := flag.Int(""stack"", 0, ""maximum per goroutine stack size or 0 for the default"")
	flag.Parse()
	if *stack > 0 {
		debug.SetMaxStack(*stack)
	}
	r(1)
}
 
func r(l int) {
	if l%1000 == 0 {
		fmt.Println(l)
	}
	r(l + 1)
}",299,23,"package main

import (
	""os/exec""
	""strings""
	""testing""
)

func TestFindLimitOfRecursion(t *testing.T) {
	tests := []struct {
		stackSize int
		expectErr bool
	}{
		{stackSize: 0, expectErr: true},   // Default stack size, expect stack overflow
		{stackSize: 1024 * 1024, expectErr: true}, // Small stack size, expect stack overflow
		{stackSize: 10 * 1024 * 1024, expectErr: false}, // Larger stack size, may not overflow
	}

	for _, test := range tests {
		t.Run(strings.Join([]string{""stackSize"", string(test.stackSize)}, ""_""), func(t *testing.T) {
			cmd := exec.Command(""go"", ""run"", ""find_limit_of_recursion.go"", ""-stack"", string(test.stackSize))
			output, err := cmd.CombinedOutput()

			if test.expectErr && err == nil {
				t.Errorf(""Expected an error for stack size %d, but got none. Output: %s"", test.stackSize, output)
			} else if !test.expectErr && err != nil {
				t.Errorf(""Did not expect an error for stack size %d, but got one. Error: %v, Output: %s"", test.stackSize, err, output)
			}
		})
	}
}
",./data/generated/docs_golang/find_limit_of_recursion/gpt_4o_2024_08_06_find_limit_of_recursion_test.go,CompileStatus.SYNTAX_ERROR,,,,0.12,0.5,,2.0,"[{'FromLinter': 'govet', 'Text': 'stringintconv: conversion from int to string yields a string of one rune, not a string of digits', 'Severity': '', 'SourceLines': ['\t\tt.Run(strings.Join([]string{""stackSize"", string(test.stackSize)}, ""_""), func(t *testing.T) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_limit_of_recursion_test.go', 'Offset': 500, 'Line': 20, 'Column': 44}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'govet', 'Text': 'stringintconv: conversion from int to string yields a string of one rune, not a string of digits', 'Severity': '', 'SourceLines': ['\t\t\tcmd := exec.Command(""go"", ""run"", ""find_limit_of_recursion.go"", ""-stack"", string(test.stackSize))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_limit_of_recursion_test.go', 'Offset': 628, 'Line': 21, 'Column': 77}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_find_limit_of_recursion_test.go', 'line': 20, 'column': 44, 'message': 'conversion from int to string yields a string of one rune, not a string of digits'}, {'file': './gpt_4o_2024_08_06_find_limit_of_recursion_test.go', 'line': 21, 'column': 77, 'message': 'conversion from int to string yields a string of one rune, not a string of digits'}]"
Find the intersection of a line with a plane,"Finding the intersection of an infinite ray with a plane in 3D is an important topic in collision detection.



Task

Find the point of intersection for the infinite ray with direction   (0, -1, -1)   passing through position   (0, 0, 10)   with the infinite plane with a normal vector of   (0, 0, 1)   and which passes through [0, 0, 5].



",Go,"package main
 
import ""fmt""
 
type Vector3D struct{ x, y, z float64 }
 
func (v *Vector3D) Add(w *Vector3D) *Vector3D {
    return &Vector3D{v.x + w.x, v.y + w.y, v.z + w.z}
}
 
func (v *Vector3D) Sub(w *Vector3D) *Vector3D {
    return &Vector3D{v.x - w.x, v.y - w.y, v.z - w.z}
}
 
func (v *Vector3D) Mul(s float64) *Vector3D {
    return &Vector3D{s * v.x, s * v.y, s * v.z}
}
 
func (v *Vector3D) Dot(w *Vector3D) float64 {
    return v.x*w.x + v.y*w.y + v.z*w.z
}
 
func (v *Vector3D) String() string {
    return fmt.Sprintf(""(%v, %v, %v)"", v.x, v.y, v.z)
}
 
func intersectPoint(rayVector, rayPoint, planeNormal, planePoint *Vector3D) *Vector3D {
    diff := rayPoint.Sub(planePoint)
    prod1 := diff.Dot(planeNormal)
    prod2 := rayVector.Dot(planeNormal)
    prod3 := prod1 / prod2
    return rayPoint.Sub(rayVector.Mul(prod3))
}
 
func main() {
    rv := &Vector3D{0.0, -1.0, -1.0}
    rp := &Vector3D{0.0, 0.0, 10.0}
    pn := &Vector3D{0.0, 0.0, 1.0}
    pp := &Vector3D{0.0, 0.0, 5.0}
    ip := intersectPoint(rv, rp, pn, pp)
    fmt.Println(""The ray intersects the plane at"", ip)
}",1097,42,"package main

import (
	""testing""
)

func TestIntersectPoint(t *testing.T) {
	rayVector := &Vector3D{0.0, -1.0, -1.0}
	rayPoint := &Vector3D{0.0, 0.0, 10.0}
	planeNormal := &Vector3D{0.0, 0.0, 1.0}
	planePoint := &Vector3D{0.0, 0.0, 5.0}

	expectedIntersection := &Vector3D{0.0, 0.0, 5.0}
	intersection := intersectPoint(rayVector, rayPoint, planeNormal, planePoint)

	if intersection.x != expectedIntersection.x || intersection.y != expectedIntersection.y || intersection.z != expectedIntersection.z {
		t.Errorf(""Expected intersection at %v, but got %v"", expectedIntersection, intersection)
	}
}

func TestIntersectPointParallelRay(t *testing.T) {
	rayVector := &Vector3D{0.0, 0.0, 1.0} // Parallel to the plane
	rayPoint := &Vector3D{0.0, 0.0, 10.0}
	planeNormal := &Vector3D{0.0, 0.0, 1.0}
	planePoint := &Vector3D{0.0, 0.0, 5.0}

	intersection := intersectPoint(rayVector, rayPoint, planeNormal, planePoint)

	if intersection != nil {
		t.Errorf(""Expected no intersection for parallel ray, but got %v"", intersection)
	}
}

func TestIntersectPointRayOriginOnPlane(t *testing.T) {
	rayVector := &Vector3D{0.0, -1.0, -1.0}
	rayPoint := &Vector3D{0.0, 0.0, 5.0} // Origin on the plane
	planeNormal := &Vector3D{0.0, 0.0, 1.0}
	planePoint := &Vector3D{0.0, 0.0, 5.0}

	expectedIntersection := &Vector3D{0.0, 0.0, 5.0}
	intersection := intersectPoint(rayVector, rayPoint, planeNormal, planePoint)

	if intersection.x != expectedIntersection.x || intersection.y != expectedIntersection.y || intersection.z != expectedIntersection.z {
		t.Errorf(""Expected intersection at %v, but got %v"", expectedIntersection, intersection)
	}
}
",./data/generated/docs_golang/find_the_intersection_of_a_line_with_a_plane/gpt_4o_2024_08_06_find_the_intersection_of_a_line_with_a_plane_test.go,CompileStatus.OK,0.0,56.2,,0.11,0.43,0.119,6.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: Vector3D', 'Severity': '', 'SourceLines': ['\trayVector := &Vector3D{0.0, -1.0, -1.0}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_the_intersection_of_a_line_with_a_plane_test.go', 'Offset': 0, 'Line': 8, 'Column': 16}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Vector3D', 'Severity': '', 'SourceLines': ['\trayPoint := &Vector3D{0.0, 0.0, 10.0}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_the_intersection_of_a_line_with_a_plane_test.go', 'Offset': 0, 'Line': 9, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Vector3D', 'Severity': '', 'SourceLines': ['\tplaneNormal := &Vector3D{0.0, 0.0, 1.0}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_the_intersection_of_a_line_with_a_plane_test.go', 'Offset': 0, 'Line': 10, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: intersectPoint', 'Severity': '', 'SourceLines': ['\tintersection := intersectPoint(rayVector, rayPoint, planeNormal, planePoint)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_the_intersection_of_a_line_with_a_plane_test.go', 'Offset': 0, 'Line': 14, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: intersectPoint', 'Severity': '', 'SourceLines': ['\tintersection := intersectPoint(rayVector, rayPoint, planeNormal, planePoint)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_the_intersection_of_a_line_with_a_plane_test.go', 'Offset': 0, 'Line': 27, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: intersectPoint', 'Severity': '', 'SourceLines': ['\tintersection := intersectPoint(rayVector, rayPoint, planeNormal, planePoint)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_the_intersection_of_a_line_with_a_plane_test.go', 'Offset': 0, 'Line': 41, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,33.33,False,[]
Find the intersection of two lines,"[1]


Task

Find the point of intersection of two lines in 2D.



The 1st line passes though    (4,0)    and    (6,10) .

The 2nd line passes though    (0,3)    and    (10,7) .



",Go," 
package main
 
import (
	""fmt""
	""errors""
)
 
type Point struct {
	x float64
	y float64
}
 
type Line struct {
	slope float64
	yint float64
}
 
func CreateLine (a, b Point) Line {
	slope := (b.y-a.y) / (b.x-a.x)
	yint := a.y - slope*a.x
	return Line{slope, yint}
} 
 
func EvalX (l Line, x float64) float64 {
	return l.slope*x + l.yint
}
 
func Intersection (l1, l2 Line) (Point, error) {
	if l1.slope == l2.slope {
		return Point{}, errors.New(""The lines do not intersect"")
	}
	x := (l2.yint-l1.yint) / (l1.slope-l2.slope)
	y := EvalX(l1, x)
	return Point{x, y}, nil
}
 
func main() {
	l1 := CreateLine(Point{4, 0}, Point{6, 10})
	l2 := CreateLine(Point{0, 3}, Point{10, 7})
	if result, err := Intersection(l1, l2); err == nil {
		fmt.Println(result)
	} else {
		fmt.Println(""The lines do not intersect"")
	}
}
 ",813,47,"package main

import (
	""testing""
)

func TestCreateLine(t *testing.T) {
	tests := []struct {
		a, b     Point
		expected Line
	}{
		{Point{4, 0}, Point{6, 10}, Line{5, -20}},
		{Point{0, 3}, Point{10, 7}, Line{0.4, 3}},
	}

	for _, test := range tests {
		result := CreateLine(test.a, test.b)
		if result != test.expected {
			t.Errorf(""CreateLine(%v, %v) = %v; expected %v"", test.a, test.b, result, test.expected)
		}
	}
}

func TestEvalX(t *testing.T) {
	tests := []struct {
		line     Line
		x        float64
		expected float64
	}{
		{Line{5, -20}, 5, 5},
		{Line{0.4, 3}, 10, 7},
	}

	for _, test := range tests {
		result := EvalX(test.line, test.x)
		if result != test.expected {
			t.Errorf(""EvalX(%v, %v) = %v; expected %v"", test.line, test.x, result, test.expected)
		}
	}
}

func TestIntersection(t *testing.T) {
	tests := []struct {
		l1, l2   Line
		expected Point
		err      error
	}{
		{Line{5, -20}, Line{0.4, 3}, Point{4.8, 4}, nil},
		{Line{1, 0}, Line{1, 1}, Point{}, errors.New(""The lines do not intersect"")},
	}

	for _, test := range tests {
		result, err := Intersection(test.l1, test.l2)
		if err != nil && test.err == nil || err == nil && test.err != nil {
			t.Errorf(""Intersection(%v, %v) unexpected error: %v"", test.l1, test.l2, err)
		}
		if err == nil && result != test.expected {
			t.Errorf(""Intersection(%v, %v) = %v; expected %v"", test.l1, test.l2, result, test.expected)
		}
	}
}
",./data/generated/docs_golang/find_the_intersection_of_two_lines/gpt_4o_2024_08_06_find_the_intersection_of_two_lines_test.go,CompileStatus.SYNTAX_ERROR,,,,0.11,0.67,,9.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: Point', 'Severity': '', 'SourceLines': ['\t\ta, b     Point'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_the_intersection_of_two_lines_test.go', 'Offset': 0, 'Line': 9, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Line', 'Severity': '', 'SourceLines': ['\t\texpected Line'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_the_intersection_of_two_lines_test.go', 'Offset': 0, 'Line': 10, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Point', 'Severity': '', 'SourceLines': ['\t\t{Point{4, 0}, Point{6, 10}, Line{5, -20}},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_the_intersection_of_two_lines_test.go', 'Offset': 0, 'Line': 12, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Point', 'Severity': '', 'SourceLines': ['\t\t{Point{0, 3}, Point{10, 7}, Line{0.4, 3}},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_the_intersection_of_two_lines_test.go', 'Offset': 0, 'Line': 13, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: CreateLine', 'Severity': '', 'SourceLines': ['\t\tresult := CreateLine(test.a, test.b)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_the_intersection_of_two_lines_test.go', 'Offset': 0, 'Line': 17, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Line', 'Severity': '', 'SourceLines': ['\t\tline     Line'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_the_intersection_of_two_lines_test.go', 'Offset': 0, 'Line': 26, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Line', 'Severity': '', 'SourceLines': ['\t\t{Line{5, -20}, 5, 5},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_the_intersection_of_two_lines_test.go', 'Offset': 0, 'Line': 30, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: EvalX', 'Severity': '', 'SourceLines': ['\t\tresult := EvalX(test.line, test.x)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_the_intersection_of_two_lines_test.go', 'Offset': 0, 'Line': 35, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Intersection', 'Severity': '', 'SourceLines': ['\t\tresult, err := Intersection(test.l1, test.l2)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_find_the_intersection_of_two_lines_test.go', 'Offset': 0, 'Line': 53, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_find_the_intersection_of_two_lines_test.go', 'line': 49, 'column': 37, 'message': 'undefined: errors'}]"
First perfect square in base n with n unique digits,"Find the first perfect square in a given base N that has at least N digits and
exactly N significant unique digits when expressed in base N.

E.G. In base 10, the first perfect square with at least 10 unique digits is 1026753849 (32043²).

You may use analytical methods to reduce the search space, but the code must do a search. Do not use magic numbers or just feed the code the answer to verify it is correct.

Task
 Find and display here, on this page, the first perfect square in base N, with N significant unique digits when expressed in base N, for each of base 2 through 12. Display each number in the base N for which it was calculated.
 (optional) Do the same for bases 13 through 16.
 (stretch goal) Continue on for bases 17 - ?? (Big Integer math)


See also

 OEIS A260182: smallest square that is pandigital in base n.
Related task
 Casting out nines

",Go,"package main
 
import (
    ""fmt""
    ""math/big""
    ""strconv""
    ""time""
)
 
const maxBase = 27
const minSq36 = ""1023456789abcdefghijklmnopqrstuvwxyz""
const minSq36x = ""10123456789abcdefghijklmnopqrstuvwxyz""
 
var bigZero = new(big.Int)
var bigOne = new(big.Int).SetUint64(1)
 
func containsAll(sq string, base int) bool {
    var found [maxBase]byte
    le := len(sq)
    reps := 0
    for _, r := range sq {
        d := r - 48
        if d > 38 {
            d -= 39
        }
        found[d]++
        if found[d] > 1 {
            reps++
            if le-reps < base {
                return false
            }
        }
    }
    return true
}
 
func sumDigits(n, base *big.Int) *big.Int {
    q := new(big.Int).Set(n)
    r := new(big.Int)
    sum := new(big.Int).Set(bigZero)
    for q.Cmp(bigZero) == 1 {
        q.QuoRem(q, base, r)
        sum.Add(sum, r)
    }
    return sum
}
 
func digitalRoot(n *big.Int, base int) int {
    root := new(big.Int)
    b := big.NewInt(int64(base))
    for i := new(big.Int).Set(n); i.Cmp(b) >= 0; i.Set(root) {
        root.Set(sumDigits(i, b))
    }
    return int(root.Int64())
}
 
func minStart(base int) (string, uint64, int) {
    nn := new(big.Int)
    ms := minSq36[:base]
    nn.SetString(ms, base)
    bdr := digitalRoot(nn, base)
    var drs []int
    var ixs []uint64
    for n := uint64(1); n < uint64(2*base); n++ {
        nn.SetUint64(n * n)
        dr := digitalRoot(nn, base)
        if dr == 0 {
            dr = int(n * n)
        }
        if dr == bdr {
            ixs = append(ixs, n)
        }
        if n < uint64(base) && dr >= bdr {
            drs = append(drs, dr)
        }
    }
    inc := uint64(1)
    if len(ixs) >= 2 && base != 3 {
        inc = ixs[1] - ixs[0]
    }
    if len(drs) == 0 {
        return ms, inc, bdr
    }
    min := drs[0]
    for _, dr := range drs[1:] {
        if dr < min {
            min = dr
        }
    }
    rd := min - bdr
    if rd == 0 {
        return ms, inc, bdr
    }
    if rd == 1 {
        return minSq36x[:base+1], 1, bdr
    }
    ins := string(minSq36[rd])
    return (minSq36[:rd] + ins + minSq36[rd:])[:base+1], inc, bdr
}
 
func main() {
    start := time.Now()
    var nb, nn big.Int
    for n, k, base := uint64(2), uint64(1), 2; ; n += k {
        if base > 2 && n%uint64(base) == 0 {
            continue
        } 
        nb.SetUint64(n)
        sq := nb.Mul(&nb, &nb).Text(base)
        if !containsAll(sq, base) {
            continue
        }
        ns := strconv.FormatUint(n, base)
        tt := time.Since(start).Seconds()
        fmt.Printf(""Base %2d:%15s² = %-27s in %8.3fs\n"", base, ns, sq, tt)
        if base == maxBase {
            break
        }
        base++
        ms, inc, bdr := minStart(base)
        k = inc
        nn.SetString(ms, base)
        nb.Sqrt(&nn)
        if nb.Uint64() < n+1 {
            nb.SetUint64(n + 1)
        }
        if k != 1 {
            for {
                nn.Mul(&nb, &nb)
                dr := digitalRoot(&nn, base)
                if dr == bdr {
                    n = nb.Uint64() - k
                    break
                }
                nb.Add(&nb, bigOne)
            }
        } else {
            n = nb.Uint64() - k
        }
    }
}",3245,141,error,,,,,,,,,,,False,False,,False,
First power of 2 that has leading decimal digits of 12,"(This task is taken from a   Project Euler   problem.)

(All numbers herein are expressed in base ten.)


27   =   128   and   7   is
the first power of   2   whose leading decimal digits are   12.

The next power of   2   whose leading decimal digits
are   12   is   80,

280   =   1208925819614629174706176.



Define        p(L,n)      to be the  nth-smallest
value of    j    such that the base ten representation
of    2j    begins with the digits of    L .

    So   p(12, 1) =  7    and
         p(12, 2) = 80



You are also given that:

         p(123, 45)   =   12710



Task

   find: 
     p(12, 1)  
     p(12, 2)  
     p(123, 45)  
     p(123, 12345)  
     p(123, 678910)  
   display the results here, on this page.

",Go,"package main
 
import (
    ""fmt""
    ""math""
    ""time""
)
 
const ld10 = math.Ln2 / math.Ln10
 
func commatize(n uint64) string {
    s := fmt.Sprintf(""%d"", n)
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    return s
}
 
func p(L, n uint64) uint64 {
    i := L
    digits := uint64(1)
    for i >= 10 {
        digits *= 10
        i /= 10
    }
    count := uint64(0)
    for i = 0; count < n; i++ {
        e := math.Exp(math.Ln10 * math.Mod(float64(i)*ld10, 1))
        if uint64(math.Trunc(e*float64(digits))) == L {
            count++            
        }
    }
    return i - 1
}
 
func main() {
    start := time.Now()
    params := [][2]uint64{{12, 1}, {12, 2}, {123, 45}, {123, 12345}, {123, 678910}}
    for _, param := range params {
        fmt.Printf(""p(%d, %d) = %s\n"", param[0], param[1], commatize(p(param[0], param[1])))
    }
    fmt.Printf(""\nTook %s\n"", time.Since(start))
}",946,44,"package main

import (
    ""testing""
)

func TestP(t *testing.T) {
    tests := []struct {
        L, n, expected uint64
    }{
        {12, 1, 7},
        {12, 2, 80},
        {123, 45, 12710},
        // The following test cases are based on the problem statement
        // and may take a significant amount of time to compute.
        // They are commented out to avoid long test execution times.
        // Uncomment them if you want to run the full test suite.
        // {123, 12345, <expected_value>},
        // {123, 678910, <expected_value>},
    }

    for _, test := range tests {
        result := p(test.L, test.n)
        if result != test.expected {
            t.Errorf(""p(%d, %d) = %d; expected %d"", test.L, test.n, result, test.expected)
        }
    }
}
",./data/generated/docs_golang/first_power_of_2_that_has_leading_decimal_digits_of_12/gpt_4o_2024_08_06_first_power_of_2_that_has_leading_decimal_digits_of_12_test.go,CompileStatus.OK,0.0,52.4,,0.08,0.12,0.2,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: p', 'Severity': '', 'SourceLines': ['        result := p(test.L, test.n)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_first_power_of_2_that_has_leading_decimal_digits_of_12_test.go', 'Offset': 0, 'Line': 23, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Fivenum,"Many big data or scientific programs use boxplots to show distributions of data.   In addition, sometimes saving large arrays for boxplots can be impractical and use extreme amounts of RAM.   It can be useful to save large arrays as arrays with five numbers to save memory.

For example, the   R   programming language implements Tukey's five-number summary as the fivenum function.



Task

Given an array of numbers, compute the five-number summary.



Note
 
While these five numbers can be used to draw a boxplot,   statistical packages will typically need extra data.

Moreover, while there is a consensus about the ""box"" of the boxplot,   there are variations among statistical packages for the whiskers.



",Go,"package main
 
import (
    ""fmt""
    ""math""
    ""sort""
)
 
func fivenum(a []float64) (n5 [5]float64) {
    sort.Float64s(a)
    n := float64(len(a))
    n4 := float64((len(a)+3)/2) / 2
    d := []float64{1, n4, (n + 1) / 2, n + 1 - n4, n}
    for e, de := range d {
        floor := int(de - 1)
        ceil := int(math.Ceil(de - 1))
        n5[e] = .5 * (a[floor] + a[ceil])
    }
    return
}
 
var (
    x1 = []float64{36, 40, 7, 39, 41, 15}
    x2 = []float64{15, 6, 42, 41, 7, 36, 49, 40, 39, 47, 43}
    x3 = []float64{
        0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594,
        0.73438555, -0.03035726, 1.46675970, -0.74621349, -0.72588772,
        0.63905160, 0.61501527, -0.98983780, -1.00447874, -0.62759469,
        0.66206163, 1.04312009, -0.10305385, 0.75775634, 0.32566578,
    }
)
 
func main() {
    fmt.Println(fivenum(x1))
    fmt.Println(fivenum(x2))
    fmt.Println(fivenum(x3))
}",919,37,"package main

import (
    ""reflect""
    ""testing""
)

func TestFivenum(t *testing.T) {
    tests := []struct {
        input    []float64
        expected [5]float64
    }{
        {
            input:    []float64{36, 40, 7, 39, 41, 15},
            expected: [5]float64{7, 15, 37.5, 40, 41},
        },
        {
            input:    []float64{15, 6, 42, 41, 7, 36, 49, 40, 39, 47, 43},
            expected: [5]float64{6, 15, 41, 43, 49},
        },
        {
            input: []float64{
                0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594,
                0.73438555, -0.03035726, 1.46675970, -0.74621349, -0.72588772,
                0.63905160, 0.61501527, -0.98983780, -1.00447874, -0.62759469,
                0.66206163, 1.04312009, -0.10305385, 0.75775634, 0.32566578,
            },
            expected: [5]float64{-1.95059594, -0.74621349, 0.32566578, 0.75775634, 1.73131507},
        },
    }

    for _, test := range tests {
        result := fivenum(test.input)
        if !reflect.DeepEqual(result, test.expected) {
            t.Errorf(""fivenum(%v) = %v; expected %v"", test.input, result, test.expected)
        }
    }
}
",./data/generated/docs_golang/fivenum/gpt_4o_2024_08_06_fivenum_test.go,CompileStatus.OK,0.0,75.0,,0.05,0.33,0.123,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: fivenum', 'Severity': '', 'SourceLines': ['        result := fivenum(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fivenum_test.go', 'Offset': 0, 'Line': 33, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Flipping bits game,"The game

Given an   N×N   square array of zeroes or ones in an initial configuration,   and a target configuration of zeroes and ones.



The game is to transform one to the other in as few moves as possible by inverting whole numbered rows or whole lettered
columns at once   (as one move).

In an inversion.   any  1  becomes  0,   and any  0  becomes  1  for that whole row or column.



Task

Create a program to score for the Flipping bits game.

 The game should create an original random target configuration and a starting configuration.
 Ensure that the starting position is never the target position.
 The target position must be guaranteed as reachable from the starting position.   (One possible way to do this is to generate the start position by legal flips from a random target position.   The flips will always be reversible back to the target from the given start position).
 The number of moves taken so far should be shown.


Show an example of a short game here, on this page, for a   3×3   array of bits.



",Go,"package main
 
import (
	""fmt""
	""math/rand""
	""time""
)
 
func main() {
 
	rand.Seed(time.Now().UnixNano())
 
	var n int = 3 // Change to define board size
	var moves int = 0
 
	a := make([][]int, n)
	for i := range a {
		a[i] = make([]int, n)
		for j := range a {
			a[i][j] = rand.Intn(2)
		}
	}
 
    b := make([][]int, len(a))
	for i := range a {
		b[i] = make([]int, len(a[i]))
		copy(b[i], a[i])
	}
 
	for i := rand.Intn(100); i > 0 || compareSlices(a, b) == true; i-- {
		b = flipCol(b, rand.Intn(n) + 1)
		b = flipRow(b, rand.Intn(n) + 1)
	}
 
	fmt.Println(""Target:"")
	drawBoard(a)
	fmt.Println(""\nBoard:"")
	drawBoard(b)
 
	var rc rune
	var num int
 
	for {
		for{
			fmt.Printf(""\nFlip row (r) or column (c)  1 .. %d (c1, ...): "", n)
			_, err := fmt.Scanf(""%c%d"", &rc, &num)
			if err != nil {
				fmt.Println(err)
				continue
			}
			if num < 1 || num > n {
				fmt.Println(""Wrong command!"")
				continue
			}
			break
		}
 
		switch rc {
			case 'c':
				fmt.Printf(""Column %v will be flipped\n"", num)
				flipCol(b, num)
			case 'r':
				fmt.Printf(""Row %v will be flipped\n"", num)
				flipRow(b, num)
			default:
				fmt.Println(""Wrong command!"")
				continue
		}
 
		moves++
		fmt.Println(""\nMoves taken: "", moves)
 
		fmt.Println(""Target:"")
		drawBoard(a)
		fmt.Println(""\nBoard:"")
		drawBoard(b)
 
		if compareSlices(a, b) {
			fmt.Printf(""Finished. You win with %d moves!\n"", moves)
			break
		}
	}
}
 
func drawBoard (m [][]int) {
	fmt.Print(""   "")
	for i := range m {
		fmt.Printf(""%d "", i+1)	
	}
	for i := range m {
		fmt.Println()
		fmt.Printf(""%d "", i+1)
		for _, val := range m[i] {
			fmt.Printf("" %d"", val)
		}
	}
	fmt.Print(""\n"")
}
 
func flipRow(m [][]int, row int) ([][]int) {
	for j := range m {
		m[row-1][j] ^= 1
	}
	return m
}
 
func flipCol(m [][]int, col int) ([][]int) {
	for j := range m {
		m[j][col-1] ^= 1
	}
	return m
}
 
func compareSlices(m [][]int, n[][]int) bool {
	o := true
	for i := range m {
		for j := range m {
			if m[i][j] != n[i][j] { o = false }
		}
	}
	return o 
}",2019,122,"package main

import (
	""testing""
)

// Helper function to create a copy of a 2D slice
func copyMatrix(m [][]int) [][]int {
	copy := make([][]int, len(m))
	for i := range m {
		copy[i] = make([]int, len(m[i]))
		copy(copy[i], m[i])
	}
	return copy
}

// Test the flipRow function
func TestFlipRow(t *testing.T) {
	matrix := [][]int{
		{0, 1, 0},
		{1, 0, 1},
		{0, 0, 1},
	}

	expected := [][]int{
		{1, 0, 1},
		{1, 0, 1},
		{0, 0, 1},
	}

	result := flipRow(copyMatrix(matrix), 1)

	for i := range expected {
		for j := range expected[i] {
			if result[i][j] != expected[i][j] {
				t.Errorf(""flipRow failed at (%d, %d): expected %d, got %d"", i, j, expected[i][j], result[i][j])
			}
		}
	}
}

// Test the flipCol function
func TestFlipCol(t *testing.T) {
	matrix := [][]int{
		{0, 1, 0},
		{1, 0, 1},
		{0, 0, 1},
	}

	expected := [][]int{
		{0, 0, 0},
		{1, 1, 1},
		{0, 1, 1},
	}

	result := flipCol(copyMatrix(matrix), 2)

	for i := range expected {
		for j := range expected[i] {
			if result[i][j] != expected[i][j] {
				t.Errorf(""flipCol failed at (%d, %d): expected %d, got %d"", i, j, expected[i][j], result[i][j])
			}
		}
	}
}

// Test the compareSlices function
func TestCompareSlices(t *testing.T) {
	matrix1 := [][]int{
		{0, 1, 0},
		{1, 0, 1},
		{0, 0, 1},
	}

	matrix2 := [][]int{
		{0, 1, 0},
		{1, 0, 1},
		{0, 0, 1},
	}

	matrix3 := [][]int{
		{1, 1, 0},
		{1, 0, 1},
		{0, 0, 1},
	}

	if !compareSlices(matrix1, matrix2) {
		t.Errorf(""compareSlices failed: expected true, got false"")
	}

	if compareSlices(matrix1, matrix3) {
		t.Errorf(""compareSlices failed: expected false, got true"")
	}
}
",./data/generated/docs_golang/flipping_bits_game/gpt_4o_2024_08_06_flipping_bits_game_test.go,CompileStatus.SYNTAX_ERROR,,,,0.08,0.15,,5.0,"[{'FromLinter': 'typecheck', 'Text': 'invalid operation: cannot call non-function copy (variable of type [][]int)', 'Severity': '', 'SourceLines': ['\t\tcopy(copy[i], m[i])'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_flipping_bits_game_test.go', 'Offset': 0, 'Line': 12, 'Column': 3}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: flipRow', 'Severity': '', 'SourceLines': ['\tresult := flipRow(copyMatrix(matrix), 1)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_flipping_bits_game_test.go', 'Offset': 0, 'Line': 31, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: flipCol', 'Severity': '', 'SourceLines': ['\tresult := flipCol(copyMatrix(matrix), 2)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_flipping_bits_game_test.go', 'Offset': 0, 'Line': 56, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: compareSlices', 'Severity': '', 'SourceLines': ['\tif !compareSlices(matrix1, matrix2) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_flipping_bits_game_test.go', 'Offset': 0, 'Line': 87, 'Column': 6}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: compareSlices', 'Severity': '', 'SourceLines': ['\tif compareSlices(matrix1, matrix3) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_flipping_bits_game_test.go', 'Offset': 0, 'Line': 91, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_flipping_bits_game_test.go', 'line': 12, 'column': 3, 'message': 'invalid operation: cannot call non-function copy (variable of type [][]int)'}]"
Floyd-Warshall algorithm,"The Floyd–Warshall algorithm is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights.




Task
Find the lengths of the shortest paths between all pairs of vertices of the given directed graph. Your code may assume that the input has already been checked for loops, parallel edges and negative cycles.


Print the pair, the distance and (optionally) the path.




Example
pair     dist    path
1 -> 2    -1     1 -> 3 -> 4 -> 2
1 -> 3    -2     1 -> 3
1 -> 4     0     1 -> 3 -> 4
2 -> 1     4     2 -> 1
2 -> 3     2     2 -> 1 -> 3
2 -> 4     4     2 -> 1 -> 3 -> 4
3 -> 1     5     3 -> 4 -> 2 -> 1
3 -> 2     1     3 -> 4 -> 2
3 -> 4     2     3 -> 4
4 -> 1     3     4 -> 2 -> 1
4 -> 2    -1     4 -> 2
4 -> 3     1     4 -> 2 -> 1 -> 3


See also
 Floyd-Warshall Algorithm - step by step guide (youtube)

",Go,"package main
 
import (
  ""fmt""
  ""strconv""
)
 
// A Graph is the interface implemented by graphs that
// this algorithm can run on.
type Graph interface {
  Vertices() []Vertex
  Neighbors(v Vertex) []Vertex
  Weight(u, v Vertex) int
}
 
// Nonnegative integer ID of vertex
type Vertex int
 
// ig is a graph of integers that satisfies the Graph interface.
type ig struct {
  vert  []Vertex
  edges map[Vertex]map[Vertex]int
}
 
func (g ig) edge(u, v Vertex, w int) {
  if _, ok := g.edges[u]; !ok {
    g.edges[u] = make(map[Vertex]int)
  }
  g.edges[u][v] = w
}
func (g ig) Vertices() []Vertex { return g.vert }
func (g ig) Neighbors(v Vertex) (vs []Vertex) {
  for k := range g.edges[v] {
    vs = append(vs, k)
  }
  return vs
}
func (g ig) Weight(u, v Vertex) int { return g.edges[u][v] }
func (g ig) path(vv []Vertex) (s string) {
  if len(vv) == 0 {
    return """"
  }
  s = strconv.Itoa(int(vv[0]))
  for _, v := range vv[1:] {
    s += "" -> "" + strconv.Itoa(int(v))
  }
  return s
}
 
const Infinity = int(^uint(0) >> 1)
 
func FloydWarshall(g Graph) (dist map[Vertex]map[Vertex]int, next map[Vertex]map[Vertex]*Vertex) {
  vert := g.Vertices()
  dist = make(map[Vertex]map[Vertex]int)
  next = make(map[Vertex]map[Vertex]*Vertex)
  for _, u := range vert {
    dist[u] = make(map[Vertex]int)
    next[u] = make(map[Vertex]*Vertex)
    for _, v := range vert {
      dist[u][v] = Infinity
    }
    dist[u][u] = 0
    for _, v := range g.Neighbors(u) {
      v := v
      dist[u][v] = g.Weight(u, v)
      next[u][v] = &v
    }
  }
  for _, k := range vert {
    for _, i := range vert {
      for _, j := range vert {
        if dist[i][k] < Infinity && dist[k][j] < Infinity {
          if dist[i][j] > dist[i][k]+dist[k][j] {
            dist[i][j] = dist[i][k] + dist[k][j]
            next[i][j] = next[i][k]
          }
        }
      }
    }
  }
  return dist, next
}
 
func Path(u, v Vertex, next map[Vertex]map[Vertex]*Vertex) (path []Vertex) {
  if next[u][v] == nil {
    return
  }
  path = []Vertex{u}
  for u != v {
    u = *next[u][v]
    path = append(path, u)
  }
  return path
}
 
func main() {
  g := ig{[]Vertex{1, 2, 3, 4}, make(map[Vertex]map[Vertex]int)}
  g.edge(1, 3, -2)
  g.edge(3, 4, 2)
  g.edge(4, 2, -1)
  g.edge(2, 1, 4)
  g.edge(2, 3, 3)
 
  dist, next := FloydWarshall(g)
  fmt.Println(""pair\tdist\tpath"")
  for u, m := range dist {
    for v, d := range m {
      if u != v {
        fmt.Printf(""%d -> %d\t%3d\t%s\n"", u, v, d, g.path(Path(u, v, next)))
      }
    }
  }
}",2516,113,"package main

import (
	""testing""
	""reflect""
)

func TestFloydWarshall(t *testing.T) {
	g := ig{[]Vertex{1, 2, 3, 4}, make(map[Vertex]map[Vertex]int)}
	g.edge(1, 3, -2)
	g.edge(3, 4, 2)
	g.edge(4, 2, -1)
	g.edge(2, 1, 4)
	g.edge(2, 3, 3)

	expectedDist := map[Vertex]map[Vertex]int{
		1: {1: 0, 2: -1, 3: -2, 4: 0},
		2: {1: 4, 2: 0, 3: 2, 4: 4},
		3: {1: 5, 2: 1, 3: 0, 4: 2},
		4: {1: 3, 2: -1, 3: 1, 4: 0},
	}

	expectedNext := map[Vertex]map[Vertex]*Vertex{
		1: {2: &Vertex(3), 3: &Vertex(3), 4: &Vertex(3)},
		2: {1: &Vertex(1), 3: &Vertex(1), 4: &Vertex(1)},
		3: {1: &Vertex(4), 2: &Vertex(4), 4: &Vertex(4)},
		4: {1: &Vertex(2), 2: &Vertex(2), 3: &Vertex(2)},
	}

	dist, next := FloydWarshall(g)

	if !reflect.DeepEqual(dist, expectedDist) {
		t.Errorf(""Expected dist: %v, got: %v"", expectedDist, dist)
	}

	for u, m := range expectedNext {
		for v, expNext := range m {
			if next[u][v] == nil || *next[u][v] != *expNext {
				t.Errorf(""Expected next[%d][%d]: %v, got: %v"", u, v, *expNext, next[u][v])
			}
		}
	}
}

func TestPath(t *testing.T) {
	next := map[Vertex]map[Vertex]*Vertex{
		1: {2: &Vertex(3), 3: &Vertex(3), 4: &Vertex(3)},
		2: {1: &Vertex(1), 3: &Vertex(1), 4: &Vertex(1)},
		3: {1: &Vertex(4), 2: &Vertex(4), 4: &Vertex(4)},
		4: {1: &Vertex(2), 2: &Vertex(2), 3: &Vertex(2)},
	}

	tests := []struct {
		u, v   Vertex
		expect []Vertex
	}{
		{1, 2, []Vertex{1, 3, 4, 2}},
		{1, 3, []Vertex{1, 3}},
		{1, 4, []Vertex{1, 3, 4}},
		{2, 1, []Vertex{2, 1}},
		{2, 3, []Vertex{2, 1, 3}},
		{2, 4, []Vertex{2, 1, 3, 4}},
		{3, 1, []Vertex{3, 4, 2, 1}},
		{3, 2, []Vertex{3, 4, 2}},
		{3, 4, []Vertex{3, 4}},
		{4, 1, []Vertex{4, 2, 1}},
		{4, 2, []Vertex{4, 2}},
		{4, 3, []Vertex{4, 2, 1, 3}},
	}

	for _, test := range tests {
		path := Path(test.u, test.v, next)
		if !reflect.DeepEqual(path, test.expect) {
			t.Errorf(""Expected path from %d to %d: %v, got: %v"", test.u, test.v, test.expect, path)
		}
	}
}
",./data/generated/docs_golang/floyd_warshall_algorithm/gpt_4o_2024_08_06_floyd_warshall_algorithm_test.go,CompileStatus.SYNTAX_ERROR,,,,0.06,0.12,,6.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: ig', 'Severity': '', 'SourceLines': ['\tg := ig{[]Vertex{1, 2, 3, 4}, make(map[Vertex]map[Vertex]int)}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_floyd_warshall_algorithm_test.go', 'Offset': 0, 'Line': 9, 'Column': 7}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Vertex', 'Severity': '', 'SourceLines': ['\texpectedDist := map[Vertex]map[Vertex]int{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_floyd_warshall_algorithm_test.go', 'Offset': 0, 'Line': 16, 'Column': 22}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Vertex', 'Severity': '', 'SourceLines': ['\texpectedNext := map[Vertex]map[Vertex]*Vertex{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_floyd_warshall_algorithm_test.go', 'Offset': 0, 'Line': 23, 'Column': 22}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Vertex', 'Severity': '', 'SourceLines': ['\t\t1: {2: &Vertex(3), 3: &Vertex(3), 4: &Vertex(3)},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_floyd_warshall_algorithm_test.go', 'Offset': 0, 'Line': 24, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: FloydWarshall', 'Severity': '', 'SourceLines': ['\tdist, next := FloydWarshall(g)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_floyd_warshall_algorithm_test.go', 'Offset': 0, 'Line': 30, 'Column': 16}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Path', 'Severity': '', 'SourceLines': ['\t\tpath := Path(test.u, test.v, next)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_floyd_warshall_algorithm_test.go', 'Offset': 0, 'Line': 72, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_floyd_warshall_algorithm_test.go', 'line': 24, 'column': 11, 'message': 'invalid operation: cannot take address of Vertex(3) (constant 3 of type Vertex)'}]"
Four bit adder,"Task

""Simulate"" a four-bit adder.

This design can be realized using four 1-bit full adders.
Each of these 1-bit full adders can be built with two half adders and an   or   gate. ;

Finally a half adder can be made using an   xor   gate and an   and   gate.

The   xor   gate can be made using two   nots,   two   ands   and one   or.

Not,   or   and   and,   the only allowed ""gates"" for the task, can be ""imitated"" by using the bitwise operators of your language.

If there is not a bit type in your language, to be sure that the   not   does not ""invert"" all the other bits of the basic type   (e.g. a byte)   we are not interested in,   you can use an extra   nand   (and   then   not)   with the constant   1   on one input.

Instead of optimizing and reducing the number of gates used for the final 4-bit adder,   build it in the most straightforward way,   connecting the other ""constructive blocks"",   in turn made of ""simpler"" and ""smaller"" ones.


Schematics of the ""constructive blocks""


(Xor gate with ANDs, ORs and NOTs)        

   (A half adder)        

          (A full adder)            

                (A 4-bit adder)        












Solutions should try to be as descriptive as possible, making it as easy as possible to identify ""connections"" between higher-order ""blocks"".

It is not mandatory to replicate the syntax of higher-order blocks in the atomic ""gate"" blocks, i.e. basic ""gate"" operations can be performed as usual bitwise operations, or they can be ""wrapped"" in a block in order to expose the same syntax of higher-order blocks, at implementers' choice.

To test the implementation, show the sum of two four-bit numbers (in binary).



",Go,"package main
 
import ""fmt""
 
func xor(a, b byte) byte {
    return a&(^b) | b&(^a)
}
 
func ha(a, b byte) (s, c byte) {
    return xor(a, b), a & b
}
 
func fa(a, b, c0 byte) (s, c1 byte) {
    sa, ca := ha(a, c0)
    s, cb := ha(sa, b)
    c1 = ca | cb
    return
}
 
func add4(a3, a2, a1, a0, b3, b2, b1, b0 byte) (v, s3, s2, s1, s0 byte) {
    s0, c0 := fa(a0, b0, 0)
    s1, c1 := fa(a1, b1, c0)
    s2, c2 := fa(a2, b2, c1)
    s3, v = fa(a3, b3, c2)
    return
}
 
func main() {
    // add 10+9  result should be 1 0 0 1 1
    fmt.Println(add4(1, 0, 1, 0, 1, 0, 0, 1))
}",577,31,"package main

import (
	""testing""
)

func TestXor(t *testing.T) {
	tests := []struct {
		a, b, expected byte
	}{
		{0, 0, 0},
		{0, 1, 1},
		{1, 0, 1},
		{1, 1, 0},
	}

	for _, test := range tests {
		result := xor(test.a, test.b)
		if result != test.expected {
			t.Errorf(""xor(%d, %d) = %d; expected %d"", test.a, test.b, result, test.expected)
		}
	}
}

func TestHalfAdder(t *testing.T) {
	tests := []struct {
		a, b, expectedS, expectedC byte
	}{
		{0, 0, 0, 0},
		{0, 1, 1, 0},
		{1, 0, 1, 0},
		{1, 1, 0, 1},
	}

	for _, test := range tests {
		s, c := ha(test.a, test.b)
		if s != test.expectedS || c != test.expectedC {
			t.Errorf(""ha(%d, %d) = (%d, %d); expected (%d, %d)"", test.a, test.b, s, c, test.expectedS, test.expectedC)
		}
	}
}

func TestFullAdder(t *testing.T) {
	tests := []struct {
		a, b, c0, expectedS, expectedC1 byte
	}{
		{0, 0, 0, 0, 0},
		{0, 1, 0, 1, 0},
		{1, 0, 0, 1, 0},
		{1, 1, 0, 0, 1},
		{0, 0, 1, 1, 0},
		{0, 1, 1, 0, 1},
		{1, 0, 1, 0, 1},
		{1, 1, 1, 1, 1},
	}

	for _, test := range tests {
		s, c1 := fa(test.a, test.b, test.c0)
		if s != test.expectedS || c1 != test.expectedC1 {
			t.Errorf(""fa(%d, %d, %d) = (%d, %d); expected (%d, %d)"", test.a, test.b, test.c0, s, c1, test.expectedS, test.expectedC1)
		}
	}
}

func TestFourBitAdder(t *testing.T) {
	tests := []struct {
		a3, a2, a1, a0, b3, b2, b1, b0 byte
		expectedV, expectedS3, expectedS2, expectedS1, expectedS0 byte
	}{
		{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
		{0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0},
		{0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0},
		{0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0},
		{1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1}, // 10 + 9 = 19 (1 0 0 1 1)
	}

	for _, test := range tests {
		v, s3, s2, s1, s0 := add4(test.a3, test.a2, test.a1, test.a0, test.b3, test.b2, test.b1, test.b0)
		if v != test.expectedV || s3 != test.expectedS3 || s2 != test.expectedS2 || s1 != test.expectedS1 || s0 != test.expectedS0 {
			t.Errorf(""add4(%d, %d, %d, %d, %d, %d, %d, %d) = (%d, %d, %d, %d, %d); expected (%d, %d, %d, %d, %d)"",
				test.a3, test.a2, test.a1, test.a0, test.b3, test.b2, test.b1, test.b0,
				v, s3, s2, s1, s0,
				test.expectedV, test.expectedS3, test.expectedS2, test.expectedS1, test.expectedS0)
		}
	}
}
",./data/generated/docs_golang/four_bit_adder/gpt_4o_2024_08_06_four_bit_adder_test.go,CompileStatus.OK,0.0,91.7,,0.07,0.8,0.13,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: xor', 'Severity': '', 'SourceLines': ['\t\tresult := xor(test.a, test.b)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_four_bit_adder_test.go', 'Offset': 0, 'Line': 18, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: ha', 'Severity': '', 'SourceLines': ['\t\ts, c := ha(test.a, test.b)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_four_bit_adder_test.go', 'Offset': 0, 'Line': 36, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fa', 'Severity': '', 'SourceLines': ['\t\ts, c1 := fa(test.a, test.b, test.c0)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_four_bit_adder_test.go', 'Offset': 0, 'Line': 58, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: add4', 'Severity': '', 'SourceLines': ['\t\tv, s3, s2, s1, s0 := add4(test.a3, test.a2, test.a1, test.a0, test.b3, test.b2, test.b1, test.b0)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_four_bit_adder_test.go', 'Offset': 0, 'Line': 78, 'Column': 24}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Four is magic,"Task

Write a subroutine, function, whatever it may be called in your language, that takes an integer number and returns an English text sequence starting with the English cardinal representation of that integer, the word 'is' and then the English cardinal representation of the count of characters that made up the first word, followed by a comma.

Continue the sequence by using the previous count word as the first word of the next phrase, append 'is' and the cardinal count of the letters in that word.

Continue until you reach four. Since four has four characters, finish by adding the words 'four is magic' and a period. All integers will eventually wind up at four.

For instance, suppose your are given the integer 3. Convert 3 to Three, add  is , then the cardinal character count of three, or five, with a comma to separate if from the next phrase. Continue the sequence five is four, (five has four letters), and finally, four is magic.

     Three is five, five is four, four is magic.

For reference, here are outputs for 0 through 9.

     Zero is four, four is magic.
     One is three, three is five, five is four, four is magic.
     Two is three, three is five, five is four, four is magic.
     Three is five, five is four, four is magic.
     Four is magic.
     Five is four, four is magic.
     Six is three, three is five, five is four, four is magic.
     Seven is five, five is four, four is magic.
     Eight is five, five is four, four is magic.
     Nine is four, four is magic.



Some task guidelines

 You may assume the input will only contain integer numbers.
 Cardinal numbers between 20 and 100 may use either hyphens or spaces as word separators but they must use a word separator. (23 is twenty three or twenty-three not twentythree.)
 Cardinal number conversions should follow the  English short scale. (billion is 1e9, trillion is 1e12, etc.)
 Cardinal numbers should not include commas. (20140 is twenty thousand one hundred forty not twenty thousand, one hundred forty.)
 When converted to a string, 100 should be one hundred, not a hundred or hundred, 1000 should be one thousand, not a thousand or thousand.
 When converted to a string, there should be no and in the cardinal string. 130 should be one hundred thirty not one hundred and thirty.
 When counting characters, count all of the characters in the cardinal number including spaces and hyphens. One hundred fifty-one should be 21 not 18.
 The output should follow the format ""N is K, K is M, M is ... four is magic."" (unless the input is 4, in which case the output should simply be ""four is magic."")
 The output can either be the return value from the function, or be displayed from within the function.
 You are encouraged, though not mandated to use proper sentence capitalization.
 You may optionally support negative numbers. -7 is negative seven.
 Show the output here for a small representative sample of values, at least 5 but no more than 25. You are free to choose which which numbers to use for output demonstration.


You can choose to use a library, (module, external routine, whatever) to do the cardinal conversions as long as the code is easily and freely available to the public.

If you roll your own, make the routine accept at minimum any integer from 0 up to 999999. If you use a pre-made library, support at least up to unsigned 64 bit integers. (or the largest integer supported in your language if it is less.)

Four is magic is a popular code-golf task. This is not code golf. Write legible, idiomatic and well formatted code.




Related tasks

   Four is the number of_letters in the ...
   Look-and-say sequence
   Number names
   Self-describing numbers
   Summarize and say sequence
   Spelling of ordinal numbers
   De Bruijn sequences

",Go,"package main
 
import (
	""fmt""
	""math""
	""strings""
)
 
func main() {
	for _, n := range [...]int64{
		0, 4, 6, 11, 13, 75, 100, 337, -164,
		math.MaxInt64,
	} {
		fmt.Println(fourIsMagic(n))
	}
}
 
func fourIsMagic(n int64) string {
	s := say(n)
	s = strings.ToUpper(s[:1]) + s[1:]
	t := s
	for n != 4 {
		n = int64(len(s))
		s = say(n)
		t += "" is "" + s + "", "" + s
	}
	t += "" is magic.""
	return t
}
 
// Following is from https://rosettacode.org/wiki/Number_names#Go
 
var small = [...]string{""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"",
	""seven"", ""eight"", ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"",
	""fourteen"", ""fifteen"", ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen""}
var tens = [...]string{"""", """", ""twenty"", ""thirty"", ""forty"",
	""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""}
var illions = [...]string{"""", "" thousand"", "" million"", "" billion"",
	"" trillion"", "" quadrillion"", "" quintillion""}
 
func say(n int64) string {
	var t string
	if n < 0 {
		t = ""negative ""
		// Note, for math.MinInt64 this leaves n negative.
		n = -n
	}
	switch {
	case n < 20:
		t += small[n]
	case n < 100:
		t += tens[n/10]
		s := n % 10
		if s > 0 {
			t += ""-"" + small[s]
		}
	case n < 1000:
		t += small[n/100] + "" hundred""
		s := n % 100
		if s > 0 {
			t += "" "" + say(s)
		}
	default:
		// work right-to-left
		sx := """"
		for i := 0; n > 0; i++ {
			p := n % 1000
			n /= 1000
			if p > 0 {
				ix := say(p) + illions[i]
				if sx != """" {
					ix += "" "" + sx
				}
				sx = ix
			}
		}
		t += sx
	}
	return t
}",1510,80,"package main

import (
	""testing""
)

func TestFourIsMagic(t *testing.T) {
	tests := []struct {
		input    int64
		expected string
	}{
		{0, ""Zero is four, four is magic.""},
		{1, ""One is three, three is five, five is four, four is magic.""},
		{2, ""Two is three, three is five, five is four, four is magic.""},
		{3, ""Three is five, five is four, four is magic.""},
		{4, ""Four is magic.""},
		{5, ""Five is four, four is magic.""},
		{6, ""Six is three, three is five, five is four, four is magic.""},
		{7, ""Seven is five, five is four, four is magic.""},
		{8, ""Eight is five, five is four, four is magic.""},
		{9, ""Nine is four, four is magic.""},
		{11, ""Eleven is six, six is three, three is five, five is four, four is magic.""},
		{13, ""Thirteen is eight, eight is five, five is four, four is magic.""},
		{75, ""Seventy-five is ten, ten is three, three is five, five is four, four is magic.""},
		{100, ""One hundred is ten, ten is three, three is five, five is four, four is magic.""},
		{337, ""Three hundred thirty-seven is twenty-three, twenty-three is eleven, eleven is six, six is three, three is five, five is four, four is magic.""},
		{-164, ""Negative one hundred sixty-four is twenty-four, twenty-four is eleven, eleven is six, six is three, three is five, five is four, four is magic.""},
	}

	for _, test := range tests {
		t.Run("""", func(t *testing.T) {
			result := fourIsMagic(test.input)
			if result != test.expected {
				t.Errorf(""Expected %q but got %q"", test.expected, result)
			}
		})
	}
}
",./data/generated/docs_golang/four_is_magic/gpt_4o_2024_08_06_four_is_magic_test.go,CompileStatus.OK,0.0,66.7,,0.04,0.07,0.12,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: fourIsMagic', 'Severity': '', 'SourceLines': ['\t\t\tresult := fourIsMagic(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_four_is_magic_test.go', 'Offset': 0, 'Line': 32, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,70.59,False,[]
Fractran,"FRACTRAN is a Turing-complete esoteric programming language invented by the mathematician John Horton Conway.

A FRACTRAN program is an ordered list of positive fractions 



P
=
(

f

1


,

f

2


,
…
,

f

m


)


{\displaystyle P=(f_{1},f_{2},\ldots ,f_{m})}

, together with an initial positive integer input 



n


{\displaystyle n}

.



The program is run by updating the integer 



n


{\displaystyle n}

 as follows:

 for the first fraction, 




f

i




{\displaystyle f_{i}}

, in the list for which 



n

f

i




{\displaystyle nf_{i}}

 is an integer, replace 



n


{\displaystyle n}

 with 



n

f

i




{\displaystyle nf_{i}}

 ;
 repeat this rule until no fraction in the list produces an integer when multiplied by 



n


{\displaystyle n}

, then halt.


Conway gave a program for primes in FRACTRAN:

 



17

/

91


{\displaystyle 17/91}

, 



78

/

85


{\displaystyle 78/85}

, 



19

/

51


{\displaystyle 19/51}

, 



23

/

38


{\displaystyle 23/38}

, 



29

/

33


{\displaystyle 29/33}

, 



77

/

29


{\displaystyle 77/29}

, 



95

/

23


{\displaystyle 95/23}

, 



77

/

19


{\displaystyle 77/19}

, 



1

/

17


{\displaystyle 1/17}

, 



11

/

13


{\displaystyle 11/13}

, 



13

/

11


{\displaystyle 13/11}

, 



15

/

14


{\displaystyle 15/14}

, 



15

/

2


{\displaystyle 15/2}

, 



55

/

1


{\displaystyle 55/1}


Starting with 



n
=
2


{\displaystyle n=2}

, this FRACTRAN program will change 



n


{\displaystyle n}

 to 



15
=
2
×
(
15

/

2
)


{\displaystyle 15=2\times (15/2)}

, then 



825
=
15
×
(
55

/

1
)


{\displaystyle 825=15\times (55/1)}

, generating the following sequence of integers:

 



2


{\displaystyle 2}

, 



15


{\displaystyle 15}

, 



825


{\displaystyle 825}

, 



725


{\displaystyle 725}

, 



1925


{\displaystyle 1925}

, 



2275


{\displaystyle 2275}

, 



425


{\displaystyle 425}

, 



390


{\displaystyle 390}

, 



330


{\displaystyle 330}

, 



290


{\displaystyle 290}

, 



770


{\displaystyle 770}

, 



…


{\displaystyle \ldots }


After 2, this sequence contains the following powers of 2:






2

2


=
4


{\displaystyle 2^{2}=4}

, 




2

3


=
8


{\displaystyle 2^{3}=8}

, 




2

5


=
32


{\displaystyle 2^{5}=32}

, 




2

7


=
128


{\displaystyle 2^{7}=128}

, 




2

11


=
2048


{\displaystyle 2^{11}=2048}

, 




2

13


=
8192


{\displaystyle 2^{13}=8192}

, 




2

17


=
131072


{\displaystyle 2^{17}=131072}

, 




2

19


=
524288


{\displaystyle 2^{19}=524288}

, 



…


{\displaystyle \ldots }


which are the prime powers of 2.



Task

Write a program that reads a list of fractions in a natural format from the keyboard or from a string,
to parse it into a sequence of fractions (i.e. two integers),
and runs the FRACTRAN starting from a provided integer, writing the result at each step.
It is also required that the number of steps is limited (by a parameter easy to find).



Extra credit

Use this program to derive the first 20 or so prime numbers.



See also

For more on how to program FRACTRAN as a universal programming language, see:

 J. H. Conway (1987). Fractran: A Simple Universal Programming Language for Arithmetic. In: Open Problems in Communication and Computation, pages 4–26. Springer.
 J. H. Conway (2010). ""FRACTRAN: A simple universal programming language for arithmetic"". In Jeffrey C. Lagarias. The Ultimate Challenge: the 3x+1 problem. American Mathematical Society. pp. 249–264. ISBN 978-0-8218-4940-8. Zbl 1216.68068.
 Number Pathology: Fractran by Mark C. Chu-Carroll; October 27, 2006.

",Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math/big""
    ""os""
    ""strconv""
    ""strings""
)
 
func compile(src string) ([]big.Rat, bool) {
    s := strings.Fields(src)
    r := make([]big.Rat, len(s))
    for i, s1 := range s {
        if _, ok := r[i].SetString(s1); !ok {
            return nil, false
        }
    }
    return r, true
}
 
func exec(p []big.Rat, n *big.Int, limit int) {
    var q, r big.Int
rule:
    for i := 0; i < limit; i++ {
        fmt.Printf(""%d "", n)
        for j := range p {
            q.QuoRem(n, p[j].Denom(), &r)
            if r.BitLen() == 0 {
                n.Mul(&q, p[j].Num())
                continue rule
            }
        }
        break
    }
    fmt.Println()
}
 
func usage() {
    log.Fatal(""usage: ft <limit> <n> <prog>"")
}
 
func main() {
    if len(os.Args) != 4 {
        usage()
    }
    limit, err := strconv.Atoi(os.Args[1])
    if err != nil {
        usage()
    }
    var n big.Int
    _, ok := n.SetString(os.Args[2], 10)
    if !ok {
        usage()
    }
    p, ok := compile(os.Args[3])
    if !ok {
        usage()
    }
    exec(p, &n, limit)
}",1121,62,none,,,,,,,,,,,False,False,,False,
Fusc sequence,"

Definitions

The   fusc   integer sequence is defined as:

   fusc(0) = 0
   fusc(1) = 1
   for n>1,   the   nth   term is defined as:
   if   n   is even;     fusc(n) = fusc(n/2)
   if   n   is   odd;     fusc(n) = fusc((n-1)/2)   +   fusc((n+1)/2)


Note that MathWorld's definition starts with unity, not zero.   This task will be using the OEIS' version   (above).



An observation

   fusc(A) = fusc(B)
where   A   is some non-negative integer expressed in binary,   and
where   B   is the binary value of   A   reversed.



Fusc numbers are also known as:

   fusc function   (named by Dijkstra, 1982)
   Stern's Diatomic series   (although it starts with unity, not zero)
   Stern-Brocot sequence   (although it starts with unity, not zero)


Task

   show the first   61   fusc numbers (starting at zero) in a horizontal format.
   show the fusc number (and its index) whose length is greater than any previous fusc number length.
   (the length is the number of decimal digits when the fusc number is expressed in base ten.)
   show all numbers with commas   (if appropriate).
   show all output here.


Related task

   RosettaCode Stern-Brocot sequence


Also see

   the MathWorld entry:   Stern's Diatomic Series.
   the OEIS entry:   A2487.

",Go,"package main
 
import (
    ""fmt""
    ""strconv""
)
 
func fusc(n int) []int {
    if n <= 0 {
        return []int{}
    }
    if n == 1 {
        return []int{0}
    }    
    res := make([]int, n)
    res[0] = 0
    res[1] = 1
    for i := 2; i < n; i++ {
        if i%2 == 0 {
            res[i] = res[i/2]
        } else {
            res[i] = res[(i-1)/2] + res[(i+1)/2]
        }
    }
    return res
}
 
func fuscMaxLen(n int) [][2]int {
    maxLen := -1
    maxFusc := -1
    f := fusc(n)
    var res [][2]int
    for i := 0; i < n; i++ {
        if f[i] <= maxFusc {
            continue // avoid expensive strconv operation where possible
        }
        maxFusc = f[i]
        le := len(strconv.Itoa(f[i]))
        if le > maxLen {
            res = append(res, [2]int{i, f[i]})
            maxLen = le
        }
    }
    return res
}
 
func commatize(n int) string {
    s := fmt.Sprintf(""%d"", n)
    if n < 0 {
        s = s[1:]
    }
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    if n >= 0 {
        return s
    }
    return ""-"" + s
}
 
func main() {
    fmt.Println(""The first 61 fusc numbers are:"")
    fmt.Println(fusc(61))
    fmt.Println(""\nThe fusc numbers whose length > any previous fusc number length are:"")
    res := fuscMaxLen(20000000)  // examine first twenty million numbers say
    for i := 0; i < len(res); i++ {
        fmt.Printf(""%7s (index %10s)\n"", commatize(res[i][1]), commatize(res[i][0]))
    }
}",1491,70,"package main

import (
    ""testing""
    ""reflect""
)

// Test the fusc function
func TestFusc(t *testing.T) {
    tests := []struct {
        input    int
        expected []int
    }{
        {0, []int{}},
        {1, []int{0}},
        {2, []int{0, 1}},
        {3, []int{0, 1, 1}},
        {4, []int{0, 1, 1, 2}},
        {5, []int{0, 1, 1, 2, 1}},
        {10, []int{0, 1, 1, 2, 1, 3, 1, 4, 3, 5}},
        {61, []int{0, 1, 1, 2, 1, 3, 1, 4, 3, 5, 1, 6, 1, 7, 5, 8, 3, 9, 5, 10, 1, 11, 1, 12, 7, 13, 5, 14, 9, 15, 1, 16, 1, 17, 11, 18, 7, 19, 11, 20, 3, 21, 5, 22, 13, 23, 9, 24, 13, 25, 1, 26, 1, 27, 17, 28, 11, 29, 17, 30, 5}},
    }

    for _, test := range tests {
        result := fusc(test.input)
        if !reflect.DeepEqual(result, test.expected) {
            t.Errorf(""fusc(%d) = %v; want %v"", test.input, result, test.expected)
        }
    }
}

// Test the fuscMaxLen function
func TestFuscMaxLen(t *testing.T) {
    tests := []struct {
        input    int
        expected [][2]int
    }{
        {10, [][2]int{{1, 1}, {3, 2}, {5, 3}, {7, 4}, {9, 5}}},
        {20, [][2]int{{1, 1}, {3, 2}, {5, 3}, {7, 4}, {9, 5}, {11, 6}, {13, 7}, {15, 8}, {17, 9}, {19, 10}}},
    }

    for _, test := range tests {
        result := fuscMaxLen(test.input)
        if !reflect.DeepEqual(result, test.expected) {
            t.Errorf(""fuscMaxLen(%d) = %v; want %v"", test.input, result, test.expected)
        }
    }
}

// Test the commatize function
func TestCommatize(t *testing.T) {
    tests := []struct {
        input    int
        expected string
    }{
        {0, ""0""},
        {1, ""1""},
        {1000, ""1,000""},
        {1000000, ""1,000,000""},
        {-1000, ""-1,000""},
        {-1000000, ""-1,000,000""},
    }

    for _, test := range tests {
        result := commatize(test.input)
        if result != test.expected {
            t.Errorf(""commatize(%d) = %s; want %s"", test.input, result, test.expected)
        }
    }
}
",./data/generated/docs_golang/fusc_sequence/gpt_4o_2024_08_06_fusc_sequence_test.go,CompileStatus.OK,0.0,85.0,,0.07,0.2,0.176,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: fusc', 'Severity': '', 'SourceLines': ['        result := fusc(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fusc_sequence_test.go', 'Offset': 0, 'Line': 25, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fuscMaxLen', 'Severity': '', 'SourceLines': ['        result := fuscMaxLen(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fusc_sequence_test.go', 'Offset': 0, 'Line': 43, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: commatize', 'Severity': '', 'SourceLines': ['        result := commatize(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_fusc_sequence_test.go', 'Offset': 0, 'Line': 65, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,33.33,False,[]
Galton box animation," Example of a Galton Box at the end of animation.


A   Galton device   Sir Francis Galton's device   is also known as a   bean machine,   a   Galton Board,   or a   quincunx.



Description of operation

In a Galton box, there are a set of pins arranged in a triangular pattern.   A number of balls are dropped so that they fall in line with the top pin, deflecting to the left or the right of the pin.   The ball continues to fall to the left or right of lower pins before arriving at one of the collection points between and to the sides of the bottom row of pins.

Eventually the balls are collected into bins at the bottom   (as shown in the image),   the ball column heights in the bins approximate a   bell curve.   Overlaying   Pascal's triangle   onto the pins shows the number of different paths that can be taken to get to each bin.



Task

Generate an animated simulation of a Galton device.



Task requirements

   The box should have at least 5 pins on the bottom row. 
   A solution can use graphics or ASCII animation. 
   Provide a sample of the output/display such as a screenshot.
   There can be one or more balls in flight at the same time. 
   If multiple balls are in flight, ensure they don't interfere with each other.
   A solution should allow users to specify the number of balls, or it should run until full or a preset limit. 
   Optionally,   display the number of balls.

",Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
const boxW = 41      // Galton box width
const boxH = 37      // Galton box height.
const pinsBaseW = 19 // Pins triangle base.
const nMaxBalls = 55 // Number of balls.
 
const centerH = pinsBaseW + (boxW-pinsBaseW*2+1)/2 - 1
 
const (
    empty  = ' '
    ball   = 'o'
    wall   = '|'
    corner = '+'
    floor  = '-'
    pin    = '.'
)
 
type Ball struct{ x, y int }
 
func newBall(x, y int) *Ball {
    if box[y][x] != empty {
        panic(""Tried to create a new ball in a non-empty cell. Program terminated."")
    }
    b := Ball{x, y}
    box[y][x] = ball
    return &b
}
 
func (b *Ball) doStep() {
    if b.y <= 0 {
        return // Reached the bottom of the box.
    }
    cell := box[b.y-1][b.x]
    switch cell {
    case empty:
        box[b.y][b.x] = empty
        b.y--
        box[b.y][b.x] = ball
    case pin:
        box[b.y][b.x] = empty
        b.y--
        if box[b.y][b.x-1] == empty && box[b.y][b.x+1] == empty {
            b.x += rand.Intn(2)*2 - 1
            box[b.y][b.x] = ball
            return
        } else if box[b.y][b.x-1] == empty {
            b.x++
        } else {
            b.x--
        }
        box[b.y][b.x] = ball
    default:
        // It's frozen - it always piles on other balls.
    }
}
 
type Cell = byte
 
/* Galton box. Will be printed upside down. */
var box [boxH][boxW]Cell
 
func initializeBox() {
    // Set ceiling and floor
    box[0][0] = corner
    box[0][boxW-1] = corner
    for i := 1; i < boxW-1; i++ {
        box[0][i] = floor
    }
    for i := 0; i < boxW; i++ {
        box[boxH-1][i] = box[0][i]
    }
 
    // Set walls
    for r := 1; r < boxH-1; r++ {
        box[r][0] = wall
        box[r][boxW-1] = wall
    }
 
    // Set rest to empty initially
    for i := 1; i < boxH-1; i++ {
        for j := 1; j < boxW-1; j++ {
            box[i][j] = empty
        }
    }
 
    // Set pins
    for nPins := 1; nPins <= pinsBaseW; nPins++ {
        for p := 0; p < nPins; p++ {
            box[boxH-2-nPins][centerH+1-nPins+p*2] = pin
        }
    }
}
 
func drawBox() {
    for r := boxH - 1; r >= 0; r-- {
        for c := 0; c < boxW; c++ {
            fmt.Printf(""%c"", box[r][c])
        }
        fmt.Println()
    }
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    initializeBox()
    var balls []*Ball
    for i := 0; i < nMaxBalls+boxH; i++ {
        fmt.Println(""\nStep"", i, "":"")
        if i < nMaxBalls {
            balls = append(balls, newBall(centerH, boxH-2)) // add ball
        }
        drawBox()
 
        // Next step for the simulation.
        // Frozen balls are kept in balls slice for simplicity
        for _, b := range balls {
            b.doStep()
        }
    }
}",2750,127,"package main

import (
    ""testing""
    ""math/rand""
    ""time""
)

func TestInitializeBox(t *testing.T) {
    initializeBox()

    // Check corners
    if box[0][0] != corner || box[0][boxW-1] != corner {
        t.Error(""Corners are not set correctly."")
    }

    // Check floor
    for i := 1; i < boxW-1; i++ {
        if box[0][i] != floor {
            t.Errorf(""Floor is not set correctly at position %d."", i)
        }
    }

    // Check walls
    for r := 1; r < boxH-1; r++ {
        if box[r][0] != wall || box[r][boxW-1] != wall {
            t.Errorf(""Walls are not set correctly at row %d."", r)
        }
    }

    // Check pins
    for nPins := 1; nPins <= pinsBaseW; nPins++ {
        for p := 0; p < nPins; p++ {
            if box[boxH-2-nPins][centerH+1-nPins+p*2] != pin {
                t.Errorf(""Pins are not set correctly at row %d, position %d."", boxH-2-nPins, centerH+1-nPins+p*2)
            }
        }
    }
}

func TestNewBall(t *testing.T) {
    initializeBox()
    b := newBall(centerH, boxH-2)

    if b.x != centerH || b.y != boxH-2 {
        t.Error(""Ball was not initialized at the correct position."")
    }

    if box[boxH-2][centerH] != ball {
        t.Error(""Ball was not placed correctly in the box."")
    }
}

func TestBallMovement(t *testing.T) {
    rand.Seed(time.Now().UnixNano())
    initializeBox()
    b := newBall(centerH, boxH-2)

    // Simulate a few steps
    for i := 0; i < 10; i++ {
        b.doStep()
    }

    // Check that the ball has moved
    if b.y >= boxH-2 {
        t.Error(""Ball did not move downwards."")
    }
}

func TestBallBoundaryConditions(t *testing.T) {
    initializeBox()
    b := newBall(centerH, boxH-2)

    // Move the ball to the bottom
    for b.y > 0 {
        b.doStep()
    }

    // Check that the ball stops at the bottom
    if b.y != 0 {
        t.Error(""Ball did not stop at the bottom."")
    }
}

func TestMultipleBalls(t *testing.T) {
    initializeBox()
    var balls []*Ball

    // Add multiple balls
    for i := 0; i < 5; i++ {
        balls = append(balls, newBall(centerH, boxH-2))
    }

    // Simulate a few steps
    for step := 0; step < 10; step++ {
        for _, b := range balls {
            b.doStep()
        }
    }

    // Check that all balls have moved
    for _, b := range balls {
        if b.y >= boxH-2 {
            t.Error(""One or more balls did not move downwards."")
        }
    }
}
",./data/generated/docs_golang/galton_box_animation/gpt_4o_2024_08_06_galton_box_animation_test.go,CompileStatus.OK,,,,0.18,0.38,,16.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: initializeBox', 'Severity': '', 'SourceLines': ['    initializeBox()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_galton_box_animation_test.go', 'Offset': 0, 'Line': 10, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: box', 'Severity': '', 'SourceLines': ['    if box[0][0] != corner || box[0][boxW-1] != corner {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_galton_box_animation_test.go', 'Offset': 0, 'Line': 13, 'Column': 8}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: boxW', 'Severity': '', 'SourceLines': ['    for i := 1; i < boxW-1; i++ {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_galton_box_animation_test.go', 'Offset': 0, 'Line': 18, 'Column': 21}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: box', 'Severity': '', 'SourceLines': ['        if box[0][i] != floor {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_galton_box_animation_test.go', 'Offset': 0, 'Line': 19, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: boxH', 'Severity': '', 'SourceLines': ['    for r := 1; r < boxH-1; r++ {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_galton_box_animation_test.go', 'Offset': 0, 'Line': 25, 'Column': 21}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: box', 'Severity': '', 'SourceLines': ['        if box[r][0] != wall || box[r][boxW-1] != wall {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_galton_box_animation_test.go', 'Offset': 0, 'Line': 26, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: pinsBaseW', 'Severity': '', 'SourceLines': ['    for nPins := 1; nPins <= pinsBaseW; nPins++ {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_galton_box_animation_test.go', 'Offset': 0, 'Line': 32, 'Column': 30}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: boxH', 'Severity': '', 'SourceLines': ['                t.Errorf(""Pins are not set correctly at row %d, position %d."", boxH-2-nPins, centerH+1-nPins+p*2)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_galton_box_animation_test.go', 'Offset': 0, 'Line': 35, 'Column': 80}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: initializeBox', 'Severity': '', 'SourceLines': ['    initializeBox()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_galton_box_animation_test.go', 'Offset': 0, 'Line': 42, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: newBall', 'Severity': '', 'SourceLines': ['    b := newBall(centerH, boxH-2)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_galton_box_animation_test.go', 'Offset': 0, 'Line': 43, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: centerH', 'Severity': '', 'SourceLines': ['    if b.x != centerH || b.y != boxH-2 {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_galton_box_animation_test.go', 'Offset': 0, 'Line': 45, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: initializeBox', 'Severity': '', 'SourceLines': ['    initializeBox()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_galton_box_animation_test.go', 'Offset': 0, 'Line': 56, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: newBall', 'Severity': '', 'SourceLines': ['    b := newBall(centerH, boxH-2)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_galton_box_animation_test.go', 'Offset': 0, 'Line': 57, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: boxH', 'Severity': '', 'SourceLines': ['    if b.y >= boxH-2 {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_galton_box_animation_test.go', 'Offset': 0, 'Line': 65, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: newBall', 'Severity': '', 'SourceLines': ['    b := newBall(centerH, boxH-2)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_galton_box_animation_test.go', 'Offset': 0, 'Line': 72, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Ball', 'Severity': '', 'SourceLines': ['    var balls []*Ball'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_galton_box_animation_test.go', 'Offset': 0, 'Line': 87, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",True,False,0.0,True,[]
Gaussian elimination,"Task

Solve   Ax=b   using Gaussian elimination then backwards substitution.

A   being an   n by n   matrix.

Also,   x and b   are   n by 1   vectors.

To improve accuracy, please use partial pivoting and scaling.



See also

   the Wikipedia entry:   Gaussian elimination

",Go,"package main
 
import (
    ""errors""
    ""fmt""
    ""log""
    ""math""
)
 
type testCase struct {
    a [][]float64
    b []float64
    x []float64
}
 
var tc = testCase{
    // common RC example.  Result x computed with rational arithmetic then
    // converted to float64, and so should be about as close to correct as
    // float64 represention allows.
    a: [][]float64{
        {1.00, 0.00, 0.00, 0.00, 0.00, 0.00},
        {1.00, 0.63, 0.39, 0.25, 0.16, 0.10},
        {1.00, 1.26, 1.58, 1.98, 2.49, 3.13},
        {1.00, 1.88, 3.55, 6.70, 12.62, 23.80},
        {1.00, 2.51, 6.32, 15.88, 39.90, 100.28},
        {1.00, 3.14, 9.87, 31.01, 97.41, 306.02}},
    b: []float64{-0.01, 0.61, 0.91, 0.99, 0.60, 0.02},
    x: []float64{-0.01, 1.602790394502114, -1.6132030599055613,
        1.2454941213714368, -0.4909897195846576, 0.065760696175232},
}
 
// result from above test case turns out to be correct to this tolerance.
const ε = 1e-13
 
func main() {
    x, err := GaussPartial(tc.a, tc.b)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(x)
    for i, xi := range x {
        if math.Abs(tc.x[i]-xi) > ε {
            log.Println(""out of tolerance"")
            log.Fatal(""expected"", tc.x)
        }
    }
}
 
func GaussPartial(a0 [][]float64, b0 []float64) ([]float64, error) {
    // make augmented matrix
    m := len(b0)
    a := make([][]float64, m)
    for i, ai := range a0 {
        row := make([]float64, m+1)
        copy(row, ai)
        row[m] = b0[i]
        a[i] = row
    }
    // WP algorithm from Gaussian elimination page
    // produces row-eschelon form
    for k := range a {
        // Find pivot for column k:
        iMax := k
        max := math.Abs(a[k][k])
        for i := k + 1; i < m; i++ {
            if abs := math.Abs(a[i][k]); abs > max {
                iMax = i
                max = abs
            }
        }
        if a[iMax][k] == 0 {
            return nil, errors.New(""singular"")
        }
        // swap rows(k, i_max)
        a[k], a[iMax] = a[iMax], a[k]
        // Do for all rows below pivot:
        for i := k + 1; i < m; i++ {
            // Do for all remaining elements in current row:
            for j := k + 1; j <= m; j++ {
                a[i][j] -= a[k][j] * (a[i][k] / a[k][k])
            }
            // Fill lower triangular matrix with zeros:
            a[i][k] = 0
        }
    }
    // end of WP algorithm.
    // now back substitute to get result.
    x := make([]float64, m)
    for i := m - 1; i >= 0; i-- {
        x[i] = a[i][m]
        for j := i + 1; j < m; j++ {
            x[i] -= a[i][j] * x[j]
        }
        x[i] /= a[i][i]
    }
    return x, nil
}",2662,97,"package main

import (
    ""math""
    ""testing""
)

func TestGaussPartial(t *testing.T) {
    tests := []struct {
        name    string
        a       [][]float64
        b       []float64
        x       []float64
        wantErr bool
    }{
        {
            name: ""Common RC example"",
            a: [][]float64{
                {1.00, 0.00, 0.00, 0.00, 0.00, 0.00},
                {1.00, 0.63, 0.39, 0.25, 0.16, 0.10},
                {1.00, 1.26, 1.58, 1.98, 2.49, 3.13},
                {1.00, 1.88, 3.55, 6.70, 12.62, 23.80},
                {1.00, 2.51, 6.32, 15.88, 39.90, 100.28},
                {1.00, 3.14, 9.87, 31.01, 97.41, 306.02},
            },
            b: []float64{-0.01, 0.61, 0.91, 0.99, 0.60, 0.02},
            x: []float64{-0.01, 1.602790394502114, -1.6132030599055613,
                1.2454941213714368, -0.4909897195846576, 0.065760696175232},
            wantErr: false,
        },
        {
            name: ""Singular matrix"",
            a: [][]float64{
                {1, 2, 3},
                {2, 4, 6},
                {3, 6, 9},
            },
            b:       []float64{1, 2, 3},
            x:       nil,
            wantErr: true,
        },
        {
            name: ""Simple 2x2 matrix"",
            a: [][]float64{
                {2, 3},
                {1, 2},
            },
            b:       []float64{8, 5},
            x:       []float64{1, 2},
            wantErr: false,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := GaussPartial(tt.a, tt.b)
            if (err != nil) != tt.wantErr {
                t.Errorf(""GaussPartial() error = %v, wantErr %v"", err, tt.wantErr)
                return
            }
            if !tt.wantErr {
                for i := range got {
                    if math.Abs(got[i]-tt.x[i]) > ε {
                        t.Errorf(""GaussPartial() = %v, want %v"", got, tt.x)
                    }
                }
            }
        })
    }
}
",./data/generated/docs_golang/gaussian_elimination/gpt_4o_2024_08_06_gaussian_elimination_test.go,CompileStatus.SYNTAX_ERROR,,,,0.04,0.14,,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: GaussPartial', 'Severity': '', 'SourceLines': ['            got, err := GaussPartial(tt.a, tt.b)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_gaussian_elimination_test.go', 'Offset': 0, 'Line': 56, 'Column': 25}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: ε', 'Severity': '', 'SourceLines': ['                    if math.Abs(got[i]-tt.x[i]) > ε {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_gaussian_elimination_test.go', 'Offset': 0, 'Line': 63, 'Column': 51}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,[]
General FizzBuzz,"Task

Write a generalized version of FizzBuzz that works for any list of factors, along with their words.

This is basically a ""fizzbuzz"" implementation where the user supplies the parameters.

The user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.

For simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.



For example, given:

>20      #This is the maximum number, supplied by the user
>3 Fizz  #The user now enters the starting factor (3) and the word they want associated with it (Fizz)
>5 Buzz  #The user now enters the next factor (5) and the word they want associated with it (Buzz)
>7 Baxx  #The user now enters the next factor (7) and the word they want associated with it (Baxx)

In other words: For this example, print the numbers 1 through 20, replacing every multiple of 3 with ""Fizz"", every multiple of 5 with ""Buzz"", and every multiple of 7 with ""Baxx"".

In the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor.

For instance, the number 15 is a multiple of both 3 and 5; print ""FizzBuzz"".

If the max number was 105 instead of 20, you would print ""FizzBuzzBaxx"" because it's a multiple of 3, 5, and 7.


Output:
1
2
Fizz
4
Buzz
Fizz
Baxx
8
Fizz
Buzz
11
Fizz
13
Baxx
FizzBuzz
16
17
Fizz
19
Buzz


",Go," 
package main
 
import (
	""fmt""
)
 
const numbers = 3
 
func main() {
 
	//using the provided data
	max := 20
	words := map[int]string{
		3: ""Fizz"",
		5: ""Buzz"",
		7: ""Baxx"",
	}
	keys := []int{3, 5, 7}
	divisible := false
	for i := 1; i <= max; i++ {
		for _, n := range keys {
			if i % n == 0 {
				fmt.Print(words[n])
				divisible = true
			}
		}
		if !divisible {
			fmt.Print(i)
		}
		fmt.Println()
		divisible = false
	}
 
}",432,35,error,,,,,,,,,,,False,False,,False,
Generate random chess position,"Task
 
Generate a random chess position in FEN format.

The position does not have to be realistic or even balanced,  but it must comply to the following rules:

 there is one and only one king of each color  (one black king and one white king);
 the kings must not be placed on adjacent squares;
 there can not be any pawn in the promotion square  (no white pawn in the eighth rank, and no black pawn in the first rank);
 including the kings, up to 32 pieces of either color can be placed. 
 There is no requirement for material balance between sides. 
 The picking of pieces does not have to comply to a regular chess set --- there can be five knights, twenty rooks, whatever ... as long as the total number of pieces do not exceed thirty-two. 
 it is white's turn.
 It's assumed that both sides have lost castling rights and that there is no possibility for   en passant   (the FEN should thus end in w - - 0 1).


No requirement is made regarding the probability distribution of your method, but your program should be able to span a reasonably representative sample of all possible positions. For instance, programs that would always generate positions with say five pieces on the board, or with kings on a corner, would not be considered truly random.



",Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""strconv""
    ""strings""
    ""time""
)
 
var grid [8][8]byte
 
func abs(i int) int {
    if i >= 0 {
        return i
    } else {
        return -i
    }
}
 
func createFen() string {
    placeKings()
    placePieces(""PPPPPPPP"", true)
    placePieces(""pppppppp"", true)
    placePieces(""RNBQBNR"", false)
    placePieces(""rnbqbnr"", false)
    return toFen()
}
 
func placeKings() {
    for {
        r1 := rand.Intn(8)
        c1 := rand.Intn(8)
        r2 := rand.Intn(8)
        c2 := rand.Intn(8)
        if r1 != r2 && abs(r1-r2) > 1 && abs(c1-c2) > 1 {
            grid[r1][c1] = 'K'
            grid[r2][c2] = 'k'
            return
        }
    }
}
 
func placePieces(pieces string, isPawn bool) {
    numToPlace := rand.Intn(len(pieces))
    for n := 0; n < numToPlace; n++ {
        var r, c int
        for {
            r = rand.Intn(8)
            c = rand.Intn(8)
            if grid[r][c] == '\000' && !(isPawn && (r == 7 || r == 0)) {
                break
            }
        }
        grid[r][c] = pieces[n]
    }
}
 
func toFen() string {
    var fen strings.Builder
    countEmpty := 0
    for r := 0; r < 8; r++ {
        for c := 0; c < 8; c++ {
            ch := grid[r][c]
            if ch == '\000' {
                ch = '.'
            }
            fmt.Printf(""%2c "", ch)
            if ch == '.' {
                countEmpty++
            } else {
                if countEmpty > 0 {
                    fen.WriteString(strconv.Itoa(countEmpty))
                    countEmpty = 0
                }
                fen.WriteByte(ch)
            }
        }
        if countEmpty > 0 {
            fen.WriteString(strconv.Itoa(countEmpty))
            countEmpty = 0
        }
        fen.WriteString(""/"")
        fmt.Println()
    }
    fen.WriteString("" w - - 0 1"")
    return fen.String()
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    fmt.Println(createFen())
}",1959,93,"package main

import (
	""testing""
	""strings""
	""unicode""
)

// TestCreateFen checks if the generated FEN string meets the specified requirements.
func TestCreateFen(t *testing.T) {
	for i := 0; i < 1000; i++ { // Run multiple times to check randomness
		fen := createFen()
		parts := strings.Split(fen, "" "")

		if len(parts) != 6 {
			t.Errorf(""FEN string should have 6 parts, got %d: %s"", len(parts), fen)
		}

		board := parts[0]
		if !strings.HasSuffix(fen, "" w - - 0 1"") {
			t.Errorf(""FEN string should end with 'w - - 0 1', got: %s"", fen)
		}

		if !validateKings(board) {
			t.Errorf(""Kings are not placed correctly in FEN: %s"", fen)
		}

		if !validatePawns(board) {
			t.Errorf(""Pawns are incorrectly placed in FEN: %s"", fen)
		}

		if !validatePieceCount(board) {
			t.Errorf(""Piece count exceeds 32 in FEN: %s"", fen)
		}
	}
}

// validateKings checks if there is exactly one white king and one black king, and they are not adjacent.
func validateKings(board string) bool {
	rows := strings.Split(board, ""/"")
	var whiteKingPos, blackKingPos [2]int
	whiteKingFound, blackKingFound := false, false

	for r, row := range rows {
		col := 0
		for _, ch := range row {
			if unicode.IsDigit(ch) {
				col += int(ch - '0')
			} else {
				if ch == 'K' {
					if whiteKingFound {
						return false
					}
					whiteKingPos = [2]int{r, col}
					whiteKingFound = true
				} else if ch == 'k' {
					if blackKingFound {
						return false
					}
					blackKingPos = [2]int{r, col}
					blackKingFound = true
				}
				col++
			}
		}
	}

	if !whiteKingFound || !blackKingFound {
		return false
	}

	// Check if kings are adjacent
	if abs(whiteKingPos[0]-blackKingPos[0]) <= 1 && abs(whiteKingPos[1]-blackKingPos[1]) <= 1 {
		return false
	}

	return true
}

// validatePawns checks if there are no pawns on the first or eighth rank.
func validatePawns(board string) bool {
	rows := strings.Split(board, ""/"")
	for _, ch := range rows[0] {
		if ch == 'p' {
			return false
		}
	}
	for _, ch := range rows[7] {
		if ch == 'P' {
			return false
		}
	}
	return true
}

// validatePieceCount checks if the total number of pieces does not exceed 32.
func validatePieceCount(board string) bool {
	count := 0
	for _, ch := range board {
		if unicode.IsLetter(ch) {
			count++
		}
	}
	return count <= 32
}

// abs returns the absolute value of an integer.
func abs(i int) int {
	if i >= 0 {
		return i
	}
	return -i
}
",./data/generated/docs_golang/generate_random_chess_position/gpt_4o_2024_08_06_generate_random_chess_position_test.go,CompileStatus.SYNTAX_ERROR,,,,0.08,0.22,,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: createFen', 'Severity': '', 'SourceLines': ['\t\tfen := createFen()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_generate_random_chess_position_test.go', 'Offset': 0, 'Line': 12, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_generate_random_chess_position_test.go', 'line': 108, 'column': 6, 'message': 'abs redeclared in this block'}]"
Globally replace text in several files,"Task

Replace every occurring instance of a piece of text in a group of text files with another one.



For this task we want to replace the text   ""Goodbye London!""   with   ""Hello New York!""   for a list of files.



",Go,"package main
 
import (
    ""bytes""
    ""io/ioutil""
    ""log""
    ""os""
)
 
func main() {
    gRepNFiles(""Goodbye London!"", ""Hello New York!"", []string{
        ""a.txt"",
        ""b.txt"",
        ""c.txt"",
    })
}
 
func gRepNFiles(olds, news string, files []string) {
    oldb := []byte(olds)
    newb := []byte(news)
    for _, fn := range files {
        if err := gRepFile(oldb, newb, fn); err != nil {
            log.Println(err)
        }
    }
}
 
func gRepFile(oldb, newb []byte, fn string) (err error) {
    var f *os.File
    if f, err = os.OpenFile(fn, os.O_RDWR, 0); err != nil {
        return
    }
    defer func() {
        if cErr := f.Close(); err == nil {
            err = cErr
        }
    }()
    var b []byte
    if b, err = ioutil.ReadAll(f); err != nil {
        return
    }
    if bytes.Index(b, oldb) < 0 {
        return
    }
    r := bytes.Replace(b, oldb, newb, -1)
    if err = f.Truncate(0); err != nil {
        return
    }
    _, err = f.WriteAt(r, 0)
    return
}",1001,51,"package main

import (
    ""io/ioutil""
    ""os""
    ""testing""
)

func TestGRepNFiles(t *testing.T) {
    // Setup test files
    files := []string{""test_a.txt"", ""test_b.txt"", ""test_c.txt""}
    contents := []string{
        ""Goodbye London! This is a test."",
        ""This file says Goodbye London! multiple times. Goodbye London!"",
        ""No goodbye here."",
    }
    expectedContents := []string{
        ""Hello New York! This is a test."",
        ""This file says Hello New York! multiple times. Hello New York!"",
        ""No goodbye here."",
    }

    // Create test files
    for i, file := range files {
        err := ioutil.WriteFile(file, []byte(contents[i]), 0644)
        if err != nil {
            t.Fatalf(""Failed to create test file %s: %v"", file, err)
        }
    }

    // Run the function
    gRepNFiles(""Goodbye London!"", ""Hello New York!"", files)

    // Check the results
    for i, file := range files {
        data, err := ioutil.ReadFile(file)
        if err != nil {
            t.Fatalf(""Failed to read test file %s: %v"", file, err)
        }
        if string(data) != expectedContents[i] {
            t.Errorf(""File %s content mismatch. Expected: %s, Got: %s"", file, expectedContents[i], string(data))
        }
    }

    // Cleanup test files
    for _, file := range files {
        os.Remove(file)
    }
}

func TestGRepFile_NoReplacementNeeded(t *testing.T) {
    // Setup test file
    file := ""test_d.txt""
    content := ""This file does not contain the target phrase.""
    expectedContent := content

    // Create test file
    err := ioutil.WriteFile(file, []byte(content), 0644)
    if err != nil {
        t.Fatalf(""Failed to create test file %s: %v"", file, err)
    }

    // Run the function
    gRepNFiles(""Goodbye London!"", ""Hello New York!"", []string{file})

    // Check the result
    data, err := ioutil.ReadFile(file)
    if err != nil {
        t.Fatalf(""Failed to read test file %s: %v"", file, err)
    }
    if string(data) != expectedContent {
        t.Errorf(""File %s content mismatch. Expected: %s, Got: %s"", file, expectedContent, string(data))
    }

    // Cleanup test file
    os.Remove(file)
}
",./data/generated/docs_golang/globally_replace_text_in_several_files/gpt_4o_2024_08_06_globally_replace_text_in_several_files_test.go,CompileStatus.OK,0.0,77.3,,0.18,0.55,0.12,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: gRepNFiles', 'Severity': '', 'SourceLines': ['    gRepNFiles(""Goodbye London!"", ""Hello New York!"", files)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_globally_replace_text_in_several_files_test.go', 'Offset': 0, 'Line': 32, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: gRepNFiles', 'Severity': '', 'SourceLines': ['    gRepNFiles(""Goodbye London!"", ""Hello New York!"", []string{file})'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_globally_replace_text_in_several_files_test.go', 'Offset': 0, 'Line': 64, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Gray code,"Gray code
Karnaugh maps
Create functions to encode a number to and decode a number from Gray code.

Display the normal binary representations, Gray code representations, and decoded Gray code values for all 5-bit binary numbers (0-31 inclusive, leading 0's not necessary).

There are many possible Gray codes. The following encodes what is called ""binary reflected Gray code.""

Encoding (MSB is bit 0, b is binary, g is Gray code):

if b[i-1] = 1
   g[i] = not b[i]
else
   g[i] = b[i]
Or:

g = b xor (b logically right shifted 1 time)
Decoding (MSB is bit 0, b is binary, g is Gray code):

b[0] = g[0]

for other bits:
b[i] = g[i] xor b[i-1]
Reference
 Converting Between Gray and Binary Codes. It includes step-by-step animations.",Go,"package main
 
import ""fmt""
 
func enc(b int) int {
    return b ^ b>>1
}
 
func dec(g int) (b int) {
    for ; g != 0; g >>= 1 {
        b ^= g
    }
    return
}
 
func main() {
    fmt.Println(""decimal  binary   gray    decoded"")
    for b := 0; b < 32; b++ {
        g := enc(b)
        d := dec(g)
        fmt.Printf(""  %2d     %05b   %05b   %05b  %2d\n"", b, b, g, d, d)
    }
}",383,23,"package main

import (
	""testing""
)

// TestEnc tests the enc function for encoding binary to Gray code.
func TestEnc(t *testing.T) {
	tests := []struct {
		binary int
		gray   int
	}{
		{0, 0},
		{1, 1},
		{2, 3},
		{3, 2},
		{4, 6},
		{5, 7},
		{6, 5},
		{7, 4},
		{8, 12},
		{9, 13},
		{10, 15},
		{11, 14},
		{12, 10},
		{13, 11},
		{14, 9},
		{15, 8},
		{16, 24},
		{17, 25},
		{18, 27},
		{19, 26},
		{20, 30},
		{21, 31},
		{22, 29},
		{23, 28},
		{24, 20},
		{25, 21},
		{26, 23},
		{27, 22},
		{28, 18},
		{29, 19},
		{30, 17},
		{31, 16},
	}

	for _, tt := range tests {
		t.Run("""", func(t *testing.T) {
			if got := enc(tt.binary); got != tt.gray {
				t.Errorf(""enc(%d) = %d; want %d"", tt.binary, got, tt.gray)
			}
		})
	}
}

// TestDec tests the dec function for decoding Gray code to binary.
func TestDec(t *testing.T) {
	tests := []struct {
		gray   int
		binary int
	}{
		{0, 0},
		{1, 1},
		{3, 2},
		{2, 3},
		{6, 4},
		{7, 5},
		{5, 6},
		{4, 7},
		{12, 8},
		{13, 9},
		{15, 10},
		{14, 11},
		{10, 12},
		{11, 13},
		{9, 14},
		{8, 15},
		{24, 16},
		{25, 17},
		{27, 18},
		{26, 19},
		{30, 20},
		{31, 21},
		{29, 22},
		{28, 23},
		{20, 24},
		{21, 25},
		{23, 26},
		{22, 27},
		{18, 28},
		{19, 29},
		{17, 30},
		{16, 31},
	}

	for _, tt := range tests {
		t.Run("""", func(t *testing.T) {
			if got := dec(tt.gray); got != tt.binary {
				t.Errorf(""dec(%d) = %d; want %d"", tt.gray, got, tt.binary)
			}
		})
	}
}
",./data/generated/docs_golang/gray_code/gpt_4o_2024_08_06_gray_code_test.go,CompileStatus.OK,0.0,44.4,,0.02,0.4,0.132,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: enc', 'Severity': '', 'SourceLines': ['\t\t\tif got := enc(tt.binary); got != tt.gray {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_gray_code_test.go', 'Offset': 0, 'Line': 49, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: dec', 'Severity': '', 'SourceLines': ['\t\t\tif got := dec(tt.gray); got != tt.binary {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_gray_code_test.go', 'Offset': 0, 'Line': 98, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Greyscale bars/Display,"The task is to display a series of vertical greyscale bars (contrast bars) with a sufficient number of bars to span the entire width of the display.

For the top quarter of the display, the left hand bar should be black, and we then incrementally step through six shades of grey until we have a white bar on the right hand side of the display. (This gives a total of 8 bars)

For the second quarter down, we start with white and step down through 14 shades of gray, getting darker until we have black on the right hand side of the display. (This gives a total of 16 bars).

Halfway down the display, we start with black, and produce 32 bars, ending in white, and for the last quarter, we start with white and step through 62 shades of grey, before finally arriving at black in the bottom right hand corner, producing a total of 64 bars for the bottom quarter.
",Go,"package main
 
import (
    ""github.com/fogleman/gg""
    ""math""
)
 
func greyBars(dc *gg.Context) {
    run := 0
    colorComp := 0.0 // component of the color
    for colCount := 8; colCount < 128; colCount *= 2 {
        // by this gap we change the background color
        colorGap := 255.0 / float64(colCount-1)
        colWidth := float64(dc.Width() / colCount)
        colHeight := float64(dc.Height() / 4)
        // switches color directions with each iteration of for loop
        if run%2 == 0 {
            colorComp = 0.0
        } else {
            colorComp = 255.0
            colorGap = -colorGap
        }
        xstart, ystart := 0.0, colHeight*float64(run)
        for i := 0; i < colCount; i++ {
            icolor := int(math.Round(colorComp)) // round to nearer integer
            dc.SetRGB255(icolor, icolor, icolor)
            dc.DrawRectangle(xstart, ystart, colWidth, colHeight)
            dc.Fill()
            xstart += colWidth
            colorComp += colorGap
        }
        run++
    }
}
 
func main() {
    dc := gg.NewContext(640, 320)
    greyBars(dc)
    dc.SavePNG(""greybars.png"")
}",1128,40,"package main

import (
    ""testing""
    ""github.com/fogleman/gg""
    ""image""
    ""image/color""
)

func TestGreyBars(t *testing.T) {
    dc := gg.NewContext(640, 320)
    greyBars(dc)
    img := dc.Image()

    // Test top quarter (8 bars)
    testBarColors(t, img, 0, 80, 8)

    // Test second quarter (16 bars)
    testBarColors(t, img, 80, 160, 16)

    // Test third quarter (32 bars)
    testBarColors(t, img, 160, 240, 32)

    // Test bottom quarter (64 bars)
    testBarColors(t, img, 240, 320, 64)
}

func testBarColors(t *testing.T, img image.Image, yStart, yEnd, barCount int) {
    width := img.Bounds().Dx()
    barWidth := width / barCount

    for i := 0; i < barCount; i++ {
        x := i * barWidth
        y := (yStart + yEnd) / 2 // Check color in the middle of the bar vertically
        expectedColor := calculateExpectedColor(i, barCount)
        actualColor := img.At(x, y)

        r, g, b, _ := actualColor.RGBA()
        actualGray := uint8(r >> 8) // Convert to 8-bit

        if actualGray != expectedColor {
            t.Errorf(""Bar %d in range (%d, %d) has color %d, expected %d"", i, yStart, yEnd, actualGray, expectedColor)
        }
    }
}

func calculateExpectedColor(index, barCount int) uint8 {
    if index == 0 {
        return 0
    } else if index == barCount-1 {
        return 255
    }
    colorGap := 255.0 / float64(barCount-1)
    return uint8(math.Round(float64(index) * colorGap))
}
",./data/generated/docs_golang/greyscale_bars_display/gpt_4o_2024_08_06_greyscale_bars_display_test.go,CompileStatus.SYNTAX_ERROR,,,,0.03,0.2,,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: greyBars', 'Severity': '', 'SourceLines': ['    greyBars(dc)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_greyscale_bars_display_test.go', 'Offset': 0, 'Line': 12, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'declared and not used: g', 'Severity': '', 'SourceLines': ['        r, g, b, _ := actualColor.RGBA()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_greyscale_bars_display_test.go', 'Offset': 0, 'Line': 38, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: math', 'Severity': '', 'SourceLines': ['    return uint8(math.Round(float64(index) * colorGap))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_greyscale_bars_display_test.go', 'Offset': 0, 'Line': 54, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""image/color"" imported and not used', 'Severity': '', 'SourceLines': ['    ""image/color""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_greyscale_bars_display_test.go', 'Offset': 0, 'Line': 7, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_greyscale_bars_display_test.go', 'line': 38, 'column': 12, 'message': 'declared and not used: g'}]"
Guess the number,"Task

Write a program where the program chooses a number between   1   and   10.

A player is then prompted to enter a guess.   If the player guesses wrong,   then the prompt appears again until the guess is correct.

When the player has made a successful guess the computer will issue a   ""Well guessed!""   message,   and the program exits.

A   conditional loop   may be used to repeat the guessing until the user is correct.



Related tasks

   Bulls and cows
   Bulls and cows/Player
   Guess the number/With Feedback
   Mastermind

",Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
func main() {
    fmt.Print(""Guess number from 1 to 10: "")
    rand.Seed(time.Now().Unix())
    n := rand.Intn(10) + 1
    for guess := n; ; fmt.Print(""No. Try again: "") {
        switch _, err := fmt.Scan(&guess); {
        case err != nil:
            fmt.Println(""\n"", err, ""\nSo, bye."")
            return
        case guess == n:
            fmt.Println(""Well guessed!"")
            return
        }
    }
}",477,23,"package main

import (
	""bytes""
	""fmt""
	""math/rand""
	""strings""
	""testing""
	""time""
)

func TestGuessTheNumber(t *testing.T) {
	// Seed the random number generator for reproducibility in tests
	rand.Seed(time.Now().UnixNano())

	// Test cases
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     ""Correct guess on first try"",
			input:    ""5\n"",
			expected: ""Well guessed!\n"",
		},
		{
			name:     ""Correct guess after wrong attempts"",
			input:    ""3\n7\n5\n"",
			expected: ""No. Try again: No. Try again: Well guessed!\n"",
		},
		{
			name:     ""Non-numeric input"",
			input:    ""abc\n5\n"",
			expected: ""\nexpected integer\nSo, bye.\n"",
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			// Mock input and output
			input := strings.NewReader(tc.input)
			output := &bytes.Buffer{}

			// Redirect standard input and output
			fmt.Scan = func(a ...interface{}) (n int, err error) {
				return fmt.Fscan(input, a...)
			}
			fmt.Print = func(a ...interface{}) (n int, err error) {
				return fmt.Fprint(output, a...)
			}
			fmt.Println = func(a ...interface{}) (n int, err error) {
				return fmt.Fprintln(output, a...)
			}

			// Run the main function
			main()

			// Check the output
			if got := output.String(); got != tc.expected {
				t.Errorf(""expected %q, got %q"", tc.expected, got)
			}
		})
	}
}
",./data/generated/docs_golang/guess_the_number/gpt_4o_2024_08_06_guess_the_number_test.go,CompileStatus.SYNTAX_ERROR,,,,0.03,0.25,,4.0,"[{'FromLinter': 'typecheck', 'Text': 'use of package fmt not in selector', 'Severity': '', 'SourceLines': ['\t\t\tfmt.Scan = func(a ...interface{}) (n int, err error) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_guess_the_number_test.go', 'Offset': 0, 'Line': 46, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'use of package fmt not in selector', 'Severity': '', 'SourceLines': ['\t\t\tfmt.Print = func(a ...interface{}) (n int, err error) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_guess_the_number_test.go', 'Offset': 0, 'Line': 49, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'use of package fmt not in selector', 'Severity': '', 'SourceLines': ['\t\t\tfmt.Println = func(a ...interface{}) (n int, err error) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_guess_the_number_test.go', 'Offset': 0, 'Line': 52, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\t\t\tmain()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_guess_the_number_test.go', 'Offset': 0, 'Line': 57, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_guess_the_number_test.go', 'line': 46, 'column': 4, 'message': 'use of package fmt not in selector'}]"
Guess the number/With feedback (player),"Task

Write a player for the game that follows the following rules:

The scorer will choose a number between set limits. The computer player will print a guess of the target number. The computer asks for a score of whether its guess is higher than, lower than, or equal to the target. The computer guesses, and the scorer scores, in turn, until the computer correctly guesses the target number.
The computer should guess intelligently based on the accumulated scores given. One way is to use a Binary search based algorithm.



Related tasks

   Guess the number/With Feedback
   Bulls and cows/Player

",Go,"package main
 
import (
    ""fmt""
    ""sort""
)
 
func main() {
    lower, upper := 0, 100
    fmt.Printf(`Instructions:
Think of integer number from %d (inclusive) to %d (exclusive) and
I will guess it. After each guess, I will ask you if it is less than
or equal to some number, and you will respond with ""yes"" or ""no"".
`, lower, upper)
    answer := sort.Search(upper-lower, func (i int) bool {
        fmt.Printf(""Is your number less than or equal to %d? "", lower+i)
        s := """"
        fmt.Scanf(""%s"", &s)
        return s != """" && s[0] == 'y'
    })
    fmt.Printf(""Your number is %d.\n"", lower+answer)
}",613,22,error,,,,,,,,,,,False,False,,False,
HTTP,"Task

Access and print a URL's content (the located resource) to the console.

There is a separate task for HTTPS Requests.



",Go," 
package main
 
import (
    ""io""
    ""log""
    ""net/http""
    ""os""
)
 
func main() {
    r, err := http.Get(""http://rosettacode.org/robots.txt"")
    if err != nil {
        log.Fatalln(err)
    }
    io.Copy(os.Stdout, r.Body)
}
 ",232,18,"package main

import (
    ""io""
    ""net/http""
    ""net/http/httptest""
    ""os""
    ""testing""
)

// TestMainFunction tests the main function which fetches and prints the content of a URL.
func TestMainFunction(t *testing.T) {
    // Create a test server to mock the HTTP GET request
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(""User-agent: *\nDisallow: /""))
    }))
    defer server.Close()

    // Redirect stdout to capture the output
    originalStdout := os.Stdout
    r, w, _ := os.Pipe()
    os.Stdout = w

    // Modify the URL in the main function to use the test server's URL
    originalURL := ""http://rosettacode.org/robots.txt""
    defer func() { http.Get = http.Get }() // Restore original http.Get after test
    http.Get = func(url string) (*http.Response, error) {
        if url == originalURL {
            return http.Get(server.URL)
        }
        return nil, nil
    }

    // Call the main function
    main()

    // Restore stdout and close the pipe
    w.Close()
    os.Stdout = originalStdout

    // Read the captured output
    var buf io.ReadWriter
    io.Copy(buf, r)

    // Check if the output is as expected
    expectedOutput := ""User-agent: *\nDisallow: /""
    if buf.String() != expectedOutput {
        t.Errorf(""Expected output %q, but got %q"", expectedOutput, buf.String())
    }
}
",./data/generated/docs_golang/http/gpt_4o_2024_08_06_http_test.go,CompileStatus.SYNTAX_ERROR,,,,0.04,0.5,,5.0,"[{'FromLinter': 'typecheck', 'Text': 'use of package http not in selector', 'Severity': '', 'SourceLines': ['    defer func() { http.Get = http.Get }() // Restore original http.Get after test'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_http_test.go', 'Offset': 0, 'Line': 27, 'Column': 20}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'use of package http not in selector', 'Severity': '', 'SourceLines': ['    http.Get = func(url string) (*http.Response, error) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_http_test.go', 'Offset': 0, 'Line': 28, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['    main()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_http_test.go', 'Offset': 0, 'Line': 36, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'buf.String undefined (type io.ReadWriter has no field or method String)', 'Severity': '', 'SourceLines': ['    if buf.String() != expectedOutput {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_http_test.go', 'Offset': 0, 'Line': 48, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'buf.String undefined (type io.ReadWriter has no field or method String)', 'Severity': '', 'SourceLines': ['        t.Errorf(""Expected output %q, but got %q"", expectedOutput, buf.String())'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_http_test.go', 'Offset': 0, 'Line': 49, 'Column': 72}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_http_test.go', 'line': 27, 'column': 20, 'message': 'use of package http not in selector'}]"
Hailstone sequence,"The Hailstone sequence of numbers can be generated from a starting positive integer,   n   by:

   If   n   is     1     then the sequence ends.
   If   n   is   even then the next   n   of the sequence    = n/2 
   If   n   is   odd   then the next   n   of the sequence    = (3 * n) + 1 


The (unproven) Collatz conjecture is that the hailstone sequence for any starting number always terminates.



This sequence was named by Lothar Collatz in 1937   (or possibly in 1939),   and is also known as (the):

   hailstone sequence,   hailstone numbers
   3x + 2 mapping,   3n + 1 problem
   Collatz sequence
   Hasse's algorithm
   Kakutani's problem
   Syracuse algorithm,   Syracuse problem
   Thwaites conjecture 
   Ulam's problem


The hailstone sequence is also known as   hailstone numbers   (because the values are usually subject to multiple descents and ascents like hailstones in a cloud).



Task

 Create a routine to generate the hailstone sequence for a number.
 Use the routine to show that the hailstone sequence for the number 27 has 112 elements starting with 27, 82, 41, 124 and ending with 8, 4, 2, 1
 Show the number less than 100,000 which has the longest hailstone sequence together with that sequence's length.
   (But don't show the actual sequence!)


See also

   xkcd (humourous).
   The Notorious Collatz conjecture Terence Tao, UCLA (Presentation, pdf).
   The Simplest Math Problem No One Can Solve Veritasium (video, sponsored).

",Go,"package main
 
import ""fmt""
 
// 1st arg is the number to generate the sequence for.
// 2nd arg is a slice to recycle, to reduce garbage.
func hs(n int, recycle []int) []int {
    s := append(recycle[:0], n)
    for n > 1 {
        if n&1 == 0 {
            n = n / 2
        } else {
            n = 3*n + 1
        }
        s = append(s, n)
    }
    return s
}
 
func main() {
    seq := hs(27, nil)
    fmt.Printf(""hs(27): %d elements: [%d %d %d %d ... %d %d %d %d]\n"",
        len(seq), seq[0], seq[1], seq[2], seq[3],
        seq[len(seq)-4], seq[len(seq)-3], seq[len(seq)-2], seq[len(seq)-1])
 
    var maxN, maxLen int
    for n := 1; n < 100000; n++ {
        seq = hs(n, seq)
        if len(seq) > maxLen {
            maxN = n
            maxLen = len(seq)
        }
    }
    fmt.Printf(""hs(%d): %d elements\n"", maxN, maxLen)
}",840,35,"package main

import (
	""testing""
)

func TestHailstoneSequence(t *testing.T) {
	tests := []struct {
		start int
		want  []int
	}{
		{1, []int{1}},
		{2, []int{2, 1}},
		{3, []int{3, 10, 5, 16, 8, 4, 2, 1}},
		{4, []int{4, 2, 1}},
		{5, []int{5, 16, 8, 4, 2, 1}},
		{6, []int{6, 3, 10, 5, 16, 8, 4, 2, 1}},
		{7, []int{7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1}},
		{27, []int{27, 82, 41, 124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1}},
	}

	for _, tt := range tests {
		t.Run("""", func(t *testing.T) {
			got := hs(tt.start, nil)
			if len(got) != len(tt.want) {
				t.Errorf(""hs(%d) = %v, want %v"", tt.start, got, tt.want)
			}
			for i := range got {
				if got[i] != tt.want[i] {
					t.Errorf(""hs(%d) = %v, want %v"", tt.start, got, tt.want)
					break
				}
			}
		})
	}
}

func TestLongestHailstoneSequenceUnder100000(t *testing.T) {
	var maxN, maxLen int
	var seq []int
	for n := 1; n < 100000; n++ {
		seq = hs(n, seq)
		if len(seq) > maxLen {
			maxN = n
			maxLen = len(seq)
		}
	}

	if maxN != 77031 || maxLen != 351 {
		t.Errorf(""Longest sequence under 100000 is hs(%d) with %d elements, got hs(%d) with %d elements"", 77031, 351, maxN, maxLen)
	}
}
",./data/generated/docs_golang/hailstone_sequence/gpt_4o_2024_08_06_hailstone_sequence_test.go,CompileStatus.OK,0.0,43.8,,0.09,0.5,0.261,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: hs', 'Severity': '', 'SourceLines': ['\t\t\tgot := hs(tt.start, nil)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hailstone_sequence_test.go', 'Offset': 0, 'Line': 24, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: hs', 'Severity': '', 'SourceLines': ['\t\tseq = hs(n, seq)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hailstone_sequence_test.go', 'Offset': 0, 'Line': 42, 'Column': 9}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Hamming numbers,"Hamming numbers are numbers of the form  

    H = 2i × 3j × 5k
           where 
     i,  j,  k  ≥  0 

Hamming numbers   are also known as   ugly numbers   and also   5-smooth numbers   (numbers whose prime divisors are less or equal to 5).



Task

Generate the sequence of Hamming numbers, in increasing order.   In particular:

 Show the   first twenty   Hamming numbers.
 Show the   1691st   Hamming number (the last one below   231).
 Show the   one millionth   Hamming number (if the language – or a convenient library – supports arbitrary-precision integers).


Related tasks

 Humble numbers
 N-smooth numbers


References

 Wikipedia entry:   Hamming numbers     (this link is re-directed to   Regular number).
 Wikipedia entry:   Smooth number
 OEIS entry:   A051037   5-smooth   or   Hamming numbers
 Hamming problem from Dr. Dobb's CodeTalk (dead link as of Sep 2011; parts of the thread here and here).

",Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func min(a, b *big.Int) *big.Int {
    if a.Cmp(b) < 0 {
        return a
    }
    return b
}
 
func hamming(n int) []*big.Int {
    h := make([]*big.Int, n)
    h[0] = big.NewInt(1)
    two, three, five    := big.NewInt(2), big.NewInt(3), big.NewInt(5)
    next2, next3, next5 := big.NewInt(2), big.NewInt(3), big.NewInt(5)
    i, j, k := 0, 0, 0
    for m := 1; m < len(h); m++ {
        h[m] = new(big.Int).Set(min(next2, min(next3, next5)))
        if h[m].Cmp(next2) == 0 { i++; next2.Mul(  two, h[i]) } 
        if h[m].Cmp(next3) == 0 { j++; next3.Mul(three, h[j]) } 
        if h[m].Cmp(next5) == 0 { k++; next5.Mul( five, h[k]) } 
    }
    return h
}
 
func main() {
    h := hamming(1e6)
    fmt.Println(h[:20])
    fmt.Println(h[1691-1])
    fmt.Println(h[len(h)-1])
}",834,35,"package main

import (
	""fmt""
	""math/big""
	""testing""
)

// TestHammingFirstTwenty tests the first 20 Hamming numbers.
func TestHammingFirstTwenty(t *testing.T) {
	expected := []string{
		""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""8"", ""9"", ""10"", ""12"",
		""15"", ""16"", ""18"", ""20"", ""24"", ""25"", ""27"", ""30"", ""32"", ""36"",
	}

	h := hamming(20)
	for i, num := range h {
		if num.String() != expected[i] {
			t.Errorf(""Expected %s but got %s at index %d"", expected[i], num.String(), i)
		}
	}
}

// TestHamming1691st tests the 1691st Hamming number.
func TestHamming1691st(t *testing.T) {
	expected := ""2123366400""
	h := hamming(1691)
	if h[1690].String() != expected {
		t.Errorf(""Expected %s but got %s for the 1691st Hamming number"", expected, h[1690].String())
	}
}

// TestHammingMillionth tests the one millionth Hamming number.
func TestHammingMillionth(t *testing.T) {
	expected := ""519312780448000""
	h := hamming(1e6)
	if h[999999].String() != expected {
		t.Errorf(""Expected %s but got %s for the one millionth Hamming number"", expected, h[999999].String())
	}
}

func main() {
	fmt.Println(""Running tests..."")
	testing.M()
}
",./data/generated/docs_golang/hamming_numbers/gpt_4o_2024_08_06_hamming_numbers_test.go,CompileStatus.SYNTAX_ERROR,,,,0.14,0.38,,5.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: hamming', 'Severity': '', 'SourceLines': ['\th := hamming(20)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hamming_numbers_test.go', 'Offset': 0, 'Line': 16, 'Column': 7}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: hamming', 'Severity': '', 'SourceLines': ['\th := hamming(1691)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hamming_numbers_test.go', 'Offset': 0, 'Line': 27, 'Column': 7}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: hamming', 'Severity': '', 'SourceLines': ['\th := hamming(1e6)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hamming_numbers_test.go', 'Offset': 0, 'Line': 36, 'Column': 7}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'missing argument in conversion to testing.M', 'Severity': '', 'SourceLines': ['\ttesting.M()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hamming_numbers_test.go', 'Offset': 0, 'Line': 44, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""math/big"" imported and not used', 'Severity': '', 'SourceLines': ['\t""math/big""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hamming_numbers_test.go', 'Offset': 0, 'Line': 5, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_hamming_numbers_test.go', 'line': 42, 'column': 6, 'message': 'main redeclared in this block'}]"
Hash join,"An inner join is an operation that combines two data tables into one table, based on matching column values. The simplest way of implementing this operation is the nested loop join algorithm, but a more scalable alternative is the hash join algorithm.

Task[edit]
Implement the ""hash join"" algorithm, and demonstrate that it passes the test-case listed below.

You should represent the tables as data structures that feel natural in your programming language.

Guidance
The ""hash join"" algorithm consists of two steps:

 Hash phase: Create a multimap from one of the two tables, mapping from each join column value to all the rows that contain it.

 The multimap must support hash-based lookup which scales better than a simple linear search, because that's the whole point of this algorithm.
 Ideally we should create the multimap for the smaller table, thus minimizing its creation time and memory size.
 Join phase: Scan the other table, and find matching rows by looking in the multimap created before.


In pseudo-code, the algorithm could be expressed as follows:

let A = the first input table (or ideally, the larger one)
let B = the second input table (or ideally, the smaller one)
let jA = the join column ID of table A
let jB = the join column ID of table B
let MB = a multimap for mapping from single values to multiple rows of table B (starts out empty)
let C = the output table (starts out empty)

for each row b in table B:
   place b in multimap MB under key b(jB)

for each row a in table A:
   for each row b in multimap MB under key a(jA):
      let c = the concatenation of row a and row b
      place row c in table C

Test-case


 Input

 Output





 A =




 Age 
 Name


 27 
 Jonah


 18 
 Alan


 28 
 Glory


 18 
 Popeye


 28 
 Alan




 B =




 Character 
 Nemesis


 Jonah 
 Whales


 Jonah 
 Spiders


 Alan 
 Ghosts


 Alan 
 Zombies


 Glory 
 Buffy



 jA =

 Name (i.e. column 1)

 jB =

 Character (i.e. column 0)





 A.Age 
 A.Name 
 B.Character 
 B.Nemesis


 27 
 Jonah 
 Jonah 
 Whales


 27 
 Jonah 
 Jonah 
 Spiders


 18 
 Alan 
 Alan 
 Ghosts


 18 
 Alan 
 Alan 
 Zombies


 28 
 Glory 
 Glory 
 Buffy


 28 
 Alan 
 Alan 
 Ghosts


 28 
 Alan 
 Alan 
 Zombies


The order of the rows in the output table is not significant.

If you're using numerically indexed arrays to represent table rows (rather than referring to columns by name), you could represent the output rows in the form [[27, ""Jonah""], [""Jonah"", ""Whales""]].



",Go,"package main
 
import ""fmt""
 
func main() {
    tableA := []struct {
        value int
        key   string
    }{
        {27, ""Jonah""}, {18, ""Alan""}, {28, ""Glory""}, {18, ""Popeye""},
        {28, ""Alan""},
    }
    tableB := []struct {
        key   string
        value string
    }{
        {""Jonah"", ""Whales""}, {""Jonah"", ""Spiders""},
        {""Alan"", ""Ghosts""}, {""Alan"", ""Zombies""}, {""Glory"", ""Buffy""},
    }
    // hash phase
    h := map[string][]int{}
    for i, r := range tableA {
        h[r.key] = append(h[r.key], i)
    }
    // join phase
    for _, x := range tableB {
        for _, a := range h[x.key] {
            fmt.Println(tableA[a], x)
        }
    }
}",674,31,"package main

import (
	""reflect""
	""testing""
)

func TestHashJoin(t *testing.T) {
	tableA := []struct {
		value int
		key   string
	}{
		{27, ""Jonah""}, {18, ""Alan""}, {28, ""Glory""}, {18, ""Popeye""},
		{28, ""Alan""},
	}
	tableB := []struct {
		key   string
		value string
	}{
		{""Jonah"", ""Whales""}, {""Jonah"", ""Spiders""},
		{""Alan"", ""Ghosts""}, {""Alan"", ""Zombies""}, {""Glory"", ""Buffy""},
	}

	expectedOutput := [][]interface{}{
		{27, ""Jonah"", ""Jonah"", ""Whales""},
		{27, ""Jonah"", ""Jonah"", ""Spiders""},
		{18, ""Alan"", ""Alan"", ""Ghosts""},
		{18, ""Alan"", ""Alan"", ""Zombies""},
		{28, ""Glory"", ""Glory"", ""Buffy""},
		{28, ""Alan"", ""Alan"", ""Ghosts""},
		{28, ""Alan"", ""Alan"", ""Zombies""},
	}

	// hash phase
	h := map[string][]int{}
	for i, r := range tableA {
		h[r.key] = append(h[r.key], i)
	}

	// join phase
	var result [][]interface{}
	for _, x := range tableB {
		for _, a := range h[x.key] {
			result = append(result, []interface{}{tableA[a].value, tableA[a].key, x.key, x.value})
		}
	}

	if !reflect.DeepEqual(result, expectedOutput) {
		t.Errorf(""Expected %v, but got %v"", expectedOutput, result)
	}
}
",./data/generated/docs_golang/hash_join/gpt_4o_2024_08_06_hash_join_test.go,CompileStatus.OK,0.0,0.0,,0.04,0.25,0.109,0.0,[],False,False,0.0,False,[]
Hello world/Line printer,"Task

Cause a line printer attached to the computer to print a line containing the message:    Hello World! 



Note

A line printer is not the same as standard output.

A   line printer   was an older-style printer which prints one line at a time to a continuous ream of paper.

With some systems, a line printer can be any device attached to an appropriate port (such as a parallel port).



",Go,"package main
 
import (
	""fmt""
	""os""
)
 
func main() {
	lp0, err := os.Create(""/dev/lp0"")
 
	if err != nil {
		panic(err)
	}
 
	defer lp0.Close()
 
	fmt.Fprintln(lp0, ""Hello World!"")
}",184,18,none,,,,,,,,,,,False,False,,False,
Hello world/Newline omission,"Some languages automatically insert a newline after outputting a string, unless measures are taken to prevent its output.



Task

Display the string   Goodbye, World!   without a trailing newline.



Related tasks

   Hello world/Graphical
   Hello world/Line Printer
   Hello world/Standard error
   Hello world/Text

",Go,"package main
 
import ""fmt""
 
func main() { fmt.Print(""Goodbye, World!"") }",74,5,"package main

import (
	""bytes""
	""testing""
)

func TestMainOutput(t *testing.T) {
	// Capture the output of the main function
	var buf bytes.Buffer
	fmtPrint = func(a ...interface{}) (n int, err error) {
		return buf.WriteString(a[0].(string))
	}

	// Call the main function
	main()

	// Expected output
	expected := ""Goodbye, World!""

	// Check if the output matches the expected string
	if buf.String() != expected {
		t.Errorf(""Expected %q, but got %q"", expected, buf.String())
	}
}

// Override fmt.Print for testing purposes
var fmtPrint = fmt.Print

func init() {
	// Redirect fmt.Print to our custom function
	fmt.Print = fmtPrint
}
",./data/generated/docs_golang/hello_world_newline_omission/gpt_4o_2024_08_06_hello_world_newline_omission_test.go,CompileStatus.SYNTAX_ERROR,,,,0.08,1.0,,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: fmt', 'Severity': '', 'SourceLines': ['var fmtPrint = fmt.Print'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hello_world_newline_omission_test.go', 'Offset': 0, 'Line': 28, 'Column': 16}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\tmain()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hello_world_newline_omission_test.go', 'Offset': 0, 'Line': 16, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fmt', 'Severity': '', 'SourceLines': ['\tfmt.Print = fmtPrint'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hello_world_newline_omission_test.go', 'Offset': 0, 'Line': 32, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_hello_world_newline_omission_test.go', 'line': 28, 'column': 16, 'message': 'undefined: fmt'}]"
Hello world/Standard error,"Hello world/Standard error is part of Short Circuit's Console Program Basics selection.
A common practice in computing is to send error messages
to a different output stream than normal text console messages.

The normal messages print to what is called ""standard output"" or ""standard out"".

The error messages print to ""standard error"".

This separation can be used to redirect error messages to a different place than normal messages.



Task

Show how to print a message to standard error by printing     Goodbye, World!     on that stream.



",Go,"package main
func main() { println(""Goodbye, World!"") }",55,2,"package main

import (
	""bytes""
	""os""
	""testing""
)

func TestMainOutput(t *testing.T) {
	// Save the original stderr
	originalStderr := os.Stderr
	defer func() { os.Stderr = originalStderr }()

	// Create a pipe to capture stderr
	r, w, err := os.Pipe()
	if err != nil {
		t.Fatalf(""Failed to create pipe: %v"", err)
	}

	// Redirect stderr to the write end of the pipe
	os.Stderr = w

	// Run the main function
	main()

	// Close the write end of the pipe
	w.Close()

	// Read the captured output from the read end of the pipe
	var buf bytes.Buffer
	if _, err := buf.ReadFrom(r); err != nil {
		t.Fatalf(""Failed to read from pipe: %v"", err)
	}

	// Check if the output matches the expected message
	expected := ""Goodbye, World!\n""
	if buf.String() != expected {
		t.Errorf(""Expected %q, but got %q"", expected, buf.String())
	}
}
",./data/generated/docs_golang/hello_world_standard_error/gpt_4o_2024_08_06_hello_world_standard_error_test.go,CompileStatus.OK,0.0,100.0,,0.18,3.0,0.112,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\tmain()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hello_world_standard_error_test.go', 'Offset': 0, 'Line': 24, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Hello world/Web server,"The browser is the new GUI !



Task

Serve our standard text   Goodbye, World!   to   http://localhost:8080/   so that it can be viewed with a web browser.

The provided solution must start or implement a server that accepts multiple client connections and serves text as requested.

Note that starting a web browser or opening a new window with this URL
is not part of the task.

Additionally, it is permissible to serve the provided page as a plain text file (there is no requirement to serve properly formatted HTML here).

The browser will generally do the right thing with simple text like this.



",Go,"package main
 
import (
  ""fmt""
  ""log""
  ""net/http""
)
 
func main() {
  http.HandleFunc(""/"", func(w http.ResponseWriter, req *http.Request) {
    fmt.Fprintln(w, ""Goodbye, World!"")
  })
  log.Fatal(http.ListenAndServe("":8080"", nil))
}
 ",237,15,"package main

import (
	""io/ioutil""
	""net/http""
	""net/http/httptest""
	""strings""
	""testing""
)

func TestHelloWorldServer(t *testing.T) {
	// Create a request to pass to our handler
	req, err := http.NewRequest(""GET"", ""/"", nil)
	if err != nil {
		t.Fatal(err)
	}

	// Create a ResponseRecorder to record the response
	rr := httptest.NewRecorder()
	handler := http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
		http.HandleFunc(""/"", func(w http.ResponseWriter, req *http.Request) {
			fmt.Fprintln(w, ""Goodbye, World!"")
		})
	})

	// Serve the request
	handler.ServeHTTP(rr, req)

	// Check the status code is what we expect
	if status := rr.Code; status != http.StatusOK {
		t.Errorf(""handler returned wrong status code: got %v want %v"", status, http.StatusOK)
	}

	// Check the response body is what we expect
	expected := ""Goodbye, World!\n""
	if strings.TrimSpace(rr.Body.String()) != strings.TrimSpace(expected) {
		t.Errorf(""handler returned unexpected body: got %v want %v"", rr.Body.String(), expected)
	}
}
",./data/generated/docs_golang/hello_world_web_server/gpt_4o_2024_08_06_hello_world_web_server_test.go,CompileStatus.SYNTAX_ERROR,,,,0.19,1.5,,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: fmt', 'Severity': '', 'SourceLines': ['\t\t\tfmt.Fprintln(w, ""Goodbye, World!"")'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hello_world_web_server_test.go', 'Offset': 0, 'Line': 22, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""io/ioutil"" imported and not used', 'Severity': '', 'SourceLines': ['\t""io/ioutil""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hello_world_web_server_test.go', 'Offset': 0, 'Line': 4, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_hello_world_web_server_test.go', 'line': 22, 'column': 4, 'message': 'undefined: fmt'}]"
Heronian triangles,"Hero's formula for the area of a triangle given the length of its three sides    a,   b,   and   c   is given by:

 



A
=


s
(
s
−
a
)
(
s
−
b
)
(
s
−
c
)


,


{\displaystyle A={\sqrt {s(s-a)(s-b)(s-c)}},}


where   s   is half the perimeter of the triangle; that is,

 



s
=



a
+
b
+
c

2


.


{\displaystyle s={\frac {a+b+c}{2}}.}



Heronian triangles
are triangles whose sides and area are all integers.

 An example is the triangle with sides   3, 4, 5   whose area is   6   (and whose perimeter is   12). 


Note that any triangle whose sides are all an integer multiple of   3, 4, 5;   such as   6, 8, 10,   will also be a Heronian triangle.

Define a Primitive Heronian triangle as a Heronian triangle where the greatest common divisor
of all three sides is   1   (unity).

This will exclude, for example, triangle   6, 8, 10.



Task

 Create a named function/method/procedure/... that implements Hero's formula.
 Use the function to generate all the primitive Heronian triangles with sides <= 200.
 Show the count of how many triangles are found.
 Order the triangles by first increasing area, then by increasing perimeter, then by increasing maximum side lengths
 Show the first ten ordered triangles in a table of sides, perimeter, and area.
 Show a similar ordered table for those triangles with area = 210


Show all output here.

Note: when generating triangles it may help to restrict 



a
<=
b
<=
c


{\displaystyle a<=b<=c}


",Go,"package main
 
import (
    ""fmt""
    ""math""
    ""sort""
)
 
const (
    n = 200
    header = ""\nSides          P   A""
)
 
func gcd(a, b int) int {
    leftover := 1
    var dividend, divisor int
    if (a > b) { dividend, divisor = a, b } else { dividend, divisor = b, a }
 
    for (leftover != 0) {
        leftover = dividend % divisor
        if (leftover > 0) {
            dividend, divisor = divisor, leftover
        }
    }
    return divisor
}
 
func is_heron(h float64) bool {
    return h > 0 && math.Mod(h, 1) == 0.0
}
 
// by_area_perimeter implements sort.Interface for [][]int based on the area first and perimeter value
type by_area_perimeter [][]int
 
func (a by_area_perimeter) Len() int           { return len(a) }
func (a by_area_perimeter) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a by_area_perimeter) Less(i, j int) bool {
    return a[i][4] < a[j][4] || a[i][4] == a[j][4] && a[i][3] < a[j][3]
}
 
func main() {
    var l [][]int
    for c := 1; c <= n; c++ {
        for b := 1; b <= c; b++ {
            for a := 1; a <= b; a++ {
                if (gcd(gcd(a, b), c) == 1) {
                    p := a + b + c
                    s := float64(p) / 2.0
                    area := math.Sqrt(s * (s - float64(a)) * (s - float64(b)) * (s - float64(c)))
                    if (is_heron(area)) {
                        l = append(l, []int{a, b, c, p, int(area)})
                    }
                }
            }
        }
    }
 
    fmt.Printf(""Number of primitive Heronian triangles with sides up to %d: %d"", n, len(l))
    sort.Sort(by_area_perimeter(l))
    fmt.Printf(""\n\nFirst ten when ordered by increasing area, then perimeter:"" + header)
    for i := 0; i < 10; i++ { fmt.Printf(""\n%3d"", l[i]) }
 
    a := 210
    fmt.Printf(""\n\nArea = %d%s"", a, header)
    for _, it := range l  {
        if (it[4] == a) {
            fmt.Printf(""\n%3d"", it)
        }
    }
}",1915,70,"package main

import (
	""math""
	""testing""
)

// TestGCD tests the gcd function
func TestGCD(t *testing.T) {
	tests := []struct {
		a, b, expected int
	}{
		{3, 5, 1},
		{6, 8, 2},
		{12, 15, 3},
		{17, 19, 1},
		{100, 10, 10},
	}

	for _, test := range tests {
		result := gcd(test.a, test.b)
		if result != test.expected {
			t.Errorf(""gcd(%d, %d) = %d; expected %d"", test.a, test.b, result, test.expected)
		}
	}
}

// TestIsHeron tests the is_heron function
func TestIsHeron(t *testing.T) {
	tests := []struct {
		h        float64
		expected bool
	}{
		{6.0, true},
		{6.5, false},
		{0.0, false},
		{10.0, true},
		{15.5, false},
	}

	for _, test := range tests {
		result := is_heron(test.h)
		if result != test.expected {
			t.Errorf(""is_heron(%f) = %v; expected %v"", test.h, result, test.expected)
		}
	}
}

// TestHeronianTriangles tests the generation of Heronian triangles
func TestHeronianTriangles(t *testing.T) {
	expectedCount := 5 // Known count of primitive Heronian triangles with sides <= 10
	var l [][]int
	for c := 1; c <= 10; c++ {
		for b := 1; b <= c; b++ {
			for a := 1; a <= b; a++ {
				if gcd(gcd(a, b), c) == 1 {
					p := a + b + c
					s := float64(p) / 2.0
					area := math.Sqrt(s * (s - float64(a)) * (s - float64(b)) * (s - float64(c)))
					if is_heron(area) {
						l = append(l, []int{a, b, c, p, int(area)})
					}
				}
			}
		}
	}

	if len(l) != expectedCount {
		t.Errorf(""Number of primitive Heronian triangles with sides up to 10 = %d; expected %d"", len(l), expectedCount)
	}
}
",./data/generated/docs_golang/heronian_triangles/gpt_4o_2024_08_06_heronian_triangles_test.go,CompileStatus.OK,0.0,32.4,,0.07,0.15,0.113,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: gcd', 'Severity': '', 'SourceLines': ['\t\tresult := gcd(test.a, test.b)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_heronian_triangles_test.go', 'Offset': 0, 'Line': 21, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: is_heron', 'Severity': '', 'SourceLines': ['\t\tresult := is_heron(test.h)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_heronian_triangles_test.go', 'Offset': 0, 'Line': 42, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: gcd', 'Severity': '', 'SourceLines': ['\t\t\t\tif gcd(gcd(a, b), c) == 1 {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_heronian_triangles_test.go', 'Offset': 0, 'Line': 56, 'Column': 8}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: is_heron', 'Severity': '', 'SourceLines': ['\t\t\t\t\tif is_heron(area) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_heronian_triangles_test.go', 'Offset': 0, 'Line': 60, 'Column': 9}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,66.67,False,[]
Hickerson series of almost integers,"The following function,   due to D. Hickerson,   is said to generate ""Almost integers"" by the

""Almost Integer"" page of Wolfram MathWorld,   (December 31 2013).   (See formula numbered   51.)



The function is:           



h
(
n
)
=



n
!


2
(
ln
⁡

2


)

n
+
1







{\displaystyle h(n)={\operatorname {n} ! \over 2(\ln {2})^{n+1}}}





It is said to produce ""almost integers"" for   n   between   1   and   17.
The purpose of the task is to verify this assertion.

Assume that an ""almost integer"" has either a nine or a zero as its first digit after the decimal point of its decimal string representation



Task

Calculate all values of the function checking and stating which are ""almost integers"".

Note: Use extended/arbitrary precision numbers in your calculation if necessary to ensure you have adequate precision of results as for example:

               h(18) = 3385534663256845326.39...


",Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    ln2, _ := new(big.Rat).SetString(""0.6931471805599453094172"")
    h := big.NewRat(1, 2)
    h.Quo(h, ln2)
    var f big.Rat
    var w big.Int
    for i := int64(1); i <= 17; i++ {
        h.Quo(h.Mul(h, f.SetInt64(i)), ln2)
        w.Quo(h.Num(), h.Denom())
        f.Sub(h, f.SetInt(&w))
        y, _ := f.Float64()
        d := fmt.Sprintf(""%.3f"", y)
        fmt.Printf(""n: %2d  h: %18d%s  Nearly integer: %t\n"",
            i, &w, d[1:], d[2] == '0' || d[2] == '9')
    }
}",546,23,"package main

import (
	""fmt""
	""math/big""
	""testing""
)

// Function to calculate h(n)
func hickerson(n int64) (int64, string, bool) {
	ln2, _ := new(big.Rat).SetString(""0.6931471805599453094172"")
	h := big.NewRat(1, 2)
	h.Quo(h, ln2)
	var f big.Rat
	var w big.Int
	for i := int64(1); i <= n; i++ {
		h.Quo(h.Mul(h, f.SetInt64(i)), ln2)
	}
	w.Quo(h.Num(), h.Denom())
	f.Sub(h, f.SetInt(&w))
	y, _ := f.Float64()
	d := fmt.Sprintf(""%.3f"", y)
	return w.Int64(), d[1:], d[2] == '0' || d[2] == '9'
}

func TestHickersonSeries(t *testing.T) {
	for i := int64(1); i <= 17; i++ {
		integerPart, decimalPart, isAlmostInteger := hickerson(i)
		if !isAlmostInteger {
			t.Errorf(""Failed for n=%d: h(n)=%d%s is not an almost integer"", i, integerPart, decimalPart)
		} else {
			t.Logf(""Success for n=%d: h(n)=%d%s is an almost integer"", i, integerPart, decimalPart)
		}
	}
}

func main() {
	TestHickersonSeries(&testing.T{})
}
",./data/generated/docs_golang/hickerson_series_of_almost_integers/gpt_4o_2024_08_06_hickerson_series_of_almost_integers_test.go,CompileStatus.SYNTAX_ERROR,,,,0.04,0.33,,0.0,[],False,False,,False,"[{'file': './gpt_4o_2024_08_06_hickerson_series_of_almost_integers_test.go', 'line': 37, 'column': 6, 'message': 'main redeclared in this block'}]"
Higher-order functions,"Task

Pass a function     as an argument     to another function.



Related task

   First-class functions

",Go,"package main
import ""fmt""
 
func func1(f func(string) string) string { return f(""a string"") }
func func2(s string) string { return ""func2 called with "" + s }
func main() { fmt.Println(func1(func2)) }",199,6,"package main

import (
	""testing""
)

// TestFunc1 tests the func1 function by passing func2 as an argument.
func TestFunc1(t *testing.T) {
	expected := ""func2 called with a string""
	result := func1(func2)

	if result != expected {
		t.Errorf(""Expected %s but got %s"", expected, result)
	}
}

// TestFunc2 tests the func2 function directly.
func TestFunc2(t *testing.T) {
	input := ""test input""
	expected := ""func2 called with test input""
	result := func2(input)

	if result != expected {
		t.Errorf(""Expected %s but got %s"", expected, result)
	}
}

// TestFunc1WithAnonymousFunction tests the func1 function by passing an anonymous function as an argument.
func TestFunc1WithAnonymousFunction(t *testing.T) {
	anonymousFunc := func(s string) string {
		return ""anonymous function called with "" + s
	}

	expected := ""anonymous function called with a string""
	result := func1(anonymousFunc)

	if result != expected {
		t.Errorf(""Expected %s but got %s"", expected, result)
	}
}
",./data/generated/docs_golang/higher_order_functions/gpt_4o_2024_08_06_higher_order_functions_test.go,CompileStatus.OK,0.0,66.7,,0.15,1.0,0.115,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: func1', 'Severity': '', 'SourceLines': ['\tresult := func1(func2)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_higher_order_functions_test.go', 'Offset': 0, 'Line': 10, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: func2', 'Severity': '', 'SourceLines': ['\tresult := func2(input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_higher_order_functions_test.go', 'Offset': 0, 'Line': 21, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: func1', 'Severity': '', 'SourceLines': ['\tresult := func1(anonymousFunc)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_higher_order_functions_test.go', 'Offset': 0, 'Line': 35, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Hofstadter Figure-Figure sequences,"These two sequences of positive integers are defined as:

 







R
(
1
)



=
1
 
;
 
S
(
1
)
=
2




R
(
n
)



=
R
(
n
−
1
)
+
S
(
n
−
1
)
,

n
>
1.






{\displaystyle {\begin{aligned}R(1)&=1\ ;\ S(1)=2\\R(n)&=R(n-1)+S(n-1),\quad n>1.\end{aligned}}}




The sequence 



S
(
n
)


{\displaystyle S(n)}

 is further defined as the sequence of positive integers not present in 



R
(
n
)


{\displaystyle R(n)}

.

Sequence 



R


{\displaystyle R}

 starts:

   1, 3, 7, 12, 18, ...

Sequence 



S


{\displaystyle S}

 starts:

   2, 4, 5, 6, 8, ...



Task

 Create two functions named ffr and ffs that when given n return R(n) or S(n) respectively.
(Note that R(1) = 1 and S(1) = 2 to avoid off-by-one errors).
 No maximum value for n should be assumed.
 Calculate and show that the first ten values of R are:
 1, 3, 7, 12, 18, 26, 35, 45, 56, and 69
 Calculate and show that the first 40 values of ffr plus the first 960 values of ffs include all the integers from 1 to 1000 exactly once.


References

 Sloane's A005228 and A030124.
 Wolfram MathWorld
 Wikipedia: Hofstadter Figure-Figure sequences.

",Go,"package main
 
import ""fmt""
 
var ffr, ffs func(int) int
 
// The point of the init function is to encapsulate r and s.  If you are
// not concerned about that or do not want that, r and s can be variables at
// package level and ffr and ffs can be ordinary functions at package level.
func init() {
    // task 1, 2
    r := []int{0, 1}
    s := []int{0, 2}
 
    ffr = func(n int) int {
        for len(r) <= n {
            nrk := len(r) - 1       // last n for which r(n) is known
            rNxt := r[nrk] + s[nrk] // next value of r:  r(nrk+1)
            r = append(r, rNxt)     // extend sequence r by one element
            for sn := r[nrk] + 2; sn < rNxt; sn++ {
                s = append(s, sn)   // extend sequence s up to rNext
            }
            s = append(s, rNxt+1)   // extend sequence s one past rNext
        }
        return r[n]
    }
 
    ffs = func(n int) int {
        for len(s) <= n {
            ffr(len(r))
        }
        return s[n]
    }
}
 
func main() {
    // task 3
    for n := 1; n <= 10; n++ {
        fmt.Printf(""r(%d): %d\n"", n, ffr(n))
    }
    // task 4
    var found [1001]int
    for n := 1; n <= 40; n++ {
        found[ffr(n)]++
    }
    for n := 1; n <= 960; n++ {
        found[ffs(n)]++
    }
    for i := 1; i <= 1000; i++ {
        if found[i] != 1 {
            fmt.Println(""task 4: FAIL"")
            return
        }
    }
    fmt.Println(""task 4: PASS"")
}",1425,56,"package main

import (
	""testing""
)

// TestFFR tests the ffr function for the first 10 values of R.
func TestFFR(t *testing.T) {
	expectedR := []int{1, 3, 7, 12, 18, 26, 35, 45, 56, 69}
	for n, expected := range expectedR {
		result := ffr(n + 1) // ffr is 1-based
		if result != expected {
			t.Errorf(""ffr(%d) = %d; want %d"", n+1, result, expected)
		}
	}
}

// TestFFS tests the ffs function to ensure it generates the correct sequence.
func TestFFS(t *testing.T) {
	// We will test the first few values of S to ensure correctness.
	expectedS := []int{2, 4, 5, 6, 8, 9, 10, 11, 13, 14}
	for n, expected := range expectedS {
		result := ffs(n + 1) // ffs is 1-based
		if result != expected {
			t.Errorf(""ffs(%d) = %d; want %d"", n+1, result, expected)
		}
	}
}

// TestCompleteSequence tests that the first 40 values of ffr and the first 960 values of ffs
// include all integers from 1 to 1000 exactly once.
func TestCompleteSequence(t *testing.T) {
	var found [1001]int
	for n := 1; n <= 40; n++ {
		found[ffr(n)]++
	}
	for n := 1; n <= 960; n++ {
		found[ffs(n)]++
	}
	for i := 1; i <= 1000; i++ {
		if found[i] != 1 {
			t.Errorf(""Integer %d is found %d times; want 1"", i, found[i])
		}
	}
}
",./data/generated/docs_golang/hofstadter_figure_figure_sequences/gpt_4o_2024_08_06_hofstadter_figure_figure_sequences_test.go,CompileStatus.OK,0.0,55.6,,0.13,0.27,0.126,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: ffr', 'Severity': '', 'SourceLines': ['\t\tresult := ffr(n + 1) // ffr is 1-based'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hofstadter_figure_figure_sequences_test.go', 'Offset': 0, 'Line': 11, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: ffs', 'Severity': '', 'SourceLines': ['\t\tresult := ffs(n + 1) // ffs is 1-based'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hofstadter_figure_figure_sequences_test.go', 'Offset': 0, 'Line': 23, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: ffr', 'Severity': '', 'SourceLines': ['\t\tfound[ffr(n)]++'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hofstadter_figure_figure_sequences_test.go', 'Offset': 0, 'Line': 35, 'Column': 9}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: ffs', 'Severity': '', 'SourceLines': ['\t\tfound[ffs(n)]++'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hofstadter_figure_figure_sequences_test.go', 'Offset': 0, 'Line': 38, 'Column': 9}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Hofstadter Q sequence,"Hofstadter Q sequence


 







Q
(
1
)



=
Q
(
2
)
=
1
,




Q
(
n
)



=
Q


(


n
−
Q
(
n
−
1
)


)


+
Q


(


n
−
Q
(
n
−
2
)


)


,

n
>
2.






{\displaystyle {\begin{aligned}Q(1)&=Q(2)=1,\\Q(n)&=Q{\big (}n-Q(n-1){\big )}+Q{\big (}n-Q(n-2){\big )},\quad n>2.\end{aligned}}}




It is defined like the Fibonacci sequence, but whereas the next term in the Fibonacci sequence is the sum of the previous two terms, in the Q sequence the previous two terms tell you how far to go back in the Q sequence to find the two numbers to sum to make the next term of the sequence.



Task

 Confirm and display that the first ten terms of the sequence are: 1, 1, 2, 3, 3, 4, 5, 5, 6, and 6 
 Confirm and display that the 1000th term is:   502


Optional extra credit
 Count and display how many times a member of the sequence is less than its preceding term for terms up to and including the 100,000th term.
 Ensure that the extra credit solution   safely   handles being initially asked for an nth term where   n   is large.

(This point is to ensure that caching and/or recursion limits, if it is a concern, is correctly handled).



",Go,"package main
 
import ""fmt""
 
var m map[int]int
 
func initMap() {
    m = make(map[int]int)
    m[1] = 1
    m[2] = 1
}
 
func q(n int) (r int) {
    if r = m[n]; r == 0 {
        r = q(n-q(n-1)) + q(n-q(n-2))
        m[n] = r
    }
    return
}
 
func main() {
    initMap()
    // task
    for n := 1; n <= 10; n++ {
        showQ(n)
    }
    // task
    showQ(1000)
    // extra credit
    count, p := 0, 1
    for n := 2; n <= 1e5; n++ {
        qn := q(n)
        if qn < p {
            count++
        }
        p = qn
    }
    fmt.Println(""count:"", count)
    // extra credit
    initMap()
    showQ(1e6)
}
 
func showQ(n int) {
    fmt.Printf(""Q(%d) = %d\n"", n, q(n))
}",681,46,"package main

import (
	""testing""
)

func TestHofstadterQSequence(t *testing.T) {
	initMap()

	// Test the first ten terms of the sequence
	expectedFirstTen := []int{1, 1, 2, 3, 3, 4, 5, 5, 6, 6}
	for i, expected := range expectedFirstTen {
		if result := q(i + 1); result != expected {
			t.Errorf(""Q(%d) = %d; want %d"", i+1, result, expected)
		}
	}

	// Test the 1000th term of the sequence
	expected1000th := 502
	if result := q(1000); result != expected1000th {
		t.Errorf(""Q(1000) = %d; want %d"", result, expected1000th)
	}

	// Extra credit: Count how many times a member of the sequence is less than its preceding term
	count, p := 0, 1
	for n := 2; n <= 1e5; n++ {
		qn := q(n)
		if qn < p {
			count++
		}
		p = qn
	}

	expectedCount := 4969 // This is the expected count based on the sequence properties
	if count != expectedCount {
		t.Errorf(""Count of terms less than their preceding term = %d; want %d"", count, expectedCount)
	}
}
",./data/generated/docs_golang/hofstadter_q_sequence/gpt_4o_2024_08_06_hofstadter_q_sequence_test.go,CompileStatus.OK,0.0,33.3,,0.15,0.38,0.324,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: initMap', 'Severity': '', 'SourceLines': ['\tinitMap()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hofstadter_q_sequence_test.go', 'Offset': 0, 'Line': 8, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: q', 'Severity': '', 'SourceLines': ['\t\tif result := q(i + 1); result != expected {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hofstadter_q_sequence_test.go', 'Offset': 0, 'Line': 13, 'Column': 16}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: q', 'Severity': '', 'SourceLines': ['\tif result := q(1000); result != expected1000th {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hofstadter_q_sequence_test.go', 'Offset': 0, 'Line': 20, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: q', 'Severity': '', 'SourceLines': ['\t\tqn := q(n)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hofstadter_q_sequence_test.go', 'Offset': 0, 'Line': 27, 'Column': 9}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
"Hofstadter-Conway $10,000 sequence","The definition of the sequence is colloquially described as:

   Starting with the list [1,1],
   Take the last number in the list so far: 1, I'll call it x.
   Count forward x places from the beginning of the list to find the first number to add (1)
   Count backward x places from the end of the list to find the second number to add (1)
   Add the two indexed numbers from the list and the result becomes the next number in the list (1+1)
   This would then produce [1,1,2] where 2 is the third element of the sequence.

Note that indexing for the description above starts from alternately the left and right ends of the list and starts from an index of one.

A less wordy description of the sequence is:

   a(1)=a(2)=1
   a(n)=a(a(n-1))+a(n-a(n-1))

The sequence begins:

   1, 1, 2, 2, 3, 4, 4, 4, 5, ...

Interesting features of the sequence are that:

   a(n)/n   tends to   0.5   as   n   grows towards infinity.
   a(n)/n   where   n   is a power of   2   is   0.5
   For   n>4   the maximal value of   a(n)/n   between successive powers of 2 decreases.



The sequence is so named because John Conway offered a prize of $10,000 to the first person who could
find the first position,   p   in the sequence where

   │a(n)/n│ < 0.55  for all  n > p

It was later found that Hofstadter had also done prior work on the sequence.

The 'prize' was won quite quickly by Dr. Colin L. Mallows who proved the properties of the sequence and allowed him to find the value of   n   (which is much smaller than the 3,173,375,556 quoted in the NYT article).



Task

   Create a routine to generate members of the Hofstadter-Conway $10,000 sequence.
   Use it to show the maxima of   a(n)/n   between successive powers of two up to   2**20
   As a stretch goal:   compute the value of   n   that would have won the prize and confirm it is true for   n   up to 2**20


Also see

   Conways Challenge Sequence, Mallows' own account.
   Mathworld Article.

",Go,"package main
 
import (
    ""fmt""
)
 
func main() {
    a := []int{0, 1, 1} // ignore 0 element. work 1 based.
    x := 1  // last number in list
    n := 2  // index of last number in list = len(a)-1
    mallow := 0
    for p := 1; p < 20; p++ {
        max := 0.
        for nextPot := n*2; n < nextPot; {
            n = len(a) // advance n
            x = a[x]+a[n-x]
            a = append(a, x)
            f := float64(x)/float64(n)
            if f > max {
                max = f
            }
            if f >= .55 {
                mallow = n
            }
        }
        fmt.Printf(""max between 2^%d and 2^%d was %f\n"", p, p+1, max)
    }
    fmt.Println(""winning number"", mallow)
}",699,29,"package main

import (
    ""testing""
)

// TestHofstadterConwaySequence tests the generation of the Hofstadter-Conway $10,000 sequence
func TestHofstadterConwaySequence(t *testing.T) {
    a := []int{0, 1, 1} // ignore 0 element. work 1 based.
    x := 1  // last number in list
    n := 2  // index of last number in list = len(a)-1
    mallow := 0
    expectedMaxima := []float64{0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5}
    expectedMallow := 3

    for p := 1; p < 20; p++ {
        max := 0.
        for nextPot := n*2; n < nextPot; {
            n = len(a) // advance n
            x = a[x]+a[n-x]
            a = append(a, x)
            f := float64(x)/float64(n)
            if f > max {
                max = f
            }
            if f >= .55 {
                mallow = n
            }
        }
        if max != expectedMaxima[p-1] {
            t.Errorf(""max between 2^%d and 2^%d was %f, expected %f"", p, p+1, max, expectedMaxima[p-1])
        }
    }
    if mallow != expectedMallow {
        t.Errorf(""winning number was %d, expected %d"", mallow, expectedMallow)
    }
}
",./data/generated/docs_golang/hofstadter_conway_10_000_sequence/gpt_4o_2024_08_06_hofstadter_conway_10_000_sequence_test.go,CompileStatus.OK,0.0,0.0,,0.08,0.4,0.304,0.0,[],False,False,0.0,False,[]
Horizontal sundial calculations,"Task

Create a program that calculates the hour, sun hour angle, dial hour line angle from 6am to 6pm for an operator entered location.



For example, the user is prompted for a location and inputs the latitude and longitude 4°57′S 150°30′W (4.95°S 150.5°W of Jules Verne's Lincoln Island, aka Ernest Legouve Reef), with a legal meridian of 150°W.

(Note: the ""meridian"" is approximately the same concept as the ""longitude"" - the distinction is that the meridian is used to determine when it is ""noon"" for official purposes. This will typically be slightly different from when the sun appears at its highest location, because of the structure of time zones. For most, but not all, time zones (hour wide zones with hour zero centred on Greenwich), the legal meridian will be an even multiple of 15 degrees.)

Wikipedia: A sundial is a device that measures time by the position of the Sun. In common designs such as the horizontal sundial, the sun casts a shadow from its style (also called its Gnomon, a thin rod or a sharp, straight edge) onto a flat surface marked with lines indicating the hours of the day (also called the dial face or dial plate). As the sun moves across the sky, the shadow-edge progressively aligns with different hour-lines on the plate. Such designs rely on the style being aligned with the axis of the Earth's rotation. Hence, if such a sundial is to tell the correct time, the style must point towards true north (not the north or south magnetic pole) and the style's angle with horizontal must equal the sundial's geographical latitude.



",Go,"package main
 
import (
    ""fmt""
    ""math""
    ""os""
)
 
func getnum(prompt string) (r float64) {
    fmt.Print(prompt)
    if _, err := fmt.Scan(&r); err != nil {
        fmt.Println(err)
        os.Exit(-1)
    }
    return
}
 
func main() {
    lat := getnum(""Enter latitude       => "")
    lng := getnum(""Enter longitude      => "")
    ref := getnum(""Enter legal meridian => "")
    slat := math.Sin(lat * math.Pi / 180)
    diff := lng - ref
    fmt.Println(""\n    sine of latitude:   "", slat)
    fmt.Println(""    diff longitude:     "", diff)
    fmt.Println(""\nHour, sun hour angle, dial hour line angle from 6am to 6pm"")
    for h := -6.; h <= 6; h++ {
        hra := 15*h - diff
        s, c := math.Sincos(hra * math.Pi / 180)
        hla := math.Atan2(slat*s, c) * 180 / math.Pi
        fmt.Printf(""%2.0f %8.3f %8.3f\n"", h, hra, hla)
    }
}",852,33,"package main

import (
    ""bytes""
    ""fmt""
    ""math""
    ""os""
    ""testing""
)

// Mock function to replace fmt.Scan for testing
func mockScan(inputs []string) func(a ...interface{}) (n int, err error) {
    var index int
    return func(a ...interface{}) (n int, err error) {
        if index < len(inputs) {
            fmt.Sscan(inputs[index], a...)
            index++
            return 1, nil
        }
        return 0, fmt.Errorf(""no more input"")
    }
}

func TestMainFunction(t *testing.T) {
    // Save original functions
    originalScan := fmt.Scan
    originalExit := os.Exit

    // Mock fmt.Scan and os.Exit
    fmt.Scan = mockScan([]string{""4.95"", ""150.5"", ""150""})
    os.Exit = func(code int) {
        if code != 0 {
            t.Fatalf(""Unexpected exit with code %d"", code)
        }
    }

    // Capture output
    var buf bytes.Buffer
    fmtPrint := fmt.Print
    fmtPrintf := fmt.Printf
    fmtPrintln := fmt.Println
    fmt.Print = func(a ...interface{}) (n int, err error) {
        return fmt.Fprint(&buf, a...)
    }
    fmt.Printf = func(format string, a ...interface{}) (n int, err error) {
        return fmt.Fprintf(&buf, format, a...)
    }
    fmt.Println = func(a ...interface{}) (n int, err error) {
        return fmt.Fprintln(&buf, a...)
    }

    // Run main function
    main()

    // Restore original functions
    fmt.Scan = originalScan
    os.Exit = originalExit
    fmt.Print = fmtPrint
    fmt.Printf = fmtPrintf
    fmt.Println = fmtPrintln

    // Expected output
    expectedOutput := `
    sine of latitude:    -0.08682408883346517
    diff longitude:      0.5

Hour, sun hour angle, dial hour line angle from 6am to 6pm
-6   -90.500   -5.002
-5   -75.500   -4.166
-4   -60.500   -3.333
-3   -45.500   -2.504
-2   -30.500   -1.679
-1   -15.500   -0.858
 0     0.500    0.000
 1    15.500    0.858
 2    30.500    1.679
 3    45.500    2.504
 4    60.500    3.333
 5    75.500    4.166
 6    90.500    5.002
`

    // Compare captured output with expected output
    if buf.String() != expectedOutput {
        t.Errorf(""Unexpected output:\n%s\nExpected:\n%s"", buf.String(), expectedOutput)
    }
}
",./data/generated/docs_golang/horizontal_sundial_calculations/gpt_4o_2024_08_06_horizontal_sundial_calculations_test.go,CompileStatus.SYNTAX_ERROR,,,,0.08,0.75,,7.0,"[{'FromLinter': 'typecheck', 'Text': 'use of package fmt not in selector', 'Severity': '', 'SourceLines': ['    fmt.Scan = mockScan([]string{""4.95"", ""150.5"", ""150""})'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_horizontal_sundial_calculations_test.go', 'Offset': 0, 'Line': 30, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'use of package os not in selector', 'Severity': '', 'SourceLines': ['    os.Exit = func(code int) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_horizontal_sundial_calculations_test.go', 'Offset': 0, 'Line': 31, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'use of package fmt not in selector', 'Severity': '', 'SourceLines': ['    fmt.Print = func(a ...interface{}) (n int, err error) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_horizontal_sundial_calculations_test.go', 'Offset': 0, 'Line': 42, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'use of package fmt not in selector', 'Severity': '', 'SourceLines': ['    fmt.Printf = func(format string, a ...interface{}) (n int, err error) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_horizontal_sundial_calculations_test.go', 'Offset': 0, 'Line': 45, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['    main()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_horizontal_sundial_calculations_test.go', 'Offset': 0, 'Line': 53, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'use of package os not in selector', 'Severity': '', 'SourceLines': ['    os.Exit = originalExit'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_horizontal_sundial_calculations_test.go', 'Offset': 0, 'Line': 57, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""math"" imported and not used', 'Severity': '', 'SourceLines': ['    ""math""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_horizontal_sundial_calculations_test.go', 'Offset': 0, 'Line': 6, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_horizontal_sundial_calculations_test.go', 'line': 30, 'column': 5, 'message': 'use of package fmt not in selector'}]"
Hostname,"Task

Find the name of the host on which the routine is running.



",Go,"package main
 
import (
	""fmt""
	""os""
)
 
func main() {
	fmt.Println(os.Hostname())
}",84,10,none,,,,,,,,,,,False,False,,False,
Hough transform,"Task

Implement the Hough transform, which is used as part of feature extraction with digital images.

It is a tool that makes it far easier to identify straight lines in the source image, whatever their orientation.

The transform maps each point in the target image, 



(
ρ
,
θ
)


{\displaystyle (\rho ,\theta )}

, to the average color of the pixels on the corresponding line of the source image (in 



(
x
,
y
)


{\displaystyle (x,y)}

-space, where the line corresponds to points of the form 



x
cos
⁡
θ
+
y
sin
⁡
θ
=
ρ


{\displaystyle x\cos \theta +y\sin \theta =\rho }

). The idea is that where there is a straight line in the original image, it corresponds to a bright (or dark, depending on the color of the background field) spot; by applying a suitable filter to the results of the transform, it is possible to extract the locations of the lines in the original image.

 Sample PNG image to use for the Hough transform.
The target space actually uses polar coordinates, but is conventionally plotted on rectangular coordinates for display. There's no specification of exactly how to map polar coordinates to a flat surface for display, but a convenient method is to use one axis for 



θ


{\displaystyle \theta }

 and the other for 



ρ


{\displaystyle \rho }

, with the center of the source image being the origin.

There is also a spherical Hough transform, which is more suited to identifying planes in 3D data.



",Go,"package main
 
import (
    ""fmt""
    ""image""
    ""image/color""
    ""image/draw""
    ""image/png""
    ""math""
    ""os""
)
 
func hough(im image.Image, ntx, mry int) draw.Image {
    nimx := im.Bounds().Max.X
    mimy := im.Bounds().Max.Y
 
    him := image.NewGray(image.Rect(0, 0, ntx, mry))
    draw.Draw(him, him.Bounds(), image.NewUniform(color.White),
        image.Point{}, draw.Src)
 
    rmax := math.Hypot(float64(nimx), float64(mimy))
    dr := rmax / float64(mry/2)
    dth := math.Pi / float64(ntx)
 
    for jx := 0; jx < nimx; jx++ {
        for iy := 0; iy < mimy; iy++ {
            col := color.GrayModel.Convert(im.At(jx, iy)).(color.Gray)
            if col.Y == 255 {
                continue
            }
            for jtx := 0; jtx < ntx; jtx++ {
                th := dth * float64(jtx)
                r := float64(jx)*math.Cos(th) + float64(iy)*math.Sin(th)
                iry := mry/2 - int(math.Floor(r/dr+.5))
                col = him.At(jtx, iry).(color.Gray)
                if col.Y > 0 {
                    col.Y--
                    him.SetGray(jtx, iry, col)
                }
            }
        }
    }
    return him
}
 
func main() {
    f, err := os.Open(""Pentagon.png"")
    if err != nil {
        fmt.Println(err)
        return
    }
    pent, err := png.Decode(f)
    if err != nil {
        fmt.Println(err)
        return
    }
    if err = f.Close(); err != nil {
        fmt.Println(err)
    }
    h := hough(pent, 460, 360)
    if f, err = os.Create(""hough.png""); err != nil {
        fmt.Println(err)
        return
    }
    if err = png.Encode(f, h); err != nil {
        fmt.Println(err)
    }
    if cErr := f.Close(); cErr != nil && err == nil {
        fmt.Println(err)
    }
}",1738,71,"package main

import (
    ""image""
    ""image/color""
    ""image/draw""
    ""image/png""
    ""math""
    ""os""
    ""testing""
)

// TestHoughTransform tests the Hough transform function with a sample image.
func TestHoughTransform(t *testing.T) {
    // Open the sample image
    f, err := os.Open(""Pentagon.png"")
    if err != nil {
        t.Fatalf(""Failed to open image: %v"", err)
    }
    defer f.Close()

    // Decode the image
    pent, err := png.Decode(f)
    if err != nil {
        t.Fatalf(""Failed to decode image: %v"", err)
    }

    // Perform the Hough transform
    ntx, mry := 460, 360
    houghImage := hough(pent, ntx, mry)

    // Check the dimensions of the output image
    if houghImage.Bounds().Max.X != ntx || houghImage.Bounds().Max.Y != mry {
        t.Errorf(""Unexpected dimensions of Hough image: got (%d, %d), want (%d, %d)"",
            houghImage.Bounds().Max.X, houghImage.Bounds().Max.Y, ntx, mry)
    }

    // Check if the output image is not entirely white (indicating some lines were detected)
    isWhite := true
    for x := 0; x < ntx; x++ {
        for y := 0; y < mry; y++ {
            col := houghImage.At(x, y).(color.Gray)
            if col.Y != 255 {
                isWhite = false
                break
            }
        }
        if !isWhite {
            break
        }
    }
    if isWhite {
        t.Error(""Hough image is entirely white, no lines detected"")
    }
}

// TestHoughTransformEmptyImage tests the Hough transform with an empty image.
func TestHoughTransformEmptyImage(t *testing.T) {
    // Create an empty white image
    emptyImage := image.NewGray(image.Rect(0, 0, 100, 100))
    draw.Draw(emptyImage, emptyImage.Bounds(), image.NewUniform(color.White), image.Point{}, draw.Src)

    // Perform the Hough transform
    ntx, mry := 460, 360
    houghImage := hough(emptyImage, ntx, mry)

    // Check if the output image is entirely white (indicating no lines were detected)
    for x := 0; x < ntx; x++ {
        for y := 0; y < mry; y++ {
            col := houghImage.At(x, y).(color.Gray)
            if col.Y != 255 {
                t.Error(""Hough image is not entirely white for an empty input image"")
                return
            }
        }
    }
}

// TestHoughTransformSingleLine tests the Hough transform with an image containing a single line.
func TestHoughTransformSingleLine(t *testing.T) {
    // Create an image with a single black line
    lineImage := image.NewGray(image.Rect(0, 0, 100, 100))
    draw.Draw(lineImage, lineImage.Bounds(), image.NewUniform(color.White), image.Point{}, draw.Src)
    for i := 0; i < 100; i++ {
        lineImage.SetGray(i, i, color.Gray{Y: 0}) // Draw a diagonal line
    }

    // Perform the Hough transform
    ntx, mry := 460, 360
    houghImage := hough(lineImage, ntx, mry)

    // Check if the output image is not entirely white (indicating the line was detected)
    isWhite := true
    for x := 0; x < ntx; x++ {
        for y := 0; y < mry; y++ {
            col := houghImage.At(x, y).(color.Gray)
            if col.Y != 255 {
                isWhite = false
                break
            }
        }
        if !isWhite {
            break
        }
    }
    if isWhite {
        t.Error(""Hough image is entirely white, line was not detected"")
    }
}
",./data/generated/docs_golang/hough_transform/gpt_4o_2024_08_06_hough_transform_test.go,CompileStatus.SYNTAX_ERROR,,,,0.11,0.43,,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: hough', 'Severity': '', 'SourceLines': ['    houghImage := hough(pent, ntx, mry)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hough_transform_test.go', 'Offset': 0, 'Line': 30, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: hough', 'Severity': '', 'SourceLines': ['    houghImage := hough(emptyImage, ntx, mry)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hough_transform_test.go', 'Offset': 0, 'Line': 65, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: hough', 'Severity': '', 'SourceLines': ['    houghImage := hough(lineImage, ntx, mry)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hough_transform_test.go', 'Offset': 0, 'Line': 90, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""math"" imported and not used', 'Severity': '', 'SourceLines': ['    ""math""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_hough_transform_test.go', 'Offset': 0, 'Line': 8, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_hough_transform_test.go', 'line': 8, 'column': 5, 'message': '""math"" imported and not used'}]"
Humble numbers,"Humble numbers are positive integers which have   no   prime factors    >    7.



Humble numbers are also called   7-smooth numbers,   and sometimes called   highly composite,

although this conflicts with another meaning of   highly composite numbers.



Another way to express the above is:

  humble  =  2i × 3j × 5k × 7m 

           where     i, j, k, m ≥ 0 



Task

   show the first   50   humble numbers   (in a horizontal list)
   show the number of humble numbers that have   x   decimal digits for all   x's   up to   n   (inclusive).
   show   (as many as feasible or reasonable for above)   on separate lines
   show all output here on this page


Related tasks

   Hamming numbers


References

   Wikipedia: Smooth numbers, see the 2nd paragraph.
   OEIS A002473: humble numbers
   University of Ulm, The first 5842 terms of humble numbers

",Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
var (
    one   = new(big.Int).SetUint64(1)
    two   = new(big.Int).SetUint64(2)
    three = new(big.Int).SetUint64(3)
    five  = new(big.Int).SetUint64(5)
    seven = new(big.Int).SetUint64(7)
    ten   = new(big.Int).SetUint64(10)
)
 
func min(a, b *big.Int) *big.Int {
    if a.Cmp(b) < 0 {
        return a
    }
    return b
}
 
func humble(n int) []*big.Int {
    h := make([]*big.Int, n)
    h[0] = new(big.Int).Set(one)
    next2, next3 := new(big.Int).Set(two), new(big.Int).Set(three)
    next5, next7 := new(big.Int).Set(five), new(big.Int).Set(seven)
    var i, j, k, l int
    for m := 1; m < len(h); m++ {
        h[m] = new(big.Int).Set(min(next2, min(next3, min(next5, next7))))
        if h[m].Cmp(next2) == 0 {
            i++
            next2.Mul(two, h[i])
        }
        if h[m].Cmp(next3) == 0 {
            j++
            next3.Mul(three, h[j])
        }
        if h[m].Cmp(next5) == 0 {
            k++
            next5.Mul(five, h[k])
        }
        if h[m].Cmp(next7) == 0 {
            l++
            next7.Mul(seven, h[l])
        }
    }
    return h
}
 
func commatize(n int) string {
    s := fmt.Sprintf(""%d"", n)
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    return s
}
 
func main() {
    const n = 13 * 1e6  // calculate the first 13 million humble numbers, say
    h := humble(n) 
    fmt.Println(""The first 50 humble numbers are:"")
    fmt.Println(h[0:50])
 
    maxDigits := len(h[len(h)-1].String()) - 1
    counts := make([]int, maxDigits+1)
    var maxUsed int
    digits := 1
    pow10 := new(big.Int).Set(ten)
    for i := 0; i < len(h); i++ {
        for {
            if h[i].Cmp(pow10) >= 0 {
                pow10.Mul(pow10, ten)
                digits++
            } else {
                break
            }
        }  
        if digits > maxDigits {
            maxUsed = i
            break
        }
        counts[digits]++
    }
    fmt.Printf(""\nOf the first %s humble numbers:\n"", commatize(maxUsed))
    for i := 1; i <= maxDigits; i++ {
        s := ""s""
        if i == 1 {
            s = """"
        }
        fmt.Printf(""%9s have %2d digit%s\n"", commatize(counts[i]), i, s)
    }       
}",2268,95,"package main

import (
    ""testing""
    ""math/big""
    ""reflect""
)

// Test the min function
func TestMin(t *testing.T) {
    a := big.NewInt(2)
    b := big.NewInt(3)
    result := min(a, b)
    if result.Cmp(a) != 0 {
        t.Errorf(""Expected %v, got %v"", a, result)
    }

    a = big.NewInt(5)
    b = big.NewInt(5)
    result = min(a, b)
    if result.Cmp(a) != 0 {
        t.Errorf(""Expected %v, got %v"", a, result)
    }
}

// Test the humble function for the first 50 humble numbers
func TestHumble(t *testing.T) {
    expected := []*big.Int{
        big.NewInt(1), big.NewInt(2), big.NewInt(3), big.NewInt(4), big.NewInt(5),
        big.NewInt(6), big.NewInt(7), big.NewInt(8), big.NewInt(9), big.NewInt(10),
        big.NewInt(12), big.NewInt(14), big.NewInt(15), big.NewInt(16), big.NewInt(18),
        big.NewInt(20), big.NewInt(21), big.NewInt(24), big.NewInt(25), big.NewInt(27),
        big.NewInt(28), big.NewInt(30), big.NewInt(32), big.NewInt(35), big.NewInt(36),
        big.NewInt(40), big.NewInt(42), big.NewInt(45), big.NewInt(48), big.NewInt(49),
        big.NewInt(50), big.NewInt(54), big.NewInt(56), big.NewInt(60), big.NewInt(63),
        big.NewInt(64), big.NewInt(70), big.NewInt(72), big.NewInt(75), big.NewInt(80),
        big.NewInt(81), big.NewInt(84), big.NewInt(90), big.NewInt(96), big.NewInt(98),
        big.NewInt(100), big.NewInt(105), big.NewInt(108), big.NewInt(112),
    }

    result := humble(50)

    if !reflect.DeepEqual(result, expected) {
        t.Errorf(""Expected %v, got %v"", expected, result)
    }
}

// Test the commatize function
func TestCommatize(t *testing.T) {
    tests := []struct {
        input    int
        expected string
    }{
        {1, ""1""},
        {12, ""12""},
        {123, ""123""},
        {1234, ""1,234""},
        {12345, ""12,345""},
        {123456, ""123,456""},
        {1234567, ""1,234,567""},
    }

    for _, test := range tests {
        result := commatize(test.input)
        if result != test.expected {
            t.Errorf(""For input %d, expected %s, got %s"", test.input, test.expected, result)
        }
    }
}
",./data/generated/docs_golang/humble_numbers/gpt_4o_2024_08_06_humble_numbers_test.go,CompileStatus.OK,0.0,52.8,,0.09,0.24,0.102,4.0,"[{'FromLinter': 'typecheck', 'Text': 'invalid argument: a (variable of type *big.Int) cannot be ordered', 'Severity': '', 'SourceLines': ['    result := min(a, b)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_humble_numbers_test.go', 'Offset': 0, 'Line': 13, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'invalid argument: a (variable of type *big.Int) cannot be ordered', 'Severity': '', 'SourceLines': ['    result = min(a, b)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_humble_numbers_test.go', 'Offset': 0, 'Line': 20, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: humble', 'Severity': '', 'SourceLines': ['    result := humble(50)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_humble_numbers_test.go', 'Offset': 0, 'Line': 41, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: commatize', 'Severity': '', 'SourceLines': ['        result := commatize(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_humble_numbers_test.go', 'Offset': 0, 'Line': 64, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,66.67,False,[]
I before E except after C,"The phrase      ""I before E, except after C""     is a
widely known mnemonic which is supposed to help when spelling English words.



Task

Using the word list from   http://wiki.puzzlers.org/pub/wordlists/unixdict.txt,

check if the two sub-clauses of the phrase are plausible individually:

   ""I before E when not preceded by C""
   ""E before I when preceded by C""


If both sub-phrases are plausible then the original phrase can be said to be plausible.

Something is plausible if the number of words having the feature is more than two times the number of words having the opposite feature (where feature is 'ie' or 'ei' preceded or not by 'c' as appropriate).



Stretch goal

As a stretch goal use the entries from the table of Word Frequencies in Written and Spoken English: based on the British National Corpus, (selecting those rows with three space or tab separated words only), to see if the phrase is plausible when word frequencies are taken into account.


Show your output here as well as your program.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




cf.

 Schools to rethink 'i before e' - BBC news, 20 June 2009
 I Before E Except After C - QI Series 8 Ep 14, (humorous)
 Companion website for the book: ""Word Frequencies in Written and Spoken English: based on the British National Corpus"".

",Go,"package main
 
import (
	""bufio""
	""fmt""
	""log""
	""os""
	""regexp""
	""strings""
)
 
func main() {
	f, err := os.Open(""unixdict.txt"")
	if err != nil {
		log.Fatalln(err)
	}
	defer f.Close()
 
	s := bufio.NewScanner(f)
	rie := regexp.MustCompile(""^ie|[^c]ie"")
	rei := regexp.MustCompile(""^ei|[^c]ei"")
	var cie, ie int
	var cei, ei int
	for s.Scan() {
		line := s.Text()
		if strings.Contains(line, ""cie"") {
			cie++
		}
		if strings.Contains(line, ""cei"") {
			cei++
		}
		if rie.MatchString(line) {
			ie++
		}
		if rei.MatchString(line) {
			ei++
		}
	}
	err = s.Err()
	if err != nil {
		log.Fatalln(err)
	}
 
	if check(ie, ei, ""I before E when not preceded by C"") &&
		check(cei, cie, ""E before I when preceded by C"") {
		fmt.Println(""Both plausable."")
		fmt.Println(`""I before E, except after C"" is plausable.`)
	} else {
		fmt.Println(""One or both implausable."")
		fmt.Println(`""I before E, except after C"" is implausable.`)
	}
}
 
// check checks if a statement is plausible. Something is plausible if a is more
// than two times b.
func check(a, b int, s string) bool {
	switch {
	case a > b*2:
		fmt.Printf(""%q is plausible (%d vs %d).\n"", s, a, b)
		return true
	case a >= b:
		fmt.Printf(""%q is implausible (%d vs %d).\n"", s, a, b)
	default:
		fmt.Printf(""%q is implausible and contra-indicated (%d vs %d).\n"",
			s, a, b)
	}
	return false
}",1342,68,error,,,,,,,,,,,False,False,,False,
Idiomatically determine all the lowercase and uppercase letters,"
Idiomatically determine all the lowercase and uppercase letters   (of the Latin [English] alphabet)   being used currently by a computer programming language.
The method should find the letters regardless of the hardware architecture that is being used (ASCII, EBCDIC, or other).



Task requirements
Display the set of all:

   lowercase letters 
   uppercase letters

that can be used (allowed) by the computer program,


where   letter   is a member of the Latin (English) alphabet:     a ──► z     and     A ──► Z.



You may want to mention what hardware architecture is being used, and if applicable, the operating system.



See also
 Idiomatically determine all the characters that can be used for symbols.

",Go,"package main
 
import (
	""fmt""
	""unicode""
)
 
const (
	lcASCII = ""abcdefghijklmnopqrstuvwxyz""
	ucASCII = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
)
 
func main() {
	fmt.Println(""ASCII lower case:"")
	fmt.Println(lcASCII)
	for l := 'a'; l <= 'z'; l++ {
		fmt.Print(string(l))
	}
	fmt.Println()
 
	fmt.Println(""\nASCII upper case:"")
	fmt.Println(ucASCII)
	for l := 'A'; l <= 'Z'; l++ {
		fmt.Print(string(l))
	}
	fmt.Println()
 
	fmt.Println(""\nUnicode version "" + unicode.Version)
	showRange16(""Lower case 16-bit code points:"", unicode.Lower.R16)
	showRange32(""Lower case 32-bit code points:"", unicode.Lower.R32)
	showRange16(""Upper case 16-bit code points:"", unicode.Upper.R16)
	showRange32(""Upper case 32-bit code points:"", unicode.Upper.R32)
}
 
func showRange16(hdr string, rList []unicode.Range16) {
	fmt.Print(""\n"", hdr, ""\n"")
	fmt.Printf(""%d ranges:\n"", len(rList))
	for _, rng := range rList {
		fmt.Printf(""%U: "", rng.Lo)
		for r := rng.Lo; r <= rng.Hi; r += rng.Stride {
			fmt.Printf(""%c"", r)
		}
		fmt.Println()
	}
}
 
func showRange32(hdr string, rList []unicode.Range32) {
	fmt.Print(""\n"", hdr, ""\n"")
	fmt.Printf(""%d ranges:\n"", len(rList))
	for _, rng := range rList {
		fmt.Printf(""%U: "", rng.Lo)
		for r := rng.Lo; r <= rng.Hi; r += rng.Stride {
			fmt.Printf(""%c"", r)
		}
		fmt.Println()
	}
}",1296,57,"package main

import (
	""testing""
	""unicode""
)

func TestASCIICharacters(t *testing.T) {
	expectedLower := ""abcdefghijklmnopqrstuvwxyz""
	expectedUpper := ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""

	// Test lowercase ASCII
	for i, l := range expectedLower {
		if l != rune('a'+i) {
			t.Errorf(""Expected %c, but got %c"", rune('a'+i), l)
		}
	}

	// Test uppercase ASCII
	for i, l := range expectedUpper {
		if l != rune('A'+i) {
			t.Errorf(""Expected %c, but got %c"", rune('A'+i), l)
		}
	}
}

func TestUnicodeLowerCase(t *testing.T) {
	for _, rng := range unicode.Lower.R16 {
		for r := rng.Lo; r <= rng.Hi; r += rng.Stride {
			if !unicode.IsLower(r) {
				t.Errorf(""Expected %c to be lowercase"", r)
			}
		}
	}

	for _, rng := range unicode.Lower.R32 {
		for r := rng.Lo; r <= rng.Hi; r += rng.Stride {
			if !unicode.IsLower(r) {
				t.Errorf(""Expected %c to be lowercase"", r)
			}
		}
	}
}

func TestUnicodeUpperCase(t *testing.T) {
	for _, rng := range unicode.Upper.R16 {
		for r := rng.Lo; r <= rng.Hi; r += rng.Stride {
			if !unicode.IsUpper(r) {
				t.Errorf(""Expected %c to be uppercase"", r)
			}
		}
	}

	for _, rng := range unicode.Upper.R32 {
		for r := rng.Lo; r <= rng.Hi; r += rng.Stride {
			if !unicode.IsUpper(r) {
				t.Errorf(""Expected %c to be uppercase"", r)
			}
		}
	}
}
",./data/generated/docs_golang/idiomatically_determine_all_the_lowercase_and_uppercase_letters/gpt_4o_2024_08_06_idiomatically_determine_all_the_lowercase_and_uppercase_letters_test.go,CompileStatus.SYNTAX_ERROR,,,,0.21,0.67,,4.0,"[{'FromLinter': 'typecheck', 'Text': 'cannot use r (variable of type uint16) as rune value in argument to unicode.IsLower', 'Severity': '', 'SourceLines': ['\t\t\tif !unicode.IsLower(r) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_idiomatically_determine_all_the_lowercase_and_uppercase_letters_test.go', 'Offset': 0, 'Line': 30, 'Column': 24}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'cannot use r (variable of type uint32) as rune value in argument to unicode.IsLower', 'Severity': '', 'SourceLines': ['\t\t\tif !unicode.IsLower(r) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_idiomatically_determine_all_the_lowercase_and_uppercase_letters_test.go', 'Offset': 0, 'Line': 38, 'Column': 24}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'cannot use r (variable of type uint16) as rune value in argument to unicode.IsUpper', 'Severity': '', 'SourceLines': ['\t\t\tif !unicode.IsUpper(r) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_idiomatically_determine_all_the_lowercase_and_uppercase_letters_test.go', 'Offset': 0, 'Line': 48, 'Column': 24}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'cannot use r (variable of type uint32) as rune value in argument to unicode.IsUpper', 'Severity': '', 'SourceLines': ['\t\t\tif !unicode.IsUpper(r) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_idiomatically_determine_all_the_lowercase_and_uppercase_letters_test.go', 'Offset': 0, 'Line': 56, 'Column': 24}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_idiomatically_determine_all_the_lowercase_and_uppercase_letters_test.go', 'line': 30, 'column': 24, 'message': 'cannot use r (variable of type uint16) as rune value in argument to unicode.IsLower'}]"
Inheritance/Single," This task is about derived types;   for implementation inheritance, see Polymorphism.


Inheritance is an operation of type algebra that creates a new type from one or several parent types.

The obtained type is called derived type.

It inherits some of the properties of its parent types.

Usually inherited properties are:

   methods
   components
   parts of the representation


The  class of the new type is a   subclass   of the classes rooted in the parent types.

When all (in certain sense) properties of the parents are preserved by the derived type,   it is said to be a Liskov subtype.

When properties are preserved then the derived type is substitutable for its parents in all contexts.   Usually full substitutability is achievable only in some contexts.



Inheritance is

   single, when only one parent is allowed
    multiple, otherwise


Some single inheritance languages usually allow multiple inheritance for certain abstract types, interfaces in particular.

Inheritance can be considered as a relation parent-child.

Parent types are sometimes called supertype, the derived ones are subtype.   This relation is transitive and reflexive.

Types bound by the relation form a wp:Directed_acyclic_graph directed acyclic graph (ignoring reflexivity).

With single inheritance it becomes a tree.



Task

Show a tree of types which inherit from each other.

   At the top of the tree should be a class called   Animal. 
   The second level should have Dog and Cat. 
   Under   Dog   should be   Lab   and   Collie. 
   None of the classes need to have any functions,   the only thing they need to do is inherit from the specified superclasses 
   (overriding functions should be shown in Polymorphism). 


The tree should look like this:

                        Animal
                          /\
                         /  \
                        /    \
                      Dog    Cat
                      /\
                     /  \
                    /    \
                  Lab  Collie


",Go,"package main
 
type animal struct {
    alive bool
}
 
type dog struct {
    animal
    obedienceTrained bool
}
 
type cat struct {
    animal
    litterBoxTrained bool
}
 
type lab struct {
    dog
    color string
}
 
type collie struct {
    dog
    catchesFrisbee bool
}
 
func main() {
    var pet lab
    pet.alive = true
    pet.obedienceTrained = false
    pet.color = ""yellow""
}
 ",389,33,"package main

import ""testing""

func TestAnimalInheritance(t *testing.T) {
    // Test Lab inheritance
    labPet := lab{}
    labPet.alive = true
    labPet.obedienceTrained = true
    labPet.color = ""black""

    if !labPet.alive {
        t.Error(""Expected labPet to be alive"")
    }
    if !labPet.obedienceTrained {
        t.Error(""Expected labPet to be obedience trained"")
    }
    if labPet.color != ""black"" {
        t.Errorf(""Expected labPet color to be black, got %s"", labPet.color)
    }

    // Test Collie inheritance
    colliePet := collie{}
    colliePet.alive = true
    colliePet.obedienceTrained = false
    colliePet.catchesFrisbee = true

    if !colliePet.alive {
        t.Error(""Expected colliePet to be alive"")
    }
    if colliePet.obedienceTrained {
        t.Error(""Expected colliePet not to be obedience trained"")
    }
    if !colliePet.catchesFrisbee {
        t.Error(""Expected colliePet to catch frisbee"")
    }

    // Test Cat inheritance
    catPet := cat{}
    catPet.alive = true
    catPet.litterBoxTrained = true

    if !catPet.alive {
        t.Error(""Expected catPet to be alive"")
    }
    if !catPet.litterBoxTrained {
        t.Error(""Expected catPet to be litter box trained"")
    }
}
",./data/generated/docs_golang/inheritance_single/gpt_4o_2024_08_06_inheritance_single_test.go,CompileStatus.OK,0.0,0.0,,0.27,8.0,0.091,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: lab', 'Severity': '', 'SourceLines': ['    labPet := lab{}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_inheritance_single_test.go', 'Offset': 0, 'Line': 7, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: collie', 'Severity': '', 'SourceLines': ['    colliePet := collie{}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_inheritance_single_test.go', 'Offset': 0, 'Line': 23, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: cat', 'Severity': '', 'SourceLines': ['    catPet := cat{}'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_inheritance_single_test.go', 'Offset': 0, 'Line': 39, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Input loop,"Input loop is part of Short Circuit's Console Program Basics selection.
Task

Read from a text stream either word-by-word or line-by-line until the stream runs out of data.

The stream will have an unknown amount of data on it.



",Go,"package main
 
import (
	""bufio""
	""io""
	""log""
	""os""
)
 
func main() {
	in := bufio.NewReader(os.Stdin)
	for {
		s, err := in.ReadString('\n')
		if err != nil {
			// io.EOF is expected, anything else
			// should be handled/reported
			if err != io.EOF {
				log.Fatal(err)
			}
			break
		}
		// Do something with the line of text
		// in string variable s.
		_ = s
	}
}",371,26,"package main

import (
	""bufio""
	""bytes""
	""io""
	""strings""
	""testing""
)

func TestInputLoop(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected []string
	}{
		{
			name:     ""Single line input"",
			input:    ""Hello, World!\n"",
			expected: []string{""Hello, World!\n""},
		},
		{
			name:     ""Multiple lines input"",
			input:    ""Hello, World!\nThis is a test.\n"",
			expected: []string{""Hello, World!\n"", ""This is a test.\n""},
		},
		{
			name:     ""Empty input"",
			input:    """",
			expected: []string{},
		},
		{
			name:     ""Input with multiple newlines"",
			input:    ""\n\n\n"",
			expected: []string{""\n"", ""\n"", ""\n""},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Redirect input to a custom reader
			in := bufio.NewReader(strings.NewReader(tt.input))
			var results []string

			for {
				s, err := in.ReadString('\n')
				if err != nil {
					if err != io.EOF {
						t.Fatalf(""unexpected error: %v"", err)
					}
					break
				}
				results = append(results, s)
			}

			if len(results) != len(tt.expected) {
				t.Fatalf(""expected %d lines, got %d"", len(tt.expected), len(results))
			}

			for i, line := range results {
				if line != tt.expected[i] {
					t.Errorf(""expected line %d to be %q, got %q"", i, tt.expected[i], line)
				}
			}
		})
	}
}
",./data/generated/docs_golang/input_loop/gpt_4o_2024_08_06_input_loop_test.go,CompileStatus.SYNTAX_ERROR,,,,0.09,0.75,,1.0,"[{'FromLinter': 'typecheck', 'Text': '""bytes"" imported and not used', 'Severity': '', 'SourceLines': ['\t""bytes""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_input_loop_test.go', 'Offset': 0, 'Line': 5, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_input_loop_test.go', 'line': 5, 'column': 2, 'message': '""bytes"" imported and not used'}]"
Integer sequence,"Task

Create a program that, when run, would display all integers from   1   to      ∞      (or any relevant implementation limit),   in sequence   (i.e.   1, 2, 3, 4, etc)   if given enough time.



An example may not be able to reach arbitrarily-large numbers based on implementations limits.   For example, if integers are represented as a 32-bit unsigned value with 0 as the smallest representable value, the largest representable value would be 4,294,967,295.   Some languages support arbitrarily-large numbers as a built-in feature, while others make use of a module or library.

If appropriate, provide an example which reflect the language implementation's common built-in limits as well as an example which supports arbitrarily large numbers, and describe the nature of such limitations—or lack thereof.



",Go,"package main
 
import ""fmt""
 
func main() {
    for i := 1;; i++ {
        fmt.Println(i)
    }
}",97,9,"package main

import (
	""testing""
	""time""
)

// TestIntegerSequence tests the integer sequence generation.
func TestIntegerSequence(t *testing.T) {
	// Create a channel to receive integers
	intChan := make(chan int)

	// Run the sequence generator in a separate goroutine
	go func() {
		for i := 1; ; i++ {
			intChan <- i
		}
	}()

	// Test that the first few integers are correct
	expected := []int{1, 2, 3, 4, 5}
	for _, exp := range expected {
		select {
		case val := <-intChan:
			if val != exp {
				t.Errorf(""Expected %d, but got %d"", exp, val)
			}
		case <-time.After(1 * time.Second):
			t.Error(""Test timed out waiting for integer sequence"")
		}
	}

	// Close the channel to stop the goroutine
	close(intChan)
}
",./data/generated/docs_golang/integer_sequence/gpt_4o_2024_08_06_integer_sequence_test.go,CompileStatus.OK,1.0,,,0.12,1.0,0.078,0.0,[],False,False,0.0,False,[]
Jacobi symbol,"The Jacobi symbol is a multiplicative function that generalizes the Legendre symbol. Specifically, the Jacobi symbol (a | n) equals the product of the Legendre symbols (a | p_i)^(k_i), where n = p_1^(k_1)*p_2^(k_2)*...*p_i^(k_i) and the Legendre symbol (a | p) denotes the value of a ^ ((p-1)/2) (mod p)

 (a | p) ≡   1     if a is a square (mod p)
 (a | p) ≡ -1     if a is not a square (mod p)
 (a | p) ≡   0     if a ≡ 0 
If n is prime, then the Jacobi symbol (a | n) equals the Legendre symbol (a | n).

Task

Calculate the Jacobi symbol (a | n).

Reference

 Wikipedia article on Jacobi symbol.",Go,"package main
 
import (
    ""fmt""
    ""log""
    ""math/big""
)
 
func jacobi(a, n uint64) int {
    if n%2 == 0 {
        log.Fatal(""'n' must be a positive odd integer"")
    }
    a %= n
    result := 1
    for a != 0 {
        for a%2 == 0 {
            a /= 2
            nn := n % 8
            if nn == 3 || nn == 5 {
                result = -result
            }
        }
        a, n = n, a
        if a%4 == 3 && n%4 == 3 {
            result = -result
        }
        a %= n
    }
    if n == 1 {
        return result
    }
    return 0
}
 
func main() {
    fmt.Println(""Using hand-coded version:"")
    fmt.Println(""n/a  0  1  2  3  4  5  6  7  8  9"")
    fmt.Println(""---------------------------------"")
    for n := uint64(1); n <= 17; n += 2 {
        fmt.Printf(""%2d "", n)
        for a := uint64(0); a <= 9; a++ {
            fmt.Printf("" % d"", jacobi(a, n))
        }
        fmt.Println()
    }
 
    ba, bn := new(big.Int), new(big.Int)
    fmt.Println(""\nUsing standard library function:"")
    fmt.Println(""n/a  0  1  2  3  4  5  6  7  8  9"")
    fmt.Println(""---------------------------------"")
    for n := uint64(1); n <= 17; n += 2 {
        fmt.Printf(""%2d "", n)
        for a := uint64(0); a <= 9; a++ {
            ba.SetUint64(a)
            bn.SetUint64(n)
            fmt.Printf("" % d"", big.Jacobi(ba, bn))            
        }
        fmt.Println()
    }
}",1389,60,"package main

import (
    ""testing""
)

// TestJacobiSymbol tests the jacobi function with various inputs
func TestJacobiSymbol(t *testing.T) {
    tests := []struct {
        a, n   uint64
        result int
    }{
        {0, 1, 0},
        {0, 3, 0},
        {1, 3, 1},
        {2, 3, -1},
        {3, 3, 0},
        {4, 3, 1},
        {5, 3, -1},
        {6, 3, 0},
        {7, 3, 1},
        {8, 3, -1},
        {9, 3, 0},
        {2, 5, -1},
        {3, 5, -1},
        {4, 5, 1},
        {5, 5, 0},
        {6, 5, -1},
        {7, 5, 1},
        {8, 5, 1},
        {9, 5, -1},
        {10, 5, 0},
        {2, 7, 1},
        {3, 7, -1},
        {4, 7, 1},
        {5, 7, -1},
        {6, 7, -1},
        {7, 7, 0},
        {8, 7, 1},
        {9, 7, -1},
        {10, 7, 1},
        {11, 7, -1},
        {12, 7, 1},
        {13, 7, -1},
        {14, 7, 0},
    }

    for _, test := range tests {
        t.Run("""", func(t *testing.T) {
            result := jacobi(test.a, test.n)
            if result != test.result {
                t.Errorf(""jacobi(%d, %d) = %d; want %d"", test.a, test.n, result, test.result)
            }
        })
    }
}

// TestJacobiSymbolInvalidN tests the jacobi function with invalid n
func TestJacobiSymbolInvalidN(t *testing.T) {
    defer func() {
        if r := recover(); r == nil {
            t.Errorf(""Expected panic for even n, but did not panic"")
        }
    }()
    jacobi(2, 4)
}
",./data/generated/docs_golang/jacobi_symbol/gpt_4o_2024_08_06_jacobi_symbol_test.go,CompileStatus.OK,0.0,,,0.04,0.14,0.085,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: jacobi', 'Severity': '', 'SourceLines': ['            result := jacobi(test.a, test.n)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_jacobi_symbol_test.go', 'Offset': 0, 'Line': 50, 'Column': 23}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: jacobi', 'Severity': '', 'SourceLines': ['    jacobi(2, 4)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_jacobi_symbol_test.go', 'Offset': 0, 'Line': 65, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,70.59,False,[]
Jaro similarity,"The Jaro distance is a measure of edit distance between two strings; its inverse, called the Jaro similarity, is a measure of two strings' similarity: the higher the value, the more similar the strings are. The score is normalized such that   0   equates to no similarities and   1   is an exact match.



Definition
The Jaro similarity   




d

j




{\displaystyle d_{j}}

   of two given strings   




s

1




{\displaystyle s_{1}}

   and   




s

2




{\displaystyle s_{2}}

   is

 




d

j


=

{




0



if 

m
=
0






1
3



(


m


|


s

1



|




+


m


|


s

2



|




+



m
−
t

m


)




otherwise









{\displaystyle d_{j}=\left\{{\begin{array}{l l}0&{\text{if }}m=0\\{\frac {1}{3}}\left({\frac {m}{|s_{1}|}}+{\frac {m}{|s_{2}|}}+{\frac {m-t}{m}}\right)&{\text{otherwise}}\end{array}}\right.}


Where:

 



m


{\displaystyle m}

   is the number of matching characters;
 



t


{\displaystyle t}

   is half the number of transpositions.


Two characters from   




s

1




{\displaystyle s_{1}}

   and   




s

2




{\displaystyle s_{2}}

   respectively, are considered matching only if they are the same and not farther apart than   




⌊



max
(

|


s

1



|

,

|


s

2



|

)

2


⌋

−
1


{\displaystyle \left\lfloor {\frac {\max(|s_{1}|,|s_{2}|)}{2}}\right\rfloor -1}

 characters.

Each character of   




s

1




{\displaystyle s_{1}}

   is compared with all its matching characters in   




s

2




{\displaystyle s_{2}}

. Each difference in position is half a transposition; that is, the number of transpositions is half the number of characters which are common to the two strings but occupy different positions in each one.



Example
Given the strings   




s

1




{\displaystyle s_{1}}

   DWAYNE   and   




s

2




{\displaystyle s_{2}}

   DUANE   we find:

 



m
=
4


{\displaystyle m=4}


 




|


s

1



|

=
6


{\displaystyle |s_{1}|=6}


 




|


s

2



|

=
5


{\displaystyle |s_{2}|=5}


 



t
=
0


{\displaystyle t=0}




We find a Jaro score of:

 




d

j


=


1
3



(


4
6


+


4
5


+



4
−
0

4


)

=
0.822


{\displaystyle d_{j}={\frac {1}{3}}\left({\frac {4}{6}}+{\frac {4}{5}}+{\frac {4-0}{4}}\right)=0.822}




Task
Implement the Jaro algorithm and show the similarity scores for each of the following pairs:

 (""MARTHA"", ""MARHTA"")
 (""DIXON"", ""DICKSONX"")
 (""JELLYFISH"", ""SMELLYFISH"")


 See also
 Jaro–Winkler distance on Wikipedia.

",Go,"package main
 
import ""fmt""
 
func jaro(str1, str2 string) float64 {
    if len(str1) == 0 && len(str2) == 0 {
        return 1
    }
    if len(str1) == 0 || len(str2) == 0 {
        return 0
    }
    match_distance := len(str1)
    if len(str2) > match_distance {
        match_distance = len(str2)
    }
    match_distance = match_distance/2 - 1
    str1_matches := make([]bool, len(str1))
    str2_matches := make([]bool, len(str2))
    matches := 0.
    transpositions := 0.
    for i := range str1 {
        start := i - match_distance
        if start < 0 {
            start = 0
        }
        end := i + match_distance + 1
        if end > len(str2) {
            end = len(str2)
        }
        for k := start; k < end; k++ {
            if str2_matches[k] {
                continue
            }
            if str1[i] != str2[k] {
                continue
            }
            str1_matches[i] = true
            str2_matches[k] = true
            matches++
            break
        }
    }
    if matches == 0 {
        return 0
    }
    k := 0
    for i := range str1 {
        if !str1_matches[i] {
            continue
        }
        for !str2_matches[k] {
            k++
        }
        if str1[i] != str2[k] {
            transpositions++
        }
        k++
    }
    transpositions /= 2
    return (matches/float64(len(str1)) +
        matches/float64(len(str2)) +
        (matches-transpositions)/matches) / 3
}
 
func main() {
    fmt.Printf(""%f\n"", jaro(""MARTHA"", ""MARHTA""))
    fmt.Printf(""%f\n"", jaro(""DIXON"", ""DICKSONX""))
    fmt.Printf(""%f\n"", jaro(""JELLYFISH"", ""SMELLYFISH""))
}",1626,69,"package main

import (
	""testing""
)

func TestJaro(t *testing.T) {
	tests := []struct {
		str1     string
		str2     string
		expected float64
	}{
		{""MARTHA"", ""MARHTA"", 0.944444},
		{""DIXON"", ""DICKSONX"", 0.766667},
		{""JELLYFISH"", ""SMELLYFISH"", 0.896296},
		{"""", """", 1.0}, // Both strings are empty
		{"""", ""NONEMPTY"", 0.0}, // One string is empty
		{""NONEMPTY"", """", 0.0}, // One string is empty
		{""SAME"", ""SAME"", 1.0}, // Both strings are identical
		{""ABC"", ""DEF"", 0.0}, // No matching characters
	}

	for _, test := range tests {
		result := jaro(test.str1, test.str2)
		if result != test.expected {
			t.Errorf(""jaro(%q, %q) = %f; expected %f"", test.str1, test.str2, result, test.expected)
		}
	}
}
",./data/generated/docs_golang/jaro_similarity/gpt_4o_2024_08_06_jaro_similarity_test.go,CompileStatus.OK,0.0,93.2,,0.05,0.06,0.115,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: jaro', 'Severity': '', 'SourceLines': ['\t\tresult := jaro(test.str1, test.str2)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_jaro_similarity_test.go', 'Offset': 0, 'Line': 24, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Julia set,"
Task
Generate and draw a Julia set.




Related tasks
   Mandelbrot Set

",Go,"package main
 
import (
	""image""
	""image/color""
	""image/png""
	""log""
	""os""
	""sync""
)
 
func main() {
	const (
		width, height = 800.0, 600.0
		maxIter       = 255
		cX, cY        = -0.7, 0.27015
		fileName      = ""julia.png""
	)
	img := image.NewNRGBA(image.Rect(0, 0, width, height))
 
	var wg sync.WaitGroup
	wg.Add(width)
	for x := 0; x < width; x++ {
		thisx := float64(x)
		go func() {
			var tmp, zx, zy float64
			var i uint8
			for y := 0.0; y < height; y++ {
				zx = 1.5 * (thisx - width/2) / (0.5 * width)
				zy = (y - height/2) / (0.5 * height)
				i = maxIter
				for zx*zx+zy*zy < 4.0 && i > 0 {
					tmp = zx*zx - zy*zy + cX
					zy = 2.0*zx*zy + cY
					zx = tmp
					i--
				}
				img.Set(int(thisx), int(y), color.RGBA{i, i, i << 3, 255})
			}
			wg.Done()
		}()
	}
	wg.Wait()
	imgFile, err := os.Create(fileName)
	if err != nil {
		log.Fatal(err)
	}
	defer imgFile.Close()
	if err := png.Encode(imgFile, img); err != nil {
		imgFile.Close()
		log.Fatal(err)
	}
}",980,53,"package main

import (
	""image""
	""image/color""
	""image/png""
	""os""
	""testing""
)

func TestJuliaSetImageCreation(t *testing.T) {
	const (
		width, height = 800, 600
		fileName      = ""julia.png""
	)

	// Run the main function to generate the image
	main()

	// Check if the file is created
	if _, err := os.Stat(fileName); os.IsNotExist(err) {
		t.Fatalf(""Expected file %s to be created, but it does not exist."", fileName)
	}

	// Open the generated image file
	imgFile, err := os.Open(fileName)
	if err != nil {
		t.Fatalf(""Failed to open generated image file: %v"", err)
	}
	defer imgFile.Close()

	// Decode the image
	img, err := png.Decode(imgFile)
	if err != nil {
		t.Fatalf(""Failed to decode generated image file: %v"", err)
	}

	// Check the image dimensions
	if img.Bounds().Dx() != width || img.Bounds().Dy() != height {
		t.Fatalf(""Expected image dimensions to be %dx%d, but got %dx%d"", width, height, img.Bounds().Dx(), img.Bounds().Dy())
	}

	// Check a few pixels to ensure they are set (not all black)
	var nonBlackPixels int
	for x := 0; x < width; x += 100 {
		for y := 0; y < height; y += 100 {
			r, g, b, _ := img.At(x, y).RGBA()
			if r != 0 || g != 0 || b != 0 {
				nonBlackPixels++
			}
		}
	}

	if nonBlackPixels == 0 {
		t.Fatalf(""Expected some non-black pixels in the image, but found none."")
	}
}

func TestJuliaSetColorRange(t *testing.T) {
	const (
		width, height = 800, 600
		fileName      = ""julia.png""
	)

	// Run the main function to generate the image
	main()

	// Open the generated image file
	imgFile, err := os.Open(fileName)
	if err != nil {
		t.Fatalf(""Failed to open generated image file: %v"", err)
	}
	defer imgFile.Close()

	// Decode the image
	img, err := png.Decode(imgFile)
	if err != nil {
		t.Fatalf(""Failed to decode generated image file: %v"", err)
	}

	// Check color range
	for x := 0; x < width; x += 100 {
		for y := 0; y < height; y += 100 {
			r, g, b, _ := img.At(x, y).RGBA()
			if r > 255 || g > 255 || b > 255 {
				t.Fatalf(""Pixel color values should be within 0-255 range, but got R: %d, G: %d, B: %d"", r, g, b)
			}
		}
	}
}
",./data/generated/docs_golang/julia_set/gpt_4o_2024_08_06_julia_set_test.go,CompileStatus.SYNTAX_ERROR,,,,0.19,1.0,,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\tmain()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_julia_set_test.go', 'Offset': 0, 'Line': 18, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\tmain()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_julia_set_test.go', 'Offset': 0, 'Line': 66, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""image"" imported and not used', 'Severity': '', 'SourceLines': ['\t""image""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_julia_set_test.go', 'Offset': 0, 'Line': 4, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""image/color"" imported and not used', 'Severity': '', 'SourceLines': ['\t""image/color""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_julia_set_test.go', 'Offset': 0, 'Line': 5, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_julia_set_test.go', 'line': 4, 'column': 2, 'message': '""image"" imported and not used'}]"
Knight's tour,"
Task
Problem: you have a standard 8x8 chessboard, empty but for a single knight on some square. Your task is to emit a series of legal knight moves that result in the knight visiting every square on the chessboard exactly once. Note that it is not a requirement that the tour be ""closed""; that is, the knight need not end within a single move of its start position.

Input and output may be textual or graphical, according to the conventions of the programming environment. If textual, squares should be indicated in algebraic notation. The output should indicate the order in which the knight visits the squares, starting with the initial position. The form of the output may be a diagram of the board with the squares numbered according to visitation sequence, or a textual list of algebraic coordinates in order, or even an actual animation of the knight moving around the chessboard.

Input: starting square

Output: move sequence



Related tasks
 A* search algorithm
 N-queens problem
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle

",Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
// input, 0-based start position
const startRow = 0
const startCol = 0
 
func main() {
    rand.Seed(time.Now().Unix())
    for !knightTour() {
    }
}
 
var moves = []struct{ dr, dc int }{
    {2, 1},
    {2, -1},
    {1, 2},
    {1, -2},
    {-1, 2},
    {-1, -2},
    {-2, 1},
    {-2, -1},
}
 
// Attempt knight tour starting at startRow, startCol using Warnsdorff's rule
// and random tie breaking.  If a tour is found, print it and return true.
// Otherwise no backtracking, just return false.
func knightTour() bool {
    // 8x8 board.  squares hold 1-based visit order.  0 means unvisited.
    board := make([][]int, 8)
    for i := range board {
        board[i] = make([]int, 8)
    }
    r := startRow
    c := startCol
    board[r][c] = 1 // first move
    for move := 2; move <= 64; move++ {
        minNext := 8
        var mr, mc, nm int
    candidateMoves:
        for _, cm := range moves {
            cr := r + cm.dr
            if cr < 0 || cr >= 8 { // off board
                continue
            }
            cc := c + cm.dc
            if cc < 0 || cc >= 8 { // off board
                continue
            }
            if board[cr][cc] > 0 { // already visited
                continue
            }
            // cr, cc candidate legal move.
            p := 0 // count possible next moves.
            for _, m2 := range moves {
                r2 := cr + m2.dr
                if r2 < 0 || r2 >= 8 {
                    continue
                }
                c2 := cc + m2.dc
                if c2 < 0 || c2 >= 8 {
                    continue
                }
                if board[r2][c2] > 0 {
                    continue
                }
                p++
                if p > minNext { // bail out as soon as it's eliminated
                    continue candidateMoves
                }
            }
            if p < minNext { // it's better.  keep it.
                minNext = p // new min possible next moves
                nm = 1      // number of candidates with this p
                mr = cr     // best candidate move
                mc = cc
                continue
            }
            // it ties for best so far.
            // keep it with probability 1/(number of tying moves)
            nm++                    // number of tying moves
            if rand.Intn(nm) == 0 { // one chance to keep it
                mr = cr
                mc = cc
            }
        }
        if nm == 0 { // no legal move
            return false
        }
        // make selected move
        r = mr
        c = mc
        board[r][c] = move
    }
    // tour complete.  print board.
    for _, r := range board {
        for _, m := range r {
            fmt.Printf(""%3d"", m)
        }
        fmt.Println()
    }
    return true
}",2862,108,"package main

import (
	""testing""
)

func TestKnightTour(t *testing.T) {
	// Test that the knightTour function completes a tour
	t.Run(""CompleteTour"", func(t *testing.T) {
		if !knightTour() {
			t.Error(""Expected knightTour to complete a tour, but it did not."")
		}
	})

	// Test that all squares are visited exactly once
	t.Run(""AllSquaresVisitedOnce"", func(t *testing.T) {
		board := make([][]int, 8)
		for i := range board {
			board[i] = make([]int, 8)
		}
		if !knightTour() {
			t.Fatal(""Expected knightTour to complete a tour, but it did not."")
		}
		visited := make(map[int]bool)
		for _, row := range board {
			for _, move := range row {
				if move == 0 {
					t.Error(""Expected all squares to be visited, but found an unvisited square."")
				}
				if visited[move] {
					t.Errorf(""Expected each square to be visited once, but found duplicate visit for move %d."", move)
				}
				visited[move] = true
			}
		}
	})

	// Test that all moves are legal knight moves
	t.Run(""LegalKnightMoves"", func(t *testing.T) {
		board := make([][]int, 8)
		for i := range board {
			board[i] = make([]int, 8)
		}
		if !knightTour() {
			t.Fatal(""Expected knightTour to complete a tour, but it did not."")
		}
		positions := make([]struct{ r, c int }, 64)
		for r, row := range board {
			for c, move := range row {
				positions[move-1] = struct{ r, c int }{r, c}
			}
		}
		for i := 0; i < 63; i++ {
			r1, c1 := positions[i].r, positions[i].c
			r2, c2 := positions[i+1].r, positions[i+1].c
			dr, dc := r2-r1, c2-c1
			if !((dr == 2 && dc == 1) || (dr == 2 && dc == -1) || (dr == 1 && dc == 2) || (dr == 1 && dc == -2) ||
				(dr == -1 && dc == 2) || (dr == -1 && dc == -2) || (dr == -2 && dc == 1) || (dr == -2 && dc == -1)) {
				t.Errorf(""Illegal knight move from (%d, %d) to (%d, %d)"", r1, c1, r2, c2)
			}
		}
	})
}
",./data/generated/docs_golang/knight_s_tour/gpt_4o_2024_08_06_knight_s_tour_test.go,CompileStatus.OK,2.0,,,0.16,0.26,0.081,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: knightTour', 'Severity': '', 'SourceLines': ['\t\tif !knightTour() {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_knight_s_tour_test.go', 'Offset': 0, 'Line': 10, 'Column': 7}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: knightTour', 'Severity': '', 'SourceLines': ['\t\tif !knightTour() {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_knight_s_tour_test.go', 'Offset': 0, 'Line': 21, 'Column': 7}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: knightTour', 'Severity': '', 'SourceLines': ['\t\tif !knightTour() {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_knight_s_tour_test.go', 'Offset': 0, 'Line': 44, 'Column': 7}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,25.0,False,[]
Knuth's algorithm S,"This is a method of randomly sampling n items from a set of M items, with equal probability; where M >= n and M, the number of items is unknown until the end.
This means that the equal probability sampling should be maintained for all successive items > n as they become available (although the content of successive samples can change).



The algorithm

 Select the first n items as the sample as they become available;
 For the i-th item where i > n, have a random chance of n/i of keeping it. If failing this chance, the sample remains the same. If not, have it randomly (1/n) replace one of the previously selected n items of the sample.
 Repeat   2nd step   for any subsequent items.


The Task

 Create a function s_of_n_creator that given 



n


{\displaystyle n}

 the maximum sample size, returns a function s_of_n that takes one parameter, item.
 Function s_of_n when called with successive items returns an equi-weighted random sample of up to n of its items so far, each time it is called, calculated using Knuths Algorithm S.
 Test your functions by printing and showing the frequency of occurrences of the selected digits from 100,000 repetitions of:
 Use the s_of_n_creator with n == 3 to generate an s_of_n.
 call s_of_n with each of the digits 0 to 9 in order, keeping the returned three digits of its random sampling from its last call with argument item=9.


Note: A class taking n and generating a callable instance/function might also be used.



Reference

 The Art of Computer Programming, Vol 2, 3.4.2 p.142


Related tasks
 
 One of n lines in a file 
 Accumulator factory

",Go,"package main
 
import (
    ""fmt""
    ""math/rand""
    ""time""
)
 
func sOfNCreator(n int) func(byte) []byte {
    s := make([]byte, 0, n)
    m := n
    return func(item byte) []byte {
        if len(s) < n {
            s = append(s, item)
        } else {
            m++
            if rand.Intn(m) < n {
                s[rand.Intn(n)] = item
            }
        }
        return s
    }
}
 
func main() {
    rand.Seed(time.Now().UnixNano())
    var freq [10]int
    for r := 0; r < 1e5; r++ {
        sOfN := sOfNCreator(3)
        for d := byte('0'); d < '9'; d++ {
            sOfN(d)
        }
        for _, d := range sOfN('9') {
            freq[d-'0']++
        }
    }
    fmt.Println(freq)
}",707,38,error,,,,,,,,,,,False,False,,False,
Knuth's power tree,"(Knuth's power tree is used for computing   xn   efficiently.)




Task

Compute and show the list of Knuth's power tree integers necessary for the computation of:

   xn   for any real   x   and any non-negative integer   n.


Then, using those integers, calculate and show the exact values of (at least) the integer powers below:

   2n     where   n   ranges from   0 ──► 17   (inclusive) 

   3191
   1.181


A  zero  power is often handled separately as a special case.

Optionally, support negative integer powers.



Example

An example of a small power tree for some low integers:

                                                                    1
                                                                     \
                                                                      2
                          ___________________________________________/ \
                         /                                              \
                        3                                                4
                       / \____________________________________            \
                      /                                       \            \
                     5                                         6            8
                    / \____________                           / \            \
                   /               \                         /   \            \
                  7                 10                      9     12           16
                 /                 //\\                     │      │           /\
                /            _____//  \\________            │      │          /  \
              14            /     /    \        \           │      │         /    \
             /│ \         11    13      15       20        18     24        17    32
            / │  \         │    /\      /\        │        /\      │        /\     │
           /  │   \        │   /  \    /  \       │       /  \     │       /  \    │
         19  21    28     22 23   26  25   30    40     27   36    48     33 34   64
         │   /\    /│\     │  │   /\   │   /\    /│\     │   /\    /│\     │  │   /\
         │  /  \  / │ \    │  │  /  \  │  /  \  / │ \    │  /  \  / │ \    │  │  /  \
        38 35 42 29 31 56 44 46 39 52 50 45 60 41 43 80 54 37 72 49 51 96 66 68 65 128

Where, for the power   43,   following the tree ""downwards"" from   1:

   (for   2)   compute square of   X,   store X2
   (for   3)   compute   X * X2,   store X3
   (for   5)   compute   X3 * X2,   store X5
   (for 10)   compute square of   X5,   store X10
   (for 20)   compute square of   X10,   store X20
   (for 40)   compute square of   X20,   store X40
   (for 43)   compute   X40 * X3   (result).
Note that for every even integer (in the power tree),   one just squares the previous value.

For an odd integer, multiply the previous value with an appropriate odd power of   X   (which was previously calculated).
  For the last multiplication in the above example, it would be   (43-40),   or   3. 


According to Dr. Knuth (see below),   computer tests have shown that this power tree gives optimum results for all of the   n
  listed above in the graph.

For   n   ≤ 100,000,   the power tree method:

   bests the factor method   88,803   times,
   ties   11,191   times,
   loses   6   times.


References

   Donald E. Knuth's book:   The Art of Computer Programming, Vol. 2, Second Edition, Seminumerical Algorithms, section 4.6.3: Evaluation of Powers.
   link   codegolf.stackexchange.com/questions/3177/knuths-power-tree     It shows a   Haskell,   Python,   and a   Ruby   computer program example   (but they are mostly   code golf).
   link   comeoncodeon.wordpress.com/tag/knuth/     (See the section on Knuth's Power Tree.)     It shows a   C++   computer program example.
   link to Rosetta Code   addition-chain exponentiation.

",Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
var (
    p   = map[int]int{1: 0}
    lvl = [][]int{[]int{1}}
)
 
func path(n int) []int {
    if n == 0 {
        return []int{}
    }
    for {
        if _, ok := p[n]; ok {
            break
        }
        var q []int
        for _, x := range lvl[0] {
            for _, y := range path(x) {
                z := x + y
                if _, ok := p[z]; ok {
                    break
                }
                p[z] = x
                q = append(q, z)
            }
        }
        lvl[0] = q
    }
    r := path(p[n])
    r = append(r, n)
    return r
}
 
func treePow(x float64, n int) *big.Float {
    r := map[int]*big.Float{0: big.NewFloat(1), 1: big.NewFloat(x)}
    p := 0
    for _, i := range path(n) {
        temp := new(big.Float).SetPrec(320)
        temp.Mul(r[i-p], r[p])
        r[i] = temp
        p = i
    }
    return r[n]
}
 
func showPow(x float64, n int, isIntegral bool) {
    fmt.Printf(""%d: %v\n"", n, path(n))
    f := ""%f""
    if isIntegral {
        f = ""%.0f""
    }
    fmt.Printf(f, x)
    fmt.Printf("" ^ %d = "", n)
    fmt.Printf(f+""\n\n"", treePow(x, n))
}
 
func main() {
    for n := 0; n <= 17; n++ {
        showPow(2, n, true)
    }
    showPow(1.1, 81, false)
    showPow(3, 191, true)
}",1295,68,"package main

import (
	""math/big""
	""testing""
)

func TestTreePow(t *testing.T) {
	tests := []struct {
		x        float64
		n        int
		expected string
	}{
		{2, 0, ""1""},
		{2, 1, ""2""},
		{2, 2, ""4""},
		{2, 3, ""8""},
		{2, 4, ""16""},
		{2, 5, ""32""},
		{2, 6, ""64""},
		{2, 7, ""128""},
		{2, 8, ""256""},
		{2, 9, ""512""},
		{2, 10, ""1024""},
		{2, 11, ""2048""},
		{2, 12, ""4096""},
		{2, 13, ""8192""},
		{2, 14, ""16384""},
		{2, 15, ""32768""},
		{2, 16, ""65536""},
		{2, 17, ""131072""},
		{3, 191, ""3138428376721""},
		{1.1, 81, ""25937424601.0705""},
	}

	for _, tt := range tests {
		t.Run("""", func(t *testing.T) {
			result := treePow(tt.x, tt.n)
			expected := new(big.Float)
			expected.SetString(tt.expected)
			if result.Cmp(expected) != 0 {
				t.Errorf(""treePow(%f, %d) = %v; want %v"", tt.x, tt.n, result, expected)
			}
		})
	}
}
",./data/generated/docs_golang/knuth_s_power_tree/gpt_4o_2024_08_06_knuth_s_power_tree_test.go,CompileStatus.OK,0.0,69.4,,0.03,0.08,0.153,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: treePow', 'Severity': '', 'SourceLines': ['\t\t\tresult := treePow(tt.x, tt.n)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_knuth_s_power_tree_test.go', 'Offset': 0, 'Line': 38, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,85.71,False,[]
Kronecker product,"Kronecker product

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Implement the   Kronecker product   of two matrices (arbitrary sized) resulting in a block matrix. 




Test cases

Show results for each of the following two samples:




Sample 1 (from Wikipedia):



          ┌   ┐     ┌   ┐     ┌           ┐
          │1 2│     │0 5│     │ 0  5  0 10│
          │3 4│  x  │6 7│  =  │ 6  7 12 14│
	  └   ┘     └   ┘     │ 0 15  0 20│
	                      │18 21 24 28│
                              └           ┘ 

Sample 2:

          ┌     ┐     ┌       ┐     ┌                       ┐       
          │0 1 0│     │1 1 1 1│     │0 0 0 0 1 1 1 1 0 0 0 0│
          │1 1 1│  x  │1 0 0 1│  =  │0 0 0 0 1 0 0 1 0 0 0 0│
          │0 1 0│     │1 1 1 1│     │0 0 0 0 1 1 1 1 0 0 0 0│
	  └     ┘     └       ┘     │1 1 1 1 1 1 1 1 1 1 1 1│
                                    │1 0 0 1 1 0 0 1 1 0 0 1│
                                    │1 1 1 1 1 1 1 1 1 1 1 1│
                                    │0 0 0 0 1 1 1 1 0 0 0 0│
                                    │0 0 0 0 1 0 0 1 0 0 0 0│
                                    │0 0 0 0 1 1 1 1 0 0 0 0│
                                    └                       ┘



See implementations and results below in JavaScript and PARI/GP languages.



Related task

  Kronecker product based fractals. 

",Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
type uintMatrix [][]uint
 
func (m uintMatrix) String() string {
    var max uint
    for _, r := range m {
        for _, e := range r {
            if e > max {
                max = e
            }
        }
    }
    w := len(fmt.Sprint(max))
    b := &strings.Builder{}
    for _, r := range m {
        fmt.Fprintf(b, ""|%*d"", w, r[0])
        for _, e := range r[1:] {
            fmt.Fprintf(b, "" %*d"", w, e)
        }
        fmt.Fprintln(b, ""|"")
    }
    return b.String()
}
 
func kronecker(m1, m2 uintMatrix) uintMatrix {
    p := make(uintMatrix, len(m1)*len(m2))
    for r1i, r1 := range m1 {
        for r2i, r2 := range m2 {
            rp := make([]uint, len(r1)*len(r2))
            for c1i, e1 := range r1 {
                for c2i, e2 := range r2 {
                    rp[c1i*len(r2)+c2i] = e1 * e2
                }
            }
            p[r1i*len(m2)+r2i] = rp
        }
    }
    return p
}
 
func sample(m1, m2 uintMatrix) {
    fmt.Println(""m1:"")
    fmt.Print(m1)
    fmt.Println(""m2:"")
    fmt.Print(m2)
    fmt.Println(""m1 ⊗ m2:"")
    fmt.Print(kronecker(m1, m2))
}
 
func main() {
    sample(uintMatrix{
        {1, 2},
        {3, 4},
    }, uintMatrix{
        {0, 5},
        {6, 7},
    })
    sample(uintMatrix{
        {0, 1, 0},
        {1, 1, 1},
        {0, 1, 0},
    }, uintMatrix{
        {1, 1, 1, 1},
        {1, 0, 0, 1},
        {1, 1, 1, 1},
    })
}",1452,73,"package main

import (
    ""reflect""
    ""testing""
)

func TestKronecker(t *testing.T) {
    tests := []struct {
        m1, m2, expected uintMatrix
    }{
        {
            m1: uintMatrix{
                {1, 2},
                {3, 4},
            },
            m2: uintMatrix{
                {0, 5},
                {6, 7},
            },
            expected: uintMatrix{
                {0, 5, 0, 10},
                {6, 7, 12, 14},
                {0, 15, 0, 20},
                {18, 21, 24, 28},
            },
        },
        {
            m1: uintMatrix{
                {0, 1, 0},
                {1, 1, 1},
                {0, 1, 0},
            },
            m2: uintMatrix{
                {1, 1, 1, 1},
                {1, 0, 0, 1},
                {1, 1, 1, 1},
            },
            expected: uintMatrix{
                {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0},
                {0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0},
                {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                {1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1},
                {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
                {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0},
                {0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0},
            },
        },
    }

    for _, test := range tests {
        result := kronecker(test.m1, test.m2)
        if !reflect.DeepEqual(result, test.expected) {
            t.Errorf(""kronecker(%v, %v) = %v; want %v"", test.m1, test.m2, result, test.expected)
        }
    }
}
",./data/generated/docs_golang/kronecker_product/gpt_4o_2024_08_06_kronecker_product_test.go,CompileStatus.OK,0.0,30.0,,0.03,0.08,0.125,7.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: uintMatrix', 'Severity': '', 'SourceLines': ['        m1, m2, expected uintMatrix'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_kronecker_product_test.go', 'Offset': 0, 'Line': 10, 'Column': 26}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: uintMatrix', 'Severity': '', 'SourceLines': ['            m1: uintMatrix{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_kronecker_product_test.go', 'Offset': 0, 'Line': 13, 'Column': 17}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'missing type in composite literal', 'Severity': '', 'SourceLines': ['                {1, 2},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_kronecker_product_test.go', 'Offset': 0, 'Line': 14, 'Column': 17}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'missing type in composite literal', 'Severity': '', 'SourceLines': ['                {3, 4},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_kronecker_product_test.go', 'Offset': 0, 'Line': 15, 'Column': 17}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: uintMatrix', 'Severity': '', 'SourceLines': ['            m2: uintMatrix{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_kronecker_product_test.go', 'Offset': 0, 'Line': 17, 'Column': 17}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'missing type in composite literal', 'Severity': '', 'SourceLines': ['                {0, 5},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_kronecker_product_test.go', 'Offset': 0, 'Line': 18, 'Column': 17}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: kronecker', 'Severity': '', 'SourceLines': ['        result := kronecker(test.m1, test.m2)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_kronecker_product_test.go', 'Offset': 0, 'Line': 54, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
LU decomposition,"Every square matrix 



A


{\displaystyle A}

 can be decomposed into a product of a lower triangular matrix 



L


{\displaystyle L}

 and a upper triangular matrix 



U


{\displaystyle U}

,
as described in LU decomposition.





A
=
L
U


{\displaystyle A=LU}


It is a modified form of Gaussian elimination.
While the Cholesky decomposition only works for symmetric,
positive definite matrices, the more general LU decomposition
works for any square matrix.

There are several algorithms for calculating L and U.
To derive Crout's algorithm for a 3x3 example,
we have to solve the following system:





A
=


(




a

11





a

12





a

13







a

21





a

22





a

23







a

31





a

32





a

33





)


=


(




l

11




0


0





l

21





l

22




0





l

31





l

32





l

33





)




(




u

11





u

12





u

13






0



u

22





u

23






0


0



u

33





)


=
L
U


{\displaystyle A={\begin{pmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\\\end{pmatrix}}={\begin{pmatrix}l_{11}&0&0\\l_{21}&l_{22}&0\\l_{31}&l_{32}&l_{33}\\\end{pmatrix}}{\begin{pmatrix}u_{11}&u_{12}&u_{13}\\0&u_{22}&u_{23}\\0&0&u_{33}\end{pmatrix}}=LU}


We now would have to solve 9 equations with 12 unknowns. To make the system uniquely solvable, usually the diagonal elements of 



L


{\displaystyle L}

 are set to 1






l

11


=
1


{\displaystyle l_{11}=1}







l

22


=
1


{\displaystyle l_{22}=1}







l

33


=
1


{\displaystyle l_{33}=1}


so we get a solvable system of 9 unknowns and 9 equations.





A
=


(




a

11





a

12





a

13







a

21





a

22





a

23







a

31





a

32





a

33





)


=


(



1


0


0





l

21




1


0





l

31





l

32




1



)




(




u

11





u

12





u

13






0



u

22





u

23






0


0



u

33





)


=


(




u

11





u

12





u

13







u

11



l

21





u

12



l

21


+

u

22





u

13



l

21


+

u

23







u

11



l

31





u

12



l

31


+

u

22



l

32





u

13



l

31


+

u

23



l

32


+

u

33





)


=
L
U


{\displaystyle A={\begin{pmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\\\end{pmatrix}}={\begin{pmatrix}1&0&0\\l_{21}&1&0\\l_{31}&l_{32}&1\\\end{pmatrix}}{\begin{pmatrix}u_{11}&u_{12}&u_{13}\\0&u_{22}&u_{23}\\0&0&u_{33}\end{pmatrix}}={\begin{pmatrix}u_{11}&u_{12}&u_{13}\\u_{11}l_{21}&u_{12}l_{21}+u_{22}&u_{13}l_{21}+u_{23}\\u_{11}l_{31}&u_{12}l_{31}+u_{22}l_{32}&u_{13}l_{31}+u_{23}l_{32}+u_{33}\end{pmatrix}}=LU}


Solving for the other 



l


{\displaystyle l}

 and 



u


{\displaystyle u}

, we get the following equations:






u

11


=

a

11




{\displaystyle u_{11}=a_{11}}







u

12


=

a

12




{\displaystyle u_{12}=a_{12}}







u

13


=

a

13




{\displaystyle u_{13}=a_{13}}







u

22


=

a

22


−

u

12



l

21




{\displaystyle u_{22}=a_{22}-u_{12}l_{21}}







u

23


=

a

23


−

u

13



l

21




{\displaystyle u_{23}=a_{23}-u_{13}l_{21}}







u

33


=

a

33


−
(

u

13



l

31


+

u

23



l

32


)


{\displaystyle u_{33}=a_{33}-(u_{13}l_{31}+u_{23}l_{32})}


and for 



l


{\displaystyle l}

:






l

21


=


1

u

11





a

21




{\displaystyle l_{21}={\frac {1}{u_{11}}}a_{21}}







l

31


=


1

u

11





a

31




{\displaystyle l_{31}={\frac {1}{u_{11}}}a_{31}}







l

32


=


1

u

22




(

a

32


−

u

12



l

31


)


{\displaystyle l_{32}={\frac {1}{u_{22}}}(a_{32}-u_{12}l_{31})}


We see that there is a calculation pattern, which can be expressed as the following formulas, first for 



U


{\displaystyle U}








u

i
j


=

a

i
j


−

∑

k
=
1


i
−
1



u

k
j



l

i
k




{\displaystyle u_{ij}=a_{ij}-\sum _{k=1}^{i-1}u_{kj}l_{ik}}


and then for 



L


{\displaystyle L}








l

i
j


=


1

u

j
j




(

a

i
j


−

∑

k
=
1


j
−
1



u

k
j



l

i
k


)


{\displaystyle l_{ij}={\frac {1}{u_{jj}}}(a_{ij}-\sum _{k=1}^{j-1}u_{kj}l_{ik})}


We see in the second formula that to get the 




l

i
j




{\displaystyle l_{ij}}

 below the diagonal, we have to divide by the diagonal element (pivot) 




u

j
j




{\displaystyle u_{jj}}

, so we get problems when 




u

j
j




{\displaystyle u_{jj}}

 is either 0 or very small, which leads to numerical instability.

The solution to this problem is pivoting 



A


{\displaystyle A}

, which means rearranging the rows of 



A


{\displaystyle A}

, prior to the 



L
U


{\displaystyle LU}

 decomposition, in a way that the largest element of each column gets onto the diagonal of 



A


{\displaystyle A}

. Rearranging the rows means to multiply 



A


{\displaystyle A}

 by a permutation matrix 



P


{\displaystyle P}

:





P
A
⇒

A
′



{\displaystyle PA\Rightarrow A'}


Example:







(



0


1




1


0



)




(



1


4




2


3



)


⇒


(



2


3




1


4



)




{\displaystyle {\begin{pmatrix}0&1\\1&0\end{pmatrix}}{\begin{pmatrix}1&4\\2&3\end{pmatrix}}\Rightarrow {\begin{pmatrix}2&3\\1&4\end{pmatrix}}}


The decomposition algorithm is then applied on the rearranged matrix so that





P
A
=
L
U


{\displaystyle PA=LU}




Task description

The task is to implement a routine which will take a square nxn matrix 



A


{\displaystyle A}

 and return a lower triangular matrix 



L


{\displaystyle L}

, a upper triangular matrix 



U


{\displaystyle U}

 and a permutation matrix 



P


{\displaystyle P}

,
so that the above equation is fulfilled.

You should then test it on the following two examples and include your output.



Example 1

A

1   3   5
2   4   7
1   1   0

L

1.00000   0.00000   0.00000
0.50000   1.00000   0.00000
0.50000  -1.00000   1.00000

U

2.00000   4.00000   7.00000
0.00000   1.00000   1.50000
0.00000   0.00000  -2.00000

P

0   1   0
1   0   0
0   0   1

Example 2

A

11    9   24    2
 1    5    2    6
 3   17   18    1
 2    5    7    1

L

1.00000   0.00000   0.00000   0.00000
0.27273   1.00000   0.00000   0.00000
0.09091   0.28750   1.00000   0.00000
0.18182   0.23125   0.00360   1.00000

U

11.00000    9.00000   24.00000    2.00000
 0.00000   14.54545   11.45455    0.45455
 0.00000    0.00000   -3.47500    5.68750
 0.00000    0.00000    0.00000    0.51079

P

1   0   0   0
0   0   1   0
0   1   0   0
0   0   0   1


",Go,"package main
 
import ""fmt""
 
type matrix [][]float64
 
func zero(n int) matrix {
    r := make([][]float64, n)
    a := make([]float64, n*n)
    for i := range r {
        r[i] = a[n*i : n*(i+1)]
    } 
    return r 
}
 
func eye(n int) matrix {
    r := zero(n)
    for i := range r {
        r[i][i] = 1
    }
    return r
}   
 
func (m matrix) print(label string) {
    if label > """" {
        fmt.Printf(""%s:\n"", label)
    }
    for _, r := range m {
        for _, e := range r {
            fmt.Printf("" %9.5f"", e)
        }
        fmt.Println()
    }
}
 
func (a matrix) pivotize() matrix { 
    p := eye(len(a))
    for j, r := range a {
        max := r[j] 
        row := j
        for i := j; i < len(a); i++ {
            if a[i][j] > max {
                max = a[i][j]
                row = i
            }
        }
        if j != row {
            // swap rows
            p[j], p[row] = p[row], p[j]
        }
    } 
    return p
}
 
func (m1 matrix) mul(m2 matrix) matrix {
    r := zero(len(m1))
    for i, r1 := range m1 {
        for j := range m2 {
            for k := range m1 {
                r[i][j] += r1[k] * m2[k][j]
            }
        }
    }
    return r
}
 
func (a matrix) lu() (l, u, p matrix) {
    l = zero(len(a))
    u = zero(len(a))
    p = a.pivotize()
    a = p.mul(a)
    for j := range a {
        l[j][j] = 1
        for i := 0; i <= j; i++ {
            sum := 0.
            for k := 0; k < i; k++ {
                sum += u[k][j] * l[i][k]
            }
            u[i][j] = a[i][j] - sum
        }
        for i := j; i < len(a); i++ {
            sum := 0.
            for k := 0; k < j; k++ {
                sum += u[k][j] * l[i][k]
            }
            l[i][j] = (a[i][j] - sum) / u[j][j]
        }
    }
    return
}
 
func main() {
    showLU(matrix{
        {1, 3, 5},
        {2, 4, 7},
        {1, 1, 0}})
    showLU(matrix{
        {11, 9, 24, 2},
        {1, 5, 2, 6},
        {3, 17, 18, 1},
        {2, 5, 7, 1}})
}
 
func showLU(a matrix) {
    a.print(""\na"")
    l, u, p := a.lu()
    l.print(""l"")
    u.print(""u"") 
    p.print(""p"") 
}",2113,110,"package main

import (
	""reflect""
	""testing""
)

func TestLUDecomposition(t *testing.T) {
	tests := []struct {
		name     string
		input    matrix
		expected struct {
			L matrix
			U matrix
			P matrix
		}
	}{
		{
			name: ""Example 1"",
			input: matrix{
				{1, 3, 5},
				{2, 4, 7},
				{1, 1, 0},
			},
			expected: struct {
				L matrix
				U matrix
				P matrix
			}{
				L: matrix{
					{1.00000, 0.00000, 0.00000},
					{0.50000, 1.00000, 0.00000},
					{0.50000, -1.00000, 1.00000},
				},
				U: matrix{
					{2.00000, 4.00000, 7.00000},
					{0.00000, 1.00000, 1.50000},
					{0.00000, 0.00000, -2.00000},
				},
				P: matrix{
					{0, 1, 0},
					{1, 0, 0},
					{0, 0, 1},
				},
			},
		},
		{
			name: ""Example 2"",
			input: matrix{
				{11, 9, 24, 2},
				{1, 5, 2, 6},
				{3, 17, 18, 1},
				{2, 5, 7, 1},
			},
			expected: struct {
				L matrix
				U matrix
				P matrix
			}{
				L: matrix{
					{1.00000, 0.00000, 0.00000, 0.00000},
					{0.27273, 1.00000, 0.00000, 0.00000},
					{0.09091, 0.28750, 1.00000, 0.00000},
					{0.18182, 0.23125, 0.00360, 1.00000},
				},
				U: matrix{
					{11.00000, 9.00000, 24.00000, 2.00000},
					{0.00000, 14.54545, 11.45455, 0.45455},
					{0.00000, 0.00000, -3.47500, 5.68750},
					{0.00000, 0.00000, 0.00000, 0.51079},
				},
				P: matrix{
					{1, 0, 0, 0},
					{0, 0, 1, 0},
					{0, 1, 0, 0},
					{0, 0, 0, 1},
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			L, U, P := tt.input.lu()
			if !reflect.DeepEqual(L, tt.expected.L) {
				t.Errorf(""L matrix = %v, expected %v"", L, tt.expected.L)
			}
			if !reflect.DeepEqual(U, tt.expected.U) {
				t.Errorf(""U matrix = %v, expected %v"", U, tt.expected.U)
			}
			if !reflect.DeepEqual(P, tt.expected.P) {
				t.Errorf(""P matrix = %v, expected %v"", P, tt.expected.P)
			}
		})
	}
}
",./data/generated/docs_golang/lu_decomposition/gpt_4o_2024_08_06_lu_decomposition_test.go,CompileStatus.OK,0.0,76.8,,0.05,0.12,0.123,6.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: matrix', 'Severity': '', 'SourceLines': ['\t\tinput    matrix'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_lu_decomposition_test.go', 'Offset': 0, 'Line': 11, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: matrix', 'Severity': '', 'SourceLines': ['\t\t\tL matrix'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_lu_decomposition_test.go', 'Offset': 0, 'Line': 13, 'Column': 6}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: matrix', 'Severity': '', 'SourceLines': ['\t\t\tU matrix'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_lu_decomposition_test.go', 'Offset': 0, 'Line': 14, 'Column': 6}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'missing type in composite literal', 'Severity': '', 'SourceLines': ['\t\t\t\t{1, 3, 5},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_lu_decomposition_test.go', 'Offset': 0, 'Line': 21, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'missing type in composite literal', 'Severity': '', 'SourceLines': ['\t\t\t\t{2, 4, 7},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_lu_decomposition_test.go', 'Offset': 0, 'Line': 22, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'missing type in composite literal', 'Severity': '', 'SourceLines': ['\t\t\t\t{1, 1, 0},'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_lu_decomposition_test.go', 'Offset': 0, 'Line': 23, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,33.33,False,[]
LZW compression,"The Lempel-Ziv-Welch (LZW) algorithm provides loss-less data compression.

You can read a complete description of it in the   Wikipedia article   on the subject.   It was patented, but it entered the public domain in 2004.



",Go,"package main
 
import (
	""fmt""
	""log""
	""strings""
)
 
// Compress a string to a list of output symbols.
func compress(uncompressed string) []int {
	// Build the dictionary.
	dictSize := 256
	// We actually want a map of []byte -> int but
	// slices are not acceptable map key types.
	dictionary := make(map[string]int, dictSize)
	for i := 0; i < dictSize; i++ {
		// Ugly mess to work around not having a []byte key type.
		// Using `string(i)` would do utf8 encoding for i>127.
		dictionary[string([]byte{byte(i)})] = i
	}
 
	var result []int
	var w []byte
	for i := 0; i < len(uncompressed); i++ {
		c := uncompressed[i]
		wc := append(w, c)
		if _, ok := dictionary[string(wc)]; ok {
			w = wc
		} else {
			result = append(result, dictionary[string(w)])
			// Add wc to the dictionary.
			dictionary[string(wc)] = dictSize
			dictSize++
			//w = []byte{c}, but re-using wc
			wc[0] = c
			w = wc[:1]
		}
	}
 
	if len(w) > 0 {
		// Output the code for w.
		result = append(result, dictionary[string(w)])
	}
	return result
}
 
type BadSymbolError int
 
func (e BadSymbolError) Error() string {
	return fmt.Sprint(""Bad compressed symbol "", int(e))
}
 
// Decompress a list of output symbols to a string.
func decompress(compressed []int) (string, error) {
	// Build the dictionary.
	dictSize := 256
	dictionary := make(map[int][]byte, dictSize)
	for i := 0; i < dictSize; i++ {
		dictionary[i] = []byte{byte(i)}
	}
 
	var result strings.Builder
	var w []byte
	for _, k := range compressed {
		var entry []byte
		if x, ok := dictionary[k]; ok {
			//entry = x, but ensuring any append will make a copy
			entry = x[:len(x):len(x)]
		} else if k == dictSize && len(w) > 0 {
			entry = append(w, w[0])
		} else {
			return result.String(), BadSymbolError(k)
		}
		result.Write(entry)
 
		if len(w) > 0 {
			// Add w+entry[0] to the dictionary.
			w = append(w, entry[0])
			dictionary[dictSize] = w
			dictSize++
		}
		w = entry
	}
	return result.String(), nil
}
 
func main() {
	compressed := compress(""TOBEORNOTTOBEORTOBEORNOT"")
	fmt.Println(compressed)
	decompressed, err := decompress(compressed)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(decompressed)
}",2163,95,"package main

import (
	""testing""
	""reflect""
)

// TestCompress tests the compress function with various inputs.
func TestCompress(t *testing.T) {
	tests := []struct {
		input    string
		expected []int
	}{
		{""TOBEORNOTTOBEORTOBEORNOT"", []int{84, 79, 66, 69, 79, 82, 78, 79, 84, 256, 258, 260, 265, 259, 261, 263}},
		{"""", []int{}}, // Test empty string
		{""A"", []int{65}}, // Test single character
		{""ABABABABA"", []int{65, 66, 256, 258, 260, 65}}, // Test repeating pattern
	}

	for _, test := range tests {
		result := compress(test.input)
		if !reflect.DeepEqual(result, test.expected) {
			t.Errorf(""compress(%q) = %v; want %v"", test.input, result, test.expected)
		}
	}
}

// TestDecompress tests the decompress function with various inputs.
func TestDecompress(t *testing.T) {
	tests := []struct {
		input    []int
		expected string
		hasError bool
	}{
		{[]int{84, 79, 66, 69, 79, 82, 78, 79, 84, 256, 258, 260, 265, 259, 261, 263}, ""TOBEORNOTTOBEORTOBEORNOT"", false},
		{[]int{}, """", false}, // Test empty input
		{[]int{65}, ""A"", false}, // Test single character
		{[]int{65, 66, 256, 258, 260, 65}, ""ABABABABA"", false}, // Test repeating pattern
		{[]int{999}, """", true}, // Test invalid symbol
	}

	for _, test := range tests {
		result, err := decompress(test.input)
		if (err != nil) != test.hasError {
			t.Errorf(""decompress(%v) error = %v; want error = %v"", test.input, err, test.hasError)
		}
		if result != test.expected {
			t.Errorf(""decompress(%v) = %q; want %q"", test.input, result, test.expected)
		}
	}
}

// TestRoundTrip tests that compressing and then decompressing returns the original string.
func TestRoundTrip(t *testing.T) {
	tests := []string{
		""TOBEORNOTTOBEORTOBEORNOT"",
		"""",
		""A"",
		""ABABABABA"",
		""The quick brown fox jumps over the lazy dog"",
	}

	for _, test := range tests {
		compressed := compress(test)
		decompressed, err := decompress(compressed)
		if err != nil {
			t.Errorf(""decompress error: %v"", err)
		}
		if decompressed != test {
			t.Errorf(""RoundTrip failed for %q: got %q"", test, decompressed)
		}
	}
}
",./data/generated/docs_golang/lzw_compression/gpt_4o_2024_08_06_lzw_compression_test.go,CompileStatus.OK,0.0,87.0,,0.13,0.33,0.117,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: compress', 'Severity': '', 'SourceLines': ['\t\tresult := compress(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_lzw_compression_test.go', 'Offset': 0, 'Line': 21, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: decompress', 'Severity': '', 'SourceLines': ['\t\tresult, err := decompress(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_lzw_compression_test.go', 'Offset': 0, 'Line': 43, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: compress', 'Severity': '', 'SourceLines': ['\t\tcompressed := compress(test)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_lzw_compression_test.go', 'Offset': 0, 'Line': 64, 'Column': 17}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: decompress', 'Severity': '', 'SourceLines': ['\t\tdecompressed, err := decompress(compressed)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_lzw_compression_test.go', 'Offset': 0, 'Line': 65, 'Column': 24}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,33.33,False,[]
Langton's ant,"Langton's ant is a cellular automaton that models an ant sitting on a plane of cells, all of which are white initially, the ant facing in one of four directions.

Each cell can either be black or white.

The ant moves according to the color of the cell it is currently sitting in, with the following rules:

   If the cell is black, it changes to white and the ant turns left;
   If the cell is white, it changes to black and the ant turns right;
   The ant then moves forward to the next cell, and repeat from step 1.

This rather simple ruleset leads to an initially chaotic movement pattern, and after about 10000 steps, a cycle appears where the ant moves steadily away from the starting location in a diagonal corridor about 10 cells wide.
Conceptually the ant can then walk infinitely far away.



Task

Start the ant near the center of a 100x100 field of cells, which is about big enough to contain the initial chaotic part of the movement.

Follow the movement rules for the ant, terminate when it moves out of the region, and show the cell colors it leaves behind.



The problem has received some analysis; for more details, please take a look at the Wikipedia article   (a link is below)..



See also

   Wikipedia:   Langton's ant.


Related task

   Rosetta Code:   Conway's Game of Life.

",Go,"package main
 
import (
    ""fmt""
    ""image""
    ""image/color""
    ""image/draw""
    ""image/png""
    ""os""
)
 
const (
    up = iota
    rt
    dn
    lt
)
 
func main() {
    bounds := image.Rect(0, 0, 100, 100)
    im := image.NewGray(bounds)
    gBlack := color.Gray{0}
    gWhite := color.Gray{255}
    draw.Draw(im, bounds, image.NewUniform(gWhite), image.ZP, draw.Src)
    pos := image.Point{50, 50}
    dir := up
    for pos.In(bounds) {
        switch im.At(pos.X, pos.Y).(color.Gray).Y {
        case gBlack.Y:
            im.SetGray(pos.X, pos.Y, gWhite)
            dir--
        case gWhite.Y:
            im.SetGray(pos.X, pos.Y, gBlack)
            dir++
        }
        if dir&1 == 1 {
            pos.X += 1 - dir&2
        } else {
            pos.Y -= 1 - dir&2
        }
    }
    f, err := os.Create(""ant.png"")
    if err != nil {
        fmt.Println(err)
        return
    }
    if err = png.Encode(f, im); err != nil {
        fmt.Println(err)
    }
    if err = f.Close(); err != nil {
        fmt.Println(err)
    }
}",1043,53,"package main

import (
    ""image""
    ""image/color""
    ""testing""
)

func TestLangtonsAnt(t *testing.T) {
    bounds := image.Rect(0, 0, 100, 100)
    im := image.NewGray(bounds)
    gBlack := color.Gray{0}
    gWhite := color.Gray{255}

    // Initialize the grid with all white cells
    for y := 0; y < 100; y++ {
        for x := 0; x < 100; x++ {
            if im.At(x, y) != gWhite {
                t.Errorf(""Expected cell (%d, %d) to be white"", x, y)
            }
        }
    }

    pos := image.Point{50, 50}
    dir := up

    // Simulate the ant's movement
    for pos.In(bounds) {
        currentColor := im.At(pos.X, pos.Y).(color.Gray).Y
        switch currentColor {
        case gBlack.Y:
            im.SetGray(pos.X, pos.Y, gWhite)
            dir--
        case gWhite.Y:
            im.SetGray(pos.X, pos.Y, gBlack)
            dir++
        }

        // Move the ant
        if dir&1 == 1 {
            pos.X += 1 - dir&2
        } else {
            pos.Y -= 1 - dir&2
        }
    }

    // Check if the ant has moved out of bounds
    if pos.In(bounds) {
        t.Errorf(""Expected ant to move out of bounds, but it is at (%d, %d)"", pos.X, pos.Y)
    }

    // Verify the final state of the grid
    // This is a simple check to ensure that some cells have changed color
    changed := false
    for y := 0; y < 100; y++ {
        for x := 0; x < 100; x++ {
            if im.At(x, y) != gWhite {
                changed = true
                break
            }
        }
        if changed {
            break
        }
    }

    if !changed {
        t.Error(""Expected some cells to have changed color, but none did"")
    }
}
",./data/generated/docs_golang/langton_s_ant/gpt_4o_2024_08_06_langton_s_ant_test.go,CompileStatus.OK,0.0,0.0,,0.08,0.38,0.758,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: up', 'Severity': '', 'SourceLines': ['    dir := up'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_langton_s_ant_test.go', 'Offset': 0, 'Line': 25, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Largest int from concatenated ints,"Task
 
Given a set of positive integers, write a function to order the integers in such a way that the concatenation of the numbers forms the largest possible integer and return this integer.

Use the following two sets of integers as tests   and   show your program output here.

   {1, 34, 3, 98, 9, 76, 45, 4}
   {54, 546, 548, 60}


Possible algorithms

 A solution could be found by trying all combinations and return the best. 
 Another way to solve this is to note that in the best arrangement, for any two adjacent original integers X and Y, the concatenation X followed by Y will be numerically greater than or equal to the concatenation Y followed by X.
 Yet another way to solve this is to pad the integers to the same size by repeating the digits then sort using these repeated integers as a sort key.


See also

   Algorithms: What is the most efficient way to arrange the given numbers to form the biggest number?
   Constructing the largest number possible by rearranging a list

",Go,"// Variation of method 3.  Repeat digits to at least the size of the longest,
// then sort as strings.
package main
 
import (
    ""fmt""
    ""math/big""
    ""sort""
    ""strconv""
    ""strings""
)
 
type c struct {
    i     int
    s, rs string
}
 
type cc []*c
 
func (c cc) Len() int           { return len(c) }
func (c cc) Less(i, j int) bool { return c[j].rs < c[i].rs }
func (c cc) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }
 
// Function required by task.  Takes a list of integers, returns big int.
func li(is ...int) *big.Int {
    ps := make(cc, len(is))
    ss := make([]c, len(is))
    ml := 0
    for j, i := range is {
        p := &ss[j]
        ps[j] = p
        p.i = i
        p.s = strconv.Itoa(i)
        if len(p.s) > ml {
            ml = len(p.s)
        }
    }
    for _, p := range ps {
        p.rs = strings.Repeat(p.s, (ml+len(p.s)-1)/len(p.s))
    }
    sort.Sort(ps)
    s := make([]string, len(ps))
    for i, p := range ps {
        s[i] = p.s
    }
    b, _ := new(big.Int).SetString(strings.Join(s, """"), 10)
    return b
}
 
func main() {
    fmt.Println(li(1, 34, 3, 98, 9, 76, 45, 4))
    fmt.Println(li(54, 546, 548, 60))
}",1162,53,"package main

import (
    ""math/big""
    ""testing""
)

func TestLargestIntFromConcatenatedInts(t *testing.T) {
    tests := []struct {
        input    []int
        expected string
    }{
        {
            input:    []int{1, 34, 3, 98, 9, 76, 45, 4},
            expected: ""998764543431"",
        },
        {
            input:    []int{54, 546, 548, 60},
            expected: ""6054854654"",
        },
    }

    for _, test := range tests {
        result := li(test.input...).String()
        if result != test.expected {
            t.Errorf(""For input %v, expected %s but got %s"", test.input, test.expected, result)
        }
    }
}

func TestLargestIntFromConcatenatedIntsEdgeCases(t *testing.T) {
    tests := []struct {
        input    []int
        expected string
    }{
        {
            input:    []int{0, 0, 0},
            expected: ""0"",
        },
        {
            input:    []int{10, 2},
            expected: ""210"",
        },
        {
            input:    []int{121, 12},
            expected: ""12121"",
        },
    }

    for _, test := range tests {
        result := li(test.input...).String()
        if result != test.expected {
            t.Errorf(""For input %v, expected %s but got %s"", test.input, test.expected, result)
        }
    }
}
",./data/generated/docs_golang/largest_int_from_concatenated_ints/gpt_4o_2024_08_06_largest_int_from_concatenated_ints_test.go,CompileStatus.SYNTAX_ERROR,,,,0.07,0.22,,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: li', 'Severity': '', 'SourceLines': ['        result := li(test.input...).String()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_largest_int_from_concatenated_ints_test.go', 'Offset': 0, 'Line': 24, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: li', 'Severity': '', 'SourceLines': ['        result := li(test.input...).String()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_largest_int_from_concatenated_ints_test.go', 'Offset': 0, 'Line': 51, 'Column': 19}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""math/big"" imported and not used', 'Severity': '', 'SourceLines': ['    ""math/big""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_largest_int_from_concatenated_ints_test.go', 'Offset': 0, 'Line': 4, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_largest_int_from_concatenated_ints_test.go', 'line': 4, 'column': 5, 'message': '""math/big"" imported and not used'}]"
Largest number divisible by its digits,"Task

Find the largest base 10 integer whose digits are all different,   and   is evenly divisible by each of its individual digits.



These numbers are also known as   Lynch-Bell numbers,   numbers   n   such that the
(base ten) digits are all different (and do not include zero)   and   n   is divisible by each of its individual digits.



Example

135   is evenly divisible by   1,   3,   and   5.



Note that the digit zero (0) can not be in the number as integer division by zero is undefined.

The digits must all be unique so a base ten number will have at most 9 digits.

Feel free to use analytics and clever algorithms to reduce the search space your example needs to visit, but it must do an actual search. (Don't just feed it the answer and verify it is correct.)



Stretch goal

Do the same thing for hexadecimal.



Related tasks

   gapful numbers.
   palindromic gapful numbers. 


Also see

   The OEIS sequence:   A115569: Lynch-Bell numbers. 

",Go,"package main
 
import (
    ""fmt""
    ""strconv""
    ""strings""
)
 
func divByAll(num int, digits []byte) bool {
    for _, digit := range digits {
        if num%int(digit-'0') != 0 {
            return false
        }
    }
    return true
}
 
func main() {
    magic := 9 * 8 * 7
    high := 9876432 / magic * magic
    for i := high; i >= magic; i -= magic {
        if i%10 == 0 {
            continue // can't end in '0'
        }
        s := strconv.Itoa(i)
        if strings.ContainsAny(s, ""05"") {
            continue // can't contain '0'or '5'
        }
        var set = make(map[byte]bool)
        var sd []byte // distinct digits
        for _, b := range []byte(s) {
            if !set[b] {
                set[b] = true
                sd = append(sd, b)
            }
        }
        if len(sd) != len(s) {
            continue // digits must be unique
        }
        if divByAll(i, sd) {
            fmt.Println(""Largest decimal number is"", i)
            return
        }
    }
}",1003,45,error,,,,,,,,,,,False,False,,False,
Last Friday of each month,"Task

Write a program or a script that returns the date of the last Fridays of each month of a given year.

The year may be given through any simple input method in your language (command line, std in, etc).



Example of an expected output:

./last_fridays 2012
2012-01-27
2012-02-24
2012-03-30
2012-04-27
2012-05-25
2012-06-29
2012-07-27
2012-08-31
2012-09-28
2012-10-26
2012-11-30
2012-12-28



Related tasks
 Five weekends
 Day of the week
 Find the last Sunday of each month

",Go,"package main
 
import (
	""fmt""
	""os""
	""strconv""
	""time""
)
 
func main() {
	y := time.Now().Year()
	if len(os.Args) == 2 {
		if i, err := strconv.Atoi(os.Args[1]); err == nil {
			y = i
		}
	}
	for m := time.January; m <= time.December; m++ {
		d := time.Date(y, m+1, 1, 0, 0, 0, 0, time.UTC).Add(-24 * time.Hour)
		d = d.Add(-time.Duration((d.Weekday()+7-time.Friday)%7) * 24 * time.Hour)
		fmt.Println(d.Format(""2006-01-02""))
	}
}",431,22,error,,,,,,,,,,,False,False,,False,
Last letter-first letter,"A certain children's game involves starting with a word in a particular category.   Each participant in turn says a word, but that word must begin with the final letter of the previous word.   Once a word has been given, it cannot be repeated.   If an opponent cannot give a word in the category, they fall out of the game.



For example, with   ""animals""   as the category,

Child 1: dog 
Child 2: goldfish
Child 1: hippopotamus
Child 2: snake
...



Task

Take the following selection of 70 English Pokemon names   (extracted from   Wikipedia's list of Pokemon)   and generate the/a sequence with the highest possible number of Pokemon names where the subsequent name starts with the final letter of the preceding name.

No Pokemon name is to be repeated.

audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon
cresselia croagunk darmanitan deino emboar emolga exeggcute gabite
girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan
kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine
nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2
porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking
sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko
tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask



Extra brownie points for dealing with the full list of   646   names.



",Go,"package main
 
import (
    ""fmt""
    ""strings""
)
 
var pokemon = `audino bagon baltoy...67 names omitted...`
 
func main() {
    // split text into slice representing directed graph
    var d []string
    for _, l := range strings.Split(pokemon, ""\n"") {
        d = append(d, strings.Fields(l)...)
    }
    fmt.Println(""searching"", len(d), ""names..."")
    // try each name as possible start
    for i := range d {
        d[0], d[i] = d[i], d[0]
        search(d, 1, len(d[0]))
        d[0], d[i] = d[i], d[0]
    }
    fmt.Println(""maximum path length:"", len(ex))
    fmt.Println(""paths of that length:"", nMax)
    fmt.Print(""example path of that length:"")
    for i, n := range ex {
        if i%6 == 0 {
            fmt.Print(""\n   "")
        }
        fmt.Print(n, "" "")
    }
    fmt.Println()
}
 
var ex []string
var nMax int
 
func search(d []string, i, ncPath int) {
    // tally statistics
    if i == len(ex) {
        nMax++
    } else if i > len(ex) {
        nMax = 1
        ex = append(ex[:0], d[:i]...)
    }
    // recursive search
    lastName := d[i-1]
    lastChar := lastName[len(lastName)-1]
    for j := i; j < len(d); j++ {
        if d[j][0] == lastChar {
            d[i], d[j] = d[j], d[i]
            search(d, i+1, ncPath+1+len(d[i]))
            d[i], d[j] = d[j], d[i]
        }
    }
}",1318,56,"package main

import (
    ""testing""
)

// TestSearchFunction tests the search function for various scenarios
func TestSearchFunction(t *testing.T) {
    testCases := []struct {
        description string
        input       []string
        expectedLen int
    }{
        {
            description: ""Test with a small subset of Pokemon names"",
            input:       []string{""audino"", ""onix"", ""xatu"", ""umbreon"", ""natu""},
            expectedLen: 5,
        },
        {
            description: ""Test with no possible sequence"",
            input:       []string{""pikachu"", ""charmander"", ""bulbasaur""},
            expectedLen: 1,
        },
        {
            description: ""Test with a single name"",
            input:       []string{""pikachu""},
            expectedLen: 1,
        },
        {
            description: ""Test with names that form a loop"",
            input:       []string{""ekans"", ""snorlax"", ""xatu"", ""umbreon"", ""natu""},
            expectedLen: 5,
        },
    }

    for _, tc := range testCases {
        t.Run(tc.description, func(t *testing.T) {
            ex = nil
            nMax = 0
            for i := range tc.input {
                tc.input[0], tc.input[i] = tc.input[i], tc.input[0]
                search(tc.input, 1, len(tc.input[0]))
                tc.input[0], tc.input[i] = tc.input[i], tc.input[0]
            }
            if len(ex) != tc.expectedLen {
                t.Errorf(""expected length %d, got %d"", tc.expectedLen, len(ex))
            }
        })
    }
}

// TestMainFunction tests the main function to ensure it runs without errors
func TestMainFunction(t *testing.T) {
    defer func() {
        if r := recover(); r != nil {
            t.Errorf(""main function panicked: %v"", r)
        }
    }()
    main()
}
",./data/generated/docs_golang/last_letter_first_letter/gpt_4o_2024_08_06_last_letter_first_letter_test.go,CompileStatus.OK,0.0,100.0,,0.06,0.2,0.147,6.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: ex', 'Severity': '', 'SourceLines': ['            ex = nil'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_last_letter_first_letter_test.go', 'Offset': 0, 'Line': 38, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: nMax', 'Severity': '', 'SourceLines': ['            nMax = 0'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_last_letter_first_letter_test.go', 'Offset': 0, 'Line': 39, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: search', 'Severity': '', 'SourceLines': ['                search(tc.input, 1, len(tc.input[0]))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_last_letter_first_letter_test.go', 'Offset': 0, 'Line': 42, 'Column': 17}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: ex', 'Severity': '', 'SourceLines': ['            if len(ex) != tc.expectedLen {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_last_letter_first_letter_test.go', 'Offset': 0, 'Line': 45, 'Column': 20}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: ex', 'Severity': '', 'SourceLines': ['                t.Errorf(""expected length %d, got %d"", tc.expectedLen, len(ex))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_last_letter_first_letter_test.go', 'Offset': 0, 'Line': 46, 'Column': 76}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['    main()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_last_letter_first_letter_test.go', 'Offset': 0, 'Line': 59, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Left factorials,"Left factorials,   !n,   may refer to either   subfactorials   or to   factorial sums;

the same notation can be confusingly seen being used for the two different definitions.

Sometimes,   subfactorials   (also known as derangements)   may use any of the notations:

     !n`   
     !n  
     n¡  


(It may not be visually obvious, but the last example uses an upside-down exclamation mark.)



This Rosetta Code task will be using this formula   (factorial sums)   for   left factorial:


   



!
n
=

∑

k
=
0


n
−
1


k
!


{\displaystyle !n=\sum _{k=0}^{n-1}k!}




 where


   



!
0
=
0


{\displaystyle !0=0}






Task
Display the left factorials for:

   zero through ten     (inclusive)
   20   through   110   (inclusive)   by tens


Display the length (in decimal digits) of the left factorials for:

   1,000   through   10,000   (inclusive), by thousands.


Also see

   The OEIS entry: A003422 left factorials
   The MathWorld entry: left factorial
   The MathWorld entry: factorial sums
   The MathWorld entry: subfactorial


Related task

   permutations/derangements (subfactorials)

",Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
func main() {
    fmt.Print(""!0 through !10: 0"")
    one := big.NewInt(1)
    n := big.NewInt(1)
    f := big.NewInt(1)
    l := big.NewInt(1)
    next := func() { f.Mul(f, n); l.Add(l, f); n.Add(n, one) }
    for ; ; next() {
        fmt.Print("" "", l)
        if n.Int64() == 10 {
            break
        }
    }
    fmt.Println()
    for {
        for i := 0; i < 10; i++ {
            next()
        }
        fmt.Printf(""!%d: %d\n"", n, l)
        if n.Int64() == 110 {
            break
        }
    }
    fmt.Println(""Lengths of !1000 through !10000 by thousands:"")
    for i := 110; i < 1000; i++ {
        next()
    }
    for {
        fmt.Print("" "", len(l.String()))
        if n.Int64() == 10000 {
            break
        }
        for i := 0; i < 1000; i++ {
            next()
        }
    }
    fmt.Println()
}",882,45,error,,,,,,,,,,,False,False,,False,
Letter frequency,"Task

Open a text file and count the occurrences of each letter.

Some of these programs count all characters (including punctuation),
but some only count letters A to Z.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Go,"package main
 
import (
    ""fmt""
    ""io/ioutil""
    ""sort""
    ""unicode""
)
 
const file = ""unixdict.txt""
 
func main() {
    bs, err := ioutil.ReadFile(file)
    if err != nil {
        fmt.Println(err)
        return
    }
    m := make(map[rune]int)
    for _, r := range string(bs) {
        m[r]++
    }
    // answer is now in m.  sort and format output:
    lfs := make(lfList, 0, len(m))
    for l, f := range m {
        lfs = append(lfs, &letterFreq{l, f})
    }
    sort.Sort(lfs)
    fmt.Println(""file:"", file)
    fmt.Println(""letter  frequency"")
    for _, lf := range lfs {
        if unicode.IsGraphic(lf.rune) {
            fmt.Printf(""   %c    %7d\n"", lf.rune, lf.freq)
        } else {
            fmt.Printf(""%U  %7d\n"", lf.rune, lf.freq)
        }
    }
}
 
type letterFreq struct {
    rune
    freq int
}
type lfList []*letterFreq
 
func (lfs lfList) Len() int { return len(lfs) }
func (lfs lfList) Less(i, j int) bool {
    switch fd := lfs[i].freq - lfs[j].freq; {
    case fd < 0:
        return false
    case fd > 0:
        return true
    }
    return lfs[i].rune < lfs[j].rune
}
func (lfs lfList) Swap(i, j int) {
    lfs[i], lfs[j] = lfs[j], lfs[i]
}",1183,57,"package main

import (
    ""io/ioutil""
    ""os""
    ""testing""
    ""unicode""
)

func TestLetterFrequency(t *testing.T) {
    // Create a temporary file for testing
    tmpfile, err := ioutil.TempFile("""", ""testfile"")
    if err != nil {
        t.Fatal(err)
    }
    defer os.Remove(tmpfile.Name()) // Clean up

    // Write test data to the temporary file
    content := ""Hello, World! 123\nHello again!""
    if _, err := tmpfile.Write([]byte(content)); err != nil {
        t.Fatal(err)
    }
    if err := tmpfile.Close(); err != nil {
        t.Fatal(err)
    }

    // Override the file constant with the temporary file name
    file = tmpfile.Name()

    // Run the main function to test
    main()

    // Expected results
    expected := map[rune]int{
        'H': 2, 'e': 2, 'l': 5, 'o': 2, 'W': 1, 'r': 1, 'd': 1, 'a': 2, 'g': 1, 'i': 1, 'n': 1,
    }

    // Read the file again to check the results
    bs, err := ioutil.ReadFile(file)
    if err != nil {
        t.Fatal(err)
    }

    m := make(map[rune]int)
    for _, r := range string(bs) {
        if unicode.IsLetter(r) {
            m[r]++
        }
    }

    // Compare the expected and actual results
    for k, v := range expected {
        if m[k] != v {
            t.Errorf(""expected %d occurrences of %c, got %d"", v, k, m[k])
        }
    }
}
",./data/generated/docs_golang/letter_frequency/gpt_4o_2024_08_06_letter_frequency_test.go,CompileStatus.SYNTAX_ERROR,,,,0.19,0.45,,3.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: file', 'Severity': '', 'SourceLines': ['    file = tmpfile.Name()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_letter_frequency_test.go', 'Offset': 0, 'Line': 28, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['    main()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_letter_frequency_test.go', 'Offset': 0, 'Line': 31, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: file', 'Severity': '', 'SourceLines': ['    bs, err := ioutil.ReadFile(file)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_letter_frequency_test.go', 'Offset': 0, 'Line': 39, 'Column': 32}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_letter_frequency_test.go', 'line': 28, 'column': 5, 'message': 'cannot assign to file (neither addressable nor a map index expression)'}]"
Levenshtein distance,"

 This page uses content from Wikipedia. The original article was at Levenshtein distance. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In information theory and computer science, the Levenshtein distance is a metric for measuring the amount of difference between two sequences (i.e. an edit distance). The Levenshtein distance between two strings is defined as the minimum number of edits needed to transform one string into the other, with the allowable edit operations being insertion, deletion, or substitution of a single character.



Example

The Levenshtein distance between ""kitten"" and ""sitting"" is 3, since the following three edits change one into the other, and there isn't a way to do it with fewer than three edits:

   kitten   sitten   (substitution of 'k' with 's')
   sitten   sittin   (substitution of 'e' with 'i')
   sittin   sitting   (insert 'g' at the end).

The Levenshtein distance between   ""rosettacode"",   ""raisethysword""   is   8.

The distance between two strings is same as that when both strings are reversed.



Task

Implements a Levenshtein distance function, or uses a library function, to show the Levenshtein distance between   ""kitten""   and   ""sitting"".



Related task

   Longest common subsequence



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Go,"package main
 
import ""fmt""
 
func main() {
    fmt.Println(ld(""kitten"", ""sitting""))
}
 
func ld(s, t string) int {
    d := make([][]int, len(s)+1)
    for i := range d {
        d[i] = make([]int, len(t)+1)
    }
    for i := range d {
        d[i][0] = i
    }
    for j := range d[0] {
        d[0][j] = j
    }
    for j := 1; j <= len(t); j++ {
        for i := 1; i <= len(s); i++ {
            if s[i-1] == t[j-1] {
                d[i][j] = d[i-1][j-1]
            } else {
                min := d[i-1][j]
                if d[i][j-1] < min {
                    min = d[i][j-1]
                }
                if d[i-1][j-1] < min {
                    min = d[i-1][j-1]
                }
                d[i][j] = min + 1
            }
        }
 
    }
    return d[len(s)][len(t)]
}",798,38,"package main

import (
	""testing""
)

func TestLevenshteinDistance(t *testing.T) {
	tests := []struct {
		s, t     string
		expected int
	}{
		{""kitten"", ""sitting"", 3},
		{""rosettacode"", ""raisethysword"", 8},
		{"""", """", 0},
		{""a"", """", 1},
		{"""", ""a"", 1},
		{""abc"", ""abc"", 0},
		{""abc"", ""def"", 3},
		{""flaw"", ""lawn"", 2},
		{""intention"", ""execution"", 5},
	}

	for _, test := range tests {
		result := ld(test.s, test.t)
		if result != test.expected {
			t.Errorf(""ld(%q, %q) = %d; expected %d"", test.s, test.t, result, test.expected)
		}
	}
}
",./data/generated/docs_golang/levenshtein_distance/gpt_4o_2024_08_06_levenshtein_distance_test.go,CompileStatus.OK,0.0,94.7,,0.05,0.1,0.124,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: ld', 'Severity': '', 'SourceLines': ['\t\tresult := ld(test.s, test.t)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_levenshtein_distance_test.go', 'Offset': 0, 'Line': 24, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
Levenshtein distance/Alignment,"The Levenshtein distance algorithm returns the number of atomic operations (insertion, deletion or edition) that must be performed on a string in order to obtain an other one, but it does not say anything about the actual operations used or their order.

An alignment is a notation used to describe the operations used to turn a string into an other. At some point in the strings, the minus character ('-') is placed in order to signify that a character must be added at this very place. For instance, an alignment between the words 'place' and 'palace' is:

P-LACE
PALACE



Task

Write a function that shows the alignment of two strings for the corresponding levenshtein distance.

As an example, use the words ""rosettacode"" and ""raisethysword"".

You can either implement an algorithm, or use a dedicated library (thus showing us how it is named in your language).



",Go,"package main
 
import (
    ""fmt""
 
    ""github.com/biogo/biogo/align""
    ab ""github.com/biogo/biogo/alphabet""
    ""github.com/biogo/biogo/feat""
    ""github.com/biogo/biogo/seq/linear""
)
 
func main() {
    // Alphabets for things like DNA are predefined in biogo, but we
    // define our own here.
    lc := ab.Must(ab.NewAlphabet(""-abcdefghijklmnopqrstuvwxyz"",
        feat.Undefined, '-', 0, true))
    // Construct scoring matrix for Needleman-Wunch algorithm.
    // We leave zeros on the diagonal for the Levenshtein distance of an
    // exact match and put -1s everywhere else for the Levenshtein distance
    // of an edit.
    nw := make(align.NW, lc.Len())
    for i := range nw {
        r := make([]int, lc.Len())
        nw[i] = r
        for j := range r {
            if j != i {
                r[j] = -1
            }
        }
    }
    // define input sequences
    a := &linear.Seq{Seq: ab.BytesToLetters([]byte(""rosettacode""))}
    a.Alpha = lc
    b := &linear.Seq{Seq: ab.BytesToLetters([]byte(""raisethysword""))}
    b.Alpha = lc
    // perform alignment
    aln, err := nw.Align(a, b)
    // format and display result
    if err != nil {
        fmt.Println(err)
        return
    }
    fa := align.Format(a, b, aln, '-')
    fmt.Printf(""%s\n%s\n"", fa[0], fa[1])
    aa := fmt.Sprint(fa[0])
    ba := fmt.Sprint(fa[1])
    ma := make([]byte, len(aa))
    for i := range ma {
        if aa[i] == ba[i] {
            ma[i] = ' '
        } else {
            ma[i] = '|'
        }
    }
    fmt.Println(string(ma))
}",1541,56,"package main

import (
    ""testing""
    ""github.com/biogo/biogo/align""
    ab ""github.com/biogo/biogo/alphabet""
    ""github.com/biogo/biogo/feat""
    ""github.com/biogo/biogo/seq/linear""
)

func TestLevenshteinDistanceAlignment(t *testing.T) {
    lc := ab.Must(ab.NewAlphabet(""-abcdefghijklmnopqrstuvwxyz"",
        feat.Undefined, '-', 0, true))
    nw := make(align.NW, lc.Len())
    for i := range nw {
        r := make([]int, lc.Len())
        nw[i] = r
        for j := range r {
            if j != i {
                r[j] = -1
            }
        }
    }

    testCases := []struct {
        a        string
        b        string
        expected [2]string
    }{
        {
            a: ""rosettacode"",
            b: ""raisethysword"",
            expected: [2]string{
                ""R-OSETTAC-ODE"",
                ""RAISETHYSWORD"",
            },
        },
        {
            a: ""kitten"",
            b: ""sitting"",
            expected: [2]string{
                ""KITTEN-"",
                ""SITTING"",
            },
        },
        {
            a: ""flaw"",
            b: ""lawn"",
            expected: [2]string{
                ""FLAW-"",
                ""-LAWN"",
            },
        },
    }

    for _, tc := range testCases {
        a := &linear.Seq{Seq: ab.BytesToLetters([]byte(tc.a))}
        a.Alpha = lc
        b := &linear.Seq{Seq: ab.BytesToLetters([]byte(tc.b))}
        b.Alpha = lc

        aln, err := nw.Align(a, b)
        if err != nil {
            t.Fatalf(""unexpected error: %v"", err)
        }

        fa := align.Format(a, b, aln, '-')
        if fa[0] != tc.expected[0] || fa[1] != tc.expected[1] {
            t.Errorf(""unexpected alignment for %s and %s: got %s and %s, expected %s and %s"",
                tc.a, tc.b, fa[0], fa[1], tc.expected[0], tc.expected[1])
        }
    }
}
",./data/generated/docs_golang/levenshtein_distance_alignment/gpt_4o_2024_08_06_levenshtein_distance_alignment_test.go,CompileStatus.SYNTAX_ERROR,,,,0.05,0.29,,1.0,"[{'FromLinter': 'typecheck', 'Text': 'invalid operation: fa[0] != tc.expected[0] (mismatched types alphabet.Slice and string)', 'Severity': '', 'SourceLines': ['        if fa[0] != tc.expected[0] || fa[1] != tc.expected[1] {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_levenshtein_distance_alignment_test.go', 'Offset': 0, 'Line': 68, 'Column': 21}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_levenshtein_distance_alignment_test.go', 'line': 68, 'column': 21, 'message': 'invalid operation: fa[0] != tc.expected[0] (mismatched types alphabet.Slice and string)'}]"
Linear congruential generator,"The linear congruential generator is a very simple example of a random number generator.

All linear congruential generators use this formula:

 




r

n
+
1


=
a
×

r

n


+
c


(
mod

m
)



{\displaystyle r_{n+1}=a\times r_{n}+c{\pmod {m}}}




Where:

 




r

0




{\displaystyle r_{0}}

 is a seed.
 




r

1




{\displaystyle r_{1}}

, 




r

2




{\displaystyle r_{2}}

, 




r

3




{\displaystyle r_{3}}

, ..., are the random numbers.
 



a


{\displaystyle a}

, 



c


{\displaystyle c}

, 



m


{\displaystyle m}

 are constants.


If one chooses the values of 



a


{\displaystyle a}

, 



c


{\displaystyle c}

 and 



m


{\displaystyle m}

 with care, then the generator produces a uniform distribution of integers from 



0


{\displaystyle 0}

 to 



m
−
1


{\displaystyle m-1}

.

LCG numbers have poor quality. 




r

n




{\displaystyle r_{n}}

 and 




r

n
+
1




{\displaystyle r_{n+1}}

 are not independent, as true random numbers would be. Anyone who knows 




r

n




{\displaystyle r_{n}}

 can predict 




r

n
+
1




{\displaystyle r_{n+1}}

, therefore LCG is not cryptographically secure. The LCG is still good enough for simple tasks like Miller-Rabin primality test, or FreeCell deals. Among the benefits of the LCG, one can easily reproduce a sequence of numbers, from the same 




r

0




{\displaystyle r_{0}}

. One can also reproduce such sequence with a different programming language, because the formula is so simple.

The task is to replicate two historic random number generators. One is the rand() function from BSD libc, and the other is the rand() function from the Microsoft C Runtime (MSCVRT.DLL). Each replica must yield the same sequence of integers as the original generator, when starting from the same seed.

In these formulas, the seed becomes 



s
t
a
t

e

0




{\displaystyle state_{0}}

. The random sequence is 



r
a
n

d

1




{\displaystyle rand_{1}}

, 



r
a
n

d

2




{\displaystyle rand_{2}}

 and so on.



BSD formula

 



s
t
a
t

e

n
+
1


=
1103515245
×
s
t
a
t

e

n


+
12345


(
mod


2

31


)



{\displaystyle state_{n+1}=1103515245\times state_{n}+12345{\pmod {2^{31}}}}


 



r
a
n

d

n


=
s
t
a
t

e

n




{\displaystyle rand_{n}=state_{n}}


 



r
a
n

d

n




{\displaystyle rand_{n}}

 is in range 0 to 2147483647.


Microsoft formula

 



s
t
a
t

e

n
+
1


=
214013
×
s
t
a
t

e

n


+
2531011


(
mod


2

31


)



{\displaystyle state_{n+1}=214013\times state_{n}+2531011{\pmod {2^{31}}}}


 



r
a
n

d

n


=
s
t
a
t

e

n


÷

2

16




{\displaystyle rand_{n}=state_{n}\div 2^{16}}


 



r
a
n

d

n




{\displaystyle rand_{n}}

 is in range 0 to 32767.


The BSD formula was so awful that FreeBSD switched to a different formula.

More info is at Random number generator (included)#C.



",Go,"package main
 
import ""fmt""
 
// basic linear congruential generator
func lcg(a, c, m, seed uint32) func() uint32 {
    r := seed
    return func() uint32 {
        r = (a*r + c) % m
        return r
    }
}
 
// microsoft generator has extra division step
func msg(seed uint32) func() uint32 {
    g := lcg(214013, 2531011, 1<<31, seed)
    return func() uint32 {
        return g() / (1 << 16)
    }
}
 
func example(seed uint32) {
    fmt.Printf(""\nWith seed = %d\n"", seed)
    bsd := lcg(1103515245, 12345, 1<<31, seed)
    msf := msg(seed)
    fmt.Println(""       BSD  Microsoft"")
    for i := 0; i < 5; i++ {
        fmt.Printf(""%10d    %5d\n"", bsd(), msf())
    }
}
 
func main() {
    example(0)
    example(1)
}",720,35,"package main

import (
	""testing""
)

// Test the BSD linear congruential generator
func TestBSDLCG(t *testing.T) {
	tests := []struct {
		seed     uint32
		expected []uint32
	}{
		{0, []uint32{12345, 1406932606, 654583775, 1449466924, 229283573}},
		{1, []uint32{1103527590, 377401575, 662824084, 1147902781, 1012239690}},
	}

	for _, test := range tests {
		bsd := lcg(1103515245, 12345, 1<<31, test.seed)
		for i, exp := range test.expected {
			if result := bsd(); result != exp {
				t.Errorf(""BSD LCG with seed %d, iteration %d: expected %d, got %d"", test.seed, i, exp, result)
			}
		}
	}
}

// Test the Microsoft linear congruential generator
func TestMSGLCG(t *testing.T) {
	tests := []struct {
		seed     uint32
		expected []uint32
	}{
		{0, []uint32{38, 497, 11606, 12803, 19850}},
		{1, []uint32{4, 21016, 29211, 24171, 7336}},
	}

	for _, test := range tests {
		msf := msg(test.seed)
		for i, exp := range test.expected {
			if result := msf(); result != exp {
				t.Errorf(""Microsoft LCG with seed %d, iteration %d: expected %d, got %d"", test.seed, i, exp, result)
			}
		}
	}
}
",./data/generated/docs_golang/linear_congruential_generator/gpt_4o_2024_08_06_linear_congruential_generator_test.go,CompileStatus.OK,0.0,46.7,,0.08,0.29,0.117,2.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: lcg', 'Severity': '', 'SourceLines': ['\t\tbsd := lcg(1103515245, 12345, 1<<31, test.seed)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_linear_congruential_generator_test.go', 'Offset': 0, 'Line': 18, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: msg', 'Severity': '', 'SourceLines': ['\t\tmsf := msg(test.seed)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_linear_congruential_generator_test.go', 'Offset': 0, 'Line': 38, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
List rooted trees,"You came back from grocery shopping.   After putting away all the goods, you are left with a pile of plastic bags, which you want to save for later use, so you take one bag and stuff all the others into it, and throw it under the sink.   In doing so, you realize that there are various ways of nesting the bags, with all bags viewed as identical.

If we use a matching pair of parentheses to represent a bag, the ways are:

For 1 bag, there's one way:

 ()	<- a bag

for 2 bags, there's one way:

 (())	<- one bag in another

for 3 bags, there are two:

 ((())) <- 3 bags nested Russian doll style
 (()()) <- 2 bags side by side, inside the third

for 4 bags, four:

 (()()())
 ((())())
 ((()()))
 (((())))

Note that because all bags are identical, the two 4-bag strings ((())()) and (()(())) represent the same configuration.

It's easy to see that each configuration for n bags represents a n-node rooted tree, where a bag is a tree node, and a bag with its content forms a subtree. The outermost bag is the tree root. Number of configurations for given n is given by OEIS A81.



Task
 
Write a program that, when given n, enumerates all ways of nesting n bags.   You can use the parentheses notation above, or any tree representation that's unambiguous and preferably intuitive.

This task asks for enumeration of trees only; for counting solutions without enumeration, that OEIS page lists various formulas, but that's not encouraged by this task, especially if implementing it would significantly increase code size.

As an example output, run 5 bags.   There should be 9 ways.



",Go,"package main
 
import (
    ""fmt""
    ""log""
    ""os""
    ""strconv""
)
 
type tree uint64
 
var (
    list   []tree
    offset = [32]uint{1: 1}
)
 
func add(t tree) {
    list = append(list, 1|t<<1)
}
 
func show(t tree, l uint) {
    for ; l > 0; t >>= 1 {
        l--
        var paren byte
        if (t & 1) != 0 {
            paren = '('
        } else {
            paren = ')'
        }
        fmt.Printf(""%c"", paren)
    }
}
 
func listTrees(n uint) {
    for i := offset[n]; i < offset[n+1]; i++ {
        show(list[i], n*2)
        fmt.Println()
    }
}
 
/* assemble tree from subtrees
n:   length of tree we want to make
t:   assembled parts so far
sl:  length of subtree we are looking at
pos: offset of subtree we are looking at
rem: remaining length to be put together
*/
 
func assemble(n uint, t tree, sl, pos, rem uint) {
    if rem == 0 {
        add(t)
        return
    }
 
    if sl > rem { // need smaller sub-trees
        sl = rem
        pos = offset[sl]
    } else if pos >= offset[sl+1] {
        // used up sl-trees, try smaller ones
        sl--
        if sl == 0 {
            return
        }
        pos = offset[sl]
    }
 
    assemble(n, t<<(2*sl)|list[pos], sl, pos, rem-sl)
    assemble(n, t, sl, pos+1, rem)
}
 
func mktrees(n uint) {
    if offset[n+1] > 0 {
        return
    }
    if n > 0 {
        mktrees(n - 1)
    }
 
    assemble(n, 0, n-1, offset[n-1], n-1)
    offset[n+1] = uint(len(list))
}
 
func main() {
    if len(os.Args) != 2 {
        log.Fatal(""There must be exactly 1 command line argument"")
    }
    n, err := strconv.Atoi(os.Args[1])
    if err != nil {
        log.Fatal(""Argument is not a valid number"")
    }
    if n <= 0 || n > 19 { // stack overflow for n == 20
        n = 5
    }
    // init 1-tree
    add(0)
 
    mktrees(uint(n))
    fmt.Fprintf(os.Stderr, ""Number of %d-trees: %d\n"", n, offset[n+1]-offset[n])
    listTrees(uint(n))
}",1912,100,"package main

import (
    ""bytes""
    ""os/exec""
    ""strconv""
    ""strings""
    ""testing""
)

func TestListRootedTrees(t *testing.T) {
    testCases := []struct {
        n        int
        expected []string
    }{
        {
            n: 1,
            expected: []string{
                ""()"",
            },
        },
        {
            n: 2,
            expected: []string{
                ""(())"",
            },
        },
        {
            n: 3,
            expected: []string{
                ""((()))"",
                ""(()())"",
            },
        },
        {
            n: 4,
            expected: []string{
                ""(((())))"",
                ""((()()))"",
                ""(()(()))"",
                ""(()()())"",
            },
        },
        {
            n: 5,
            expected: []string{
                ""((((()))))"",
                ""(((()())))"",
                ""((()(())))"",
                ""((()()()))"",
                ""(()((())))"",
                ""(()(()()))"",
                ""(()()(()))"",
                ""(()()()())"",
                ""(()(()))()"",
            },
        },
    }

    for _, tc := range testCases {
        t.Run(""n=""+strconv.Itoa(tc.n), func(t *testing.T) {
            cmd := exec.Command(""./list_rooted_trees"", strconv.Itoa(tc.n))
            var out bytes.Buffer
            cmd.Stdout = &out
            err := cmd.Run()
            if err != nil {
                t.Fatalf(""Failed to execute command: %v"", err)
            }

            output := out.String()
            lines := strings.Split(strings.TrimSpace(output), ""\n"")

            if len(lines) != len(tc.expected) {
                t.Fatalf(""Expected %d trees, got %d"", len(tc.expected), len(lines))
            }

            for i, expected := range tc.expected {
                if lines[i] != expected {
                    t.Errorf(""Expected tree %d to be %s, got %s"", i, expected, lines[i])
                }
            }
        })
    }
}
",./data/generated/docs_golang/list_rooted_trees/gpt_4o_2024_08_06_list_rooted_trees_test.go,CompileStatus.OK,0.0,0.0,,0.1,0.16,0.132,0.0,[],False,False,0.0,False,[]
Long primes,"

A   long prime   (as defined here)   is a prime number whose reciprocal   (in decimal)   has
a   period length   of one less than the prime number.


Long primes   are also known as:

   base ten cyclic numbers
   full reptend primes
   golden primes
   long period primes
   maximal period primes
   proper primes


Another definition:   primes   p   such that the decimal expansion of   1/p   has period   p-1,   which is the greatest period possible for any integer.



Example

7   is the first long prime,   the reciprocal of seven
is   1/7,   which
is equal to the repeating decimal fraction   0.142857142857···

The length of the   repeating   part of the decimal fraction
is six,   (the underlined part)   which is one less
than the (decimal) prime number   7.

Thus   7   is a long prime.



There are other (more) general definitions of a   long prime   which
include wording/verbiage for bases other than ten.



Task

   Show all long primes up to   500   (preferably on one line).
   Show the   number   of long primes up to         500
   Show the   number   of long primes up to      1,000
   Show the   number   of long primes up to      2,000
   Show the   number   of long primes up to      4,000
   Show the   number   of long primes up to      8,000
   Show the   number   of long primes up to   16,000
   Show the   number   of long primes up to   32,000
   Show the   number   of long primes up to   64,000   (optional)
   Show all output here.


Also see

   Wikipedia: full reptend prime
   MathWorld: full reptend prime
   OEIS: A001913

",Go,"package main
 
import ""fmt""
 
func sieve(limit int) []int {
    var primes []int
    c := make([]bool, limit + 1) // composite = true
    // no need to process even numbers
    p := 3
    p2 := p * p
    for p2 <= limit {
        for i := p2; i <= limit; i += 2 * p {
            c[i] = true
        }
        for ok := true; ok; ok = c[p] {
            p += 2
        }
        p2 = p * p
    }
    for i := 3; i <= limit; i += 2 {
        if !c[i] {
            primes = append(primes, i)
        }
    }
    return primes
}
 
// finds the period of the reciprocal of n
func findPeriod(n int) int {
    r := 1
    for i := 1; i <= n + 1; i++ {
        r = (10 * r) % n
    }
    rr := r
    period := 0
    for ok := true; ok; ok = r != rr {
        r = (10 * r) % n
        period++
    }
    return period
}
 
func main() {
    primes := sieve(64000)
    var longPrimes []int
    for _, prime := range primes {
        if findPeriod(prime) == prime - 1 {
            longPrimes = append(longPrimes, prime)
        }
    }
    numbers := []int{500, 1000, 2000, 4000, 8000, 16000, 32000, 64000}
    index := 0
    count := 0
    totals := make([]int, len(numbers))
    for _, longPrime := range longPrimes {
        if longPrime > numbers[index] {
            totals[index] = count
            index++
        }
        count++
    }
    totals[len(numbers)-1] = count
    fmt.Println(""The long primes up to"", numbers[0], ""are: "")
    fmt.Println(longPrimes[:totals[0]])
 
    fmt.Println(""\nThe number of long primes up to: "")
    for i, total := range totals {
        fmt.Printf(""  %5d is %d\n"", numbers[i], total)
    }
}",1627,70,error,,,,,,,,,,,False,False,,False,
Longest common substring,"Task

Write a function that returns the longest common substring of two strings.

Use it within a program that demonstrates sample output from the function, which will consist of the longest common substring between ""thisisatest"" and ""testing123testing"".

Note that substrings are consecutive characters within a string.   This distinguishes them from subsequences, which is any sequence of characters within a string, even if there are extraneous characters in between them.

Hence, the longest common subsequence between ""thisisatest"" and ""testing123testing"" is ""tsitest"", whereas the longest common substring is just ""test"".




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




References

Generalize Suffix Tree
Ukkonen’s Suffix Tree Construction

",Go,"package main
 
import ""fmt""
 
func lcs(a, b string) (output string) {
    lengths := make([]int, len(a)*len(b))
    greatestLength := 0
    for i, x := range a {
        for j, y := range b {
            if x == y {
                if i == 0 || j == 0 {
                    lengths[i*len(b)+j] = 1
                } else {
                    lengths[i*len(b)+j] = lengths[(i-1)*len(b)+j-1] + 1
                }
                if lengths[i*len(b)+j] > greatestLength {
                    greatestLength = lengths[i*len(b)+j]
                    output = a[i-greatestLength+1 : i+1]
                }
            }
        }
    }
    return
}
 
func main() {
    fmt.Println(lcs(""thisisatest"", ""testing123testing""))
}",720,28,error,,,,,,,,,,,False,False,,False,
Longest increasing subsequence,"Calculate and show here a longest increasing subsequence of the list:





{
3
,
2
,
6
,
4
,
5
,
1
}


{\displaystyle \{3,2,6,4,5,1\}}


And of the list:





{
0
,
8
,
4
,
12
,
2
,
10
,
6
,
14
,
1
,
9
,
5
,
13
,
3
,
11
,
7
,
15
}


{\displaystyle \{0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15\}}


Note that a list may have more than one subsequence that is of the maximum length.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




Ref

 Dynamic Programming #1: Longest Increasing Subsequence on YouTube
 An efficient solution can be based on Patience sorting.

",Go,"package main
 
import (
  ""fmt""
  ""sort""
)
 
type Node struct {
    val int
    back *Node
}
 
func lis (n []int) (result []int) {
  var pileTops []*Node
  // sort into piles
  for _, x := range n {
    j := sort.Search(len(pileTops), func (i int) bool { return pileTops[i].val >= x })
    node := &Node{ x, nil }
    if j != 0 { node.back = pileTops[j-1] }
    if j != len(pileTops) {
      pileTops[j] = node
    } else {
      pileTops = append(pileTops, node)
    }
  }
 
  if len(pileTops) == 0 { return []int{} }
  for node := pileTops[len(pileTops)-1]; node != nil; node = node.back {
    result = append(result, node.val)
  }
  // reverse
  for i := 0; i < len(result)/2; i++ {
    result[i], result[len(result)-i-1] = result[len(result)-i-1], result[i]
  }
  return
}
 
func main() {
    for _, d := range [][]int{{3, 2, 6, 4, 5, 1},
            {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}} {
        fmt.Printf(""an L.I.S. of %v is %v\n"", d, lis(d))
    }
}",977,43,"package main

import (
	""reflect""
	""testing""
)

func TestLIS(t *testing.T) {
	tests := []struct {
		input    []int
		expected []int
	}{
		{
			input:    []int{3, 2, 6, 4, 5, 1},
			expected: []int{2, 4, 5}, // One possible LIS
		},
		{
			input:    []int{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15},
			expected: []int{0, 2, 6, 9, 11, 15}, // One possible LIS
		},
		{
			input:    []int{10, 22, 9, 33, 21, 50, 41, 60, 80},
			expected: []int{10, 22, 33, 50, 60, 80}, // One possible LIS
		},
		{
			input:    []int{3, 10, 2, 1, 20},
			expected: []int{3, 10, 20}, // One possible LIS
		},
		{
			input:    []int{3, 2},
			expected: []int{2}, // One possible LIS
		},
		{
			input:    []int{50, 3, 10, 7, 40, 80},
			expected: []int{3, 7, 40, 80}, // One possible LIS
		},
		{
			input:    []int{},
			expected: []int{}, // Empty input should return empty LIS
		},
	}

	for _, test := range tests {
		result := lis(test.input)
		if !reflect.DeepEqual(result, test.expected) {
			t.Errorf(""For input %v, expected %v, but got %v"", test.input, test.expected, result)
		}
	}
}
",./data/generated/docs_golang/longest_increasing_subsequence/gpt_4o_2024_08_06_longest_increasing_subsequence_test.go,CompileStatus.OK,0.0,89.5,,0.04,0.1,0.129,1.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: lis', 'Severity': '', 'SourceLines': ['\t\tresult := lis(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_longest_increasing_subsequence_test.go', 'Offset': 0, 'Line': 44, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Longest string challenge,"Background

This ""longest string challenge"" is inspired by a problem that used to be given to students learning Icon. Students were expected to try to solve the problem in Icon and another language with which the student was already familiar. The basic problem is quite simple; the challenge and fun part came through the introduction of restrictions. Experience has shown that the original restrictions required some adjustment to bring out the intent of the challenge and make it suitable for Rosetta Code.



Basic problem statement
Write a program that reads lines from standard input and, upon end of file, writes the longest line to standard output.
If there are ties for the longest line, the program writes out all the lines that tie.
If there is no input, the program should produce no output.



Task 
Implement a solution to the basic problem that adheres to the spirit of the restrictions (see below).

Describe how you circumvented or got around these 'restrictions' and met the 'spirit' of the challenge. Your supporting description may need to describe any challenges to interpreting the restrictions and how you made this interpretation. You should state any assumptions, warnings, or other relevant points. The central idea here is to make the task a bit more interesting by thinking outside of the box and perhaps by showing off the capabilities of your language in a creative way. Because there is potential for considerable variation between solutions, the description is key to helping others see what you've done.

This task is likely to encourage a variety of different types of solutions. They should be substantially different approaches.

Given the input:

a
bb
ccc
ddd
ee
f
ggg

the output should be (possibly rearranged):

ccc
ddd
ggg



Original list of restrictions
 No comparison operators may be used.
 No arithmetic operations, such as addition and subtraction, may be used.
 The only datatypes you may use are integer and string. In particular, you may not use lists.
 Do not re-read the input file. Avoid using files as a replacement for lists (this restriction became apparent in the discussion).


Intent of restrictions

Because of the variety of languages on Rosetta Code and the wide variety of concepts used in them, there needs to be a bit of clarification and guidance here to get to the spirit of the challenge and the intent of the restrictions.

The basic problem can be solved very conventionally, but that's boring and pedestrian. The original intent here wasn't to unduly frustrate people with interpreting the restrictions, it was to get people to think outside of their particular box and have a bit of fun doing it.

The guiding principle here should be to be creative in demonstrating some of the capabilities of the programming language being used. If you need to bend the restrictions a bit, explain why and try to follow the intent. If you think you've implemented a 'cheat', call out the fragment yourself and ask readers if they can spot why. If you absolutely can't get around one of the restrictions, explain why in your description.

Now having said that, the restrictions require some elaboration.

 In general, the restrictions are meant to avoid the explicit use of these features.
 ""No comparison operators may be used"" - At some level there must be some test that allows the solution to get at the length and determine if one string is longer. Comparison operators, in particular any less/greater comparison should be avoided. Representing the length of any string as a number should also be avoided. Various approaches allow for detecting the end of a string. Some of these involve implicitly using equal/not-equal; however, explicitly using equal/not-equal should be acceptable.
 ""No arithmetic operations"" - Again, at some level something may have to advance through the string. Often there are ways a language can do this implicitly advance a cursor or pointer without explicitly using a +, - , ++, --, add, subtract, etc.
 The datatype restrictions are amongst the most difficult to reinterpret. In the language of the original challenge strings are atomic datatypes and structured datatypes like lists are quite distinct and have many different operations that apply to them. This becomes a bit fuzzier with languages with a different programming paradigm. The intent would be to avoid using an easy structure to accumulate the longest strings and spit them out. There will be some natural reinterpretation here.


To make this a bit more concrete, here are a couple of specific examples:
In C, a string is an array of chars, so using a couple of arrays as strings is in the spirit while using a second array in a non-string like fashion would violate the intent.
In APL or J, arrays are the core of the language so ruling them out is unfair. Meeting the spirit will come down to how they are used.

Please keep in mind these are just examples and you may hit new territory finding a solution. There will be other cases like these. Explain your reasoning. You may want to open a discussion on the talk page as well.

 The added ""No rereading"" restriction is for practical reasons, re-reading stdin should be broken. I haven't outright banned the use of other files but I've discouraged them as it is basically another form of a list. Somewhere there may be a language that just sings when doing file manipulation and where that makes sense; however, for most there should be a way to accomplish without resorting to an externality.


At the end of the day for the implementer this should be a bit of fun. As an implementer you represent the expertise in your language, the reader may have no knowledge of your language. For the reader it should give them insight into how people think outside the box in other languages. Comments, especially for non-obvious (to the reader) bits will be extremely helpful. While the implementations may be a bit artificial in the context of this task, the general techniques may be useful elsewhere.



",Go,"package main
 
import (
    ""bufio""
    ""os""
)
 
func main() {
    in := bufio.NewReader(os.Stdin)
    var blankLine = ""\n""
    var printLongest func(string) string
    printLongest = func(candidate string) (longest string) {
        longest = candidate
        s, err := in.ReadString('\n')
        defer func() {
            recover()
            defer func() {
                recover()
            }()
            _ = blankLine[0]
            func() {
                defer func() {
                    recover()
                }()
                _ = s[len(longest)]
                longest = s
            }()
            longest = printLongest(longest)
            func() {
                defer func() {
                    recover()
                    os.Stdout.WriteString(s)
                }()
                _ = longest[len(s)]
                s = """"
            }()
        }()
        _ = err.(error)
        os.Stdout.WriteString(blankLine)
        blankLine = """"
        return
    }
    printLongest("""")
}",1026,44,"package main

import (
	""bytes""
	""os""
	""strings""
	""testing""
)

func TestLongestStringChallenge(t *testing.T) {
	tests := []struct {
		input    string
		expected []string
	}{
		{
			input:    ""a\nbb\nccc\nddd\nee\nf\nggg\n"",
			expected: []string{""ccc"", ""ddd"", ""ggg""},
		},
		{
			input:    ""hello\nworld\nfoo\nbar\nbaz\n"",
			expected: []string{""hello"", ""world""},
		},
		{
			input:    ""short\nlonger\nlongest\n"",
			expected: []string{""longest""},
		},
		{
			input:    ""one\ntwo\nthree\nfour\nfive\nsix\nseven\n"",
			expected: []string{""three""},
		},
		{
			input:    """",
			expected: []string{},
		},
	}

	for _, test := range tests {
		// Redirect standard input
		r, w, _ := os.Pipe()
		os.Stdin = r

		// Write test input to standard input
		w.WriteString(test.input)
		w.Close()

		// Capture standard output
		var buf bytes.Buffer
		os.Stdout = &buf

		// Run the main function
		main()

		// Reset standard output
		os.Stdout = os.NewFile(1, ""/dev/stdout"")

		// Get the output and split it into lines
		output := strings.TrimSpace(buf.String())
		lines := strings.Split(output, ""\n"")

		// Check if the output matches the expected result
		if len(lines) != len(test.expected) {
			t.Errorf(""Expected %d lines, got %d lines"", len(test.expected), len(lines))
		}

		for i, line := range lines {
			if line != test.expected[i] {
				t.Errorf(""Expected line %d to be %q, got %q"", i, test.expected[i], line)
			}
		}
	}
}
",./data/generated/docs_golang/longest_string_challenge/gpt_4o_2024_08_06_longest_string_challenge_test.go,CompileStatus.SYNTAX_ERROR,,,,0.06,0.25,,2.0,"[{'FromLinter': 'typecheck', 'Text': 'cannot use &buf (value of type *bytes.Buffer) as *os.File value in assignment', 'Severity': '', 'SourceLines': ['\t\tos.Stdout = &buf'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_longest_string_challenge_test.go', 'Offset': 0, 'Line': 48, 'Column': 15}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\t\tmain()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_longest_string_challenge_test.go', 'Offset': 0, 'Line': 51, 'Column': 3}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_longest_string_challenge_test.go', 'line': 48, 'column': 15, 'message': 'cannot use &buf (value of type *bytes.Buffer) as *os.File value in assignment'}]"
Loops/Increment loop index within loop body,"Sometimes, one may need   (or want)   a loop which
its   iterator   (the index
variable)   is modified within the

loop body    in addition to the normal incrementation by the   (do)   loop structure index.



Goal

Demonstrate the best way to accomplish this.



Task

Write a loop which:

   starts the index (variable) at   42
   (at iteration time)   increments the index by unity
   if the index is prime:
   displays the count of primes found (so far) and the prime   (to the terminal)
   increments the index such that the new index is now the (old) index plus that prime
   terminates the loop when   42   primes are shown


Extra credit:   because of the primes get rather large, use commas
within the displayed primes to ease comprehension.



Show all output here.



Note

Not all programming languages allow the modification of a
loop's index.   If that is the case, then use whatever method that
is appropriate or idiomatic for that language.   Please add a note
if the loop's index isn't modifiable.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Go,"package main
 
import(
    ""golang.org/x/text/language""
    ""golang.org/x/text/message""
)
 
func isPrime(n uint64) bool {
    if n % 2 == 0 {
        return n == 2
    }
    if n % 3 == 0 {
        return n == 3
    }
    d := uint64(5)
    for d * d <= n {
        if n % d == 0 {
            return false
        }
        d += 2
        if n % d == 0 {
            return false
        } 
        d += 4
    }
    return true
}
 
const limit = 42
 
func main() {
    p := message.NewPrinter(language.English)
    for i, n := uint64(limit), 0; n < limit; i++ {
        if isPrime(i) {
            n++
            p.Printf(""n = %-2d  %19d\n"", n, i)
            i += i - 1
        }
    }
}",690,40,"package main

import (
	""testing""
)

// TestIsPrime tests the isPrime function for various cases
func TestIsPrime(t *testing.T) {
	tests := []struct {
		input    uint64
		expected bool
	}{
		{2, true},
		{3, true},
		{4, false},
		{5, true},
		{9, false},
		{11, true},
		{15, false},
		{17, true},
		{19, true},
		{23, true},
		{25, false},
		{29, true},
		{31, true},
		{37, true},
		{41, true},
		{42, false},
		{43, true},
		{47, true},
		{53, true},
		{59, true},
	}

	for _, test := range tests {
		result := isPrime(test.input)
		if result != test.expected {
			t.Errorf(""isPrime(%d) = %v; expected %v"", test.input, result, test.expected)
		}
	}
}

// TestMainFunction tests the main function to ensure it outputs the correct number of primes
func TestMainFunction(t *testing.T) {
	// Capture the output of the main function
	output := captureOutput(main)

	// Check if the output contains 42 prime numbers
	expectedCount := 42
	actualCount := countPrimesInOutput(output)
	if actualCount != expectedCount {
		t.Errorf(""Expected %d primes, but got %d"", expectedCount, actualCount)
	}
}

// Helper function to capture the output of a function
func captureOutput(f func()) string {
	// Redirect stdout
	r, w, _ := os.Pipe()
	stdout := os.Stdout
	defer func() {
		os.Stdout = stdout
	}()
	os.Stdout = w

	// Call the function
	f()

	// Read the output
	w.Close()
	var buf bytes.Buffer
	io.Copy(&buf, r)
	return buf.String()
}

// Helper function to count the number of primes in the output
func countPrimesInOutput(output string) int {
	lines := strings.Split(output, ""\n"")
	count := 0
	for _, line := range lines {
		if strings.Contains(line, ""n ="") {
			count++
		}
	}
	return count
}
",./data/generated/docs_golang/loops_increment_loop_index_within_loop_body/gpt_4o_2024_08_06_loops_increment_loop_index_within_loop_body_test.go,CompileStatus.SYNTAX_ERROR,,,,0.06,0.33,,9.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: isPrime', 'Severity': '', 'SourceLines': ['\t\tresult := isPrime(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_increment_loop_index_within_loop_body_test.go', 'Offset': 0, 'Line': 36, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: main', 'Severity': '', 'SourceLines': ['\toutput := captureOutput(main)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_increment_loop_index_within_loop_body_test.go', 'Offset': 0, 'Line': 46, 'Column': 26}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: os', 'Severity': '', 'SourceLines': ['\tr, w, _ := os.Pipe()'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_increment_loop_index_within_loop_body_test.go', 'Offset': 0, 'Line': 59, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: os', 'Severity': '', 'SourceLines': ['\tstdout := os.Stdout'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_increment_loop_index_within_loop_body_test.go', 'Offset': 0, 'Line': 60, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: os', 'Severity': '', 'SourceLines': ['\t\tos.Stdout = stdout'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_increment_loop_index_within_loop_body_test.go', 'Offset': 0, 'Line': 62, 'Column': 3}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: bytes', 'Severity': '', 'SourceLines': ['\tvar buf bytes.Buffer'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_increment_loop_index_within_loop_body_test.go', 'Offset': 0, 'Line': 71, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: io', 'Severity': '', 'SourceLines': ['\tio.Copy(&buf, r)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_increment_loop_index_within_loop_body_test.go', 'Offset': 0, 'Line': 72, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: strings', 'Severity': '', 'SourceLines': ['\tlines := strings.Split(output, ""\\n"")'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_increment_loop_index_within_loop_body_test.go', 'Offset': 0, 'Line': 78, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: strings', 'Severity': '', 'SourceLines': ['\t\tif strings.Contains(line, ""n ="") {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_increment_loop_index_within_loop_body_test.go', 'Offset': 0, 'Line': 81, 'Column': 6}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_loops_increment_loop_index_within_loop_body_test.go', 'line': 59, 'column': 13, 'message': 'undefined: os'}]"
Loops/With multiple ranges,"Loops/With multiple ranges

You are encouraged to solve this task according to the task description, using any language you may know.
Some languages allow multiple loop ranges, such as the PL/I example (snippet) below.

                                       /* all variables are DECLARED as integers. */
          prod=  1;                    /*start with a product of unity.           */
           sum=  0;                    /*  ""     ""  ""   sum    "" zero.            */
             x= +5;
             y= -5;
             z= -2;
           one=  1;
         three=  3;
         seven=  7;
                                       /*(below)  **  is exponentiation:  4**3=64 */
           do j=   -three  to     3**3        by three   ,
                   -seven  to   +seven        by   x     ,
                      555  to      550 - y               ,
                       22  to      -28        by -three  ,
                     1927  to     1939                   ,
                        x  to        y        by   z     ,
                    11**x  to    11**x + one;
                                                        /* ABS(n) = absolute value*/
           sum= sum + abs(j);                           /*add absolute value of J.*/
           if abs(prod)<2**27 & j¬=0  then prod=prod*j; /*PROD is small enough & J*/
           end;                                         /*not 0, then multiply it.*/
                     /*SUM and PROD are used for verification of J incrementation.*/
         display (' sum= ' ||  sum);                    /*display strings to term.*/
         display ('prod= ' || prod);                    /*   ""       ""     ""   ""  */


Task

Simulate/translate the above PL/I program snippet as best as possible in your
language,   with particular emphasis on the   do   loop construct.

The   do   index must be incremented/decremented in the same order shown.

If feasible, add commas to the two output numbers (being displayed).

Show all output here.

      A simple PL/I   DO  loop  (incrementing or decrementing)  has the construct of:
 
            DO variable = start_expression    {TO ending_expression]       {BY increment_expression} ;
                 ---or---
            DO variable = start_expression    {BY increment_expression}    {TO ending_expression]    ;  
 
      where it is understood that all expressions will have a value.  The  variable  is normally a 
      scaler variable,  but need not be  (but for this task, all variables and expressions are declared
      to be scaler integers).   If the   BY   expression is omitted,  a   BY   value of unity is used.
      All expressions are evaluated before the   DO   loop is executed,  and those values are used
      throughout the   DO   loop execution   (even though, for instance,  the value of   Z   may be
      changed within the   DO   loop.    This isn't the case here for this task.  
 
      A multiple-range   DO   loop can be constructed by using a comma (,) to separate additional ranges
      (the use of multiple   TO   and/or   BY   keywords).     This is the construct used in this task.
 
      There are other forms of   DO   loops in PL/I involving the  WHILE  clause,  but those won't be 
      needed here.    DO  loops without a   TO   clause might need a   WHILE   clause  or some other 
      means of exiting the loop  (such as  LEAVE,  RETURN,  SIGNAL,  GOTO,  or  STOP),  or some other 
      (possible error) condition that causes transfer of control outside the  DO  loop.
 
      Also, in PL/I, the check if the   DO   loop index value is outside the range is made at the 
      ""head""  (start)  of the   DO  loop,  so it's possible that the   DO   loop isn't executed,  but 
      that isn't the case for any of the ranges used in this task. 
 
      In the example above, the clause:                    x    to y       by z     
      will cause the variable   J   to have to following values  (in this order):  5  3  1  -1  -3  -5
 
      In the example above, the clause:                 -seven  to +seven  by x  
      will cause the variable   J   to have to following values  (in this order):  -7  -2   3  


Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Go,"package main
 
import ""fmt""
 
func pow(n int, e uint) int {
    if e == 0 {
        return 1
    }
    prod := n
    for i := uint(2); i <= e; i++ {
        prod *= n
    }
    return prod
}
 
func abs(n int) int {
    if n >= 0 {
        return n
    }
    return -n
}
 
func commatize(n int) string {
    s := fmt.Sprintf(""%d"", n)
    if n < 0 {
        s = s[1:]
    }
    le := len(s)
    for i := le - 3; i >= 1; i -= 3 {
        s = s[0:i] + "","" + s[i:]
    }
    if n >= 0 {
        return "" "" + s
    }
    return ""-"" + s
}
 
func main() {
    prod := 1
    sum := 0
    const (
        x     = 5
        y     = -5
        z     = -2
        one   = 1
        three = 3
        seven = 7
    )
    p := pow(11, x)
    var j int
 
    process := func() {
        sum += abs(j)
        if abs(prod) < (1<<27) && j != 0 {
            prod *= j
        }
    }
 
    for j = -three; j <= pow(3, 3); j += three {
        process()
    }
    for j = -seven; j <= seven; j += x {
        process()
    }
    for j = 555; j <= 550-y; j++ {
        process()
    }
    for j = 22; j >= -28; j -= three {
        process()
    }
    for j = 1927; j <= 1939; j++ {
        process()
    }
    for j = x; j >= y; j -= -z {
        process()
    }
    for j = p; j <= p+one; j++ {
        process()
    }
    fmt.Println(""sum  = "", commatize(sum))
    fmt.Println(""prod = "", commatize(prod))
}",1389,82,"package main

import (
	""testing""
)

// TestPow tests the pow function
func TestPow(t *testing.T) {
	tests := []struct {
		base     int
		exponent uint
		expected int
	}{
		{2, 3, 8},
		{3, 3, 27},
		{5, 0, 1},
		{11, 5, 161051},
	}

	for _, test := range tests {
		result := pow(test.base, test.exponent)
		if result != test.expected {
			t.Errorf(""pow(%d, %d) = %d; want %d"", test.base, test.exponent, result, test.expected)
		}
	}
}

// TestAbs tests the abs function
func TestAbs(t *testing.T) {
	tests := []struct {
		input    int
		expected int
	}{
		{5, 5},
		{-5, 5},
		{0, 0},
	}

	for _, test := range tests {
		result := abs(test.input)
		if result != test.expected {
			t.Errorf(""abs(%d) = %d; want %d"", test.input, result, test.expected)
		}
	}
}

// TestCommatize tests the commatize function
func TestCommatize(t *testing.T) {
	tests := []struct {
		input    int
		expected string
	}{
		{1000, "" 1,000""},
		{-1000, ""-1,000""},
		{123456789, "" 123,456,789""},
		{0, "" 0""},
	}

	for _, test := range tests {
		result := commatize(test.input)
		if result != test.expected {
			t.Errorf(""commatize(%d) = %s; want %s"", test.input, result, test.expected)
		}
	}
}

// TestMainFunction tests the main function logic
func TestMainFunction(t *testing.T) {
	prod := 1
	sum := 0
	const (
		x     = 5
		y     = -5
		z     = -2
		one   = 1
		three = 3
		seven = 7
	)
	p := pow(11, x)
	var j int

	process := func() {
		sum += abs(j)
		if abs(prod) < (1<<27) && j != 0 {
			prod *= j
		}
	}

	for j = -three; j <= pow(3, 3); j += three {
		process()
	}
	for j = -seven; j <= seven; j += x {
		process()
	}
	for j = 555; j <= 550-y; j++ {
		process()
	}
	for j = 22; j >= -28; j -= three {
		process()
	}
	for j = 1927; j <= 1939; j++ {
		process()
	}
	for j = x; j >= y; j -= -z {
		process()
	}
	for j = p; j <= p+one; j++ {
		process()
	}

	expectedSum := 124, 255
	expectedProd := 1, 307, 674, 368, 000

	if sum != expectedSum {
		t.Errorf(""sum = %d; want %d"", sum, expectedSum)
	}

	if prod != expectedProd {
		t.Errorf(""prod = %d; want %d"", prod, expectedProd)
	}
}
",./data/generated/docs_golang/loops_with_multiple_ranges/gpt_4o_2024_08_06_loops_with_multiple_ranges_test.go,CompileStatus.SYNTAX_ERROR,,,,0.07,0.25,,9.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: pow', 'Severity': '', 'SourceLines': ['\t\tresult := pow(test.base, test.exponent)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_with_multiple_ranges_test.go', 'Offset': 0, 'Line': 21, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: abs', 'Severity': '', 'SourceLines': ['\t\tresult := abs(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_with_multiple_ranges_test.go', 'Offset': 0, 'Line': 40, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: commatize', 'Severity': '', 'SourceLines': ['\t\tresult := commatize(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_with_multiple_ranges_test.go', 'Offset': 0, 'Line': 60, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: pow', 'Severity': '', 'SourceLines': ['\tp := pow(11, x)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_with_multiple_ranges_test.go', 'Offset': 0, 'Line': 79, 'Column': 7}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: abs', 'Severity': '', 'SourceLines': ['\t\tsum += abs(j)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_with_multiple_ranges_test.go', 'Offset': 0, 'Line': 83, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: abs', 'Severity': '', 'SourceLines': ['\t\tif abs(prod) < (1<<27) && j != 0 {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_with_multiple_ranges_test.go', 'Offset': 0, 'Line': 84, 'Column': 6}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: pow', 'Severity': '', 'SourceLines': ['\tfor j = -three; j <= pow(3, 3); j += three {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_with_multiple_ranges_test.go', 'Offset': 0, 'Line': 89, 'Column': 23}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'assignment mismatch: 1 variable but 2 values', 'Severity': '', 'SourceLines': ['\texpectedSum := 124, 255'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_with_multiple_ranges_test.go', 'Offset': 0, 'Line': 111, 'Column': 17}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'assignment mismatch: 1 variable but 5 values', 'Severity': '', 'SourceLines': ['\texpectedProd := 1, 307, 674, 368, 000'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_with_multiple_ranges_test.go', 'Offset': 0, 'Line': 112, 'Column': 18}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_loops_with_multiple_ranges_test.go', 'line': 111, 'column': 17, 'message': 'assignment mismatch: 1 variable but 2 values'}]"
Loops/Wrong ranges,"Loops/Wrong ranges

You are encouraged to solve this task according to the task description, using any language you may know.
Some languages have syntax or function(s) to generate a range of numeric values from a start value, a stop value, and an increment.

The purpose of this task is to select the range syntax/function that would generate at least two increasing numbers when given a stop value more than the start value and a positive increment of less than half the difference.   You are then to use that same syntax/function but with different parameters; and show, here, what would happen.

Use these values if possible:



start 
stop 
increment 
Comment


 -2
2
1
Normal


 -2
2
0
Zero increment


 -2
2
-1
Increments away from stop value


 -2
2
10
First increment is beyond stop value


2
-2
1
Start more than stop: positive increment


2
2
1
Start equal stop: positive increment


2
2
-1
Start equal stop: negative increment


2
2
0
Start equal stop: zero increment


0
0
0
Start equal stop equal zero: zero increment

Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Go,"package main
 
import ""fmt""
 
type S struct {
    start, stop, incr int
    comment          string
}
 
var examples = []S{
    {-2, 2, 1, ""Normal""},
    {-2, 2, 0, ""Zero increment""},
    {-2, 2, -1, ""Increments away from stop value""},
    {-2, 2, 10, ""First increment is beyond stop value""},
    {2, -2, 1, ""Start more than stop: positive increment""},
    {2, 2, 1, ""Start equal stop: positive increment""},
    {2, 2, -1, ""Start equal stop: negative increment""},
    {2, 2, 0, ""Start equal stop: zero increment""},
    {0, 0, 0, ""Start equal stop equal zero: zero increment""},
}
 
func sequence(s S, limit int) []int {
    var seq []int
    for i, c := s.start, 0; i <= s.stop && c < limit; i, c = i+s.incr, c+1 {
        seq = append(seq, i)
    }
    return seq
}
 
func main() {
    const limit = 10
    for _, ex := range examples {
        fmt.Println(ex.comment)
        fmt.Printf(""Range(%d, %d, %d) -> "", ex.start, ex.stop, ex.incr)
        fmt.Println(sequence(ex, limit))
        fmt.Println()
    }
}",1011,38,"package main

import (
	""reflect""
	""testing""
)

type S struct {
	start, stop, incr int
	comment           string
}

var examples = []S{
	{-2, 2, 1, ""Normal""},
	{-2, 2, 0, ""Zero increment""},
	{-2, 2, -1, ""Increments away from stop value""},
	{-2, 2, 10, ""First increment is beyond stop value""},
	{2, -2, 1, ""Start more than stop: positive increment""},
	{2, 2, 1, ""Start equal stop: positive increment""},
	{2, 2, -1, ""Start equal stop: negative increment""},
	{2, 2, 0, ""Start equal stop: zero increment""},
	{0, 0, 0, ""Start equal stop equal zero: zero increment""},
}

func sequence(s S, limit int) []int {
	var seq []int
	for i, c := s.start, 0; i <= s.stop && c < limit; i, c = i+s.incr, c+1 {
		seq = append(seq, i)
	}
	return seq
}

func TestSequence(t *testing.T) {
	tests := []struct {
		input    S
		limit    int
		expected []int
	}{
		{S{-2, 2, 1, ""Normal""}, 10, []int{-2, -1, 0, 1, 2}},
		{S{-2, 2, 0, ""Zero increment""}, 10, []int{}},
		{S{-2, 2, -1, ""Increments away from stop value""}, 10, []int{}},
		{S{-2, 2, 10, ""First increment is beyond stop value""}, 10, []int{-2}},
		{S{2, -2, 1, ""Start more than stop: positive increment""}, 10, []int{}},
		{S{2, 2, 1, ""Start equal stop: positive increment""}, 10, []int{2}},
		{S{2, 2, -1, ""Start equal stop: negative increment""}, 10, []int{2}},
		{S{2, 2, 0, ""Start equal stop: zero increment""}, 10, []int{}},
		{S{0, 0, 0, ""Start equal stop equal zero: zero increment""}, 10, []int{}},
	}

	for _, test := range tests {
		t.Run(test.input.comment, func(t *testing.T) {
			result := sequence(test.input, test.limit)
			if !reflect.DeepEqual(result, test.expected) {
				t.Errorf(""For %s, expected %v, got %v"", test.input.comment, test.expected, result)
			}
		})
	}
}
",./data/generated/docs_golang/loops_wrong_ranges/gpt_4o_2024_08_06_loops_wrong_ranges_test.go,CompileStatus.SYNTAX_ERROR,,,,0.03,0.2,,1.0,"[{'FromLinter': 'unused', 'Text': 'var `examples` is unused', 'Severity': '', 'SourceLines': ['var examples = []S{'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_loops_wrong_ranges_test.go', 'Offset': 120, 'Line': 13, 'Column': 5}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_loops_wrong_ranges_test.go', 'line': 8, 'column': 6, 'message': 'S redeclared in this block'}]"
Lucas-Lehmer test,"Lucas-Lehmer Test:

for 



p


{\displaystyle p}

 an odd prime, the Mersenne number 




2

p


−
1


{\displaystyle 2^{p}-1}

 is prime if and only if 




2

p


−
1


{\displaystyle 2^{p}-1}

 divides 



S
(
p
−
1
)


{\displaystyle S(p-1)}

 where 



S
(
n
+
1
)
=
(
S
(
n
)

)

2


−
2


{\displaystyle S(n+1)=(S(n))^{2}-2}

, and 



S
(
1
)
=
4


{\displaystyle S(1)=4}

.



Task

Calculate all Mersenne primes up to the implementation's
maximum precision, or the 47th Mersenne prime   (whichever comes first).



",Go,"package main
 
import (
    ""fmt""
    ""math/big""
)
 
var primes = []uint{3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,
    53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127}
 
var mersennes = []uint{521, 607, 1279, 2203, 2281, 3217, 4253, 4423, 9689,
    9941, 11213, 19937, 21701, 23209, 44497, 86243, 110503, 132049, 216091,
    756839, 859433, 1257787, 1398269, 2976221, 3021377, 6972593, 13466917,
    20996011, 24036583}
 
func main() {
    llTest(primes)
    fmt.Println()
    llTest(mersennes)
}
 
func llTest(ps []uint) {
    var s, m big.Int
    one := big.NewInt(1)
    two := big.NewInt(2)
    for _, p := range ps {
        m.Sub(m.Lsh(one, p), one)
        s.SetInt64(4)
        for i := uint(2); i < p; i++ {
            s.Mod(s.Sub(s.Mul(&s, &s), two), &m)
        }
        if s.BitLen() == 0 {
            fmt.Printf(""M%d "", p)
        }
    }
}",888,36,"package main

import (
    ""math/big""
    ""testing""
)

func TestLucasLehmer(t *testing.T) {
    testCases := []struct {
        primes    []uint
        expected  []uint
    }{
        {
            primes:   []uint{3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47},
            expected: []uint{3, 5, 7, 13, 17, 19, 31},
        },
        {
            primes:   []uint{53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127},
            expected: []uint{61, 89, 107, 127},
        },
    }

    for _, tc := range testCases {
        result := llTest(tc.primes)
        if !equal(result, tc.expected) {
            t.Errorf(""Expected %v, but got %v"", tc.expected, result)
        }
    }
}

func llTest(ps []uint) []uint {
    var s, m big.Int
    one := big.NewInt(1)
    two := big.NewInt(2)
    var result []uint
    for _, p := range ps {
        m.Sub(m.Lsh(one, p), one)
        s.SetInt64(4)
        for i := uint(2); i < p; i++ {
            s.Mod(s.Sub(s.Mul(&s, &s), two), &m)
        }
        if s.BitLen() == 0 {
            result = append(result, p)
        }
    }
    return result
}

func equal(a, b []uint) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}
",./data/generated/docs_golang/lucas_lehmer_test/gpt_4o_2024_08_06_lucas_lehmer_test_test.go,CompileStatus.SYNTAX_ERROR,,,,0.03,0.2,,0.0,[],False,False,,False,"[{'file': './lucas_lehmer_test.go', 'line': 22, 'column': 6, 'message': 'llTest redeclared in this block'}]"
Lucky and even lucky numbers,"Note that in the following explanation list indices are assumed to start at one.

Definition of lucky numbers
Lucky numbers are positive integers that are formed by:

 Form a list of all the positive odd integers > 0




1
,
3
,
5
,
7
,
9
,
11
,
13
,
15
,
17
,
19
,
21
,
23
,
25
,
27
,
29
,
31
,
33
,
35
,
37
,
39...


{\displaystyle 1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39...}


 Return the first number from the list (which is 1).
 (Loop begins here)
 Note then return the second number from the list (which is 3).
 Discard every third, (as noted), number from the list to form the new list




1
,
3
,
7
,
9
,
13
,
15
,
19
,
21
,
25
,
27
,
31
,
33
,
37
,
39
,
43
,
45
,
49
,
51
,
55
,
57...


{\displaystyle 1,3,7,9,13,15,19,21,25,27,31,33,37,39,43,45,49,51,55,57...}


 (Expanding the loop a few more times...)
 Note then return the third number from the list (which is 7).
 Discard every 7th, (as noted), number from the list to form the new list




1
,
3
,
7
,
9
,
13
,
15
,
21
,
25
,
27
,
31
,
33
,
37
,
43
,
45
,
49
,
51
,
55
,
57
,
63
,
67...


{\displaystyle 1,3,7,9,13,15,21,25,27,31,33,37,43,45,49,51,55,57,63,67...}


 Note then return the 4th number from the list (which is 9).
 Discard every 9th, (as noted), number from the list to form the new list




1
,
3
,
7
,
9
,
13
,
15
,
21
,
25
,
31
,
33
,
37
,
43
,
45
,
49
,
51
,
55
,
63
,
67
,
69
,
73...


{\displaystyle 1,3,7,9,13,15,21,25,31,33,37,43,45,49,51,55,63,67,69,73...}


 Take the 5th, i.e. 13. Remove every 13th.
 Take the 6th, i.e. 15. Remove every 15th.
 Take the 7th, i.e. 21. Remove every 21th.
 Take the 8th, i.e. 25. Remove every 25th.
 (Rule for the loop)
 Note the 



n


{\displaystyle n}

th, which is 



m


{\displaystyle m}

.
 Remove every 



m


{\displaystyle m}

th.
 Increment 



n


{\displaystyle n}

.
Definition of even lucky numbers
This follows the same rules as the definition of lucky numbers above except for the very first step:

 Form a list of all the positive even integers > 0




2
,
4
,
6
,
8
,
10
,
12
,
14
,
16
,
18
,
20
,
22
,
24
,
26
,
28
,
30
,
32
,
34
,
36
,
38
,
40...


{\displaystyle 2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40...}


 Return the first number from the list (which is 2).
 (Loop begins here)
 Note then return the second number from the list (which is 4).
 Discard every 4th, (as noted), number from the list to form the new list




2
,
4
,
6
,
10
,
12
,
14
,
18
,
20
,
22
,
26
,
28
,
30
,
34
,
36
,
38
,
42
,
44
,
46
,
50
,
52...


{\displaystyle 2,4,6,10,12,14,18,20,22,26,28,30,34,36,38,42,44,46,50,52...}


 (Expanding the loop a few more times...)
 Note then return the third number from the list (which is 6).
 Discard every 6th, (as noted), number from the list to form the new list




2
,
4
,
6
,
10
,
12
,
18
,
20
,
22
,
26
,
28
,
34
,
36
,
38
,
42
,
44
,
50
,
52
,
54
,
58
,
60...


{\displaystyle 2,4,6,10,12,18,20,22,26,28,34,36,38,42,44,50,52,54,58,60...}


 Take the 4th, i.e. 10. Remove every 10th.
 Take the 5th, i.e. 12. Remove every 12th.
 (Rule for the loop)
 Note the 



n


{\displaystyle n}

th, which is 



m


{\displaystyle m}

.
 Remove every 



m


{\displaystyle m}

th.
 Increment 



n


{\displaystyle n}

.
Task requirements
 Write one or two subroutines (functions) to generate lucky numbers and even lucky numbers 
 Write a command-line interface to allow selection of which kind of numbers and which number(s). Since input is from the command line, tests should be made for the common errors:
 missing arguments
 too many arguments
 number (or numbers) aren't legal
 misspelled argument (lucky or evenLucky)
 The command line handling should:
 support mixed case handling of the (non-numeric) arguments
 support printing a particular number
 support printing a range of numbers by their index
 support printing a range of numbers by their values
 The resulting list of numbers should be printed on a single line.

The program should support the arguments:

                             what is displayed  (on a single line)
       argument(s)              (optional verbiage is encouraged)
  ╔═══════════════════╦════════════════════════════════════════════════════╗
  ║  j                ║  Jth       lucky number                            ║
  ║  j  ,      lucky  ║  Jth       lucky number                            ║
  ║  j  ,  evenLucky  ║  Jth  even lucky number                            ║
  ║                   ║                                                    ║
  ║  j  k             ║  Jth  through  Kth (inclusive)       lucky numbers ║
  ║  j  k      lucky  ║  Jth  through  Kth (inclusive)       lucky numbers ║
  ║  j  k  evenLucky  ║  Jth  through  Kth (inclusive)  even lucky numbers ║
  ║                   ║                                                    ║
  ║  j -k             ║  all       lucky numbers in the range  j ──► |k|   ║
  ║  j -k      lucky  ║  all       lucky numbers in the range  j ──► |k|   ║
  ║  j -k  evenLucky  ║  all  even lucky numbers in the range  j ──► |k|   ║
  ╚═══════════════════╩════════════════════════════════════════════════════╝
                           where    |k|    is the absolute value of   k

Demonstrate the program by:

 showing the first twenty lucky numbers
 showing the first twenty even lucky numbers
 showing all lucky numbers between 6,000 and 6,100 (inclusive)
 showing all even lucky numbers in the same range as above
 showing the 10,000th lucky number (extra credit)
 showing the 10,000th even lucky number (extra credit)
See also

 This task is related to the Sieve of Eratosthenes task.
 OEIS Wiki Lucky numbers.
 Sequence A000959 lucky numbers on The On-Line Encyclopedia of Integer Sequences.
 Sequence A045954 even lucky numbers or ELN on The On-Line Encyclopedia of Integer Sequences.
 Entry lucky numbers on The Eric Weisstein's World of Mathematics.

",Go,"package main
 
import (
    ""fmt""
    ""log""
    ""os""
    ""strconv""
    ""strings""
)
 
const luckySize = 60000
 
var luckyOdd = make([]int, luckySize)
var luckyEven = make([]int, luckySize)
 
func init() {
    for i := 0; i < luckySize; i++ {
        luckyOdd[i] = i*2 + 1
        luckyEven[i] = i*2 + 2
    }
}
 
func filterLuckyOdd() {
    for n := 2; n < len(luckyOdd); n++ {
        m := luckyOdd[n-1]
        end := (len(luckyOdd)/m)*m - 1
        for j := end; j >= m-1; j -= m {
            copy(luckyOdd[j:], luckyOdd[j+1:])
            luckyOdd = luckyOdd[:len(luckyOdd)-1]
        }
    }
}
 
func filterLuckyEven() {
    for n := 2; n < len(luckyEven); n++ {
        m := luckyEven[n-1]
        end := (len(luckyEven)/m)*m - 1
        for j := end; j >= m-1; j -= m {
            copy(luckyEven[j:], luckyEven[j+1:])
            luckyEven = luckyEven[:len(luckyEven)-1]
        }
    }
}
 
func printSingle(j int, odd bool) error {
    if odd {
        if j >= len(luckyOdd) {
            return fmt.Errorf(""the argument, %d, is too big"", j)
        }
        fmt.Println(""Lucky number"", j, ""="", luckyOdd[j-1])
    } else {
        if j >= len(luckyEven) {
            return fmt.Errorf(""the argument, %d, is too big"", j)
        }
        fmt.Println(""Lucky even number"", j, ""="", luckyEven[j-1])
    }
    return nil
}
 
func printRange(j, k int, odd bool) error {
    if odd {
        if k >= len(luckyOdd) {
            return fmt.Errorf(""the argument, %d, is too big"", k)
        }
        fmt.Println(""Lucky numbers"", j, ""to"", k, ""are:"")
        fmt.Println(luckyOdd[j-1 : k])
    } else {
        if k >= len(luckyEven) {
            return fmt.Errorf(""the argument, %d, is too big"", k)
        }
        fmt.Println(""Lucky even numbers"", j, ""to"", k, ""are:"")
        fmt.Println(luckyEven[j-1 : k])
    }
    return nil
}
 
func printBetween(j, k int, odd bool) error {
    var r []int
    if odd {
        max := luckyOdd[len(luckyOdd)-1]
        if j > max || k > max {
            return fmt.Errorf(""at least one argument, %d or %d, is too big"", j, k)
        }
        for _, num := range luckyOdd {
            if num < j {
                continue
            }
            if num > k {
                break
            }
            r = append(r, num)
        }
        fmt.Println(""Lucky numbers between"", j, ""and"", k, ""are:"")
        fmt.Println(r)
    } else {
        max := luckyEven[len(luckyEven)-1]
        if j > max || k > max {
            return fmt.Errorf(""at least one argument, %d or %d, is too big"", j, k)
        }
        for _, num := range luckyEven {
            if num < j {
                continue
            }
            if num > k {
                break
            }
            r = append(r, num)
        }
        fmt.Println(""Lucky even numbers between"", j, ""and"", k, ""are:"")
        fmt.Println(r)
    }
    return nil
}
 
func main() {
    nargs := len(os.Args)
    if nargs < 2 || nargs > 4 {
        log.Fatal(""there must be between 1 and 3 command line arguments"")
    }
    filterLuckyOdd()
    filterLuckyEven()
    j, err := strconv.Atoi(os.Args[1])
    if err != nil || j < 1 {
        log.Fatalf(""first argument, %s, must be a positive integer"", os.Args[1])
    }
    if nargs == 2 {
        if err := printSingle(j, true); err != nil {
            log.Fatal(err)
        }
        return
    }
 
    if nargs == 3 {
        k, err := strconv.Atoi(os.Args[2])
        if err != nil {
            log.Fatalf(""second argument, %s, must be an integer"", os.Args[2])
        }
        if k >= 0 {
            if j > k {
                log.Fatalf(""second argument, %d, can't be less than first, %d"", k, j)
            }
            if err := printRange(j, k, true); err != nil {
                log.Fatal(err)
            }
        } else {
            l := -k
            if j > l {
                log.Fatalf(""second argument, %d, can't be less in absolute value than first, %d"", k, j)
            }
            if err := printBetween(j, l, true); err != nil {
                log.Fatal(err)
            }
        }
        return
    }
 
    var odd bool
    switch lucky := strings.ToLower(os.Args[3]); lucky {
    case ""lucky"":
        odd = true
    case ""evenlucky"":
        odd = false
    default:
        log.Fatalf(""third argument, %s, is invalid"", os.Args[3])
    }
    if os.Args[2] == "","" {
        if err := printSingle(j, odd); err != nil {
            log.Fatal(err)
        }
        return
    }
 
    k, err := strconv.Atoi(os.Args[2])
    if err != nil {
        log.Fatal(""second argument must be an integer or a comma"")
    }
    if k >= 0 {
        if j > k {
            log.Fatalf(""second argument, %d, can't be less than first, %d"", k, j)
        }
        if err := printRange(j, k, odd); err != nil {
            log.Fatal(err)
        }
    } else {
        l := -k
        if j > l {
            log.Fatalf(""second argument, %d, can't be less in absolute value than first, %d"", k, j)
        }
        if err := printBetween(j, l, odd); err != nil {
            log.Fatal(err)
        }
    }
}",5086,193,"package main

import (
    ""os/exec""
    ""strings""
    ""testing""
)

func TestLuckyNumbers(t *testing.T) {
    // Test showing the first twenty lucky numbers
    cmd := exec.Command(""go"", ""run"", ""lucky_and_even_lucky_numbers.go"", ""1"", ""20"")
    output, err := cmd.CombinedOutput()
    if err != nil {
        t.Fatalf(""Failed to execute command: %s"", err)
    }
    expected := ""Lucky numbers 1 to 20 are:\n[1 3 7 9 13 15 21 25 31 33 37 43 49 51 63 67 69 73 75 79]""
    if strings.TrimSpace(string(output)) != expected {
        t.Errorf(""Expected %s, but got %s"", expected, output)
    }

    // Test showing the first twenty even lucky numbers
    cmd = exec.Command(""go"", ""run"", ""lucky_and_even_lucky_numbers.go"", ""1"", ""20"", ""evenLucky"")
    output, err = cmd.CombinedOutput()
    if err != nil {
        t.Fatalf(""Failed to execute command: %s"", err)
    }
    expected = ""Lucky even numbers 1 to 20 are:\n[2 4 6 10 12 18 20 22 26 28 34 36 38 42 44 50 52 54 58 60]""
    if strings.TrimSpace(string(output)) != expected {
        t.Errorf(""Expected %s, but got %s"", expected, output)
    }

    // Test showing all lucky numbers between 6,000 and 6,100 (inclusive)
    cmd = exec.Command(""go"", ""run"", ""lucky_and_even_lucky_numbers.go"", ""6000"", ""-6100"")
    output, err = cmd.CombinedOutput()
    if err != nil {
        t.Fatalf(""Failed to execute command: %s"", err)
    }
    expected = ""Lucky numbers between 6000 and 6100 are:\n[6001 6003 6007 6013 6017 6021 6025 6029 6031 6033 6037 6041 6043 6047 6051 6053 6057 6061 6063 6067 6071 6073 6077 6081 6083 6087 6091 6093 6097 6101]""
    if strings.TrimSpace(string(output)) != expected {
        t.Errorf(""Expected %s, but got %s"", expected, output)
    }

    // Test showing all even lucky numbers in the same range as above
    cmd = exec.Command(""go"", ""run"", ""lucky_and_even_lucky_numbers.go"", ""6000"", ""-6100"", ""evenLucky"")
    output, err = cmd.CombinedOutput()
    if err != nil {
        t.Fatalf(""Failed to execute command: %s"", err)
    }
    expected = ""Lucky even numbers between 6000 and 6100 are:\n[6002 6004 6006 6010 6012 6018 6020 6022 6026 6028 6034 6036 6038 6042 6044 6050 6052 6054 6058 6060 6066 6068 6070 6074 6076 6082 6084 6086 6090 6092 6098 6100]""
    if strings.TrimSpace(string(output)) != expected {
        t.Errorf(""Expected %s, but got %s"", expected, output)
    }

    // Test showing the 10,000th lucky number
    cmd = exec.Command(""go"", ""run"", ""lucky_and_even_lucky_numbers.go"", ""10000"")
    output, err = cmd.CombinedOutput()
    if err != nil {
        t.Fatalf(""Failed to execute command: %s"", err)
    }
    expected = ""Lucky number 10000 = 114083""
    if strings.TrimSpace(string(output)) != expected {
        t.Errorf(""Expected %s, but got %s"", expected, output)
    }

    // Test showing the 10,000th even lucky number
    cmd = exec.Command(""go"", ""run"", ""lucky_and_even_lucky_numbers.go"", ""10000"", "","", ""evenLucky"")
    output, err = cmd.CombinedOutput()
    if err != nil {
        t.Fatalf(""Failed to execute command: %s"", err)
    }
    expected = ""Lucky even number 10000 = 114084""
    if strings.TrimSpace(string(output)) != expected {
        t.Errorf(""Expected %s, but got %s"", expected, output)
    }
}

func TestCommandLineErrors(t *testing.T) {
    // Test missing arguments
    cmd := exec.Command(""go"", ""run"", ""lucky_and_even_lucky_numbers.go"")
    output, err := cmd.CombinedOutput()
    if err == nil || !strings.Contains(string(output), ""there must be between 1 and 3 command line arguments"") {
        t.Errorf(""Expected error for missing arguments, but got %s"", output)
    }

    // Test too many arguments
    cmd = exec.Command(""go"", ""run"", ""lucky_and_even_lucky_numbers.go"", ""1"", ""2"", ""3"", ""4"")
    output, err = cmd.CombinedOutput()
    if err == nil || !strings.Contains(string(output), ""there must be between 1 and 3 command line arguments"") {
        t.Errorf(""Expected error for too many arguments, but got %s"", output)
    }

    // Test illegal number
    cmd = exec.Command(""go"", ""run"", ""lucky_and_even_lucky_numbers.go"", ""abc"")
    output, err = cmd.CombinedOutput()
    if err == nil || !strings.Contains(string(output), ""first argument, abc, must be a positive integer"") {
        t.Errorf(""Expected error for illegal number, but got %s"", output)
    }

    // Test misspelled argument
    cmd = exec.Command(""go"", ""run"", ""lucky_and_even_lucky_numbers.go"", ""1"", ""2"", ""luckyy"")
    output, err = cmd.CombinedOutput()
    if err == nil || !strings.Contains(string(output), ""third argument, luckyy, is invalid"") {
        t.Errorf(""Expected error for misspelled argument, but got %s"", output)
    }
}
",./data/generated/docs_golang/lucky_and_even_lucky_numbers/gpt_4o_2024_08_06_lucky_and_even_lucky_numbers_test.go,CompileStatus.OK,,,,0.32,0.38,,0.0,[],False,False,0.0,True,[]
Ludic numbers,"Ludic numbers   are related to prime numbers as they are generated by a sieve quite like the Sieve of Eratosthenes is used to generate prime numbers.

The first ludic number is   1.

To generate succeeding ludic numbers create an array of increasing integers starting from   2.

2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ...
(Loop)

 Take the first member of the resultant array as the next ludic number   2.
 Remove every   2nd   indexed item from the array (including the first).
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ...
 (Unrolling a few loops...)
 Take the first member of the resultant array as the next ludic number   3.
 Remove every   3rd   indexed item from the array (including the first).
3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 ...
 Take the first member of the resultant array as the next ludic number   5.
 Remove every   5th   indexed item from the array (including the first).
5 7 11 13 17 19 23 25 29 31 35 37 41 43 47 49 53 55 59 61 65 67 71 73 77 ...
 Take the first member of the resultant array as the next ludic number   7.
 Remove every   7th   indexed item from the array (including the first).
7 11 13 17 23 25 29 31 37 41 43 47 53 55 59 61 67 71 73 77 83 85 89 91 97 ...
  ... 
 Take the first member of the current array as the next ludic number   L.
 Remove every   Lth   indexed item from the array (including the first).
  ... 


Task

 Generate and show here the first 25 ludic numbers.
 How many ludic numbers are there less than or equal to 1000?
 Show the 2000..2005th ludic numbers.


Stretch goal

Show all triplets of ludic numbers < 250.

 A triplet is any three numbers     



x
,


{\displaystyle x,}

   



x
+
2
,


{\displaystyle x+2,}

   



x
+
6


{\displaystyle x+6}

      where all three numbers are also ludic numbers. 

",Go,"package main
 
import ""fmt""
 
// Ludic returns a slice of Ludic numbers stopping after
// either n entries or when max is exceeded.
// Either argument may be <=0 to disable that limit.
func Ludic(n int, max int) []uint32 {
	const maxInt32 = 1<<31 - 1 // i.e. math.MaxInt32
	if max > 0 && n < 0 {
		n = maxInt32
	}
	if n < 1 {
		return nil
	}
	if max < 0 {
		max = maxInt32
	}
	sieve := make([]uint32, 10760) // XXX big enough for 2005 Ludics
	sieve[0] = 1
	sieve[1] = 2
	if n > 2 {
		// We start with even numbers already removed
		for i, j := 2, uint32(3); i < len(sieve); i, j = i+1, j+2 {
			sieve[i] = j
		}
		// We leave the Ludic numbers in place,
		// k is the index of the next Ludic
		for k := 2; k < n; k++ {
			l := int(sieve[k])
			if l >= max {
				n = k
				break
			}
			i := l
			l--
			// last is the last valid index
			last := k + i - 1
			for j := k + i + 1; j < len(sieve); i, j = i+1, j+1 {
				last = k + i
				sieve[last] = sieve[j]
				if i%l == 0 {
					j++
				}
			}
			// Truncate down to only the valid entries
			if last < len(sieve)-1 {
				sieve = sieve[:last+1]
			}
		}
	}
	if n > len(sieve) {
		panic(""program error"") // should never happen
	}
	return sieve[:n]
}
 
func has(x []uint32, v uint32) bool {
	for i := 0; i < len(x) && x[i] <= v; i++ {
		if x[i] == v {
			return true
		}
	}
	return false
}
 
func main() {
	// Ludic() is so quick we just call it repeatedly
	fmt.Println(""First 25:"", Ludic(25, -1))
	fmt.Println(""Numner of Ludics below 1000:"", len(Ludic(-1, 1000)))
	fmt.Println(""Ludic 2000 to 2005:"", Ludic(2005, -1)[1999:])
 
	fmt.Print(""Tripples below 250:"")
	x := Ludic(-1, 250)
	for i, v := range x[:len(x)-2] {
		if has(x[i+1:], v+2) && has(x[i+2:], v+6) {
			fmt.Printf("", (%d %d %d)"", v, v+2, v+6)
		}
	}
	fmt.Println()
}",1777,81,"package main

import (
	""testing""
	""reflect""
)

func TestLudicFirst25(t *testing.T) {
	expected := []uint32{1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89}
	result := Ludic(25, -1)
	if !reflect.DeepEqual(result, expected) {
		t.Errorf(""Expected first 25 ludic numbers to be %v, but got %v"", expected, result)
	}
}

func TestLudicBelow1000(t *testing.T) {
	expectedCount := 177
	result := len(Ludic(-1, 1000))
	if result != expectedCount {
		t.Errorf(""Expected number of ludic numbers below 1000 to be %d, but got %d"", expectedCount, result)
	}
}

func TestLudic2000To2005(t *testing.T) {
	expected := []uint32{1213, 1217, 1223, 1225, 1229, 1231}
	result := Ludic(2005, -1)[1999:]
	if !reflect.DeepEqual(result, expected) {
		t.Errorf(""Expected ludic numbers from 2000 to 2005 to be %v, but got %v"", expected, result)
	}
}

func TestLudicTripletsBelow250(t *testing.T) {
	expectedTriplets := [][3]uint32{
		{1, 3, 7},
		{3, 5, 11},
		{7, 9, 15},
		{13, 15, 21},
		{21, 23, 29},
		{31, 33, 39},
		{43, 45, 51},
		{55, 57, 63},
		{61, 63, 69},
		{73, 75, 81},
		{79, 81, 87},
		{97, 99, 105},
		{103, 105, 111},
		{109, 111, 117},
		{127, 129, 135},
		{151, 153, 159},
		{157, 159, 165},
		{163, 165, 171},
		{181, 183, 189},
		{193, 195, 201},
		{199, 201, 207},
		{211, 213, 219},
		{217, 219, 225},
		{223, 225, 231},
	}

	x := Ludic(-1, 250)
	var triplets [][3]uint32
	for i, v := range x[:len(x)-2] {
		if has(x[i+1:], v+2) && has(x[i+2:], v+6) {
			triplets = append(triplets, [3]uint32{v, v + 2, v + 6})
		}
	}

	if !reflect.DeepEqual(triplets, expectedTriplets) {
		t.Errorf(""Expected ludic triplets below 250 to be %v, but got %v"", expectedTriplets, triplets)
	}
}
",./data/generated/docs_golang/ludic_numbers/gpt_4o_2024_08_06_ludic_numbers_test.go,CompileStatus.OK,0.0,75.0,,0.08,0.19,0.228,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: Ludic', 'Severity': '', 'SourceLines': ['\tresult := Ludic(25, -1)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_ludic_numbers_test.go', 'Offset': 0, 'Line': 10, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Ludic', 'Severity': '', 'SourceLines': ['\tresult := len(Ludic(-1, 1000))'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_ludic_numbers_test.go', 'Offset': 0, 'Line': 18, 'Column': 16}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Ludic', 'Severity': '', 'SourceLines': ['\tresult := Ludic(2005, -1)[1999:]'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_ludic_numbers_test.go', 'Offset': 0, 'Line': 26, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: has', 'Severity': '', 'SourceLines': ['\t\tif has(x[i+1:], v+2) && has(x[i+2:], v+6) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_ludic_numbers_test.go', 'Offset': 0, 'Line': 63, 'Column': 6}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,0.0,False,[]
Lychrel numbers,"   Take an integer n, greater than zero.
   Form the next n of its series by reversing the digits of the current n and adding the result to the current n.
   Stop when n becomes palindromic - i.e. the digits of n in reverse order == n.


The above recurrence relation when applied to most starting numbers n = 1, 2, ... terminates in a palindrome quite quickly.



Example

If n0 = 12 we get

       12
       12 +  21 =  33,   a palindrome!

And if n0 = 55 we get

       55
       55 +  55 = 110
      110 + 011 = 121,   a palindrome!

Notice that the check for a palindrome happens   after   an addition.



Some starting numbers seem to go on forever; the recurrence relation for 196 has been calculated for millions of repetitions forming numbers with millions of digits, without forming a palindrome.

These numbers that do not end in a palindrome are called Lychrel numbers.

For the purposes of this task a Lychrel number is any starting number that does not form a palindrome within 500 (or more) iterations.



Seed and related Lychrel numbers

Any integer produced in the sequence of a Lychrel number is also a Lychrel number.

In general, any sequence from one Lychrel number might converge to join the sequence from a prior Lychrel number candidate; for example the sequences for the numbers 196 and then 689 begin:

        196
        196 +    691 =   887
        887 +    788 =  1675
       1675 +   5761 =  7436
       7436 +   6347 = 13783
      13783 +  38731 = 52514
      52514 +  41525 = 94039
       ...


        689
        689 +    986 =  1675
       1675 +   5761 =  7436
       ...

So we see that the sequence starting with 689 converges to, and continues with the same numbers as that for 196.

Because of this we can further split the Lychrel numbers into true Seed Lychrel number candidates, and Related numbers that produce no palindromes but have integers in their sequence seen as part of the sequence generated from a lower Lychrel number.



Task

   Find the number of seed Lychrel number candidates and related numbers for n in the range 1..10000 inclusive. (With that iteration limit of 500).
   Print the number of seed Lychrels found; the actual seed Lychrels; and just the number of relateds found.
   Print any seed Lychrel or related number that is itself a palindrome.


Show all output here.



References

   What's special about 196? Numberphile video.
   A023108 Positive integers which apparently never result in a palindrome under repeated applications of the function f(x) = x + (x with digits reversed).
   Status of the 196 conjecture? Mathoverflow.

",Go,"package main
 
import (
	""flag""
	""fmt""
	""math""
	""math/big""
	""os""
)
 
var maxRev = big.NewInt(math.MaxUint64 / 10) // approximate
var ten = big.NewInt(10)
 
// Reverse sets `result` to the value of the base ten digits of `v` in
// reverse order and returns `result`.
// Only handles positive integers.
func reverseInt(v *big.Int, result *big.Int) *big.Int {
	if v.Cmp(maxRev) <= 0 {
		// optimize small values that fit within uint64
		result.SetUint64(reverseUint64(v.Uint64()))
	} else {
		if true {
			// Reverse the string representation
			s := reverseString(v.String())
			result.SetString(s, 10)
		} else {
			// This has fewer allocations but is slower:
			// Use a copy of `v` since we mutate it.
			v := new(big.Int).Set(v)
			digit := new(big.Int)
			result.SetUint64(0)
			for v.BitLen() > 0 {
				v.QuoRem(v, ten, digit)
				result.Mul(result, ten)
				result.Add(result, digit)
			}
		}
	}
	return result
}
 
func reverseUint64(v uint64) uint64 {
	var r uint64
	for v > 0 {
		r *= 10
		r += v % 10
		v /= 10
	}
	return r
}
 
func reverseString(s string) string {
	b := make([]byte, len(s))
	for i, j := 0, len(s)-1; j >= 0; i, j = i+1, j-1 {
		b[i] = s[j]
	}
	return string(b)
}
 
var known = make(map[string]bool)
 
func Lychrel(n uint64, iter uint) (isLychrel, isSeed bool) {
	v, r := new(big.Int).SetUint64(n), new(big.Int)
	reverseInt(v, r)
	seen := make(map[string]bool)
	isLychrel = true
	isSeed = true
	for i := iter; i > 0; i-- {
		str := v.String()
		if seen[str] {
			//log.Println(""found a loop with"", n, ""at"", str)
			isLychrel = true
			break
		}
		if ans, ok := known[str]; ok {
			//log.Println(""already know:"", str, ans)
			isLychrel = ans
			isSeed = false
			break
		}
		seen[str] = true
 
		v = v.Add(v, r)
		//log.Printf(""%v + %v = %v\n"", str, r, v)
		reverseInt(v, r)
		if v.Cmp(r) == 0 {
			//log.Println(v, ""is a palindrome,"", n, ""is not a Lychrel number"")
			isLychrel = false
			isSeed = false
			break
		}
	}
	for k := range seen {
		known[k] = isLychrel
	}
	//if isLychrel { log.Printf(""%v may be a Lychrel number\n"", n) }
	return isLychrel, isSeed
}
 
func main() {
	max := flag.Uint64(""max"", 10000, ""search in the range 1..`N` inclusive"")
	iter := flag.Uint(""iter"", 500, ""limit palindrome search to `N` iterations"")
	flag.Parse()
	if flag.NArg() != 0 {
		flag.Usage()
		os.Exit(2)
	}
 
	fmt.Printf(""Calculating using n = 1..%v and %v iterations:\n"", *max, *iter)
	var seeds []uint64
	var related int
	var pals []uint64
	for i := uint64(1); i <= *max; i++ {
		if l, s := Lychrel(i, *iter); l {
			if s {
				seeds = append(seeds, i)
			} else {
				related++
			}
			if i == reverseUint64(i) {
				pals = append(pals, i)
			}
		}
	}
 
	fmt.Println(""      Number of Lychrel seeds:"", len(seeds))
	fmt.Println(""                Lychrel seeds:"", seeds)
	fmt.Println(""            Number of related:"", related)
	fmt.Println(""Number of Lychrel palindromes:"", len(pals))
	fmt.Println(""          Lychrel palindromes:"", pals)
}",2956,131,"package main

import (
	""testing""
	""math/big""
)

// TestReverseInt tests the reverseInt function for various cases.
func TestReverseInt(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{""123"", ""321""},
		{""100"", ""001""},
		{""9876543210"", ""0123456789""},
		{""1"", ""1""},
		{""0"", ""0""},
	}

	for _, test := range tests {
		v := new(big.Int)
		v.SetString(test.input, 10)
		result := new(big.Int)
		reverseInt(v, result)
		if result.String() != test.expected {
			t.Errorf(""reverseInt(%s) = %s; expected %s"", test.input, result.String(), test.expected)
		}
	}
}

// TestReverseUint64 tests the reverseUint64 function for various cases.
func TestReverseUint64(t *testing.T) {
	tests := []struct {
		input    uint64
		expected uint64
	}{
		{123, 321},
		{100, 1},
		{9876543210, 123456789},
		{1, 1},
		{0, 0},
	}

	for _, test := range tests {
		result := reverseUint64(test.input)
		if result != test.expected {
			t.Errorf(""reverseUint64(%d) = %d; expected %d"", test.input, result, test.expected)
		}
	}
}

// TestReverseString tests the reverseString function for various cases.
func TestReverseString(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{""123"", ""321""},
		{""100"", ""001""},
		{""9876543210"", ""0123456789""},
		{""1"", ""1""},
		{""0"", ""0""},
	}

	for _, test := range tests {
		result := reverseString(test.input)
		if result != test.expected {
			t.Errorf(""reverseString(%s) = %s; expected %s"", test.input, result, test.expected)
		}
	}
}

// TestLychrel tests the Lychrel function for various cases.
func TestLychrel(t *testing.T) {
	tests := []struct {
		input    uint64
		iter     uint
		expectedIsLychrel bool
		expectedIsSeed    bool
	}{
		{12, 500, false, false},  // 12 becomes 33, a palindrome
		{55, 500, false, false},  // 55 becomes 121, a palindrome
		{196, 500, true, true},   // 196 is a known Lychrel candidate
		{689, 500, true, false},  // 689 is related to 196
		{1, 500, false, false},   // 1 is a palindrome
	}

	for _, test := range tests {
		isLychrel, isSeed := Lychrel(test.input, test.iter)
		if isLychrel != test.expectedIsLychrel || isSeed != test.expectedIsSeed {
			t.Errorf(""Lychrel(%d, %d) = (%v, %v); expected (%v, %v)"", test.input, test.iter, isLychrel, isSeed, test.expectedIsLychrel, test.expectedIsSeed)
		}
	}
}
",./data/generated/docs_golang/lychrel_numbers/gpt_4o_2024_08_06_lychrel_numbers_test.go,CompileStatus.OK,0.0,55.1,,0.08,0.2,0.138,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: reverseInt', 'Severity': '', 'SourceLines': ['\t\treverseInt(v, result)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_lychrel_numbers_test.go', 'Offset': 0, 'Line': 25, 'Column': 3}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: reverseUint64', 'Severity': '', 'SourceLines': ['\t\tresult := reverseUint64(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_lychrel_numbers_test.go', 'Offset': 0, 'Line': 46, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: reverseString', 'Severity': '', 'SourceLines': ['\t\tresult := reverseString(test.input)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_lychrel_numbers_test.go', 'Offset': 0, 'Line': 67, 'Column': 13}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: Lychrel', 'Severity': '', 'SourceLines': ['\t\tisLychrel, isSeed := Lychrel(test.input, test.iter)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_lychrel_numbers_test.go', 'Offset': 0, 'Line': 90, 'Column': 24}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,75.0,False,[]
MAC Vendor Lookup,"Every connected device around the world comes with a unique Media Access Control address, or a   MAC address.

A common task a network administrator may come across is being able to identify a network device's manufacturer when given only a MAC address.



Task

Interface with one (or numerous) APIs that exist on the internet and retrieve the device manufacturer based on a supplied MAC address.

A MAC address that does not return a valid result should return the String ""N/A"".   An error related to the network connectivity or the API should return a null result.

Many implementations on this page use http://api.macvendors.com/ which, as of 19th September 2021, is throttling requests. After only 2 calls, the following response is returned for all subsequent requests. If you are planning to use the same provider or going to run the examples on this page, consider building in a delay between two calls.

{""errors"":{""detail"":""Too Many Requests"",""message"":""Please slow down your requests or upgrade your plan at https://macvendors.com""}}
",Go,"package main
 
import (
	""net/http""
	""fmt""
	""io/ioutil""
)
 
func macLookUp(mac string) (res string){
	resp, _ := http.Get(""http://api.macvendors.com/"" + mac)
	body, _ := ioutil.ReadAll(resp.Body)
	res = string(body)
	return
}
 
func main()  {
	fmt.Println(macLookUp(""FC-A1-3E""))
	fmt.Println(macLookUp(""FC:FB:FB:01:FA:21""))
	fmt.Println(macLookUp(""BC:5F:F4""))
}
 ",363,21,"package main

import (
	""net/http""
	""net/http/httptest""
	""testing""
	""io/ioutil""
	""strings""
)

// Mock server to simulate the API responses
func mockServer(response string, statusCode int) *httptest.Server {
	return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(statusCode)
		w.Write([]byte(response))
	}))
}

func TestMacLookUp(t *testing.T) {
	// Test case 1: Valid MAC address with a known manufacturer
	server := mockServer(""Apple, Inc."", http.StatusOK)
	defer server.Close()
	
	originalURL := ""http://api.macvendors.com/""
	http.DefaultClient.Transport = &http.Transport{
		Proxy: func(req *http.Request) (*http.Response, error) {
			req.URL.Scheme = ""http""
			req.URL.Host = strings.TrimPrefix(server.URL, ""http://"")
			return nil, nil
		},
	}
	
	result := macLookUp(""FC-A1-3E"")
	expected := ""Apple, Inc.""
	if result != expected {
		t.Errorf(""Expected %s, got %s"", expected, result)
	}

	// Test case 2: Valid MAC address with no known manufacturer
	server = mockServer("""", http.StatusOK)
	defer server.Close()
	
	result = macLookUp(""00:00:00:00:00:00"")
	expected = ""N/A""
	if result != expected {
		t.Errorf(""Expected %s, got %s"", expected, result)
	}

	// Test case 3: API returns an error (e.g., too many requests)
	server = mockServer(`{""errors"":{""detail"":""Too Many Requests"",""message"":""Please slow down your requests or upgrade your plan at https://macvendors.com""}}`, http.StatusTooManyRequests)
	defer server.Close()
	
	result = macLookUp(""FC:FB:FB:01:FA:21"")
	if result != """" {
		t.Errorf(""Expected null result, got %s"", result)
	}

	// Test case 4: Network error (simulate by using an invalid URL)
	http.DefaultClient.Transport = &http.Transport{
		Proxy: func(req *http.Request) (*http.Response, error) {
			return nil, fmt.Errorf(""network error"")
		},
	}
	
	result = macLookUp(""BC:5F:F4"")
	if result != """" {
		t.Errorf(""Expected null result, got %s"", result)
	}
}
",./data/generated/docs_golang/mac_vendor_lookup/gpt_4o_2024_08_06_mac_vendor_lookup_test.go,CompileStatus.SYNTAX_ERROR,,,,0.14,2.5,,8.0,"[{'FromLinter': 'typecheck', 'Text': 'cannot use (func(req *http.Request) (*http.Response, error) literal) (value of type func(req *http.Request) (*http.Response, error)) as func(*http.Request) (*url.URL, error) value in struct literal', 'Severity': '', 'SourceLines': ['\t\tProxy: func(req *http.Request) (*http.Response, error) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_mac_vendor_lookup_test.go', 'Offset': 0, 'Line': 26, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: macLookUp', 'Severity': '', 'SourceLines': ['\tresult := macLookUp(""FC-A1-3E"")'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_mac_vendor_lookup_test.go', 'Offset': 0, 'Line': 33, 'Column': 12}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: macLookUp', 'Severity': '', 'SourceLines': ['\tresult = macLookUp(""00:00:00:00:00:00"")'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_mac_vendor_lookup_test.go', 'Offset': 0, 'Line': 43, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: macLookUp', 'Severity': '', 'SourceLines': ['\tresult = macLookUp(""FC:FB:FB:01:FA:21"")'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_mac_vendor_lookup_test.go', 'Offset': 0, 'Line': 53, 'Column': 11}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'cannot use (func(req *http.Request) (*http.Response, error) literal) (value of type func(req *http.Request) (*http.Response, error)) as func(*http.Request) (*url.URL, error) value in struct literal', 'Severity': '', 'SourceLines': ['\t\tProxy: func(req *http.Request) (*http.Response, error) {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_mac_vendor_lookup_test.go', 'Offset': 0, 'Line': 60, 'Column': 10}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: fmt', 'Severity': '', 'SourceLines': ['\t\t\treturn nil, fmt.Errorf(""network error"")'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_mac_vendor_lookup_test.go', 'Offset': 0, 'Line': 61, 'Column': 16}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'declared and not used: originalURL', 'Severity': '', 'SourceLines': ['\toriginalURL := ""http://api.macvendors.com/""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_mac_vendor_lookup_test.go', 'Offset': 0, 'Line': 24, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': '""io/ioutil"" imported and not used', 'Severity': '', 'SourceLines': ['\t""io/ioutil""'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_mac_vendor_lookup_test.go', 'Offset': 0, 'Line': 7, 'Column': 2}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,,False,"[{'file': './gpt_4o_2024_08_06_mac_vendor_lookup_test.go', 'line': 26, 'column': 10, 'message': 'cannot use (func(req *http.Request) (*http.Response, error) literal) (value of type func(req *http.Request) (*http.Response, error)) as func(*http.Request) (*url.URL, error) value in struct literal'}]"
MD5/Implementation,"The purpose of this task to code and validate an implementation of the MD5 Message Digest Algorithm by coding the algorithm directly (not using a call to a built-in or external hashing library). For details of the algorithm refer to MD5 on Wikipedia or the MD5 definition in IETF RFC (1321).

 The implementation needs to implement the key functionality namely producing a correct message digest for an input string. It is not necessary to mimic all of the calling modes such as adding to a digest one block at a time over subsequent calls. 
 In addition to coding and verifying your implementation, note any challenges your language presented implementing the solution, implementation choices made, or limitations of your solution. 
 Solutions on this page should implement MD5 directly and NOT use built in (MD5) functions, call outs to operating system calls or library routines written in other languages as is common in the original MD5 task.
 The following are acceptable:
 An original implementation from the specification, reference implementation, or pseudo-code
 A translation of a correct implementation from another language
 A library routine in the same language; however, the source must be included here.


The solutions shown here will provide practical illustrations of bit manipulation, unsigned integers, working with little-endian data. Additionally, the task requires an attention to details such as boundary conditions since being out by even 1 bit will produce dramatically different results. Subtle implementation bugs can result in some hashes being correct while others are wrong. Not only is it critical to get the individual sub functions working correctly, even small errors in padding, endianness, or data layout will result in failure.

RFC 1321
                            hash code <== string 
   0xd41d8cd98f00b204e9800998ecf8427e <== """"  
   0x0cc175b9c0f1b6a831c399e269772661 <== ""a""
   0x900150983cd24fb0d6963f7d28e17f72 <== ""abc""
   0xf96b697d7cb7938d525a2f31aaf161d0 <== ""message digest""
   0xc3fcd3d76192e4007dfb496cca67e13b <== ""abcdefghijklmnopqrstuvwxyz""
   0xd174ab98d277d9f5a5611c2c9f419d9f <== ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789""
   0x57edf4a22be3c955ac49da2e2107b67a <== ""12345678901234567890123456789012345678901234567890123456789012345678901234567890""
In addition, intermediate outputs to aid in developing an implementation can be found here.

The MD5 Message-Digest Algorithm was developed by RSA Data Security, Inc. in 1991.



 Warning
Rosetta Code is not a place you should rely on for examples of code in critical roles, including security.
Also, note that MD5 has been broken and should not be used in applications requiring security. For these consider SHA2 or the upcoming SHA3.
",Go,"package main
 
import (
    ""fmt""
    ""math""
    ""bytes""
    ""encoding/binary""
)
 
type testCase struct {
    hashCode string
    string
}
 
var testCases = []testCase{
    {""d41d8cd98f00b204e9800998ecf8427e"", """"},
    {""0cc175b9c0f1b6a831c399e269772661"", ""a""},
    {""900150983cd24fb0d6963f7d28e17f72"", ""abc""},
    {""f96b697d7cb7938d525a2f31aaf161d0"", ""message digest""},
    {""c3fcd3d76192e4007dfb496cca67e13b"", ""abcdefghijklmnopqrstuvwxyz""},
    {""d174ab98d277d9f5a5611c2c9f419d9f"",
        ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789""},
    {""57edf4a22be3c955ac49da2e2107b67a"", ""12345678901234567890"" +
        ""123456789012345678901234567890123456789012345678901234567890""},
}
 
func main() {
    for _, tc := range testCases {
        fmt.Printf(""%s\n%x\n\n"", tc.hashCode, md5(tc.string))
    }
}
 
var shift = [...]uint{7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21}
var table [64]uint32
 
func init() {
    for i := range table {
        table[i] = uint32((1 << 32) * math.Abs(math.Sin(float64(i + 1))))
    }
}
 
func md5(s string) (r [16]byte) {
    padded := bytes.NewBuffer([]byte(s))
    padded.WriteByte(0x80)
    for padded.Len() % 64 != 56 {
        padded.WriteByte(0)
    }
    messageLenBits := uint64(len(s)) * 8
    binary.Write(padded, binary.LittleEndian, messageLenBits)
 
    var a, b, c, d uint32 = 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476
    var buffer [16]uint32
    for binary.Read(padded, binary.LittleEndian, buffer[:]) == nil { // read every 64 bytes
        a1, b1, c1, d1 := a, b, c, d
        for j := 0; j < 64; j++ {
            var f uint32
            bufferIndex := j
            round := j >> 4
            switch round {
            case 0:
                f = (b1 & c1) | (^b1 & d1)
            case 1:
                f = (b1 & d1) | (c1 & ^d1)
                bufferIndex = (bufferIndex*5 + 1) & 0x0F
            case 2:
                f = b1 ^ c1 ^ d1
                bufferIndex = (bufferIndex*3 + 5) & 0x0F
            case 3:
                f = c1 ^ (b1 | ^d1)
                bufferIndex = (bufferIndex * 7) & 0x0F
            }
            sa := shift[(round<<2)|(j&3)]
            a1 += f + buffer[bufferIndex] + table[j]
            a1, d1, c1, b1 = d1, c1, b1, a1<<sa|a1>>(32-sa)+b1
        }
        a, b, c, d = a+a1, b+b1, c+c1, d+d1
    }
 
    binary.Write(bytes.NewBuffer(r[:0]), binary.LittleEndian, []uint32{a, b, c, d})
    return
}",2434,81,"package main

import (
	""encoding/hex""
	""testing""
)

func TestMD5(t *testing.T) {
	for _, tc := range testCases {
		t.Run(tc.string, func(t *testing.T) {
			result := md5(tc.string)
			resultHex := hex.EncodeToString(result[:])
			if resultHex != tc.hashCode {
				t.Errorf(""MD5(%q) = %s; want %s"", tc.string, resultHex, tc.hashCode)
			}
		})
	}
}

func BenchmarkMD5(b *testing.B) {
	for i := 0; i < b.N; i++ {
		for _, tc := range testCases {
			md5(tc.string)
		}
	}
}
",./data/generated/docs_golang/md5_implementation/gpt_4o_2024_08_06_md5_implementation_test.go,CompileStatus.OK,0.0,93.8,,0.08,0.08,0.174,4.0,"[{'FromLinter': 'typecheck', 'Text': 'undefined: testCases', 'Severity': '', 'SourceLines': ['\tfor _, tc := range testCases {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_md5_implementation_test.go', 'Offset': 0, 'Line': 9, 'Column': 21}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: md5', 'Severity': '', 'SourceLines': ['\t\t\tresult := md5(tc.string)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_md5_implementation_test.go', 'Offset': 0, 'Line': 11, 'Column': 14}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: testCases', 'Severity': '', 'SourceLines': ['\t\tfor _, tc := range testCases {'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_md5_implementation_test.go', 'Offset': 0, 'Line': 22, 'Column': 22}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}, {'FromLinter': 'typecheck', 'Text': 'undefined: md5', 'Severity': '', 'SourceLines': ['\t\t\tmd5(tc.string)'], 'Replacement': None, 'Pos': {'Filename': 'gpt_4o_2024_08_06_md5_implementation_test.go', 'Offset': 0, 'Line': 23, 'Column': 4}, 'ExpectNoLint': False, 'ExpectedNoLintLinter': ''}]",False,False,100.0,False,[]
